{"pr_number": 321, "pr_title": "CartesianProductTestExtension from JUnit examples", "pr_createdAt": "2020-08-14T16:16:56Z", "pr_url": "https://github.com/junit-pioneer/junit-pioneer/pull/321", "timeline": [{"oid": "bbde484c4d17ac965fb256d801f8c5bc3f7f7078", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/bbde484c4d17ac965fb256d801f8c5bc3f7f7078", "message": "WIP\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-07-31T07:33:09Z", "type": "commit"}, {"oid": "0df73816b69ae2e9eb8d47794c3fa93a5d23b4b2", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/0df73816b69ae2e9eb8d47794c3fa93a5d23b4b2", "message": "Initial commit - copied sources from JUnit 5 examples.\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-08-14T12:46:38Z", "type": "commit"}, {"oid": "e8ceb12666aefa67231e7bddac437309b5623f98", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/e8ceb12666aefa67231e7bddac437309b5623f98", "message": "Some more tests\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-08-14T16:14:44Z", "type": "commit"}, {"oid": "bb0f012c79607aee5ab0bb3748caad98a9915b1e", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/bb0f012c79607aee5ab0bb3748caad98a9915b1e", "message": "spotless\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-08-14T16:15:40Z", "type": "commit"}, {"oid": "edbf0fd89c684880ac2bc92c19933653bbe8d994", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/edbf0fd89c684880ac2bc92c19933653bbe8d994", "message": "WIP config tests\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-08-14T16:56:56Z", "type": "commit"}, {"oid": "dd8d33aa312c85d71f8594139980ca124bccdeea", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/dd8d33aa312c85d71f8594139980ca124bccdeea", "message": "Merge branch 'master' into issue/68-cartesian-product-extension", "committedDate": "2020-08-14T16:58:11Z", "type": "commit"}, {"oid": "8c04e10b6fd059c826369639bc081461dff9f48e", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/8c04e10b6fd059c826369639bc081461dff9f48e", "message": "More tests and an ugly new utility method\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-08-14T20:26:55Z", "type": "commit"}, {"oid": "c5f0b28f6d1d8368bb7dce08cf1d7ed1b8163c85", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/c5f0b28f6d1d8368bb7dce08cf1d7ed1b8163c85", "message": "Added docs and more tests\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-08-14T22:52:24Z", "type": "commit"}, {"oid": "c18b6c2a6ced73af067de99cc0945ce78e499bb8", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/c18b6c2a6ced73af067de99cc0945ce78e499bb8", "message": "Added some javadoc (also spotless)\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-08-14T23:14:30Z", "type": "commit"}, {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "message": "added `factory()` for specifying static factory name, refactored documentation\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-08-15T13:30:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDExNw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471090117", "bodyText": "There's no example for this factory() annotation parameter. It is mentions some times in the docs but nowhere to see.", "author": "Bukama", "createdAt": "2020-08-16T09:39:01Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,122 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+[#_static-factory-example]\n+```java", "originalCommit": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5MTU0NA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471991544", "bodyText": "Um, whoops? Thank you, updated. \ud83d\ude05", "author": "Michael1993", "createdAt": "2020-08-18T08:02:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDM1NQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471090355", "bodyText": "Which method is meant by \"this\"? The method which provides the values or the test method? A sub headline would help to catch up the reader after this (long but relevant) example and get him back on track. I had to read it several times until I know what the section is about.", "author": "Bukama", "createdAt": "2020-08-16T09:41:09Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,122 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+There are a couple conditions this method has to fulfill to qualify:", "originalCommit": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NjY1OQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471986659", "bodyText": "Thank you, I rewrote this section entirely.", "author": "Michael1993", "createdAt": "2020-08-18T07:54:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDY5Nw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471090697", "bodyText": "I would introduce the set far before in the section when you write about proving values. Show there that you can provide Strings or a CartesianProductTest.Sets. Or even more better: Design the extension that they always get such a CartesianProductTest.Sets and the String this is just a reduced wrapper for small and easy test cases.\nAs of now you throw in a core feature of the extension in a subsentence of a foot note.", "author": "Bukama", "createdAt": "2020-08-16T09:45:04Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,122 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+There are a couple conditions this method has to fulfill to qualify:\n+\n+- must have the same name as the test method or its name must be specified via `factory()`\n+- must be `static`\n+- must have **no** parameters\n+- must return `CartesianProductTest.Sets` ^1^\n+- must register values for every parameter exactly once ^2^\n+\n+1: This is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, above>>).", "originalCommit": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ0MTI4OA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471441288", "bodyText": "You can't provide CartesianProductTest.Sets as an annotation parameter, so I'm not sure what you meant here.", "author": "Michael1993", "createdAt": "2020-08-17T12:22:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NzkwNw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471987907", "bodyText": "I agree that CartesianProductTest.Setsshould be introduced earlier in the docs, so I moved it up. Do you think it needs more explanation than how it currently looks?", "author": "Michael1993", "createdAt": "2020-08-18T07:56:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU2MTEzMA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r493561130", "bodyText": "@Bukama ping. I still would like to hear your thoughts on this, please. \ud83d\ude07", "author": "Michael1993", "createdAt": "2020-09-23T13:01:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY0MDIwMg==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r493640202", "bodyText": "If not I would have mentioned in the review :)", "author": "Bukama", "createdAt": "2020-09-23T14:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc0NzcwNw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r493747707", "bodyText": "Thank you!", "author": "Michael1993", "createdAt": "2020-09-23T16:58:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDgzNA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471090834", "bodyText": "Would keep them together and not put a foot note into a foot note when booth are about invalid parameters. Provide an own subsection for misconfiguration and link to this subsection in the list above", "author": "Bukama", "createdAt": "2020-08-16T09:46:26Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,122 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+There are a couple conditions this method has to fulfill to qualify:\n+\n+- must have the same name as the test method or its name must be specified via `factory()`\n+- must be `static`\n+- must have **no** parameters\n+- must return `CartesianProductTest.Sets` ^1^\n+- must register values for every parameter exactly once ^2^\n+\n+1: This is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, above>>).\n+\n+2: If you register too few, too many, or conflicting ^3^ parameters, you will get an `org.junit.jupiter.api.extension.ParameterResolutionException`.\n+\n+3: For example, if your test method has a `TestInfo` or `TestReporter` (or any other parameter that is automatically injected by JUnit) and you register too much sets in your factory method:", "originalCommit": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5MTczNA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471991734", "bodyText": "Good idea, did just that.", "author": "Michael1993", "createdAt": "2020-08-18T08:02:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDk3Mg==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471090972", "bodyText": "A link is formatted as [link text](url) isnt it?", "author": "Bukama", "createdAt": "2020-08-16T09:47:45Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,122 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+There are a couple conditions this method has to fulfill to qualify:\n+\n+- must have the same name as the test method or its name must be specified via `factory()`\n+- must be `static`\n+- must have **no** parameters\n+- must return `CartesianProductTest.Sets` ^1^\n+- must register values for every parameter exactly once ^2^\n+\n+1: This is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, above>>).\n+\n+2: If you register too few, too many, or conflicting ^3^ parameters, you will get an `org.junit.jupiter.api.extension.ParameterResolutionException`.\n+\n+3: For example, if your test method has a `TestInfo` or `TestReporter` (or any other parameter that is automatically injected by JUnit) and you register too much sets in your factory method:\n+```java\n+@CartesianProductTest\n+void confusing(String a, TestInfo info) {\n+    // completely valid test\n+}\n+\n+static CartesianProductTest.Sets confusing() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"A\", \"B\", \"C\")\n+        .add(1, 2, 3);\n+}\n+```\n+\n+== Combining `@CartesianProductTest` with `@Test`\n+\n+If `@CartesianProductTest` is combined with `@Test` or `TestTemplate`-based mechanisms (like `@RepeatedTest` or `@ParameterizedTest`), the test engine will execute it according to each annotation (i.e. more than once).\n+This is most likely unwanted and will probably lead to the following exception/failure message:\n+\n+> org.junit.jupiter.api.extension.ParameterResolutionException:\n+> No ParameterResolver registered for parameter [...]\n+\n+This is because `@Test` does not know what to do with the parameter(s) of the `@CartesianProductTest`.\n+\n+== Thread-Safety\n+\n+This extension is safe to use during https://junit.org/junit5/docs/current/user-guide/#writing-tests-parallel-execution[parallel test execution].", "originalCommit": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ1NzY2NQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471457665", "bodyText": "This is the proper way to format links in Asciidoc.", "author": "Michael1993", "createdAt": "2020-08-17T12:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTEzNg==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471091136", "bodyText": "As mentioned above, when changing this to CartesianProductTest.Setswould be more type save, wouldn't it?", "author": "Bukama", "createdAt": "2020-08-16T09:49:37Z", "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductResolver.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.ParameterContext;\n+import org.junit.jupiter.api.extension.ParameterResolver;\n+\n+public class CartesianProductResolver implements ParameterResolver {\n+\n+\tprivate final List<?> parameters;", "originalCommit": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NDY3NA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471984674", "bodyText": "I'm not sure, since CartesianProductTest.Sets is just a wrapper around a List<List<?>>. Or maybe I misunderstood what you meant... again. \ud83d\ude05", "author": "Michael1993", "createdAt": "2020-08-18T07:50:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTM5Mw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471091393", "bodyText": "I don't like the name factory, because it doesn't tell what is generated. Rename to TestSetFactoryMethod or something like this. Also Javadoc is missing.", "author": "Bukama", "createdAt": "2020-08-16T09:52:03Z", "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.TestTemplate;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+/**\n+ * {@code @CartesianProductTest} is a JUnit Jupiter extension that marks\n+ * a test to be executed with all possible input combinations.\n+ *\n+ * <p>Methods annotated with this annotation <b>MUST NOT</b> be annotated with {@code Test},\n+ * because it will throw an exception.\n+ * </p>\n+ *\n+ * <p>Methods annotated with this annotation are different from {@code ParameterizedTest}s because\n+ * they can not have {@code ArgumentsSource}s - those are completely disregarded. Instead a\n+ * String array must be provided (for methods with only String parameters) or a static factory method\n+ * with the same name as the test method must exist.\n+ * </p>\n+ *\n+ * @since ???\n+ */\n+@TestTemplate\n+@ExtendWith(CartesianProductTestExtension.class)\n+@Target(ElementType.METHOD)\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface CartesianProductTest {\n+\n+\t/**\n+\t * Specifies {@code String} values for all inputs simultaneously.\n+\t */\n+\tString[] value() default {};\n+\n+\tString factory() default \"\";", "originalCommit": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTUzOQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471091539", "bodyText": "Why as an inner class and not as a public Tuple class or something like this? Could be a way to provide a dynamic class for test data tuples.", "author": "Bukama", "createdAt": "2020-08-16T09:53:43Z", "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.TestTemplate;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+/**\n+ * {@code @CartesianProductTest} is a JUnit Jupiter extension that marks\n+ * a test to be executed with all possible input combinations.\n+ *\n+ * <p>Methods annotated with this annotation <b>MUST NOT</b> be annotated with {@code Test},\n+ * because it will throw an exception.\n+ * </p>\n+ *\n+ * <p>Methods annotated with this annotation are different from {@code ParameterizedTest}s because\n+ * they can not have {@code ArgumentsSource}s - those are completely disregarded. Instead a\n+ * String array must be provided (for methods with only String parameters) or a static factory method\n+ * with the same name as the test method must exist.\n+ * </p>\n+ *\n+ * @since ???\n+ */\n+@TestTemplate\n+@ExtendWith(CartesianProductTestExtension.class)\n+@Target(ElementType.METHOD)\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface CartesianProductTest {\n+\n+\t/**\n+\t * Specifies {@code String} values for all inputs simultaneously.\n+\t */\n+\tString[] value() default {};\n+\n+\tString factory() default \"\";\n+\n+\tclass Sets {", "originalCommit": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ1OTM2MQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471459361", "bodyText": "I don't know what you mean. Sets is an interface member - automatically public and static.", "author": "Michael1993", "createdAt": "2020-08-17T12:56:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTUzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2NjU2MA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474066560", "bodyText": "I see the Sets thing as a dataholder class and in itself has nothing to do with the Cartesian production interface. I personally don't like to squeeze a general class/interface into a specific one.", "author": "Bukama", "createdAt": "2020-08-20T15:22:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTYwNA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471091604", "bodyText": "Why not using our Pioneer annotation methods? (Whole class)", "author": "Bukama", "createdAt": "2020-08-16T09:54:28Z", "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;\n+import static org.junit.platform.commons.support.ReflectionSupport.invokeMethod;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.TestTemplateInvocationContext;\n+import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider;\n+\n+class CartesianProductTestExtension implements TestTemplateInvocationContextProvider {\n+\n+\t@Override\n+\tpublic boolean supportsTestTemplate(ExtensionContext context) {\n+\t\treturn findAnnotation(context.getTestMethod(), CartesianProductTest.class).isPresent();", "originalCommit": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5MjA2Mw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471992063", "bodyText": "Bit of an overkill, don't you think? We are always going to depend on JUnit (obviously) so the way JUnit finds annotations on a test method will always be good enough (was my thinking).", "author": "Michael1993", "createdAt": "2020-08-18T08:03:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTYwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2NzM2Mg==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474067362", "bodyText": "Then you argue to throw Pioneer Annotations out, because we can use the JUnit things. The idea was Pioneer Annotation was to encapsulate the JUnit thing with our own, improved methods. But I'll leave it to you / the others which way we use.\nSame for TestKit or PioneerAssertions \ud83e\udd37\u200d\u2642\ufe0f", "author": "Bukama", "createdAt": "2020-08-20T15:24:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTYwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc0Nzg2MA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474747860", "bodyText": "In this specific case, we don't need to improve the method used by JUnit, so encapsulating it is unnecessary.", "author": "Michael1993", "createdAt": "2020-08-21T14:51:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTYwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3MDU4MA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r496970580", "bodyText": "The advantage of our annotation methods is that they make it easy to find meta annotations that are _indirectly present: (if a supertype of the element is annotated), meta-present (if an annotation that is present on the element is itself annotated), or _enclosing-present (if an enclosing type [think opposite of @Nested] is annotated). As I see it, only meta-present is relevant here, but that should indeed be allowed. Not sure if AnnotationSupport.findAnnotation does that.", "author": "nipafx", "createdAt": "2020-09-29T19:03:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTk0Mw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471091943", "bodyText": "Start with an upper letter after the parameter name", "author": "Bukama", "createdAt": "2020-08-16T09:57:25Z", "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -44,4 +48,32 @@ private PioneerUtils() {\n \t\t}\n \t}\n \n+\t/**\n+\t * Find the first {@link Method} of the supplied class or interface that\n+\t * meets the specified criteria, beginning with the specified class or\n+\t * interface and traversing its enclosing classes until such a method is\n+\t * found or the top level class is reached.\n+\t *\n+\t * <p>The algorithm does not search for methods in {@link java.lang.Object}.\n+\t *\n+\t * @param clazz the class or interface in which to find the method; never {@code null}\n+\t * @param methodName the name of the method to find; never {@code null} or empty\n+\t * @param parameterTypes the types of parameters accepted by the method, if any;", "originalCommit": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5Mjg2Ng==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471092866", "bodyText": "According never null: You can't ensure that the user does not pass null. The underlying methods may check this and throw an exception. So remove this in the parameter description and a @throws section where you describe the exception which is thrown when one of the parameters is null.", "author": "Bukama", "createdAt": "2020-08-16T10:07:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTk0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ2MjIzMA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471462230", "bodyText": "This is copy-pasted from JUnit 5s ReflectionSupport, it means that the method will throw an exception if null is supplied as a parameter.", "author": "Michael1993", "createdAt": "2020-08-17T13:01:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTk0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ2NDYwOQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471464609", "bodyText": "Your first suggestion is not in-line with other classes in Pioneer. For example, EnvironmentVariableUtils.", "author": "Michael1993", "createdAt": "2020-08-17T13:05:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTk0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5NjA3OQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471996079", "bodyText": "I did a bit of reading, and it seems like adding @throws for RuntimeExceptions is not recommended?", "author": "Michael1993", "createdAt": "2020-08-18T08:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MjQ1Mg==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471092452", "bodyText": "If I understand this right the declaration of the CartesianProductTest.Sets must be in the same test class or a parent class. Why force the users to use such test data structure instead allowing them to define the test data in a complete different class?", "author": "Bukama", "createdAt": "2020-08-16T10:03:09Z", "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;\n+import static org.junit.platform.commons.support.ReflectionSupport.invokeMethod;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.TestTemplateInvocationContext;\n+import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider;\n+\n+class CartesianProductTestExtension implements TestTemplateInvocationContextProvider {\n+\n+\t@Override\n+\tpublic boolean supportsTestTemplate(ExtensionContext context) {\n+\t\treturn findAnnotation(context.getTestMethod(), CartesianProductTest.class).isPresent();\n+\t}\n+\n+\t@Override\n+\tpublic Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContexts(ExtensionContext context) {\n+\t\tList<List<?>> sets = computeSets(context.getRequiredTestMethod());\n+\t\treturn cartesianProduct(sets).stream().map(CartesianProductTestInvocationContext::new);\n+\t}\n+\n+\tprivate List<List<?>> computeSets(Method testMethod) {\n+\t\tCartesianProductTest annotation = findAnnotation(testMethod, CartesianProductTest.class)\n+\t\t\t\t.orElseThrow(() -> new AssertionError(\"@CartesianProductTest not found\"));\n+\t\t// Compute A \u2a2f A \u2a2f ... \u2a2f A from single source \"set\"\n+\t\tif (annotation.value().length > 0) {\n+\t\t\tList<String> strings = Arrays.asList(annotation.value());\n+\t\t\tList<List<?>> sets = new ArrayList<>();\n+\t\t\tfor (int i = 0; i < testMethod.getParameterTypes().length; i++) {\n+\t\t\t\tsets.add(strings);\n+\t\t\t}\n+\t\t\treturn sets;\n+\t\t}\n+\t\t// No single entry supplied? Try the sets factory method instead...\n+\t\tString factoryMethod = annotation.factory().isEmpty() ? testMethod.getName() : annotation.factory();\n+\n+\t\treturn invokeSetsFactory(testMethod, factoryMethod).getSets();\n+\t}\n+\n+\tprivate CartesianProductTest.Sets invokeSetsFactory(Method testMethod, String factoryMethodName) {\n+\t\tClass<?> declaringClass = testMethod.getDeclaringClass();\n+\t\tMethod factory = PioneerUtils\n+\t\t\t\t.findMethodCurrentOrEnclosing(declaringClass, factoryMethodName)\n+\t\t\t\t.orElseThrow(() -> new AssertionError(\"Method `CartesianProductTest.Sets \" + factoryMethodName\n+\t\t\t\t\t\t+ \"()` not found in \" + declaringClass + \"or any enclosing class\"));", "originalCommit": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzE2MQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471093161", "bodyText": "Linebreaks for each .add like in nFold.", "author": "Bukama", "createdAt": "2020-08-16T10:10:12Z", "path": "src/test/java/org/junitpioneer/jupiter/CartesianProductTestExtensionTests.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.junitpioneer.testkit.assertion.PioneerAssert.assertThat;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.junitpioneer.testkit.ExecutionResults;\n+import org.junitpioneer.testkit.PioneerTestKit;\n+\n+public class CartesianProductTestExtensionTests {\n+\n+\t@Nested\n+\tclass StandardBehaviouralTests {\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\" })\n+\t\t@DisplayName(\"Does nothing if there are no parameters\")\n+\t\tvoid empty() {\n+\t\t}\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\", \"2\" })\n+\t\t@DisplayName(\"Runs for each parameter once for single parameter\")\n+\t\tvoid singleParameter(String param) {\n+\t\t\tint value = Integer.parseInt(param);\n+\t\t\tAssertions.assertThat(value).isBetween(0, 2);\n+\t\t}\n+\n+\t\t@CartesianProductTest({ \"0\", \"1\" })\n+\t\tvoid threeBits(String a, String b, String c) {\n+\t\t\tint value = Integer.parseUnsignedInt(a + b + c, 2);\n+\t\t\tAssertions.assertThat(value).isBetween(0b000, 0b111);\n+\t\t}\n+\n+\t\t@CartesianProductTest\n+\t\t@DisplayName(\"S \u2a2f T \u2a2f U\")\n+\t\tvoid nFold(String string, Class<?> type, TimeUnit unit, TestInfo info) {\n+\t\t\tAssertions.assertThat(string).endsWith(\"a\");\n+\t\t\tAssertions.assertThat(type).isInterface();\n+\t\t\tAssertions.assertThat(unit.name()).endsWith(\"S\");\n+\t\t\tAssertions.assertThat(info.getTags()).isEmpty();\n+\t\t}\n+\n+\t\t@CartesianProductTest(factory = \"supplyValues\")\n+\t\t@DisplayName(\"Can have an explicit factory method over the implicit one\")\n+\t\tvoid explicitFactory(String string, TimeUnit unit) {\n+\t\t\tAssertions.assertThat(string).isIn(\"War\", \"Peace\");\n+\t\t\tAssertions.assertThat(unit.name()).endsWith(\"S\");\n+\t\t}\n+\n+\t}\n+\n+\tstatic CartesianProductTest.Sets nFold() {\n+\t\treturn new CartesianProductTest.Sets()\n+\t\t\t\t.add(\"Alpha\", \"Omega\")\n+\t\t\t\t.add(Runnable.class, Comparable.class, TestInfo.class)\n+\t\t\t\t.add(TimeUnit.DAYS, TimeUnit.HOURS);\n+\t}\n+\n+\tstatic CartesianProductTest.Sets supplyValues() {\n+\t\treturn new CartesianProductTest.Sets().add(\"War\", \"Peace\").add(TimeUnit.SECONDS, TimeUnit.DAYS);", "originalCommit": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ3ODI2MQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471478261", "bodyText": "Spotless. \ud83e\udd37\nWould you prefer I did @formatter:off?", "author": "Michael1993", "createdAt": "2020-08-17T13:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzE2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY0OTYxNQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471649615", "bodyText": "To be honest: Yes, Think it's more readable then and consistent like in nFold", "author": "Bukama", "createdAt": "2020-08-17T17:31:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzE2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4MzY5Mw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471983693", "bodyText": "Alright. Fair enough.", "author": "Michael1993", "createdAt": "2020-08-18T07:49:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzI0MQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471093241", "bodyText": "What does nFold mean?", "author": "Bukama", "createdAt": "2020-08-16T10:11:06Z", "path": "src/test/java/org/junitpioneer/jupiter/CartesianProductTestExtensionTests.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.junitpioneer.testkit.assertion.PioneerAssert.assertThat;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.junitpioneer.testkit.ExecutionResults;\n+import org.junitpioneer.testkit.PioneerTestKit;\n+\n+public class CartesianProductTestExtensionTests {\n+\n+\t@Nested\n+\tclass StandardBehaviouralTests {\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\" })\n+\t\t@DisplayName(\"Does nothing if there are no parameters\")\n+\t\tvoid empty() {\n+\t\t}\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\", \"2\" })\n+\t\t@DisplayName(\"Runs for each parameter once for single parameter\")\n+\t\tvoid singleParameter(String param) {\n+\t\t\tint value = Integer.parseInt(param);\n+\t\t\tAssertions.assertThat(value).isBetween(0, 2);\n+\t\t}\n+\n+\t\t@CartesianProductTest({ \"0\", \"1\" })\n+\t\tvoid threeBits(String a, String b, String c) {\n+\t\t\tint value = Integer.parseUnsignedInt(a + b + c, 2);\n+\t\t\tAssertions.assertThat(value).isBetween(0b000, 0b111);\n+\t\t}\n+\n+\t\t@CartesianProductTest\n+\t\t@DisplayName(\"S \u2a2f T \u2a2f U\")\n+\t\tvoid nFold(String string, Class<?> type, TimeUnit unit, TestInfo info) {", "originalCommit": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNDk5Nw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r472004997", "bodyText": "No clue, this is copy-pasted from JUnit examples.", "author": "Michael1993", "createdAt": "2020-08-18T08:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAxMDkwMw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r472010903", "bodyText": "What would be a good alternative?", "author": "Michael1993", "createdAt": "2020-08-18T08:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA1NjA0MQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474056041", "bodyText": "As I don't understand it it can't give a good alternative.", "author": "Bukama", "createdAt": "2020-08-20T15:07:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc0OTgxOA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474749818", "bodyText": "It looks like it'd be a good idea to start the documentation with a bit of copy-paste (or at least link) from the Wikipedia article on Cartesian product, to avoid confusion like this. I really should've looked that up (at least) before working on this. \ud83e\udd26", "author": "Michael1993", "createdAt": "2020-08-21T14:54:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU2MjMwOA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r493562308", "bodyText": "@Bukama If you think the new introduction properly explains why this example is named nFold I will close this discussion.", "author": "Michael1993", "createdAt": "2020-09-23T13:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY0MTQ0Nw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r493641447", "bodyText": "Didn't thought this \"discussion\" is still relevant. The explanation of nFold is in the into and so I'm totally fine :)", "author": "Bukama", "createdAt": "2020-09-23T14:31:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzM0OQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471093349", "bodyText": "You could put the Test fails, when into a @DisplayName of the @Nested class.", "author": "Bukama", "createdAt": "2020-08-16T10:12:17Z", "path": "src/test/java/org/junitpioneer/jupiter/CartesianProductTestExtensionTests.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.junitpioneer.testkit.assertion.PioneerAssert.assertThat;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.junitpioneer.testkit.ExecutionResults;\n+import org.junitpioneer.testkit.PioneerTestKit;\n+\n+public class CartesianProductTestExtensionTests {\n+\n+\t@Nested\n+\tclass StandardBehaviouralTests {\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\" })\n+\t\t@DisplayName(\"Does nothing if there are no parameters\")\n+\t\tvoid empty() {\n+\t\t}\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\", \"2\" })\n+\t\t@DisplayName(\"Runs for each parameter once for single parameter\")\n+\t\tvoid singleParameter(String param) {\n+\t\t\tint value = Integer.parseInt(param);\n+\t\t\tAssertions.assertThat(value).isBetween(0, 2);\n+\t\t}\n+\n+\t\t@CartesianProductTest({ \"0\", \"1\" })\n+\t\tvoid threeBits(String a, String b, String c) {\n+\t\t\tint value = Integer.parseUnsignedInt(a + b + c, 2);\n+\t\t\tAssertions.assertThat(value).isBetween(0b000, 0b111);\n+\t\t}\n+\n+\t\t@CartesianProductTest\n+\t\t@DisplayName(\"S \u2a2f T \u2a2f U\")\n+\t\tvoid nFold(String string, Class<?> type, TimeUnit unit, TestInfo info) {\n+\t\t\tAssertions.assertThat(string).endsWith(\"a\");\n+\t\t\tAssertions.assertThat(type).isInterface();\n+\t\t\tAssertions.assertThat(unit.name()).endsWith(\"S\");\n+\t\t\tAssertions.assertThat(info.getTags()).isEmpty();\n+\t\t}\n+\n+\t\t@CartesianProductTest(factory = \"supplyValues\")\n+\t\t@DisplayName(\"Can have an explicit factory method over the implicit one\")\n+\t\tvoid explicitFactory(String string, TimeUnit unit) {\n+\t\t\tAssertions.assertThat(string).isIn(\"War\", \"Peace\");\n+\t\t\tAssertions.assertThat(unit.name()).endsWith(\"S\");\n+\t\t}\n+\n+\t}\n+\n+\tstatic CartesianProductTest.Sets nFold() {\n+\t\treturn new CartesianProductTest.Sets()\n+\t\t\t\t.add(\"Alpha\", \"Omega\")\n+\t\t\t\t.add(Runnable.class, Comparable.class, TestInfo.class)\n+\t\t\t\t.add(TimeUnit.DAYS, TimeUnit.HOURS);\n+\t}\n+\n+\tstatic CartesianProductTest.Sets supplyValues() {\n+\t\treturn new CartesianProductTest.Sets().add(\"War\", \"Peace\").add(TimeUnit.SECONDS, TimeUnit.DAYS);\n+\t}\n+\n+\t@Nested\n+\tclass BadConfigurationTests {\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails when there is no factory method\")", "originalCommit": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNzc0OA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r472007748", "bodyText": "Good idea, thank you.", "author": "Michael1993", "createdAt": "2020-08-18T08:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzU0MA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471093540", "bodyText": "Can a message be provided (and asserted) in such case?", "author": "Bukama", "createdAt": "2020-08-16T10:14:41Z", "path": "src/test/java/org/junitpioneer/jupiter/CartesianProductTestExtensionTests.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.junitpioneer.testkit.assertion.PioneerAssert.assertThat;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.junitpioneer.testkit.ExecutionResults;\n+import org.junitpioneer.testkit.PioneerTestKit;\n+\n+public class CartesianProductTestExtensionTests {\n+\n+\t@Nested\n+\tclass StandardBehaviouralTests {\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\" })\n+\t\t@DisplayName(\"Does nothing if there are no parameters\")\n+\t\tvoid empty() {\n+\t\t}\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\", \"2\" })\n+\t\t@DisplayName(\"Runs for each parameter once for single parameter\")\n+\t\tvoid singleParameter(String param) {\n+\t\t\tint value = Integer.parseInt(param);\n+\t\t\tAssertions.assertThat(value).isBetween(0, 2);\n+\t\t}\n+\n+\t\t@CartesianProductTest({ \"0\", \"1\" })\n+\t\tvoid threeBits(String a, String b, String c) {\n+\t\t\tint value = Integer.parseUnsignedInt(a + b + c, 2);\n+\t\t\tAssertions.assertThat(value).isBetween(0b000, 0b111);\n+\t\t}\n+\n+\t\t@CartesianProductTest\n+\t\t@DisplayName(\"S \u2a2f T \u2a2f U\")\n+\t\tvoid nFold(String string, Class<?> type, TimeUnit unit, TestInfo info) {\n+\t\t\tAssertions.assertThat(string).endsWith(\"a\");\n+\t\t\tAssertions.assertThat(type).isInterface();\n+\t\t\tAssertions.assertThat(unit.name()).endsWith(\"S\");\n+\t\t\tAssertions.assertThat(info.getTags()).isEmpty();\n+\t\t}\n+\n+\t\t@CartesianProductTest(factory = \"supplyValues\")\n+\t\t@DisplayName(\"Can have an explicit factory method over the implicit one\")\n+\t\tvoid explicitFactory(String string, TimeUnit unit) {\n+\t\t\tAssertions.assertThat(string).isIn(\"War\", \"Peace\");\n+\t\t\tAssertions.assertThat(unit.name()).endsWith(\"S\");\n+\t\t}\n+\n+\t}\n+\n+\tstatic CartesianProductTest.Sets nFold() {\n+\t\treturn new CartesianProductTest.Sets()\n+\t\t\t\t.add(\"Alpha\", \"Omega\")\n+\t\t\t\t.add(Runnable.class, Comparable.class, TestInfo.class)\n+\t\t\t\t.add(TimeUnit.DAYS, TimeUnit.HOURS);\n+\t}\n+\n+\tstatic CartesianProductTest.Sets supplyValues() {\n+\t\treturn new CartesianProductTest.Sets().add(\"War\", \"Peace\").add(TimeUnit.SECONDS, TimeUnit.DAYS);\n+\t}\n+\n+\t@Nested\n+\tclass BadConfigurationTests {\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails when there is no factory method\")\n+\t\tvoid throwsForMissingFactoryMethod() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigurationTest.class, \"noFactory\", int.class);\n+\n+\t\t\tassertThat(results)\n+\t\t\t\t\t.hasSingleFailedContainer()\n+\t\t\t\t\t.withExceptionInstanceOf(AssertionError.class)\n+\t\t\t\t\t.hasMessageContaining(\"not found\");\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails when the factory is not static\")\n+\t\tvoid throwsForNonStaticFactoryMethod() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigurationTest.class, \"nonStaticFactory\", int.class);\n+\n+\t\t\tassertThat(results)\n+\t\t\t\t\t.hasSingleFailedContainer()\n+\t\t\t\t\t.withExceptionInstanceOf(AssertionError.class)\n+\t\t\t\t\t.hasMessageContaining(\"must be static\");\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails when the factory does not return Sets\")\n+\t\tvoid throwsForWrongReturnValueFactoryMethod() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigurationTest.class, \"wrongReturnFactory\", int.class);\n+\n+\t\t\tassertThat(results)\n+\t\t\t\t\t.hasSingleFailedContainer()\n+\t\t\t\t\t.withExceptionInstanceOf(AssertionError.class)\n+\t\t\t\t\t.hasMessageContaining(\"must return\");\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails if the factory does not produce enough parameters\")\n+\t\tvoid throwsForTooFewFactoryMethodParameters() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigurationTest.class, \"incompleteFactory\", int.class,\n+\t\t\t\t\t\tString.class, TimeUnit.class);\n+\n+\t\t\tassertThat(results).hasNumberOfDynamicallyRegisteredTests(3).hasNumberOfFailedTests(3);", "originalCommit": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ3ODc2Mw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471478763", "bodyText": "Even though all tests fail, the container is considered successful. No clue why.", "author": "Michael1993", "createdAt": "2020-08-17T13:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzU0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwODM4Ng==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r472008386", "bodyText": "There should be a discussion about extending Pioneer assertions as need for it arises, (such as in this case).", "author": "Michael1993", "createdAt": "2020-08-18T08:30:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzYzMg==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471093632", "bodyText": "Why is it possible to generate a message when there a too much parameters, but not too less (see test above)?", "author": "Bukama", "createdAt": "2020-08-16T10:15:15Z", "path": "src/test/java/org/junitpioneer/jupiter/CartesianProductTestExtensionTests.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.junitpioneer.testkit.assertion.PioneerAssert.assertThat;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.junitpioneer.testkit.ExecutionResults;\n+import org.junitpioneer.testkit.PioneerTestKit;\n+\n+public class CartesianProductTestExtensionTests {\n+\n+\t@Nested\n+\tclass StandardBehaviouralTests {\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\" })\n+\t\t@DisplayName(\"Does nothing if there are no parameters\")\n+\t\tvoid empty() {\n+\t\t}\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\", \"2\" })\n+\t\t@DisplayName(\"Runs for each parameter once for single parameter\")\n+\t\tvoid singleParameter(String param) {\n+\t\t\tint value = Integer.parseInt(param);\n+\t\t\tAssertions.assertThat(value).isBetween(0, 2);\n+\t\t}\n+\n+\t\t@CartesianProductTest({ \"0\", \"1\" })\n+\t\tvoid threeBits(String a, String b, String c) {\n+\t\t\tint value = Integer.parseUnsignedInt(a + b + c, 2);\n+\t\t\tAssertions.assertThat(value).isBetween(0b000, 0b111);\n+\t\t}\n+\n+\t\t@CartesianProductTest\n+\t\t@DisplayName(\"S \u2a2f T \u2a2f U\")\n+\t\tvoid nFold(String string, Class<?> type, TimeUnit unit, TestInfo info) {\n+\t\t\tAssertions.assertThat(string).endsWith(\"a\");\n+\t\t\tAssertions.assertThat(type).isInterface();\n+\t\t\tAssertions.assertThat(unit.name()).endsWith(\"S\");\n+\t\t\tAssertions.assertThat(info.getTags()).isEmpty();\n+\t\t}\n+\n+\t\t@CartesianProductTest(factory = \"supplyValues\")\n+\t\t@DisplayName(\"Can have an explicit factory method over the implicit one\")\n+\t\tvoid explicitFactory(String string, TimeUnit unit) {\n+\t\t\tAssertions.assertThat(string).isIn(\"War\", \"Peace\");\n+\t\t\tAssertions.assertThat(unit.name()).endsWith(\"S\");\n+\t\t}\n+\n+\t}\n+\n+\tstatic CartesianProductTest.Sets nFold() {\n+\t\treturn new CartesianProductTest.Sets()\n+\t\t\t\t.add(\"Alpha\", \"Omega\")\n+\t\t\t\t.add(Runnable.class, Comparable.class, TestInfo.class)\n+\t\t\t\t.add(TimeUnit.DAYS, TimeUnit.HOURS);\n+\t}\n+\n+\tstatic CartesianProductTest.Sets supplyValues() {\n+\t\treturn new CartesianProductTest.Sets().add(\"War\", \"Peace\").add(TimeUnit.SECONDS, TimeUnit.DAYS);\n+\t}\n+\n+\t@Nested\n+\tclass BadConfigurationTests {\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails when there is no factory method\")\n+\t\tvoid throwsForMissingFactoryMethod() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigurationTest.class, \"noFactory\", int.class);\n+\n+\t\t\tassertThat(results)\n+\t\t\t\t\t.hasSingleFailedContainer()\n+\t\t\t\t\t.withExceptionInstanceOf(AssertionError.class)\n+\t\t\t\t\t.hasMessageContaining(\"not found\");\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails when the factory is not static\")\n+\t\tvoid throwsForNonStaticFactoryMethod() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigurationTest.class, \"nonStaticFactory\", int.class);\n+\n+\t\t\tassertThat(results)\n+\t\t\t\t\t.hasSingleFailedContainer()\n+\t\t\t\t\t.withExceptionInstanceOf(AssertionError.class)\n+\t\t\t\t\t.hasMessageContaining(\"must be static\");\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails when the factory does not return Sets\")\n+\t\tvoid throwsForWrongReturnValueFactoryMethod() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigurationTest.class, \"wrongReturnFactory\", int.class);\n+\n+\t\t\tassertThat(results)\n+\t\t\t\t\t.hasSingleFailedContainer()\n+\t\t\t\t\t.withExceptionInstanceOf(AssertionError.class)\n+\t\t\t\t\t.hasMessageContaining(\"must return\");\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails if the factory does not produce enough parameters\")\n+\t\tvoid throwsForTooFewFactoryMethodParameters() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigurationTest.class, \"incompleteFactory\", int.class,\n+\t\t\t\t\t\tString.class, TimeUnit.class);\n+\n+\t\t\tassertThat(results).hasNumberOfDynamicallyRegisteredTests(3).hasNumberOfFailedTests(3);\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails if the factory produces too much parameters\")\n+\t\tvoid throwsForTooManyFactoryMethodParameters() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigurationTest.class, \"bloatedFactory\", int.class,\n+\t\t\t\t\t\tString.class);\n+\n+\t\t\tassertThat(results)\n+\t\t\t\t\t.hasSingleFailedContainer()\n+\t\t\t\t\t.withExceptionInstanceOf(AssertionError.class)\n+\t\t\t\t\t.hasMessageContaining(\"must register values for each parameter\");", "originalCommit": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ4OTY3Ng==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471489676", "bodyText": "Don't know how to test for too few parameters, unless we check for auto-injected parameters (like TestReporter or TestInfo) that should not be part of the @CartesianProductTest.", "author": "Michael1993", "createdAt": "2020-08-17T13:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzYzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA1NjYyMg==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474056622", "bodyText": "Okay.", "author": "Bukama", "createdAt": "2020-08-20T15:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzYzMg=="}], "type": "inlineReview"}, {"oid": "0bec357c0770adfc4f16176c94899cba50ec5edb", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/0bec357c0770adfc4f16176c94899cba50ec5edb", "message": "Rewrote documentation, added new test\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-08-18T08:34:11Z", "type": "commit"}, {"oid": "05dba570d277621c69a402a11a2f3cde1fb3a662", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/05dba570d277621c69a402a11a2f3cde1fb3a662", "message": "Fix bad test and weird formatting things\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-08-18T08:43:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA1OTA2OA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474059068", "bodyText": "giving a value\n\nWith a single value there is no Cartesian product (or to be exactly: The CP only has one row). Would change it to plural, e.g. \"by giving values to. These values are input for all parameters.\" or something like that.", "author": "Bukama", "createdAt": "2020-08-20T15:11:52Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,150 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.", "originalCommit": "05dba570d277621c69a402a11a2f3cde1fb3a662", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc3NjA0MA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474776040", "bodyText": "I rewrote it to be more explicit. Tell me your thoughts, please.", "author": "Michael1993", "createdAt": "2020-08-21T15:37:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA1OTA2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA1OTI2Mw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474059263", "bodyText": "values", "author": "Bukama", "createdAt": "2020-08-20T15:12:12Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,150 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".", "originalCommit": "05dba570d277621c69a402a11a2f3cde1fb3a662", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc3NDAyOA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474774028", "bodyText": "Fixed.", "author": "Michael1993", "createdAt": "2020-08-21T15:34:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA1OTI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MDA0NA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474060044", "bodyText": "Would add an introduction sentence like \"If you don't only supply String values to your test method like in the example above...\"", "author": "Bukama", "createdAt": "2020-08-20T15:13:26Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,150 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.", "originalCommit": "05dba570d277621c69a402a11a2f3cde1fb3a662", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc3NTAzNQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474775035", "bodyText": "Good idea, thank you. Fixed (I think).", "author": "Michael1993", "createdAt": "2020-08-21T15:36:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MDA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MDU2Mw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474060563", "bodyText": "Capital I after :", "author": "Bukama", "createdAt": "2020-08-20T15:14:05Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,150 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, the example>>).", "originalCommit": "05dba570d277621c69a402a11a2f3cde1fb3a662", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc3NjI2OA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474776268", "bodyText": "Yuuuup. \ud83d\ude13 Fixed.", "author": "Michael1993", "createdAt": "2020-08-21T15:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MDU2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MTczOQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474061739", "bodyText": "As you describe the input of nFold here this should be moved up to be in place with the example and after that show the possibility to use an individual name for the data provider method (without further explanation)", "author": "Bukama", "createdAt": "2020-08-20T15:15:46Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,150 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, the example>>).\n+\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void aTestMethodThatNeedsArguments(String string, int i) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets provideArguments() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Mercury\", \"Earth\", \"Venus\")\n+        .add(1, 12, 144);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+", "originalCommit": "05dba570d277621c69a402a11a2f3cde1fb3a662", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc3ODk1OA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474778958", "bodyText": "...Fixed? Please, take a look.", "author": "Michael1993", "createdAt": "2020-08-21T15:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MTczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MjY5Ng==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474062696", "bodyText": "\"There are some conditions\" or \"There are a couple of conditions\" or \"There are several conditions\"", "author": "Bukama", "createdAt": "2020-08-20T15:17:10Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,150 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, the example>>).\n+\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void aTestMethodThatNeedsArguments(String string, int i) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets provideArguments() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Mercury\", \"Earth\", \"Venus\")\n+        .add(1, 12, 144);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+=== Conditions for the static factory method\n+\n+There are a couple conditions the static factory method has to fulfill to qualify:", "originalCommit": "05dba570d277621c69a402a11a2f3cde1fb3a662", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc3OTE3OA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474779178", "bodyText": "\"There are multiple conditions\"? (Fixed?)", "author": "Michael1993", "createdAt": "2020-08-21T15:43:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MjY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MzcxNA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474063714", "bodyText": "This line reads like there is missing something at the end. Would change it to \"The following example shows...\" or something like this.", "author": "Bukama", "createdAt": "2020-08-20T15:18:41Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,150 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, the example>>).\n+\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void aTestMethodThatNeedsArguments(String string, int i) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets provideArguments() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Mercury\", \"Earth\", \"Venus\")\n+        .add(1, 12, 144);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+=== Conditions for the static factory method\n+\n+There are a couple conditions the static factory method has to fulfill to qualify:\n+\n+- must have the same name as the test method or its name must be specified via `factory()`\n+- must be `static`\n+- must have **no** parameters\n+- must return `CartesianProductTest.Sets`\n+- must register values for every parameter exactly once\n+- must register values in order\n+\n+=== Returning wrong `Sets` in the static factory method\n+\n+If you register too few, too many, or conflicting parameters, you will get an `org.junit.jupiter.api.extension.ParameterResolutionException`.\n+For example, if your test method has a `TestInfo` or `TestReporter` (or any other parameter that is automatically injected by JUnit), and you register too many sets in your factory method:", "originalCommit": "05dba570d277621c69a402a11a2f3cde1fb3a662", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc4Mjc4NA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474782784", "bodyText": "Reworded that part.", "author": "Michael1993", "createdAt": "2020-08-21T15:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MzcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2NDI0NQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474064245", "bodyText": "Remove as you don't know. The changelog will show the version the extension comes available.", "author": "Bukama", "createdAt": "2020-08-20T15:19:22Z", "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTest.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.TestTemplate;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+/**\n+ * {@code @CartesianProductTest} is a JUnit Jupiter extension that marks\n+ * a test to be executed with all possible input combinations.\n+ *\n+ * <p>Methods annotated with this annotation <b>MUST NOT</b> be annotated with {@code Test},\n+ * because it will throw an exception.\n+ * </p>\n+ *\n+ * <p>Methods annotated with this annotation are different from {@code ParameterizedTest}s because\n+ * they can not have {@code ArgumentsSource}s - those are completely disregarded. Instead a\n+ * String array must be provided (for methods with only String parameters) or a static factory method\n+ * with the same name as the test method must exist.\n+ * </p>\n+ *\n+ * @since ???", "originalCommit": "05dba570d277621c69a402a11a2f3cde1fb3a662", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc4NzM4MQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474787381", "bodyText": "Removed.", "author": "Michael1993", "createdAt": "2020-08-21T15:59:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2NDI0NQ=="}], "type": "inlineReview"}, {"oid": "06d45a7219280730d6228b4f6eeb35139f15f99f", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/06d45a7219280730d6228b4f6eeb35139f15f99f", "message": "Create our own `CartesianValueSource` for supplying parameter values to `CartesianProductTest`\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-08-21T14:33:10Z", "type": "commit"}, {"oid": "15ce2f2e79a03e6633d1066a289895c8e6d50e7c", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/15ce2f2e79a03e6633d1066a289895c8e6d50e7c", "message": "Rewrote documentation again.\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-08-21T16:09:06Z", "type": "commit"}, {"oid": "096f41ed7fd92b2c70b5add05b5d3309fb351291", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/096f41ed7fd92b2c70b5add05b5d3309fb351291", "message": "Making SONAR happy\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-08-21T16:22:45Z", "type": "commit"}, {"oid": "25bfc9013ed08e55012c5cf94a0dbaa8ab542753", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/25bfc9013ed08e55012c5cf94a0dbaa8ab542753", "message": "Remove duplicate elements from inputs\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-08-24T09:24:15Z", "type": "commit"}, {"oid": "088288c5575fc73f60536539d869f11f84a9cc07", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/088288c5575fc73f60536539d869f11f84a9cc07", "message": "spotless\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-08-24T09:25:20Z", "type": "commit"}, {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "message": "Added some explanation about the extension removing duplicates\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-08-24T09:32:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUzNDMxMQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476534311", "bodyText": "For a better transition between the theoretical part and the extension I would change this to something like:\nSometimes its useful to test all possible combinations of parameters set. Normally this results in a lot of written test data parameters. For a more comfortable way you may use the CartesianProductTest extension. The extension takes the test data parameter values and runs....\nThe basic usage of the extension (with the parameter sets) are describe below anyway.", "author": "Bukama", "createdAt": "2020-08-25T15:22:57Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUzNzY1Ng==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476537656", "bodyText": "I don't know which words I should choose, but this sentence lacks some kind of introduction, like to \"There are multiple ways to pass test data to the extension.\". As of now you (or at least I) fall \"into\" this sentences without knowing what to expect.", "author": "Bukama", "createdAt": "2020-08-25T15:27:11Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUzODUxMQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476538511", "bodyText": "The Cartesian product works with sets, so the extension does. (more fluent I think)", "author": "Bukama", "createdAt": "2020-08-25T15:28:25Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0MDA1OA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476540058", "bodyText": "You should add if the duplicates get removed automatically (most probably as Set can't work with duplicates). To emphasize that I would remove the final Cartesian product (you described above how it is created) and change the line to the (automatically) \"real/reduced\" input, e.g.\nIf your input is { 1, 1, 3, 4 } and { 2, 2, 3 } the input sets get reduced to  { { 1, 3, 4 }, { 2, 3 } }.\nI would change If you need that functionality to If you need to pass the same parameters multiple times, you might.. to make clear what you mean with functionality.", "author": "Bukama", "createdAt": "2020-08-25T15:30:37Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0NDIwNQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476544205", "bodyText": "I don't like the wording of \"a value\". I know it's because value is the default name of the annotation variable, but \"a value\" mislead to \"a single value\", which is false, because you are passing String arrays.\nWhat about something like \"Supplying (simple) sets of Strings to the extension\"?", "author": "Bukama", "createdAt": "2020-08-25T15:36:17Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0NTY0NQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476545645", "bodyText": "No , before and- this is no enumeration", "author": "Bukama", "createdAt": "2020-08-25T15:38:25Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0NzAyNA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476547024", "bodyText": "Change ; to ,, because that's .. is a subordinate clause.", "author": "Bukama", "createdAt": "2020-08-25T15:40:17Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0Nzk5Mw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476547993", "bodyText": "_Instead of only suppliying string values to your ... you can annotate ... with CartesianValueSource [to do what <- thats missing]\nOr written in another way: If I don't supply string values I don't supply them. Period. Starting a sentence like this makes the reader feel that there are (bad) consequences if not doing so.", "author": "Bukama", "createdAt": "2020-08-25T15:41:46Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0OTM3Nw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476549377", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n          \n          \n            \n            This is annotation might look familiar (it mimics JUnits `@ValueSource`), but it works differently.....[insert explanation].\n          \n      \n    \n    \n  \n\nOr explanation below at end of subsection.", "author": "Bukama", "createdAt": "2020-08-25T15:43:51Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1MDk1OQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476550959", "bodyText": "left-to-right or top-to-bottom: The or irritates me. Is there any forced order or not? You example seems like the order of the annotation must match the parameter order? Are the names of \"ints\" and \"strings\" fixed or forced too?", "author": "Bukama", "createdAt": "2020-08-25T15:46:10Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n+It is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right or top-to-bottom) and the test will try every combination those values can have.", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTYzNzg5Mg==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r479637892", "bodyText": "Left-to-right = top-to-bottom. There is a forced order.", "author": "Michael1993", "createdAt": "2020-08-29T11:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1MDk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1MTQ3Mw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476551473", "bodyText": ";to ,", "author": "Bukama", "createdAt": "2020-08-25T15:46:58Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n+It is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right or top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations; that's `3 \u00d7 2`, so six tests in total.", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1MjA3NA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476552074", "bodyText": "Move this up to the explanation (or add a subsubsection / some sentences) here to explain the differences.", "author": "Bukama", "createdAt": "2020-08-25T15:47:55Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n+It is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right or top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations; that's `3 \u00d7 2`, so six tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `number` | value of `character`\n+| 1st test  | 1                 | \"A\"\n+| 2nd test  | 1                 | \"B\"\n+| 3rd test  | 2                 | \"A\"\n+| 4th test  | 2                 | \"B\"\n+| 5th test  | 4                 | \"A\"\n+| 6th test  | 4                 | \"B\"\n+|===\n+\n+Please note that `@CartesianValueSource` is not compatible with `@ParameterizedTest`.", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1MjU3Mg==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476552572", "bodyText": "Remove the \"finally,\"", "author": "Bukama", "createdAt": "2020-08-25T15:48:44Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n+It is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right or top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations; that's `3 \u00d7 2`, so six tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `number` | value of `character`\n+| 1st test  | 1                 | \"A\"\n+| 2nd test  | 1                 | \"B\"\n+| 3rd test  | 2                 | \"A\"\n+| 4th test  | 2                 | \"B\"\n+| 5th test  | 4                 | \"A\"\n+| 6th test  | 4                 | \"B\"\n+|===\n+\n+Please note that `@CartesianValueSource` is not compatible with `@ParameterizedTest`.\n+\n+== Writing a static factory method for the parameters\n+\n+Finally, if your tests require special inputs that `@CartesianValueSource` is not able to supply, you can define a static factory method to supply your test parameters.", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NDAwMg==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476554002", "bodyText": "What about a more fluent sentence like: To create a set with test data, instantiate a new CartesianProductTest.Sets(), use the add()... and return the created object.", "author": "Bukama", "createdAt": "2020-08-25T15:50:50Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n+It is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right or top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations; that's `3 \u00d7 2`, so six tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `number` | value of `character`\n+| 1st test  | 1                 | \"A\"\n+| 2nd test  | 1                 | \"B\"\n+| 3rd test  | 2                 | \"A\"\n+| 4th test  | 2                 | \"B\"\n+| 5th test  | 4                 | \"A\"\n+| 6th test  | 4                 | \"B\"\n+|===\n+\n+Please note that `@CartesianValueSource` is not compatible with `@ParameterizedTest`.\n+\n+== Writing a static factory method for the parameters\n+\n+Finally, if your tests require special inputs that `@CartesianValueSource` is not able to supply, you can define a static factory method to supply your test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: Instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, the example>>).", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NDI0Ng==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476554246", "bodyText": "again", "author": "Bukama", "createdAt": "2020-08-25T15:51:12Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n+It is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right or top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations; that's `3 \u00d7 2`, so six tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `number` | value of `character`\n+| 1st test  | 1                 | \"A\"\n+| 2nd test  | 1                 | \"B\"\n+| 3rd test  | 2                 | \"A\"\n+| 4th test  | 2                 | \"B\"\n+| 5th test  | 4                 | \"A\"\n+| 6th test  | 4                 | \"B\"\n+|===\n+\n+Please note that `@CartesianValueSource` is not compatible with `@ParameterizedTest`.\n+\n+== Writing a static factory method for the parameters\n+\n+Finally, if your tests require special inputs that `@CartesianValueSource` is not able to supply, you can define a static factory method to supply your test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: Instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, the example>>).\n+\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NTQ0MA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476555440", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Remember, you can reuse the same argument provider if you explicitly give its name to `@CartesianProductTest`.\n          \n          \n            \n            Remember, you can reuse the same argument provider method, by explicitly pass its name to the  `@CartesianProductTest` `factory` attribute.", "author": "Bukama", "createdAt": "2020-08-25T15:52:56Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n+It is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right or top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations; that's `3 \u00d7 2`, so six tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `number` | value of `character`\n+| 1st test  | 1                 | \"A\"\n+| 2nd test  | 1                 | \"B\"\n+| 3rd test  | 2                 | \"A\"\n+| 4th test  | 2                 | \"B\"\n+| 5th test  | 4                 | \"A\"\n+| 6th test  | 4                 | \"B\"\n+|===\n+\n+Please note that `@CartesianValueSource` is not compatible with `@ParameterizedTest`.\n+\n+== Writing a static factory method for the parameters\n+\n+Finally, if your tests require special inputs that `@CartesianValueSource` is not able to supply, you can define a static factory method to supply your test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: Instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, the example>>).\n+\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+Remember, you can reuse the same argument provider if you explicitly give its name to `@CartesianProductTest`.", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NjY2NA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476556664", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - must have the same name as the test method or its name must be specified via `factory()`\n          \n          \n            \n            - must have the same name as the test method (or its name must be specified via `factory()`)\n          \n      \n    \n    \n  \n\nYou are listing conditions of the method. So the same name is only in default case (as you described above)  and I would put the note about the factory() method as a reminder in brackets here.", "author": "Bukama", "createdAt": "2020-08-25T15:54:41Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n+It is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right or top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations; that's `3 \u00d7 2`, so six tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `number` | value of `character`\n+| 1st test  | 1                 | \"A\"\n+| 2nd test  | 1                 | \"B\"\n+| 3rd test  | 2                 | \"A\"\n+| 4th test  | 2                 | \"B\"\n+| 5th test  | 4                 | \"A\"\n+| 6th test  | 4                 | \"B\"\n+|===\n+\n+Please note that `@CartesianValueSource` is not compatible with `@ParameterizedTest`.\n+\n+== Writing a static factory method for the parameters\n+\n+Finally, if your tests require special inputs that `@CartesianValueSource` is not able to supply, you can define a static factory method to supply your test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: Instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, the example>>).\n+\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+Remember, you can reuse the same argument provider if you explicitly give its name to `@CartesianProductTest`.\n+\n+```java\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void testNeedingArguments(String string, int i) {\n+    // passing test code\n+}\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void testNeedingSameArguments(String string, int i) {\n+    // different passing test code\n+}\n+\n+static CartesianProductTest.Sets provideArguments() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Mercury\", \"Earth\", \"Venus\")\n+        .add(1, 12, 144);\n+}\n+```\n+\n+=== Conditions for the static factory method\n+\n+There are multiple conditions the static factory method has to fulfill to qualify:\n+\n+- must have the same name as the test method or its name must be specified via `factory()`", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NzI5Nw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476557297", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            == Combining `@CartesianProductTest` with `@Test`\n          \n          \n            \n            == Warning: Don't combine `@CartesianProductTest` with `@Test`!", "author": "Bukama", "createdAt": "2020-08-25T15:55:36Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n+It is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right or top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations; that's `3 \u00d7 2`, so six tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `number` | value of `character`\n+| 1st test  | 1                 | \"A\"\n+| 2nd test  | 1                 | \"B\"\n+| 3rd test  | 2                 | \"A\"\n+| 4th test  | 2                 | \"B\"\n+| 5th test  | 4                 | \"A\"\n+| 6th test  | 4                 | \"B\"\n+|===\n+\n+Please note that `@CartesianValueSource` is not compatible with `@ParameterizedTest`.\n+\n+== Writing a static factory method for the parameters\n+\n+Finally, if your tests require special inputs that `@CartesianValueSource` is not able to supply, you can define a static factory method to supply your test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: Instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, the example>>).\n+\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+Remember, you can reuse the same argument provider if you explicitly give its name to `@CartesianProductTest`.\n+\n+```java\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void testNeedingArguments(String string, int i) {\n+    // passing test code\n+}\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void testNeedingSameArguments(String string, int i) {\n+    // different passing test code\n+}\n+\n+static CartesianProductTest.Sets provideArguments() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Mercury\", \"Earth\", \"Venus\")\n+        .add(1, 12, 144);\n+}\n+```\n+\n+=== Conditions for the static factory method\n+\n+There are multiple conditions the static factory method has to fulfill to qualify:\n+\n+- must have the same name as the test method or its name must be specified via `factory()`\n+- must be `static`\n+- must have **no** parameters\n+- must return `CartesianProductTest.Sets`\n+- must register values for every parameter exactly once\n+- must register values in order\n+\n+=== Returning wrong `Sets` in the static factory method\n+\n+If you register too few, too many, or conflicting parameters, you will get an `org.junit.jupiter.api.extension.ParameterResolutionException`.\n+Conflicting parameters meaning your test method has a `TestInfo` or `TestReporter` (or any other parameter that is automatically injected by JUnit), and you register too many sets in your factory method.\n+\n+Examples of badly configured tests/static factory method:\n+```java\n+@CartesianProductTest(factory = \"resolveParameters\")\n+void tooFewParameters(String string, int i, boolean b) {\n+    // fails because the boolean parameter is not resolved\n+}\n+\n+@CartesianProductTest(factory = \"resolveParameters\")\n+void tooManyParameters(String string) {\n+    // fails because we try to supply a non-existent integer parameter\n+}\n+\n+@CartesianProductTest(factory = \"resolveParameters\")\n+void wrongOrderParameters(int i, String string) {\n+    // fails because the static factory method declared parameter sets in the wrong order\n+}\n+\n+@CartesianProductTest(factory = \"resolveParameters\")\n+void conflictingParameters(String string, TestInfo info) {\n+    // fails because both the factory method and JUnit tries to inject TestInfo\n+    // OR\n+    // fails because the static factory method tries to inject int instead of TestInfo\n+}\n+\n+static CartesianProductTest.Sets resolveParameters() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"A\", \"B\", \"C\")\n+        .add(1, 2, 3);\n+}\n+```\n+\n+== Combining `@CartesianProductTest` with `@Test`", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1OTEwMA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476559100", "bodyText": "_ Spotless what did you do here?_", "author": "Bukama", "createdAt": "2020-08-25T15:58:11Z", "path": "src/main/java/org/junitpioneer/jupiter/CartesianValueArgumentsProvider.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.junit.platform.commons.util.Preconditions;\n+\n+/**\n+ * This is basically a copy of ValueSourceArgumentsProvider,\n+ * except it does NOT support {@code @ParameterizedTest}.\n+ */\n+class CartesianValueArgumentsProvider implements Consumer<CartesianValueSource> {\n+\n+\tprivate Object[] arguments;\n+\n+\t@Override\n+\tpublic void accept(CartesianValueSource source) {\n+\t\t// @formatter:off\n+        List<Object> arrays =\n+                // Declaration of <Object> is necessary due to a bug in Eclipse Photon.\n+                Stream.<Object> of(\n+                        source.shorts(),\n+                        source.bytes(),\n+                        source.ints(),\n+                        source.longs(),\n+                        source.floats(),\n+                        source.doubles(),\n+                        source.chars(),\n+                        source.booleans(),\n+                        source.strings(),\n+                        source.classes()\n+                )\n+                .filter(array -> Array.getLength(array) > 0)\n+                .collect(toList());\n+        // @formatter:on\n+\n+\t\tPreconditions\n+\t\t\t\t.condition(arrays.size() == 1, () -> \"Exactly one type of input must be provided in the @\"\n+\t\t\t\t\t\t+ CartesianValueSource.class.getSimpleName() + \" annotation, but there were \" + arrays.size());", "originalCommit": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a9a4864879b738a08bc9bcbba41c0dab39f3ed4d", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/a9a4864879b738a08bc9bcbba41c0dab39f3ed4d", "message": "Documentation updates following suggestions\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-08-29T11:07:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc3NzA5MQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r479777091", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Sometimes its useful to test all possible combinations of parameters set.\n          \n          \n            \n            Sometimes its useful to test all possible combinations of parameters sets.", "author": "Bukama", "createdAt": "2020-08-30T14:32:08Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,222 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+Sometimes its useful to test all possible combinations of parameters set.", "originalCommit": "a9a4864879b738a08bc9bcbba41c0dab39f3ed4d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "733d9249d8e9827ecc08102ca31d95ca0d347afd", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/733d9249d8e9827ecc08102ca31d95ca0d347afd", "message": "Fixing typo\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-08-30T16:31:40Z", "type": "commit"}, {"oid": "21c18d6a7edbc50c933b7f547045f5523517dd08", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/21c18d6a7edbc50c933b7f547045f5523517dd08", "message": "Merge branch 'master' into issue/68-cartesian-product-extension", "committedDate": "2020-09-08T17:55:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTU4NQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r485175585", "bodyText": "\"the free encyclopedia\" seems a bit patronizing, I think most people know that small project already. \ud83d\ude09", "author": "nipafx", "createdAt": "2020-09-08T20:24:06Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,222 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:", "originalCommit": "733d9249d8e9827ecc08102ca31d95ca0d347afd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTcwNA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r485175704", "bodyText": "Love this! \u2764\ufe0f \ud83d\udc4d", "author": "nipafx", "createdAt": "2020-09-08T20:24:23Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,222 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?", "originalCommit": "733d9249d8e9827ecc08102ca31d95ca0d347afd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NjM4OQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r485176389", "bodyText": "I think the section Basic Use could do with a simple, working code snippet.", "author": "nipafx", "createdAt": "2020-09-08T20:25:44Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,222 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+Sometimes it's useful to test all possible combinations of parameter sets.\n+Normally, this results in a lot of written test data parameters.\n+For a more comfortable way you may use the `@CartesianProductTest` extension.\n+The extension takes the test data parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use", "originalCommit": "733d9249d8e9827ecc08102ca31d95ca0d347afd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY5MTQwMw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r491691403", "bodyText": "Added a basic snippet without explanation", "author": "Michael1993", "createdAt": "2020-09-20T13:24:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NjM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODA4MA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r485178080", "bodyText": "The section header talks about single sets, which made me expect a way to define sets of all types (e.g. a single set of ints), but the text only mentions String arrays. Does this work for all kinds of arrays? If so/not, this should be stated explicitly.", "author": "nipafx", "createdAt": "2020-09-08T20:29:23Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,222 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+Sometimes it's useful to test all possible combinations of parameter sets.\n+Normally, this results in a lot of written test data parameters.\n+For a more comfortable way you may use the `@CartesianProductTest` extension.\n+The extension takes the test data parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+\n+You can supply test parameters to `@CartesianProductTest` in multiple ways.\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+Just like the mathematical Cartesian product, `@CartesianProductTest` works with sets.\n+Duplicate elements get removed automatically.\n+If your input is `{ 1, 1, 3 }` and `{ 2, 2 }` the extension will consider their Cartesian product `{ { 1, 2 }, { 3, 2 } }`.\n+Otherwise, the test would run with the same parameters multiple times.\n+If you need to pass the same parameters multiple times, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying CartesianProductTest with a single set\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.", "originalCommit": "733d9249d8e9827ecc08102ca31d95ca0d347afd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY5MTQ1MA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r491691450", "bodyText": "Cleaned up wording to explicitly mean String[]", "author": "Michael1993", "createdAt": "2020-09-20T13:25:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MDE3Nw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r485180177", "bodyText": "Good connection to something the reader (may) already know! \ud83d\udc4d Add a link to the user guide or docs to drive it home.", "author": "nipafx", "createdAt": "2020-09-08T20:33:34Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,222 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+Sometimes it's useful to test all possible combinations of parameter sets.\n+Normally, this results in a lot of written test data parameters.\n+For a more comfortable way you may use the `@CartesianProductTest` extension.\n+The extension takes the test data parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+\n+You can supply test parameters to `@CartesianProductTest` in multiple ways.\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+Just like the mathematical Cartesian product, `@CartesianProductTest` works with sets.\n+Duplicate elements get removed automatically.\n+If your input is `{ 1, 1, 3 }` and `{ 2, 2 }` the extension will consider their Cartesian product `{ { 1, 2 }, { 3, 2 } }`.\n+Otherwise, the test would run with the same parameters multiple times.\n+If you need to pass the same parameters multiple times, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying CartesianProductTest with a single set\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters.\n+The test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations, that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply string values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+`@CartesianValueSource` is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right/top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+This annotation might look familiar - it mimics JUnits `@ValueSource`, except `@CartesianValueSource` is repeatable.", "originalCommit": "733d9249d8e9827ecc08102ca31d95ca0d347afd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY5MTQ2Nw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r491691467", "bodyText": "Link added.", "author": "Michael1993", "createdAt": "2020-09-20T13:25:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MDE3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NjE1OQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r485186159", "bodyText": "This made me think, I could not have TestInfo or TestReporter params in my test method signature.", "author": "nipafx", "createdAt": "2020-09-08T20:45:38Z", "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,222 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+Sometimes it's useful to test all possible combinations of parameter sets.\n+Normally, this results in a lot of written test data parameters.\n+For a more comfortable way you may use the `@CartesianProductTest` extension.\n+The extension takes the test data parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+\n+You can supply test parameters to `@CartesianProductTest` in multiple ways.\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+Just like the mathematical Cartesian product, `@CartesianProductTest` works with sets.\n+Duplicate elements get removed automatically.\n+If your input is `{ 1, 1, 3 }` and `{ 2, 2 }` the extension will consider their Cartesian product `{ { 1, 2 }, { 3, 2 } }`.\n+Otherwise, the test would run with the same parameters multiple times.\n+If you need to pass the same parameters multiple times, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying CartesianProductTest with a single set\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters.\n+The test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations, that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply string values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+`@CartesianValueSource` is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right/top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+This annotation might look familiar - it mimics JUnits `@ValueSource`, except `@CartesianValueSource` is repeatable.\n+It also does NOT work with `@ParameterizedTest`.\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations, that's `3 \u00d7 2`, so six tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `number` | value of `character`\n+| 1st test  | 1                 | \"A\"\n+| 2nd test  | 1                 | \"B\"\n+| 3rd test  | 2                 | \"A\"\n+| 4th test  | 2                 | \"B\"\n+| 5th test  | 4                 | \"A\"\n+| 6th test  | 4                 | \"B\"\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+If your tests require special inputs that `@CartesianValueSource` is not able to supply, you can define a static factory method to supply your test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+To create the test data, instantiate a `new CartesianProductTest.Sets()` then use the `add()` method to register the values for the parameters.\n+\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations, that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+Remember, you can reuse the same argument provider method, by explicitly passing its name to `@CartesianProductTest`'s `factory` attribute.\n+\n+```java\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void testNeedingArguments(String string, int i) {\n+    // passing test code\n+}\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void testNeedingSameArguments(String string, int i) {\n+    // different passing test code\n+}\n+\n+static CartesianProductTest.Sets provideArguments() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Mercury\", \"Earth\", \"Venus\")\n+        .add(1, 12, 144);\n+}\n+```\n+\n+=== Conditions for the static factory method\n+\n+There are multiple conditions the static factory method has to fulfill to qualify:\n+\n+- must have the same name as the test method (or its name must be specified via `factory()`)\n+- must be `static`\n+- must have **no** parameters\n+- must return `CartesianProductTest.Sets`\n+- must register values for every parameter exactly once\n+- must register values in order\n+\n+=== Returning wrong `Sets` in the static factory method\n+\n+If you register too few, too many, or conflicting parameters, you will get an `org.junit.jupiter.api.extension.ParameterResolutionException`.\n+Conflicting parameters meaning your test method has a `TestInfo` or `TestReporter` (or any other parameter that is automatically injected by JUnit), and you register too many sets in your factory method.", "originalCommit": "733d9249d8e9827ecc08102ca31d95ca0d347afd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NjQzNw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r485186437", "bodyText": "If TestInfo or TestReporter works with correct configurations, that may be worth a mention as well.", "author": "nipafx", "createdAt": "2020-09-08T20:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NjE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY3OTk2NA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r491679964", "bodyText": "It works if you don't try to \"manually\" inject your own TestReporter. I will clean up the wording of this sentence.", "author": "Michael1993", "createdAt": "2020-09-20T11:01:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NjE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY5MTQ5Ng==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r491691496", "bodyText": "Cleaned up, mention added.", "author": "Michael1993", "createdAt": "2020-09-20T13:26:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NjE1OQ=="}], "type": "inlineReview"}, {"oid": "f82643ccf72fdada563b0bf4b4549a671e3a102f", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/f82643ccf72fdada563b0bf4b4549a671e3a102f", "message": "Merge branch 'master' into issue/68-cartesian-product-extension", "committedDate": "2020-09-09T09:36:40Z", "type": "commit"}, {"oid": "2b041892c3d99347be85163c69025d4e45fbc2c3", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/2b041892c3d99347be85163c69025d4e45fbc2c3", "message": "CartesianProductTest display names should align with ParameterizedTest display names\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-09-20T13:22:42Z", "type": "commit"}, {"oid": "5f04e74c62249db4476ddf1e57341f08cf751892", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/5f04e74c62249db4476ddf1e57341f08cf751892", "message": "Applying suggestions to documentation\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-09-20T13:23:00Z", "type": "commit"}, {"oid": "ae17e0f43e1d873a934649fea7a7e21165fa7748", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/ae17e0f43e1d873a934649fea7a7e21165fa7748", "message": "Merge branch 'master' into issue/68-cartesian-product-extension", "committedDate": "2020-09-20T13:23:44Z", "type": "commit"}, {"oid": "916c0e5d5c95005ae7447afba13aa57403a64d4a", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/916c0e5d5c95005ae7447afba13aa57403a64d4a", "message": "Small documentation improvements (subject to Mihaly's approval)", "committedDate": "2020-09-26T09:11:35Z", "type": "commit"}, {"oid": "b76351dceb0ae3e619ab6a74b1eb36964d9e2cc1", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/b76351dceb0ae3e619ab6a74b1eb36964d9e2cc1", "message": "Merge branch 'master' into issue/68-cartesian-product-extension", "committedDate": "2020-09-26T09:25:44Z", "type": "commit"}, {"oid": "cb836ff1adbd68c00a358ec7a2bf7bec7c921bd9", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/cb836ff1adbd68c00a358ec7a2bf7bec7c921bd9", "message": "Replace AssertionError with ExtensionConfigurationException\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-09-26T09:26:58Z", "type": "commit"}, {"oid": "c94cd6fbc526097f996e7cda8e80ff9e52949704", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/c94cd6fbc526097f996e7cda8e80ff9e52949704", "message": "Fix modular build?\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-09-26T09:35:45Z", "type": "commit"}, {"oid": "b6daad3d71bbed16d30b5c0d58283d0cce2ab81a", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/b6daad3d71bbed16d30b5c0d58283d0cce2ab81a", "message": "Replace AssertionError with ExtensionConfigurationException in tests\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-09-26T09:40:11Z", "type": "commit"}, {"oid": "118c3e1f40383b1a850a4edfa949b1d5a8c01470", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/118c3e1f40383b1a850a4edfa949b1d5a8c01470", "message": "Fix comment and JavaDoc\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-09-26T09:46:44Z", "type": "commit"}, {"oid": "7186f694b0d818d856b1f9e84e1ef6838a58cbd1", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/7186f694b0d818d856b1f9e84e1ef6838a58cbd1", "message": "Merge branch 'master' into issue/68-cartesian-product-extension", "committedDate": "2020-09-26T09:49:34Z", "type": "commit"}, {"oid": "99003da041688209f876d47233f1a12ab68d46f6", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/99003da041688209f876d47233f1a12ab68d46f6", "message": "Validate input of CartesianProductTests with ReportEntry", "committedDate": "2020-09-26T10:40:11Z", "type": "commit"}, {"oid": "6ef09b6a0768c10f13b2cba0d8a2d983012fe5f2", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/6ef09b6a0768c10f13b2cba0d8a2d983012fe5f2", "message": "Add ExtensionConfigurationException to conflicting arguments sources.", "committedDate": "2020-09-26T13:11:36Z", "type": "commit"}, {"oid": "72d01df5c9e74f136e2f8f6cb4b630f5f6e73579", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/72d01df5c9e74f136e2f8f6cb4b630f5f6e73579", "message": "Added a sentence about different parameter sources conflicting in the documentation", "committedDate": "2020-09-26T14:29:31Z", "type": "commit"}, {"oid": "d3776202cf25626c4305911780682a67e405f591", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/d3776202cf25626c4305911780682a67e405f591", "message": "Added an option to change display name of tests created by a CartesianProductTest", "committedDate": "2020-09-26T18:44:00Z", "type": "commit"}, {"oid": "722abb0da5265fe04f01a4f87e107194891c52a9", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/722abb0da5265fe04f01a4f87e107194891c52a9", "message": "Fix Java 9+ calls to List.of to be Arrays.asList", "committedDate": "2020-09-26T21:15:55Z", "type": "commit"}, {"oid": "f22aaae5ccad2a43f558b798b9b32bf6388eda23", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/f22aaae5ccad2a43f558b798b9b32bf6388eda23", "message": "Fix creaky things", "committedDate": "2020-09-26T22:49:32Z", "type": "commit"}, {"oid": "cfd855593a6364c4ab3085ee8df940c451a8cb3b", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/cfd855593a6364c4ab3085ee8df940c451a8cb3b", "message": "Add missing test case", "committedDate": "2020-09-26T23:09:11Z", "type": "commit"}, {"oid": "0f70f8cd7ef6df7831d0b395697b800d043b392b", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/0f70f8cd7ef6df7831d0b395697b800d043b392b", "message": "no star imports", "committedDate": "2020-09-26T23:13:47Z", "type": "commit"}, {"oid": "c8f3dc487f68d97135153352b70662bb06029ccf", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/c8f3dc487f68d97135153352b70662bb06029ccf", "message": "Added documentation about customizing Display Names of CartesianProductTests", "committedDate": "2020-09-27T15:51:14Z", "type": "commit"}, {"oid": "a802ca8074b2a09b298b43d909fc5e131fe39fe4", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/a802ca8074b2a09b298b43d909fc5e131fe39fe4", "message": "Small edits in tests", "committedDate": "2020-09-29T18:48:07Z", "type": "commit"}, {"oid": "b620344d08515cc2ec5ddf49cb7057145fd40fe4", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/b620344d08515cc2ec5ddf49cb7057145fd40fe4", "message": "Reduce visibility", "committedDate": "2020-09-29T19:23:48Z", "type": "commit"}, {"oid": "6c07302c61c24cbfccad3ad99ad8655a653ac19d", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/6c07302c61c24cbfccad3ad99ad8655a653ac19d", "message": "Small refactorings", "committedDate": "2020-09-29T19:24:16Z", "type": "commit"}, {"oid": "7cd5f1963e61c482ea96f97524fc13045d8e4239", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/7cd5f1963e61c482ea96f97524fc13045d8e4239", "message": "DEATH TO SPACES! \u2620", "committedDate": "2020-09-29T19:24:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk2NzQ5OA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r496967498", "bodyText": "Can we get a little more detail on how to use the extension and a link to the website with details?", "author": "nipafx", "createdAt": "2020-09-29T18:57:55Z", "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.TestTemplate;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+/**\n+ * {@code @CartesianProductTest} is a JUnit Jupiter extension that marks\n+ * a test to be executed with all possible input combinations.\n+ *\n+ * <p>Methods annotated with this annotation should not be annotated with {@code Test}.\n+ * </p>", "originalCommit": "c8f3dc487f68d97135153352b70662bb06029ccf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3MjA5OA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r496972098", "bodyText": "What if sets.getSets().size() == testMethod.getParameterCount(), but one of the parameters is resolved by JUnit itself? Then we should still see the exception.", "author": "nipafx", "createdAt": "2020-09-29T19:06:08Z", "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static java.lang.String.format;\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;\n+import static org.junit.platform.commons.support.AnnotationSupport.findRepeatableAnnotations;\n+import static org.junit.platform.commons.support.ReflectionSupport.invokeMethod;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionConfigurationException;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.ParameterResolutionException;\n+import org.junit.jupiter.api.extension.TestTemplateInvocationContext;\n+import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider;\n+\n+class CartesianProductTestExtension implements TestTemplateInvocationContextProvider {\n+\n+\t@Override\n+\tpublic boolean supportsTestTemplate(ExtensionContext context) {\n+\t\treturn findAnnotation(context.getTestMethod(), CartesianProductTest.class).isPresent();\n+\t}\n+\n+\t@Override\n+\tpublic Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContexts(ExtensionContext context) {\n+\t\tList<List<?>> sets = computeSets(context);\n+\t\tCartesianProductTestNameFormatter formatter = createNameFormatter(context);\n+\t\treturn cartesianProduct(sets)\n+\t\t\t\t.stream()\n+\t\t\t\t.map(params -> new CartesianProductTestInvocationContext(params, formatter));\n+\t}\n+\n+\tprivate CartesianProductTestNameFormatter createNameFormatter(ExtensionContext context) {\n+\t\tCartesianProductTest annotation = findAnnotation(context.getRequiredTestMethod(), CartesianProductTest.class)\n+\t\t\t\t.orElseThrow(() -> new ExtensionConfigurationException(\"@CartesianProductTest not found\"));\n+\t\tString pattern = annotation.name();\n+\t\tif (pattern.isEmpty())\n+\t\t\tthrow new ExtensionConfigurationException(\"CartesianProductTest can not have a non-empty display name\");\n+\t\tString displayName = context.getDisplayName();\n+\t\treturn new CartesianProductTestNameFormatter(pattern, displayName);\n+\t}\n+\n+\tprivate List<List<?>> computeSets(ExtensionContext context) {\n+\t\tMethod testMethod = context.getRequiredTestMethod();\n+\t\tCartesianProductTest annotation = findAnnotation(testMethod, CartesianProductTest.class)\n+\t\t\t\t.orElseThrow(() -> new ExtensionConfigurationException(\"@CartesianProductTest not found\"));\n+\t\tList<CartesianValueSource> valueSources = findRepeatableAnnotations(testMethod, CartesianValueSource.class);\n+\t\tensureNoInputConflicts(annotation, valueSources);\n+\t\t// Compute A \u2a2f A \u2a2f ... \u2a2f A from single source \"set\"\n+\t\tif (annotation.value().length > 0) {\n+\t\t\treturn getSetsFromValue(testMethod, annotation);\n+\t\t}\n+\t\t// Try finding the @CartesianValueSource annotation\n+\t\tif (!valueSources.isEmpty()) {\n+\t\t\treturn getSetsFromRepeatableAnnotation(valueSources);\n+\t\t}\n+\t\t// Try the sets static factory method\n+\t\treturn getSetsFromStaticFactory(testMethod, annotation.factory());\n+\t}\n+\n+\tprivate static void ensureNoInputConflicts(CartesianProductTest annotation,\n+\t\t\tList<CartesianValueSource> valueSources) {\n+\t\tboolean hasValue = annotation.value().length != 0;\n+\t\tboolean hasFactory = !annotation.factory().isEmpty();\n+\t\tboolean hasValueSources = !valueSources.isEmpty();\n+\t\tif (hasValue && hasFactory || hasValue && hasValueSources || hasFactory && hasValueSources) {\n+\t\t\tthrow new ExtensionConfigurationException(\n+\t\t\t\t\"CartesianProductTest can only take exactly one type of arguments source\");\n+\t\t}\n+\t}\n+\n+\tprivate List<List<?>> getSetsFromValue(Method testMethod, CartesianProductTest annotation) {\n+\t\tList<List<?>> sets = new ArrayList<>();\n+\t\tList<String> strings = Arrays.stream(annotation.value()).distinct().collect(toList());\n+\t\tfor (int i = 0; i < testMethod.getParameterTypes().length; i++) {\n+\t\t\tsets.add(strings);\n+\t\t}\n+\t\treturn sets;\n+\t}\n+\n+\tprivate List<List<?>> getSetsFromRepeatableAnnotation(List<CartesianValueSource> valueSources) {\n+\t\tList<List<?>> sets = new ArrayList<>();\n+\t\tfor (CartesianValueSource source : valueSources) {\n+\t\t\tCartesianValueArgumentsProvider provider = new CartesianValueArgumentsProvider();\n+\t\t\tprovider.accept(source);\n+\t\t\tList<Object> collect = provider.provideArguments().distinct().collect(toList());\n+\t\t\tsets.add(collect);\n+\t\t}\n+\t\treturn sets;\n+\t}\n+\n+\tprivate List<List<?>> getSetsFromStaticFactory(Method testMethod, String explicitFactoryName) {\n+\t\tif (explicitFactoryName.isEmpty())\n+\t\t\treturn invokeSetsFactory(testMethod, testMethod.getName()).getSets();\n+\t\telse\n+\t\t\treturn invokeSetsFactory(testMethod, explicitFactoryName).getSets();\n+\t}\n+\n+\tprivate CartesianProductTest.Sets invokeSetsFactory(Method testMethod, String factoryMethodName) {\n+\t\tClass<?> declaringClass = testMethod.getDeclaringClass();\n+\t\tMethod factory = PioneerUtils\n+\t\t\t\t.findMethodCurrentOrEnclosing(declaringClass, factoryMethodName)\n+\t\t\t\t.orElseThrow(() -> new ExtensionConfigurationException(\"Method `CartesianProductTest.Sets \"\n+\t\t\t\t\t\t+ factoryMethodName + \"()` not found in \" + declaringClass + \"or any enclosing class\"));\n+\t\tString method = \"Method `\" + factory + \"`\";\n+\t\tif (!Modifier.isStatic(factory.getModifiers())) {\n+\t\t\tthrow new ExtensionConfigurationException(method + \" must be static\");\n+\t\t}\n+\t\tif (!CartesianProductTest.Sets.class.isAssignableFrom(factory.getReturnType())) {\n+\t\t\tthrow new ExtensionConfigurationException(method + \" must return `CartesianProductTest.Sets`\");\n+\t\t}\n+\t\tCartesianProductTest.Sets sets = (CartesianProductTest.Sets) invokeMethod(factory, null);\n+\t\tif (sets.getSets().size() > testMethod.getParameterCount()) {\n+\t\t\tthrow new ParameterResolutionException(format(\n+\t\t\t\t\"%s must register values for each parameter exactly once. Expected [%d] parameter sets, but got [%d]\",\n+\t\t\t\tmethod, testMethod.getParameterCount(), sets.getSets().size()));\n+\t\t}", "originalCommit": "c8f3dc487f68d97135153352b70662bb06029ccf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk4ODMyOA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r496988328", "bodyText": "Can't, JUnit throws an exception before we get here - competing ParameterResolvers.", "author": "Michael1993", "createdAt": "2020-09-29T19:26:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3MjA5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAyMTE3Mg==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r497021172", "bodyText": "Oh, good to know! Can you add a comment saying as much?", "author": "nipafx", "createdAt": "2020-09-29T20:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3MjA5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3Mjc5OQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r496972799", "bodyText": "I really like it that this is its own class. \ud83d\udc4d", "author": "nipafx", "createdAt": "2020-09-29T19:07:27Z", "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestNameFormatter.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static java.util.stream.Collectors.joining;\n+import static org.junit.jupiter.params.ParameterizedTest.ARGUMENTS_PLACEHOLDER;\n+import static org.junit.jupiter.params.ParameterizedTest.DISPLAY_NAME_PLACEHOLDER;\n+import static org.junit.jupiter.params.ParameterizedTest.INDEX_PLACEHOLDER;\n+\n+import java.text.MessageFormat;\n+import java.util.Arrays;\n+import java.util.stream.IntStream;\n+\n+import org.junit.jupiter.api.extension.ExtensionConfigurationException;\n+\n+class CartesianProductTestNameFormatter {", "originalCommit": "c8f3dc487f68d97135153352b70662bb06029ccf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0860c8e6c86aeb499de8a51293c2a49434252ac1", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/0860c8e6c86aeb499de8a51293c2a49434252ac1", "message": "DEATH TO SPOTLESS! \u2620 \u2620 \u2620", "committedDate": "2020-09-29T19:32:56Z", "type": "commit"}, {"oid": "dec19903d8879268e1aa3fca96fa751eefa4f7b5", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/dec19903d8879268e1aa3fca96fa751eefa4f7b5", "message": "Add comment about why equality is not checked", "committedDate": "2020-10-04T14:30:37Z", "type": "commit"}, {"oid": "6c7d1d05b73b25826ed60ce0c7b1b07ab7009e97", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/6c7d1d05b73b25826ed60ce0c7b1b07ab7009e97", "message": "Add/expand basic documentation", "committedDate": "2020-10-04T14:49:14Z", "type": "commit"}, {"oid": "c89cf05ba600a1b365902b2d1e5a7a1032593051", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/c89cf05ba600a1b365902b2d1e5a7a1032593051", "message": "Merge branch 'issue/68-cartesian-product-extension' of https://github.com/Michael1993/junit-pioneer into issue/68-cartesian-product-extension", "committedDate": "2020-10-04T14:49:38Z", "type": "commit"}, {"oid": "26c0bbb8059f0f1e43149670ba43b30712e0b993", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/26c0bbb8059f0f1e43149670ba43b30712e0b993", "message": "Improve Javadoc", "committedDate": "2020-10-06T18:39:30Z", "type": "commit"}, {"oid": "6c0be910fc1cfd07fcddd38c8e3c2e7f03ed91a7", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/6c0be910fc1cfd07fcddd38c8e3c2e7f03ed91a7", "message": "Fix Javadoc", "committedDate": "2020-10-06T18:44:50Z", "type": "commit"}]}