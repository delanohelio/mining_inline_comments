{"pr_number": 368, "pr_title": "DisableIfArgument", "pr_createdAt": "2020-10-31T14:14:13Z", "pr_url": "https://github.com/junit-pioneer/junit-pioneer/pull/368", "timeline": [{"oid": "d99e74b0ad59b0f87772645e1b913855b41b7413", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/d99e74b0ad59b0f87772645e1b913855b41b7413", "message": "Created PoC extension for disabling parameterized tests\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-09-26T07:14:48Z", "type": "commit"}, {"oid": "62bf604755b6462546e631b2009391eabcd344ca", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/62bf604755b6462546e631b2009391eabcd344ca", "message": "Merge branch 'master' into issue313/explore-invocation-interceptor", "committedDate": "2020-10-31T13:38:41Z", "type": "commit"}, {"oid": "d223cfd1596489d15221c2e71e75590e361cbfb6", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/d223cfd1596489d15221c2e71e75590e361cbfb6", "message": "Replaced value() with contains() and matches()\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-10-31T14:09:24Z", "type": "commit"}, {"oid": "9574ea83dce2b4c14a0913e17b146b9b4366ec11", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/9574ea83dce2b4c14a0913e17b146b9b4366ec11", "message": "Disable based on containing and RegEx\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-10-31T14:09:57Z", "type": "commit"}, {"oid": "0168cc15df4ba7d5fc3b7ddc9e1ce7fd83a84b42", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/0168cc15df4ba7d5fc3b7ddc9e1ce7fd83a84b42", "message": "Updated tests\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-10-31T14:10:08Z", "type": "commit"}, {"oid": "c4e357622f56e41347b140e3b60c3534f4d65f08", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/c4e357622f56e41347b140e3b60c3534f4d65f08", "message": "Spotless, no :(\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-10-31T14:10:32Z", "type": "commit"}, {"oid": "f9f46c8d6d6290c2bbc72f07e5e87e90a6a92a78", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/f9f46c8d6d6290c2bbc72f07e5e87e90a6a92a78", "message": "Add documentation based on DisableIfDisplayName\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-11-02T17:18:03Z", "type": "commit"}, {"oid": "81fddd97f9565848f2bc59aafc8ffb116c66d5a4", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/81fddd97f9565848f2bc59aafc8ffb116c66d5a4", "message": "README.md updated to include contribution\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-11-02T17:18:28Z", "type": "commit"}, {"oid": "98663ed3122bc85a65555e745c89c374f5e2f9c2", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/98663ed3122bc85a65555e745c89c374f5e2f9c2", "message": "Simplify orElseThrow\n(no, not because this will make Sonar consider it 100% covered, why would you think that?)\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-11-02T17:19:37Z", "type": "commit"}, {"oid": "2cfc8c11f960cc91bc8a6e0cace0bdda64cf404b", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/2cfc8c11f960cc91bc8a6e0cace0bdda64cf404b", "message": "Update tests to include a poem (Oscar Wilde: Requiescat)\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-11-02T17:20:02Z", "type": "commit"}, {"oid": "b85e3e0be0cb5bf66d562916c155cea3d847d995", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/b85e3e0be0cb5bf66d562916c155cea3d847d995", "message": "Update package-info.java with the new addition\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-11-02T17:24:14Z", "type": "commit"}, {"oid": "5643ebf0da2b99ec1998471fc2a67a60c693ca6c", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/5643ebf0da2b99ec1998471fc2a67a60c693ca6c", "message": "Fix comma typo\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-11-02T17:25:48Z", "type": "commit"}, {"oid": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1", "message": "Add references to contribution\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-11-02T17:28:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzMTU5MA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516831590", "bodyText": "Why (almost) all uppercase?\nedit: I see - we do it everywhere.... /edit", "author": "Bukama", "createdAt": "2020-11-03T17:19:09Z", "path": "docs/disable-if-parameter.adoc", "diffHunk": "@@ -0,0 +1,83 @@\n+:page-title: Disable Parameterized Test Based on Parameter Values", "originalCommit": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzMzc2NA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516833764", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfParameter` is validated before each parameterized test execution.\n          \n          \n            \n            Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation, `@DisableIfParameter` is validated before each execution of a parameterized test .\n          \n      \n    \n    \n  \n\nAside the wrong space, I think this is better to understand.", "author": "Bukama", "createdAt": "2020-11-03T17:22:11Z", "path": "docs/disable-if-parameter.adoc", "diffHunk": "@@ -0,0 +1,83 @@\n+:page-title: Disable Parameterized Test Based on Parameter Values\n+:page-description: Extends JUnit Jupiter with `@DisableIfParameter`, which selectively disables parameterized tests\n+\n+The `@DisableIfParameter` annotation can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfParameter` is validated before each parameterized test execution.", "originalCommit": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzNDkwNQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516834905", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As a consequence, instead of disabling the entire set of parameterized tests, each test can be evaluated and possibly disabled individually.\n          \n          \n            \n            As a consequence, instead of disabling the entire set of parameterized tests, each test is evaluated and possibly disabled individually.", "author": "Bukama", "createdAt": "2020-11-03T17:24:00Z", "path": "docs/disable-if-parameter.adoc", "diffHunk": "@@ -0,0 +1,83 @@\n+:page-title: Disable Parameterized Test Based on Parameter Values\n+:page-description: Extends JUnit Jupiter with `@DisableIfParameter`, which selectively disables parameterized tests\n+\n+The `@DisableIfParameter` annotation can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfParameter` is validated before each parameterized test execution.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test can be evaluated and possibly disabled individually.", "originalCommit": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzNzUyNA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516837524", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The first invocation because the first parameter contains \"bright\".\n          \n          \n            \n            The second invocation because the second parameter contains \"dust\".\n          \n          \n            \n            The first invocation got disabled, because the first parameter contains \"bright\".\n          \n          \n            \n            The second execution got skipped, because the other parameter contains \"dust\".", "author": "Bukama", "createdAt": "2020-11-03T17:28:06Z", "path": "docs/disable-if-parameter.adoc", "diffHunk": "@@ -0,0 +1,83 @@\n+:page-title: Disable Parameterized Test Based on Parameter Values\n+:page-description: Extends JUnit Jupiter with `@DisableIfParameter`, which selectively disables parameterized tests\n+\n+The `@DisableIfParameter` annotation can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfParameter` is validated before each parameterized test execution.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test can be evaluated and possibly disabled individually.\n+\n+[source,java]\n+----\n+// disable invocations whose parameter contains \"she\"\n+@DisableIfParameter(contains = \"she\")\n+@ParameterizedTest\n+@ValueSource(strings = {\n+        \"Tread lightly, she is near\",\n+        \"Under the snow,\",\n+        \"Speak gently, she can hear\",\n+        \"The daisies grow.\"\n+})\n+void interceptContains(String line) {\n+}\n+----\n+\n+The test `interceptContains` ordinarily would run four times, but because the first and third lines contain the word \"she\", those invocations get disabled.\n+\n+You can specify more than one substring at a time:\n+\n+[source,java]\n+----\n+@DisableIfParameter(contains = { \"bright\", \"dust\" })\n+@ParameterizedTest\n+@CsvSource(delimiter = ';', value = {\n+        \"All her bright golden hair;Tarnished with rust,\",\n+        \"She that was young and fair;Fallen to dust.\"\n+})\n+void interceptContainsAny(String line, String line2) {\n+}\n+----\n+\n+`DisableIfParameter` will disable the test invocation if any parameter value matches any value from `contains`.\n+In this case, the test `interceptContainsAny` should have run two times, but both invocations got disabled.\n+The first invocation because the first parameter contains \"bright\".\n+The second invocation because the second parameter contains \"dust\".", "originalCommit": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzNzk2Ng==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516837966", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If substrings are not powerful enough, you can also use regular expressions:\n          \n          \n            \n            If substrings are not powerful enough, you can also use regular expressions, using the `matches` value:", "author": "Bukama", "createdAt": "2020-11-03T17:28:51Z", "path": "docs/disable-if-parameter.adoc", "diffHunk": "@@ -0,0 +1,83 @@\n+:page-title: Disable Parameterized Test Based on Parameter Values\n+:page-description: Extends JUnit Jupiter with `@DisableIfParameter`, which selectively disables parameterized tests\n+\n+The `@DisableIfParameter` annotation can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfParameter` is validated before each parameterized test execution.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test can be evaluated and possibly disabled individually.\n+\n+[source,java]\n+----\n+// disable invocations whose parameter contains \"she\"\n+@DisableIfParameter(contains = \"she\")\n+@ParameterizedTest\n+@ValueSource(strings = {\n+        \"Tread lightly, she is near\",\n+        \"Under the snow,\",\n+        \"Speak gently, she can hear\",\n+        \"The daisies grow.\"\n+})\n+void interceptContains(String line) {\n+}\n+----\n+\n+The test `interceptContains` ordinarily would run four times, but because the first and third lines contain the word \"she\", those invocations get disabled.\n+\n+You can specify more than one substring at a time:\n+\n+[source,java]\n+----\n+@DisableIfParameter(contains = { \"bright\", \"dust\" })\n+@ParameterizedTest\n+@CsvSource(delimiter = ';', value = {\n+        \"All her bright golden hair;Tarnished with rust,\",\n+        \"She that was young and fair;Fallen to dust.\"\n+})\n+void interceptContainsAny(String line, String line2) {\n+}\n+----\n+\n+`DisableIfParameter` will disable the test invocation if any parameter value matches any value from `contains`.\n+In this case, the test `interceptContainsAny` should have run two times, but both invocations got disabled.\n+The first invocation because the first parameter contains \"bright\".\n+The second invocation because the second parameter contains \"dust\".\n+\n+If substrings are not powerful enough, you can also use regular expressions:", "originalCommit": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzOTEzMA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516839130", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can use both, in which case a test is disabled if any parameter value contains a substring _or_ matches an expression:\n          \n          \n            \n            You can also combine both options.\n          \n          \n            \n            When doing so, test is disabled if any parameter value contains a substring _or_ matches an expression:", "author": "Bukama", "createdAt": "2020-11-03T17:30:44Z", "path": "docs/disable-if-parameter.adoc", "diffHunk": "@@ -0,0 +1,83 @@\n+:page-title: Disable Parameterized Test Based on Parameter Values\n+:page-description: Extends JUnit Jupiter with `@DisableIfParameter`, which selectively disables parameterized tests\n+\n+The `@DisableIfParameter` annotation can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfParameter` is validated before each parameterized test execution.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test can be evaluated and possibly disabled individually.\n+\n+[source,java]\n+----\n+// disable invocations whose parameter contains \"she\"\n+@DisableIfParameter(contains = \"she\")\n+@ParameterizedTest\n+@ValueSource(strings = {\n+        \"Tread lightly, she is near\",\n+        \"Under the snow,\",\n+        \"Speak gently, she can hear\",\n+        \"The daisies grow.\"\n+})\n+void interceptContains(String line) {\n+}\n+----\n+\n+The test `interceptContains` ordinarily would run four times, but because the first and third lines contain the word \"she\", those invocations get disabled.\n+\n+You can specify more than one substring at a time:\n+\n+[source,java]\n+----\n+@DisableIfParameter(contains = { \"bright\", \"dust\" })\n+@ParameterizedTest\n+@CsvSource(delimiter = ';', value = {\n+        \"All her bright golden hair;Tarnished with rust,\",\n+        \"She that was young and fair;Fallen to dust.\"\n+})\n+void interceptContainsAny(String line, String line2) {\n+}\n+----\n+\n+`DisableIfParameter` will disable the test invocation if any parameter value matches any value from `contains`.\n+In this case, the test `interceptContainsAny` should have run two times, but both invocations got disabled.\n+The first invocation because the first parameter contains \"bright\".\n+The second invocation because the second parameter contains \"dust\".\n+\n+If substrings are not powerful enough, you can also use regular expressions:\n+\n+[source,java]\n+----\n+// disable invocations whose parameter ends with 'knew' or 'grew'\n+@DisableIfParameter(matches = { \".*knew\", \".*grew\" })\n+@ParameterizedTest\n+@ValueSource(strings = {\n+        \"Lily-like, white as snow,\",\n+        \"She hardly knew\",\n+        \"She was a woman, so\",\n+        \"Sweetly she grew\"\n+})\n+void interceptMatches(String value) {\n+}\n+----\n+\n+The second invocation has a parameter that ends with \"knew\", so it gets disabled.\n+The fourth invocation has a parameter that ends with \"grew\", so it gets disabled.\n+\n+Just like with `contains`, if any parameter value matches any expression from `matches`, the invocation gets disabled.\n+\n+You can use both, in which case a test is disabled if any parameter value contains a substring _or_ matches an expression:", "originalCommit": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzOTg3NQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516839875", "bodyText": "To align this tests with the others, and because the regex is not so easy to read like the ones above I would suggest to also add an explanation, which tests are executed and which are not.", "author": "Bukama", "createdAt": "2020-11-03T17:31:59Z", "path": "docs/disable-if-parameter.adoc", "diffHunk": "@@ -0,0 +1,83 @@\n+:page-title: Disable Parameterized Test Based on Parameter Values\n+:page-description: Extends JUnit Jupiter with `@DisableIfParameter`, which selectively disables parameterized tests\n+\n+The `@DisableIfParameter` annotation can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfParameter` is validated before each parameterized test execution.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test can be evaluated and possibly disabled individually.\n+\n+[source,java]\n+----\n+// disable invocations whose parameter contains \"she\"\n+@DisableIfParameter(contains = \"she\")\n+@ParameterizedTest\n+@ValueSource(strings = {\n+        \"Tread lightly, she is near\",\n+        \"Under the snow,\",\n+        \"Speak gently, she can hear\",\n+        \"The daisies grow.\"\n+})\n+void interceptContains(String line) {\n+}\n+----\n+\n+The test `interceptContains` ordinarily would run four times, but because the first and third lines contain the word \"she\", those invocations get disabled.\n+\n+You can specify more than one substring at a time:\n+\n+[source,java]\n+----\n+@DisableIfParameter(contains = { \"bright\", \"dust\" })\n+@ParameterizedTest\n+@CsvSource(delimiter = ';', value = {\n+        \"All her bright golden hair;Tarnished with rust,\",\n+        \"She that was young and fair;Fallen to dust.\"\n+})\n+void interceptContainsAny(String line, String line2) {\n+}\n+----\n+\n+`DisableIfParameter` will disable the test invocation if any parameter value matches any value from `contains`.\n+In this case, the test `interceptContainsAny` should have run two times, but both invocations got disabled.\n+The first invocation because the first parameter contains \"bright\".\n+The second invocation because the second parameter contains \"dust\".\n+\n+If substrings are not powerful enough, you can also use regular expressions:\n+\n+[source,java]\n+----\n+// disable invocations whose parameter ends with 'knew' or 'grew'\n+@DisableIfParameter(matches = { \".*knew\", \".*grew\" })\n+@ParameterizedTest\n+@ValueSource(strings = {\n+        \"Lily-like, white as snow,\",\n+        \"She hardly knew\",\n+        \"She was a woman, so\",\n+        \"Sweetly she grew\"\n+})\n+void interceptMatches(String value) {\n+}\n+----\n+\n+The second invocation has a parameter that ends with \"knew\", so it gets disabled.\n+The fourth invocation has a parameter that ends with \"grew\", so it gets disabled.\n+\n+Just like with `contains`, if any parameter value matches any expression from `matches`, the invocation gets disabled.\n+\n+You can use both, in which case a test is disabled if any parameter value contains a substring _or_ matches an expression:\n+\n+[source,java]\n+----\n+@ParameterizedTest\n+@DisableIfParameter(\n+        contains = { \"sonnet\", \"life\" },\n+        matches = \"^.*(.+)\\\\1.*$\")\n+@ValueSource(strings = {\n+        \"Peace, Peace, she cannot hear\",\n+        \"Lyre or sonnet,\",\n+        \"All my life\u2019s buried here,\",\n+        \"Heap earth upon it.\"\n+})\n+void interceptBoth(String value) {\n+}\n+----", "originalCommit": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0MzE1MQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516843151", "bodyText": "To me the messages is misleading. If the annotation is present, e.g. with contains, then for me it is specified, but as an empty set. I would rephrase to something like \"specified with at least one element, but both are empty\"", "author": "Bukama", "createdAt": "2020-11-03T17:37:32Z", "path": "src/main/java/org/junitpioneer/jupiter/params/DisableIfParameterExtension.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter.params;\n+\n+import static java.lang.String.format;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+import org.junit.jupiter.api.extension.ExtensionConfigurationException;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.InvocationInterceptor;\n+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+import org.opentest4j.TestAbortedException;\n+\n+class DisableIfParameterExtension implements InvocationInterceptor {\n+\n+\t@Override\n+\tpublic void interceptTestTemplateMethod(Invocation<Void> invocation,\n+\t\t\tReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {\n+\t\tMethod testMethod = extensionContext.getRequiredTestMethod();\n+\t\tDisableIfParameter annotation = AnnotationSupport\n+\t\t\t\t.findAnnotation(testMethod, DisableIfParameter.class)\n+\t\t\t\t.orElseThrow(() -> new ExtensionConfigurationException(\"@DisableIfParameter is missing\"));\n+\t\tif (annotation.contains().length == 0 && annotation.matches().length == 0)\n+\t\t\tthrow new ExtensionConfigurationException(\n+\t\t\t\tformat(\"%s requires that either `contains` or `matches` is specified, but both are empty.\",\n+\t\t\t\t\tDisableIfParameter.class.getSimpleName()));", "originalCommit": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NDEzNA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516844134", "bodyText": "To other reviewers: I asked @Michael1993 to add those comments, while we was working on the extension on stream, because the two checks look realy the same, but differ in one word in the middle of them, which I didn't mention at the beginning. With the comments I think its more readable.", "author": "Bukama", "createdAt": "2020-11-03T17:39:08Z", "path": "src/main/java/org/junitpioneer/jupiter/params/DisableIfParameterExtension.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter.params;\n+\n+import static java.lang.String.format;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+import org.junit.jupiter.api.extension.ExtensionConfigurationException;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.InvocationInterceptor;\n+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+import org.opentest4j.TestAbortedException;\n+\n+class DisableIfParameterExtension implements InvocationInterceptor {\n+\n+\t@Override\n+\tpublic void interceptTestTemplateMethod(Invocation<Void> invocation,\n+\t\t\tReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {\n+\t\tMethod testMethod = extensionContext.getRequiredTestMethod();\n+\t\tDisableIfParameter annotation = AnnotationSupport\n+\t\t\t\t.findAnnotation(testMethod, DisableIfParameter.class)\n+\t\t\t\t.orElseThrow(() -> new ExtensionConfigurationException(\"@DisableIfParameter is missing\"));\n+\t\tif (annotation.contains().length == 0 && annotation.matches().length == 0)\n+\t\t\tthrow new ExtensionConfigurationException(\n+\t\t\t\tformat(\"%s requires that either `contains` or `matches` is specified, but both are empty.\",\n+\t\t\t\t\tDisableIfParameter.class.getSimpleName()));\n+\t\t// Check if any argument contains any element from 'contains'", "originalCommit": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NzkwNw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516847907", "bodyText": "I'm confused why\n\nyou don't check for the particular exceptions you throw\nWhy sonar claims full coverage (speaking of the part with the three different exceptions)\n\n\ud83e\udd37\u200d\u2642\ufe0f", "author": "Bukama", "createdAt": "2020-11-03T17:45:19Z", "path": "src/test/java/org/junitpioneer/jupiter/params/DisableIfParameterExtensionTests.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter.params;\n+\n+import static org.junitpioneer.testkit.assertion.PioneerAssert.assertThat;\n+\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.junitpioneer.testkit.ExecutionResults;\n+import org.junitpioneer.testkit.PioneerTestKit;\n+\n+/**\n+ * Oscar Wilde: Requiescat is in the public domain\n+ */\n+@DisplayName(\"DisableIfParameterExtension\")\n+class DisableIfParameterExtensionTests {\n+\n+\t@Nested\n+\t@DisplayName(\"when configured correctly\")\n+\tclass CorrectConfigurationTests {\n+\n+\t\t@Test\n+\t\t@DisplayName(\"disables tests when parameter contains any value from the 'contains' array\")\n+\t\tvoid interceptContains() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(CorrectConfigTestCases.class, \"interceptContains\",\n+\t\t\t\t\t\tString.class);\n+\n+\t\t\tassertThat(results).hasNumberOfSucceededTests(2).hasNumberOfAbortedTests(2);\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"disables tests when any parameter contains any value from the 'contains' array\")\n+\t\tvoid interceptContainsAny() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(CorrectConfigTestCases.class, \"interceptContainsAny\",\n+\t\t\t\t\t\tString.class, String.class);\n+\n+\t\t\tassertThat(results).hasNumberOfAbortedTests(2);\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"disables tests when parameter matches any regex from the 'matches' array\")\n+\t\tvoid interceptMatches() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(CorrectConfigTestCases.class, \"interceptMatches\",\n+\t\t\t\t\t\tString.class);\n+\n+\t\t\tassertThat(results).hasNumberOfSucceededTests(2).hasNumberOfAbortedTests(2);\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"disables tests when any parameter matches any regex from the 'matches' array\")\n+\t\tvoid interceptMatchesAny() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(CorrectConfigTestCases.class, \"interceptMatchesAny\",\n+\t\t\t\t\t\tString.class, String.class);\n+\n+\t\t\tassertThat(results).hasNumberOfAbortedTests(2);\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"disables tests if parameter matches regex from 'matches' or contains value from 'contains'\")\n+\t\tvoid interceptMatchesAndContains() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(CorrectConfigTestCases.class, \"interceptBoth\", String.class);\n+\n+\t\t\tassertThat(results).hasNumberOfSucceededTests(1).hasNumberOfAbortedTests(3);\n+\t\t}\n+\n+\t}\n+\n+\t@Nested\n+\t@DisplayName(\"when not configured correctly\")\n+\tclass MisconfigurationTests {\n+\n+\t\t@Test\n+\t\t@DisplayName(\"throws an exception if both 'matches' and 'contains' is missing\")\n+\t\tvoid missingValues() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigTestCases.class, \"missingValues\", String.class);\n+\n+\t\t\tassertThat(results).hasNumberOfFailedTests(3);\n+\t\t}\n+\n+\t}", "originalCommit": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTIxMzA2Mg==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r519213062", "bodyText": "Do you mean the TestAbortedException?", "author": "Michael1993", "createdAt": "2020-11-07T20:02:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NzkwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTM1NDU4Nw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r519354587", "bodyText": "I mean you have three checks about misconfiguration you do in the extension, but only one test case and I don't get why SONAR does not complain \ud83e\udd37\u200d\u2642\ufe0f", "author": "Bukama", "createdAt": "2020-11-08T11:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NzkwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1NTA5OA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r520355098", "bodyText": "It's line coverage, not part coverage. If the line is called, it's considered covered. Example:\n/* 100% coverage */\nOptional.of(new Object())\n.orElseThrow(() -> new RuntimeException(\"Never thrown!\"));\n\n/* < 100% coverage */\nOptional.of(new Object())\n.orElseThrow(\n    () -> new RuntimeException(\"Never thrown!\")\n);", "author": "Michael1993", "createdAt": "2020-11-10T07:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NzkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE2NDEzNw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r519164137", "bodyText": "Two suggestions:\n\n\nSince we are dealing with parameterized tests and also the annotation uses the term \"parameter\", we might want to adopt this instead of \"argument\" (even if the invocation context says getArguments()).\n\n\nMore a matter of taste, but you could split things up into several methods.\n\n\nExample:\n@Override\npublic void interceptTestTemplateMethod(Invocation<Void> invocation,\n\t\tReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {\n\tMethod testMethod = extensionContext.getRequiredTestMethod();\n\tDisableIfParameter annotation = AnnotationSupport\n\t\t\t.findAnnotation(testMethod, DisableIfParameter.class)\n\t\t\t.orElseThrow(() -> new ExtensionConfigurationException(\"@DisableIfParameter is missing\"));\n\tif (annotation.contains().length == 0 && annotation.matches().length == 0)\n\t\tthrow new ExtensionConfigurationException(\n\t\t\tformat(\"%s requires that either `contains` or `matches` is specified, but both are empty.\",\n\t\t\t\tDisableIfParameter.class.getSimpleName()));\n\ttestContains(invocationContext, annotation);\n\ttestMatches(invocationContext, annotation);\n\tinvocation.proceed();\n}\n\nprivate void testMatches(ReflectiveInvocationContext<Method> invocationContext, DisableIfParameter annotation) {\n\tPredicate<Object> matchesParam = param -> Arrays\n\t\t\t.stream(annotation.matches())\n\t\t\t.anyMatch(param.toString()::matches);\n\tString matchesMessage = \"One or more parameters matched a regular expression from the `matches` array.\";\n\ttestParams(invocationContext, matchesParam, matchesMessage);\n}\n\nprivate void testContains(ReflectiveInvocationContext<Method> invocationContext, DisableIfParameter annotation) {\n\tPredicate<Object> containsParam = param -> Arrays\n\t\t\t.stream(annotation.contains())\n\t\t\t.anyMatch(param.toString()::contains);\n\tString containsMessage = \"One or more parameters contained a value from the `contains` array.\";\n\ttestParams(invocationContext, containsParam, containsMessage);\n}\n\nprivate void testParams(ReflectiveInvocationContext<Method> invocationContext, Predicate<Object> predicate,\n\t\tString message) {\n\tif (invocationContext.getArguments().stream().anyMatch(predicate))\n\t\tthrow new TestAbortedException(message);\n}", "author": "beatngu13", "createdAt": "2020-11-07T10:48:40Z", "path": "src/main/java/org/junitpioneer/jupiter/params/DisableIfParameterExtension.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter.params;\n+\n+import static java.lang.String.format;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+import org.junit.jupiter.api.extension.ExtensionConfigurationException;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.InvocationInterceptor;\n+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+import org.opentest4j.TestAbortedException;\n+\n+class DisableIfParameterExtension implements InvocationInterceptor {\n+\n+\t@Override\n+\tpublic void interceptTestTemplateMethod(Invocation<Void> invocation,", "originalCommit": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE2NTQ0NQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r519165445", "bodyText": "Kudos for using <em> instead of <i>! \ud83d\udc4d", "author": "beatngu13", "createdAt": "2020-11-07T11:03:40Z", "path": "src/main/java/org/junitpioneer/jupiter/params/DisableIfParameter.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter.params;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+/**\n+ * {@code @DisableIfParameter} is a JUnit Jupiter extension that can\n+ * be used to selectively disable a {@link org.junit.jupiter.params.ParameterizedTest}\n+ * based on their parameter values as defined by {@link Object#toString()}.\n+ *\n+ * <p>The extension utilizes Jupiter's {@link org.junit.jupiter.api.extension.InvocationInterceptor}.\n+ * It's important to note that since it's marked as {@link org.apiguardian.api.API.Status#EXPERIMENTAL}\n+ * it might be removed without prior notice.\n+ * Unlike {@link org.junit.jupiter.api.Disabled} annotations, this extension doesn't disable the whole test method.\n+ * With {@code DisableIfParameter}, it is possible to selectively disable tests out of the plethora\n+ * of dynamically registered parameterized tests.</p>\n+ *\n+ * <p>If neither {@link DisableIfParameter#contains() contains} nor\n+ * {@link DisableIfParameter#matches() matches} is configured, the extension will throw an exception.\n+ * It is possible to configure both, in which case the test gets disabled if at least one substring\n+ * was found <em>or</em> at least one regular expression matched.</p>", "originalCommit": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE2NTc0Nw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r519165747", "bodyText": "Does it make sense to add minimal Javadoc referring to String#contains and String#matches?", "author": "beatngu13", "createdAt": "2020-11-07T11:07:01Z", "path": "src/main/java/org/junitpioneer/jupiter/params/DisableIfParameter.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter.params;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+/**\n+ * {@code @DisableIfParameter} is a JUnit Jupiter extension that can\n+ * be used to selectively disable a {@link org.junit.jupiter.params.ParameterizedTest}\n+ * based on their parameter values as defined by {@link Object#toString()}.\n+ *\n+ * <p>The extension utilizes Jupiter's {@link org.junit.jupiter.api.extension.InvocationInterceptor}.\n+ * It's important to note that since it's marked as {@link org.apiguardian.api.API.Status#EXPERIMENTAL}\n+ * it might be removed without prior notice.\n+ * Unlike {@link org.junit.jupiter.api.Disabled} annotations, this extension doesn't disable the whole test method.\n+ * With {@code DisableIfParameter}, it is possible to selectively disable tests out of the plethora\n+ * of dynamically registered parameterized tests.</p>\n+ *\n+ * <p>If neither {@link DisableIfParameter#contains() contains} nor\n+ * {@link DisableIfParameter#matches() matches} is configured, the extension will throw an exception.\n+ * It is possible to configure both, in which case the test gets disabled if at least one substring\n+ * was found <em>or</em> at least one regular expression matched.</p>\n+ *\n+ * @see DisableIfParameterExtension\n+ */\n+@Target(ElementType.METHOD)\n+@Retention(RetentionPolicy.RUNTIME)\n+@ExtendWith(DisableIfParameterExtension.class)\n+public @interface DisableIfParameter {\n+\n+\tString[] contains() default {};\n+\n+\tString[] matches() default {};", "originalCommit": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE2NjE1NA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r519166154", "bodyText": "I like that you refer to parameterized tests, maybe adapt the title here as well (i.e. \"Disable Parameterized Test Based on Display Name\").", "author": "beatngu13", "createdAt": "2020-11-07T11:11:49Z", "path": "docs/docs-nav.yml", "diffHunk": "@@ -12,6 +12,8 @@\n         url: /docs/default-locale-timezone/\n       - title: \"Disable Based on DisplayName\"", "originalCommit": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bbe9dd0fb827e72d3852c2ceabbcc202f3f2d295", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/bbe9dd0fb827e72d3852c2ceabbcc202f3f2d295", "message": "Update code and documentation according to feedback\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-11-10T18:54:39Z", "type": "commit"}, {"oid": "26fdcb591aea3299723ccd2e6af508f6eb489c25", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/26fdcb591aea3299723ccd2e6af508f6eb489c25", "message": "In progress DisableIfParameter\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-11-24T21:22:26Z", "type": "commit"}, {"oid": "ff66f8592cca97e484900ffee71b8323b3e5be3e", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/ff66f8592cca97e484900ffee71b8323b3e5be3e", "message": "No parameters can not be disabled.\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2020-12-22T18:42:43Z", "type": "commit"}, {"oid": "4b8d27b496dbd165a19f300e2e53c01fbe7b114c", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/4b8d27b496dbd165a19f300e2e53c01fbe7b114c", "message": "Update DisableIfParameter based on feedback\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2021-03-23T15:33:55Z", "type": "commit"}, {"oid": "c3459d95011d0b0bb8e5d1a459096d79a333fead", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/c3459d95011d0b0bb8e5d1a459096d79a333fead", "message": "Merge remote-tracking branch 'origin/main' into issue313/explore-invocation-interceptor\n\n# Conflicts:\n#\tREADME.md\n#\tdocs/docs-nav.yml\n#\tsrc/main/java/org/junitpioneer/jupiter/params/DisableIfNameExtension.java\n#\tsrc/test/java/org/junitpioneer/jupiter/params/DisabledIfNameExtensionTests.java", "committedDate": "2021-03-23T15:40:20Z", "type": "commit"}, {"oid": "a5bd7ca05d5163e2dfadb1fb2e46de2ebc5c499f", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/a5bd7ca05d5163e2dfadb1fb2e46de2ebc5c499f", "message": "Update tests and formatting\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2021-03-23T16:03:32Z", "type": "commit"}, {"oid": "b0e08e328c118396f5647b2be435ba26c6d150df", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/b0e08e328c118396f5647b2be435ba26c6d150df", "message": "Update tests\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2021-03-23T16:22:49Z", "type": "commit"}, {"oid": "8bb3765f7b96897e88fcf564ba5692187c39622e", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/8bb3765f7b96897e88fcf564ba5692187c39622e", "message": "Invalid input returns exception\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2021-03-23T17:16:25Z", "type": "commit"}, {"oid": "6903f5b84c35b650aabc6e003249ae402c62f003", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/6903f5b84c35b650aabc6e003249ae402c62f003", "message": "Invalid input returns exception, try #2\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2021-03-23T17:28:08Z", "type": "commit"}, {"oid": "b6886d0b08891c97f83bd452fa5fb5b0c94ba009", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/b6886d0b08891c97f83bd452fa5fb5b0c94ba009", "message": "Add another test\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2021-03-23T17:45:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDUyNDY4MA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r600524680", "bodyText": "I call this OK, cause the PR is from 2020 :D", "author": "Bukama", "createdAt": "2021-03-24T14:23:13Z", "path": "README.md", "diffHunk": "@@ -125,7 +125,7 @@ The least we can do is to thank them and list some of their accomplishments here\n * [Ignat Simonenko](https://github.com/simonenkoi) fixed a noteworthy bug in the default locale extension (#146 / #161)\n * [Mark R\u00f6sler](https://github.com/Hancho2009) contributed the [environment variable extension](https://junit-pioneer.org/docs/environment-variables/) (#167 / #174 and #241 / #242)\n * [Matthias B\u00fcnger](https://github.com/Bukama) opened, vetted, and groomed countless issues and PRs and contributed multiple refactorings (e.g. #165 / #168) and fixes (e.g. #190 / #200) before getting promoted to maintainer\n-* [Mih\u00e1ly Verh\u00e1s](https://github.com/Michael1993) contributed [the StdIO extension](https://junit-pioneer.org/docs/standard-input-output/) (#34 / #227), [the ReportEntryExtension](https://junit-pioneer.org/docs/report-entries/) (#134, #179 / #183, #216, #294), [the CartesianProductTestExtension](https://junit-pioneer.org/docs/cartesian-product/) (#321, #362 / #68, #354), added tests to other extensions (#164 / #272), the Pioneer assertions and contributed to multiple issues (e.g. #217 / #298) and PRs (e.g. #253, #307)\n+* [Mih\u00e1ly Verh\u00e1s](https://github.com/Michael1993) contributed [the StdIO extension](https://junit-pioneer.org/docs/standard-input-output/) (#34 / #227), [the ReportEntryExtension](https://junit-pioneer.org/docs/report-entries/) (#134, #179 / #183, #216, #294), [the CartesianProductTestExtension](https://junit-pioneer.org/docs/cartesian-product/) (#321, #362 / #68, #354), [the DisableIfParameterExtension](https://junit-pioneer.org/docs/disable-parameterized-tests/) (#313, #368) added tests to other extensions (#164 / #272), the Pioneer assertions and contributed to multiple issues (e.g. #217 / #298) and PRs (e.g. #253, #307)", "originalCommit": "b6886d0b08891c97f83bd452fa5fb5b0c94ba009", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDUyODk1Mw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r600528953", "bodyText": "Correct placeholder", "author": "Bukama", "createdAt": "2021-03-24T14:27:18Z", "path": "docs/disable-parameterized-tests.adoc", "diffHunk": "@@ -0,0 +1,250 @@\n+:page-title: Disable Parameterized Test\n+:page-description: Extends JUnit Jupiter with multiple extensions, which selectively disables parameterized tests\n+\n+JUnit Pioneer offers multiple extensions for selectively disabling parameterized tests.\n+These are as follows:\n+\n+- DisableIfDisplayName\n+- DisableIfParameter\n+\n+== DisableIfDisplayName\n+\n+\n+The `@DisableIfDisplayName` annotation can be used to selectively disable parameterized tests based on their display names, which are dynamically registered on runtime.\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfDisplayName` is validated before each parameterized test execution.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test (name) can be evaluated and possibly disabled individually.\n+\n+[source,java]\n+----\n+// disable invocations whose display name contains \"disable\"\n+@DisableIfDisplayName(contains = \"disable\")\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(\n+\t// Disabled: 1,2,3,4,5\n+\t// Not disabled: 6\n+\tstrings = {\n+\t\t\"disable who\", // 1\n+\t\t\"you, disable you\", // 2\n+\t\t\"why am I disabled\", // 3\n+\t\t\"what has been disabled must stay disabled\", // 4\n+\t\t\"fine disable me all you want\", // 5\n+\t\t\"not those one, though!\" // 6\n+\t}\n+)\n+void testExecutionDisabled(String reason) {\n+\tif (reason.contains(\"disable\"))\n+\t\tfail(\"Test should've been disabled \" + reason);\n+}\n+----\n+\n+You can also specify more than one substring at a time:\n+\n+[source,java]\n+----\n+@DisableIfDisplayName(contains = {\"1\", \"2\"})\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(ints = { 1, 2, 3, 4, 5 })\n+void testDisplayNameString(int num) {\n+\tif (num == 1 || num == 2)\n+\t\tfail(\"Test should've been disabled for \" + num);\n+}\n+----\n+\n+If substrings are not powerful enough, you can also use regular expressions:\n+\n+[source,java]\n+----\n+// disable invocations whose display name\n+// contains \"disable \" or \"disabled \"\n+@DisableIfDisplayName(matches = \".*disabled?\\\\s.*\")\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(\n+\t// Disabled: 1,2,4,5\n+\t// Not disabled: 3,6\n+\tstrings = {\n+\t\t\"disable who\", // 1\n+\t\t\"you, disable you\", // 2\n+\t\t\"why am I disabled\", // 3\n+\t\t\"what has been disabled must stay disabled\", // 4\n+\t\t\"fine disable me all you want\", // 5\n+\t\t\"not those one, though!\" // 6\n+\t}\n+)\n+void single(String reason) {\n+\t// ...\n+}\n+----\n+\n+Using both `matches` and `contains` in a single annotation is no longer permitted as of {VERSION_OR_DATE_PLACHOLDER}.", "originalCommit": "b6886d0b08891c97f83bd452fa5fb5b0c94ba009", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDUzMDQ4MQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r600530481", "bodyText": "I would add (yes add, not move) the information about case-sensetive to the general information about the disableIfParameter too, cause important.\nSo the general information and here an example for it", "author": "Bukama", "createdAt": "2021-03-24T14:28:44Z", "path": "docs/disable-parameterized-tests.adoc", "diffHunk": "@@ -0,0 +1,250 @@\n+:page-title: Disable Parameterized Test\n+:page-description: Extends JUnit Jupiter with multiple extensions, which selectively disables parameterized tests\n+\n+JUnit Pioneer offers multiple extensions for selectively disabling parameterized tests.\n+These are as follows:\n+\n+- DisableIfDisplayName\n+- DisableIfParameter\n+\n+== DisableIfDisplayName\n+\n+\n+The `@DisableIfDisplayName` annotation can be used to selectively disable parameterized tests based on their display names, which are dynamically registered on runtime.\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfDisplayName` is validated before each parameterized test execution.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test (name) can be evaluated and possibly disabled individually.\n+\n+[source,java]\n+----\n+// disable invocations whose display name contains \"disable\"\n+@DisableIfDisplayName(contains = \"disable\")\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(\n+\t// Disabled: 1,2,3,4,5\n+\t// Not disabled: 6\n+\tstrings = {\n+\t\t\"disable who\", // 1\n+\t\t\"you, disable you\", // 2\n+\t\t\"why am I disabled\", // 3\n+\t\t\"what has been disabled must stay disabled\", // 4\n+\t\t\"fine disable me all you want\", // 5\n+\t\t\"not those one, though!\" // 6\n+\t}\n+)\n+void testExecutionDisabled(String reason) {\n+\tif (reason.contains(\"disable\"))\n+\t\tfail(\"Test should've been disabled \" + reason);\n+}\n+----\n+\n+You can also specify more than one substring at a time:\n+\n+[source,java]\n+----\n+@DisableIfDisplayName(contains = {\"1\", \"2\"})\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(ints = { 1, 2, 3, 4, 5 })\n+void testDisplayNameString(int num) {\n+\tif (num == 1 || num == 2)\n+\t\tfail(\"Test should've been disabled for \" + num);\n+}\n+----\n+\n+If substrings are not powerful enough, you can also use regular expressions:\n+\n+[source,java]\n+----\n+// disable invocations whose display name\n+// contains \"disable \" or \"disabled \"\n+@DisableIfDisplayName(matches = \".*disabled?\\\\s.*\")\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(\n+\t// Disabled: 1,2,4,5\n+\t// Not disabled: 3,6\n+\tstrings = {\n+\t\t\"disable who\", // 1\n+\t\t\"you, disable you\", // 2\n+\t\t\"why am I disabled\", // 3\n+\t\t\"what has been disabled must stay disabled\", // 4\n+\t\t\"fine disable me all you want\", // 5\n+\t\t\"not those one, though!\" // 6\n+\t}\n+)\n+void single(String reason) {\n+\t// ...\n+}\n+----\n+\n+Using both `matches` and `contains` in a single annotation is no longer permitted as of {VERSION_OR_DATE_PLACHOLDER}.\n+\n+== DisableIfParameter\n+\n+This extension can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).\n+The extension comes with three annotations, covering different use-cases:\n+\n+- `@DisableIfAnyParameter`, non-repeatable\n+- `@DisableIfAllParameters`, non-repeatable\n+- `@DisableIfParameter`, repeatable\n+\n+The annotations are only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation, the extension evaluates each execution of a parameterized test.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test is possibly disabled individually.\n+All three annotations require that you specify one of two parameters, `contains` *or* `matches`.\n+`@DisableIfAnyParameter` will disable test executions if *any* argument either contains or matches any of the given strings.\n+`@DisableIfAllParameters` will disable test executions if *all* arguments either contain or match any of the given strings.\n+`@DisableIfParameter` will disable test executions if a *specified* argument either contains or matches any of the given strings.\n+\n+=== Using `contains`\n+\n+[source,java]\n+----\n+@DisableIfAllParameters(contains = \"the\")\n+@ParameterizedTest\n+@CsvSource(value = {\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\",\n+\t\t\"Then let them toll the passing-bell,;Then of your servitude be free,\",\n+\t\t\"The clock may stop, its hands fall still,;And time be over then for me!\"\n+}, delimiter = ';')\n+void disableAllContains(String line, String line2) {\n+}\n+----\n+\n+The test `disableAllContains` ordinarily would run four times, but the second execution gets disabled because both arguments contain \"the\" (the second argument as part of \"there\").\n+Using the same test with a different annotation would look like this:\n+\n+[source,java]\n+----\n+@DisableIfAnyParameter(contains = \"Then\")\n+@ParameterizedTest\n+@CsvSource(value = {\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\",\n+\t\t\"Then let them toll the passing-bell,;Then of your servitude be free,\",\n+\t\t\"The clock may stop, its hands fall still,;And time be over then for me!\"\n+}, delimiter = ';')\n+void disableAnyContains(String line, String line2) {\n+}\n+----\n+\n+The test `disableAnyContains` ordinarily would run four times, but the second and third executions get disabled because an argument contains \"Then\".\n+The last execution does not get disabled, because the extension is case-sensitive.", "originalCommit": "b6886d0b08891c97f83bd452fa5fb5b0c94ba009", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDUzMjU5MQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r600532591", "bodyText": "I personally like to write this .. starting from 0 (zero) to show that I don't have a typo.", "author": "Bukama", "createdAt": "2021-03-24T14:30:48Z", "path": "docs/disable-parameterized-tests.adoc", "diffHunk": "@@ -0,0 +1,250 @@\n+:page-title: Disable Parameterized Test\n+:page-description: Extends JUnit Jupiter with multiple extensions, which selectively disables parameterized tests\n+\n+JUnit Pioneer offers multiple extensions for selectively disabling parameterized tests.\n+These are as follows:\n+\n+- DisableIfDisplayName\n+- DisableIfParameter\n+\n+== DisableIfDisplayName\n+\n+\n+The `@DisableIfDisplayName` annotation can be used to selectively disable parameterized tests based on their display names, which are dynamically registered on runtime.\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfDisplayName` is validated before each parameterized test execution.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test (name) can be evaluated and possibly disabled individually.\n+\n+[source,java]\n+----\n+// disable invocations whose display name contains \"disable\"\n+@DisableIfDisplayName(contains = \"disable\")\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(\n+\t// Disabled: 1,2,3,4,5\n+\t// Not disabled: 6\n+\tstrings = {\n+\t\t\"disable who\", // 1\n+\t\t\"you, disable you\", // 2\n+\t\t\"why am I disabled\", // 3\n+\t\t\"what has been disabled must stay disabled\", // 4\n+\t\t\"fine disable me all you want\", // 5\n+\t\t\"not those one, though!\" // 6\n+\t}\n+)\n+void testExecutionDisabled(String reason) {\n+\tif (reason.contains(\"disable\"))\n+\t\tfail(\"Test should've been disabled \" + reason);\n+}\n+----\n+\n+You can also specify more than one substring at a time:\n+\n+[source,java]\n+----\n+@DisableIfDisplayName(contains = {\"1\", \"2\"})\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(ints = { 1, 2, 3, 4, 5 })\n+void testDisplayNameString(int num) {\n+\tif (num == 1 || num == 2)\n+\t\tfail(\"Test should've been disabled for \" + num);\n+}\n+----\n+\n+If substrings are not powerful enough, you can also use regular expressions:\n+\n+[source,java]\n+----\n+// disable invocations whose display name\n+// contains \"disable \" or \"disabled \"\n+@DisableIfDisplayName(matches = \".*disabled?\\\\s.*\")\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(\n+\t// Disabled: 1,2,4,5\n+\t// Not disabled: 3,6\n+\tstrings = {\n+\t\t\"disable who\", // 1\n+\t\t\"you, disable you\", // 2\n+\t\t\"why am I disabled\", // 3\n+\t\t\"what has been disabled must stay disabled\", // 4\n+\t\t\"fine disable me all you want\", // 5\n+\t\t\"not those one, though!\" // 6\n+\t}\n+)\n+void single(String reason) {\n+\t// ...\n+}\n+----\n+\n+Using both `matches` and `contains` in a single annotation is no longer permitted as of {VERSION_OR_DATE_PLACHOLDER}.\n+\n+== DisableIfParameter\n+\n+This extension can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).\n+The extension comes with three annotations, covering different use-cases:\n+\n+- `@DisableIfAnyParameter`, non-repeatable\n+- `@DisableIfAllParameters`, non-repeatable\n+- `@DisableIfParameter`, repeatable\n+\n+The annotations are only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation, the extension evaluates each execution of a parameterized test.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test is possibly disabled individually.\n+All three annotations require that you specify one of two parameters, `contains` *or* `matches`.\n+`@DisableIfAnyParameter` will disable test executions if *any* argument either contains or matches any of the given strings.\n+`@DisableIfAllParameters` will disable test executions if *all* arguments either contain or match any of the given strings.\n+`@DisableIfParameter` will disable test executions if a *specified* argument either contains or matches any of the given strings.\n+\n+=== Using `contains`\n+\n+[source,java]\n+----\n+@DisableIfAllParameters(contains = \"the\")\n+@ParameterizedTest\n+@CsvSource(value = {\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\",\n+\t\t\"Then let them toll the passing-bell,;Then of your servitude be free,\",\n+\t\t\"The clock may stop, its hands fall still,;And time be over then for me!\"\n+}, delimiter = ';')\n+void disableAllContains(String line, String line2) {\n+}\n+----\n+\n+The test `disableAllContains` ordinarily would run four times, but the second execution gets disabled because both arguments contain \"the\" (the second argument as part of \"there\").\n+Using the same test with a different annotation would look like this:\n+\n+[source,java]\n+----\n+@DisableIfAnyParameter(contains = \"Then\")\n+@ParameterizedTest\n+@CsvSource(value = {\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\",\n+\t\t\"Then let them toll the passing-bell,;Then of your servitude be free,\",\n+\t\t\"The clock may stop, its hands fall still,;And time be over then for me!\"\n+}, delimiter = ';')\n+void disableAnyContains(String line, String line2) {\n+}\n+----\n+\n+The test `disableAnyContains` ordinarily would run four times, but the second and third executions get disabled because an argument contains \"Then\".\n+The last execution does not get disabled, because the extension is case-sensitive.\n+\n+You can specify more than one substring at a time:\n+\n+[source, java]\n+----\n+@DisableIfAnyParameter(contains = { \"Then\", \"then\" })\n+@ParameterizedTest\n+@CsvSource(value = {\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\",\n+\t\t\"Then let them toll the passing-bell,;Then of your servitude be free,\",\n+\t\t\"The clock may stop, its hands fall still,;And time be over then for me!\"\n+}, delimiter = ';')\n+void disableAnyContains(String line, String line2) {\n+}\n+----\n+\n+The extension disables the second, third and fourth executions because an argument contains either \"Then\" or \"then\".\n+\n+`@DisableIfParameter` requires you to target a specific parameter.\n+You can do this in three ways:\n+\n+- By a `name` https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Parameter.html#isNamePresent--[if parameter naming information is present].\n+- By an explicit `index`, starting from 0.\n+- By an implicit index.\n+\n+Using both `name` and `index` in a single `@DisableIfParameter` annotation is not permitted.\n+\n+==== Targeting by `name`\n+\n+If naming information is included during compilation, you can target parameters by their name.\n+\n+[source, java]\n+----\n+@DisableIfParameter(name = \"line2\", contains = \"swift\")\n+@ParameterizedTest\n+@CsvSource({\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\"\n+})\n+void targetName(String line, String line2) {\n+}\n+----\n+\n+The test gets executed two times because we explicitly targeted the second parameter, which never contains the word \"swift\".\n+\n+==== Targeting by `index`\n+\n+You can target your parameters with their index, starting from 0.", "originalCommit": "b6886d0b08891c97f83bd452fa5fb5b0c94ba009", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDUzMzg1Nw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r600533857", "bodyText": "I would add some kind of theader here, because the not is not a note for the particular example above", "author": "Bukama", "createdAt": "2021-03-24T14:32:13Z", "path": "docs/disable-parameterized-tests.adoc", "diffHunk": "@@ -0,0 +1,250 @@\n+:page-title: Disable Parameterized Test\n+:page-description: Extends JUnit Jupiter with multiple extensions, which selectively disables parameterized tests\n+\n+JUnit Pioneer offers multiple extensions for selectively disabling parameterized tests.\n+These are as follows:\n+\n+- DisableIfDisplayName\n+- DisableIfParameter\n+\n+== DisableIfDisplayName\n+\n+\n+The `@DisableIfDisplayName` annotation can be used to selectively disable parameterized tests based on their display names, which are dynamically registered on runtime.\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfDisplayName` is validated before each parameterized test execution.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test (name) can be evaluated and possibly disabled individually.\n+\n+[source,java]\n+----\n+// disable invocations whose display name contains \"disable\"\n+@DisableIfDisplayName(contains = \"disable\")\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(\n+\t// Disabled: 1,2,3,4,5\n+\t// Not disabled: 6\n+\tstrings = {\n+\t\t\"disable who\", // 1\n+\t\t\"you, disable you\", // 2\n+\t\t\"why am I disabled\", // 3\n+\t\t\"what has been disabled must stay disabled\", // 4\n+\t\t\"fine disable me all you want\", // 5\n+\t\t\"not those one, though!\" // 6\n+\t}\n+)\n+void testExecutionDisabled(String reason) {\n+\tif (reason.contains(\"disable\"))\n+\t\tfail(\"Test should've been disabled \" + reason);\n+}\n+----\n+\n+You can also specify more than one substring at a time:\n+\n+[source,java]\n+----\n+@DisableIfDisplayName(contains = {\"1\", \"2\"})\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(ints = { 1, 2, 3, 4, 5 })\n+void testDisplayNameString(int num) {\n+\tif (num == 1 || num == 2)\n+\t\tfail(\"Test should've been disabled for \" + num);\n+}\n+----\n+\n+If substrings are not powerful enough, you can also use regular expressions:\n+\n+[source,java]\n+----\n+// disable invocations whose display name\n+// contains \"disable \" or \"disabled \"\n+@DisableIfDisplayName(matches = \".*disabled?\\\\s.*\")\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(\n+\t// Disabled: 1,2,4,5\n+\t// Not disabled: 3,6\n+\tstrings = {\n+\t\t\"disable who\", // 1\n+\t\t\"you, disable you\", // 2\n+\t\t\"why am I disabled\", // 3\n+\t\t\"what has been disabled must stay disabled\", // 4\n+\t\t\"fine disable me all you want\", // 5\n+\t\t\"not those one, though!\" // 6\n+\t}\n+)\n+void single(String reason) {\n+\t// ...\n+}\n+----\n+\n+Using both `matches` and `contains` in a single annotation is no longer permitted as of {VERSION_OR_DATE_PLACHOLDER}.\n+\n+== DisableIfParameter\n+\n+This extension can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).\n+The extension comes with three annotations, covering different use-cases:\n+\n+- `@DisableIfAnyParameter`, non-repeatable\n+- `@DisableIfAllParameters`, non-repeatable\n+- `@DisableIfParameter`, repeatable\n+\n+The annotations are only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation, the extension evaluates each execution of a parameterized test.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test is possibly disabled individually.\n+All three annotations require that you specify one of two parameters, `contains` *or* `matches`.\n+`@DisableIfAnyParameter` will disable test executions if *any* argument either contains or matches any of the given strings.\n+`@DisableIfAllParameters` will disable test executions if *all* arguments either contain or match any of the given strings.\n+`@DisableIfParameter` will disable test executions if a *specified* argument either contains or matches any of the given strings.\n+\n+=== Using `contains`\n+\n+[source,java]\n+----\n+@DisableIfAllParameters(contains = \"the\")\n+@ParameterizedTest\n+@CsvSource(value = {\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\",\n+\t\t\"Then let them toll the passing-bell,;Then of your servitude be free,\",\n+\t\t\"The clock may stop, its hands fall still,;And time be over then for me!\"\n+}, delimiter = ';')\n+void disableAllContains(String line, String line2) {\n+}\n+----\n+\n+The test `disableAllContains` ordinarily would run four times, but the second execution gets disabled because both arguments contain \"the\" (the second argument as part of \"there\").\n+Using the same test with a different annotation would look like this:\n+\n+[source,java]\n+----\n+@DisableIfAnyParameter(contains = \"Then\")\n+@ParameterizedTest\n+@CsvSource(value = {\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\",\n+\t\t\"Then let them toll the passing-bell,;Then of your servitude be free,\",\n+\t\t\"The clock may stop, its hands fall still,;And time be over then for me!\"\n+}, delimiter = ';')\n+void disableAnyContains(String line, String line2) {\n+}\n+----\n+\n+The test `disableAnyContains` ordinarily would run four times, but the second and third executions get disabled because an argument contains \"Then\".\n+The last execution does not get disabled, because the extension is case-sensitive.\n+\n+You can specify more than one substring at a time:\n+\n+[source, java]\n+----\n+@DisableIfAnyParameter(contains = { \"Then\", \"then\" })\n+@ParameterizedTest\n+@CsvSource(value = {\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\",\n+\t\t\"Then let them toll the passing-bell,;Then of your servitude be free,\",\n+\t\t\"The clock may stop, its hands fall still,;And time be over then for me!\"\n+}, delimiter = ';')\n+void disableAnyContains(String line, String line2) {\n+}\n+----\n+\n+The extension disables the second, third and fourth executions because an argument contains either \"Then\" or \"then\".\n+\n+`@DisableIfParameter` requires you to target a specific parameter.\n+You can do this in three ways:\n+\n+- By a `name` https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Parameter.html#isNamePresent--[if parameter naming information is present].\n+- By an explicit `index`, starting from 0.\n+- By an implicit index.\n+\n+Using both `name` and `index` in a single `@DisableIfParameter` annotation is not permitted.\n+\n+==== Targeting by `name`\n+\n+If naming information is included during compilation, you can target parameters by their name.\n+\n+[source, java]\n+----\n+@DisableIfParameter(name = \"line2\", contains = \"swift\")\n+@ParameterizedTest\n+@CsvSource({\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\"\n+})\n+void targetName(String line, String line2) {\n+}\n+----\n+\n+The test gets executed two times because we explicitly targeted the second parameter, which never contains the word \"swift\".\n+\n+==== Targeting by `index`\n+\n+You can target your parameters with their index, starting from 0.\n+\n+[source, java]\n+----\n+@DisableIfParameter(index = 1, contains = \"swift\")\n+@ParameterizedTest\n+@CsvSource({\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\"\n+})\n+void targetIndex(String line, String line2) {\n+}\n+----\n+\n+Again, the test gets executed two times, because we targeted the second parameter.\n+\n+==== Targeting by implicit index\n+\n+You can opt to not specify `index` or `name` and use annotation order to specify what parameter to target.\n+In this case the first `@DisableIfParameter` targets the first parameter, the second annotation the second parameter, etc.\n+This is mainly for convenience when you have a test method with a single parameter.\n+Using this method to target parameters when your test has multiple parameters is discouraged.\n+\n+[source, java]\n+----\n+@DisableIfParameter(contains = \"gibberish\")\n+@DisableIfParameter(contains = \"gladly\")\n+@ParameterizedTest\n+@CsvSource({\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\"\n+})\n+void targetByOrder(String line, String line2) {\n+}\n+----\n+\n+The test gets executed once.\n+The second execution is disabled because the second argument contains \"gladly\".\n+\n+=== Using `matches`\n+\n+If substrings are not powerful enough, you can also use regular expressions, with the `matches` value.\n+\n+[source,java]\n+----\n+// disable invocations whose parameter ends with 'knew' or 'grew'\n+@DisableIfParameter(matches = { \".*knew\", \".*grew\" })\n+@ParameterizedTest\n+@ValueSource(strings = {\n+\t\t\"Lily-like, white as snow,\",\n+\t\t\"She hardly knew\",\n+\t\t\"She was a woman, so\",\n+\t\t\"Sweetly she grew\"\n+})\n+void interceptMatches(String value) {\n+}\n+----\n+\n+These test invocations get disabled:\n+\n+* The second invocation, because it has a parameter that matches \".*knew\" - ends with knew.\n+* The fourth invocation, because it has a parameter that matches \".*grew\" - ends with grew.\n+\n+Just like with `contains`, if any parameter value matches any expression from `matches`, the invocation gets disabled.\n+", "originalCommit": "b6886d0b08891c97f83bd452fa5fb5b0c94ba009", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNzk3MDM0Nw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r607970347", "bodyText": "I don't know what you mean. Could you clarify?", "author": "Michael1993", "createdAt": "2021-04-06T15:47:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDUzMzg1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTAxMTY3MA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r611011670", "bodyText": "For me I see some kind of break between line 244 (Just like..) and 246 (NOTE:) where the sentences are not connected by each other but from the formatting it seems like they belong together.", "author": "Bukama", "createdAt": "2021-04-10T07:39:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDUzMzg1Nw=="}], "type": "inlineReview"}, {"oid": "87637cbe979349587671a0a5d0a373283cb7054b", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/87637cbe979349587671a0a5d0a373283cb7054b", "message": "Update docs\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2021-04-06T15:47:03Z", "type": "commit"}, {"oid": "6c32440b0fe1f8671b71c4413bb91af8609d0349", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/6c32440b0fe1f8671b71c4413bb91af8609d0349", "message": "Merge branch 'main' into issue313/explore-invocation-interceptor", "committedDate": "2021-04-08T20:41:38Z", "type": "commit"}, {"oid": "cf6d5dc08453f6d850088e31c7735a9b7dbb8443", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/cf6d5dc08453f6d850088e31c7735a9b7dbb8443", "message": "Trigger checks again", "committedDate": "2021-04-08T23:05:27Z", "type": "commit"}, {"oid": "faf3d609d64ad511955b7d6ed5b1e9f4b1f8dc62", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/faf3d609d64ad511955b7d6ed5b1e9f4b1f8dc62", "message": "Add JavaDoc on annotations\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2021-04-17T13:18:02Z", "type": "commit"}, {"oid": "6d99b67b0c85b27c5284d5bb676aa21437a30085", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/6d99b67b0c85b27c5284d5bb676aa21437a30085", "message": "More JavaDoc updates\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2021-04-17T13:22:53Z", "type": "commit"}, {"oid": "612030f71ebc1d4275f21e1aee995978c16c7ca3", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/612030f71ebc1d4275f21e1aee995978c16c7ca3", "message": "Minor documentation polish\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>", "committedDate": "2021-04-18T08:53:34Z", "type": "commit"}, {"oid": "b90527495c9f8281ee88fb5bf21eb2196c94e9f7", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/b90527495c9f8281ee88fb5bf21eb2196c94e9f7", "message": "Merge branch 'main' into issue313/explore-invocation-interceptor", "committedDate": "2021-04-21T08:09:07Z", "type": "commit"}, {"oid": "960051f6bb6e4a8618a26a3d57920d40ffc6099e", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/960051f6bb6e4a8618a26a3d57920d40ffc6099e", "message": "Merge branch 'main' into issue313/explore-invocation-interceptor", "committedDate": "2021-05-18T17:03:47Z", "type": "commit"}, {"oid": "76aa6d8f8152490b6e976f88fb29e90135e0938d", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/76aa6d8f8152490b6e976f88fb29e90135e0938d", "message": "Edit documentation", "committedDate": "2021-05-18T19:38:44Z", "type": "commit"}, {"oid": "4fad9b5df4d5de9f2516d367765927b3b169c8b2", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/4fad9b5df4d5de9f2516d367765927b3b169c8b2", "message": "Moving code around", "committedDate": "2021-05-18T19:40:07Z", "type": "commit"}, {"oid": "058a1a2d448b7faeac390c417e952f2c4756ddc2", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/058a1a2d448b7faeac390c417e952f2c4756ddc2", "message": "Rename \"Parameter\" to \"Argument\"", "committedDate": "2021-05-18T20:13:08Z", "type": "commit"}, {"oid": "7f8c3311ad18fe20f1d8af9cde5b327f6e5bda00", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/7f8c3311ad18fe20f1d8af9cde5b327f6e5bda00", "message": "Merge branch 'main' of https://github.com/junit-pioneer/junit-pioneer into issue313/explore-invocation-interceptor", "committedDate": "2021-05-29T11:47:13Z", "type": "commit"}, {"oid": "27bd4fbef4cc34479af1b69e6980ea860ee3c387", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/27bd4fbef4cc34479af1b69e6980ea860ee3c387", "message": "Add since in javadoc", "committedDate": "2021-05-29T11:50:12Z", "type": "commit"}]}