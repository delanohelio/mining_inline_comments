{"pr_number": 4086, "pr_title": "add additional node context for lineage", "pr_createdAt": "2020-11-11T08:33:04Z", "pr_url": "https://github.com/odpi/egeria/pull/4086", "timeline": [{"oid": "26defbf0ef049770a548600641309f6d7503f148", "url": "https://github.com/odpi/egeria/commit/26defbf0ef049770a548600641309f6d7503f148", "message": "add additional node context for lineage\n\nSigned-off-by: marius-patrascu <marius-florin.patrascu@ing.com>", "committedDate": "2020-11-11T08:31:18Z", "type": "commit"}, {"oid": "ae6a77fdc95be97d035ddfbb2c879837242363b1", "url": "https://github.com/odpi/egeria/commit/ae6a77fdc95be97d035ddfbb2c879837242363b1", "message": "Merge branch 'master' into implement-node-details-for-lineage", "committedDate": "2020-11-11T08:33:11Z", "type": "commit"}, {"oid": "947c871a26321bdb4a0e2552fd65d02cc7910583", "url": "https://github.com/odpi/egeria/commit/947c871a26321bdb4a0e2552fd65d02cc7910583", "message": "Merge branch 'master' into implement-node-details-for-lineage", "committedDate": "2020-11-11T10:16:41Z", "type": "commit"}, {"oid": "c00dd5315fa92e64790d260f79f35df587d22ddd", "url": "https://github.com/odpi/egeria/commit/c00dd5315fa92e64790d260f79f35df587d22ddd", "message": "small refactoring\n\nSigned-off-by: marius-patrascu <marius-florin.patrascu@ing.com>", "committedDate": "2020-11-11T12:20:12Z", "type": "commit"}, {"oid": "b16643ecdaccc19996c4ae892f83862074c987ba", "url": "https://github.com/odpi/egeria/commit/b16643ecdaccc19996c4ae892f83862074c987ba", "message": "Merge branch 'master' of https://github.com/odpi/egeria into serialization-issue-on-remote-janusgraph\n\nSigned-off-by: marius-patrascu <marius-florin.patrascu@ing.com>", "committedDate": "2020-11-11T12:32:22Z", "type": "commit"}, {"oid": "5c665aa31a518363ec280ee2fe4e7352f2cde7ae", "url": "https://github.com/odpi/egeria/commit/5c665aa31a518363ec280ee2fe4e7352f2cde7ae", "message": "Merge branch 'master' into implement-node-details-for-lineage", "committedDate": "2020-11-11T13:19:23Z", "type": "commit"}, {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de", "url": "https://github.com/odpi/egeria/commit/854e5a152793d6432c0a7eb57b9634e020c196de", "message": "Merge branch 'master' into implement-node-details-for-lineage", "committedDate": "2020-11-11T13:58:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NDQxNA==", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521494414", "bodyText": "No commit", "author": "lcpopa", "createdAt": "2020-11-11T16:48:35Z", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -662,85 +665,96 @@ private void addColumnProperties(Set<LineageVertex> lineageVertices) {\n             return;\n         }\n \n-        lineageVertices.stream().filter(this::isColumn).forEach(lineageVertex -> {\n+        lineageVertices.stream().filter(this::needsAdditionalNodeContext).forEach(lineageVertex -> {\n             Vertex graphVertex = g.V().has(PROPERTY_KEY_ENTITY_GUID, lineageVertex.getGuid()).next();\n             Object vertexId = graphVertex.id();\n             Map<String, String> properties = new HashMap<>();\n \n             switch (lineageVertex.getNodeType()) {\n                 case TABULAR_COLUMN:\n-                    properties = getDataFileProperties(g, vertexId);\n+                    properties = getTabularColumnProperties(g, vertexId);\n                     break;\n                 case RELATIONAL_COLUMN:\n+                    properties = getRelationalColumnProperties(g, vertexId);\n+                    break;\n+                case RELATIONAL_TABLE:\n                     properties = getRelationalTableProperties(g, vertexId);\n                     break;\n+                case DATA_FILE:\n+                    properties = getDataFileProperties(g, vertexId);\n+                    break;\n+                case PROCESS:\n+                case NODE_LABEL_SUB_PROCESS:\n+                    properties = getProcessProperties(g, vertexId);\n+                    break;\n+                case GLOSSARY_TERM:\n+                case GLOSSARY_CATEGORY:\n+                    properties = getGlossaryTermProperties(g, vertexId);\n+                    break;\n             }\n             lineageVertex.setProperties(properties);\n         });\n     }\n \n-    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+\n+    private boolean needsAdditionalNodeContext(LineageVertex lineageVertex) {\n+        return Arrays.asList(DATA_FILE, Constants.RELATIONAL_TABLE, Constants.GLOSSARY_TERM, Constants.GLOSSARY_CATEGORY, Constants.PROCESS,\n+                Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN, NODE_LABEL_SUB_PROCESS).contains(lineageVertex.getNodeType());\n+    }\n+\n+    private Map<String, String> getRelationalColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tableAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(RELATIONAL_TABLE));\n         if (tableAsset.hasNext()) {\n-            properties.put(PROPERTY_KEY_TABLE_DISPLAY_NAME, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(RELATIONAL_TABLE_KEY, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> relationalDBSchemaType =\n                 g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(2).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n         if (relationalDBSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n-                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n-        }\n-\n-        Iterator<Vertex> deployedDatabaseSchema =\n-                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DEPLOYED_DB_SCHEMA_TYPE));\n-        if (deployedDatabaseSchema.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_DISPLAY_NAME,\n-                    deployedDatabaseSchema.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(SCHEMA_TYPE_KEY, relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).or(hasLabel(DATABASE));", "originalCommit": "854e5a152793d6432c0a7eb57b9634e020c196de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NDcwNw==", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521494707", "bodyText": "No commit", "author": "lcpopa", "createdAt": "2020-11-11T16:49:01Z", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -662,85 +665,96 @@ private void addColumnProperties(Set<LineageVertex> lineageVertices) {\n             return;\n         }\n \n-        lineageVertices.stream().filter(this::isColumn).forEach(lineageVertex -> {\n+        lineageVertices.stream().filter(this::needsAdditionalNodeContext).forEach(lineageVertex -> {\n             Vertex graphVertex = g.V().has(PROPERTY_KEY_ENTITY_GUID, lineageVertex.getGuid()).next();\n             Object vertexId = graphVertex.id();\n             Map<String, String> properties = new HashMap<>();\n \n             switch (lineageVertex.getNodeType()) {\n                 case TABULAR_COLUMN:\n-                    properties = getDataFileProperties(g, vertexId);\n+                    properties = getTabularColumnProperties(g, vertexId);\n                     break;\n                 case RELATIONAL_COLUMN:\n+                    properties = getRelationalColumnProperties(g, vertexId);\n+                    break;\n+                case RELATIONAL_TABLE:\n                     properties = getRelationalTableProperties(g, vertexId);\n                     break;\n+                case DATA_FILE:\n+                    properties = getDataFileProperties(g, vertexId);\n+                    break;\n+                case PROCESS:\n+                case NODE_LABEL_SUB_PROCESS:\n+                    properties = getProcessProperties(g, vertexId);\n+                    break;\n+                case GLOSSARY_TERM:\n+                case GLOSSARY_CATEGORY:\n+                    properties = getGlossaryTermProperties(g, vertexId);\n+                    break;\n             }\n             lineageVertex.setProperties(properties);\n         });\n     }\n \n-    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+\n+    private boolean needsAdditionalNodeContext(LineageVertex lineageVertex) {\n+        return Arrays.asList(DATA_FILE, Constants.RELATIONAL_TABLE, Constants.GLOSSARY_TERM, Constants.GLOSSARY_CATEGORY, Constants.PROCESS,\n+                Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN, NODE_LABEL_SUB_PROCESS).contains(lineageVertex.getNodeType());\n+    }\n+\n+    private Map<String, String> getRelationalColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tableAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(RELATIONAL_TABLE));\n         if (tableAsset.hasNext()) {\n-            properties.put(PROPERTY_KEY_TABLE_DISPLAY_NAME, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(RELATIONAL_TABLE_KEY, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> relationalDBSchemaType =\n                 g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(2).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n         if (relationalDBSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n-                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n-        }\n-\n-        Iterator<Vertex> deployedDatabaseSchema =\n-                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DEPLOYED_DB_SCHEMA_TYPE));\n-        if (deployedDatabaseSchema.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_DISPLAY_NAME,\n-                    deployedDatabaseSchema.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(SCHEMA_TYPE_KEY, relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).or(hasLabel(DATABASE));\n         if (database.hasNext()) {\n-            properties.put(PROPERTY_KEY_DATABASE_DISPLAY_NAME,\n+            properties.put(DATABASE_KEY,\n                     database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(5).hasLabel(CONNECTION);", "originalCommit": "854e5a152793d6432c0a7eb57b9634e020c196de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NDgzNw==", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521494837", "bodyText": "No commit", "author": "lcpopa", "createdAt": "2020-11-11T16:49:12Z", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -662,85 +665,96 @@ private void addColumnProperties(Set<LineageVertex> lineageVertices) {\n             return;\n         }\n \n-        lineageVertices.stream().filter(this::isColumn).forEach(lineageVertex -> {\n+        lineageVertices.stream().filter(this::needsAdditionalNodeContext).forEach(lineageVertex -> {\n             Vertex graphVertex = g.V().has(PROPERTY_KEY_ENTITY_GUID, lineageVertex.getGuid()).next();\n             Object vertexId = graphVertex.id();\n             Map<String, String> properties = new HashMap<>();\n \n             switch (lineageVertex.getNodeType()) {\n                 case TABULAR_COLUMN:\n-                    properties = getDataFileProperties(g, vertexId);\n+                    properties = getTabularColumnProperties(g, vertexId);\n                     break;\n                 case RELATIONAL_COLUMN:\n+                    properties = getRelationalColumnProperties(g, vertexId);\n+                    break;\n+                case RELATIONAL_TABLE:\n                     properties = getRelationalTableProperties(g, vertexId);\n                     break;\n+                case DATA_FILE:\n+                    properties = getDataFileProperties(g, vertexId);\n+                    break;\n+                case PROCESS:\n+                case NODE_LABEL_SUB_PROCESS:\n+                    properties = getProcessProperties(g, vertexId);\n+                    break;\n+                case GLOSSARY_TERM:\n+                case GLOSSARY_CATEGORY:\n+                    properties = getGlossaryTermProperties(g, vertexId);\n+                    break;\n             }\n             lineageVertex.setProperties(properties);\n         });\n     }\n \n-    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+\n+    private boolean needsAdditionalNodeContext(LineageVertex lineageVertex) {\n+        return Arrays.asList(DATA_FILE, Constants.RELATIONAL_TABLE, Constants.GLOSSARY_TERM, Constants.GLOSSARY_CATEGORY, Constants.PROCESS,\n+                Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN, NODE_LABEL_SUB_PROCESS).contains(lineageVertex.getNodeType());\n+    }\n+\n+    private Map<String, String> getRelationalColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tableAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(RELATIONAL_TABLE));\n         if (tableAsset.hasNext()) {\n-            properties.put(PROPERTY_KEY_TABLE_DISPLAY_NAME, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(RELATIONAL_TABLE_KEY, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> relationalDBSchemaType =\n                 g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(2).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n         if (relationalDBSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n-                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n-        }\n-\n-        Iterator<Vertex> deployedDatabaseSchema =\n-                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DEPLOYED_DB_SCHEMA_TYPE));\n-        if (deployedDatabaseSchema.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_DISPLAY_NAME,\n-                    deployedDatabaseSchema.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(SCHEMA_TYPE_KEY, relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).or(hasLabel(DATABASE));\n         if (database.hasNext()) {\n-            properties.put(PROPERTY_KEY_DATABASE_DISPLAY_NAME,\n+            properties.put(DATABASE_KEY,\n                     database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(5).hasLabel(CONNECTION);\n         if (connection.hasNext()) {\n-            properties.put(PROPERTY_KEY_CONNECTION_NAME, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         return properties;\n     }\n \n-    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+    private Map<String, String> getTabularColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tabularSchemaType = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(TABULAR_SCHEMA_TYPE));", "originalCommit": "854e5a152793d6432c0a7eb57b9634e020c196de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NDk1NA==", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521494954", "bodyText": "No commit", "author": "lcpopa", "createdAt": "2020-11-11T16:49:21Z", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -662,85 +665,96 @@ private void addColumnProperties(Set<LineageVertex> lineageVertices) {\n             return;\n         }\n \n-        lineageVertices.stream().filter(this::isColumn).forEach(lineageVertex -> {\n+        lineageVertices.stream().filter(this::needsAdditionalNodeContext).forEach(lineageVertex -> {\n             Vertex graphVertex = g.V().has(PROPERTY_KEY_ENTITY_GUID, lineageVertex.getGuid()).next();\n             Object vertexId = graphVertex.id();\n             Map<String, String> properties = new HashMap<>();\n \n             switch (lineageVertex.getNodeType()) {\n                 case TABULAR_COLUMN:\n-                    properties = getDataFileProperties(g, vertexId);\n+                    properties = getTabularColumnProperties(g, vertexId);\n                     break;\n                 case RELATIONAL_COLUMN:\n+                    properties = getRelationalColumnProperties(g, vertexId);\n+                    break;\n+                case RELATIONAL_TABLE:\n                     properties = getRelationalTableProperties(g, vertexId);\n                     break;\n+                case DATA_FILE:\n+                    properties = getDataFileProperties(g, vertexId);\n+                    break;\n+                case PROCESS:\n+                case NODE_LABEL_SUB_PROCESS:\n+                    properties = getProcessProperties(g, vertexId);\n+                    break;\n+                case GLOSSARY_TERM:\n+                case GLOSSARY_CATEGORY:\n+                    properties = getGlossaryTermProperties(g, vertexId);\n+                    break;\n             }\n             lineageVertex.setProperties(properties);\n         });\n     }\n \n-    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+\n+    private boolean needsAdditionalNodeContext(LineageVertex lineageVertex) {\n+        return Arrays.asList(DATA_FILE, Constants.RELATIONAL_TABLE, Constants.GLOSSARY_TERM, Constants.GLOSSARY_CATEGORY, Constants.PROCESS,\n+                Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN, NODE_LABEL_SUB_PROCESS).contains(lineageVertex.getNodeType());\n+    }\n+\n+    private Map<String, String> getRelationalColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tableAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(RELATIONAL_TABLE));\n         if (tableAsset.hasNext()) {\n-            properties.put(PROPERTY_KEY_TABLE_DISPLAY_NAME, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(RELATIONAL_TABLE_KEY, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> relationalDBSchemaType =\n                 g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(2).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n         if (relationalDBSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n-                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n-        }\n-\n-        Iterator<Vertex> deployedDatabaseSchema =\n-                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DEPLOYED_DB_SCHEMA_TYPE));\n-        if (deployedDatabaseSchema.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_DISPLAY_NAME,\n-                    deployedDatabaseSchema.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(SCHEMA_TYPE_KEY, relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).or(hasLabel(DATABASE));\n         if (database.hasNext()) {\n-            properties.put(PROPERTY_KEY_DATABASE_DISPLAY_NAME,\n+            properties.put(DATABASE_KEY,\n                     database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(5).hasLabel(CONNECTION);\n         if (connection.hasNext()) {\n-            properties.put(PROPERTY_KEY_CONNECTION_NAME, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         return properties;\n     }\n \n-    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+    private Map<String, String> getTabularColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tabularSchemaType = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(TABULAR_SCHEMA_TYPE));\n         if (tabularSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n+            properties.put(SCHEMA_TYPE_KEY,\n                     tabularSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> dataFileAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(2).or(hasLabel(DATA_FILE));", "originalCommit": "854e5a152793d6432c0a7eb57b9634e020c196de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NTE1OQ==", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521495159", "bodyText": "No commit", "author": "lcpopa", "createdAt": "2020-11-11T16:49:39Z", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -662,85 +665,96 @@ private void addColumnProperties(Set<LineageVertex> lineageVertices) {\n             return;\n         }\n \n-        lineageVertices.stream().filter(this::isColumn).forEach(lineageVertex -> {\n+        lineageVertices.stream().filter(this::needsAdditionalNodeContext).forEach(lineageVertex -> {\n             Vertex graphVertex = g.V().has(PROPERTY_KEY_ENTITY_GUID, lineageVertex.getGuid()).next();\n             Object vertexId = graphVertex.id();\n             Map<String, String> properties = new HashMap<>();\n \n             switch (lineageVertex.getNodeType()) {\n                 case TABULAR_COLUMN:\n-                    properties = getDataFileProperties(g, vertexId);\n+                    properties = getTabularColumnProperties(g, vertexId);\n                     break;\n                 case RELATIONAL_COLUMN:\n+                    properties = getRelationalColumnProperties(g, vertexId);\n+                    break;\n+                case RELATIONAL_TABLE:\n                     properties = getRelationalTableProperties(g, vertexId);\n                     break;\n+                case DATA_FILE:\n+                    properties = getDataFileProperties(g, vertexId);\n+                    break;\n+                case PROCESS:\n+                case NODE_LABEL_SUB_PROCESS:\n+                    properties = getProcessProperties(g, vertexId);\n+                    break;\n+                case GLOSSARY_TERM:\n+                case GLOSSARY_CATEGORY:\n+                    properties = getGlossaryTermProperties(g, vertexId);\n+                    break;\n             }\n             lineageVertex.setProperties(properties);\n         });\n     }\n \n-    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+\n+    private boolean needsAdditionalNodeContext(LineageVertex lineageVertex) {\n+        return Arrays.asList(DATA_FILE, Constants.RELATIONAL_TABLE, Constants.GLOSSARY_TERM, Constants.GLOSSARY_CATEGORY, Constants.PROCESS,\n+                Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN, NODE_LABEL_SUB_PROCESS).contains(lineageVertex.getNodeType());\n+    }\n+\n+    private Map<String, String> getRelationalColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tableAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(RELATIONAL_TABLE));\n         if (tableAsset.hasNext()) {\n-            properties.put(PROPERTY_KEY_TABLE_DISPLAY_NAME, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(RELATIONAL_TABLE_KEY, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> relationalDBSchemaType =\n                 g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(2).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n         if (relationalDBSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n-                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n-        }\n-\n-        Iterator<Vertex> deployedDatabaseSchema =\n-                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DEPLOYED_DB_SCHEMA_TYPE));\n-        if (deployedDatabaseSchema.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_DISPLAY_NAME,\n-                    deployedDatabaseSchema.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(SCHEMA_TYPE_KEY, relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).or(hasLabel(DATABASE));\n         if (database.hasNext()) {\n-            properties.put(PROPERTY_KEY_DATABASE_DISPLAY_NAME,\n+            properties.put(DATABASE_KEY,\n                     database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(5).hasLabel(CONNECTION);\n         if (connection.hasNext()) {\n-            properties.put(PROPERTY_KEY_CONNECTION_NAME, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         return properties;\n     }\n \n-    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+    private Map<String, String> getTabularColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tabularSchemaType = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(TABULAR_SCHEMA_TYPE));\n         if (tabularSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n+            properties.put(SCHEMA_TYPE_KEY,\n                     tabularSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> dataFileAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(2).or(hasLabel(DATA_FILE));\n         if (dataFileAsset.hasNext()) {\n             Vertex dataFileVertex = dataFileAsset.next();\n-            properties.put(PROPERTY_KEY_TABLE_DISPLAY_NAME, dataFileVertex.property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n-\n-            List<Vertex> folderVertices = getFolderVertices(g, dataFileVertex);\n+            properties.put(DATA_FILE_KEY, dataFileVertex.property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            List<Vertex> folderVertices = getFolderVertices(g, dataFileVertex.id());\n             if (CollectionUtils.isEmpty(folderVertices)) {\n                 return properties;\n             }\n             Object lastFolderVertexId = folderVertices.get(folderVertices.size() - 1).id();\n+            properties.put(FILE_FOLDER_KEY, String.join(\"/\", getFoldersPath(folderVertices)));\n \n             Iterator<Vertex> connection = g.V(lastFolderVertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(CONNECTION));", "originalCommit": "854e5a152793d6432c0a7eb57b9634e020c196de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5Nzc2OQ==", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521497769", "bodyText": "No commit", "author": "lcpopa", "createdAt": "2020-11-11T16:53:41Z", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));", "originalCommit": "854e5a152793d6432c0a7eb57b9634e020c196de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NzkyNQ==", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521497925", "bodyText": "No commit", "author": "lcpopa", "createdAt": "2020-11-11T16:53:54Z", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));", "originalCommit": "854e5a152793d6432c0a7eb57b9634e020c196de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5ODAwOQ==", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521498009", "bodyText": "No commit", "author": "lcpopa", "createdAt": "2020-11-11T16:54:02Z", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n+        if (relationalDBSchemaType.hasNext()) {\n+            properties.put(SCHEMA_TYPE_KEY,\n+                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DATABASE));", "originalCommit": "854e5a152793d6432c0a7eb57b9634e020c196de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5ODA3Mw==", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521498073", "bodyText": "No commit", "author": "lcpopa", "createdAt": "2020-11-11T16:54:08Z", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n+        if (relationalDBSchemaType.hasNext()) {\n+            properties.put(SCHEMA_TYPE_KEY,\n+                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DATABASE));\n+        if (database.hasNext()) {\n+            properties.put(DATABASE_KEY,\n+                    database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).hasLabel(CONNECTION);", "originalCommit": "854e5a152793d6432c0a7eb57b9634e020c196de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5ODIwMQ==", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521498201", "bodyText": "No commit", "author": "lcpopa", "createdAt": "2020-11-11T16:54:19Z", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n+        if (relationalDBSchemaType.hasNext()) {\n+            properties.put(SCHEMA_TYPE_KEY,\n+                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DATABASE));\n+        if (database.hasNext()) {\n+            properties.put(DATABASE_KEY,\n+                    database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).hasLabel(CONNECTION);\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        List<Vertex> folderVertices = getFolderVertices(g, vertexId);\n+        if (CollectionUtils.isEmpty(folderVertices)) {\n+            return properties;\n+        }\n+        Object lastFolderVertexId = folderVertices.get(folderVertices.size() - 1).id();\n+        properties.put(FILE_FOLDER_KEY, String.join(\"/\", getFoldersPath(folderVertices)));\n+\n+        Iterator<Vertex> connection = g.V(lastFolderVertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(CONNECTION));", "originalCommit": "854e5a152793d6432c0a7eb57b9634e020c196de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5ODI1NA==", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521498254", "bodyText": "No commit", "author": "lcpopa", "createdAt": "2020-11-11T16:54:24Z", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n+        if (relationalDBSchemaType.hasNext()) {\n+            properties.put(SCHEMA_TYPE_KEY,\n+                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DATABASE));\n+        if (database.hasNext()) {\n+            properties.put(DATABASE_KEY,\n+                    database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).hasLabel(CONNECTION);\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        List<Vertex> folderVertices = getFolderVertices(g, vertexId);\n+        if (CollectionUtils.isEmpty(folderVertices)) {\n+            return properties;\n+        }\n+        Object lastFolderVertexId = folderVertices.get(folderVertices.size() - 1).id();\n+        properties.put(FILE_FOLDER_KEY, String.join(\"/\", getFoldersPath(folderVertices)));\n+\n+        Iterator<Vertex> connection = g.V(lastFolderVertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(CONNECTION));\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getProcessProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        GraphTraversal<Vertex, ? extends Property<Object>> qualifiedNameTraversal = g.V(vertexId).properties(PROPERTY_NAME_INSTANCEPROP_QUALIFIED_NAME);", "originalCommit": "854e5a152793d6432c0a7eb57b9634e020c196de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5ODMwNg==", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521498306", "bodyText": "No commit", "author": "lcpopa", "createdAt": "2020-11-11T16:54:30Z", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n+        if (relationalDBSchemaType.hasNext()) {\n+            properties.put(SCHEMA_TYPE_KEY,\n+                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DATABASE));\n+        if (database.hasNext()) {\n+            properties.put(DATABASE_KEY,\n+                    database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).hasLabel(CONNECTION);\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        List<Vertex> folderVertices = getFolderVertices(g, vertexId);\n+        if (CollectionUtils.isEmpty(folderVertices)) {\n+            return properties;\n+        }\n+        Object lastFolderVertexId = folderVertices.get(folderVertices.size() - 1).id();\n+        properties.put(FILE_FOLDER_KEY, String.join(\"/\", getFoldersPath(folderVertices)));\n+\n+        Iterator<Vertex> connection = g.V(lastFolderVertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(CONNECTION));\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getProcessProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        GraphTraversal<Vertex, ? extends Property<Object>> qualifiedNameTraversal = g.V(vertexId).properties(PROPERTY_NAME_INSTANCEPROP_QUALIFIED_NAME);\n+        if (qualifiedNameTraversal.hasNext()) {\n+            String value = (String) qualifiedNameTraversal.next().value();\n+            properties.put(PROPERTY_NAME_INSTANCEPROP_QUALIFIED_NAME, value);\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(8).or(hasLabel(CONNECTION));", "originalCommit": "854e5a152793d6432c0a7eb57b9634e020c196de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5ODM5NQ==", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521498395", "bodyText": "No commit", "author": "lcpopa", "createdAt": "2020-11-11T16:54:39Z", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n+        if (relationalDBSchemaType.hasNext()) {\n+            properties.put(SCHEMA_TYPE_KEY,\n+                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DATABASE));\n+        if (database.hasNext()) {\n+            properties.put(DATABASE_KEY,\n+                    database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).hasLabel(CONNECTION);\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        List<Vertex> folderVertices = getFolderVertices(g, vertexId);\n+        if (CollectionUtils.isEmpty(folderVertices)) {\n+            return properties;\n+        }\n+        Object lastFolderVertexId = folderVertices.get(folderVertices.size() - 1).id();\n+        properties.put(FILE_FOLDER_KEY, String.join(\"/\", getFoldersPath(folderVertices)));\n+\n+        Iterator<Vertex> connection = g.V(lastFolderVertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(CONNECTION));\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getProcessProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        GraphTraversal<Vertex, ? extends Property<Object>> qualifiedNameTraversal = g.V(vertexId).properties(PROPERTY_NAME_INSTANCEPROP_QUALIFIED_NAME);\n+        if (qualifiedNameTraversal.hasNext()) {\n+            String value = (String) qualifiedNameTraversal.next().value();\n+            properties.put(PROPERTY_NAME_INSTANCEPROP_QUALIFIED_NAME, value);\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(8).or(hasLabel(CONNECTION));\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+        return properties;\n+    }\n+\n+    private Map<String, String> getGlossaryTermProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+        Iterator<Vertex> tableAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(GLOSSARY));", "originalCommit": "854e5a152793d6432c0a7eb57b9634e020c196de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}