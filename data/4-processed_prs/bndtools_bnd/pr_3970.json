{"pr_number": 3970, "pr_title": "memoize: Change CloseableMemoize to not serialize accepts", "pr_createdAt": "2020-04-24T22:43:36Z", "pr_url": "https://github.com/bndtools/bnd/pull/3970", "timeline": [{"oid": "6d40187fbc0bf14ed1ca334ba0e79830751282ae", "url": "https://github.com/bndtools/bnd/commit/6d40187fbc0bf14ed1ca334ba0e79830751282ae", "message": "memoize: Improve CloseableMemoize to not serialize accepts\n\nLots of javadoc improvements and other doc updates. Some more tests.\n\nSigned-off-by: BJ Hargrave <bj@bjhargrave.com>", "committedDate": "2020-04-25T03:47:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyNzU5OA==", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415027598", "bodyText": "can elaborate why you're not directly writing it? It looks so strange so I assume you have reason for this?", "author": "pkriens", "createdAt": "2020-04-25T09:52:40Z", "path": "aQute.libg/src/aQute/lib/memoize/CloseableMemoizingSupplier.java", "diffHunk": "@@ -2,74 +2,109 @@\n \n import static java.util.Objects.requireNonNull;\n \n+import java.util.concurrent.locks.StampedLock;\n import java.util.function.Consumer;\n import java.util.function.Supplier;\n \n+/**\n+ * The object can exist in one of three states:\n+ * <ul>\n+ * <li>initial which means neither {@code get} or {@code close} has been called.\n+ * From this state, the object can transition directly to either open or\n+ * closed.</li>\n+ * <li>open which means memoized is non-null with the value from the wrapped\n+ * supplier. From this state, the object can transition to closed.</li>\n+ * <li>closed which means memoized is null and any value it may have held was\n+ * closed. This is a terminal state.</li>\n+ * </ul>\n+ */\n class CloseableMemoizingSupplier<T extends AutoCloseable> implements CloseableMemoize<T> {\n \tprivate final Supplier<? extends T>\tsupplier;\n-\t// @GuardedBy(\"this\")\n-\tprivate boolean\t\t\t\t\t\tclosed\t= false;\n-\tprivate volatile T\t\t\t\t\tmemoized;\n+\tprivate final StampedLock\t\t\tlock;\n+\tprivate volatile boolean\t\t\tinitial;\n+\t// @GuardedBy(\"initial\")\n+\tprivate T\t\t\t\t\t\t\tmemoized;\n \n \tCloseableMemoizingSupplier(Supplier<? extends T> supplier) {\n \t\tthis.supplier = requireNonNull(supplier);\n+\t\tlock = new StampedLock();\n+\t\tinitial = true;\n \t}\n \n \t@Override\n \tpublic T get() {\n-\t\tif (memoized == null) {\n-\t\t\tsynchronized (this) {\n-\t\t\t\tif (closed)\n-\t\t\t\t\tthrow new IllegalStateException(\"Already closed\");\n-\t\t\t\treturn get0();\n+\t\t// read initial _before_ read memoized\n+\t\tif (initial) {\n+\t\t\t// critical section: only one at a time\n+\t\t\tfinal long stamp = lock.writeLock();\n+\t\t\ttry {\n+\t\t\t\tif (initial) {\n+\t\t\t\t\tT result = requireNonNull(supplier.get());", "originalCommit": "6d40187fbc0bf14ed1ca334ba0e79830751282ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAzMjAyMw==", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415032023", "bodyText": "To minimize memory barriers. You need to 2 thing with the result: write to memory and also return it to the caller. If you write to memoize and then read from memoize you have both a write and read memory barrier which is unnecessary.", "author": "bjhargrave", "createdAt": "2020-04-25T10:19:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyNzU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyNzg1Ng==", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415027856", "bodyText": "this violates the contract that you call the supplier at most once ... if it throws an exception, the next get will call it again", "author": "pkriens", "createdAt": "2020-04-25T09:54:03Z", "path": "aQute.libg/src/aQute/lib/memoize/CloseableMemoizingSupplier.java", "diffHunk": "@@ -2,74 +2,109 @@\n \n import static java.util.Objects.requireNonNull;\n \n+import java.util.concurrent.locks.StampedLock;\n import java.util.function.Consumer;\n import java.util.function.Supplier;\n \n+/**\n+ * The object can exist in one of three states:\n+ * <ul>\n+ * <li>initial which means neither {@code get} or {@code close} has been called.\n+ * From this state, the object can transition directly to either open or\n+ * closed.</li>\n+ * <li>open which means memoized is non-null with the value from the wrapped\n+ * supplier. From this state, the object can transition to closed.</li>\n+ * <li>closed which means memoized is null and any value it may have held was\n+ * closed. This is a terminal state.</li>\n+ * </ul>\n+ */\n class CloseableMemoizingSupplier<T extends AutoCloseable> implements CloseableMemoize<T> {\n \tprivate final Supplier<? extends T>\tsupplier;\n-\t// @GuardedBy(\"this\")\n-\tprivate boolean\t\t\t\t\t\tclosed\t= false;\n-\tprivate volatile T\t\t\t\t\tmemoized;\n+\tprivate final StampedLock\t\t\tlock;\n+\tprivate volatile boolean\t\t\tinitial;\n+\t// @GuardedBy(\"initial\")\n+\tprivate T\t\t\t\t\t\t\tmemoized;\n \n \tCloseableMemoizingSupplier(Supplier<? extends T> supplier) {\n \t\tthis.supplier = requireNonNull(supplier);\n+\t\tlock = new StampedLock();\n+\t\tinitial = true;\n \t}\n \n \t@Override\n \tpublic T get() {\n-\t\tif (memoized == null) {\n-\t\t\tsynchronized (this) {\n-\t\t\t\tif (closed)\n-\t\t\t\t\tthrow new IllegalStateException(\"Already closed\");\n-\t\t\t\treturn get0();\n+\t\t// read initial _before_ read memoized\n+\t\tif (initial) {\n+\t\t\t// critical section: only one at a time\n+\t\t\tfinal long stamp = lock.writeLock();\n+\t\t\ttry {\n+\t\t\t\tif (initial) {\n+\t\t\t\t\tT result = requireNonNull(supplier.get());\n+\t\t\t\t\tmemoized = result;\n+\t\t\t\t\t// write initial _after_ write memoized\n+\t\t\t\t\tinitial = false;", "originalCommit": "6d40187fbc0bf14ed1ca334ba0e79830751282ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAzMjE3OQ==", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415032179", "bodyText": "The supplier violates the contract by returning null. Unless you want to have the supplier returning null result in closing the memoizing supplier.", "author": "bjhargrave", "createdAt": "2020-04-25T10:21:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyNzg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAzNTc3MQ==", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415035771", "bodyText": "Well, why not just call it once to at least obey the contract?", "author": "pkriens", "createdAt": "2020-04-25T10:41:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyNzg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAzNjk5OA==", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415036998", "bodyText": "If it returns null, we could declare that to be a close of the memoizeing supplier. So the memoizing supplier would enter the closed state when the wrapper supplier returns null. If that in line with what you are thinking?", "author": "bjhargrave", "createdAt": "2020-04-25T10:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyNzg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAzODU1OA==", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415038558", "bodyText": "We still then have the problem of what to do with the caller to our get method. Is the null then returned to him? The current state means he will get an NPE to at least alert him to the fact that the wrapped supplier returned a null. Otherwise, the caller may need to null check the result from our get.", "author": "bjhargrave", "createdAt": "2020-04-25T10:59:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyNzg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3MTgwMg==", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415071802", "bodyText": "If we treat the wrapper supplier returning null as causing the memoized supplier to be closed, then the proper thing would be to throw an IllegalStateException since that is what would have happened if get was called on a closed memoized supplier.\nI made #3973 to show this.", "author": "bjhargrave", "createdAt": "2020-04-25T14:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyNzg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyODMxOA==", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415028318", "bodyText": "what is the reason memoized is not volatile? Makes things smaller and a lot more readable?", "author": "pkriens", "createdAt": "2020-04-25T09:56:40Z", "path": "aQute.libg/src/aQute/lib/memoize/CloseableMemoizingSupplier.java", "diffHunk": "@@ -2,74 +2,109 @@\n \n import static java.util.Objects.requireNonNull;\n \n+import java.util.concurrent.locks.StampedLock;\n import java.util.function.Consumer;\n import java.util.function.Supplier;\n \n+/**\n+ * The object can exist in one of three states:\n+ * <ul>\n+ * <li>initial which means neither {@code get} or {@code close} has been called.\n+ * From this state, the object can transition directly to either open or\n+ * closed.</li>\n+ * <li>open which means memoized is non-null with the value from the wrapped\n+ * supplier. From this state, the object can transition to closed.</li>\n+ * <li>closed which means memoized is null and any value it may have held was\n+ * closed. This is a terminal state.</li>\n+ * </ul>\n+ */\n class CloseableMemoizingSupplier<T extends AutoCloseable> implements CloseableMemoize<T> {\n \tprivate final Supplier<? extends T>\tsupplier;\n-\t// @GuardedBy(\"this\")\n-\tprivate boolean\t\t\t\t\t\tclosed\t= false;\n-\tprivate volatile T\t\t\t\t\tmemoized;\n+\tprivate final StampedLock\t\t\tlock;\n+\tprivate volatile boolean\t\t\tinitial;\n+\t// @GuardedBy(\"initial\")\n+\tprivate T\t\t\t\t\t\t\tmemoized;\n \n \tCloseableMemoizingSupplier(Supplier<? extends T> supplier) {\n \t\tthis.supplier = requireNonNull(supplier);\n+\t\tlock = new StampedLock();\n+\t\tinitial = true;\n \t}\n \n \t@Override\n \tpublic T get() {\n-\t\tif (memoized == null) {\n-\t\t\tsynchronized (this) {\n-\t\t\t\tif (closed)\n-\t\t\t\t\tthrow new IllegalStateException(\"Already closed\");\n-\t\t\t\treturn get0();\n+\t\t// read initial _before_ read memoized\n+\t\tif (initial) {\n+\t\t\t// critical section: only one at a time\n+\t\t\tfinal long stamp = lock.writeLock();\n+\t\t\ttry {\n+\t\t\t\tif (initial) {\n+\t\t\t\t\tT result = requireNonNull(supplier.get());\n+\t\t\t\t\tmemoized = result;\n+\t\t\t\t\t// write initial _after_ write memoized\n+\t\t\t\t\tinitial = false;\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t} finally {\n+\t\t\t\tlock.unlockWrite(stamp);\n \t\t\t}\n \t\t}\n-\t\treturn memoized;\n-\t}\n-\n-\tprivate T get0() {\n-\t\tif (memoized == null) {\n-\t\t\tmemoized = supplier.get();\n-\t\t\tassert memoized != null;\n+\t\tT result = memoized;\n+\t\tif (result == null) {\n+\t\t\tthrow new IllegalStateException(\"closed\");\n \t\t}\n-\t\treturn memoized;\n+\t\treturn result;\n \t}\n \n \t@Override\n \tpublic T peek() {\n+\t\t// read initial _before_ read memoized\n+\t\tif (initial) {", "originalCommit": "6d40187fbc0bf14ed1ca334ba0e79830751282ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyODYzNQ==", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415028635", "bodyText": "making memoizd volatile saves a lot of this hard to read code, why doing it so complicated?", "author": "pkriens", "createdAt": "2020-04-25T09:58:53Z", "path": "aQute.libg/src/aQute/lib/memoize/CloseableMemoizingSupplier.java", "diffHunk": "@@ -2,74 +2,109 @@\n \n import static java.util.Objects.requireNonNull;\n \n+import java.util.concurrent.locks.StampedLock;\n import java.util.function.Consumer;\n import java.util.function.Supplier;\n \n+/**\n+ * The object can exist in one of three states:\n+ * <ul>\n+ * <li>initial which means neither {@code get} or {@code close} has been called.\n+ * From this state, the object can transition directly to either open or\n+ * closed.</li>\n+ * <li>open which means memoized is non-null with the value from the wrapped\n+ * supplier. From this state, the object can transition to closed.</li>\n+ * <li>closed which means memoized is null and any value it may have held was\n+ * closed. This is a terminal state.</li>\n+ * </ul>\n+ */\n class CloseableMemoizingSupplier<T extends AutoCloseable> implements CloseableMemoize<T> {\n \tprivate final Supplier<? extends T>\tsupplier;\n-\t// @GuardedBy(\"this\")\n-\tprivate boolean\t\t\t\t\t\tclosed\t= false;\n-\tprivate volatile T\t\t\t\t\tmemoized;\n+\tprivate final StampedLock\t\t\tlock;\n+\tprivate volatile boolean\t\t\tinitial;\n+\t// @GuardedBy(\"initial\")\n+\tprivate T\t\t\t\t\t\t\tmemoized;\n \n \tCloseableMemoizingSupplier(Supplier<? extends T> supplier) {\n \t\tthis.supplier = requireNonNull(supplier);\n+\t\tlock = new StampedLock();\n+\t\tinitial = true;\n \t}\n \n \t@Override\n \tpublic T get() {\n-\t\tif (memoized == null) {\n-\t\t\tsynchronized (this) {\n-\t\t\t\tif (closed)\n-\t\t\t\t\tthrow new IllegalStateException(\"Already closed\");\n-\t\t\t\treturn get0();\n+\t\t// read initial _before_ read memoized\n+\t\tif (initial) {\n+\t\t\t// critical section: only one at a time\n+\t\t\tfinal long stamp = lock.writeLock();\n+\t\t\ttry {\n+\t\t\t\tif (initial) {\n+\t\t\t\t\tT result = requireNonNull(supplier.get());\n+\t\t\t\t\tmemoized = result;\n+\t\t\t\t\t// write initial _after_ write memoized\n+\t\t\t\t\tinitial = false;\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t} finally {\n+\t\t\t\tlock.unlockWrite(stamp);\n \t\t\t}\n \t\t}\n-\t\treturn memoized;\n-\t}\n-\n-\tprivate T get0() {\n-\t\tif (memoized == null) {\n-\t\t\tmemoized = supplier.get();\n-\t\t\tassert memoized != null;\n+\t\tT result = memoized;\n+\t\tif (result == null) {\n+\t\t\tthrow new IllegalStateException(\"closed\");\n \t\t}\n-\t\treturn memoized;\n+\t\treturn result;\n \t}\n \n \t@Override\n \tpublic T peek() {\n+\t\t// read initial _before_ read memoized\n+\t\tif (initial) {\n+\t\t\treturn null;\n+\t\t}\n \t\treturn memoized;\n \t}\n \n \t@Override\n-\tpublic synchronized boolean isClosed() {\n-\t\treturn closed;\n+\tpublic boolean isClosed() {\n+\t\t// read initial _before_ read memoized\n+\t\treturn !initial && (memoized == null);\n \t}\n \n \t@Override\n \tpublic void close() throws Exception {\n-\t\tT current;\n-\t\tsynchronized (this) {\n-\t\t\tif (closed)\n-\t\t\t\treturn;\n-\n-\t\t\tclosed = true;\n-\n-\t\t\tif (memoized == null)\n-\t\t\t\treturn;\n-\n-\t\t\tcurrent = memoized;\n-\t\t\tmemoized = null;\n+\t\tif (!isClosed()) {\n+\t\t\tAutoCloseable closeable;\n+\t\t\t// critical section: only one at a time\n+\t\t\tfinal long stamp = lock.writeLock();\n+\t\t\ttry {\n+\t\t\t\tif (initial) {\n+\t\t\t\t\tinitial = false;\n+\t\t\t\t\treturn; // no value to close\n+\t\t\t\t}\n+\t\t\t\tcloseable = memoized;\n+\t\t\t\tmemoized = null; // mark closed\n+\t\t\t\t// write initial _after_ write memoized\n+\t\t\t\tinitial = false; // even though it is already false", "originalCommit": "6d40187fbc0bf14ed1ca334ba0e79830751282ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAzMzAwNQ==", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415033005", "bodyText": "The code may be a little non-straight forward but it is designed to only have a single read barrier for the normal case on get. I have review other performance tuned code which does similar work and similar techniques are used to optimize the normal case.", "author": "bjhargrave", "createdAt": "2020-04-25T10:26:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyODYzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU1NDYzNA==", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415554634", "bodyText": "it is an interesting puzzle ... my objection is that it does make the code hard to understand. It is a lot clearer now but I've always been pretty hard on simple is better unless proven otherwise. You lately seem to more and more go to small optimizations over readability.\nJust for theory, let me try to come up with something that is more readable and only has one read barrier for the common case.\nDid you introduce the StampedLock (first time I run into it...) because you can then have a read lock on the accept? Or is there some other advantage over a synchronized block?", "author": "pkriens", "createdAt": "2020-04-27T06:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyODYzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5Njc2OA==", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415796768", "bodyText": "Did you introduce the StampedLock (first time I run into it...) because you can then have a read lock on the accept?\n\nI used it for the read/write lock support which is much simpler then ReentrantReadWriteLock. Some actions (initial get and close) need exclusive (write) locks while accept needs a non-exclusive (read) lock to hold off close. The accept method can now get the write lock if needed and downgrade to the read lock before calling the consumer.\nStampedLocks are much faster than ReentrantReadWriteLocks but they are not reentrant (which we did not need) and also have some other limitations (which were not an issue for this usage).", "author": "bjhargrave", "createdAt": "2020-04-27T13:08:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyODYzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg2OTk3Nw==", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415869977", "bodyText": "I noticed StampedLocks are not reentrant. So if accept calls accept, we have a deadlock. Shouldn't we have a timeout to break this?", "author": "pkriens", "createdAt": "2020-04-27T14:39:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyODYzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg3ODUwNg==", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415878506", "bodyText": "read locks are non-exclusive, so we wont have any issue with reentrancy on accept. The reentrant call will just get another non-exclusive read lock and then release it when it returns. I confirmed this by tweaking the test case to reentrantly call accept.\ndiff --git a/aQute.libg/test/aQute/lib/memoize/MemoizeTest.java b/aQute.libg/test/aQute/lib/memoize/MemoizeTest.java\nindex 5589a943d..155313cd1 100644\n--- a/aQute.libg/test/aQute/lib/memoize/MemoizeTest.java\n+++ b/aQute.libg/test/aQute/lib/memoize/MemoizeTest.java\n@@ -368,18 +368,18 @@ public class MemoizeTest {\n                CountDownLatch consumerReady = new CountDownLatch(multi);\n                CountDownLatch consumerSync = new CountDownLatch(1);\n                CountDownLatch consumerDone = new CountDownLatch(multi);\n-               Consumer<AutoCloseable> consumer = asConsumer(s -> {\n-                       consumerReady.countDown();\n-                       if (consumerSync.await(20, TimeUnit.SECONDS)) {\n-                               consumerDone.countDown();\n-                       }\n-               });\n \n                CountDownLatch threadReady = new CountDownLatch(multi);\n                CountDownLatch threadSync = new CountDownLatch(1);\n                ExecutorService threadPool = Executors.newFixedThreadPool(multi);\n                Supplier<CloseableClass> source = () -> new CloseableClass(count.incrementAndGet());\n                try (CloseableMemoize<AutoCloseable> memoized = CloseableMemoize.closeableSupplier(source)) {\n+                       Consumer<AutoCloseable> consumer = asConsumer(s -> {\n+                               consumerReady.countDown();\n+                               if (consumerSync.await(20, TimeUnit.SECONDS)) {\n+                                       memoized.accept(x -> consumerDone.countDown());\n+                               }\n+                       });\n                        for (int i = 0; i < multi; i++) {\n                                threadPool.execute(asRunnable(() -> {\n                                        threadReady.countDown();", "author": "bjhargrave", "createdAt": "2020-04-27T14:49:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyODYzNQ=="}], "type": "inlineReview"}]}