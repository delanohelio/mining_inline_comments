{"pr_number": 5691, "pr_title": "5052 utility class for AbstractNode background tasks", "pr_createdAt": "2020-03-09T21:52:13Z", "pr_url": "https://github.com/sleuthkit/autopsy/pull/5691", "timeline": [{"oid": "468e0b95e9ee8c16e727ba751128d6afb43b88e6", "url": "https://github.com/sleuthkit/autopsy/commit/468e0b95e9ee8c16e727ba751128d6afb43b88e6", "message": "5052 utility class for AbstractNode backforund tasks", "committedDate": "2020-03-09T21:51:39Z", "type": "commit"}, {"oid": "bd42ee66a937adcab5735afd78f19e6c9efe15a6", "url": "https://github.com/sleuthkit/autopsy/commit/bd42ee66a937adcab5735afd78f19e6c9efe15a6", "message": "5052 utility class for AbstractNode backforund tasks", "committedDate": "2020-03-09T21:56:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ0MTk3Mw==", "url": "https://github.com/sleuthkit/autopsy/pull/5691#discussion_r390441973", "bodyText": "Future.cancel() will set the interrupt flag on the underlying thread. What additional functionality do you want from Future that couldn't be solved with a check to Thread.currentThread().isInterrupted()?", "author": "dannysmyda", "createdAt": "2020-03-10T16:23:12Z", "path": "Core/src/org/sleuthkit/autopsy/datamodel/utils/BackgroundTaskRunner.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.datamodel.utils;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.lang.ref.WeakReference;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.logging.Level;\n+import org.openide.nodes.AbstractNode;\n+import org.openide.util.WeakListeners;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.datamodel.AbstractContentNode;\n+\n+/**\n+ * A utility that allows AbstractNode subclasses to execute background tasks in\n+ * threads in a thread pool. An AbstractNode subclass client needs to provide an\n+ * implementation of the NodeTask interface that does the background task and\n+ * returns the task result in the form of a PropertyChangeEvent. It also needs\n+ * to provide an implementation of a PropertyChangeListener to handle the\n+ * PropertyChangeEvent returned by the NodeTask. The utility uses weak\n+ * references to the AbstractNode and the PropertyChangeListener to safely\n+ * return results to the node, if it has not been destroyed by the NetBeans\n+ * framework at the time the task is completed.\n+ */\n+public final class BackgroundTaskRunner {\n+\n+    private static final Logger logger = Logger.getLogger(AbstractContentNode.class.getName());\n+    private static final Integer THREAD_POOL_SIZE = 10;\n+    private static final ExecutorService executor = Executors.newFixedThreadPool(THREAD_POOL_SIZE, new ThreadFactoryBuilder().setNameFormat(\"node-background-task-%d\").build());\n+\n+    /**\n+     * Implementations of this interface do a task in a background thread\n+     * supplied by this utility.\n+     */\n+    @FunctionalInterface\n+    public interface NodeTask {\n+\n+        /**\n+         * Performs a task in a thread supplied by this utility.\n+         *\n+         * @param future The future of the actual background task executing this", "originalCommit": "bd42ee66a937adcab5735afd78f19e6c9efe15a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ0NTQ5Ng==", "url": "https://github.com/sleuthkit/autopsy/pull/5691#discussion_r390445496", "bodyText": "This impl invites deadlock. Future.get() will block one of the Threads indefinitely.", "author": "dannysmyda", "createdAt": "2020-03-10T16:28:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ0MTk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ1OTE5OA==", "url": "https://github.com/sleuthkit/autopsy/pull/5691#discussion_r390459198", "bodyText": "See reply below.", "author": "rcordovano", "createdAt": "2020-03-10T16:48:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ0MTk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ0MjQyMA==", "url": "https://github.com/sleuthkit/autopsy/pull/5691#discussion_r390442420", "bodyText": "For instance, this could be a check to Thread.currentThread().isInterrupted(). Then the problem of passing the Future before execution is gone.", "author": "dannysmyda", "createdAt": "2020-03-10T16:23:49Z", "path": "Core/src/org/sleuthkit/autopsy/datamodel/utils/BackgroundTaskRunner.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.datamodel.utils;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.lang.ref.WeakReference;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.logging.Level;\n+import org.openide.nodes.AbstractNode;\n+import org.openide.util.WeakListeners;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.datamodel.AbstractContentNode;\n+\n+/**\n+ * A utility that allows AbstractNode subclasses to execute background tasks in\n+ * threads in a thread pool. An AbstractNode subclass client needs to provide an\n+ * implementation of the NodeTask interface that does the background task and\n+ * returns the task result in the form of a PropertyChangeEvent. It also needs\n+ * to provide an implementation of a PropertyChangeListener to handle the\n+ * PropertyChangeEvent returned by the NodeTask. The utility uses weak\n+ * references to the AbstractNode and the PropertyChangeListener to safely\n+ * return results to the node, if it has not been destroyed by the NetBeans\n+ * framework at the time the task is completed.\n+ */\n+public final class BackgroundTaskRunner {\n+\n+    private static final Logger logger = Logger.getLogger(AbstractContentNode.class.getName());\n+    private static final Integer THREAD_POOL_SIZE = 10;\n+    private static final ExecutorService executor = Executors.newFixedThreadPool(THREAD_POOL_SIZE, new ThreadFactoryBuilder().setNameFormat(\"node-background-task-%d\").build());\n+\n+    /**\n+     * Implementations of this interface do a task in a background thread\n+     * supplied by this utility.\n+     */\n+    @FunctionalInterface\n+    public interface NodeTask {\n+\n+        /**\n+         * Performs a task in a thread supplied by this utility.\n+         *\n+         * @param future The future of the actual background task executing this\n+         *               method, may be checked for task cancellation.\n+         *\n+         * @return A PropertyChangeEvent holding the result of the task.\n+         *\n+         * @throws Exception If there is an error performing the task.\n+         */\n+        PropertyChangeEvent run(Future<?> future) throws Exception;\n+    }\n+\n+    /**\n+     * Submits a background task for an AbstractNode to a dedicated thread pool.\n+     *\n+     * @param node     The AbstractNode.\n+     * @param task     The task to be done in the background.\n+     * @param listener A PropertyChangeListener for the AbstractNode to handle\n+     *                 the PropertyChangeEvent produced by the task.\n+     *\n+     * @return The Future for the Runnable used to run the task.\n+     */\n+    public static Future<?> submitTask(AbstractNode node, NodeTask task, PropertyChangeListener listener) {\n+        NodeBackgroundTask backgroundTask = new NodeBackgroundTask(node, task, listener);\n+        Future<?> future = executor.submit(backgroundTask);\n+        backgroundTask.setFuture(future);\n+        return future;\n+    }\n+\n+    /**\n+     * A Runnable that uses weak references to an AbstractNode and the\n+     * PropertyChangeListener for the node to safely return results to the node,\n+     * if it has not been destroyed by the NetBeans framework at the time the\n+     * task is completed.\n+     */\n+    private static class NodeBackgroundTask implements Runnable {\n+\n+        private final WeakReference<AbstractNode> weakNodeRef;\n+        private final NodeTask task;\n+        private final PropertyChangeListener weakListenerRef;\n+        private Future<?> future;\n+\n+        /**\n+         * Constructs a Runnable that uses weak references to an AbstractNode\n+         * and the PropertyChangeListener for the node to safely return results\n+         * to the node, if it still exists at the time the task is completed.\n+         *\n+         * @param node     The AbstractNode.\n+         * @param task     The task to be done in the background.\n+         * @param listener A PropertyChangeListener for the AbstractNode to\n+         *                 handle the PropertyChangeEvent produced by the task.\n+         */\n+        private NodeBackgroundTask(AbstractNode node, NodeTask task, PropertyChangeListener listener) {\n+            this.weakNodeRef = new WeakReference<>(node);\n+            this.task = task;\n+            this.weakListenerRef = WeakListeners.propertyChange(listener, null);\n+        }\n+\n+        @Override\n+        public void run() {\n+            AbstractNode node = weakNodeRef.get();\n+            if (node == null) {\n+                return;\n+            }\n+\n+            if (future.isCancelled()) {", "originalCommit": "bd42ee66a937adcab5735afd78f19e6c9efe15a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ1ODk2OQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5691#discussion_r390458969", "bodyText": "I have used that technique before. I agree that it is a good simplification. It just means that the task client doing the cancellation needs to call Future.cancel(true).", "author": "rcordovano", "createdAt": "2020-03-10T16:47:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ0MjQyMA=="}], "type": "inlineReview"}, {"oid": "e93ff5e39f9b8e70479e3f7b2d8deba9af36d1c5", "url": "https://github.com/sleuthkit/autopsy/commit/e93ff5e39f9b8e70479e3f7b2d8deba9af36d1c5", "message": "NodeBackgroundTaskRunner to AbstractNodePropertySheetTask", "committedDate": "2020-03-10T18:05:58Z", "type": "commit"}, {"oid": "e8fe6ec1e57be944070c456c1fe767945d9b6c17", "url": "https://github.com/sleuthkit/autopsy/commit/e8fe6ec1e57be944070c456c1fe767945d9b6c17", "message": "NodeBackgroundTaskRunner to AbstractNodePropertySheetTask", "committedDate": "2020-03-10T18:09:14Z", "type": "commit"}, {"oid": "e5d36505514a9ae2e6a1c57ed49eabaacd3896a2", "url": "https://github.com/sleuthkit/autopsy/commit/e5d36505514a9ae2e6a1c57ed49eabaacd3896a2", "message": "NodeBackgroundTaskRunner to AbstractNodePropertySheetTask", "committedDate": "2020-03-10T18:11:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyMTgxMQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5691#discussion_r390521811", "bodyText": "The signature should likely be PropertySheetTask<T extends AbstractNode>. See the comment on computePropertyValue for more details.", "author": "dannysmyda", "createdAt": "2020-03-10T18:24:14Z", "path": "Core/src/org/sleuthkit/autopsy/datamodel/utils/AbstractNodePropertySheetTask.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.datamodel.utils;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.lang.ref.WeakReference;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.logging.Level;\n+import org.openide.nodes.AbstractNode;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.datamodel.AbstractContentNode;\n+\n+/**\n+ * An abstract base class for background tasks needed to compute values for the\n+ * property sheet of an AbstractNode.\n+ *\n+ * The results of the computation are returned by firing a PropertyChangeEvent\n+ * and the run method has an exception firewall with logging. These features\n+ * relieve the AbstractNode from having to create a thread to block on the get()\n+ * method of the task Future.\n+ *\n+ * Only weak references to the AbstractNode and its PropertyChangeListener are\n+ * held prior to task execution so that a queued task does not interfere with\n+ * garbage collection if the node has been destroyed by the NetBeans framework.\n+ *\n+ * A thread pool with descriptively named threads (node-background-task-N) is\n+ * provided for executing instances of the tasks.\n+ */\n+public abstract class AbstractNodePropertySheetTask implements Runnable {", "originalCommit": "e5d36505514a9ae2e6a1c57ed49eabaacd3896a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyODk0MA==", "url": "https://github.com/sleuthkit/autopsy/pull/5691#discussion_r390528940", "bodyText": "Kk.", "author": "rcordovano", "createdAt": "2020-03-10T18:36:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyMTgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyMzAyMw==", "url": "https://github.com/sleuthkit/autopsy/pull/5691#discussion_r390523023", "bodyText": "Lets assume the background task logic we are submitting is for a LocalFileNode. Its routine depends entirely on the result of LocalFileNode.hasContentChildren(). How will I be able to utilize this class for my use case?", "author": "dannysmyda", "createdAt": "2020-03-10T18:26:13Z", "path": "Core/src/org/sleuthkit/autopsy/datamodel/utils/AbstractNodePropertySheetTask.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.datamodel.utils;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.lang.ref.WeakReference;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.logging.Level;\n+import org.openide.nodes.AbstractNode;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.datamodel.AbstractContentNode;\n+\n+/**\n+ * An abstract base class for background tasks needed to compute values for the\n+ * property sheet of an AbstractNode.\n+ *\n+ * The results of the computation are returned by firing a PropertyChangeEvent\n+ * and the run method has an exception firewall with logging. These features\n+ * relieve the AbstractNode from having to create a thread to block on the get()\n+ * method of the task Future.\n+ *\n+ * Only weak references to the AbstractNode and its PropertyChangeListener are\n+ * held prior to task execution so that a queued task does not interfere with\n+ * garbage collection if the node has been destroyed by the NetBeans framework.\n+ *\n+ * A thread pool with descriptively named threads (node-background-task-N) is\n+ * provided for executing instances of the tasks.\n+ */\n+public abstract class AbstractNodePropertySheetTask implements Runnable {\n+\n+    private static final Logger LOGGER = Logger.getLogger(AbstractContentNode.class.getName());\n+    private static final Integer THREAD_POOL_SIZE = 10;\n+    private static final ExecutorService executor = Executors.newFixedThreadPool(THREAD_POOL_SIZE, new ThreadFactoryBuilder().setNameFormat(\"node-background-task-%d\").build());\n+    private final WeakReference<AbstractNode> weakNodeRef;\n+    private final WeakReference<PropertyChangeListener> weakListenerRef;\n+\n+    /**\n+     * Submits a task to compute values for the property sheet of an\n+     * AbstractNode to a thread pool dedicated to such tasks with descriptively\n+     * named threads (node-background-task-N).\n+     *\n+     * @param task The task.\n+     *\n+     * @return The Future of the task, may be used for task cancellation by\n+     *         calling Future.cancel(true).\n+     */\n+    public static Future<?> submitTask(AbstractNodePropertySheetTask task) {\n+        return executor.submit(task);\n+    }\n+\n+    /**\n+     * Constructs an abstract base class for background tasks needed to compute\n+     * values for the property sheet of an AbstractNode.\n+     *\n+     * The results of the computation are returned by firing a\n+     * PropertyChangeEvent and the run method has an exception firewall with\n+     * logging. These features relieve the AbstractNode from having to create a\n+     * thread to block on the get() method of the task Future.\n+     *\n+     * Only weak references to the AbstractNode and its PropertyChangeListener\n+     * are held prior to task execution so that a queued task does not interfere\n+     * with garbage collection if the node has been destroyed by the NetBeans\n+     * framework.\n+     *\n+     * A thread pool with descriptively named threads (node-background-task-N)\n+     * is provided for executing instances of the tasks.\n+     *\n+     * @param node     The node.\n+     * @param listener A property change listener for the node.\n+     */\n+    protected AbstractNodePropertySheetTask(AbstractNode node, PropertyChangeListener listener) {\n+        this.weakNodeRef = new WeakReference<>(node);\n+        this.weakListenerRef = new WeakReference<>(listener);\n+    }\n+\n+    /**\n+     * Computes the values for the property sheet of an AbstractNode. The\n+     * results of the computation are returned as a PropertyChangeEvent which is\n+     * fired to the PropertyChangeEventListener of the node.\n+     *\n+     * IMPORTANT: Implementations of this method should check for cancellation\n+     * by calling Thread.currentThread().isInterrupted() at approoraite\n+     * intervals.\n+     *\n+     * @param node The AbstractNode.\n+     *\n+     * @return The result of the computation as a PropertyChangeEvent.\n+     */\n+    protected abstract PropertyChangeEvent computePropertyValue(AbstractNode node) throws Exception;", "originalCommit": "e5d36505514a9ae2e6a1c57ed49eabaacd3896a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyOTA2OA==", "url": "https://github.com/sleuthkit/autopsy/pull/5691#discussion_r390529068", "bodyText": "Using generic, as suggested.", "author": "rcordovano", "createdAt": "2020-03-10T18:36:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyMzAyMw=="}], "type": "inlineReview"}, {"oid": "3038a9b869c26cb4a960cc6a633478caf75fb8b5", "url": "https://github.com/sleuthkit/autopsy/commit/3038a9b869c26cb4a960cc6a633478caf75fb8b5", "message": "NodeBackgroundTaskRunner to AbstractNodePropertySheetTask", "committedDate": "2020-03-10T18:36:47Z", "type": "commit"}]}