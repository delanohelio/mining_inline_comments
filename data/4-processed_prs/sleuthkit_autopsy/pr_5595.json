{"pr_number": 5595, "pr_title": "1379, 1389, & 1390 kml geolocation track support", "pr_createdAt": "2020-01-15T14:50:25Z", "pr_url": "https://github.com/sleuthkit/autopsy/pull/5595", "timeline": [{"oid": "f90f86170acef437d7bb1c41cb7124d8e4a6be7e", "url": "https://github.com/sleuthkit/autopsy/commit/f90f86170acef437d7bb1c41cb7124d8e4a6be7e", "message": "Inital commit of drone parse code", "committedDate": "2020-01-03T17:15:45Z", "type": "commit"}, {"oid": "b8af7a3a9dbc06554e516c434613782f53bed79a", "url": "https://github.com/sleuthkit/autopsy/commit/b8af7a3a9dbc06554e516c434613782f53bed79a", "message": "Changed sample rate adn modified attribute names", "committedDate": "2020-01-06T19:50:25Z", "type": "commit"}, {"oid": "080c5370aef7732b44831b06e37113e961e491ac", "url": "https://github.com/sleuthkit/autopsy/commit/080c5370aef7732b44831b06e37113e961e491ac", "message": "Updated to use Artifact helper to create TSK_GEO_TRACK artifacts", "committedDate": "2020-01-09T18:12:24Z", "type": "commit"}, {"oid": "0885cae26420a3c5f66d202f9a36a6b4f3035751", "url": "https://github.com/sleuthkit/autopsy/commit/0885cae26420a3c5f66d202f9a36a6b4f3035751", "message": "Refactored for sleuthkit file move", "committedDate": "2020-01-09T19:22:31Z", "type": "commit"}, {"oid": "6ac91235e5920e48fd0b9bd0362e901488305e5f", "url": "https://github.com/sleuthkit/autopsy/commit/6ac91235e5920e48fd0b9bd0362e901488305e5f", "message": "Updated due for changes to GeoArtifactHelper", "committedDate": "2020-01-10T15:05:12Z", "type": "commit"}, {"oid": "fe04b10b248d16a1aae1b8f53d871e952f375603", "url": "https://github.com/sleuthkit/autopsy/commit/fe04b10b248d16a1aae1b8f53d871e952f375603", "message": "Merge branch 'develop' into 1379-drone-DAT-ingest-module", "committedDate": "2020-01-10T15:39:07Z", "type": "commit"}, {"oid": "734b840ce9ffbe4573a9dff599b564cd913b7ed3", "url": "https://github.com/sleuthkit/autopsy/commit/734b840ce9ffbe4573a9dff599b564cd913b7ed3", "message": "Fixed codacy issue", "committedDate": "2020-01-10T16:19:06Z", "type": "commit"}, {"oid": "b0215cacc9234bd35749a6def37b18e10aed7782", "url": "https://github.com/sleuthkit/autopsy/commit/b0215cacc9234bd35749a6def37b18e10aed7782", "message": "Added tracks to geolocation window and KML report", "committedDate": "2020-01-15T14:47:36Z", "type": "commit"}, {"oid": "5b290dea4bb7f4b615a475c5884a6d70ae115585", "url": "https://github.com/sleuthkit/autopsy/commit/5b290dea4bb7f4b615a475c5884a6d70ae115585", "message": "Merge branch 'develop' into 1379-drone-DAT-ingest-module", "committedDate": "2020-01-15T15:27:03Z", "type": "commit"}, {"oid": "544974f7e8a31c9228f3a4b27559979e9d3bbfff", "url": "https://github.com/sleuthkit/autopsy/commit/544974f7e8a31c9228f3a4b27559979e9d3bbfff", "message": "Merge branch '1379-drone-DAT-ingest-module' into 1390-KML-geolocation-track-support", "committedDate": "2020-01-15T15:28:14Z", "type": "commit"}, {"oid": "0a006421e7af25b98fcec48871649ceb6f3ec8bf", "url": "https://github.com/sleuthkit/autopsy/commit/0a006421e7af25b98fcec48871649ceb6f3ec8bf", "message": "Geolocation changes to address codacy issues", "committedDate": "2020-01-15T16:08:59Z", "type": "commit"}, {"oid": "f415213afc5e7d36d31bbb4e944c5d7e3850db92", "url": "https://github.com/sleuthkit/autopsy/commit/f415213afc5e7d36d31bbb4e944c5d7e3850db92", "message": "Addressed codacy issue", "committedDate": "2020-01-15T16:24:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAwMDgwOQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5595#discussion_r368000809", "bodyText": "Do we plan to address the Codacy comment about name of this class?\nWhen I hear \"Path\" - what first comes to my mind is a file or directory path,  not path as a series of location points.", "author": "raman-bt", "createdAt": "2020-01-17T15:43:01Z", "path": "Core/src/org/sleuthkit/autopsy/geolocation/datamodel/Path.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ *\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.geolocation.datamodel;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.Content;\n+import org.sleuthkit.datamodel.SleuthkitCase;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * Class representing a series of waypoints that form a path.\n+ */\n+public class Path {", "originalCommit": "f415213afc5e7d36d31bbb4e944c5d7e3850db92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyMTIyMw==", "url": "https://github.com/sleuthkit/autopsy/pull/5595#discussion_r368021223", "bodyText": "I know.  I was a little stumped on a name for that class.  I was thinking like a path that you following.  I am open to suggestions.", "author": "kellykelly3", "createdAt": "2020-01-17T16:22:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAwMDgwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYwNTEzMg==", "url": "https://github.com/sleuthkit/autopsy/pull/5595#discussion_r369605132", "bodyText": "How about GeoPath?", "author": "rcordovano", "createdAt": "2020-01-22T14:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAwMDgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyMTg1MQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5595#discussion_r368021851", "bodyText": "Gets the list of tracks...", "author": "raman-bt", "createdAt": "2020-01-17T16:24:03Z", "path": "Core/src/org/sleuthkit/autopsy/geolocation/datamodel/Path.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ *\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.geolocation.datamodel;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.Content;\n+import org.sleuthkit.datamodel.SleuthkitCase;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * Class representing a series of waypoints that form a path.\n+ */\n+public class Path {\n+\n+    private final List<Waypoint> waypointList;\n+    private final String pathName;\n+    private final BlackboardArtifact artifact;\n+\n+    /**\n+     * Gets the list of Routes from the TSK_GPS_ROUTE artifacts.\n+     *\n+     * @param skCase Currently open SleuthkitCase\n+     *\n+     * @return List of Route objects, empty list will be returned if no Routes\n+     *         were found\n+     *\n+     * @throws GeoLocationDataException\n+     */\n+    static public List<Route> getRoutes(SleuthkitCase skCase) throws GeoLocationDataException {\n+        List<BlackboardArtifact> artifacts = null;\n+        try {\n+            artifacts = skCase.getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_ROUTE);\n+        } catch (TskCoreException ex) {\n+            throw new GeoLocationDataException(\"Unable to get artifacts for type: TSK_GPS_BOOKMARK\", ex);\n+        }\n+\n+        List<Route> routes = new ArrayList<>();\n+        for (BlackboardArtifact artifact : artifacts) {\n+            Route route = new Route(artifact);\n+            routes.add(route);\n+        }\n+        return routes;\n+    }\n+\n+    /**\n+     * Gets the list of Routes from the TSK_GPS_TRACK artifacts.", "originalCommit": "f415213afc5e7d36d31bbb4e944c5d7e3850db92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyMjAwOA==", "url": "https://github.com/sleuthkit/autopsy/pull/5595#discussion_r368022008", "bodyText": "List of track objects....", "author": "raman-bt", "createdAt": "2020-01-17T16:24:23Z", "path": "Core/src/org/sleuthkit/autopsy/geolocation/datamodel/Path.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ *\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.geolocation.datamodel;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.Content;\n+import org.sleuthkit.datamodel.SleuthkitCase;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * Class representing a series of waypoints that form a path.\n+ */\n+public class Path {\n+\n+    private final List<Waypoint> waypointList;\n+    private final String pathName;\n+    private final BlackboardArtifact artifact;\n+\n+    /**\n+     * Gets the list of Routes from the TSK_GPS_ROUTE artifacts.\n+     *\n+     * @param skCase Currently open SleuthkitCase\n+     *\n+     * @return List of Route objects, empty list will be returned if no Routes\n+     *         were found\n+     *\n+     * @throws GeoLocationDataException\n+     */\n+    static public List<Route> getRoutes(SleuthkitCase skCase) throws GeoLocationDataException {\n+        List<BlackboardArtifact> artifacts = null;\n+        try {\n+            artifacts = skCase.getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_ROUTE);\n+        } catch (TskCoreException ex) {\n+            throw new GeoLocationDataException(\"Unable to get artifacts for type: TSK_GPS_BOOKMARK\", ex);\n+        }\n+\n+        List<Route> routes = new ArrayList<>();\n+        for (BlackboardArtifact artifact : artifacts) {\n+            Route route = new Route(artifact);\n+            routes.add(route);\n+        }\n+        return routes;\n+    }\n+\n+    /**\n+     * Gets the list of Routes from the TSK_GPS_TRACK artifacts.\n+     *\n+     * @param skCase     Currently open SleuthkitCase\n+     * @param sourceList List of source to return tracks from, maybe null to\n+     *                   return tracks from all sources\n+     *\n+     * @return List of Route objects, empty list will be returned if no Routes", "originalCommit": "f415213afc5e7d36d31bbb4e944c5d7e3850db92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyNjg2Mw==", "url": "https://github.com/sleuthkit/autopsy/pull/5595#discussion_r368026863", "bodyText": "Latest timestamp...", "author": "raman-bt", "createdAt": "2020-01-17T16:34:08Z", "path": "Core/src/org/sleuthkit/autopsy/geolocation/datamodel/Track.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ *\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.geolocation.datamodel;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.blackboardutils.attributes.GeoTrackPoints;\n+import org.sleuthkit.datamodel.blackboardutils.attributes.GeoWaypoint.GeoTrackPoint;\n+\n+/**\n+ * A GPS track with which wraps the TSK_GPS_TRACK artifact.\n+ */\n+public final class Track extends Path{\n+\n+    private final Long startTimestamp;\n+    private final Long endTimeStamp;\n+\n+    /**\n+     * Construct a new Track for the given artifact.\n+     * \n+     * @param artifact\n+     * \n+     * @throws GeoLocationDataException \n+     */\n+    public Track(BlackboardArtifact artifact) throws GeoLocationDataException {\n+        this(artifact, Waypoint.getAttributesFromArtifactAsMap(artifact));\n+    }\n+\n+    /**\n+     * Construct a Track for the given artifact and attributeMap.\n+     * \n+     * @param artifact TSK_GPD_TRACK artifact\n+     * @param attributeMap  Map of the artifact attributes\n+     * \n+     * @throws GeoLocationDataException \n+     */\n+    private Track(BlackboardArtifact artifact, Map<BlackboardAttribute.ATTRIBUTE_TYPE, BlackboardAttribute> attributeMap) throws GeoLocationDataException {\n+        super(artifact, getTrackName(attributeMap));\n+\n+        List<GeoTrackPoint> points = getPointsList(attributeMap);\n+        buildPath(points);\n+\n+        startTimestamp = findStartTime(points);\n+        endTimeStamp = findEndTime(points);\n+    }\n+    \n+    /**\n+     * Returns the start time of this track.\n+     * \n+     * @return  Earliest time, or null if none was available. \n+     *          (seconds from java epoch)\n+     */\n+    public Long getStartTime() {\n+        return startTimestamp;\n+    }\n+    \n+    /**\n+     * Returns the end time of this track.\n+     * \n+     * @return  Earliest timestamp, or null if none was available. ", "originalCommit": "f415213afc5e7d36d31bbb4e944c5d7e3850db92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMDc0OA==", "url": "https://github.com/sleuthkit/autopsy/pull/5595#discussion_r368030748", "bodyText": "Last non null....", "author": "raman-bt", "createdAt": "2020-01-17T16:42:13Z", "path": "Core/src/org/sleuthkit/autopsy/geolocation/datamodel/Track.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ *\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.geolocation.datamodel;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.blackboardutils.attributes.GeoTrackPoints;\n+import org.sleuthkit.datamodel.blackboardutils.attributes.GeoWaypoint.GeoTrackPoint;\n+\n+/**\n+ * A GPS track with which wraps the TSK_GPS_TRACK artifact.\n+ */\n+public final class Track extends Path{\n+\n+    private final Long startTimestamp;\n+    private final Long endTimeStamp;\n+\n+    /**\n+     * Construct a new Track for the given artifact.\n+     * \n+     * @param artifact\n+     * \n+     * @throws GeoLocationDataException \n+     */\n+    public Track(BlackboardArtifact artifact) throws GeoLocationDataException {\n+        this(artifact, Waypoint.getAttributesFromArtifactAsMap(artifact));\n+    }\n+\n+    /**\n+     * Construct a Track for the given artifact and attributeMap.\n+     * \n+     * @param artifact TSK_GPD_TRACK artifact\n+     * @param attributeMap  Map of the artifact attributes\n+     * \n+     * @throws GeoLocationDataException \n+     */\n+    private Track(BlackboardArtifact artifact, Map<BlackboardAttribute.ATTRIBUTE_TYPE, BlackboardAttribute> attributeMap) throws GeoLocationDataException {\n+        super(artifact, getTrackName(attributeMap));\n+\n+        List<GeoTrackPoint> points = getPointsList(attributeMap);\n+        buildPath(points);\n+\n+        startTimestamp = findStartTime(points);\n+        endTimeStamp = findEndTime(points);\n+    }\n+    \n+    /**\n+     * Returns the start time of this track.\n+     * \n+     * @return  Earliest time, or null if none was available. \n+     *          (seconds from java epoch)\n+     */\n+    public Long getStartTime() {\n+        return startTimestamp;\n+    }\n+    \n+    /**\n+     * Returns the end time of this track.\n+     * \n+     * @return  Earliest timestamp, or null if none was available. \n+     *          (seconds from java epoch)\n+     */\n+    public Long getEndTime() {\n+        return endTimeStamp;\n+    }\n+\n+    /**\n+     * Return the name of the track from the attributeMap. \n+     * Track name is stored in the attribute TSK_NAME\n+     * \n+     * @param attributeMap\n+     \n+     * @return Track name or empty string if none was available. \n+     */\n+    private static String getTrackName(Map<BlackboardAttribute.ATTRIBUTE_TYPE, BlackboardAttribute> attributeMap) {\n+        BlackboardAttribute attribute = attributeMap.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME);\n+\n+        return attribute != null ? attribute.getValueString() : \"\";\n+    }\n+\n+    /**\n+     * Create the list of TrackWaypoints from the GeoTrackPoint list.\n+     * \n+     * @param points List of GeoTrackPoints\n+     * \n+     * @throws GeoLocationDataException \n+     */\n+    private void buildPath(List<GeoTrackPoint> points) throws GeoLocationDataException {\n+        for (GeoTrackPoint point : points) {\n+            addToPath(new TrackWaypoint(point));\n+        }\n+    }\n+\n+    /**\n+     * Returns the list of GeoTrackPoints from the attributeMap.  Creates the \n+     * GeoTrackPoint list from the TSK_GEO_TRACKPOINTS attribute.\n+     * \n+     * @param attributeMap Map of artifact attributes.\n+     * \n+     * @return GeoTrackPoint list empty list if the attribute was not found.\n+     */\n+    private List<GeoTrackPoint> getPointsList(Map<BlackboardAttribute.ATTRIBUTE_TYPE, BlackboardAttribute> attributeMap) {\n+        BlackboardAttribute attribute = attributeMap.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_TRACKPOINTS);\n+        if (attribute != null) {\n+            String value = attribute.getValueString();\n+            return GeoTrackPoints.deserializePoints(value);\n+        }\n+\n+        return new ArrayList<>();\n+    }\n+\n+    /**\n+     * Return the start time for the track. Assumes the points are in time\n+     * order.\n+     *\n+     * @param points List of GeoTrackPoints.\n+     *\n+     * @return First non-null time stamp or null, if one was not found.\n+     */\n+    private Long findStartTime(List<GeoTrackPoint> points) {\n+        if (points != null) {\n+            for (GeoTrackPoint point : points) {\n+                if (point.getTimeStamp() != null) {\n+                    return point.getTimeStamp();\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return the ends time for the track. Assumes the points are in time\n+     * order.\n+     *\n+     * @param points List of GeoTrackPoints.\n+     *\n+     * @return First non-null time stamp or null, if one was not found.", "originalCommit": "f415213afc5e7d36d31bbb4e944c5d7e3850db92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMzA0NQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5595#discussion_r368033045", "bodyText": "If the list is not immutable any more, we should update this comment?", "author": "raman-bt", "createdAt": "2020-01-17T16:46:45Z", "path": "Core/src/org/sleuthkit/autopsy/geolocation/datamodel/Waypoint.java", "diffHunk": "@@ -43,17 +43,17 @@\n     final private String label;\n     final private AbstractFile image;\n     final private BlackboardArtifact artifact;\n-    final private Route route;\n+    final private Path path;\n \n     // This list is not expected to change after construction. The \n     // constructor will take care of making an unmodifiable List", "originalCommit": "f415213afc5e7d36d31bbb4e944c5d7e3850db92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1MTgzMQ==", "url": "https://github.com/sleuthkit/autopsy/pull/5595#discussion_r368051831", "bodyText": "May be log the objectID of the file in addition to path/name.", "author": "raman-bt", "createdAt": "2020-01-17T17:30:04Z", "path": "Core/src/org/sleuthkit/autopsy/modules/drones/DATExtractor.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.modules.drones;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import org.openide.util.NbBundle;\n+import org.openide.util.NbBundle.Messages;\n+import org.sleuthkit.autopsy.casemodule.services.FileManager;\n+import org.sleuthkit.autopsy.coreutils.FileUtil;\n+import org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProgress;\n+import org.sleuthkit.autopsy.ingest.IngestJobContext;\n+import org.sleuthkit.datamodel.AbstractFile;\n+import org.sleuthkit.datamodel.Content;\n+import org.sleuthkit.datamodel.blackboardutils.attributes.GeoWaypoint.GeoTrackPoint;\n+import org.sleuthkit.datamodel.blackboardutils.GeoArtifactsHelper;\n+import org.sleuthkit.datamodel.TskCoreException;\n+import org.sleuthkit.datamodel.Blackboard.BlackboardException;\n+\n+/**\n+ * Extract drone position data from DJI Phantom drones.\n+ *\n+ * Module uses DatCon.jar to dump FLYXXX.DAT file to a CSV file which is stored\n+ * in the case temp directory. Artifacts are created by parsing the csv file.\n+ *\n+ */\n+final class DATExtractor extends DroneExtractor {\n+\n+    private static final Logger logger = Logger.getLogger(DATExtractor.class.getName());\n+\n+    private static final String HEADER_LONG = \"IMU_ATTI(0):Longitude\";  //NON-NLS\n+    private static final String HEADER_LAT = \"IMU_ATTI(0):Latitude\"; //NON-NLS\n+    private static final String HEADER_VELOCITY = \"IMU_ATTI(0):velComposite\"; //NON-NLS\n+    private static final String HEADER_DATETILE = \"GPS:dateTimeStamp\"; //NON-NLS\n+    private static final String HEADER_ALTITUDE = \"GPS(0):heightMSL\"; //NON-NLS\n+    private static final String HEADER_DISTANCE_FROM_HP = \"IMU_ATTI(0):distanceHP\"; //NON-NLS\n+    private static final String HEADER_DISTANCE_TRAVELED = \"IMU_ATTI(0):distanceTravelled\"; //NON-NLS\n+\n+    /**\n+     * Construct a DATExtractor.\n+     *\n+     * @throws DroneIngestException\n+     */\n+    DATExtractor() throws DroneIngestException {\n+        super();\n+    }\n+\n+    @Messages({\n+        \"DATExtractor_process_message=Processing DJI DAT file: %s\"\n+    })\n+    @Override\n+    void process(Content dataSource, IngestJobContext context, DataSourceIngestModuleProgress progressBar) throws DroneIngestException {\n+        List<AbstractFile> datFiles = findDATFiles(dataSource);\n+\n+        DATDumper dumper = new DATDumper();\n+\n+        try {\n+            for (AbstractFile DATFile : datFiles) {\n+                if (context.dataSourceIngestIsCancelled()) {\n+                    break;\n+                }\n+\n+                progressBar.progress(String.format(Bundle.DATExtractor_process_message(), DATFile.getName()));\n+\n+                // Copy the DAT file into the case temp folder\n+                File tempDATFile = getTemporaryFile(context, DATFile);\n+\n+                // Create a path for the csv file\n+                String csvFilePath = getCSVPathForDAT(DATFile);\n+\n+                try {\n+                    if (!dumper.isDATFile(tempDATFile.getAbsolutePath())) {\n+                        logger.log(Level.WARNING, String.format(\"%s is not a valid DAT file\", DATFile.getName())); //NON-NLS\n+                        continue;\n+                    }\n+                    // Dump the DAT file to a csv file\n+                    dumper.dumpDATFile(tempDATFile.getAbsolutePath(), csvFilePath, true);\n+\n+                    if (context.dataSourceIngestIsCancelled()) {\n+                        break;\n+                    }\n+\n+                    // Process the csv file\n+                    List<GeoTrackPoint> trackPoints = processCSVFile(context, DATFile, csvFilePath);\n+\n+                    if (trackPoints != null && !trackPoints.isEmpty()) {\n+                        (new GeoArtifactsHelper(getSleuthkitCase(), getName(), DATFile)).addTrack(DATFile.getName(), trackPoints);\n+                    } else {\n+                        logger.log(Level.INFO, String.format(\"No trackpoints with valid longitude or latitude found in %s\", DATFile.getName())); //NON-NLS\n+                    }\n+\n+                } catch (TskCoreException | BlackboardException ex) {\n+                    logger.log(Level.WARNING, String.format(\"Exception thrown while processing DAT file %s\", DATFile.getName()), ex); //NON-NLS\n+                } finally {\n+                    tempDATFile.delete();\n+                    (new File(csvFilePath)).delete();\n+                }\n+            }\n+        } finally {\n+            FileUtil.deleteDir(getExtractorTempPath().toFile());\n+        }\n+    }\n+\n+    @NbBundle.Messages({\n+        \"DATFileExtractor_Extractor_Name=DAT File Extractor\"\n+    })\n+\n+    @Override\n+    String getName() {\n+        return Bundle.DATFileExtractor_Extractor_Name();\n+    }\n+\n+    /**\n+     * Find any files that have the file name FLYXXX.DAT where the X are digit\n+     * characters.\n+     *\n+     * @param dataSource Data source to search\n+     *\n+     * @return List of found files or empty list if none where found\n+     *\n+     * @throws DroneIngestException\n+     */\n+    private List<AbstractFile> findDATFiles(Content dataSource) throws DroneIngestException {\n+        List<AbstractFile> fileList = new ArrayList<>();\n+\n+        FileManager fileManager = getCurrentCase().getServices().getFileManager();\n+\n+        // findFiles use the SQL wildcard # in the file name\n+        try {\n+            fileList = fileManager.findFiles(dataSource, \"FLY___.DAT\"); //NON-NLS\n+        } catch (TskCoreException ex) {\n+            throw new DroneIngestException(\"Unable to find drone DAT files.\", ex); //NON-NLS\n+        }\n+\n+        return fileList;\n+    }\n+\n+    /**\n+     * Return an absolute path for the given DAT file.\n+     *\n+     * @param file DAT file\n+     *\n+     * @return Absolute csv file path\n+     */\n+    private String getCSVPathForDAT(AbstractFile file) {\n+        String tempFileName = file.getName() + file.getId() + \".csv\"; //NON-NLS\n+        return Paths.get(getExtractorTempPath().toString(), tempFileName).toString();\n+    }\n+\n+    /**\n+     * Process the csv dump of the drone DAT file.\n+     *\n+     * Create artifacts for all rows that have a valid longitude and latitude.\n+     *\n+     * @param context     current case job context\n+     * @param DATFile     Original DAT file\n+     * @param csvFilePath Path of csv file to process\n+     *\n+     * @throws DroneIngestException\n+     */\n+    private List<GeoTrackPoint> processCSVFile(IngestJobContext context, AbstractFile DATFile, String csvFilePath) throws DroneIngestException {\n+        List<GeoTrackPoint> trackPoints = new ArrayList<>();\n+        try (BufferedReader reader = new BufferedReader(new FileReader(new File(csvFilePath)))) {\n+            // First read in the header line and process\n+            String line = reader.readLine();\n+            Map<String, Integer> headerMap = makeHeaderMap(line.split(\",\")); //NON-NLS\n+\n+            while ((line = reader.readLine()) != null) {\n+                if (context.dataSourceIngestIsCancelled()) {\n+                    return null;\n+                }\n+\n+                String[] values = line.split(\",\"); //NON-NLS\n+                GeoTrackPoint point = createTrackPoint(headerMap, values);\n+                if (point != null) {\n+                    trackPoints.add(point);\n+                }\n+            }\n+\n+        } catch (IOException ex) {\n+            throw new DroneIngestException(String.format(\"Failed to read DAT csvFile %s\", csvFilePath), ex); //NON-NLS", "originalCommit": "f415213afc5e7d36d31bbb4e944c5d7e3850db92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NDcxMg==", "url": "https://github.com/sleuthkit/autopsy/pull/5595#discussion_r368054712", "bodyText": "log the object id as well.", "author": "raman-bt", "createdAt": "2020-01-17T17:37:16Z", "path": "Core/src/org/sleuthkit/autopsy/modules/drones/DroneExtractor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.modules.drones;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.casemodule.NoCurrentCaseException;\n+import org.sleuthkit.autopsy.datamodel.ContentUtils;\n+import org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProgress;\n+import org.sleuthkit.autopsy.ingest.IngestJobContext;\n+import org.sleuthkit.datamodel.AbstractFile;\n+import org.sleuthkit.datamodel.Content;\n+import org.sleuthkit.datamodel.SleuthkitCase;\n+\n+/**\n+ * Abstract base class for all Drone file extractors.\n+ */\n+abstract class DroneExtractor {\n+\n+    static private final String TEMP_FOLDER_NAME = \"DroneExtractor\"; //NON-NLS\n+    private final Case currentCase;\n+\n+    /**\n+     * Common constructor. Subclasses should call super in their constructor.\n+     *\n+     * @throws DroneIngestException\n+     */\n+    protected DroneExtractor() throws DroneIngestException {\n+        try {\n+            currentCase = Case.getCurrentCaseThrows();\n+        } catch (NoCurrentCaseException ex) {\n+            throw new DroneIngestException(\"Unable to create drone extractor, no open case.\", ex); //NON-NLS\n+        }\n+    }\n+\n+    abstract void process(Content dataSource, IngestJobContext context, DataSourceIngestModuleProgress progressBar) throws DroneIngestException;\n+\n+    abstract String getName();\n+\n+    /**\n+     * Return the current case object.\n+     *\n+     * @return Current case\n+     */\n+    final protected Case getCurrentCase() {\n+        return currentCase;\n+    }\n+\n+    /**\n+     * Return the current SleuthkitCase.\n+     *\n+     * @return Current sleuthkit case\n+     */\n+    final protected SleuthkitCase getSleuthkitCase() {\n+        return currentCase.getSleuthkitCase();\n+    }\n+\n+    /**\n+     * Build the temp path and create the directory if it does not currently\n+     * exist.\n+     *\n+     * @param currentCase   Currently open case\n+     * @param extractorName Name of extractor\n+     *\n+     * @return Path of the temp directory for this module\n+     */\n+    protected Path getExtractorTempPath() {\n+        Path path = Paths.get(currentCase.getTempDirectory(), TEMP_FOLDER_NAME, this.getClass().getCanonicalName());\n+        File dir = path.toFile();\n+        if (!dir.exists()) {\n+            dir.mkdirs();\n+        }\n+\n+        return path;\n+    }\n+\n+    /**\n+     * Create a copy of file in the case temp directory.\n+     *\n+     * @param context Current ingest context\n+     * @param file    File to be copied\n+     *\n+     * @return File copy.\n+     *\n+     * @throws DroneIngestException\n+     */\n+    protected File getTemporaryFile(IngestJobContext context, AbstractFile file) throws DroneIngestException {\n+        String tempFileName = file.getName() + file.getId() + file.getNameExtension();\n+\n+        Path tempFilePath = Paths.get(getExtractorTempPath().toString(), tempFileName);\n+\n+        try {\n+            ContentUtils.writeToFile(file, tempFilePath.toFile(), context::dataSourceIngestIsCancelled);\n+        } catch (IOException ex) {\n+            throw new DroneIngestException(String.format(\"Unable to create temp file %s for abstract file %s\", tempFilePath.toString(), file.getName()), ex); //NON-NLS", "originalCommit": "f415213afc5e7d36d31bbb4e944c5d7e3850db92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "880af5b85c0f54878cce4ec1de313240642c3ef7", "url": "https://github.com/sleuthkit/autopsy/commit/880af5b85c0f54878cce4ec1de313240642c3ef7", "message": "Updated based on review comments", "committedDate": "2020-01-21T19:33:48Z", "type": "commit"}, {"oid": "7417feac2f70e503147bb37a4e30d6ff99c8d932", "url": "https://github.com/sleuthkit/autopsy/commit/7417feac2f70e503147bb37a4e30d6ff99c8d932", "message": "Renamed Path to GeoPath", "committedDate": "2020-01-22T15:00:50Z", "type": "commit"}]}