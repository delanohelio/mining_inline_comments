{"pr_number": 1293, "pr_title": "Fix #1285 make FixedResultPipe consume message", "pr_createdAt": "2020-11-25T15:17:47Z", "pr_url": "https://github.com/ibissource/iaf/pull/1293", "timeline": [{"oid": "150ca13f4c5c96af6b54fc4ecc552ad9fa2613d7", "url": "https://github.com/ibissource/iaf/commit/150ca13f4c5c96af6b54fc4ecc552ad9fa2613d7", "message": "Always consume input message in FixedResult", "committedDate": "2020-11-25T14:51:34Z", "type": "commit"}, {"oid": "2325dddadbf9989114f3a2e66253920d83e1ab7e", "url": "https://github.com/ibissource/iaf/commit/2325dddadbf9989114f3a2e66253920d83e1ab7e", "message": "Rename FixedResult to FixedResultPipe", "committedDate": "2020-11-25T15:12:25Z", "type": "commit"}, {"oid": "6098fc2469ca5b4a4de5f1b5023e79ca436ea80e", "url": "https://github.com/ibissource/iaf/commit/6098fc2469ca5b4a4de5f1b5023e79ca436ea80e", "message": "Add compatibility class", "committedDate": "2020-11-25T15:15:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUwNDI1Mw==", "url": "https://github.com/ibissource/iaf/pull/1293#discussion_r531504253", "bodyText": "rename to", "author": "nielsm5", "createdAt": "2020-11-27T10:11:46Z", "path": "core/src/main/java/nl/nn/adapterframework/pipes/FixedResult.java", "diffHunk": "@@ -15,285 +15,10 @@\n */\n package nl.nn.adapterframework.pipes;\n \n-import java.io.IOException;\n-import java.net.URL;\n+import nl.nn.adapterframework.configuration.ConfigurationWarning;\n \n-import javax.xml.transform.Transformer;\n-import javax.xml.transform.TransformerConfigurationException;\n-import javax.xml.transform.TransformerException;\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.apache.commons.lang.SystemUtils;\n-import org.xml.sax.SAXException;\n-\n-import nl.nn.adapterframework.configuration.ConfigurationException;\n-import nl.nn.adapterframework.core.IPipeLineSession;\n-import nl.nn.adapterframework.core.ParameterException;\n-import nl.nn.adapterframework.core.PipeForward;\n-import nl.nn.adapterframework.core.PipeRunException;\n-import nl.nn.adapterframework.core.PipeRunResult;\n-import nl.nn.adapterframework.doc.IbisDoc;\n-import nl.nn.adapterframework.parameters.ParameterValue;\n-import nl.nn.adapterframework.parameters.ParameterValueList;\n-import nl.nn.adapterframework.stream.Message;\n-import nl.nn.adapterframework.util.AppConstants;\n-import nl.nn.adapterframework.util.ClassUtils;\n-import nl.nn.adapterframework.util.Misc;\n-import nl.nn.adapterframework.util.StringResolver;\n-import nl.nn.adapterframework.util.XmlUtils;\n-\n-/**\n- * Provides an example of a pipe. It may return the contents of a file\n- * (in the classpath) when <code>fileName</code> or <code>fileNameSessionKey</code> is specified, otherwise the\n- * input of <code>returnString</code> is returned.\n- *\n- * <table border=\"1\">\n- * <p><b>Parameters:</b>\n- * <tr><th>name</th><th>type</th><th>remarks</th></tr>\n- * <tr>\n- *   <td><i>any</i></td><td><i>any</i></td>\n- * \t <td>Any parameters defined on the pipe will be used for replacements. Each occurrence\n- * \t\t of <code>${name-of-parameter}</code> in the file {@link #setFileName(String) fileName} \n- *       will be replaced by its corresponding <i>value-of-parameter</i>. <br>\n- *       This works only with files, not with values supplied in attribute {@link #setReturnString(String) returnString}</td>\n- * </tr>\n- * </table>\n- * </p>\n- * <p><b>Exits:</b>\n- * <table border=\"1\">\n- * <tr><th>state</th><th>condition</th></tr>\n- * <tr><td>\"success\"</td><td>default</td></tr>\n- * <tr><td>\"filenotfound\"</td><td>file not found (when this forward isn't specified an exception will be thrown)</td></tr>\n- * <tr><td><i>{@link #setForwardName(String) forwardName}</i></td><td>if specified</td></tr>\n- * </table>\n- * </p>\n- * @author Johan Verrips\n- */\n-public class FixedResult extends FixedForwardPipe {\n-\t\n-\tprivate final static String FILE_NOT_FOUND_FORWARD = \"filenotfound\";\n-\t\n-\tAppConstants appConstants;\n-    private String fileName;\n-    private String fileNameSessionKey;\n-    private String returnString;\n-    private boolean substituteVars=false;\n-\tprivate String replaceFrom = null;\n-\tprivate String replaceTo = null;\n-\tprivate String styleSheetName = null;\n-\tprivate boolean lookupAtRuntime=false;\n-\tprivate boolean replaceFixedParams=false;\n-\t\n-    /**\n-     * checks for correct configuration, and translates the fileName to\n-     * a file, to check existence. \n-     * If a fileName or fileNameSessionKey was specified, the contents of the file is put in the\n-     * <code>returnString</code>, so that the <code>returnString</code>\n-     * may always be returned.\n-     * @throws ConfigurationException\n-     */\n-    @Override\n-\tpublic void configure() throws ConfigurationException {\n-\t\tsuper.configure();\n-\t\tappConstants = AppConstants.getInstance(getConfigurationClassLoader());\n-\t\tif (StringUtils.isNotEmpty(getFileName()) && !isLookupAtRuntime()) {\n-\t\t\tURL resource = null;\n-\t\t\ttry {\n-\t\t\t\tresource = ClassUtils.getResourceURL(getConfigurationClassLoader(), getFileName());\n-\t\t\t} catch (Throwable e) {\n-\t\t\t\tthrow new ConfigurationException(getLogPrefix(null)+\"got exception searching for [\"+getFileName()+\"]\", e);\n-\t\t\t}\n-\t\t\tif (resource==null) {\n-\t\t\t\tthrow new ConfigurationException(getLogPrefix(null)+\"cannot find resource [\"+getFileName()+\"]\");\n-\t\t\t}\n-            try {\n-\t\t\t\treturnString = Misc.resourceToString(resource, SystemUtils.LINE_SEPARATOR);\n-            } catch (Throwable e) {\n-                throw new ConfigurationException(getLogPrefix(null)+\"got exception loading [\"+getFileName()+\"]\", e);\n-            }\n-        }\n-        if ((StringUtils.isEmpty(fileName)) && (StringUtils.isEmpty(fileNameSessionKey)) && returnString==null) {  // allow an empty returnString to be specified\n-            throw new ConfigurationException(getLogPrefix(null)+\"has neither fileName nor fileNameSessionKey nor returnString specified\");\n-        }\n-\t\tif (StringUtils.isNotEmpty(replaceFrom)) {\n-\t\t\treturnString = replace(returnString, replaceFrom, replaceTo );\n-\t\t}\n-    }\n-    \n-\t@Override\n-\tpublic PipeRunResult doPipe(Message message, IPipeLineSession session) throws PipeRunException {\n-\t\tString result=returnString;\n-\t\tif ((StringUtils.isNotEmpty(getFileName()) && isLookupAtRuntime())\n-\t\t\t\t|| StringUtils.isNotEmpty(getFileNameSessionKey())) {\n-\t\t\tString fileName = null;\n-\t\t\tif (StringUtils.isNotEmpty(getFileNameSessionKey())) {\n-\t\t\t\tfileName = (String)session.get(fileNameSessionKey);\n-\t\t\t}\n-\t\t\tif (fileName == null) {\n-\t\t\t\tif (StringUtils.isNotEmpty(getFileName()) && isLookupAtRuntime()) {\n-\t\t\t\t\tfileName = getFileName();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tURL resource = null;\n-\t\t\ttry {\n-\t\t\t\tresource = ClassUtils.getResourceURL(getConfigurationClassLoader(), fileName);\n-\t\t\t} catch (Throwable e) {\n-\t\t\t\tthrow new PipeRunException(this,getLogPrefix(session)+\"got exception searching for [\"+fileName+\"]\", e);\n-\t\t\t}\n-\t\t\tif (resource == null) {\n-\t\t\t\tPipeForward fileNotFoundForward = findForward(FILE_NOT_FOUND_FORWARD);\n-\t\t\t\tif (fileNotFoundForward != null) {\n-\t\t\t\t\treturn new PipeRunResult(fileNotFoundForward, message);\n-\t\t\t\t} else {\n-\t\t\t\t\tthrow new PipeRunException(this,getLogPrefix(session)+\"cannot find resource [\"+fileName+\"]\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tresult = Misc.resourceToString(resource, SystemUtils.LINE_SEPARATOR);\n-\t\t\t} catch (Throwable e) {\n-\t\t\t\tthrow new PipeRunException(this,getLogPrefix(session)+\"got exception loading [\"+fileName+\"]\", e);\n-\t\t\t}\n-\t\t}\n-\t\tif (getParameterList()!=null) {\n-\t\t\tParameterValueList pvl;\n-\t\t\ttry {\n-\t\t\t\tpvl = getParameterList().getValues(message, session);\n-\t\t\t} catch (ParameterException e) {\n-\t\t\t\tthrow new PipeRunException(this,getLogPrefix(session)+\"exception extracting parameters\",e);\n-\t\t\t}\n-\t\t\tfor (int i=0; i<pvl.size(); i++) {\n-\t\t\t\tParameterValue pv = pvl.getParameterValue(i);\n-\t\t\t\tString replaceFrom;\n-\t\t\t\tif (isReplaceFixedParams()) {\n-\t\t\t\t\treplaceFrom=pv.getDefinition().getName();\n-\t\t\t\t} else {\n-\t\t\t\t\treplaceFrom=\"${\"+pv.getDefinition().getName()+\"}\";\n-\t\t\t\t}\n-\t\t\t\tresult=replace(result,replaceFrom,pv.asStringValue(\"\"));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (getSubstituteVars()){\n-\t\t\tresult=StringResolver.substVars(returnString, session, appConstants);\n-\t\t}\n-\n-\t\tif (StringUtils.isNotEmpty(styleSheetName)) {\n-\t\t\tURL xsltSource = ClassUtils.getResourceURL(getConfigurationClassLoader(), styleSheetName);\n-\t\t\tif (xsltSource!=null) {\n-\t\t\t\ttry{\n-\t\t\t\t\tString xsltResult = null;\n-\t\t\t\t\tTransformer transformer = XmlUtils.createTransformer(xsltSource);\n-\t\t\t\t\txsltResult = XmlUtils.transformXml(transformer, result);\n-\t\t\t\t\tresult = xsltResult;\n-\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\tthrow new PipeRunException(this,getLogPrefix(session)+\"cannot retrieve [\"+ styleSheetName + \"], resource [\" + xsltSource.toString() + \"]\", e);\n-\t\t\t\t} catch (SAXException|TransformerConfigurationException e) {\n-\t\t\t\t\tthrow new PipeRunException(this,getLogPrefix(session)+\"got error creating transformer from file [\" + styleSheetName + \"]\", e);\n-\t\t\t\t} catch (TransformerException e) {\n-\t\t\t\t\tthrow new PipeRunException(this,getLogPrefix(session)+\"got error transforming resource [\" + xsltSource.toString() + \"] from [\" + styleSheetName + \"]\", e);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t    log.debug(getLogPrefix(session)+ \" returning fixed result [\" + result + \"]\");\n-\n-   \t\treturn new PipeRunResult(getForward(), result);\n-\t}\n-\n-\tpublic static String replace (String target, String from, String to) {   \n-\t\t// target is the original string\n-\t\t// from   is the string to be replaced\n-\t\t// to     is the string which will used to replace\n-\t\tint start = target.indexOf (from);\n-\t\tif (start==-1) return target;\n-\t\tint lf = from.length();\n-\t\tchar [] targetChars = target.toCharArray();\n-\t\tStringBuffer buffer = new StringBuffer();\n-\t\tint copyFrom=0;\n-\t\twhile (start != -1) {\n-\t\t\tbuffer.append (targetChars, copyFrom, start-copyFrom);\n-\t\t\tbuffer.append (to);\n-\t\t\tcopyFrom=start+lf;\n-\t\t\tstart = target.indexOf (from, copyFrom);\n-\t\t}\n-\t\tbuffer.append (targetChars, copyFrom, targetChars.length-copyFrom);\n-\t\treturn buffer.toString();\n-\t}\n-\n-\t@IbisDoc({\"should values between ${ and } be resolved from the pipelinesession (search order: 1) system properties 2) pipelinesession variables 3) application properties)\", \"false\"})\n-\tpublic void setSubstituteVars(boolean substitute){\n-\t\tthis.substituteVars=substitute;\n-\t}\n-\tpublic boolean getSubstituteVars(){\n-\t\treturn this.substituteVars;\n-\t}\n-\n-    /**\n-     * Sets the name of the filename. The fileName should not be specified\n-     * as an absolute path, but as a resource in the classpath.\n-     */\n-\t@IbisDoc({\"name of the file containing the resultmessage\", \"\"})\n-    public void setFileName(String fileName) {\n-        this.fileName = fileName;\n-    }\n-\tpublic String getFileName() {\n-\t\treturn fileName;\n-\t}\n-\t\n-\t/**\n-\t * @param filenameSessionKey the session key that contains the name of the file\n-\t */\n-\t@IbisDoc({\"name of the session key containing the file name of the file containing the result message\", \"\"})\n-\tpublic void setFileNameSessionKey(String filenameSessionKey) {\n-\t\tthis.fileNameSessionKey = filenameSessionKey;\n-\t}\n-\tpublic String getFileNameSessionKey() {\n-\t\treturn fileNameSessionKey;\n-\t}\n-\n-\t@IbisDoc({\"returned message\", \"\"})\n-    public void setReturnString(String returnString) {\n-        this.returnString = returnString;\n-    }\n-\tpublic String getReturnString() {\n-\t\treturn returnString;\n-\t}\n-\n-\tpublic String getReplaceFrom() {\n-\t\treturn replaceFrom;\n-\t}\n-\tpublic void setReplaceFrom (String replaceFrom){\n-\t\tthis.replaceFrom=replaceFrom;\n-\t}\n-\n-\tpublic String getReplaceTo() {\n-\t\treturn replaceTo;\n-\t}\n-\tpublic void setReplaceTo (String replaceTo){\n-\t\tthis.replaceTo=replaceTo;\n-\t}\n-\n-\tpublic String getStyleSheetName() {\n-\t\treturn styleSheetName;\n-\t}\n-\tpublic void setStyleSheetName (String styleSheetName){\n-\t\tthis.styleSheetName=styleSheetName;\n-\t}\n-\n-\t@IbisDoc({\"when set <code>true</code>, the lookup of the file will be done at runtime instead of at configuration time\", \"false\"})\n-\tpublic void setLookupAtRuntime(boolean b){\n-\t\tlookupAtRuntime=b;\n-\t}\n-\tpublic boolean isLookupAtRuntime(){\n-\t\treturn lookupAtRuntime;\n-\t}\n-\n-\t@IbisDoc({\"when set <code>true</code>, any parameter is used for replacements but with <code>name-of-parameter</code> and not <code>${name-of-parameter}</code>\", \"false\"})\n-\tpublic void setReplaceFixedParams(boolean b){\n-\t\treplaceFixedParams=b;\n-\t}\n-\tpublic boolean isReplaceFixedParams(){\n-\t\treturn replaceFixedParams;\n-\t}\n+@Deprecated\n+@ConfigurationWarning(\"has been renamed into FixedResultPipe\")", "originalCommit": "6098fc2469ca5b4a4de5f1b5023e79ca436ea80e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUwNDQ5Mw==", "url": "https://github.com/ibissource/iaf/pull/1293#discussion_r531504493", "bodyText": "connection leaking when... explain the httpsender scenario", "author": "nielsm5", "createdAt": "2020-11-27T10:12:09Z", "path": "core/src/main/java/nl/nn/adapterframework/pipes/FixedResultPipe.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+   Copyright 2013, 2016, 2019 Nationale-Nederlanden, 2020 WeAreFrank!\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package nl.nn.adapterframework.pipes;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.net.URL;\n+\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerConfigurationException;\n+import javax.xml.transform.TransformerException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.lang.SystemUtils;\n+import org.xml.sax.SAXException;\n+\n+import nl.nn.adapterframework.configuration.ConfigurationException;\n+import nl.nn.adapterframework.core.IPipeLineSession;\n+import nl.nn.adapterframework.core.ParameterException;\n+import nl.nn.adapterframework.core.PipeForward;\n+import nl.nn.adapterframework.core.PipeRunException;\n+import nl.nn.adapterframework.core.PipeRunResult;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.parameters.ParameterValue;\n+import nl.nn.adapterframework.parameters.ParameterValueList;\n+import nl.nn.adapterframework.stream.Message;\n+import nl.nn.adapterframework.util.AppConstants;\n+import nl.nn.adapterframework.util.ClassUtils;\n+import nl.nn.adapterframework.util.Misc;\n+import nl.nn.adapterframework.util.StringResolver;\n+import nl.nn.adapterframework.util.XmlUtils;\n+\n+/**\n+ * Provides an example of a pipe. It may return the contents of a file\n+ * (in the classpath) when <code>fileName</code> or <code>fileNameSessionKey</code> is specified, otherwise the\n+ * input of <code>returnString</code> is returned.\n+ *\n+ * <table border=\"1\">\n+ * <p><b>Parameters:</b>\n+ * <tr><th>name</th><th>type</th><th>remarks</th></tr>\n+ * <tr>\n+ *   <td><i>any</i></td><td><i>any</i></td>\n+ * \t <td>Any parameters defined on the pipe will be used for replacements. Each occurrence\n+ * \t\t of <code>${name-of-parameter}</code> in the file {@link #setFileName(String) fileName} \n+ *       will be replaced by its corresponding <i>value-of-parameter</i>. <br>\n+ *       This works only with files, not with values supplied in attribute {@link #setReturnString(String) returnString}</td>\n+ * </tr>\n+ * </table>\n+ * </p>\n+ * <p><b>Exits:</b>\n+ * <table border=\"1\">\n+ * <tr><th>state</th><th>condition</th></tr>\n+ * <tr><td>\"success\"</td><td>default</td></tr>\n+ * <tr><td>\"filenotfound\"</td><td>file not found (when this forward isn't specified an exception will be thrown)</td></tr>\n+ * <tr><td><i>{@link #setForwardName(String) forwardName}</i></td><td>if specified</td></tr>\n+ * </table>\n+ * </p>\n+ * @author Johan Verrips\n+ */\n+public class FixedResultPipe extends FixedForwardPipe {\n+\t\n+\tprivate final static String FILE_NOT_FOUND_FORWARD = \"filenotfound\";\n+\t\n+\tAppConstants appConstants;\n+    private String fileName;\n+    private String fileNameSessionKey;\n+    private String returnString;\n+    private boolean substituteVars=false;\n+\tprivate String replaceFrom = null;\n+\tprivate String replaceTo = null;\n+\tprivate String styleSheetName = null;\n+\tprivate boolean lookupAtRuntime=false;\n+\tprivate boolean replaceFixedParams=false;\n+\t\n+    /**\n+     * checks for correct configuration, and translates the fileName to\n+     * a file, to check existence. \n+     * If a fileName or fileNameSessionKey was specified, the contents of the file is put in the\n+     * <code>returnString</code>, so that the <code>returnString</code>\n+     * may always be returned.\n+     * @throws ConfigurationException\n+     */\n+    @Override\n+\tpublic void configure() throws ConfigurationException {\n+\t\tsuper.configure();\n+\t\tappConstants = AppConstants.getInstance(getConfigurationClassLoader());\n+\t\tif (StringUtils.isNotEmpty(getFileName()) && !isLookupAtRuntime()) {\n+\t\t\tURL resource = null;\n+\t\t\ttry {\n+\t\t\t\tresource = ClassUtils.getResourceURL(getConfigurationClassLoader(), getFileName());\n+\t\t\t} catch (Throwable e) {\n+\t\t\t\tthrow new ConfigurationException(getLogPrefix(null)+\"got exception searching for [\"+getFileName()+\"]\", e);\n+\t\t\t}\n+\t\t\tif (resource==null) {\n+\t\t\t\tthrow new ConfigurationException(getLogPrefix(null)+\"cannot find resource [\"+getFileName()+\"]\");\n+\t\t\t}\n+            try {\n+\t\t\t\treturnString = Misc.resourceToString(resource, SystemUtils.LINE_SEPARATOR);\n+            } catch (Throwable e) {\n+                throw new ConfigurationException(getLogPrefix(null)+\"got exception loading [\"+getFileName()+\"]\", e);\n+            }\n+        }\n+        if ((StringUtils.isEmpty(fileName)) && (StringUtils.isEmpty(fileNameSessionKey)) && returnString==null) {  // allow an empty returnString to be specified\n+            throw new ConfigurationException(getLogPrefix(null)+\"has neither fileName nor fileNameSessionKey nor returnString specified\");\n+        }\n+\t\tif (StringUtils.isNotEmpty(replaceFrom)) {\n+\t\t\treturnString = replace(returnString, replaceFrom, replaceTo );\n+\t\t}\n+    }\n+    \n+\t@Override\n+\tpublic PipeRunResult doPipe(Message message, IPipeLineSession session) throws PipeRunException {\n+\t\tString result=returnString;\n+\t\tString fileName = null;\n+\t\tif (StringUtils.isNotEmpty(getFileNameSessionKey())) {\n+\t\t\tfileName = (String)session.get(fileNameSessionKey);\n+\t\t}\n+\t\tif (fileName == null && StringUtils.isNotEmpty(getFileName()) && isLookupAtRuntime()) {\n+\t\t\tfileName = getFileName();\n+\t\t}\n+\t\tif (StringUtils.isNotEmpty(fileName)) {\n+\t\t\tURL resource = null;\n+\t\t\ttry {\n+\t\t\t\tresource = ClassUtils.getResourceURL(getConfigurationClassLoader(), fileName);\n+\t\t\t} catch (Throwable e) {\n+\t\t\t\tthrow new PipeRunException(this,getLogPrefix(session)+\"got exception searching for [\"+fileName+\"]\", e);\n+\t\t\t}\n+\t\t\tif (resource == null) {\n+\t\t\t\tPipeForward fileNotFoundForward = findForward(FILE_NOT_FOUND_FORWARD);\n+\t\t\t\tif (fileNotFoundForward != null) {\n+\t\t\t\t\treturn new PipeRunResult(fileNotFoundForward, message);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new PipeRunException(this,getLogPrefix(session)+\"cannot find resource [\"+fileName+\"]\");\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\tresult = Misc.resourceToString(resource, SystemUtils.LINE_SEPARATOR);\n+\t\t\t} catch (Throwable e) {\n+\t\t\t\tthrow new PipeRunException(this,getLogPrefix(session)+\"got exception loading [\"+fileName+\"]\", e);\n+\t\t\t}\n+\t\t}\n+\t\tif (getParameterList()!=null) {\n+\t\t\tParameterValueList pvl;\n+\t\t\ttry {\n+\t\t\t\tpvl = getParameterList().getValues(message, session);\n+\t\t\t} catch (ParameterException e) {\n+\t\t\t\tthrow new PipeRunException(this,getLogPrefix(session)+\"exception extracting parameters\",e);\n+\t\t\t}\n+\t\t\tfor (int i=0; i<pvl.size(); i++) {\n+\t\t\t\tParameterValue pv = pvl.getParameterValue(i);\n+\t\t\t\tString replaceFrom;\n+\t\t\t\tif (isReplaceFixedParams()) {\n+\t\t\t\t\treplaceFrom=pv.getDefinition().getName();\n+\t\t\t\t} else {\n+\t\t\t\t\treplaceFrom=\"${\"+pv.getDefinition().getName()+\"}\";\n+\t\t\t\t}\n+\t\t\t\tresult=replace(result,replaceFrom,pv.asStringValue(\"\"));\n+\t\t\t}\n+\t\t}\n+\n+\t\ttry (Reader dummy = message.asReader()) {\n+\t\t\t// get the inputstream and close it, to avoid connection leaking when the message itself is not consumed", "originalCommit": "6098fc2469ca5b4a4de5f1b5023e79ca436ea80e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "69890f56beb9115272b60078529fada075158be5", "url": "https://github.com/ibissource/iaf/commit/69890f56beb9115272b60078529fada075158be5", "message": "Clarify message consumption", "committedDate": "2020-11-27T10:34:22Z", "type": "commit"}]}