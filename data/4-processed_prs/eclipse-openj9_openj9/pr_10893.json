{"pr_number": 10893, "pr_title": "Update resolve code to support OpenJDK MH", "pr_createdAt": "2020-10-14T22:21:29Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10893", "timeline": [{"oid": "8238f0f70a0e69645abac087b5d85323a197b05e", "url": "https://github.com/eclipse-openj9/openj9/commit/8238f0f70a0e69645abac087b5d85323a197b05e", "message": "Update JIT helper to support OpenJDK MH\n\n- update old_slow_jitResolveHandleMethod\n\nCo-authored-by: Babneet Singh <sbabneet@ca.ibm.com>\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-10-14T22:25:13Z", "type": "forcePushed"}, {"oid": "93078a5ffaa1bc8ce84ba6c4c1275a10a112c812", "url": "https://github.com/eclipse-openj9/openj9/commit/93078a5ffaa1bc8ce84ba6c4c1275a10a112c812", "message": "Update JIT helper to support OpenJDK MH\n\n- update old_slow_jitResolveHandleMethod\n\nCo-authored-by: Babneet Singh <sbabneet@ca.ibm.com>\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-10-20T20:14:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwNDY2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517604668", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tvoid markMethodRefAsUsedByInvokeHandleGeneric(U_16 methodRefCfrCPIndex) { mark(methodRefCfrCPIndex, INVOKE_HANDLEGENERIC); _invokeCacheCount++;\n          \n          \n            \n            \tvoid markMethodRefAsUsedByInvokeHandleGeneric(U_16 methodRefCfrCPIndex) { mark(methodRefCfrCPIndex, INVOKE_HANDLEGENERIC); _invokeCacheCount++; }", "author": "babsingh", "createdAt": "2020-11-04T20:13:59Z", "path": "runtime/bcutil/ConstantPoolMap.hpp", "diffHunk": "@@ -287,8 +291,14 @@ class ConstantPoolMap\n \tvoid markMethodRefAsUsedByInvokeSpecial(U_16 methodRefCfrCPIndex)       { mark(methodRefCfrCPIndex, INVOKE_SPECIAL); }\n \tvoid markMethodRefAsUsedByInvokeStatic(U_16 methodRefCfrCPIndex)        { mark(methodRefCfrCPIndex, INVOKE_STATIC); }\n \tvoid markMethodRefAsUsedByInvokeInterface(U_16 methodRefCfrCPIndex)     { mark(methodRefCfrCPIndex, INVOKE_INTERFACE); }\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tvoid markMethodRefAsUsedByInvokeHandle(U_16 methodRefCfrCPIndex)        { mark(methodRefCfrCPIndex, INVOKE_HANDLEEXACT); _invokeCacheCount++; }\n+\tvoid markMethodRefAsUsedByInvokeHandleGeneric(U_16 methodRefCfrCPIndex) { mark(methodRefCfrCPIndex, INVOKE_HANDLEGENERIC); _invokeCacheCount++;", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQxOTI0Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518419246", "bodyText": "fixed", "author": "fengxue-IS", "createdAt": "2020-11-05T22:53:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwNDY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwODg1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517608850", "bodyText": "Should it be an #elif instead of an #else in case both opt_openjdkMethodhandle and opt_methodHandle flags are disabled? Reference to the coding standard. If this change is accepted, then it should be applied to all ifdefs.\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n...\n#elif defined(J9VM_OPT_METHOD_HANDLE) /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n...\n#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n    /* JSR292 completely disabled. */\n    ASSERT if possible since this code shouldn't be executed when the flags are disabled;\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */", "author": "babsingh", "createdAt": "2020-11-04T20:22:10Z", "path": "runtime/bcutil/ConstantPoolMap.hpp", "diffHunk": "@@ -287,8 +291,14 @@ class ConstantPoolMap\n \tvoid markMethodRefAsUsedByInvokeSpecial(U_16 methodRefCfrCPIndex)       { mark(methodRefCfrCPIndex, INVOKE_SPECIAL); }\n \tvoid markMethodRefAsUsedByInvokeStatic(U_16 methodRefCfrCPIndex)        { mark(methodRefCfrCPIndex, INVOKE_STATIC); }\n \tvoid markMethodRefAsUsedByInvokeInterface(U_16 methodRefCfrCPIndex)     { mark(methodRefCfrCPIndex, INVOKE_INTERFACE); }\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tvoid markMethodRefAsUsedByInvokeHandle(U_16 methodRefCfrCPIndex)        { mark(methodRefCfrCPIndex, INVOKE_HANDLEEXACT); _invokeCacheCount++; }\n+\tvoid markMethodRefAsUsedByInvokeHandleGeneric(U_16 methodRefCfrCPIndex) { mark(methodRefCfrCPIndex, INVOKE_HANDLEGENERIC); _invokeCacheCount++;\n+#else /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM5ODU3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518398577", "bodyText": "The original code isn't ifdef-ed under any tag, so I considered the code as default.\nThe J9VM_OPT_METHOD_HANDLE flag is not very consistent through the vm code, I think this is mostly due to method handle need to be supported by default since Java7/8", "author": "fengxue-IS", "createdAt": "2020-11-05T22:06:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwODg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMTk5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517611994", "bodyText": "Correct the formatting for the multi-line comment, and add missing full-stops. Reference to the coding standard.", "author": "babsingh", "createdAt": "2020-11-04T20:28:00Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -2325,6 +2325,25 @@ old_slow_jitResolveHandleMethod(J9VMThread *currentThread)\n \tDECLARE_JIT_PARM(void*, jitEIP, 3);\n \tvoid *addr = NULL;\n \tJ9JavaVM *vm = currentThread->javaVM;\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef*)ramConstantPool) + cpIndex;\n+\tUDATA invokeCacheIndex = ramMethodRef->methodIndexAndArgCount >> 8;\n+retry:\n+\tj9object_t invokeCacheArray = (J9_CLASS_FROM_CP(ramConstantPool)->invokeCache)[invokeCacheIndex];\n+\tif (NULL == invokeCacheArray) {\n+\t\tbuildJITResolveFrameWithPC(currentThread, J9_SSF_JIT_RESOLVE_DATA, parmCount, true, 0, jitEIP);\n+\t\t// add new resolve code which calls sendResolveInvokeHandle -> MHN.linkMethod()\n+\t\t// store the memberName/appendix values in invokeCache[invokeCacheIndex]", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQxOTI5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518419294", "bodyText": "fixed", "author": "fengxue-IS", "createdAt": "2020-11-05T22:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMTk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjUxMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517612510", "bodyText": "Is there an extra pair of unneeded brackets?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef*)ramConstantPool) + cpIndex;\n          \n          \n            \n            \tJ9RAMMethodRef *ramMethodRef = (J9RAMMethodRef*)ramConstantPool + cpIndex;", "author": "babsingh", "createdAt": "2020-11-04T20:29:00Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -2325,6 +2325,25 @@ old_slow_jitResolveHandleMethod(J9VMThread *currentThread)\n \tDECLARE_JIT_PARM(void*, jitEIP, 3);\n \tvoid *addr = NULL;\n \tJ9JavaVM *vm = currentThread->javaVM;\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef*)ramConstantPool) + cpIndex;", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg1NjE0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518856143", "bodyText": "The extra brackets remove any ambiguity from the order of operations.  It's clear that the + is pointer arithmetic on J9RAMMethodRef*.  Otherwise you need to know which order of operations occurs first:  casting vs addition\nMy vote is keep them", "author": "DanHeidinga", "createdAt": "2020-11-06T16:17:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNjQxMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517616411", "bodyText": "Avoid nested calls.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tif (J9CLASS_IS_ARRAY(J9OBJECT_CLAZZ(_currentThread, invokeCacheArray))) {\n          \n          \n            \n            \t\t\tJ9Class *clazz = J9OBJECT_CLAZZ(_currentThread, invokeCacheArray);\n          \n          \n            \n            \t\t\tif (J9CLASS_IS_ARRAY(clazz)) {", "author": "babsingh", "createdAt": "2020-11-04T20:36:19Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8017,23 +8017,22 @@ class INTERPRETER_CLASS\n \t\tU_16 index = *(U_16 *)(_pc + 1);\n \n \t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n-\t\tJ9InvokeCacheEntry *invokeCache = ((J9InvokeCacheEntry *)ramConstantPool->ramClass->callSites) + index;\n+\t\tj9object_t invokeCacheArray = (ramConstantPool->ramClass->callSites)[index];\n \n-\t\tj9object_t memberName = invokeCache->target;\n-\n-\t\tif (J9_EXPECTED(NULL != memberName)) {\n-\t\t\tif (J9OBJECT_CLAZZ(_currentThread, memberName) == J9VMJAVALANGINVOKEMEMBERNAME_OR_NULL(_vm)) {\n+\t\tif (J9_EXPECTED(NULL != invokeCacheArray)) {\n+\t\t\tif (J9CLASS_IS_ARRAY(J9OBJECT_CLAZZ(_currentThread, invokeCacheArray))) {", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQxOTM5Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518419393", "bodyText": "fixed", "author": "fengxue-IS", "createdAt": "2020-11-05T22:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNjQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNzI5Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517617297", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            sendResolveOpenJDKInvokeHandle(J9VMThread *currentThread, J9ConstantPool *ramCP, UDATA cpIndex, I_32 refKind, J9Class *resolvedClass, J9ROMNameAndSignature* nameAndSig)\n          \n          \n            \n            sendResolveOpenJDKInvokeHandle(J9VMThread *currentThread, J9ConstantPool *ramCP, UDATA cpIndex, I_32 refKind, J9Class *resolvedClass, J9ROMNameAndSignature *nameAndSig)", "author": "babsingh", "createdAt": "2020-11-04T20:38:15Z", "path": "runtime/vm/callin.cpp", "diffHunk": "@@ -942,6 +942,43 @@ sendForGenericInvoke(J9VMThread *currentThread, j9object_t methodHandle, j9objec\n \tTrc_VM_sendForGenericInvoke_Exit(currentThread);\n }\n \n+void JNICALL\n+sendResolveOpenJDKInvokeHandle(J9VMThread *currentThread, J9ConstantPool *ramCP, UDATA cpIndex, I_32 refKind, J9Class *resolvedClass, J9ROMNameAndSignature* nameAndSig)", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNzM3Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517617376", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t/* Convert name and signature to String objects */\n          \n          \n            \n            \t\t/* Convert name and signature to String objects. */", "author": "babsingh", "createdAt": "2020-11-04T20:38:27Z", "path": "runtime/vm/callin.cpp", "diffHunk": "@@ -942,6 +942,43 @@ sendForGenericInvoke(J9VMThread *currentThread, j9object_t methodHandle, j9objec\n \tTrc_VM_sendForGenericInvoke_Exit(currentThread);\n }\n \n+void JNICALL\n+sendResolveOpenJDKInvokeHandle(J9VMThread *currentThread, J9ConstantPool *ramCP, UDATA cpIndex, I_32 refKind, J9Class *resolvedClass, J9ROMNameAndSignature* nameAndSig)\n+{\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tTrc_VM_sendResolveOpenJDKInvokeHandle_Entry(currentThread);\n+\tJ9VMEntryLocalStorage newELS;\n+\tif (buildCallInStackFrame(currentThread, &newELS, true, false)) {\n+\t\t/* Convert name and signature to String objects */", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQwMDI1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518400251", "bodyText": "keeping existing format for consistency within the file", "author": "fengxue-IS", "createdAt": "2020-11-05T22:10:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNzM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNzUyNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517617525", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t/* Run the method */\n          \n          \n            \n            \t\t\t\t/* Run the method. */", "author": "babsingh", "createdAt": "2020-11-04T20:38:46Z", "path": "runtime/vm/callin.cpp", "diffHunk": "@@ -942,6 +942,43 @@ sendForGenericInvoke(J9VMThread *currentThread, j9object_t methodHandle, j9objec\n \tTrc_VM_sendForGenericInvoke_Exit(currentThread);\n }\n \n+void JNICALL\n+sendResolveOpenJDKInvokeHandle(J9VMThread *currentThread, J9ConstantPool *ramCP, UDATA cpIndex, I_32 refKind, J9Class *resolvedClass, J9ROMNameAndSignature* nameAndSig)\n+{\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tTrc_VM_sendResolveOpenJDKInvokeHandle_Entry(currentThread);\n+\tJ9VMEntryLocalStorage newELS;\n+\tif (buildCallInStackFrame(currentThread, &newELS, true, false)) {\n+\t\t/* Convert name and signature to String objects */\n+\t\tJ9JavaVM *vm = currentThread->javaVM;\n+\t\tJ9MemoryManagerFunctions const * const mmFuncs = vm->memoryManagerFunctions;\n+\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n+\t\tj9object_t nameString = mmFuncs->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF), 0);\n+\t\tif (NULL != nameString) {\n+\t\t\tJ9UTF8 *sigUTF = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameString);\n+\t\t\tj9object_t sigString = mmFuncs->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(sigUTF), J9UTF8_LENGTH(sigUTF), 0);\n+\t\t\tnameString = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\tif (NULL != sigString) {\n+\t\t\t\t/* Run the method */", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQwMDM2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518400364", "bodyText": "keeping existing format for consistency within the file", "author": "fengxue-IS", "createdAt": "2020-11-05T22:10:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNzUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxODY1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517618656", "bodyText": "If I recollect correctly, new tracepoints should always be added to the end of file.", "author": "babsingh", "createdAt": "2020-11-04T20:41:00Z", "path": "runtime/vm/j9vm.tdf", "diffHunk": "@@ -222,6 +222,13 @@ TraceExit=Trc_VM_resolveStaticFieldRef_Exit Overhead=1 Level=3 Template=\"resolve\n TraceEntry=Trc_VM_resolveInstanceFieldRef_Entry_old Obsolete Overhead=1 Level=3 Template=\"resolveInstanceFieldRef(ramCP=%p, cpIndex=%zu, flags=%zx, returnAddress=%p)\"\n TraceExit=Trc_VM_resolveInstanceFieldRef_Exit Overhead=1 Level=3 Template=\"resolveInstanceFieldRef --> result=%d\"\n \n+TraceEntry=Trc_VM_resolveInvokeHandle_Entry Overhead=1 Level=3 Template=\"resolveInvokeHandle(ramCP=%p, cpIndex=%zu, flags=%zx)\"", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQxOTU1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518419558", "bodyText": "fixed", "author": "fengxue-IS", "createdAt": "2020-11-05T22:54:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxODY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxODg1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517618851", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            isMethodHandleINL(U_8* methodName, U_16 methodNameLength)\n          \n          \n            \n            isMethodHandleINL(U_8 *methodName, U_16 methodNameLength)", "author": "babsingh", "createdAt": "2020-11-04T20:41:27Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -116,6 +116,40 @@ checkForDecompile(J9VMThread *currentThread, J9ROMMethodRef *romMethodRef, bool\n \t}\n }\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+static BOOLEAN\n+isMethodHandleINL(U_8* methodName, U_16 methodNameLength)", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxOTM3Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517619373", "bodyText": "missing default. Coding standard: Switch statements should always include a default:.", "author": "babsingh", "createdAt": "2020-11-04T20:42:31Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -116,6 +116,40 @@ checkForDecompile(J9VMThread *currentThread, J9ROMMethodRef *romMethodRef, bool\n \t}\n }\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+static BOOLEAN\n+isMethodHandleINL(U_8* methodName, U_16 methodNameLength)\n+{\n+\tBOOLEAN isMethodHandle = FALSE;\n+\n+\tswitch (methodNameLength) {\n+\tcase 11:\n+\t\tif (J9UTF8_LITERAL_EQUALS(methodName, methodNameLength, \"invokeBasic\")) {\n+\t\t\tisMethodHandle = TRUE;\n+\t\t}\n+\t\tbreak;\n+\tcase 12:\n+\t\tif (J9UTF8_LITERAL_EQUALS(methodName, methodNameLength, \"linkToStatic\")) {\n+\t\t\tisMethodHandle = TRUE;\n+\t\t}\n+\t\tbreak;\n+\tcase 13:\n+\t\tif (J9UTF8_LITERAL_EQUALS(methodName, methodNameLength, \"linkToSpecial\")\n+\t\t||  J9UTF8_LITERAL_EQUALS(methodName, methodNameLength, \"linkToVirtual\")) {\n+\t\t\tisMethodHandle = TRUE;\n+\t\t}\n+\t\tbreak;\n+\tcase 15:\n+\t\tif (J9UTF8_LITERAL_EQUALS(methodName, methodNameLength, \"linkToInterface\")) {\n+\t\t\tisMethodHandle = TRUE;\n+\t\t}\n+\t\tbreak;", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQxOTAxMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518419013", "bodyText": "fixed", "author": "fengxue-IS", "createdAt": "2020-11-05T22:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxOTM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxOTYxMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517619610", "bodyText": "This shouldn't be indented.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n          \n          \n            \n            #if defined(J9VM_OPT_OPENJDK_METHODHANDLE)", "author": "babsingh", "createdAt": "2020-11-04T20:43:03Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -496,7 +532,47 @@ resolveStaticMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cp\n \tif (isResolvedClassAnInterface) {\n \t\tlookupOptions |= J9_LOOK_INTERFACE;\n \t}\n-\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef), cpClass, lookupOptions);\n+\n+\t#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMTQyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517621426", "bodyText": "We should also disable the above VarHandle (VH) code since OpenJDK VHs are rewritten to the invokehandle bytecode and the above code won't be used.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            #endif /* defined(J9VM_OPT_METHOD_HANDLE) || defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n          \n          \n            \n            #else /* defined(J9VM_OPT_METHOD_HANDLE) */\n          \n          \n            \n                ASSERT(...);\n          \n          \n            \n            #endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */", "author": "babsingh", "createdAt": "2020-11-04T20:46:32Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1611,7 +1716,7 @@ resolveVirtualMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA c\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n+#endif /* defined(J9VM_OPT_METHOD_HANDLE) || defined(J9VM_OPT_OPENJDK_METHODHANDLE) */", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5MDQ4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518890488", "bodyText": "VM_Assert_\nBut yes, totally agree!", "author": "DanHeidinga", "createdAt": "2020-11-06T17:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMTQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI2MzEyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r522263126", "bodyText": "fixed", "author": "fengxue-IS", "createdAt": "2020-11-12T16:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMTQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMjYzNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517622635", "bodyText": "Not needed since we are also disabling the else if for VarHandles since it is not needed for the OpenJDK implementation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            #endif /* defined(J9VM_OPT_METHOD_HANDLE) */", "author": "babsingh", "createdAt": "2020-11-04T20:49:00Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1443,6 +1547,7 @@ resolveVirtualMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA c\n \n \t\t\t\tgoto done;\n \t\t\t}\n+#endif /* defined(J9VM_OPT_METHOD_HANDLE) */", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMzY2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517623668", "bodyText": "Don't share this if statement between the two implementations since it makes code difficult to read:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            #elif defined(J9VM_OPT_METHOD_HANDLE) /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n          \n          \n            \n            #elif defined(J9VM_OPT_METHOD_HANDLE) /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n          \n          \n            \n            \t\tif ((NULL != cpShapeDescription) && (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vm))) {", "author": "babsingh", "createdAt": "2020-11-04T20:51:07Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1368,18 +1444,46 @@ resolveVirtualMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA c\n \t\t\tcpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass);\n \t\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n \t\t}\n-\t\t\n-#if defined(J9VM_OPT_METHOD_HANDLE)\n-\t\t/*\n-\t\t * Check for MH.invoke and MH.invokeExact.\n-\t\t *\n-\t\t * Methodrefs corresponding to those methods already have their methodIndex set to index into\n-\t\t * cpClass->methodTypes. We resolve them by calling into MethodType.fromMethodDescriptorString()\n-\t\t * and storing the result into the cpClass->methodTypes table.\n-\t\t */\n+\n+#if defined(J9VM_OPT_METHOD_HANDLE) || defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n \t\tif ((NULL != cpShapeDescription)\n \t\t&& (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vm))\n \t\t) {\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\t\t\t/**\n+\t\t\t * Check for MH intrinsic methods\n+\t\t\t *\n+\t\t\t * Modify the signature to avoid signature mismatch due to varargs\n+\t\t\t * These methods have special INL send targets\n+\t\t\t */\n+\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n+\t\t\tU_8* initialMethodName = J9UTF8_DATA(nameUTF);\n+\t\t\tU_16 initialMethodNameLength = J9UTF8_LENGTH(nameUTF);\n+\n+\t\t\tif (isMethodHandleINL(initialMethodName, initialMethodNameLength)) {\n+\t\t\t\tJ9UTF8 *modifiedMethodName = (J9UTF8 *)(nameAndNAS + sizeof(J9ROMNameAndSignature));\n+\t\t\t\tJ9UTF8 *modifiedMethodSig = (J9UTF8 *)(nameAndNAS + sizeof(nameAndNAS) - sizeof(J9UTF8));\n+\t\t\t\tmemset(nameAndNAS, 0, sizeof(nameAndNAS));\n+\n+\t\t\t\t/* Create new J9ROMNameAndSignature */\n+\t\t\t\tnameAndSig = (J9ROMNameAndSignature *)nameAndNAS;\n+\t\t\t\tNNSRP_SET(nameAndSig->name, modifiedMethodName);\n+\t\t\t\tNNSRP_SET(nameAndSig->signature, modifiedMethodSig);\n+\n+\t\t\t\tmodifiedMethodName->length = initialMethodNameLength;\n+\t\t\t\tmemcpy(modifiedMethodName->data, initialMethodName, initialMethodNameLength);\n+\n+\t\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t\t}\n+#elif defined(J9VM_OPT_METHOD_HANDLE) /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMzc5Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517623796", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t}", "author": "babsingh", "createdAt": "2020-11-04T20:51:24Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1368,18 +1444,46 @@ resolveVirtualMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA c\n \t\t\tcpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass);\n \t\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n \t\t}\n-\t\t\n-#if defined(J9VM_OPT_METHOD_HANDLE)\n-\t\t/*\n-\t\t * Check for MH.invoke and MH.invokeExact.\n-\t\t *\n-\t\t * Methodrefs corresponding to those methods already have their methodIndex set to index into\n-\t\t * cpClass->methodTypes. We resolve them by calling into MethodType.fromMethodDescriptorString()\n-\t\t * and storing the result into the cpClass->methodTypes table.\n-\t\t */\n+\n+#if defined(J9VM_OPT_METHOD_HANDLE) || defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n \t\tif ((NULL != cpShapeDescription)\n \t\t&& (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vm))\n \t\t) {\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\t\t\t/**\n+\t\t\t * Check for MH intrinsic methods\n+\t\t\t *\n+\t\t\t * Modify the signature to avoid signature mismatch due to varargs\n+\t\t\t * These methods have special INL send targets\n+\t\t\t */\n+\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n+\t\t\tU_8* initialMethodName = J9UTF8_DATA(nameUTF);\n+\t\t\tU_16 initialMethodNameLength = J9UTF8_LENGTH(nameUTF);\n+\n+\t\t\tif (isMethodHandleINL(initialMethodName, initialMethodNameLength)) {\n+\t\t\t\tJ9UTF8 *modifiedMethodName = (J9UTF8 *)(nameAndNAS + sizeof(J9ROMNameAndSignature));\n+\t\t\t\tJ9UTF8 *modifiedMethodSig = (J9UTF8 *)(nameAndNAS + sizeof(nameAndNAS) - sizeof(J9UTF8));\n+\t\t\t\tmemset(nameAndNAS, 0, sizeof(nameAndNAS));\n+\n+\t\t\t\t/* Create new J9ROMNameAndSignature */\n+\t\t\t\tnameAndSig = (J9ROMNameAndSignature *)nameAndNAS;\n+\t\t\t\tNNSRP_SET(nameAndSig->name, modifiedMethodName);\n+\t\t\t\tNNSRP_SET(nameAndSig->signature, modifiedMethodSig);\n+\n+\t\t\t\tmodifiedMethodName->length = initialMethodNameLength;\n+\t\t\t\tmemcpy(modifiedMethodName->data, initialMethodName, initialMethodNameLength);\n+\n+\t\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t\t}", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyNDE0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517624149", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            #if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n          \n          \n            \n            #if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n          \n          \n            \n            \t\tif ((NULL != cpShapeDescription) && (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vm))) {", "author": "babsingh", "createdAt": "2020-11-04T20:52:02Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1368,18 +1444,46 @@ resolveVirtualMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA c\n \t\t\tcpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass);\n \t\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n \t\t}\n-\t\t\n-#if defined(J9VM_OPT_METHOD_HANDLE)\n-\t\t/*\n-\t\t * Check for MH.invoke and MH.invokeExact.\n-\t\t *\n-\t\t * Methodrefs corresponding to those methods already have their methodIndex set to index into\n-\t\t * cpClass->methodTypes. We resolve them by calling into MethodType.fromMethodDescriptorString()\n-\t\t * and storing the result into the cpClass->methodTypes table.\n-\t\t */\n+\n+#if defined(J9VM_OPT_METHOD_HANDLE) || defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n \t\tif ((NULL != cpShapeDescription)\n \t\t&& (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vm))\n \t\t) {\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyNDg3MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517624870", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            #if defined(J9VM_OPT_METHOD_HANDLE) || defined(J9VM_OPT_OPENJDK_METHODHANDLE)", "author": "babsingh", "createdAt": "2020-11-04T20:53:27Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1368,18 +1444,46 @@ resolveVirtualMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA c\n \t\t\tcpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass);\n \t\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n \t\t}\n-\t\t\n-#if defined(J9VM_OPT_METHOD_HANDLE)\n-\t\t/*\n-\t\t * Check for MH.invoke and MH.invokeExact.\n-\t\t *\n-\t\t * Methodrefs corresponding to those methods already have their methodIndex set to index into\n-\t\t * cpClass->methodTypes. We resolve them by calling into MethodType.fromMethodDescriptorString()\n-\t\t * and storing the result into the cpClass->methodTypes table.\n-\t\t */\n+\n+#if defined(J9VM_OPT_METHOD_HANDLE) || defined(J9VM_OPT_OPENJDK_METHODHANDLE)", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyNDk0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517624949", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tif ((NULL != cpShapeDescription)", "author": "babsingh", "createdAt": "2020-11-04T20:53:36Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1368,18 +1444,46 @@ resolveVirtualMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA c\n \t\t\tcpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass);\n \t\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n \t\t}\n-\t\t\n-#if defined(J9VM_OPT_METHOD_HANDLE)\n-\t\t/*\n-\t\t * Check for MH.invoke and MH.invokeExact.\n-\t\t *\n-\t\t * Methodrefs corresponding to those methods already have their methodIndex set to index into\n-\t\t * cpClass->methodTypes. We resolve them by calling into MethodType.fromMethodDescriptorString()\n-\t\t * and storing the result into the cpClass->methodTypes table.\n-\t\t */\n+\n+#if defined(J9VM_OPT_METHOD_HANDLE) || defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n \t\tif ((NULL != cpShapeDescription)", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyNTAxOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517625018", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t&& (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vm))", "author": "babsingh", "createdAt": "2020-11-04T20:53:45Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1368,18 +1444,46 @@ resolveVirtualMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA c\n \t\t\tcpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass);\n \t\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n \t\t}\n-\t\t\n-#if defined(J9VM_OPT_METHOD_HANDLE)\n-\t\t/*\n-\t\t * Check for MH.invoke and MH.invokeExact.\n-\t\t *\n-\t\t * Methodrefs corresponding to those methods already have their methodIndex set to index into\n-\t\t * cpClass->methodTypes. We resolve them by calling into MethodType.fromMethodDescriptorString()\n-\t\t * and storing the result into the cpClass->methodTypes table.\n-\t\t */\n+\n+#if defined(J9VM_OPT_METHOD_HANDLE) || defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n \t\tif ((NULL != cpShapeDescription)\n \t\t&& (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vm))", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyNTA5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517625094", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t) {", "author": "babsingh", "createdAt": "2020-11-04T20:53:54Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1368,18 +1444,46 @@ resolveVirtualMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA c\n \t\t\tcpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass);\n \t\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n \t\t}\n-\t\t\n-#if defined(J9VM_OPT_METHOD_HANDLE)\n-\t\t/*\n-\t\t * Check for MH.invoke and MH.invokeExact.\n-\t\t *\n-\t\t * Methodrefs corresponding to those methods already have their methodIndex set to index into\n-\t\t * cpClass->methodTypes. We resolve them by calling into MethodType.fromMethodDescriptorString()\n-\t\t * and storing the result into the cpClass->methodTypes table.\n-\t\t */\n+\n+#if defined(J9VM_OPT_METHOD_HANDLE) || defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n \t\tif ((NULL != cpShapeDescription)\n \t\t&& (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vm))\n \t\t) {", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyNjgxNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517626817", "bodyText": "The entry tracepoint should be invoked before the above return statements. The exit tracepoint should also be invoked before the above return _statements.", "author": "babsingh", "createdAt": "2020-11-04T20:57:13Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1979,6 +2084,56 @@ resolveMethodHandleRef(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpInde\n \n }\n \n+j9object_t\n+resolveInvokeHandle(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n+{\n+\tj9object_t result = NULL;\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tbool canRunJavaCode = J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_REDEFINE_CLASS);\n+\tJ9RAMMethodRef *ramCPEntry = (J9RAMMethodRef*)ramCP + cpIndex;\n+\tUDATA invokeCacheIndex = ramCPEntry->methodIndexAndArgCount >> 8;\n+\tJ9Class *ramClass = J9_CLASS_FROM_CP(ramCP);\n+\tj9object_t *invokeCache = ramClass->invokeCache + invokeCacheIndex;\n+\tresult = *invokeCache;\n+\n+\tif (NULL != result) {\n+\t\treturn result;\n+\t} else if (!canRunJavaCode) {\n+\t\treturn NULL;\n+\t}\n+\n+\tTrc_VM_resolveInvokeHandle_Entry(vmThread, ramCP, cpIndex, resolveFlags);", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI2MzM5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r522263391", "bodyText": "fixed", "author": "fengxue-IS", "createdAt": "2020-11-12T16:59:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyNjgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyNjk3Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517626973", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t/* Already a pending exception */\n          \n          \n            \n            \t\t\t/* Already a pending exception. */", "author": "babsingh", "createdAt": "2020-11-04T20:57:31Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1979,6 +2084,56 @@ resolveMethodHandleRef(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpInde\n \n }\n \n+j9object_t\n+resolveInvokeHandle(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n+{\n+\tj9object_t result = NULL;\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tbool canRunJavaCode = J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_REDEFINE_CLASS);\n+\tJ9RAMMethodRef *ramCPEntry = (J9RAMMethodRef*)ramCP + cpIndex;\n+\tUDATA invokeCacheIndex = ramCPEntry->methodIndexAndArgCount >> 8;\n+\tJ9Class *ramClass = J9_CLASS_FROM_CP(ramCP);\n+\tj9object_t *invokeCache = ramClass->invokeCache + invokeCacheIndex;\n+\tresult = *invokeCache;\n+\n+\tif (NULL != result) {\n+\t\treturn result;\n+\t} else if (!canRunJavaCode) {\n+\t\treturn NULL;\n+\t}\n+\n+\tTrc_VM_resolveInvokeHandle_Entry(vmThread, ramCP, cpIndex, resolveFlags);\n+\n+\tJ9ROMMethodRef *romMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n+\tJ9ROMNameAndSignature *nameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n+\n+\t/* Resolve the class. */\n+\tJ9Class *resolvedClass = resolveClassRef(vmThread, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n+\tif (resolvedClass != NULL) {\n+\t\tsendResolveOpenJDKInvokeHandle(vmThread, ramCP, cpIndex, MH_REF_INVOKEVIRTUAL, resolvedClass, nameAndSig);\n+\t\tresult = (j9object_t)vmThread->returnValue;\n+\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\t/* Already a pending exception */", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQwMzA1NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518403054", "bodyText": "keeping existing format for consistency within the file", "author": "fengxue-IS", "createdAt": "2020-11-05T22:16:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyNjk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyNzkwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517627906", "bodyText": "if (result != NULL) is equivalent to the else block in the previous if/else block.", "author": "babsingh", "createdAt": "2020-11-04T20:59:23Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1979,6 +2084,56 @@ resolveMethodHandleRef(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpInde\n \n }\n \n+j9object_t\n+resolveInvokeHandle(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n+{\n+\tj9object_t result = NULL;\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tbool canRunJavaCode = J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_REDEFINE_CLASS);\n+\tJ9RAMMethodRef *ramCPEntry = (J9RAMMethodRef*)ramCP + cpIndex;\n+\tUDATA invokeCacheIndex = ramCPEntry->methodIndexAndArgCount >> 8;\n+\tJ9Class *ramClass = J9_CLASS_FROM_CP(ramCP);\n+\tj9object_t *invokeCache = ramClass->invokeCache + invokeCacheIndex;\n+\tresult = *invokeCache;\n+\n+\tif (NULL != result) {\n+\t\treturn result;\n+\t} else if (!canRunJavaCode) {\n+\t\treturn NULL;\n+\t}\n+\n+\tTrc_VM_resolveInvokeHandle_Entry(vmThread, ramCP, cpIndex, resolveFlags);\n+\n+\tJ9ROMMethodRef *romMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n+\tJ9ROMNameAndSignature *nameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n+\n+\t/* Resolve the class. */\n+\tJ9Class *resolvedClass = resolveClassRef(vmThread, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n+\tif (resolvedClass != NULL) {\n+\t\tsendResolveOpenJDKInvokeHandle(vmThread, ramCP, cpIndex, MH_REF_INVOKEVIRTUAL, resolvedClass, nameAndSig);\n+\t\tresult = (j9object_t)vmThread->returnValue;\n+\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\t/* Already a pending exception */\n+\t\t\tresult = NULL;\n+\t\t} else if (result == NULL) {\n+\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t\t}\n+\n+\t\tif (result != NULL) {", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQxOTg1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518419856", "bodyText": "fixed", "author": "fengxue-IS", "createdAt": "2020-11-05T22:55:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyNzkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyODA4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517628088", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t}\n          \n          \n            \n            \t\t} else { /* (result != NULL) */", "author": "babsingh", "createdAt": "2020-11-04T20:59:45Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1979,6 +2084,56 @@ resolveMethodHandleRef(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpInde\n \n }\n \n+j9object_t\n+resolveInvokeHandle(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n+{\n+\tj9object_t result = NULL;\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tbool canRunJavaCode = J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_REDEFINE_CLASS);\n+\tJ9RAMMethodRef *ramCPEntry = (J9RAMMethodRef*)ramCP + cpIndex;\n+\tUDATA invokeCacheIndex = ramCPEntry->methodIndexAndArgCount >> 8;\n+\tJ9Class *ramClass = J9_CLASS_FROM_CP(ramCP);\n+\tj9object_t *invokeCache = ramClass->invokeCache + invokeCacheIndex;\n+\tresult = *invokeCache;\n+\n+\tif (NULL != result) {\n+\t\treturn result;\n+\t} else if (!canRunJavaCode) {\n+\t\treturn NULL;\n+\t}\n+\n+\tTrc_VM_resolveInvokeHandle_Entry(vmThread, ramCP, cpIndex, resolveFlags);\n+\n+\tJ9ROMMethodRef *romMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n+\tJ9ROMNameAndSignature *nameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n+\n+\t/* Resolve the class. */\n+\tJ9Class *resolvedClass = resolveClassRef(vmThread, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n+\tif (resolvedClass != NULL) {\n+\t\tsendResolveOpenJDKInvokeHandle(vmThread, ramCP, cpIndex, MH_REF_INVOKEVIRTUAL, resolvedClass, nameAndSig);\n+\t\tresult = (j9object_t)vmThread->returnValue;\n+\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\t/* Already a pending exception */\n+\t\t\tresult = NULL;\n+\t\t} else if (result == NULL) {\n+\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t\t}", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyOTAwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517629006", "bodyText": "The entry tracepoint should be invoked before the above return statement. The exit tracepoint should also be invoked before the above return statement.", "author": "babsingh", "createdAt": "2020-11-04T21:01:38Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -2105,56 +2260,80 @@ resolveInvokeDynamic(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA callSite\n {\n \tAssert_VM_true(J9_RESOLVE_FLAG_RUNTIME_RESOLVE == resolveFlags);\n \tj9object_t *callSite = ramCP->ramClass->callSites + callSiteIndex;\n-\tj9object_t methodHandle = *callSite;\n+\tj9object_t result = *callSite;\n \n \tJ9ROMClass *romClass = ramCP->ramClass->romClass;\n \tJ9SRP *callSiteData = (J9SRP *) J9ROMCLASS_CALLSITEDATA(romClass);\n \tU_16 *bsmIndices = (U_16 *) (callSiteData + romClass->callSiteCount);\n \tU_16 *bsmData = bsmIndices + romClass->callSiteCount;\n \tJ9ROMNameAndSignature* nameAndSig = SRP_PTR_GET(callSiteData + callSiteIndex, J9ROMNameAndSignature*);\n \tU_16 bsmIndex = bsmIndices[callSiteIndex];\n-\tU_16 i;\n+\tU_16 i = 0;\n \n \t/* Check if already resolved */\n-\tif (methodHandle != NULL) {\n-\t\treturn methodHandle;\n+\tif (result != NULL) {\n+\t\treturn result;\n \t}\n \n+\tTrc_VM_resolveInvokeDynamic_Entry(vmThread, callSiteIndex, bsmIndex, resolveFlags);", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMDAyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517630021", "bodyText": "The code can be rewritten to have only one return statement. This will allow entry and exit tracepoints to be correctly located.", "author": "babsingh", "createdAt": "2020-11-04T21:03:47Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1979,6 +2084,56 @@ resolveMethodHandleRef(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpInde\n \n }\n \n+j9object_t\n+resolveInvokeHandle(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n+{\n+\tj9object_t result = NULL;\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tbool canRunJavaCode = J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_REDEFINE_CLASS);\n+\tJ9RAMMethodRef *ramCPEntry = (J9RAMMethodRef*)ramCP + cpIndex;\n+\tUDATA invokeCacheIndex = ramCPEntry->methodIndexAndArgCount >> 8;\n+\tJ9Class *ramClass = J9_CLASS_FROM_CP(ramCP);\n+\tj9object_t *invokeCache = ramClass->invokeCache + invokeCacheIndex;\n+\tresult = *invokeCache;\n+\n+\tif (NULL != result) {\n+\t\treturn result;\n+\t} else if (!canRunJavaCode) {\n+\t\treturn NULL;", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI2MzY1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r522263658", "bodyText": "fixed", "author": "fengxue-IS", "createdAt": "2020-11-12T16:59:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMDAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMDE4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517630188", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t/* store result */\n          \n          \n            \n            \t\t\t/* Store result. */", "author": "babsingh", "createdAt": "2020-11-04T21:04:04Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1979,6 +2084,56 @@ resolveMethodHandleRef(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpInde\n \n }\n \n+j9object_t\n+resolveInvokeHandle(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n+{\n+\tj9object_t result = NULL;\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tbool canRunJavaCode = J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_REDEFINE_CLASS);\n+\tJ9RAMMethodRef *ramCPEntry = (J9RAMMethodRef*)ramCP + cpIndex;\n+\tUDATA invokeCacheIndex = ramCPEntry->methodIndexAndArgCount >> 8;\n+\tJ9Class *ramClass = J9_CLASS_FROM_CP(ramCP);\n+\tj9object_t *invokeCache = ramClass->invokeCache + invokeCacheIndex;\n+\tresult = *invokeCache;\n+\n+\tif (NULL != result) {\n+\t\treturn result;\n+\t} else if (!canRunJavaCode) {\n+\t\treturn NULL;\n+\t}\n+\n+\tTrc_VM_resolveInvokeHandle_Entry(vmThread, ramCP, cpIndex, resolveFlags);\n+\n+\tJ9ROMMethodRef *romMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n+\tJ9ROMNameAndSignature *nameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n+\n+\t/* Resolve the class. */\n+\tJ9Class *resolvedClass = resolveClassRef(vmThread, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n+\tif (resolvedClass != NULL) {\n+\t\tsendResolveOpenJDKInvokeHandle(vmThread, ramCP, cpIndex, MH_REF_INVOKEVIRTUAL, resolvedClass, nameAndSig);\n+\t\tresult = (j9object_t)vmThread->returnValue;\n+\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\t/* Already a pending exception */\n+\t\t\tresult = NULL;\n+\t\t} else if (result == NULL) {\n+\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t\t}\n+\n+\t\tif (result != NULL) {\n+\t\t\t/* store result */", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMDU3OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517630579", "bodyText": "If possible, avoid multiple return statements. This will make it easier to position entry and exit tracepoints.", "author": "babsingh", "createdAt": "2020-11-04T21:04:50Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -2105,56 +2260,80 @@ resolveInvokeDynamic(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA callSite\n {\n \tAssert_VM_true(J9_RESOLVE_FLAG_RUNTIME_RESOLVE == resolveFlags);\n \tj9object_t *callSite = ramCP->ramClass->callSites + callSiteIndex;\n-\tj9object_t methodHandle = *callSite;\n+\tj9object_t result = *callSite;\n \n \tJ9ROMClass *romClass = ramCP->ramClass->romClass;\n \tJ9SRP *callSiteData = (J9SRP *) J9ROMCLASS_CALLSITEDATA(romClass);\n \tU_16 *bsmIndices = (U_16 *) (callSiteData + romClass->callSiteCount);\n \tU_16 *bsmData = bsmIndices + romClass->callSiteCount;\n \tJ9ROMNameAndSignature* nameAndSig = SRP_PTR_GET(callSiteData + callSiteIndex, J9ROMNameAndSignature*);\n \tU_16 bsmIndex = bsmIndices[callSiteIndex];\n-\tU_16 i;\n+\tU_16 i = 0;\n \n \t/* Check if already resolved */\n-\tif (methodHandle != NULL) {\n-\t\treturn methodHandle;\n+\tif (result != NULL) {\n+\t\treturn result;", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMTEzMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517631133", "bodyText": "The below if (result != NULL) can be replaced with an else block here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t}\n          \n          \n            \n            \t} else { // (result != NULL)", "author": "babsingh", "createdAt": "2020-11-04T21:05:58Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -2105,56 +2260,80 @@ resolveInvokeDynamic(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA callSite\n {\n \tAssert_VM_true(J9_RESOLVE_FLAG_RUNTIME_RESOLVE == resolveFlags);\n \tj9object_t *callSite = ramCP->ramClass->callSites + callSiteIndex;\n-\tj9object_t methodHandle = *callSite;\n+\tj9object_t result = *callSite;\n \n \tJ9ROMClass *romClass = ramCP->ramClass->romClass;\n \tJ9SRP *callSiteData = (J9SRP *) J9ROMCLASS_CALLSITEDATA(romClass);\n \tU_16 *bsmIndices = (U_16 *) (callSiteData + romClass->callSiteCount);\n \tU_16 *bsmData = bsmIndices + romClass->callSiteCount;\n \tJ9ROMNameAndSignature* nameAndSig = SRP_PTR_GET(callSiteData + callSiteIndex, J9ROMNameAndSignature*);\n \tU_16 bsmIndex = bsmIndices[callSiteIndex];\n-\tU_16 i;\n+\tU_16 i = 0;\n \n \t/* Check if already resolved */\n-\tif (methodHandle != NULL) {\n-\t\treturn methodHandle;\n+\tif (result != NULL) {\n+\t\treturn result;\n \t}\n \n+\tTrc_VM_resolveInvokeDynamic_Entry(vmThread, callSiteIndex, bsmIndex, resolveFlags);\n+\n \t/* Walk bsmData - skip all bootstrap methods before bsmIndex */\n \tfor (i = 0; i < bsmIndex; i++) {\n \t\t/* increment by size of bsm data plus header */\n \t\tbsmData += bsmData[1] + 2;\n \t}\n \n \tsendResolveInvokeDynamic(vmThread, ramCP, callSiteIndex, nameAndSig, bsmData);\n-\tmethodHandle = (j9object_t) vmThread->returnValue;\n+\tresult = (j9object_t) vmThread->returnValue;\n+\n+\tTrc_VM_resolveInvokeDynamic_Resolved(vmThread, callSiteIndex, result);\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n \t/* check if an exception is already pending */\n \tif (vmThread->currentException != NULL) {\n \t\t/* Already a pending exception */\n-\t\tmethodHandle = NULL;\n-\t} else if (methodHandle == NULL) {\n+\t\tresult = vmThread->currentException;\n+\t} else if (result == NULL) {\n+\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t}", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMTI1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517631256", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t/* check if an exception is already pending */\n          \n          \n            \n            \t/* Check if an exception is already pending. */", "author": "babsingh", "createdAt": "2020-11-04T21:06:11Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -2105,56 +2260,80 @@ resolveInvokeDynamic(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA callSite\n {\n \tAssert_VM_true(J9_RESOLVE_FLAG_RUNTIME_RESOLVE == resolveFlags);\n \tj9object_t *callSite = ramCP->ramClass->callSites + callSiteIndex;\n-\tj9object_t methodHandle = *callSite;\n+\tj9object_t result = *callSite;\n \n \tJ9ROMClass *romClass = ramCP->ramClass->romClass;\n \tJ9SRP *callSiteData = (J9SRP *) J9ROMCLASS_CALLSITEDATA(romClass);\n \tU_16 *bsmIndices = (U_16 *) (callSiteData + romClass->callSiteCount);\n \tU_16 *bsmData = bsmIndices + romClass->callSiteCount;\n \tJ9ROMNameAndSignature* nameAndSig = SRP_PTR_GET(callSiteData + callSiteIndex, J9ROMNameAndSignature*);\n \tU_16 bsmIndex = bsmIndices[callSiteIndex];\n-\tU_16 i;\n+\tU_16 i = 0;\n \n \t/* Check if already resolved */\n-\tif (methodHandle != NULL) {\n-\t\treturn methodHandle;\n+\tif (result != NULL) {\n+\t\treturn result;\n \t}\n \n+\tTrc_VM_resolveInvokeDynamic_Entry(vmThread, callSiteIndex, bsmIndex, resolveFlags);\n+\n \t/* Walk bsmData - skip all bootstrap methods before bsmIndex */\n \tfor (i = 0; i < bsmIndex; i++) {\n \t\t/* increment by size of bsm data plus header */\n \t\tbsmData += bsmData[1] + 2;\n \t}\n \n \tsendResolveInvokeDynamic(vmThread, ramCP, callSiteIndex, nameAndSig, bsmData);\n-\tmethodHandle = (j9object_t) vmThread->returnValue;\n+\tresult = (j9object_t) vmThread->returnValue;\n+\n+\tTrc_VM_resolveInvokeDynamic_Resolved(vmThread, callSiteIndex, result);\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n \t/* check if an exception is already pending */", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMTMxMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517631310", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t/* Already a pending exception */\n          \n          \n            \n            \t\t/* Already a pending exception. */", "author": "babsingh", "createdAt": "2020-11-04T21:06:19Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -2105,56 +2260,80 @@ resolveInvokeDynamic(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA callSite\n {\n \tAssert_VM_true(J9_RESOLVE_FLAG_RUNTIME_RESOLVE == resolveFlags);\n \tj9object_t *callSite = ramCP->ramClass->callSites + callSiteIndex;\n-\tj9object_t methodHandle = *callSite;\n+\tj9object_t result = *callSite;\n \n \tJ9ROMClass *romClass = ramCP->ramClass->romClass;\n \tJ9SRP *callSiteData = (J9SRP *) J9ROMCLASS_CALLSITEDATA(romClass);\n \tU_16 *bsmIndices = (U_16 *) (callSiteData + romClass->callSiteCount);\n \tU_16 *bsmData = bsmIndices + romClass->callSiteCount;\n \tJ9ROMNameAndSignature* nameAndSig = SRP_PTR_GET(callSiteData + callSiteIndex, J9ROMNameAndSignature*);\n \tU_16 bsmIndex = bsmIndices[callSiteIndex];\n-\tU_16 i;\n+\tU_16 i = 0;\n \n \t/* Check if already resolved */\n-\tif (methodHandle != NULL) {\n-\t\treturn methodHandle;\n+\tif (result != NULL) {\n+\t\treturn result;\n \t}\n \n+\tTrc_VM_resolveInvokeDynamic_Entry(vmThread, callSiteIndex, bsmIndex, resolveFlags);\n+\n \t/* Walk bsmData - skip all bootstrap methods before bsmIndex */\n \tfor (i = 0; i < bsmIndex; i++) {\n \t\t/* increment by size of bsm data plus header */\n \t\tbsmData += bsmData[1] + 2;\n \t}\n \n \tsendResolveInvokeDynamic(vmThread, ramCP, callSiteIndex, nameAndSig, bsmData);\n-\tmethodHandle = (j9object_t) vmThread->returnValue;\n+\tresult = (j9object_t) vmThread->returnValue;\n+\n+\tTrc_VM_resolveInvokeDynamic_Resolved(vmThread, callSiteIndex, result);\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n \t/* check if an exception is already pending */\n \tif (vmThread->currentException != NULL) {\n \t\t/* Already a pending exception */", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQwMzIzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518403238", "bodyText": "keeping existing format for consistency within the file", "author": "fengxue-IS", "createdAt": "2020-11-05T22:16:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMTMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMTQwMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517631403", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t/* store result */\n          \n          \n            \n            \t\t/* Store result. */", "author": "babsingh", "createdAt": "2020-11-04T21:06:33Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -2105,56 +2260,80 @@ resolveInvokeDynamic(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA callSite\n {\n \tAssert_VM_true(J9_RESOLVE_FLAG_RUNTIME_RESOLVE == resolveFlags);\n \tj9object_t *callSite = ramCP->ramClass->callSites + callSiteIndex;\n-\tj9object_t methodHandle = *callSite;\n+\tj9object_t result = *callSite;\n \n \tJ9ROMClass *romClass = ramCP->ramClass->romClass;\n \tJ9SRP *callSiteData = (J9SRP *) J9ROMCLASS_CALLSITEDATA(romClass);\n \tU_16 *bsmIndices = (U_16 *) (callSiteData + romClass->callSiteCount);\n \tU_16 *bsmData = bsmIndices + romClass->callSiteCount;\n \tJ9ROMNameAndSignature* nameAndSig = SRP_PTR_GET(callSiteData + callSiteIndex, J9ROMNameAndSignature*);\n \tU_16 bsmIndex = bsmIndices[callSiteIndex];\n-\tU_16 i;\n+\tU_16 i = 0;\n \n \t/* Check if already resolved */\n-\tif (methodHandle != NULL) {\n-\t\treturn methodHandle;\n+\tif (result != NULL) {\n+\t\treturn result;\n \t}\n \n+\tTrc_VM_resolveInvokeDynamic_Entry(vmThread, callSiteIndex, bsmIndex, resolveFlags);\n+\n \t/* Walk bsmData - skip all bootstrap methods before bsmIndex */\n \tfor (i = 0; i < bsmIndex; i++) {\n \t\t/* increment by size of bsm data plus header */\n \t\tbsmData += bsmData[1] + 2;\n \t}\n \n \tsendResolveInvokeDynamic(vmThread, ramCP, callSiteIndex, nameAndSig, bsmData);\n-\tmethodHandle = (j9object_t) vmThread->returnValue;\n+\tresult = (j9object_t) vmThread->returnValue;\n+\n+\tTrc_VM_resolveInvokeDynamic_Resolved(vmThread, callSiteIndex, result);\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n \t/* check if an exception is already pending */\n \tif (vmThread->currentException != NULL) {\n \t\t/* Already a pending exception */\n-\t\tmethodHandle = NULL;\n-\t} else if (methodHandle == NULL) {\n+\t\tresult = vmThread->currentException;\n+\t} else if (result == NULL) {\n+\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t}\n+\n+\tif (result != NULL) {\n+\t\t/* store result */", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMTUxNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517631517", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t/* check if an exception is already pending */\n          \n          \n            \n            \t/* Check if an exception is already pending. */", "author": "babsingh", "createdAt": "2020-11-04T21:06:46Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -2105,56 +2260,80 @@ resolveInvokeDynamic(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA callSite\n {\n \tAssert_VM_true(J9_RESOLVE_FLAG_RUNTIME_RESOLVE == resolveFlags);\n \tj9object_t *callSite = ramCP->ramClass->callSites + callSiteIndex;\n-\tj9object_t methodHandle = *callSite;\n+\tj9object_t result = *callSite;\n \n \tJ9ROMClass *romClass = ramCP->ramClass->romClass;\n \tJ9SRP *callSiteData = (J9SRP *) J9ROMCLASS_CALLSITEDATA(romClass);\n \tU_16 *bsmIndices = (U_16 *) (callSiteData + romClass->callSiteCount);\n \tU_16 *bsmData = bsmIndices + romClass->callSiteCount;\n \tJ9ROMNameAndSignature* nameAndSig = SRP_PTR_GET(callSiteData + callSiteIndex, J9ROMNameAndSignature*);\n \tU_16 bsmIndex = bsmIndices[callSiteIndex];\n-\tU_16 i;\n+\tU_16 i = 0;\n \n \t/* Check if already resolved */\n-\tif (methodHandle != NULL) {\n-\t\treturn methodHandle;\n+\tif (result != NULL) {\n+\t\treturn result;\n \t}\n \n+\tTrc_VM_resolveInvokeDynamic_Entry(vmThread, callSiteIndex, bsmIndex, resolveFlags);\n+\n \t/* Walk bsmData - skip all bootstrap methods before bsmIndex */\n \tfor (i = 0; i < bsmIndex; i++) {\n \t\t/* increment by size of bsm data plus header */\n \t\tbsmData += bsmData[1] + 2;\n \t}\n \n \tsendResolveInvokeDynamic(vmThread, ramCP, callSiteIndex, nameAndSig, bsmData);\n-\tmethodHandle = (j9object_t) vmThread->returnValue;\n+\tresult = (j9object_t) vmThread->returnValue;\n+\n+\tTrc_VM_resolveInvokeDynamic_Resolved(vmThread, callSiteIndex, result);\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n \t/* check if an exception is already pending */\n \tif (vmThread->currentException != NULL) {\n \t\t/* Already a pending exception */\n-\t\tmethodHandle = NULL;\n-\t} else if (methodHandle == NULL) {\n+\t\tresult = vmThread->currentException;\n+\t} else if (result == NULL) {\n+\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t}\n+\n+\tif (result != NULL) {\n+\t\t/* store result */\n+\t\tJ9MemoryManagerFunctions *gcFuncs = vmThread->javaVM->memoryManagerFunctions;\n+\t\tJ9Class *j9class = J9_CLASS_FROM_CP(ramCP);\n+\t\tif (0 == gcFuncs->j9gc_objaccess_staticCompareAndSwapObject(vmThread, j9class, callSite, NULL, result)) {\n+\t\t\t/* Another thread beat this thread to updating the call site, ensure both threads return the same method handle. */\n+\t\t\tresult = *callSite;\n+\t\t}\n+\t}\n+#else /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n+\t/* check if an exception is already pending */", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMTYwMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517631601", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t/* Already a pending exception */\n          \n          \n            \n            \t\t/* Already a pending exception. */", "author": "babsingh", "createdAt": "2020-11-04T21:06:58Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -2105,56 +2260,80 @@ resolveInvokeDynamic(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA callSite\n {\n \tAssert_VM_true(J9_RESOLVE_FLAG_RUNTIME_RESOLVE == resolveFlags);\n \tj9object_t *callSite = ramCP->ramClass->callSites + callSiteIndex;\n-\tj9object_t methodHandle = *callSite;\n+\tj9object_t result = *callSite;\n \n \tJ9ROMClass *romClass = ramCP->ramClass->romClass;\n \tJ9SRP *callSiteData = (J9SRP *) J9ROMCLASS_CALLSITEDATA(romClass);\n \tU_16 *bsmIndices = (U_16 *) (callSiteData + romClass->callSiteCount);\n \tU_16 *bsmData = bsmIndices + romClass->callSiteCount;\n \tJ9ROMNameAndSignature* nameAndSig = SRP_PTR_GET(callSiteData + callSiteIndex, J9ROMNameAndSignature*);\n \tU_16 bsmIndex = bsmIndices[callSiteIndex];\n-\tU_16 i;\n+\tU_16 i = 0;\n \n \t/* Check if already resolved */\n-\tif (methodHandle != NULL) {\n-\t\treturn methodHandle;\n+\tif (result != NULL) {\n+\t\treturn result;\n \t}\n \n+\tTrc_VM_resolveInvokeDynamic_Entry(vmThread, callSiteIndex, bsmIndex, resolveFlags);\n+\n \t/* Walk bsmData - skip all bootstrap methods before bsmIndex */\n \tfor (i = 0; i < bsmIndex; i++) {\n \t\t/* increment by size of bsm data plus header */\n \t\tbsmData += bsmData[1] + 2;\n \t}\n \n \tsendResolveInvokeDynamic(vmThread, ramCP, callSiteIndex, nameAndSig, bsmData);\n-\tmethodHandle = (j9object_t) vmThread->returnValue;\n+\tresult = (j9object_t) vmThread->returnValue;\n+\n+\tTrc_VM_resolveInvokeDynamic_Resolved(vmThread, callSiteIndex, result);\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n \t/* check if an exception is already pending */\n \tif (vmThread->currentException != NULL) {\n \t\t/* Already a pending exception */\n-\t\tmethodHandle = NULL;\n-\t} else if (methodHandle == NULL) {\n+\t\tresult = vmThread->currentException;\n+\t} else if (result == NULL) {\n+\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t}\n+\n+\tif (result != NULL) {\n+\t\t/* store result */\n+\t\tJ9MemoryManagerFunctions *gcFuncs = vmThread->javaVM->memoryManagerFunctions;\n+\t\tJ9Class *j9class = J9_CLASS_FROM_CP(ramCP);\n+\t\tif (0 == gcFuncs->j9gc_objaccess_staticCompareAndSwapObject(vmThread, j9class, callSite, NULL, result)) {\n+\t\t\t/* Another thread beat this thread to updating the call site, ensure both threads return the same method handle. */\n+\t\t\tresult = *callSite;\n+\t\t}\n+\t}\n+#else /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n+\t/* check if an exception is already pending */\n+\tif (vmThread->currentException != NULL) {\n+\t\t/* Already a pending exception */", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQwMzQwNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518403405", "bodyText": "keeping existing format for consistency within the file", "author": "fengxue-IS", "createdAt": "2020-11-05T22:17:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMTYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMTc5MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r517631790", "bodyText": "The below if (result != NULL) can be replaced with an else block here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t}\n          \n          \n            \n            \t} else { // (result != NULL)", "author": "babsingh", "createdAt": "2020-11-04T21:07:23Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -2105,56 +2260,80 @@ resolveInvokeDynamic(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA callSite\n {\n \tAssert_VM_true(J9_RESOLVE_FLAG_RUNTIME_RESOLVE == resolveFlags);\n \tj9object_t *callSite = ramCP->ramClass->callSites + callSiteIndex;\n-\tj9object_t methodHandle = *callSite;\n+\tj9object_t result = *callSite;\n \n \tJ9ROMClass *romClass = ramCP->ramClass->romClass;\n \tJ9SRP *callSiteData = (J9SRP *) J9ROMCLASS_CALLSITEDATA(romClass);\n \tU_16 *bsmIndices = (U_16 *) (callSiteData + romClass->callSiteCount);\n \tU_16 *bsmData = bsmIndices + romClass->callSiteCount;\n \tJ9ROMNameAndSignature* nameAndSig = SRP_PTR_GET(callSiteData + callSiteIndex, J9ROMNameAndSignature*);\n \tU_16 bsmIndex = bsmIndices[callSiteIndex];\n-\tU_16 i;\n+\tU_16 i = 0;\n \n \t/* Check if already resolved */\n-\tif (methodHandle != NULL) {\n-\t\treturn methodHandle;\n+\tif (result != NULL) {\n+\t\treturn result;\n \t}\n \n+\tTrc_VM_resolveInvokeDynamic_Entry(vmThread, callSiteIndex, bsmIndex, resolveFlags);\n+\n \t/* Walk bsmData - skip all bootstrap methods before bsmIndex */\n \tfor (i = 0; i < bsmIndex; i++) {\n \t\t/* increment by size of bsm data plus header */\n \t\tbsmData += bsmData[1] + 2;\n \t}\n \n \tsendResolveInvokeDynamic(vmThread, ramCP, callSiteIndex, nameAndSig, bsmData);\n-\tmethodHandle = (j9object_t) vmThread->returnValue;\n+\tresult = (j9object_t) vmThread->returnValue;\n+\n+\tTrc_VM_resolveInvokeDynamic_Resolved(vmThread, callSiteIndex, result);\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n \t/* check if an exception is already pending */\n \tif (vmThread->currentException != NULL) {\n \t\t/* Already a pending exception */\n-\t\tmethodHandle = NULL;\n-\t} else if (methodHandle == NULL) {\n+\t\tresult = vmThread->currentException;\n+\t} else if (result == NULL) {\n+\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t}\n+\n+\tif (result != NULL) {\n+\t\t/* store result */\n+\t\tJ9MemoryManagerFunctions *gcFuncs = vmThread->javaVM->memoryManagerFunctions;\n+\t\tJ9Class *j9class = J9_CLASS_FROM_CP(ramCP);\n+\t\tif (0 == gcFuncs->j9gc_objaccess_staticCompareAndSwapObject(vmThread, j9class, callSite, NULL, result)) {\n+\t\t\t/* Another thread beat this thread to updating the call site, ensure both threads return the same method handle. */\n+\t\t\tresult = *callSite;\n+\t\t}\n+\t}\n+#else /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n+\t/* check if an exception is already pending */\n+\tif (vmThread->currentException != NULL) {\n+\t\t/* Already a pending exception */\n+\t\tresult = NULL;\n+\t} else if (result == NULL) {\n \t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n \t}", "originalCommit": "95bd6ed99881668882b4e5a6dda478ad2b124a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b959b48b979d00efacf139aca713294bf114e86e", "url": "https://github.com/eclipse-openj9/openj9/commit/b959b48b979d00efacf139aca713294bf114e86e", "message": "Add tracepoints for invokeHandle and invokeDynamic resolution\n\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-11-05T22:51:20Z", "type": "forcePushed"}, {"oid": "8e73fef7ab57e3a2dcfc5db142f359db0017110d", "url": "https://github.com/eclipse-openj9/openj9/commit/8e73fef7ab57e3a2dcfc5db142f359db0017110d", "message": "Add tracepoints for invokeHandle and invokeDynamic resolution\n\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-11-05T22:58:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg1NDYyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518854622", "bodyText": "Rather than duplicating the functions, can you ifdef just the count changes?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            #if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n          \n          \n            \n            \tvoid markMethodRefAsUsedByInvokeHandle(U_16 methodRefCfrCPIndex)        { mark(methodRefCfrCPIndex, INVOKE_HANDLEEXACT); _invokeCacheCount++; }\n          \n          \n            \n            \tvoid markMethodRefAsUsedByInvokeHandleGeneric(U_16 methodRefCfrCPIndex) { mark(methodRefCfrCPIndex, INVOKE_HANDLEGENERIC); _invokeCacheCount++; }\n          \n          \n            \n            #else /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n          \n          \n            \n            \tvoid markMethodRefAsUsedByInvokeHandle(U_16 methodRefCfrCPIndex)        { mark(methodRefCfrCPIndex, INVOKE_HANDLEEXACT); _methodTypeCount++; }\n          \n          \n            \n            \tvoid markMethodRefAsUsedByInvokeHandleGeneric(U_16 methodRefCfrCPIndex) { mark(methodRefCfrCPIndex, INVOKE_HANDLEGENERIC); _methodTypeCount++; }\n          \n          \n            \n            #endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n          \n          \n            \n            \n          \n          \n            \n            \tvoid markMethodRefAsUsedByInvokeHandle(U_16 methodRefCfrCPIndex) { \n          \n          \n            \n            \t\tmark(methodRefCfrCPIndex, INVOKE_HANDLEEXACT); \n          \n          \n            \n            #if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n          \n          \n            \n            \t\t_invokeCacheCount++; \n          \n          \n            \n            #else\n          \n          \n            \n            \t\t_methodTypeCount++;\n          \n          \n            \n            #endif\n          \n          \n            \n            \t}\n          \n          \n            \n            \tvoid markMethodRefAsUsedByInvokeHandleGeneric(U_16 methodRefCfrCPIndex) {\n          \n          \n            \n            \t\tmark(methodRefCfrCPIndex, INVOKE_HANDLEGENERIC); \n          \n          \n            \n            #if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n          \n          \n            \n            \t\t_invokeCacheCount++; \n          \n          \n            \n            #else\n          \n          \n            \n            \t\t_methodTypeCount++;\n          \n          \n            \n            #endif\n          \n          \n            \n            \t}", "author": "DanHeidinga", "createdAt": "2020-11-06T16:14:56Z", "path": "runtime/bcutil/ConstantPoolMap.hpp", "diffHunk": "@@ -287,8 +291,14 @@ class ConstantPoolMap\n \tvoid markMethodRefAsUsedByInvokeSpecial(U_16 methodRefCfrCPIndex)       { mark(methodRefCfrCPIndex, INVOKE_SPECIAL); }\n \tvoid markMethodRefAsUsedByInvokeStatic(U_16 methodRefCfrCPIndex)        { mark(methodRefCfrCPIndex, INVOKE_STATIC); }\n \tvoid markMethodRefAsUsedByInvokeInterface(U_16 methodRefCfrCPIndex)     { mark(methodRefCfrCPIndex, INVOKE_INTERFACE); }\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tvoid markMethodRefAsUsedByInvokeHandle(U_16 methodRefCfrCPIndex)        { mark(methodRefCfrCPIndex, INVOKE_HANDLEEXACT); _invokeCacheCount++; }\n+\tvoid markMethodRefAsUsedByInvokeHandleGeneric(U_16 methodRefCfrCPIndex) { mark(methodRefCfrCPIndex, INVOKE_HANDLEGENERIC); _invokeCacheCount++; }\n+#else /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n \tvoid markMethodRefAsUsedByInvokeHandle(U_16 methodRefCfrCPIndex)        { mark(methodRefCfrCPIndex, INVOKE_HANDLEEXACT); _methodTypeCount++; }\n \tvoid markMethodRefAsUsedByInvokeHandleGeneric(U_16 methodRefCfrCPIndex) { mark(methodRefCfrCPIndex, INVOKE_HANDLEGENERIC); _methodTypeCount++; }\n+#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */", "originalCommit": "8e73fef7ab57e3a2dcfc5db142f359db0017110d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI2Mzg5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r522263894", "bodyText": "fixed", "author": "fengxue-IS", "createdAt": "2020-11-12T17:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg1NDYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2MDYzMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518860633", "bodyText": "the code on the old path used to handle resolving the targetClass here.  Is this not needed anymore?", "author": "DanHeidinga", "createdAt": "2020-11-06T16:24:57Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -2325,6 +2325,26 @@ old_slow_jitResolveHandleMethod(J9VMThread *currentThread)\n \tDECLARE_JIT_PARM(void*, jitEIP, 3);\n \tvoid *addr = NULL;\n \tJ9JavaVM *vm = currentThread->javaVM;\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef*)ramConstantPool) + cpIndex;\n+\tUDATA invokeCacheIndex = ramMethodRef->methodIndexAndArgCount >> 8;\n+retry:\n+\tj9object_t invokeCacheArray = (J9_CLASS_FROM_CP(ramConstantPool)->invokeCache)[invokeCacheIndex];\n+\tif (NULL == invokeCacheArray) {\n+\t\tbuildJITResolveFrameWithPC(currentThread, J9_SSF_JIT_RESOLVE_DATA, parmCount, true, 0, jitEIP);\n+\t\t/* add new resolve code which calls sendResolveInvokeHandle -> MHN.linkMethod()\n+\t\t * store the memberName/appendix values in invokeCache[invokeCacheIndex]\n+\t\t */\n+\t\tvm->internalVMFunctions->resolveInvokeHandle(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);", "originalCommit": "8e73fef7ab57e3a2dcfc5db142f359db0017110d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI2NDYzOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r522264639", "bodyText": "the targetClass is resolved as part of the resolveInvokeHandle call", "author": "fengxue-IS", "createdAt": "2020-11-12T17:01:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2MDYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2MjUxNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518862516", "bodyText": "Shouldn't this iterator be renamed given it's 1) not iterating MTs anymore, 2) it's now dealing with the invokeCache?\n@amicic opinions?", "author": "DanHeidinga", "createdAt": "2020-11-06T16:27:54Z", "path": "runtime/gc_structs/ClassIterator.hpp", "diffHunk": "@@ -85,7 +85,11 @@ class GC_ClassIterator {\n \t\t, _classStaticsIterator(env, clazz)\n \t\t, _constantPoolObjectSlotIterator((J9JavaVM *)env->getLanguageVM(), clazz)\n \t\t, _callSitesIterator(clazz)\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\t\t, _methodTypesIterator(clazz->romClass->invokeCacheCount, clazz->invokeCache)", "originalCommit": "8e73fef7ab57e3a2dcfc5db142f359db0017110d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNjU4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r519006582", "bodyText": "seems reasonable, but since I don't fully understand relationship between MH and invokeCache,  I'll add @dmitripivkine", "author": "amicic", "createdAt": "2020-11-06T21:10:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2MjUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwOTk0NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r519009944", "bodyText": "(from my narrow perspective) I'm wondering why the ifdef build flag has METHODHANDLE in the name, and should it be INVOKECACHE ?", "author": "amicic", "createdAt": "2020-11-06T21:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2MjUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU5NzUyNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r520597527", "bodyText": "The ifdef is for the other all feature which is using the OpenJDK MH implementation.", "author": "DanHeidinga", "createdAt": "2020-11-10T14:20:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2MjUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzMjQ2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r522332468", "bodyText": "@fengxue-IS Can you open an issue to track renaming the GC_MethodTypesIterator to something like GC_InvokeCacheIterator?  We need to track it as a cleanup task that should be done before the final cutover but doesn't need to be included in this PR", "author": "DanHeidinga", "createdAt": "2020-11-12T18:42:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2MjUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3NzAzNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r522377037", "bodyText": "created #11168 to track this cleanup work", "author": "fengxue-IS", "createdAt": "2020-11-12T19:45:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2MjUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2MzIyNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518863225", "bodyText": "Why both resolveInvokeHandle and sendResolveOpenJDKInvokeHandle?  If they are related, shouldn't the names both include OpenJDK?", "author": "DanHeidinga", "createdAt": "2020-11-06T16:29:00Z", "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -4559,8 +4575,10 @@ typedef struct J9InternalVMFunctions {\n \tvoid  (JNICALL *sendForGenericInvoke)(struct J9VMThread *vmThread, j9object_t methodHandle, j9object_t methodType, UDATA dropFirstArg) ;\n \tvoid  (JNICALL *jitFillOSRBuffer)(struct J9VMThread *vmContext, void *osrBlock) ;\n \tvoid  (JNICALL *sendResolveMethodHandle)(struct J9VMThread *vmThread, UDATA cpIndex, J9ConstantPool *ramCP, J9Class *definingClass, J9ROMNameAndSignature* nameAndSig) ;\n+\tj9object_t ( *resolveInvokeHandle)(struct J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags) ;", "originalCommit": "8e73fef7ab57e3a2dcfc5db142f359db0017110d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI2NDkyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r522264921", "bodyText": "fixed naming to both include OpenJDK", "author": "fengxue-IS", "createdAt": "2020-11-12T17:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2MzIyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2ODg4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518868882", "bodyText": "Can you add a comment like this to the code?  It makes it clear what the data we're working with is\n/* Fetch the method to call and add the \"appendix\" arg from the invokeCacheArray.\n * The stack transition looks like:\n * args  <- SP\n * MH\n *\n * and becomes:\n * invokeCacheArray[1] \"appendix\" <- SP\n * args\n * MH\n *\n * and sendMethod is ((j.l.MemberName)invokeCacheArray[0]).vmtargetOffset\n */", "author": "DanHeidinga", "createdAt": "2020-11-06T16:38:06Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8017,23 +8017,23 @@ class INTERPRETER_CLASS\n \t\tU_16 index = *(U_16 *)(_pc + 1);\n \n \t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n-\t\tJ9InvokeCacheEntry *invokeCache = ((J9InvokeCacheEntry *)ramConstantPool->ramClass->callSites) + index;\n+\t\tj9object_t invokeCacheArray = (ramConstantPool->ramClass->callSites)[index];\n \n-\t\tj9object_t memberName = invokeCache->target;\n-\n-\t\tif (J9_EXPECTED(NULL != memberName)) {\n-\t\t\tif (J9OBJECT_CLAZZ(_currentThread, memberName) == J9VMJAVALANGINVOKEMEMBERNAME_OR_NULL(_vm)) {\n+\t\tif (J9_EXPECTED(NULL != invokeCacheArray)) {\n+\t\t\tJ9Class *clazz = J9OBJECT_CLAZZ(_currentThread, invokeCacheArray);\n+\t\t\tif (J9CLASS_IS_ARRAY(clazz)) {", "originalCommit": "8e73fef7ab57e3a2dcfc5db142f359db0017110d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI2NTE5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r522265192", "bodyText": "added comments", "author": "fengxue-IS", "createdAt": "2020-11-12T17:01:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2ODg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3MDgxMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518870810", "bodyText": "This should TrcAssert in the non OJDK MH case rather than return a nonsense (null) value", "author": "DanHeidinga", "createdAt": "2020-11-06T16:41:23Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1979,6 +2086,54 @@ resolveMethodHandleRef(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpInde\n \n }\n \n+j9object_t\n+resolveInvokeHandle(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n+{\n+\tj9object_t result = NULL;\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tbool canRunJavaCode = J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_REDEFINE_CLASS);\n+\tJ9RAMMethodRef *ramCPEntry = (J9RAMMethodRef*)ramCP + cpIndex;\n+\tUDATA invokeCacheIndex = ramCPEntry->methodIndexAndArgCount >> 8;\n+\tJ9Class *ramClass = J9_CLASS_FROM_CP(ramCP);\n+\tj9object_t *invokeCache = ramClass->invokeCache + invokeCacheIndex;\n+\tresult = *invokeCache;\n+\n+\tif (NULL != result) {\n+\t\treturn result;\n+\t} else if (!canRunJavaCode) {\n+\t\treturn NULL;\n+\t}\n+\n+\tTrc_VM_resolveInvokeHandle_Entry(vmThread, ramCP, cpIndex, resolveFlags);\n+\n+\tJ9ROMMethodRef *romMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n+\tJ9ROMNameAndSignature *nameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n+\n+\t/* Resolve the class. */\n+\tJ9Class *resolvedClass = resolveClassRef(vmThread, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n+\tif (resolvedClass != NULL) {\n+\t\tsendResolveOpenJDKInvokeHandle(vmThread, ramCP, cpIndex, MH_REF_INVOKEVIRTUAL, resolvedClass, nameAndSig);\n+\t\tresult = (j9object_t)vmThread->returnValue;\n+\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\t/* Already a pending exception */\n+\t\t\tresult = NULL;\n+\t\t} else if (result == NULL) {\n+\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t\t} else {\n+\t\t\t/* Only write the value in if it is not null */\n+\t\t\tJ9MemoryManagerFunctions *gcFuncs = vmThread->javaVM->memoryManagerFunctions;\n+\t\t\tif (0 == gcFuncs->j9gc_objaccess_staticCompareAndSwapObject(vmThread, ramClass, invokeCache, NULL, result)) {\n+\t\t\t\t/* Another thread beat this thread to updating the call site, ensure both threads return the same method handle. */\n+\t\t\t\tresult = *invokeCache;\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_VM_resolveInvokeHandle_Exit(vmThread, result);\n+#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */", "originalCommit": "8e73fef7ab57e3a2dcfc5db142f359db0017110d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI2NTYzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r522265631", "bodyText": "added Trc_VM_Assert_ShouldNeverHappen", "author": "fengxue-IS", "createdAt": "2020-11-12T17:02:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3MDgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3NzM3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518877377", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tU_8 nameAndNAS[sizeof(J9ROMNameAndSignature) + (sizeof(U_16) + 16) + sizeof(J9UTF8)];\n          \n          \n            \n            \tU_8 nameAndNAS[sizeof(J9ROMNameAndSignature) + (sizeof(J9UTF8) * 2) + 16];", "author": "DanHeidinga", "createdAt": "2020-11-06T16:52:06Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -496,7 +534,47 @@ resolveStaticMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cp\n \tif (isResolvedClassAnInterface) {\n \t\tlookupOptions |= J9_LOOK_INTERFACE;\n \t}\n-\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef), cpClass, lookupOptions);\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\t/* Stack allocate a byte array for MethodHandle method name and signature. The array size is:\n+\t*  - J9ROMNameAndSignature\n+\t*  - Modified method name\n+\t*      - U_16 for J9UTF8 length\n+\t*      - 16 bytes for the original method name (\"linkToInterface\" is the longest)\n+\t*  - J9UTF8 for empty signature\n+\t*/\n+\tU_8 nameAndNAS[sizeof(J9ROMNameAndSignature) + (sizeof(U_16) + 16) + sizeof(J9UTF8)];", "originalCommit": "8e73fef7ab57e3a2dcfc5db142f359db0017110d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3ODk0OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518878948", "bodyText": "Should this be 15?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t*      - 16 bytes for the original method name (\"linkToInterface\" is the longest)\n          \n          \n            \n            \t*      - 15 bytes for the original method name (\"linkToInterface\" is the longest)", "author": "DanHeidinga", "createdAt": "2020-11-06T16:54:38Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -496,7 +534,47 @@ resolveStaticMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cp\n \tif (isResolvedClassAnInterface) {\n \t\tlookupOptions |= J9_LOOK_INTERFACE;\n \t}\n-\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef), cpClass, lookupOptions);\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\t/* Stack allocate a byte array for MethodHandle method name and signature. The array size is:\n+\t*  - J9ROMNameAndSignature\n+\t*  - Modified method name\n+\t*      - U_16 for J9UTF8 length\n+\t*      - 16 bytes for the original method name (\"linkToInterface\" is the longest)", "originalCommit": "8e73fef7ab57e3a2dcfc5db142f359db0017110d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4NDA3Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518884076", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tU_8 nameAndNAS[sizeof(J9ROMNameAndSignature) + (sizeof(U_16) + 16) + sizeof(J9UTF8)];\n          \n          \n            \n            \tU_8 onStackNAS[sizeof(J9ROMNameAndSignature) + (sizeof(U_16) + 16) + sizeof(J9UTF8)];\n          \n      \n    \n    \n  \n\nnameAndNAS expands to nameAndNameAndSiguture which doesn't make sense.  Better to use the name to indicate why it's special", "author": "DanHeidinga", "createdAt": "2020-11-06T17:03:43Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -496,7 +534,47 @@ resolveStaticMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cp\n \tif (isResolvedClassAnInterface) {\n \t\tlookupOptions |= J9_LOOK_INTERFACE;\n \t}\n-\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef), cpClass, lookupOptions);\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\t/* Stack allocate a byte array for MethodHandle method name and signature. The array size is:\n+\t*  - J9ROMNameAndSignature\n+\t*  - Modified method name\n+\t*      - U_16 for J9UTF8 length\n+\t*      - 16 bytes for the original method name (\"linkToInterface\" is the longest)\n+\t*  - J9UTF8 for empty signature\n+\t*/\n+\tU_8 nameAndNAS[sizeof(J9ROMNameAndSignature) + (sizeof(U_16) + 16) + sizeof(J9UTF8)];", "originalCommit": "8e73fef7ab57e3a2dcfc5db142f359db0017110d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI2NTgzMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r522265830", "bodyText": "fixed", "author": "fengxue-IS", "createdAt": "2020-11-12T17:02:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4NDA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4ODgzOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518888839", "bodyText": "Have you looked at the J9_LOOK_DIRECT_NAS lookupOption?  It allows passing direct pointers which would be much simpler:\nThen the onStackNAS becomes\nU_8 onStackNAS[sizeof(J9NameAndSignature)];\nJ9UTF8 nullSignature = {0};\n\nand the assignment becomes:\nonStackNAS->name = nameAndSig->name;\nonStackNAS->signature = nullSignature;", "author": "DanHeidinga", "createdAt": "2020-11-06T17:12:13Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -496,7 +534,47 @@ resolveStaticMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cp\n \tif (isResolvedClassAnInterface) {\n \t\tlookupOptions |= J9_LOOK_INTERFACE;\n \t}\n-\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef), cpClass, lookupOptions);\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\t/* Stack allocate a byte array for MethodHandle method name and signature. The array size is:\n+\t*  - J9ROMNameAndSignature\n+\t*  - Modified method name\n+\t*      - U_16 for J9UTF8 length\n+\t*      - 16 bytes for the original method name (\"linkToInterface\" is the longest)\n+\t*  - J9UTF8 for empty signature\n+\t*/\n+\tU_8 nameAndNAS[sizeof(J9ROMNameAndSignature) + (sizeof(U_16) + 16) + sizeof(J9UTF8)];\n+\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vmStruct->javaVM)) {\n+\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n+\t\t/**\n+\t\t * Check for MH intrinsic methods\n+\t\t *\n+\t\t * Modify the signature to avoid signature mismatch due to varargs\n+\t\t * These methods have special INL send targets\n+\t\t */\n+\t\tU_8* initialMethodName = J9UTF8_DATA(nameUTF);\n+\t\tU_16 initialMethodNameLength = J9UTF8_LENGTH(nameUTF);\n+\n+\t\tif (isMethodHandleINL(initialMethodName, initialMethodNameLength)) {\n+\t\t\tJ9UTF8 *modifiedMethodName = (J9UTF8 *)(nameAndNAS + sizeof(J9ROMNameAndSignature));\n+\t\t\tJ9UTF8 *modifiedMethodSig = (J9UTF8 *)(nameAndNAS + sizeof(nameAndNAS) - sizeof(J9UTF8));\n+\t\t\tmemset(nameAndNAS, 0, sizeof(nameAndNAS));\n+\n+\t\t\t/* Create new J9ROMNameAndSignature */\n+\t\t\tnameAndSig = (J9ROMNameAndSignature *)nameAndNAS;\n+\t\t\tNNSRP_SET(nameAndSig->name, modifiedMethodName);\n+\t\t\tNNSRP_SET(nameAndSig->signature, modifiedMethodSig);\n+\n+\t\t\tmodifiedMethodName->length = initialMethodNameLength;\n+\t\t\tmemcpy(modifiedMethodName->data, initialMethodName, initialMethodNameLength);\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;", "originalCommit": "8e73fef7ab57e3a2dcfc5db142f359db0017110d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5MDE1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r518890155", "bodyText": "Similar comment applies here as well about using DIRECT option.\nAlso, names like \"modifiedX\" should in some way, modify X.  Otherwise the code is confusing", "author": "DanHeidinga", "createdAt": "2020-11-06T17:14:35Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1368,18 +1446,46 @@ resolveVirtualMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA c\n \t\t\tcpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass);\n \t\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n \t\t}\n-\t\t\n-#if defined(J9VM_OPT_METHOD_HANDLE)\n-\t\t/*\n-\t\t * Check for MH.invoke and MH.invokeExact.\n-\t\t *\n-\t\t * Methodrefs corresponding to those methods already have their methodIndex set to index into\n-\t\t * cpClass->methodTypes. We resolve them by calling into MethodType.fromMethodDescriptorString()\n-\t\t * and storing the result into the cpClass->methodTypes table.\n-\t\t */\n+\n+#if defined(J9VM_OPT_METHOD_HANDLE) || defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n \t\tif ((NULL != cpShapeDescription)\n \t\t&& (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vm))\n \t\t) {\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\t\t\t/**\n+\t\t\t * Check for MH intrinsic methods\n+\t\t\t *\n+\t\t\t * Modify the signature to avoid signature mismatch due to varargs\n+\t\t\t * These methods have special INL send targets\n+\t\t\t */\n+\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n+\t\t\tU_8* initialMethodName = J9UTF8_DATA(nameUTF);\n+\t\t\tU_16 initialMethodNameLength = J9UTF8_LENGTH(nameUTF);\n+\n+\t\t\tif (isMethodHandleINL(initialMethodName, initialMethodNameLength)) {\n+\t\t\t\tJ9UTF8 *modifiedMethodName = (J9UTF8 *)(nameAndNAS + sizeof(J9ROMNameAndSignature));\n+\t\t\t\tJ9UTF8 *modifiedMethodSig = (J9UTF8 *)(nameAndNAS + sizeof(nameAndNAS) - sizeof(J9UTF8));\n+\t\t\t\tmemset(nameAndNAS, 0, sizeof(nameAndNAS));\n+\n+\t\t\t\t/* Create new J9ROMNameAndSignature */\n+\t\t\t\tnameAndSig = (J9ROMNameAndSignature *)nameAndNAS;\n+\t\t\t\tNNSRP_SET(nameAndSig->name, modifiedMethodName);\n+\t\t\t\tNNSRP_SET(nameAndSig->signature, modifiedMethodSig);\n+\n+\t\t\t\tmodifiedMethodName->length = initialMethodNameLength;\n+\t\t\t\tmemcpy(modifiedMethodName->data, initialMethodName, initialMethodNameLength);\n+\n+\t\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */", "originalCommit": "8e73fef7ab57e3a2dcfc5db142f359db0017110d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA5NTAwOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r519095009", "bodyText": "JIT expects this helper to return the address of the entry, not the content of the entry. See the current implementation.", "author": "liqunl", "createdAt": "2020-11-07T03:48:28Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -2325,6 +2325,26 @@ old_slow_jitResolveHandleMethod(J9VMThread *currentThread)\n \tDECLARE_JIT_PARM(void*, jitEIP, 3);\n \tvoid *addr = NULL;\n \tJ9JavaVM *vm = currentThread->javaVM;\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef*)ramConstantPool) + cpIndex;\n+\tUDATA invokeCacheIndex = ramMethodRef->methodIndexAndArgCount >> 8;\n+retry:\n+\tj9object_t invokeCacheArray = (J9_CLASS_FROM_CP(ramConstantPool)->invokeCache)[invokeCacheIndex];\n+\tif (NULL == invokeCacheArray) {\n+\t\tbuildJITResolveFrameWithPC(currentThread, J9_SSF_JIT_RESOLVE_DATA, parmCount, true, 0, jitEIP);\n+\t\t/* add new resolve code which calls sendResolveInvokeHandle -> MHN.linkMethod()\n+\t\t * store the memberName/appendix values in invokeCache[invokeCacheIndex]\n+\t\t */\n+\t\tvm->internalVMFunctions->resolveInvokeHandle(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\taddr = restoreJITResolveFrame(currentThread, jitEIP);\n+\t\tif (NULL != addr) {\n+\t\t\tgoto done;\n+\t\t}\n+\t\tgoto retry;\n+\t}\n+\tJIT_RETURN_UDATA(invokeCacheArray);", "originalCommit": "8e73fef7ab57e3a2dcfc5db142f359db0017110d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI2NjA0Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r522266042", "bodyText": "fixed", "author": "fengxue-IS", "createdAt": "2020-11-12T17:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA5NTAwOQ=="}], "type": "inlineReview"}, {"oid": "391f18782ef6e527650df5ea53b59748555d082e", "url": "https://github.com/eclipse-openj9/openj9/commit/391f18782ef6e527650df5ea53b59748555d082e", "message": "Add tracepoints for invokeHandle and invokeDynamic resolution\n\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-11-12T16:53:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzOTc2MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r522339760", "bodyText": "Does this need to be indented 1 more level to match the surrounding code?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tTrc_VM_Assert_ShouldNeverHappen();\n          \n          \n            \n            \t\tTrc_VM_Assert_ShouldNeverHappen();", "author": "DanHeidinga", "createdAt": "2020-11-12T18:54:07Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1611,7 +1700,9 @@ resolveVirtualMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA c\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n+#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\tTrc_VM_Assert_ShouldNeverHappen();", "originalCommit": "391f18782ef6e527650df5ea53b59748555d082e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0MDI4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r522340288", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tresult = *invokeCache;\n          \n          \n            \n            \tj9object_t result = *invokeCache;", "author": "DanHeidinga", "createdAt": "2020-11-12T18:54:56Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -1979,6 +2070,55 @@ resolveMethodHandleRef(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpInde\n \n }\n \n+j9object_t\n+resolveOpenJDKInvokeHandle(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n+{\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tj9object_t result = NULL;\n+\tbool canRunJavaCode = J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_REDEFINE_CLASS);\n+\tJ9RAMMethodRef *ramCPEntry = (J9RAMMethodRef*)ramCP + cpIndex;\n+\tUDATA invokeCacheIndex = ramCPEntry->methodIndexAndArgCount >> 8;\n+\tJ9Class *ramClass = J9_CLASS_FROM_CP(ramCP);\n+\tj9object_t *invokeCache = ramClass->invokeCache + invokeCacheIndex;\n+\tresult = *invokeCache;", "originalCommit": "391f18782ef6e527650df5ea53b59748555d082e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0MDY3MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r522340671", "bodyText": "Declare the local here and it only has 1 value - no need to reason about where the original NULL leaks to", "author": "DanHeidinga", "createdAt": "2020-11-12T18:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0MDI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0Mzk0Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10893#discussion_r522343947", "bodyText": "Is there a } missing here?  The indentation doesn't match the if (NULL == result) { statement.", "author": "DanHeidinga", "createdAt": "2020-11-12T19:01:10Z", "path": "runtime/vm/resolvesupport.cpp", "diffHunk": "@@ -2100,61 +2240,81 @@ resolveConstantDynamic(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpInde\n \treturn value;\n }\n \n-j9object_t   \n+j9object_t\n resolveInvokeDynamic(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA callSiteIndex, UDATA resolveFlags)\n {\n \tAssert_VM_true(J9_RESOLVE_FLAG_RUNTIME_RESOLVE == resolveFlags);\n \tj9object_t *callSite = ramCP->ramClass->callSites + callSiteIndex;\n-\tj9object_t methodHandle = *callSite;\n+\tj9object_t result = *callSite;\n \n \tJ9ROMClass *romClass = ramCP->ramClass->romClass;\n \tJ9SRP *callSiteData = (J9SRP *) J9ROMCLASS_CALLSITEDATA(romClass);\n \tU_16 *bsmIndices = (U_16 *) (callSiteData + romClass->callSiteCount);\n \tU_16 *bsmData = bsmIndices + romClass->callSiteCount;\n \tJ9ROMNameAndSignature* nameAndSig = SRP_PTR_GET(callSiteData + callSiteIndex, J9ROMNameAndSignature*);\n \tU_16 bsmIndex = bsmIndices[callSiteIndex];\n-\tU_16 i;\n+\tU_16 i = 0;\n+\n+\tTrc_VM_resolveInvokeDynamic_Entry(vmThread, callSiteIndex, bsmIndex, resolveFlags);\n \n \t/* Check if already resolved */\n-\tif (methodHandle != NULL) {\n-\t\treturn methodHandle;\n-\t}\n+\tif (NULL == result) {\n+\t\t/* Walk bsmData - skip all bootstrap methods before bsmIndex */\n+\t\tfor (i = 0; i < bsmIndex; i++) {\n+\t\t\t/* increment by size of bsm data plus header */\n+\t\t\tbsmData += bsmData[1] + 2;\n+\t\t}\n \n-\t/* Walk bsmData - skip all bootstrap methods before bsmIndex */\n-\tfor (i = 0; i < bsmIndex; i++) {\n-\t\t/* increment by size of bsm data plus header */\n-\t\tbsmData += bsmData[1] + 2;\n-\t}\n+\t\tsendResolveInvokeDynamic(vmThread, ramCP, callSiteIndex, nameAndSig, bsmData);\n+\t\tresult = (j9object_t) vmThread->returnValue;\n \n-\tsendResolveInvokeDynamic(vmThread, ramCP, callSiteIndex, nameAndSig, bsmData);\n-\tmethodHandle = (j9object_t) vmThread->returnValue;\n+\t\tTrc_VM_resolveInvokeDynamic_Resolved(vmThread, callSiteIndex, result);\n \n-\t/* check if an exception is already pending */\n-\tif (vmThread->currentException != NULL) {\n-\t\t/* Already a pending exception */\n-\t\tmethodHandle = NULL;\n-\t} else if (methodHandle == NULL) {\n-\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n-\t}\n-\n-\t/* Only write the value in if its not null */\n-\tif (NULL != methodHandle) {\n-\t\tJ9MemoryManagerFunctions *gcFuncs = vmThread->javaVM->memoryManagerFunctions;\n-\t\tmethodHandle = gcFuncs->j9gc_objaccess_asConstantPoolObject(\n-\t\t\t\t\t\t\t\t\tvmThread,\n-\t\t\t\t\t\t\t\t\tmethodHandle,\n-\t\t\t\t\t\t\t\t\tJ9_GC_ALLOCATE_OBJECT_TENURED | J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE | J9_GC_ALLOCATE_OBJECT_HASHED);\n-\n-\t\tif (NULL == methodHandle) {\n-\t\t\tsetHeapOutOfMemoryError(vmThread);\n-\t\t} else {\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\t\t/* Check if an exception is already pending */\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\t/* Already a pending exception */\n+\t\t\tresult = vmThread->currentException;\n+\t\t} else if (result == NULL) {\n+\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t\t} else { /* (result != NULL) */\n+\t\t\t/* Only write the value in if it is not null */\n+\t\t\tJ9MemoryManagerFunctions *gcFuncs = vmThread->javaVM->memoryManagerFunctions;\n \t\t\tJ9Class *j9class = J9_CLASS_FROM_CP(ramCP);\n-\t\t\tif (0 == gcFuncs->j9gc_objaccess_staticCompareAndSwapObject(vmThread, j9class, callSite, NULL, methodHandle)) {\n+\n+\t\t\t/* Ensure that result array elements are written before the array reference is stored */\n+\t\t\tVM_AtomicSupport::writeBarrier();\n+\t\t\tif (0 == gcFuncs->j9gc_objaccess_staticCompareAndSwapObject(vmThread, j9class, callSite, NULL, result)) {\n \t\t\t\t/* Another thread beat this thread to updating the call site, ensure both threads return the same method handle. */\n-\t\t\t\tmethodHandle = *callSite;\n+\t\t\t\tresult = *callSite;\n \t\t\t}\n \t\t}\n-\t}\n-\n-\treturn methodHandle;\n+#else /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n+\t\t/* Check if an exception is already pending */\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\t/* Already a pending exception */\n+\t\t\tresult = NULL;\n+\t\t} else if (result == NULL) {\n+\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t\t} else { /* (result != NULL) */\n+\t\t\t/* Only write the value in if it is not null */\n+\t\t\tJ9MemoryManagerFunctions *gcFuncs = vmThread->javaVM->memoryManagerFunctions;\n+\t\t\tresult = gcFuncs->j9gc_objaccess_asConstantPoolObject(\n+\t\t\t\t\t\t\t\t\t\tvmThread,\n+\t\t\t\t\t\t\t\t\t\tresult,\n+\t\t\t\t\t\t\t\t\t\tJ9_GC_ALLOCATE_OBJECT_TENURED | J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE | J9_GC_ALLOCATE_OBJECT_HASHED);\n+\n+\t\t\tif (NULL == result) {\n+\t\t\t\tsetHeapOutOfMemoryError(vmThread);\n+\t\t\t} else {\n+\t\t\t\tJ9Class *j9class = J9_CLASS_FROM_CP(ramCP);\n+\t\t\t\tif (0 == gcFuncs->j9gc_objaccess_staticCompareAndSwapObject(vmThread, j9class, callSite, NULL, result)) {\n+\t\t\t\t\t/* Another thread beat this thread to updating the call site, ensure both threads return the same method handle. */\n+\t\t\t\t\tresult = *callSite;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}", "originalCommit": "391f18782ef6e527650df5ea53b59748555d082e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a7cc768a1ab63a639b9f5212e43febbdf05beef1", "url": "https://github.com/eclipse-openj9/openj9/commit/a7cc768a1ab63a639b9f5212e43febbdf05beef1", "message": "Add tracepoints for invokeHandle and invokeDynamic resolution\n\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-11-12T19:13:17Z", "type": "forcePushed"}, {"oid": "955d40f122d5a2af521ca2223a4831f22c79f62c", "url": "https://github.com/eclipse-openj9/openj9/commit/955d40f122d5a2af521ca2223a4831f22c79f62c", "message": "Add tracepoints for invokeHandle and invokeDynamic resolution\n\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-11-12T21:03:10Z", "type": "forcePushed"}, {"oid": "2a3dd878e6060f6be8f2bcb44fae751db3931bdc", "url": "https://github.com/eclipse-openj9/openj9/commit/2a3dd878e6060f6be8f2bcb44fae751db3931bdc", "message": "Add tracepoints for invokeHandle and invokeDynamic resolution\n\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-11-12T21:04:43Z", "type": "forcePushed"}, {"oid": "2fb187312397401724e6d6c43489c4e8c04ade97", "url": "https://github.com/eclipse-openj9/openj9/commit/2fb187312397401724e6d6c43489c4e8c04ade97", "message": "Rename methodTypes table to invokeCache table\n\nCo-authored-by: Babneet Singh <sbabneet@ca.ibm.com>\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-11-13T16:47:23Z", "type": "commit"}, {"oid": "6913db2003f521bd2f39af1974aef9125331391f", "url": "https://github.com/eclipse-openj9/openj9/commit/6913db2003f521bd2f39af1974aef9125331391f", "message": "Update resolve code to support OpenJDK MH\n\n- new sendResolveOpenJDKInvokeHandle\n- new resolveOpenJDKInvokeHandle\n- update resolveInvokeDynamic\n- update resolveVirtualMethodRefInto\n- update resolveStaticMethodRefInto\n\nCo-authored-by: Babneet Singh <sbabneet@ca.ibm.com>\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-11-13T16:48:15Z", "type": "commit"}, {"oid": "5eca3dd5d536d1c13fd4cf50c73b7486d0779db8", "url": "https://github.com/eclipse-openj9/openj9/commit/5eca3dd5d536d1c13fd4cf50c73b7486d0779db8", "message": "Update BytecodeInterpreter to support OpenJDK MH\n\nModify Interpreter code to support the new single slot design\n\nCo-authored-by: Babneet Singh <sbabneet@ca.ibm.com>\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-11-13T16:48:15Z", "type": "commit"}, {"oid": "64534a78c389ce079353f05bebefe3e439ff5e77", "url": "https://github.com/eclipse-openj9/openj9/commit/64534a78c389ce079353f05bebefe3e439ff5e77", "message": "Update JIT helper to support OpenJDK MH\n\n- update old_slow_jitResolveHandleMethod\n\nCo-authored-by: Babneet Singh <sbabneet@ca.ibm.com>\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-11-13T16:48:15Z", "type": "commit"}, {"oid": "1a9fb65bc8c4b711c94d3fa2687365200cd06cb3", "url": "https://github.com/eclipse-openj9/openj9/commit/1a9fb65bc8c4b711c94d3fa2687365200cd06cb3", "message": "Add tracepoints for invokeHandle and invokeDynamic resolution\n\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-11-13T16:48:15Z", "type": "commit"}, {"oid": "1a9fb65bc8c4b711c94d3fa2687365200cd06cb3", "url": "https://github.com/eclipse-openj9/openj9/commit/1a9fb65bc8c4b711c94d3fa2687365200cd06cb3", "message": "Add tracepoints for invokeHandle and invokeDynamic resolution\n\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-11-13T16:48:15Z", "type": "forcePushed"}]}