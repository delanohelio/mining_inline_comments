{"pr_number": 9074, "pr_title": "Add FlattenedArrayObjectScanner", "pr_createdAt": "2020-04-01T18:59:18Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9074", "timeline": [{"oid": "448e19ab08c84f8b0ab136119d36761a71fb66fd", "url": "https://github.com/eclipse-openj9/openj9/commit/448e19ab08c84f8b0ab136119d36761a71fb66fd", "message": "Add FlattenedArrayObjectSCanner\n\n- Use flattened size when iterating flattened arrays\n- Use object ptr in Mixed and Reference scanner constructors\n\nSigned-off-by: Andrew Young <youngar17@gmail.com>", "committedDate": "2020-04-01T19:01:27Z", "type": "forcePushed"}, {"oid": "bef5fb3e365d0c73250c6292a9721584ad2b40c4", "url": "https://github.com/eclipse-openj9/openj9/commit/bef5fb3e365d0c73250c6292a9721584ad2b40c4", "message": "Add FlattenedArrayObjectSCanner\n\n- Use flattened size when iterating flattened arrays\n- Use object ptr in Mixed and Reference scanner constructors\n\nSigned-off-by: Andrew Young <youngar17@gmail.com>", "committedDate": "2020-04-01T19:22:43Z", "type": "forcePushed"}, {"oid": "97ef6d7b24f7c1ae8407f22cad612f70c92883b5", "url": "https://github.com/eclipse-openj9/openj9/commit/97ef6d7b24f7c1ae8407f22cad612f70c92883b5", "message": "Add FlattenedArrayObjectScanner\n\n- Use flattened size when iterating flattened arrays\n- Use object ptr in Mixed and Reference scanner constructors\n\nSigned-off-by: Andrew Young <youngar17@gmail.com>", "committedDate": "2020-04-01T19:34:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2Mjk1OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401862959", "bodyText": "Unfortunately with compressed/full selection runtime we can not use fomrobject_t * pointer math directly any more. Please use GC_SlotObject::addToSlotAddress() (in this case) instead. See examples in ObjectScanner.hpp and other scanners source code.", "author": "dmitripivkine", "createdAt": "2020-04-01T19:39:49Z", "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);", "originalCommit": "97ef6d7b24f7c1ae8407f22cad612f70c92883b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3MDk3OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401870979", "bodyText": "I'm not sure if that is correct. This is adding the total size in bytes of the object, which should be correct no matter if we're compressed or not.", "author": "youngar", "createdAt": "2020-04-01T19:54:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2Mjk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg4MzkxNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401883914", "bodyText": "Right. I put this comment wrong place when re-do it after refresh, sorry. I intended to put it for line 147. However I am not sure line 147 is correct - (splitAmount * elementStride) is in bytes but added to pointer. Anyway, any (if any)fomrobject_t * pointer math in this PR should support runtime compressed/full selection", "author": "dmitripivkine", "createdAt": "2020-04-01T20:18:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2Mjk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg4NzI5OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401887299", "bodyText": "formatting: please add spaces around multiplication sign *", "author": "dmitripivkine", "createdAt": "2020-04-01T20:24:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2Mjk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5MjcxMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401892710", "bodyText": "Should I wrap it in brackets, like this?\n(fomrobject_t *)((uintptr_t)basePtr + (startIndex * elementStride));", "author": "youngar", "createdAt": "2020-04-01T20:34:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2Mjk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NzkyOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401897928", "bodyText": "Yes, please. I like it", "author": "dmitripivkine", "createdAt": "2020-04-01T20:44:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2Mjk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NTE0NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401975145", "bodyText": "Fixed!", "author": "youngar", "createdAt": "2020-04-01T23:50:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2Mjk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg4Njk3Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401886972", "bodyText": "Good catch Dmitri\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tendPtr = scanPtr + (splitAmount * elementStride);\n          \n          \n            \n            \t\t\tendPtr = (fomrobject_t *)((uintptr_t)scanPtr + splitAmount*elementStride);", "author": "youngar", "createdAt": "2020-04-01T20:23:32Z", "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);\n+\t\tfomrobject_t *endPtr = limitPtr;\n+\t\tif (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {\n+\t\t\tAssert_MM_unreachable();\n+\t\t\tendPtr = scanPtr + (splitAmount * elementStride);", "originalCommit": "97ef6d7b24f7c1ae8407f22cad612f70c92883b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NTM1Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401975357", "bodyText": "Fixed in the PR, I didn't use the automatic github commit.", "author": "youngar", "createdAt": "2020-04-01T23:51:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg4Njk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5Mjc3MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401892771", "bodyText": "formatting: please add spaces around multiplication sign * : splitAmount * elementStride - here and a few other places", "author": "dmitripivkine", "createdAt": "2020-04-01T20:34:43Z", "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);\n+\t\tfomrobject_t *endPtr = limitPtr;\n+\t\tif (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {\n+\t\t\tAssert_MM_unreachable();\n+\t\t\tendPtr = (fomrobject_t *)((uintptr_t)scanPtr + splitAmount*elementStride);", "originalCommit": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NTUxNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401895517", "bodyText": "Is there a reason to cast to (uint8_t *)? There is cast to (uintptr_t) used everywhere. However if you want to keep (uint8_t *) - formatting: please add space between uint8_t and *", "author": "dmitripivkine", "createdAt": "2020-04-01T20:39:56Z", "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);\n+\t\tfomrobject_t *endPtr = limitPtr;\n+\t\tif (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {\n+\t\t\tAssert_MM_unreachable();\n+\t\t\tendPtr = (fomrobject_t *)((uintptr_t)scanPtr + splitAmount*elementStride);\n+\t\t\tif (endPtr > limitPtr) {\n+\t\t\t\tendPtr = limitPtr;\n+\t\t\t}\n+\t\t}\n+\t\tuintptr_t *instanceDescription = elementClass->instanceDescription;\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tuintptr_t *leafDescription = elementClass->instanceLeafDescription;\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, leafDescription, flags);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, flags);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\tobjectScanner->initialize(env);\n+\t\tif (0 != startIndex) {\n+\t\t\tobjectScanner->clearHeadObjectScanner();\n+\t\t}\n+\t\treturn objectScanner;\n+\t}\n+\n+\tMMINLINE uintptr_t getBytesRemaining() { return sizeof(fomrobject_t) * (_endPtr - _scanPtr); }\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param splitAmount The maximum number of array elements to include\n+\t * @return Pointer to split scanner in allocSpace\n+\t */\n+\tGC_IndexableObjectScanner *\n+\tsplitTo(MM_EnvironmentBase *env, void *allocSpace, uintptr_t splitAmount)\n+\t{\n+\t\tAssert_MM_unimplemented();\n+\t}\n+\n+\t/**\n+\t * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The\n+\t * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of\n+\t * increasing significance, and the least significant bit maps to the slot at the returned\n+\t * base pointer.\n+\t *\n+\t * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last\n+\t * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots\n+\t */\n+\tvirtual fomrobject_t *\n+\tgetNextSlotMap(uintptr_t *slotMap, bool *hasNextSlotMap)\n+\t{\n+\t\tfomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, hasNextSlotMap);\n+\t\t/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */\n+\t\t*hasNextSlotMap = true;\n+\t\tif (result == NULL) {\n+\t\t\t/* No more slots in the current element, get the next element of the array */\n+\t\t\tresult = _indexableScanner.nextIndexableElement();\n+\t\t\tif (result == NULL) {\n+\t\t\t\t/* There are no elements in the array */\n+\t\t\t\t*hasNextSlotMap = false;\n+\t\t\t} else {\n+\t\t\t\t_mapPtr = result;\n+\t\t\t\t_endPtr = (fomrobject_t *)((uint8_t*)_mapPtr + _elementSizeWithoutPadding);", "originalCommit": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NjI4NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401896284", "bodyText": "I'll cast to uintptr_t instead", "author": "youngar", "createdAt": "2020-04-01T20:41:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NTUxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NTQyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401975422", "bodyText": "Fixed", "author": "youngar", "createdAt": "2020-04-01T23:51:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NTUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NjYzOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401896639", "bodyText": "Same as above - change cast to (uintptr_t) or add space", "author": "dmitripivkine", "createdAt": "2020-04-01T20:42:06Z", "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);\n+\t\tfomrobject_t *endPtr = limitPtr;\n+\t\tif (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {\n+\t\t\tAssert_MM_unreachable();\n+\t\t\tendPtr = (fomrobject_t *)((uintptr_t)scanPtr + splitAmount*elementStride);\n+\t\t\tif (endPtr > limitPtr) {\n+\t\t\t\tendPtr = limitPtr;\n+\t\t\t}\n+\t\t}\n+\t\tuintptr_t *instanceDescription = elementClass->instanceDescription;\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tuintptr_t *leafDescription = elementClass->instanceLeafDescription;\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, leafDescription, flags);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, flags);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\tobjectScanner->initialize(env);\n+\t\tif (0 != startIndex) {\n+\t\t\tobjectScanner->clearHeadObjectScanner();\n+\t\t}\n+\t\treturn objectScanner;\n+\t}\n+\n+\tMMINLINE uintptr_t getBytesRemaining() { return sizeof(fomrobject_t) * (_endPtr - _scanPtr); }\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param splitAmount The maximum number of array elements to include\n+\t * @return Pointer to split scanner in allocSpace\n+\t */\n+\tGC_IndexableObjectScanner *\n+\tsplitTo(MM_EnvironmentBase *env, void *allocSpace, uintptr_t splitAmount)\n+\t{\n+\t\tAssert_MM_unimplemented();\n+\t}\n+\n+\t/**\n+\t * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The\n+\t * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of\n+\t * increasing significance, and the least significant bit maps to the slot at the returned\n+\t * base pointer.\n+\t *\n+\t * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last\n+\t * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots\n+\t */\n+\tvirtual fomrobject_t *\n+\tgetNextSlotMap(uintptr_t *slotMap, bool *hasNextSlotMap)\n+\t{\n+\t\tfomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, hasNextSlotMap);\n+\t\t/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */\n+\t\t*hasNextSlotMap = true;\n+\t\tif (result == NULL) {\n+\t\t\t/* No more slots in the current element, get the next element of the array */\n+\t\t\tresult = _indexableScanner.nextIndexableElement();\n+\t\t\tif (result == NULL) {\n+\t\t\t\t/* There are no elements in the array */\n+\t\t\t\t*hasNextSlotMap = false;\n+\t\t\t} else {\n+\t\t\t\t_mapPtr = result;\n+\t\t\t\t_endPtr = (fomrobject_t *)((uint8_t*)_mapPtr + _elementSizeWithoutPadding);\n+\t\t\t\tGC_HeadlessMixedObjectScanner::initialize(_env, _descriptionBasePtr, _leafBasePtr);\n+\t\t\t\t/* GC_HeadlessMixedObjectScanner::initialize() may setNoMoreSlots(), so set it back to true. \n+\t\t\t\t * We must also return (hasNextSlotMap = true) on top of this\n+\t\t\t\t */\n+\t\t\t\tsetMoreSlots();\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+#if defined(OMR_GC_LEAF_BITS)\n+\t/**\n+\t * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The\n+\t * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of\n+\t * increasing significance, and the least significant bit maps to the slot at the returned\n+\t * base pointer.\n+\t *\n+\t * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] leafMap the leaf bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last\n+\t * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots\n+\t */\n+\tvirtual fomrobject_t *\n+\tgetNextSlotMap(uintptr_t *slotMap, uintptr_t *leafMap, bool *hasNextSlotMap)\n+\t{\n+\t\tfomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, leafMap, hasNextSlotMap);\n+\t\t/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */\n+\t\t*hasNextSlotMap = true;\n+\t\tif (result == NULL) {\n+\t\t\t/* No more slots in the current element, get the next element of the array */\n+\t\t\tresult = _indexableScanner.nextIndexableElement();\n+\t\t\tif (result == NULL) {\n+\t\t\t\t/* There are no elements in the array */\n+\t\t\t\t*hasNextSlotMap = false;\n+\t\t\t} else {\n+\t\t\t\t_mapPtr = result;\n+\t\t\t\t_endPtr = (fomrobject_t *)((uint8_t*)_mapPtr + _elementSizeWithoutPadding);", "originalCommit": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NTQ4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401975488", "bodyText": "Fixed", "author": "youngar", "createdAt": "2020-04-01T23:51:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NjYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5OTk1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401899955", "bodyText": "Same as above - change cast to (uintptr_t) or add space", "author": "dmitripivkine", "createdAt": "2020-04-01T20:48:27Z", "path": "runtime/gc_glue_java/HeadlessMixedObjectScanner.hpp", "diffHunk": "@@ -51,13 +51,14 @@ class GC_HeadlessMixedObjectScanner : public GC_ObjectScanner\n \n \t/**\n \t * @param env The scanning thread environment\n-\t * @param[in] objectPtr the object to be processed\n-\t * @param[in] flags Scanning context flags\n+\t * @param scanPtr Pointer to the start of the object\n+\t * @param size The instance size\n+\t * @param flags Scanning context flags\n \t */\n-\tMMINLINE GC_HeadlessMixedObjectScanner(MM_EnvironmentBase *env, J9Class *clazzPtr, fomrobject_t *scanPtr, uintptr_t flags)\n+\tMMINLINE GC_HeadlessMixedObjectScanner(MM_EnvironmentBase *env, fomrobject_t *scanPtr, uintptr_t size, uintptr_t flags)\n \t\t: GC_ObjectScanner(env, scanPtr, 0, flags)\n-\t\t, _endPtr((fomrobject_t *)((uint8_t*)_scanPtr + env->getExtensions()->mixedObjectModel.getSizeInBytesWithoutHeader(clazzPtr)))\n-\t\t, _mapPtr(_scanPtr)\n+\t\t, _endPtr((fomrobject_t *)((uint8_t*)scanPtr + size))", "originalCommit": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkwMTE1NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401901154", "bodyText": "this change is not necessary", "author": "dmitripivkine", "createdAt": "2020-04-01T20:50:43Z", "path": "runtime/gc_glue_java/MixedObjectScanner.hpp", "diffHunk": "@@ -41,7 +41,7 @@\n class GC_MixedObjectScanner : public GC_HeadlessMixedObjectScanner\n {\n \n-\t/* Data Members */\n+\t\t/* Data Members */", "originalCommit": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkwMzMyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401903322", "bodyText": "I guess typo. Should it be /* megaObject */ ?", "author": "dmitripivkine", "createdAt": "2020-04-01T20:54:54Z", "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "diffHunk": "@@ -107,6 +107,9 @@\n \tstatic Class largeObjectValueClass = null;\n \tstatic MethodHandle makeLargeObjectValue = null;\n \tstatic MethodHandle[] getObjects = null;\n+\t/* megeObject */", "originalCommit": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxNDA3MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401914070", "bodyText": "you can use checkFieldAccessMHOfAssortedType to verify that what you are getting back is the correct thing", "author": "tajila", "createdAt": "2020-04-01T21:15:31Z", "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "diffHunk": "@@ -252,6 +255,71 @@ static public void testCreateArrayPoint2D() throws Throwable {\n \t\tassertEquals(getY.invoke(point2D_2_check), getY.invoke(point2D_2));\n \t}\n \n+\t@Test(priority=5)\n+\tstatic public void testGCFlattenedPoint2DArray() throws Throwable {\n+\t\tint x1 = 0xFFEEFFEE;\n+\t\tint y1 = 0xAABBAABB;\n+\t\tObject point2D = makePoint2D.invoke(x1, y1);\n+\t\tObject arrayObject = Array.newInstance(point2DClass, 8);\n+\n+\t\tfor (int i = 1; i < 8; i++) {\n+\t\t\tArray.set(arrayObject, i, point2D);\n+\t\t}\n+\n+\t\tSystem.gc();\n+\t\tSystem.gc();\n+\n+\t\tObject value = Array.get(arrayObject, 0);\n+\t}\n+\n+\t@Test(priority=5)\n+\tstatic public void testGCFlattenedAssortedValueArray() throws Throwable {\n+\t\tObject arrayObject = Array.newInstance(assortedValueWithLongAlignmentClass, 4);\n+\t\tObject assortedValueWithLongAlignment = createAssorted(makeAssortedValueWithLongAlignment, typeWithLongAlignmentFields);\n+\n+\t\tfor (int i = 1; i < 4; i++) {\n+\t\t\tArray.set(arrayObject, i, assortedValueWithLongAlignment);\n+\t\t}\n+\n+\t\tSystem.gc();\n+\t\tSystem.gc();\n+\n+\t\tObject value = Array.get(arrayObject, 0);", "originalCommit": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NzY0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401977643", "bodyText": "I added tests so now we're doing all three singleAlignment, objectAlignment, and longAlignment.  The tests are now using checkFieldAccessMHOfAssortedType on each array element.", "author": "youngar", "createdAt": "2020-04-01T23:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxNDA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxNjE3Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401916172", "bodyText": "For this test we want to see whether the GC will scan the default value on the J9Class (see https://github.com/eclipse/openj9/blob/master/runtime/gc_structs/ValueTypesIterator.hpp#L69), we know this is tested with a big number (200000) does it still exercise that path with 200?", "author": "tajila", "createdAt": "2020-04-01T21:19:52Z", "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "diffHunk": "@@ -1402,7 +1471,7 @@ static public void testStaticFieldsWithObjectAlignment() throws Throwable {\n \tstatic public void testCreateLargeNumberOfPoint2D() throws Throwable {\n \t\tString fields[] = {\"x:I\", \"y:I\"};\n \t\tString className = \"Point2D\";\n-\t\tfor (int valueIndex = 0; valueIndex < 200000; valueIndex++) {\n+\t\tfor (int valueIndex = 0; valueIndex < 200; valueIndex++) {", "originalCommit": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkyOTk1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401929951", "bodyText": "This was accidentally added, the tests were simply taking too long.  Thanks for pointing it out.  Could we switch this test to call System.gc()?", "author": "youngar", "createdAt": "2020-04-01T21:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxNjE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3ODEwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401978107", "bodyText": "I just switched back the number for now.", "author": "youngar", "createdAt": "2020-04-02T00:00:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxNjE3Mg=="}], "type": "inlineReview"}, {"oid": "e13901880b00fda8b174cf21e6ac2c4720be0e71", "url": "https://github.com/eclipse-openj9/openj9/commit/e13901880b00fda8b174cf21e6ac2c4720be0e71", "message": "Add more value type array tests\n\n- Add tests for all assorted value alignment types\n- Make sure tests are validating after a GC\n\nSigned-off-by: Andrew Young <youngar17@gmail.com>", "committedDate": "2020-04-01T23:46:57Z", "type": "forcePushed"}, {"oid": "b67b1ebd85e5006e0a034c5f0c30981445e58d72", "url": "https://github.com/eclipse-openj9/openj9/commit/b67b1ebd85e5006e0a034c5f0c30981445e58d72", "message": "Add more value type array tests\n\n- Add tests for all assorted value alignment types\n- Make sure tests are validating after a GC\n\nSigned-off-by: Andrew Young <youngar17@gmail.com>", "committedDate": "2020-04-01T23:50:00Z", "type": "forcePushed"}, {"oid": "f41926821736c594ddc7b61143e219a85f5e8730", "url": "https://github.com/eclipse-openj9/openj9/commit/f41926821736c594ddc7b61143e219a85f5e8730", "message": "Add more value type array tests\n\n- Add tests for all assorted value alignment types\n- Make sure tests are validating after a GC\n\nSigned-off-by: Andrew Young <youngar17@gmail.com>", "committedDate": "2020-04-02T00:01:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3ODkzOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401978939", "bodyText": "@tajila I think it makes sense to enable the GC as a separate variation.  It may help track down if the issue is GC specific. What do you think?", "author": "youngar", "createdAt": "2020-04-02T00:03:11Z", "path": "test/functional/Valhalla/playlist.xml", "diffHunk": "@@ -27,6 +27,7 @@\n \t\t<variations>\n \t\t\t<variation>NoOptions</variation>\n \t\t\t<variation>-Xgcpolicy:nogc -XX:ValueTypeFlatteningThreshold=99999</variation>\n+\t\t\t<variation>-Xgcpolicy:optthruput -Xnocompactgc -XX:ValueTypeFlatteningThreshold=99999</variation>", "originalCommit": "f41926821736c594ddc7b61143e219a85f5e8730", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3OTkzMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401979930", "bodyText": "that sounds good", "author": "tajila", "createdAt": "2020-04-02T00:06:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3ODkzOQ=="}], "type": "inlineReview"}, {"oid": "07755f7fa4775348a9c8eb58f8c9e59b0bf861fb", "url": "https://github.com/eclipse-openj9/openj9/commit/07755f7fa4775348a9c8eb58f8c9e59b0bf861fb", "message": "Add FlattenedArrayObjectScanner\n\n- Use flattened size when iterating flattened arrays\n- Use object ptr in Mixed and Reference scanner constructors\n- Add more value type array tests\n- Add tests for all assorted value alignment types\n- Make sure tests are validating after a GC\n\nSigned-off-by: Andrew Young <youngar17@gmail.com>", "committedDate": "2020-04-02T01:22:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQxMjM5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r402412391", "bodyText": "I'd rather have this (and all parent) classes cache and pass through init method GCExtentions then Environment, since they don't seem  to use anything that is thread specific. This sort of makes assumption that thread that created the scanner will not be passed to another thread for usage (which might not be true - it might be passed through global scan queue).\n@dmitripivkine your opinion?\nAnyhow, that's a separate issue (would require OMR change, as well).", "author": "amicic", "createdAt": "2020-04-02T15:39:23Z", "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,255 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;", "originalCommit": "07755f7fa4775348a9c8eb58f8c9e59b0bf861fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQzOTY4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r402439682", "bodyText": "Yes, I agree. I noticed this and it might be a source of the problem potentially", "author": "dmitripivkine", "createdAt": "2020-04-02T16:17:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQxMjM5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4NDcyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r402484722", "bodyText": "Created an issue for this: eclipse/omr#5018", "author": "youngar", "createdAt": "2020-04-02T17:27:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQxMjM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQxMzU1Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r402413553", "bodyText": "missing EOL or something?", "author": "amicic", "createdAt": "2020-04-02T15:40:57Z", "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,255 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + (sizeInElements * elementStride));\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + (startIndex * elementStride));\n+\t\tfomrobject_t *endPtr = limitPtr;\n+\t\tif (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {\n+\t\t\tAssert_MM_unreachable();\n+\t\t\tendPtr = (fomrobject_t *)((uintptr_t)scanPtr + (splitAmount * elementStride));\n+\t\t\tif (endPtr > limitPtr) {\n+\t\t\t\tendPtr = limitPtr;\n+\t\t\t}\n+\t\t}\n+\t\tuintptr_t *instanceDescription = elementClass->instanceDescription;\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tuintptr_t *leafDescription = elementClass->instanceLeafDescription;\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, leafDescription, flags);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, flags);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\tobjectScanner->initialize(env);\n+\t\tif (0 != startIndex) {\n+\t\t\tobjectScanner->clearHeadObjectScanner();\n+\t\t}\n+\t\treturn objectScanner;\n+\t}\n+\n+\tMMINLINE uintptr_t getBytesRemaining() { return sizeof(fomrobject_t) * (_endPtr - _scanPtr); }\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param splitAmount The maximum number of array elements to include\n+\t * @return Pointer to split scanner in allocSpace\n+\t */\n+\tGC_IndexableObjectScanner *\n+\tsplitTo(MM_EnvironmentBase *env, void *allocSpace, uintptr_t splitAmount)\n+\t{\n+\t\tAssert_MM_unimplemented();\n+\t}\n+\n+\t/**\n+\t * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The\n+\t * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of\n+\t * increasing significance, and the least significant bit maps to the slot at the returned\n+\t * base pointer.\n+\t *\n+\t * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last\n+\t * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots\n+\t */\n+\tvirtual fomrobject_t *\n+\tgetNextSlotMap(uintptr_t *slotMap, bool *hasNextSlotMap)\n+\t{\n+\t\tfomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, hasNextSlotMap);\n+\t\t/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */\n+\t\t*hasNextSlotMap = true;\n+\t\tif (result == NULL) {\n+\t\t\t/* No more slots in the current element, get the next element of the array */\n+\t\t\tresult = _indexableScanner.nextIndexableElement();\n+\t\t\tif (result == NULL) {\n+\t\t\t\t/* There are no elements in the array */\n+\t\t\t\t*hasNextSlotMap = false;\n+\t\t\t} else {\n+\t\t\t\t_mapPtr = result;\n+\t\t\t\t_endPtr = (fomrobject_t *)((uintptr_t)_mapPtr + _elementSizeWithoutPadding);\n+\t\t\t\tGC_HeadlessMixedObjectScanner::initialize(_env, _descriptionBasePtr, _leafBasePtr);\n+\t\t\t\t/* GC_HeadlessMixedObjectScanner::initialize() may setNoMoreSlots(), so set it back to true. \n+\t\t\t\t * We must also return (hasNextSlotMap = true) on top of this\n+\t\t\t\t */\n+\t\t\t\tsetMoreSlots();\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+#if defined(OMR_GC_LEAF_BITS)\n+\t/**\n+\t * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The\n+\t * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of\n+\t * increasing significance, and the least significant bit maps to the slot at the returned\n+\t * base pointer.\n+\t *\n+\t * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] leafMap the leaf bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last\n+\t * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots\n+\t */\n+\tvirtual fomrobject_t *\n+\tgetNextSlotMap(uintptr_t *slotMap, uintptr_t *leafMap, bool *hasNextSlotMap)\n+\t{\n+\t\tfomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, leafMap, hasNextSlotMap);\n+\t\t/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */\n+\t\t*hasNextSlotMap = true;\n+\t\tif (result == NULL) {\n+\t\t\t/* No more slots in the current element, get the next element of the array */\n+\t\t\tresult = _indexableScanner.nextIndexableElement();\n+\t\t\tif (result == NULL) {\n+\t\t\t\t/* There are no elements in the array */\n+\t\t\t\t*hasNextSlotMap = false;\n+\t\t\t} else {\n+\t\t\t\t_mapPtr = result;\n+\t\t\t\t_endPtr = (fomrobject_t *)((uintptr_t)_mapPtr + _elementSizeWithoutPadding);\n+\t\t\t\tGC_HeadlessMixedObjectScanner::initialize(_env, _descriptionBasePtr, _leafBasePtr);\n+\t\t\t\t/* GC_HeadlessMixedObjectScanner::initialize() may setNoMoreSlots(), so set it back to true. \n+\t\t\t\t * We must also return (hasNextSlotMap = true) on top of this\n+\t\t\t\t */\n+\t\t\t\tsetMoreSlots();\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+};\n+\n+#endif /* FLATTENEDARRAYOBJECTSCANNER_HPP_ */", "originalCommit": "07755f7fa4775348a9c8eb58f8c9e59b0bf861fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ2NTc4OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r402465789", "bodyText": "Fixed", "author": "youngar", "createdAt": "2020-04-02T16:57:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQxMzU1Mw=="}], "type": "inlineReview"}, {"oid": "69ba50da5d14fead1654ba8072419cd8e2d8fff8", "url": "https://github.com/eclipse-openj9/openj9/commit/69ba50da5d14fead1654ba8072419cd8e2d8fff8", "message": "Add FlattenedArrayObjectScanner\n\n- Use flattened size when iterating flattened arrays\n- Use object ptr in Mixed and Reference scanner constructors\n- Add more value type array tests\n- Add tests for all assorted value alignment types\n- Make sure tests are validating after a GC\n\nSigned-off-by: Andrew Young <youngar17@gmail.com>", "committedDate": "2020-04-02T16:56:22Z", "type": "commit"}, {"oid": "69ba50da5d14fead1654ba8072419cd8e2d8fff8", "url": "https://github.com/eclipse-openj9/openj9/commit/69ba50da5d14fead1654ba8072419cd8e2d8fff8", "message": "Add FlattenedArrayObjectScanner\n\n- Use flattened size when iterating flattened arrays\n- Use object ptr in Mixed and Reference scanner constructors\n- Add more value type array tests\n- Add tests for all assorted value alignment types\n- Make sure tests are validating after a GC\n\nSigned-off-by: Andrew Young <youngar17@gmail.com>", "committedDate": "2020-04-02T16:56:22Z", "type": "forcePushed"}]}