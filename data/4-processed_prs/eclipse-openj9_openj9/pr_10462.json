{"pr_number": 10462, "pr_title": "Implement initial JIT support for Valhalla flattened value type fields", "pr_createdAt": "2020-08-26T17:35:16Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10462", "timeline": [{"oid": "7da170fc78566c7cb6e242c2ee9b402472bd9a6d", "url": "https://github.com/eclipse-openj9/openj9/commit/7da170fc78566c7cb6e242c2ee9b402472bd9a6d", "message": "Add JIT flattened field testing\n\nAdd test config command to run Valhalla tests with field flattening and\nthe JIT enabled.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>", "committedDate": "2020-08-26T16:50:33Z", "type": "commit"}, {"oid": "fff8f6a590307d803c1c2d3f5e40affd119ea649", "url": "https://github.com/eclipse-openj9/openj9/commit/fff8f6a590307d803c1c2d3f5e40affd119ea649", "message": "Correctly query if symref is resolved method in StringPeepholes\n\nPreviously, StringPeepholes assumed that if the symref on an acall is\n*not* unresolved, then the symbol must be a resolved method. This is\nincorrect since the symbol could be a helper, or non-helper, etc.\n\nThis commit corrects the check by querying isResolvedMethod() instead of\n!isUnresolved().\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>", "committedDate": "2020-08-26T16:50:33Z", "type": "commit"}, {"oid": "1f8470e6f85d170f6181381d5b19834a382a1511", "url": "https://github.com/eclipse-openj9/openj9/commit/1f8470e6f85d170f6181381d5b19834a382a1511", "message": "Implement flattened storeInstance support\n\nSupport is implemented by generating a call to the putFlattenableField\nruntime helper.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>", "committedDate": "2020-08-26T17:38:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU5NTIzMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r478595230", "bodyText": "-Xgcpolicy:optthruput -Xnocompactgc is used in -Xint when both  -XX:ValueTypeFlatteningThreshold=99999 and -XX:+EnableArrayFlattening are enabled.  To be consistent as -Xint test variations, is this variation added here for future when we add -XX:+EnableArrayFlattening to -Xjit test?", "author": "a7ehuo", "createdAt": "2020-08-27T17:53:04Z", "path": "test/functional/Valhalla/playlist.xml", "diffHunk": "@@ -62,6 +62,8 @@\n \t\t\t  -\t<variation>-Xjit:count=0</variation>\n \t\t\t  -->\n \t\t\t<variation>-Xjit:count=1,disableAsyncCompilation</variation>\n+\t\t\t<variation>-Xjit:count=1,disableAsyncCompilation -Xgcpolicy:nogc -XX:ValueTypeFlatteningThreshold=99999</variation>\n+\t\t\t<variation>-Xjit:count=1,disableAsyncCompilation -Xgcpolicy:optthruput -Xnocompactgc -XX:ValueTypeFlatteningThreshold=99999</variation>", "originalCommit": "7da170fc78566c7cb6e242c2ee9b402472bd9a6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE0MTUyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r480141526", "bodyText": "My understanding is that these are the only configurations we are supporting, so these are the configurations I'm testing.", "author": "Leonardo2718", "createdAt": "2020-08-31T13:46:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU5NTIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYwMjI4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r478602281", "bodyText": "Would it make the API cleaner by combining these helpers into one API such as findOrCreateFlattenableSymbolRef(owningMethodSymbol, opCode, isStatic, isArrayElment) and have an enum to switch on the different optCode and type?", "author": "a7ehuo", "createdAt": "2020-08-27T18:05:47Z", "path": "runtime/compiler/compile/J9SymbolReferenceTable.hpp", "diffHunk": "@@ -110,7 +110,17 @@ class SymbolReferenceTable : public OMR::SymbolReferenceTableConnector\n    TR::SymbolReference * findOrCreateWriteBarrierClassStoreRealTimeGCSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = 0);\n    TR::SymbolReference * findOrCreateWriteBarrierBatchStoreSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = 0);\n \n-   TR::SymbolReference * findOrCreateAcmpHelperSymbolRef(TR::ResolvedMethodSymbol * owningMEthodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateAcmpHelperSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+\n+   // these helpers are guarenteed to never throw if the receiving object is not null,\n+   // so we explicit generate NULLCHKs and assume the helpers will never throw\n+   TR::SymbolReference * findOrCreateGetFlattenableFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateWithFlattenableFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreatePutFlattenableFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateGetFlattenableStaticFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreatePutFlattenableStaticFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateLoadFlattenableArrayElementSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateStoreFlattenableArrayElementSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);", "originalCommit": "3a5f95c1fcffff186871f77a133cce7ddfdf1609", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzMzczMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r480133733", "bodyText": "Using separate functions for each helper symbol seems to be the convention. There is findOrCreateRuntimeHelper(), which takes in the enum name for the helper as an argument. I don't see a need for having a separate enum just for flattened value type helpers.", "author": "Leonardo2718", "createdAt": "2020-08-31T13:33:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYwMjI4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxMTA1NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r478611054", "bodyText": "Should isStore is passed in as true for isFieldResolved here?", "author": "a7ehuo", "createdAt": "2020-08-27T18:22:02Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6735,6 +6735,20 @@ TR_J9ByteCodeIlGenerator::storeInstance(int32_t cpIndex)\n    if (_generateWriteBarriersForFieldWatch && comp()->compileRelocatableCode())\n       comp()->failCompilation<J9::AOTNoSupportForAOTFailure>(\"NO support for AOT in field watch\");\n \n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+   if (TR::Compiler->om.areValueTypesEnabled() && owningMethod->isFieldQType(cpIndex))\n+      {\n+      if (!isFieldResolved(comp(), owningMethod, cpIndex, false))", "originalCommit": "1f8470e6f85d170f6181381d5b19834a382a1511", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE1NzU4OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r480157589", "bodyText": "Fixed in force push", "author": "Leonardo2718", "createdAt": "2020-08-31T14:11:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxMTA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxNDE2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r478614164", "bodyText": "I wonder if genFlattenableWithFieldWithHelper should be moved before the stack manipulation at line 6222. genFlattenableWithFieldWithHelper will take care of pop and push and genNullCheck instead of piggy back on genWithField here. It'd be easier down the road to debug the code when the stack manipulation inside one function. Actually loadFlattenableInstanceWithHelper and storeFlattenableInstanceWithHelper already do so.", "author": "a7ehuo", "createdAt": "2020-08-27T18:27:56Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6231,6 +6231,13 @@ TR_J9ByteCodeIlGenerator::genWithField(uint16_t fieldCpIndex)\n    TR::Node *passThruNode = TR::Node::create(TR::PassThrough, 1, originalObject);\n    genTreeTop(genNullCheck(passThruNode));\n \n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+   if (owningMethod->isFieldQType(fieldCpIndex) && owningMethod->isFieldFlattened(comp(), fieldCpIndex, _methodSymbol->isStatic()))\n+      {\n+      genFlattenableWithFieldWithHelper(fieldCpIndex, newFieldValue, originalObject);\n+      return;\n+      }\n+", "originalCommit": "01c05be6691f9b107a095ac7791d695a8ffb1536", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzODg0Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r480138846", "bodyText": "Maybe.\ngenWithField() is a bit different from loadInstance() and storeInstance() because it only gets called when value types are enabled (i.e. the check is already done by the caller and there isn't anything to do if value types are disabled other than aborting compilation). My thinking was that organizing the code this way reduces code duplication. I'm not sure I see how putting the stack manipulation in one function is going to help with debugging.", "author": "Leonardo2718", "createdAt": "2020-08-31T13:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxNDE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxNjI0MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r478616241", "bodyText": "Why isn't  push(helperCallNode) needed here?", "author": "a7ehuo", "createdAt": "2020-08-27T18:31:48Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6868,6 +6882,25 @@ TR_J9ByteCodeIlGenerator::storeInstance(int32_t cpIndex)\n       }\n    }\n \n+void\n+TR_J9ByteCodeIlGenerator::storeFlattenableInstanceWithHelper(int32_t cpIndex)\n+   {\n+   TR::Node * value = pop();\n+   TR::Node * address = pop();\n+   if (!address->isNonNull())\n+      {\n+      auto* nullchk = TR::Node::create(TR::PassThrough, 1, address);\n+      nullchk = genNullCheck(nullchk);\n+      genTreeTop(nullchk);\n+      }\n+   auto* j9ResolvedMethod = static_cast<TR_ResolvedJ9Method *>(_methodSymbol->getResolvedMethod());\n+   auto* ramFieldRef = reinterpret_cast<J9RAMFieldRef*>(j9ResolvedMethod->cp()) + cpIndex;\n+   auto* ramFieldRefNode = TR::Node::aconst(reinterpret_cast<uintptr_t>(ramFieldRef));\n+   auto* helperCallNode = TR::Node::createWithSymRef(TR::acall, 3, 3, value, address, ramFieldRefNode, comp()->getSymRefTab()->findOrCreatePutFlattenableFieldSymbolRef());\n+   handleSideEffect(helperCallNode);\n+   genTreeTop(helperCallNode);\n+   }", "originalCommit": "1f8470e6f85d170f6181381d5b19834a382a1511", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzOTgzNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r480139835", "bodyText": "putfield doesn't produce a result, so there is nothing to push on the stack.", "author": "Leonardo2718", "createdAt": "2020-08-31T13:43:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxNjI0MQ=="}], "type": "inlineReview"}, {"oid": "121d2f4f2b9d51a06caf82ced2fa3d92249ca4bd", "url": "https://github.com/eclipse-openj9/openj9/commit/121d2f4f2b9d51a06caf82ced2fa3d92249ca4bd", "message": "Implement flattened storeInstance support\n\nSupport is implemented by generating a call to the putFlattenableField\nruntime helper.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>", "committedDate": "2020-08-31T14:10:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MDUxNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r481440514", "bodyText": "Is there a macro or other helper to do this test and the shifting? Just wanting to avoid magic values if possible...", "author": "andrewcraik", "createdAt": "2020-09-01T21:24:52Z", "path": "runtime/compiler/env/j9fieldsInfo.cpp", "diffHunk": "@@ -166,127 +128,81 @@ TR_VMFieldsInfo::TR_VMFieldsInfo(TR::Compilation * comp, J9Class *aClazz, int bu\n          TR_ASSERT_FATAL(supClass, \"Found NULL supClass in inheritance chain\");\n          }\n \n-      romCl = supClass->romClass;\n-\n-      // iterate through the fields creating TR_VMField and inserting them into a List\n-\n-      currentField = romFieldsStartDo(romCl, &state);\n-      while (currentField)\n-         {\n-         if ((currentField->modifiers & J9AccStatic) == 0)\n-            {\n-            totalNumFields++;\n-            _numRefSlotsInObject += buildField(supClass, currentField);\n-            }\n-         else\n-            {\n-            buildField(supClass, currentField);\n-            }\n-         currentField = romFieldsNextDo(&state);\n-         }\n+      collectFieldInfo(supClass);\n       }\n \n    // copy the GCData\n-   numSlotsInObject = (aClazz->totalInstanceSize + numBytesInSlot - 1)/numBytesInSlot;\n-   numRefs = 0;\n-   descriptorPtr = aClazz->instanceDescription;\n-\n-   // null terminated\n-   _gcDescriptor = (int32_t *) _comp->trMemory()->allocateMemory((_numRefSlotsInObject+1)*sizeof(int32_t), allocKind);\n-   _gcDescriptor[_numRefSlotsInObject] = 0;\n+   UDATA *descriptorPtr = aClazz->instanceDescription;\n+   UDATA descriptorWord=0;\n \n-   slotsInHeader = (TR::Compiler->om.objectHeaderSizeInBytes()/numBytesInSlot);\n-   countSlots = slotsInHeader;\n-   bitIndex = 0;\n+   int32_t bitIndex = 0;\n    if ( ((UDATA) descriptorPtr) & BCT_J9DescriptionImmediate )\n       {\n       bitIndex++;\n       descriptorWord = ((UDATA) descriptorPtr) >> 1;\n       }\n    else\n-     {\n-     descriptorWord = descriptorPtr[0];\n-     }\n+      {\n+      descriptorWord = descriptorPtr[0];\n+      }\n \n+   const int32_t numBytesInSlot = TR::Compiler->om.sizeofReferenceField();\n+   const int32_t numBitsInWord = 8*sizeof(decltype(*(aClazz->instanceDescription)));\n+   const int32_t numSlotsInObject = (aClazz->totalInstanceSize + numBytesInSlot - 1)/numBytesInSlot;\n+   const uintptr_t slotsInHeader = (TR::Compiler->om.objectHeaderSizeInBytes()/numBytesInSlot);\n+   uintptr_t countSlots = slotsInHeader;\n    while (1)\n       {\n-       if ( descriptorWord & 0x1 )\n-          {\n-           _gcDescriptor[numRefs++] = countSlots;\n-          }\n-       countSlots++;\n-       if (countSlots >= (slotsInHeader + numSlotsInObject))\n-          {\n-             break;\n-          }\n-       if (bitIndex == (numBitsInWord - 1))\n-          {\n-          descriptorPtr++;\n-          bitIndex = 0;\n-          descriptorWord = *descriptorPtr;\n-          }\n-       else\n-          {\n-          descriptorWord = descriptorWord >> 1;\n-          bitIndex++;\n-          }\n+      if ( descriptorWord & 0x1 )", "originalCommit": "121d2f4f2b9d51a06caf82ced2fa3d92249ca4bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE1MDE3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482150177", "bodyText": "Yeah, I don't like the magic constant either (actually I don't like any of this descriptorWord code). But, I couldn't find any macros for it and it looks like the GC also does it this way (although the code is much more elegant):\nhttps://github.com/eclipse/openj9/blob/a91c5af9b85a1894fd641c03956def8d97b0eea4/runtime/gc_base/ClassModel.hpp#L114-L138", "author": "Leonardo2718", "createdAt": "2020-09-02T15:11:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MDUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMjE1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r481412150", "bodyText": "This is a real nit, and I know the loop was already coded this way, but if the value of the index variable i is never used in this loop, is there any reason for having this loop count down to zero rather than writing?\nfor (int32_t i = 0; i < numSupClasses; i++)", "author": "hzongaro", "createdAt": "2020-09-01T20:29:12Z", "path": "runtime/compiler/env/j9fieldsInfo.cpp", "diffHunk": "@@ -121,38 +103,18 @@ TR_VMFieldsInfo::TR_VMFieldsInfo(TR::Compilation * comp, J9Class *aClazz, int bu\n             _statics = new (_comp->trMemory(), allocKind) TR_ScratchList<TR_VMField> (_comp->trMemory());\n             break;\n          default:\n-         \tbreak;\n+            TR_ASSERT_FATAL(false, \"Unknown allocation kind %d\", allocKind);\n          }\n-\t  }\n-   else\n-\t  {\n-      _fields = NULL;\n-      _statics = NULL;\n-\t  }\n-   _numRefSlotsInObject = 0;\n+      }\n \n    // self\n-   romCl = aClazz->romClass;\n-   TR_ASSERT(!(romCl->modifiers & J9AccClassArray), \"Cannot construct TR_VMFieldsInfo for array class %p\", aClazz);\n-   currentField = romFieldsStartDo(romCl, &state);\n-   while (currentField)\n-      {\n-      if ((currentField->modifiers & J9AccStatic) == 0)\n-         {\n-         totalNumFields++;\n-         _numRefSlotsInObject += buildField(aClazz, currentField);\n-         }\n-\t  else\n-\t\t {\n-         buildField(aClazz, currentField);\n-\t\t }\n-      currentField = romFieldsNextDo(&state);\n-      }\n+   TR_ASSERT(!(aClazz->romClass->modifiers & J9AccClassArray), \"Cannot construct TR_VMFieldsInfo for array class %p\", aClazz);\n+   collectFieldInfo(aClazz);\n \n    //supers\n-   int numSupClasses = J9CLASS_DEPTH(aClazz);\n+   const int32_t numSupClasses = J9CLASS_DEPTH(aClazz);\n    J9Class *supClass = aClazz;\n-   for (i=numSupClasses-1; i>=0; i--)\n+   for (int32_t i = numSupClasses-1; i>=0; i--)", "originalCommit": "fae2c6b4d97fe082ef5994a6f31741e5a51db001", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEzOTU2Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482139566", "bodyText": "Yeah, migh as well make it a \"normal\" for loop. Fixed in force push.", "author": "Leonardo2718", "createdAt": "2020-09-02T15:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMjE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxNDQ5Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r481414497", "bodyText": "Another nit - as long as you're correcting the indentation, I think this break is still indented too far.", "author": "hzongaro", "createdAt": "2020-09-01T20:33:55Z", "path": "runtime/compiler/env/j9fieldsInfo.cpp", "diffHunk": "@@ -166,127 +128,81 @@ TR_VMFieldsInfo::TR_VMFieldsInfo(TR::Compilation * comp, J9Class *aClazz, int bu\n          TR_ASSERT_FATAL(supClass, \"Found NULL supClass in inheritance chain\");\n          }\n \n-      romCl = supClass->romClass;\n-\n-      // iterate through the fields creating TR_VMField and inserting them into a List\n-\n-      currentField = romFieldsStartDo(romCl, &state);\n-      while (currentField)\n-         {\n-         if ((currentField->modifiers & J9AccStatic) == 0)\n-            {\n-            totalNumFields++;\n-            _numRefSlotsInObject += buildField(supClass, currentField);\n-            }\n-         else\n-            {\n-            buildField(supClass, currentField);\n-            }\n-         currentField = romFieldsNextDo(&state);\n-         }\n+      collectFieldInfo(supClass);\n       }\n \n    // copy the GCData\n-   numSlotsInObject = (aClazz->totalInstanceSize + numBytesInSlot - 1)/numBytesInSlot;\n-   numRefs = 0;\n-   descriptorPtr = aClazz->instanceDescription;\n-\n-   // null terminated\n-   _gcDescriptor = (int32_t *) _comp->trMemory()->allocateMemory((_numRefSlotsInObject+1)*sizeof(int32_t), allocKind);\n-   _gcDescriptor[_numRefSlotsInObject] = 0;\n+   UDATA *descriptorPtr = aClazz->instanceDescription;\n+   UDATA descriptorWord=0;\n \n-   slotsInHeader = (TR::Compiler->om.objectHeaderSizeInBytes()/numBytesInSlot);\n-   countSlots = slotsInHeader;\n-   bitIndex = 0;\n+   int32_t bitIndex = 0;\n    if ( ((UDATA) descriptorPtr) & BCT_J9DescriptionImmediate )\n       {\n       bitIndex++;\n       descriptorWord = ((UDATA) descriptorPtr) >> 1;\n       }\n    else\n-     {\n-     descriptorWord = descriptorPtr[0];\n-     }\n+      {\n+      descriptorWord = descriptorPtr[0];\n+      }\n \n+   const int32_t numBytesInSlot = TR::Compiler->om.sizeofReferenceField();\n+   const int32_t numBitsInWord = 8*sizeof(decltype(*(aClazz->instanceDescription)));\n+   const int32_t numSlotsInObject = (aClazz->totalInstanceSize + numBytesInSlot - 1)/numBytesInSlot;\n+   const uintptr_t slotsInHeader = (TR::Compiler->om.objectHeaderSizeInBytes()/numBytesInSlot);\n+   uintptr_t countSlots = slotsInHeader;\n    while (1)\n       {\n-       if ( descriptorWord & 0x1 )\n-          {\n-           _gcDescriptor[numRefs++] = countSlots;\n-          }\n-       countSlots++;\n-       if (countSlots >= (slotsInHeader + numSlotsInObject))\n-          {\n-             break;\n-          }\n-       if (bitIndex == (numBitsInWord - 1))\n-          {\n-          descriptorPtr++;\n-          bitIndex = 0;\n-          descriptorWord = *descriptorPtr;\n-          }\n-       else\n-          {\n-          descriptorWord = descriptorWord >> 1;\n-          bitIndex++;\n-          }\n+      if ( descriptorWord & 0x1 )\n+         {\n+         _gcDescriptor.push_back(countSlots);\n+         }\n+      countSlots++;\n+      if (countSlots >= (slotsInHeader + numSlotsInObject))\n+         {\n+            break;", "originalCommit": "fae2c6b4d97fe082ef5994a6f31741e5a51db001", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE0MDM4MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482140380", "bodyText": "Yep, somehow I missed that one. \ud83d\ude05\nFixed in force push.", "author": "Leonardo2718", "createdAt": "2020-09-02T15:02:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxNDQ5Nw=="}], "type": "inlineReview"}, {"oid": "a9694a83d94c0d8c04aa192ce6a191c09af02c73", "url": "https://github.com/eclipse-openj9/openj9/commit/a9694a83d94c0d8c04aa192ce6a191c09af02c73", "message": "Fix TR_VMFieldsInfo constructor\n\nPreviously, the TR_VMFieldInfo constructors assumed that the number of\nfields in an object instance must equal the number of slots in the\ninstance. Value type flattening breaks that assumption, so this\ncommit refactors the code to correctly handle flattened fields.\n\nThe original code traversed all the fields in an object instance and\nrecorded the number of object references visited. This number was then\nused to calculate the size of the dynamically allocated `_gcDescriptor`\narray, which was then populated with the offset of each ref slot.\nUnfortunately, when enabling value type flattening, the number of ref\nslots can end up being larger than the number of ref fields in the object,\nresulting writes past the end of the array (which happens to corrupt the\nstack because it just happens to get allocated in a stack region).\n\nAs a fix, this commit changes `_gcDescriptor` to be a std::vector that\nis populated by calling `push_back()` for every ref slot in an instance.\nAs a result, pre-calculating the number of ref-slots is no longer needed\nand the allocated space is guaranteed to be large enough. As a bonus,\nthe code can be significantly simplified by removing some of the\nbookkeeping previously used to calculate the number of ref slots.\n\nIn order to make the code easier to understand for myself while fixing\nthe above issue and for future developers, I have also done the\nfollowing refactors:\n\n- Added member initialization list to ensure all members always get\n  initialized with some default value (previously, there was a path were\n  `_statics` and `_fields` could be uninitialized)\n- Moved variable declarations to where the variables are actually used\n  (there's no reason to pretend a constructor has to compile with C89)\n- Removed unused/unneeded variables and fields:\n  - _ramClass\n  - _numRefSlotsInObject\n  - totalNumFields\n  - numSlotsInObject\n- Changed return type of `buildField()` to void\n  - we no longer need to know if the field that was added is a ref\n- Moved field collection to it's own function\n  - simplified collection of fields by removing need to care about\n    static vs non-static fields\n  - we no longer need to know which fields occupy slots in an instance\n- Made some variables `const` to make sure they are never assigned\n- Removed unused methods:\n  - `print()` (only used in commented out code)\n  - `getNumRefSlotsInObject()`\n- Fixed incorrect indenting\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>", "committedDate": "2020-09-02T15:00:54Z", "type": "commit"}, {"oid": "348866a842a6467e4f0d8cc60e9d0372072218e9", "url": "https://github.com/eclipse-openj9/openj9/commit/348866a842a6467e4f0d8cc60e9d0372072218e9", "message": "Add findOrCreate methods for flattened value type helper symbols\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>", "committedDate": "2020-09-02T15:00:59Z", "type": "commit"}, {"oid": "f6f521ed788389d01ba6f7836c0569ea970844f2", "url": "https://github.com/eclipse-openj9/openj9/commit/f6f521ed788389d01ba6f7836c0569ea970844f2", "message": "Implement flattened storeInstance support\n\nSupport is implemented by generating a call to the putFlattenableField\nruntime helper.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>", "committedDate": "2020-09-02T15:00:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTY0OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482171648", "bodyText": "Why do we do runtime resolve when we can safely compile-time resolve it? Other fields only need resolve check when we can't compile-time resolve them. Are ValueType fields different?", "author": "liqunl", "createdAt": "2020-09-02T15:40:44Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,11 +5061,48 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+/**\n+ * @brief Returns whether a field ref in the constant pool resolved\n+ *\n+ * Importantly, when this function returns false, a ResolveCHK is guarenteed to be needed.", "originalCommit": "f6f521ed788389d01ba6f7836c0569ea970844f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4ODcyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482188726", "bodyText": "My understanding was that a resolve check is still needed for compile-time resolved fields. @andrewcraik can you confirm what the correct behaviour is?", "author": "Leonardo2718", "createdAt": "2020-09-02T16:05:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIyNDIwMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482224200", "bodyText": "A compile-time resolve is not a true resolve - it is a promise from the VM that we know what the entry is going to resolve to - if the entry in the constant pool is not resolved when we start compiling and isn't genuinely resolved after the helper call the resolvechk is needed to make the resolution happen at the appropriate point at runtime.", "author": "andrewcraik", "createdAt": "2020-09-02T17:01:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2NDQzNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482264437", "bodyText": "@andrewcraik My understanding is that, if VM knows what the entry is going to resolve to, we'll treat it resolved even if the entry is not resolved in cp. That's what we do for other fields (we also do so for method calls except when rtResolve is on).\nMy impression is that when the JIT ask the VM to compile time resolve something, the VM looks up that thing with restrictions, such as no java code is allowed during the look up. So if a cp entry can be compile-time resolved, it means its resolution has no side effect, and the runtime resolution is not necessary since we know what it is.\nWhile my impression may be inaccurate, my question is with us treating other compile-time resolvable fields resolved, what makes the ValueType fields different? If there is a difference, may be a comment is needed to explain the difference.", "author": "liqunl", "createdAt": "2020-09-02T18:03:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2NzEyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482267121", "bodyText": "I don't think there is a difference, but we should ask @tajila or @DanHeidinga to confirm if they want the JIT to call to resolve the CP entry or not or if we can skip that.", "author": "andrewcraik", "createdAt": "2020-09-02T18:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMxNDE1OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482314159", "bodyText": "For fields, if the compile-time resolve is successful then we update the linkage state for the cpEntry. This is equivalent to what would happen in the case of a runtime resolve. If the compile-time resolve fails then the runtime resolution must be run, so that appropriate exceptions can be thrown.", "author": "tajila", "createdAt": "2020-09-02T19:02:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMyMDIyMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482320223", "bodyText": "Ok so that means for a field resolve that succeeds at compile time we can skip the ResolveCHK, but failure means the ResolveCHK must remain.", "author": "andrewcraik", "createdAt": "2020-09-02T19:09:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY0OTY3Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r485649672", "bodyText": "Changed in force push to return the result of the compile-time resolve.", "author": "Leonardo2718", "createdAt": "2020-09-09T14:19:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTY0OA=="}], "type": "inlineReview"}, {"oid": "867966b76548849a32c35a1e3d275630e5e2d51b", "url": "https://github.com/eclipse-openj9/openj9/commit/867966b76548849a32c35a1e3d275630e5e2d51b", "message": "Add helper to check if field cpRef is resolved\n\nThis helper will be used during IL generation to handle flattened value\ntype fields.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>", "committedDate": "2020-09-09T14:18:01Z", "type": "commit"}, {"oid": "f18bbddadb68ae27a6e69e6fd7b32b204588b51c", "url": "https://github.com/eclipse-openj9/openj9/commit/f18bbddadb68ae27a6e69e6fd7b32b204588b51c", "message": "Implement flattened loadInstance support\n\nSupport is implemented by generating a call to the getFlattenableField\nruntime helper.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>", "committedDate": "2020-09-09T14:18:06Z", "type": "commit"}, {"oid": "87d281cfb617e5fca58f4dbe1035f54ad888e6fd", "url": "https://github.com/eclipse-openj9/openj9/commit/87d281cfb617e5fca58f4dbe1035f54ad888e6fd", "message": "Implement flattened withfield support\n\nSupport is implemented by generating a call to the withFlattenableField\nruntime helper.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>", "committedDate": "2020-09-09T14:18:06Z", "type": "commit"}, {"oid": "f4f609fe37f91189aba08575b4a1fcd4d07e6ac9", "url": "https://github.com/eclipse-openj9/openj9/commit/f4f609fe37f91189aba08575b4a1fcd4d07e6ac9", "message": "Implement flattened storeInstance support\n\nSupport is implemented by generating a call to the putFlattenableField\nruntime helper.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>", "committedDate": "2020-09-09T14:18:06Z", "type": "commit"}, {"oid": "f4f609fe37f91189aba08575b4a1fcd4d07e6ac9", "url": "https://github.com/eclipse-openj9/openj9/commit/f4f609fe37f91189aba08575b4a1fcd4d07e6ac9", "message": "Implement flattened storeInstance support\n\nSupport is implemented by generating a call to the putFlattenableField\nruntime helper.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>", "committedDate": "2020-09-09T14:18:06Z", "type": "forcePushed"}]}