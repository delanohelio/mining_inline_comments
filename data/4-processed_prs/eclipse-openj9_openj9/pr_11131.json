{"pr_number": 11131, "pr_title": "AArch64: Implement VMcheckcastEvaluator", "pr_createdAt": "2020-11-09T03:43:37Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/11131", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0MzkyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11131#discussion_r519543926", "bodyText": "Please move this break; out of the { ... } block, in the same way as other cases such as ProfiledClassTest and CastClassCacheTest.", "author": "knn-k", "createdAt": "2020-11-09T04:14:57Z", "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -1146,21 +1156,313 @@ J9::ARM64::TreeEvaluator::VMinstanceofEvaluator(TR::Node *node, TR::CodeGenerato\n    return resultReg;\n    }\n \n+/**\n+ * @brief Generates null test instructions\n+ * \n+ * @param[in]         cg: code generator\n+ * @param[in]     objReg: register holding object\n+ * @param[in]       node: null check node\n+ * @param[in] nullSymRef: symbol reference of null check\n+ * \n+ */\n+static\n+void generateNullTest(TR::CodeGenerator *cg, TR::Register *objReg, TR::Node *node, TR::SymbolReference *nullSymRef = NULL)\n+   {\n+   TR::LabelSymbol *snippetLabel = generateLabelSymbol(cg);\n+   TR::Compilation *comp = cg->comp();\n+   if (nullSymRef == NULL)\n+      {\n+      nullSymRef = comp->getSymRefTab()->findOrCreateNullCheckSymbolRef(comp->getMethodSymbol());\n+      }\n+   TR::Snippet *snippet = new (cg->trHeapMemory()) TR::ARM64HelperCallSnippet(cg, node, snippetLabel, nullSymRef, NULL);\n+   cg->addSnippet(snippet);\n+\n+   TR::Instruction *cbzInstruction = generateCompareBranchInstruction(cg, TR::InstOpCode::cbzx, node, objReg, snippetLabel);\n+   cbzInstruction->setNeedsGCMap(0xffffffff);\n+   snippet->gcMap().setGCRegisterMask(0xffffffff);\n+   // ARM64HelperCallSnippet generates \"bl\" instruction\n+   cg->machine()->setLinkRegisterKilled(true);\n+   }\n+\n+TR::Register *\n+J9::ARM64::TreeEvaluator::VMcheckcastEvaluator(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+   TR::Compilation                      *comp = cg->comp();\n+   TR_OpaqueClassBlock                  *compileTimeGuessClass;\n+   int32_t                               maxProfiledClasses = comp->getOptions()->getCheckcastMaxProfiledClassTests();\n+   traceMsg(comp, \"%s:Maximum Profiled Classes = %d\\n\", node->getOpCode().getName(),maxProfiledClasses);\n+   TR_ASSERT_FATAL(maxProfiledClasses <= 4, \"Maximum 4 profiled classes per site allowed because we use a fixed stack allocated buffer for profiled classes\\n\");\n+   InstanceOfOrCheckCastSequences        sequences[InstanceOfOrCheckCastMaxSequences];\n+   bool                                  topClassWasCastClass = false;\n+   float                                 topClassProbability = 0.0;\n+\n+   bool                                  profiledClassIsInstanceOf;\n+   InstanceOfOrCheckCastProfiledClasses  profiledClassesList[4];\n+   uint32_t                              numberOfProfiledClass;\n+   uint32_t                              numSequencesRemaining = calculateInstanceOfOrCheckCastSequences(node, sequences, &compileTimeGuessClass, cg, profiledClassesList, &numberOfProfiledClass, maxProfiledClasses, &topClassProbability, &topClassWasCastClass);\n+\n+\n+   TR::Node                       *objectNode = node->getFirstChild();\n+   TR::Node                       *castClassNode = node->getSecondChild();\n+   TR::Register                   *objectReg = cg->evaluate(objectNode);\n+   TR::Register                   *castClassReg = NULL;\n+\n+   TR::LabelSymbol *doneLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *callHelperLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nextSequenceLabel = generateLabelSymbol(cg);\n+\n+   TR::Instruction *gcPoint;\n+\n+   TR_ARM64ScratchRegisterManager *srm = cg->generateScratchRegisterManager();\n+   TR::Register                 *objectClassReg = NULL;\n+\n+   auto itBegin = std::begin(sequences);\n+   const auto itEnd = std::next(itBegin, numSequencesRemaining);\n+   \n+   for (auto it = itBegin; it != itEnd; it++)\n+      {\n+      auto current = *it;\n+      switch (current)\n+         {\n+         case EvaluateCastClass:\n+            TR_ASSERT(!castClassReg, \"Cast class already evaluated\");\n+            castClassReg = cg->gprClobberEvaluate(castClassNode);\n+            break;\n+         case LoadObjectClass:\n+            TR_ASSERT(!objectClassReg, \"Object class already loaded\");\n+            objectClassReg = srm->findOrCreateScratchRegister();\n+            generateLoadJ9Class(node, objectClassReg, objectReg, cg);\n+            break;\n+         case NullTest:\n+            if (comp->getOption(TR_TraceCG)) traceMsg(comp, \"%s: Emitting NullTest\\n\", node->getOpCode().getName());\n+            TR_ASSERT(!objectNode->isNonNull(), \"Object is known to be non-null, no need for a null test\");\n+            if (node->getOpCodeValue() == TR::checkcastAndNULLCHK)\n+               {\n+               TR::Node *nullChkInfo = comp->findNullChkInfo(node);\n+               generateNullTest(cg, objectReg, nullChkInfo);\n+               }\n+            else\n+               {\n+               if (isNextItemHelperCall(it, itEnd) || isNextItemGoToFalse(it, itEnd))\n+                  {\n+                  generateCompareBranchInstruction(cg, TR::InstOpCode::cbnzx, node, objectReg, callHelperLabel);\n+                  }\n+               else\n+                  {\n+                  // branch to doneLabel if object is null\n+                  generateCompareBranchInstruction(cg, TR::InstOpCode::cbzx, node, objectReg, doneLabel);\n+                  }\n+               }\n+            break;\n+         case GoToTrue:\n+            TR_ASSERT_FATAL(isTerminalSequence(it, itEnd), \"GoToTrue should be the terminal sequence\");\n+            if (comp->getOption(TR_TraceCG)) traceMsg(comp, \"%s: Emitting GoToTrue\\n\", node->getOpCode().getName());\n+            break;\n+         case ClassEqualityTest:\n+            if (comp->getOption(TR_TraceCG)) traceMsg(comp, \"%s: Emitting ClassEqualityTest\\n\", node->getOpCode().getName());\n+            cg->generateDebugCounter(TR::DebugCounter::debugCounterName(comp, \"checkCastStats/(%s)/Equality\", comp->signature()),1,TR::DebugCounter::Undetermined);\n+\n+            generateCompareInstruction(cg, node, objectClassReg, castClassReg, true);\n+            break;\n+         case SuperClassTest:\n+            {\n+            if (comp->getOption(TR_TraceCG)) traceMsg(comp, \"%s: Emitting SuperClassTest\\n\", node->getOpCode().getName());\n+            cg->generateDebugCounter(TR::DebugCounter::debugCounterName(comp, \"checkCastStats/(%s)/SuperClassTest\", comp->signature()),1,TR::DebugCounter::Undetermined);\n+\n+            int32_t castClassDepth = castClassNode->getSymbolReference()->classDepth(comp);\n+            auto falseLabel = (isNextItemGoToFalse(it, itEnd) || isNextItemHelperCall(it, itEnd)) ? callHelperLabel : nextSequenceLabel;\n+            genInstanceOfOrCheckCastSuperClassTest(node, objectClassReg, castClassReg, castClassDepth, falseLabel, srm, cg);\n+            break;", "originalCommit": "674126823d958aba811486fb838ada67332b987d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU1ODgwMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11131#discussion_r519558802", "bodyText": "Moved break out of the { ... } block.", "author": "Akira1Saitoh", "createdAt": "2020-11-09T05:22:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0MzkyNg=="}], "type": "inlineReview"}, {"oid": "3723b75cb612fd2c6bd4dcad6cbdae2fea6e9277", "url": "https://github.com/eclipse-openj9/openj9/commit/3723b75cb612fd2c6bd4dcad6cbdae2fea6e9277", "message": "AArch64: Implement VMcheckcastEvaluator\n\nThis commit adds inlined version of evaluator for `checkcast`\nand `checkcastAndNULLCHK`.\nAs in `VMinstanceofEvaluator`, this evaluator uses a common method\nthat determines which sequences need to be generated.\n\nSigned-off-by: Akira Saitoh <saiaki@jp.ibm.com>", "committedDate": "2020-11-09T05:21:39Z", "type": "commit"}, {"oid": "3723b75cb612fd2c6bd4dcad6cbdae2fea6e9277", "url": "https://github.com/eclipse-openj9/openj9/commit/3723b75cb612fd2c6bd4dcad6cbdae2fea6e9277", "message": "AArch64: Implement VMcheckcastEvaluator\n\nThis commit adds inlined version of evaluator for `checkcast`\nand `checkcastAndNULLCHK`.\nAs in `VMinstanceofEvaluator`, this evaluator uses a common method\nthat determines which sequences need to be generated.\n\nSigned-off-by: Akira Saitoh <saiaki@jp.ibm.com>", "committedDate": "2020-11-09T05:21:39Z", "type": "forcePushed"}]}