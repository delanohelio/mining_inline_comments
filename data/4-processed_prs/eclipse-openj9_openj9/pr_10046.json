{"pr_number": 10046, "pr_title": "JIT runtime helpers for get/put/withfield", "pr_createdAt": "2020-06-29T18:37:23Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10046", "timeline": [{"oid": "ce2729019e6b3fe7e7969e640d98162f720a2383", "url": "https://github.com/eclipse-openj9/openj9/commit/ce2729019e6b3fe7e7969e640d98162f720a2383", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-07-08T13:54:16Z", "type": "forcePushed"}, {"oid": "8fad3b5f12dcae613a12ac39fdd2db16c250ace1", "url": "https://github.com/eclipse-openj9/openj9/commit/8fad3b5f12dcae613a12ac39fdd2db16c250ace1", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-07-08T14:35:14Z", "type": "forcePushed"}, {"oid": "bb696538baaa47ea295a76ed79da50c341892528", "url": "https://github.com/eclipse-openj9/openj9/commit/bb696538baaa47ea295a76ed79da50c341892528", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-07-30T16:05:26Z", "type": "forcePushed"}, {"oid": "70638d15f89c17cb2048e32f56a9c8b654d9aea2", "url": "https://github.com/eclipse-openj9/openj9/commit/70638d15f89c17cb2048e32f56a9c8b654d9aea2", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-07-30T17:55:23Z", "type": "forcePushed"}, {"oid": "75bcf85ebafe4dfdfc30d6932e1f25337198dc97", "url": "https://github.com/eclipse-openj9/openj9/commit/75bcf85ebafe4dfdfc30d6932e1f25337198dc97", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-07-30T19:41:40Z", "type": "forcePushed"}, {"oid": "e4f4dd332f6bc3ccd0aeabe171f31b5fc9b1ba21", "url": "https://github.com/eclipse-openj9/openj9/commit/e4f4dd332f6bc3ccd0aeabe171f31b5fc9b1ba21", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-07-30T19:45:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzNzU3Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10046#discussion_r463237573", "bodyText": "This is the wrong kind of frame build - please follow the other examples in this file, don't try to be too clever re-using the NPE entrypoint.", "author": "gacholio", "createdAt": "2020-07-30T19:58:57Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -682,37 +682,194 @@ old_fast_jitNewObjectNoZeroInit(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitGetFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tJ9RAMFieldRef* cpEntry = (J9RAMFieldRef*) currentThread->floatTemp1;\n+\tj9object_t receiver = (j9object_t) currentThread->floatTemp2;\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\n+\tif (NULL == receiver) {\n+\t\tbuildJITResolveFrameForTrapHandler(currentThread);\n+\t\trc = (void*)old_slow_jitThrowNullPointerException;\n+\t\tgoto done;\n+\t}\n+\n+\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\treturnObject = currentThread->javaVM->internalVMFunctions->getFlattenableField(currentThread, cpEntry, receiver, FALSE, FALSE);\n+\tif (NULL == returnObject) {\n+\t\trc = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\tgoto done;\n+\t}\n+\n+\tcurrentThread->floatTemp1 = (void*)returnObject; // in case of decompile\n+\trc = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\tif (NULL != rc) {\n+\t\tgoto done;\n+\t}\n+\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn rc;\n }\n \n void* J9FASTCALL\n old_fast_jitGetFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(2);\n+\tDECLARE_JIT_PARM(J9RAMFieldRef*, cpEntry, 1);\n+\tDECLARE_JIT_PARM(j9object_t, receiver, 2);\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\n+\tif (NULL == receiver) {\n+\t\tbuildJITResolveFrameForTrapHandler(currentThread);", "originalCommit": "e4f4dd332f6bc3ccd0aeabe171f31b5fc9b1ba21", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI0MDkxMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10046#discussion_r463240911", "bodyText": "Documentation?", "author": "gacholio", "createdAt": "2020-07-30T20:05:25Z", "path": "runtime/oti/vm_api.h", "diffHunk": "@@ -2455,6 +2455,15 @@ getFlattenableFieldSize(J9VMThread *currentThread, J9Class *fieldOwner, J9ROMFie\n UDATA\n arrayElementSize(J9ArrayClass* arrayClass);\n \n+j9object_t", "originalCommit": "e4f4dd332f6bc3ccd0aeabe171f31b5fc9b1ba21", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1057bd2b8f1965ae5f4876cb3187c4d8b9ffd284", "url": "https://github.com/eclipse-openj9/openj9/commit/1057bd2b8f1965ae5f4876cb3187c4d8b9ffd284", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-07-30T21:54:18Z", "type": "forcePushed"}, {"oid": "e2f707e6d4f159f5d1cfcda57cb92d429241a83d", "url": "https://github.com/eclipse-openj9/openj9/commit/e2f707e6d4f159f5d1cfcda57cb92d429241a83d", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-07-31T01:25:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEyNDI0NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10046#discussion_r465124245", "bodyText": "These new functions also need doc.", "author": "gacholio", "createdAt": "2020-08-04T15:10:46Z", "path": "runtime/vm/ValueTypeHelpers.hpp", "diffHunk": "@@ -255,6 +256,116 @@ class VM_ValueTypeHelpers {\n \t\treturn rc;\n \t}\n \n+\tstatic VMINLINE j9object_t", "originalCommit": "e2f707e6d4f159f5d1cfcda57cb92d429241a83d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1ODA5OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10046#discussion_r465158099", "bodyText": "This will need to be in the slow path (so all of the JIT registers are visible to the stack walker).", "author": "gacholio", "createdAt": "2020-08-04T15:59:06Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -682,37 +682,163 @@ old_fast_jitNewObjectNoZeroInit(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitGetFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tJ9RAMFieldRef* cpEntry = (J9RAMFieldRef*) currentThread->floatTemp1;\n+\tj9object_t receiver = (j9object_t) currentThread->floatTemp2;\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\n+\tif (NULL == receiver) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\trc = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t\tgoto done;\n+\t}\n+\n+\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\treturnObject = currentThread->javaVM->internalVMFunctions->getFlattenableField(currentThread, cpEntry, receiver, FALSE, FALSE);\n+\tif (NULL == returnObject) {\n+\t\trc = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\tgoto done;\n+\t}\n+\n+\tcurrentThread->floatTemp1 = (void*)returnObject; // in case of decompile\n+\trc = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\tif (NULL != rc) {\n+\t\tgoto done;\n+\t}\n+\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn rc;\n }\n \n void* J9FASTCALL\n old_fast_jitGetFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(2);\n+\tDECLARE_JIT_PARM(J9RAMFieldRef*, cpEntry, 1);\n+\tDECLARE_JIT_PARM(j9object_t, receiver, 2);\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\n+\tif (NULL == receiver) {\n+\t\tgoto slow;\n+\t}\n+\n+\treturnObject = currentThread->javaVM->internalVMFunctions->getFlattenableField(currentThread, cpEntry, receiver, TRUE, FALSE);\n+\tif (J9_UNEXPECTED(NULL == returnObject)) {\n+\t\tgoto slow;\n+\t}\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\treturn rc;\n+\n+slow:\n+\tcurrentThread->floatTemp1 = (void*)cpEntry;\n+\tcurrentThread->floatTemp2 = (void*)receiver;\n+\trc = (void *) old_slow_jitGetFlattenableField;\n+\tgoto done;\n }\n \n void* J9FASTCALL\n old_slow_jitWithFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tJ9RAMFieldRef* cpEntry = (J9RAMFieldRef*) currentThread->floatTemp1;\n+\tj9object_t receiver = (j9object_t) currentThread->floatTemp2;\n+\tj9object_t paramObject = (j9object_t) currentThread->floatTemp3;\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tif (NULL == receiver) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\trc = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t\tgoto done;\n+\t}\n+\n+\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\treturnObject = vmFuncs->cloneValueType(currentThread, J9OBJECT_CLAZZ(currentThread, receiver), receiver, FALSE, FALSE);\n+\tif (J9_UNEXPECTED(NULL == returnObject)) {\n+\t\trc = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\tgoto done;\n+\t}\n+\n+\tvmFuncs->putFlattenableField(currentThread, cpEntry, receiver, paramObject);\n+\n+\tcurrentThread->floatTemp1 = (void*)returnObject; // in case of decompile\n+\trc = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\tif (NULL != rc) {\n+\t\tgoto done;\n+\t}\n+\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn rc;\n+\n }\n \n void* J9FASTCALL\n old_fast_jitWithFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n-}\n+\tOLD_JIT_HELPER_PROLOGUE(3);\n+\tDECLARE_JIT_PARM(J9RAMFieldRef*, cpEntry, 1);\n+\tDECLARE_JIT_PARM(j9object_t, receiver, 2);\n+\tDECLARE_JIT_PARM(j9object_t, paramObject, 3);\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n \n-void* J9FASTCALL\n-old_slow_jitPutFlattenableField(J9VMThread *currentThread)\n-{\n-\treturn NULL;\n+\tif (NULL == receiver) {\n+\t\tgoto slow;\n+\t}\n+\n+\treturnObject = vmFuncs->cloneValueType(currentThread, J9OBJECT_CLAZZ(currentThread, receiver), receiver, TRUE, FALSE);\n+\tif (J9_UNEXPECTED(NULL == returnObject)) {\n+\t\tgoto slow;\n+\t}\n+\n+\tvmFuncs->putFlattenableField(currentThread, cpEntry, receiver, paramObject);\n+\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\treturn rc;\n+\n+slow:\n+\tcurrentThread->floatTemp1 = (void*)cpEntry;\n+\tcurrentThread->floatTemp2 = (void*)receiver;\n+\tcurrentThread->floatTemp3 = (void*)paramObject;\n+\trc = (void *) old_slow_jitWithFlattenableField;\n+\tgoto done;\n }\n \n void* J9FASTCALL\n old_fast_jitPutFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(3);\n+\tDECLARE_JIT_PARM(J9RAMFieldRef*, cpEntry, 1);\n+\tDECLARE_JIT_PARM(j9object_t, receiver, 2);\n+\tDECLARE_JIT_PARM(j9object_t, paramObject, 3);\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\n+\tif (NULL == receiver) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);", "originalCommit": "e2f707e6d4f159f5d1cfcda57cb92d429241a83d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fe2e7dbc2880e6ef60897e7511751bc3807b9375", "url": "https://github.com/eclipse-openj9/openj9/commit/fe2e7dbc2880e6ef60897e7511751bc3807b9375", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-08-04T16:35:08Z", "type": "forcePushed"}, {"oid": "a84320b370ec93dbcafc61d7ace1737c8a2d3cb6", "url": "https://github.com/eclipse-openj9/openj9/commit/a84320b370ec93dbcafc61d7ace1737c8a2d3cb6", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-08-04T16:41:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0MzQyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10046#discussion_r465243426", "bodyText": "This can simply build the frame and throw the exception without the extra checks (you can only get here in the NPE case). There's no possibility of reaching the putfield.", "author": "gacholio", "createdAt": "2020-08-04T18:22:46Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -682,37 +682,193 @@ old_fast_jitNewObjectNoZeroInit(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitGetFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tJ9RAMFieldRef* cpEntry = (J9RAMFieldRef*) currentThread->floatTemp1;\n+\tj9object_t receiver = (j9object_t) currentThread->floatTemp2;\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\n+\tif (NULL == receiver) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\trc = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t\tgoto done;\n+\t}\n+\n+\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\treturnObject = currentThread->javaVM->internalVMFunctions->getFlattenableField(currentThread, cpEntry, receiver, FALSE, FALSE);\n+\tif (NULL == returnObject) {\n+\t\trc = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\tgoto done;\n+\t}\n+\n+\tcurrentThread->floatTemp1 = (void*)returnObject; // in case of decompile\n+\trc = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\tif (NULL != rc) {\n+\t\tgoto done;\n+\t}\n+\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn rc;\n }\n \n void* J9FASTCALL\n old_fast_jitGetFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(2);\n+\tDECLARE_JIT_PARM(J9RAMFieldRef*, cpEntry, 1);\n+\tDECLARE_JIT_PARM(j9object_t, receiver, 2);\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\n+\tif (NULL == receiver) {\n+\t\tgoto slow;\n+\t}\n+\n+\treturnObject = currentThread->javaVM->internalVMFunctions->getFlattenableField(currentThread, cpEntry, receiver, TRUE, FALSE);\n+\tif (J9_UNEXPECTED(NULL == returnObject)) {\n+\t\tgoto slow;\n+\t}\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\treturn rc;\n+\n+slow:\n+\tcurrentThread->floatTemp1 = (void*)cpEntry;\n+\tcurrentThread->floatTemp2 = (void*)receiver;\n+\trc = (void *) old_slow_jitGetFlattenableField;\n+\tgoto done;\n }\n \n void* J9FASTCALL\n old_slow_jitWithFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tJ9RAMFieldRef* cpEntry = (J9RAMFieldRef*) currentThread->floatTemp1;\n+\tj9object_t receiver = (j9object_t) currentThread->floatTemp2;\n+\tj9object_t paramObject = (j9object_t) currentThread->floatTemp3;\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tif (NULL == receiver) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\trc = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t\tgoto done;\n+\t}\n+\n+\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\treturnObject = vmFuncs->cloneValueType(currentThread, J9OBJECT_CLAZZ(currentThread, receiver), receiver, FALSE, FALSE);\n+\tif (J9_UNEXPECTED(NULL == returnObject)) {\n+\t\trc = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\tgoto done;\n+\t}\n+\n+\tvmFuncs->putFlattenableField(currentThread, cpEntry, returnObject, paramObject);\n+\n+\tcurrentThread->floatTemp1 = (void*)returnObject; // in case of decompile\n+\trc = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\tif (NULL != rc) {\n+\t\tgoto done;\n+\t}\n+\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn rc;\n+\n }\n \n void* J9FASTCALL\n old_fast_jitWithFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(3);\n+\tDECLARE_JIT_PARM(J9RAMFieldRef*, cpEntry, 1);\n+\tDECLARE_JIT_PARM(j9object_t, receiver, 2);\n+\tDECLARE_JIT_PARM(j9object_t, paramObject, 3);\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tif (NULL == receiver) {\n+\t\tgoto slow;\n+\t}\n+\n+\treturnObject = vmFuncs->cloneValueType(currentThread, J9OBJECT_CLAZZ(currentThread, receiver), receiver, TRUE, FALSE);\n+\tif (J9_UNEXPECTED(NULL == returnObject)) {\n+\t\tgoto slow;\n+\t}\n+\n+\tvmFuncs->putFlattenableField(currentThread, cpEntry, returnObject, paramObject);\n+\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\treturn rc;\n+\n+slow:\n+\tcurrentThread->floatTemp1 = (void*)cpEntry;\n+\tcurrentThread->floatTemp2 = (void*)receiver;\n+\tcurrentThread->floatTemp3 = (void*)paramObject;\n+\trc = (void *) old_slow_jitWithFlattenableField;\n+\tgoto done;\n }\n \n void* J9FASTCALL\n old_slow_jitPutFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();", "originalCommit": "a84320b370ec93dbcafc61d7ace1737c8a2d3cb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0MzU0Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10046#discussion_r465243546", "bodyText": "No need to pass the data to the slow path.", "author": "gacholio", "createdAt": "2020-08-04T18:23:01Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -682,37 +682,193 @@ old_fast_jitNewObjectNoZeroInit(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitGetFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tJ9RAMFieldRef* cpEntry = (J9RAMFieldRef*) currentThread->floatTemp1;\n+\tj9object_t receiver = (j9object_t) currentThread->floatTemp2;\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\n+\tif (NULL == receiver) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\trc = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t\tgoto done;\n+\t}\n+\n+\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\treturnObject = currentThread->javaVM->internalVMFunctions->getFlattenableField(currentThread, cpEntry, receiver, FALSE, FALSE);\n+\tif (NULL == returnObject) {\n+\t\trc = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\tgoto done;\n+\t}\n+\n+\tcurrentThread->floatTemp1 = (void*)returnObject; // in case of decompile\n+\trc = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\tif (NULL != rc) {\n+\t\tgoto done;\n+\t}\n+\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn rc;\n }\n \n void* J9FASTCALL\n old_fast_jitGetFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(2);\n+\tDECLARE_JIT_PARM(J9RAMFieldRef*, cpEntry, 1);\n+\tDECLARE_JIT_PARM(j9object_t, receiver, 2);\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\n+\tif (NULL == receiver) {\n+\t\tgoto slow;\n+\t}\n+\n+\treturnObject = currentThread->javaVM->internalVMFunctions->getFlattenableField(currentThread, cpEntry, receiver, TRUE, FALSE);\n+\tif (J9_UNEXPECTED(NULL == returnObject)) {\n+\t\tgoto slow;\n+\t}\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\treturn rc;\n+\n+slow:\n+\tcurrentThread->floatTemp1 = (void*)cpEntry;\n+\tcurrentThread->floatTemp2 = (void*)receiver;\n+\trc = (void *) old_slow_jitGetFlattenableField;\n+\tgoto done;\n }\n \n void* J9FASTCALL\n old_slow_jitWithFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tJ9RAMFieldRef* cpEntry = (J9RAMFieldRef*) currentThread->floatTemp1;\n+\tj9object_t receiver = (j9object_t) currentThread->floatTemp2;\n+\tj9object_t paramObject = (j9object_t) currentThread->floatTemp3;\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tif (NULL == receiver) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\trc = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t\tgoto done;\n+\t}\n+\n+\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\treturnObject = vmFuncs->cloneValueType(currentThread, J9OBJECT_CLAZZ(currentThread, receiver), receiver, FALSE, FALSE);\n+\tif (J9_UNEXPECTED(NULL == returnObject)) {\n+\t\trc = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\tgoto done;\n+\t}\n+\n+\tvmFuncs->putFlattenableField(currentThread, cpEntry, returnObject, paramObject);\n+\n+\tcurrentThread->floatTemp1 = (void*)returnObject; // in case of decompile\n+\trc = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\tif (NULL != rc) {\n+\t\tgoto done;\n+\t}\n+\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn rc;\n+\n }\n \n void* J9FASTCALL\n old_fast_jitWithFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(3);\n+\tDECLARE_JIT_PARM(J9RAMFieldRef*, cpEntry, 1);\n+\tDECLARE_JIT_PARM(j9object_t, receiver, 2);\n+\tDECLARE_JIT_PARM(j9object_t, paramObject, 3);\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tif (NULL == receiver) {\n+\t\tgoto slow;\n+\t}\n+\n+\treturnObject = vmFuncs->cloneValueType(currentThread, J9OBJECT_CLAZZ(currentThread, receiver), receiver, TRUE, FALSE);\n+\tif (J9_UNEXPECTED(NULL == returnObject)) {\n+\t\tgoto slow;\n+\t}\n+\n+\tvmFuncs->putFlattenableField(currentThread, cpEntry, returnObject, paramObject);\n+\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\treturn rc;\n+\n+slow:\n+\tcurrentThread->floatTemp1 = (void*)cpEntry;\n+\tcurrentThread->floatTemp2 = (void*)receiver;\n+\tcurrentThread->floatTemp3 = (void*)paramObject;\n+\trc = (void *) old_slow_jitWithFlattenableField;\n+\tgoto done;\n }\n \n void* J9FASTCALL\n old_slow_jitPutFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tJ9RAMFieldRef* cpEntry = (J9RAMFieldRef*) currentThread->floatTemp1;\n+\tj9object_t receiver = (j9object_t) currentThread->floatTemp2;\n+\tj9object_t paramObject = (j9object_t) currentThread->floatTemp3;\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\n+\tif (NULL == receiver) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\trc = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t\tgoto done;\n+\t}\n+\n+\tcurrentThread->javaVM->internalVMFunctions->putFlattenableField(currentThread, cpEntry, receiver, paramObject);\n+\n+done:\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn rc;\n }\n \n void* J9FASTCALL\n old_fast_jitPutFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(3);\n+\tDECLARE_JIT_PARM(J9RAMFieldRef*, cpEntry, 1);\n+\tDECLARE_JIT_PARM(j9object_t, receiver, 2);\n+\tDECLARE_JIT_PARM(j9object_t, paramObject, 3);\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\n+\tif (NULL == receiver) {\n+\t\tgoto slow;\n+\t}\n+\n+\tcurrentThread->javaVM->internalVMFunctions->putFlattenableField(currentThread, cpEntry, receiver, paramObject);\n+\n+done:\n+\treturn rc;\n+\n+slow:\n+\tcurrentThread->floatTemp1 = (void*)cpEntry;", "originalCommit": "a84320b370ec93dbcafc61d7ace1737c8a2d3cb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b5cab5ee28e4da6ddb3891877ff9c297cb9ed233", "url": "https://github.com/eclipse-openj9/openj9/commit/b5cab5ee28e4da6ddb3891877ff9c297cb9ed233", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-08-04T19:35:47Z", "type": "forcePushed"}, {"oid": "bb01019afbdc03ab3008309b9f7d884a7b2d2e44", "url": "https://github.com/eclipse-openj9/openj9/commit/bb01019afbdc03ab3008309b9f7d884a7b2d2e44", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nFix incorrect helper prototype for withfield (shouldn't be no return)\nUse internal calling convention on all platforms\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-08-04T19:38:37Z", "type": "forcePushed"}, {"oid": "f138ce54d603efc49e6adcbab44f6497209000b2", "url": "https://github.com/eclipse-openj9/openj9/commit/f138ce54d603efc49e6adcbab44f6497209000b2", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nFix incorrect helper prototype for withfield (shouldn't be no return)\nUse internal calling convention on all platforms\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-08-04T19:42:29Z", "type": "forcePushed"}, {"oid": "5e43618fc618ef35753b072cd22b082b94fafa75", "url": "https://github.com/eclipse-openj9/openj9/commit/5e43618fc618ef35753b072cd22b082b94fafa75", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nFix incorrect helper prototype for withfield (shouldn't be no return)\nUse internal calling convention on all platforms\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-08-04T19:44:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4OTg5Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10046#discussion_r465289897", "bodyText": "Never used.", "author": "gacholio", "createdAt": "2020-08-04T19:46:20Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -682,37 +682,182 @@ old_fast_jitNewObjectNoZeroInit(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitGetFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tJ9RAMFieldRef* cpEntry = (J9RAMFieldRef*) currentThread->floatTemp1;\n+\tj9object_t receiver = (j9object_t) currentThread->floatTemp2;\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\n+\tif (NULL == receiver) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\trc = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t\tgoto done;\n+\t}\n+\n+\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\treturnObject = currentThread->javaVM->internalVMFunctions->getFlattenableField(currentThread, cpEntry, receiver, FALSE);\n+\tif (NULL == returnObject) {\n+\t\trc = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\tgoto done;\n+\t}\n+\n+\tcurrentThread->floatTemp1 = (void*)returnObject; // in case of decompile\n+\trc = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\tif (NULL != rc) {\n+\t\tgoto done;\n+\t}\n+\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn rc;\n }\n \n void* J9FASTCALL\n old_fast_jitGetFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(2);\n+\tDECLARE_JIT_PARM(J9RAMFieldRef*, cpEntry, 1);\n+\tDECLARE_JIT_PARM(j9object_t, receiver, 2);\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\n+\tif (NULL == receiver) {\n+\t\tgoto slow;\n+\t}\n+\n+\treturnObject = currentThread->javaVM->internalVMFunctions->getFlattenableField(currentThread, cpEntry, receiver, TRUE);\n+\tif (J9_UNEXPECTED(NULL == returnObject)) {\n+\t\tgoto slow;\n+\t}\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\treturn rc;\n+\n+slow:\n+\tcurrentThread->floatTemp1 = (void*)cpEntry;\n+\tcurrentThread->floatTemp2 = (void*)receiver;\n+\trc = (void *) old_slow_jitGetFlattenableField;\n+\tgoto done;\n }\n \n void* J9FASTCALL\n old_slow_jitWithFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tJ9RAMFieldRef* cpEntry = (J9RAMFieldRef*) currentThread->floatTemp1;\n+\tj9object_t receiver = (j9object_t) currentThread->floatTemp2;\n+\tj9object_t paramObject = (j9object_t) currentThread->floatTemp3;\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tif (NULL == receiver) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\trc = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t\tgoto done;\n+\t}\n+\n+\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\treturnObject = vmFuncs->cloneValueType(currentThread, J9OBJECT_CLAZZ(currentThread, receiver), receiver, FALSE);\n+\tif (J9_UNEXPECTED(NULL == returnObject)) {\n+\t\trc = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\tgoto done;\n+\t}\n+\n+\tvmFuncs->putFlattenableField(currentThread, cpEntry, returnObject, paramObject);\n+\n+\tcurrentThread->floatTemp1 = (void*)returnObject; // in case of decompile\n+\trc = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\tif (NULL != rc) {\n+\t\tgoto done;\n+\t}\n+\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn rc;\n+\n }\n \n void* J9FASTCALL\n old_fast_jitWithFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(3);\n+\tDECLARE_JIT_PARM(J9RAMFieldRef*, cpEntry, 1);\n+\tDECLARE_JIT_PARM(j9object_t, receiver, 2);\n+\tDECLARE_JIT_PARM(j9object_t, paramObject, 3);\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tif (NULL == receiver) {\n+\t\tgoto slow;\n+\t}\n+\n+\treturnObject = vmFuncs->cloneValueType(currentThread, J9OBJECT_CLAZZ(currentThread, receiver), receiver, TRUE);\n+\tif (J9_UNEXPECTED(NULL == returnObject)) {\n+\t\tgoto slow;\n+\t}\n+\n+\tvmFuncs->putFlattenableField(currentThread, cpEntry, returnObject, paramObject);\n+\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\treturn rc;\n+\n+slow:\n+\tcurrentThread->floatTemp1 = (void*)cpEntry;\n+\tcurrentThread->floatTemp2 = (void*)receiver;\n+\tcurrentThread->floatTemp3 = (void*)paramObject;\n+\trc = (void *) old_slow_jitWithFlattenableField;\n+\tgoto done;\n }\n \n void* J9FASTCALL\n old_slow_jitPutFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\t/* can only get here if we are throwing an exception */\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t returnObject = NULL;", "originalCommit": "5e43618fc618ef35753b072cd22b082b94fafa75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5MDAxMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10046#discussion_r465290010", "bodyText": "Never used.", "author": "gacholio", "createdAt": "2020-08-04T19:46:33Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -682,37 +682,182 @@ old_fast_jitNewObjectNoZeroInit(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitGetFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tJ9RAMFieldRef* cpEntry = (J9RAMFieldRef*) currentThread->floatTemp1;\n+\tj9object_t receiver = (j9object_t) currentThread->floatTemp2;\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\n+\tif (NULL == receiver) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\trc = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t\tgoto done;\n+\t}\n+\n+\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\treturnObject = currentThread->javaVM->internalVMFunctions->getFlattenableField(currentThread, cpEntry, receiver, FALSE);\n+\tif (NULL == returnObject) {\n+\t\trc = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\tgoto done;\n+\t}\n+\n+\tcurrentThread->floatTemp1 = (void*)returnObject; // in case of decompile\n+\trc = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\tif (NULL != rc) {\n+\t\tgoto done;\n+\t}\n+\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn rc;\n }\n \n void* J9FASTCALL\n old_fast_jitGetFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(2);\n+\tDECLARE_JIT_PARM(J9RAMFieldRef*, cpEntry, 1);\n+\tDECLARE_JIT_PARM(j9object_t, receiver, 2);\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\n+\tif (NULL == receiver) {\n+\t\tgoto slow;\n+\t}\n+\n+\treturnObject = currentThread->javaVM->internalVMFunctions->getFlattenableField(currentThread, cpEntry, receiver, TRUE);\n+\tif (J9_UNEXPECTED(NULL == returnObject)) {\n+\t\tgoto slow;\n+\t}\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\treturn rc;\n+\n+slow:\n+\tcurrentThread->floatTemp1 = (void*)cpEntry;\n+\tcurrentThread->floatTemp2 = (void*)receiver;\n+\trc = (void *) old_slow_jitGetFlattenableField;\n+\tgoto done;\n }\n \n void* J9FASTCALL\n old_slow_jitWithFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tJ9RAMFieldRef* cpEntry = (J9RAMFieldRef*) currentThread->floatTemp1;\n+\tj9object_t receiver = (j9object_t) currentThread->floatTemp2;\n+\tj9object_t paramObject = (j9object_t) currentThread->floatTemp3;\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tif (NULL == receiver) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\trc = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t\tgoto done;\n+\t}\n+\n+\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\treturnObject = vmFuncs->cloneValueType(currentThread, J9OBJECT_CLAZZ(currentThread, receiver), receiver, FALSE);\n+\tif (J9_UNEXPECTED(NULL == returnObject)) {\n+\t\trc = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\tgoto done;\n+\t}\n+\n+\tvmFuncs->putFlattenableField(currentThread, cpEntry, returnObject, paramObject);\n+\n+\tcurrentThread->floatTemp1 = (void*)returnObject; // in case of decompile\n+\trc = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\tif (NULL != rc) {\n+\t\tgoto done;\n+\t}\n+\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn rc;\n+\n }\n \n void* J9FASTCALL\n old_fast_jitWithFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(3);\n+\tDECLARE_JIT_PARM(J9RAMFieldRef*, cpEntry, 1);\n+\tDECLARE_JIT_PARM(j9object_t, receiver, 2);\n+\tDECLARE_JIT_PARM(j9object_t, paramObject, 3);\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tif (NULL == receiver) {\n+\t\tgoto slow;\n+\t}\n+\n+\treturnObject = vmFuncs->cloneValueType(currentThread, J9OBJECT_CLAZZ(currentThread, receiver), receiver, TRUE);\n+\tif (J9_UNEXPECTED(NULL == returnObject)) {\n+\t\tgoto slow;\n+\t}\n+\n+\tvmFuncs->putFlattenableField(currentThread, cpEntry, returnObject, paramObject);\n+\n+\tJIT_RETURN_UDATA(returnObject);\n+\n+done:\n+\treturn rc;\n+\n+slow:\n+\tcurrentThread->floatTemp1 = (void*)cpEntry;\n+\tcurrentThread->floatTemp2 = (void*)receiver;\n+\tcurrentThread->floatTemp3 = (void*)paramObject;\n+\trc = (void *) old_slow_jitWithFlattenableField;\n+\tgoto done;\n }\n \n void* J9FASTCALL\n old_slow_jitPutFlattenableField(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\t/* can only get here if we are throwing an exception */\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t returnObject = NULL;\n+\tvoid *rc = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;", "originalCommit": "5e43618fc618ef35753b072cd22b082b94fafa75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5MDQzNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10046#discussion_r465290437", "bodyText": "No longer required.", "author": "gacholio", "createdAt": "2020-08-04T19:47:23Z", "path": "runtime/vm/ValueTypeHelpers.hpp", "diffHunk": "@@ -38,6 +38,7 @@\n #include \"ut_j9vm.h\"\n \n #include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"OutOfLineINL.hpp\"", "originalCommit": "5e43618fc618ef35753b072cd22b082b94fafa75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bc5512e57c209c61afe8c5666ae9312f0ee9ef9e", "url": "https://github.com/eclipse-openj9/openj9/commit/bc5512e57c209c61afe8c5666ae9312f0ee9ef9e", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nFix incorrect helper prototype for withfield (shouldn't be no return)\nUse internal calling convention on all platforms\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-08-04T21:49:46Z", "type": "forcePushed"}, {"oid": "94d88948504005d87856c8e0416e53840c10089f", "url": "https://github.com/eclipse-openj9/openj9/commit/94d88948504005d87856c8e0416e53840c10089f", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nFix incorrect helper prototype for withfield (shouldn't be no return)\nUse internal calling convention on all platforms\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-08-04T21:51:20Z", "type": "forcePushed"}, {"oid": "82e183de58c5b2e8846f6801c68721a5e047e841", "url": "https://github.com/eclipse-openj9/openj9/commit/82e183de58c5b2e8846f6801c68721a5e047e841", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nFix incorrect helper prototype for withfield (shouldn't be no return)\nUse internal calling convention on all platforms\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-08-05T00:31:31Z", "type": "forcePushed"}, {"oid": "40b693a7be0c60c58d910bcfade064c46cb4b40f", "url": "https://github.com/eclipse-openj9/openj9/commit/40b693a7be0c60c58d910bcfade064c46cb4b40f", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nFix incorrect helper prototype for withfield (shouldn't be no return)\nUse internal calling convention on all platforms\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-08-05T13:52:10Z", "type": "forcePushed"}, {"oid": "81c949cd724af8e53e51d77cfa2c227c0c8ddbad", "url": "https://github.com/eclipse-openj9/openj9/commit/81c949cd724af8e53e51d77cfa2c227c0c8ddbad", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nFix incorrect helper prototype for withfield (shouldn't be no return)\nUse internal calling convention on all platforms\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-08-05T19:18:06Z", "type": "commit"}, {"oid": "81c949cd724af8e53e51d77cfa2c227c0c8ddbad", "url": "https://github.com/eclipse-openj9/openj9/commit/81c949cd724af8e53e51d77cfa2c227c0c8ddbad", "message": "JIT runtime helpers for get/put/withfield\n\nAdd new runtime helpers for flattened instance fields.\n\nFix incorrect helper prototype for withfield (shouldn't be no return)\nUse internal calling convention on all platforms\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-08-05T19:18:06Z", "type": "forcePushed"}]}