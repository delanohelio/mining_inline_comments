{"pr_number": 9745, "pr_title": "Sampling allocation bytes precisely without compromising the performance", "pr_createdAt": "2020-05-29T18:59:20Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9745", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4MzQ1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/9745#discussion_r433383456", "bodyText": "Looks like the question I asked about support for dual TLH mode applies here: Am I reading correctly that if we set size for both TLHs we can get 2 * size to be allocated potentially?", "author": "dmitripivkine", "createdAt": "2020-06-01T17:35:12Z", "path": "runtime/gc_glue_java/EnvironmentDelegate.cpp", "diffHunk": "@@ -252,58 +252,134 @@ MM_EnvironmentDelegate::forceOutOfLineVMAccess()\n \n #if defined (J9VM_GC_THREAD_LOCAL_HEAP)\n /**\n- * Disable inline TLH allocates by hiding the real heap allocation address from\n- * JIT/Interpreter in realHeapAlloc and setting heapALloc == HeapTop so TLH\n+ * Disable inline TLH allocates by hiding the real heap top address from\n+ * JIT/Interpreter in realHeapTop and setting HeapTop == heapALloc so TLH\n  * looks full.\n  *\n  */\n void\n MM_EnvironmentDelegate::disableInlineTLHAllocate()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\ttlh->realHeapAlloc = _vmThread->heapAlloc;\n-\t_vmThread->heapAlloc = _vmThread->heapTop;\n+\tif (NULL == tlh->realHeapTop) {\n+\t\ttlh->realHeapTop = _vmThread->heapTop;\n+\t}\n+\t_vmThread->heapTop = _vmThread->heapAlloc;\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\ttlh->realHeapAlloc = _vmThread->nonZeroHeapAlloc;\n-\t_vmThread->nonZeroHeapAlloc = _vmThread->nonZeroHeapTop;\n+\tif (NULL == tlh->realHeapTop) {\n+\t\ttlh->realHeapTop = _vmThread->nonZeroHeapTop;\n+\t}\n+\t_vmThread->nonZeroHeapTop = _vmThread->nonZeroHeapAlloc;\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n }\n \n /**\n- * Re-enable inline TLH allocate by restoring heapAlloc from realHeapAlloc\n+ * Re-enable inline TLH allocate by restoring heapTop from realHeapTop\n  */\n void\n MM_EnvironmentDelegate::enableInlineTLHAllocate()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\t_vmThread->heapAlloc =  tlh->realHeapAlloc;\n-\ttlh->realHeapAlloc = NULL;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\t_vmThread->heapTop =  tlh->realHeapTop;\n+\t\ttlh->realHeapTop = NULL;\n+\t}\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\t_vmThread->nonZeroHeapAlloc =  tlh->realHeapAlloc;\n-\ttlh->realHeapAlloc = NULL;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\t_vmThread->nonZeroHeapTop =  tlh->realHeapTop;\n+\t\ttlh->realHeapTop = NULL;\n+\t}\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n }\n \n /**\n- * Determine if inline TLH allocate is enabled; its enabled if realheapAlloc is NULL.\n+ * Determine if inline TLH allocate is enabled; its enabled if realheapTop is NULL.\n  * @return TRUE if inline TLH allocates currently enabled for this thread; FALSE otherwise\n  */\n bool\n MM_EnvironmentDelegate::isInlineTLHAllocateEnabled()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\tbool result = (NULL == tlh->realHeapAlloc);\n+\tbool result = (NULL == tlh->realHeapTop);\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\tresult = result && (NULL == tlh->realHeapAlloc);\n+\tresult = result && (NULL == tlh->realHeapTop);\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n \n \treturn result;\n }\n+\n+\n+void\n+MM_EnvironmentDelegate::setTLHSamplingTop(uintptr_t size)\n+{\n+\tuintptr_t max = 0;\n+\tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\tmax = tlh->realHeapTop - _vmThread->heapAlloc;\n+\t} else {\n+\t\tmax = _vmThread->heapTop - _vmThread->heapAlloc;\n+\t}\n+\n+\tif (max > size) {\n+\t\tif (NULL == tlh->realHeapTop) {\n+\t\t\ttlh->realHeapTop = _vmThread->heapTop;\n+\t\t}\n+\t\t_vmThread->heapTop = _vmThread->heapAlloc + size;\n+\t} else {\n+\t\tif (NULL != tlh->realHeapTop) {\n+\t\t\t_vmThread->heapTop =  tlh->realHeapTop;\n+\t\t\ttlh->realHeapTop = NULL;\n+\t\t}\n+\t}\n+\n+#if defined(J9VM_GC_NON_ZERO_TLH)\n+\t/* TODO: need to find better way set TLH sampling Top for NON ZERO case */\n+\ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\tmax = tlh->realHeapTop - _vmThread->nonZeroHeapAlloc;\n+\t} else {\n+\t\tmax = _vmThread->nonZeroHeapTop - _vmThread->nonZeroHeapAlloc;\n+\t}\n+\n+\tif (max > size) {\n+\t\tif (NULL == tlh->realHeapTop) {\n+\t\t\ttlh->realHeapTop = _vmThread->nonZeroHeapTop;\n+\t\t}\n+\t\t_vmThread->nonZeroHeapTop = _vmThread->nonZeroHeapAlloc + size;\n+\t} else {\n+\t\tif (NULL != tlh->realHeapTop) {\n+\t\t\t_vmThread->nonZeroHeapTop =  tlh->realHeapTop;\n+\t\t\ttlh->realHeapTop = NULL;\n+\t\t}\n+\t}", "originalCommit": "0cdfcf384b05e280d57036a02e54c3ae361e7805", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQwOTI3MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9745#discussion_r433409271", "bodyText": "yes, we might not get very accurate result on nonzero case,have not found the better way to handle the non zero case.", "author": "LinHu2016", "createdAt": "2020-06-01T18:24:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4MzQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2MjMwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9745#discussion_r433462308", "bodyText": "Do we have a platform that can actually have both active (btw, is X using just nonZeroHeapAlloc/Top?)?  I'm willing to ignore that issue for now, if we think it will take more than a day to do/test it and we can follow up after the upcoming release (by as you said disabling one of two TLHs).", "author": "amicic", "createdAt": "2020-06-01T20:10:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4MzQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2NjgxMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9745#discussion_r433466810", "bodyText": "I believe non-Zeroed TLH is using on pLinux (LE and BE) and AIX. I am not sure about current status of zLinux.", "author": "dmitripivkine", "createdAt": "2020-06-01T20:19:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4MzQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2OTQwMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9745#discussion_r433469403", "bodyText": "Non-zero TLH can be used for primitive arrays only. So to see a mismatch an application should include primitive arrays to the allocation mix.", "author": "dmitripivkine", "createdAt": "2020-06-01T20:24:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4MzQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ3MzMzMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9745#discussion_r433473330", "bodyText": "I agree that proper handling for dual TLH case can be done later in separate change", "author": "dmitripivkine", "createdAt": "2020-06-01T20:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4MzQ1Ng=="}], "type": "inlineReview"}, {"oid": "3e18189e1a258cb36380c6965d2cec270a1d9994", "url": "https://github.com/eclipse-openj9/openj9/commit/3e18189e1a258cb36380c6965d2cec270a1d9994", "message": "Sampling allocation bytes precisely without compromising the performance\n\nin order to sampling heap allocation bytes precisely without\ncompromising the performance, we have the below changes.\n\nHandle instrumentableAllocateHook and\nVM_OBJECT_ALLOCATE_WITHIN_THRESHOLD is still via disabling inline\nallocation\nHandle smapling for tracepoint is still during out of line allocation\nHandle smapling for JEP331 is via setTLHSamplingTop(size)\n\nUsing fake Heap Top instead of fake Heap Alloc for disabling inline\nallocation (realHeapAlloc-->realHeapTop,\nset/getRealAlloc()-->set/getRealTop(), getRealSize(), getUsedSize())\nUsing fake Heap Top to force out of line allocation at sampling thresold\nfor sampling heap allocation (setTLHSamplingTop()/resetTLHSamplingTop())\nsetTLHSamplingTop(size) are only called in the below 3 cases\n\t1, sampling threshold has been changed via GC-VM api\nj9gc_set_allocation_sampling_interval()\n\t2, TLH is refreshed\n\t3, after sampling is done\n\nCounting trace allocation byte includes allocation bytes inside TLH\nCache before flushing(_stats.bytesAllocated(true),\nstats->_tlhAllocatedUsed, )\nHandle traceAllocationByte for Health\nCenter(_oolTraceAllocationBytesForTracepoint,\noolObjectSamplingBytesGranularityForTracepoint) and traceAllocationByte\nfor JEP331(_traceAllocationBytesForHook,\nobjectSamplingBytesGranularityForHook) independently\n\nSigned-off-by: Lin Hu <linhu@ca.ibm.com>", "committedDate": "2020-06-01T19:15:43Z", "type": "forcePushed"}, {"oid": "03f2d378a2fc4de288719cc6e485ea68b9f84547", "url": "https://github.com/eclipse-openj9/openj9/commit/03f2d378a2fc4de288719cc6e485ea68b9f84547", "message": "Sampling allocation bytes precisely without compromising the performance\n\nin order to sampling heap allocation bytes precisely without\ncompromising the performance, we have the below changes.\n\nHandle instrumentableAllocateHook and\nVM_OBJECT_ALLOCATE_WITHIN_THRESHOLD is still via disabling inline\nallocation\nHandle smapling for tracepoint is still during out of line allocation\nHandle smapling for JEP331 is via setTLHSamplingTop(size)\n\nUsing fake Heap Top instead of fake Heap Alloc for disabling inline\nallocation (realHeapAlloc-->realHeapTop,\nset/getRealAlloc()-->set/getRealTop(), getRealSize(), getUsedSize())\nUsing fake Heap Top to force out of line allocation at sampling thresold\nfor sampling heap allocation (setTLHSamplingTop()/resetTLHSamplingTop())\nsetTLHSamplingTop(size) are only called in the below 3 cases\n\t1, sampling threshold has been changed via GC-VM api\nj9gc_set_allocation_sampling_interval()\n\t2, TLH is refreshed\n\t3, after sampling is done\n\nCounting trace allocation byte includes allocation bytes inside TLH\nCache before flushing(_stats.bytesAllocated(true),\nstats->_tlhAllocatedUsed, )\nHandle traceAllocationByte for Health\nCenter(_oolTraceAllocationBytesForTracepoint,\noolObjectSamplingBytesGranularityForTracepoint) and traceAllocationByte\nfor JEP331(_traceAllocationBytesForHook,\nobjectSamplingBytesGranularityForHook) independently\n\nSigned-off-by: Lin Hu <linhu@ca.ibm.com>", "committedDate": "2020-06-02T02:40:23Z", "type": "forcePushed"}, {"oid": "0b095c2c42709d99721cb48b63251f1d575eebb0", "url": "https://github.com/eclipse-openj9/openj9/commit/0b095c2c42709d99721cb48b63251f1d575eebb0", "message": "Sampling allocation bytes precisely without compromising the performance\n\nin order to sampling heap allocation bytes precisely without\ncompromising the performance, we have the below changes.\n\nHandle instrumentableAllocateHook and\nVM_OBJECT_ALLOCATE_WITHIN_THRESHOLD is still via disabling inline\nallocation\nHandle smapling for tracepoint is still during out of line allocation\nHandle smapling for JEP331 is via setTLHSamplingTop(size)\n\nUsing fake Heap Top instead of fake Heap Alloc for disabling inline\nallocation (realHeapAlloc-->realHeapTop,\nset/getRealAlloc()-->set/getRealTop(), getRealSize(), getUsedSize())\nUsing fake Heap Top to force out of line allocation at sampling thresold\nfor sampling heap allocation (setTLHSamplingTop()/resetTLHSamplingTop())\nsetTLHSamplingTop(size) are only called in the below 3 cases\n\t1, sampling threshold has been changed via GC-VM api\nj9gc_set_allocation_sampling_interval()\n\t2, TLH is refreshed\n\t3, after sampling is done\n\nCounting trace allocation byte includes allocation bytes inside TLH\nCache before flushing(_stats.bytesAllocated(true),\nstats->_tlhAllocatedUsed, )\nHandle traceAllocationByte for Health\nCenter(_oolTraceAllocationBytesForTracepoint,\noolObjectSamplingBytesGranularityForTracepoint) and traceAllocationByte\nfor JEP331(_traceAllocationBytesForHook,\nobjectSamplingBytesGranularityForHook) independently\n\nSigned-off-by: Lin Hu <linhu@ca.ibm.com>", "committedDate": "2020-06-02T15:08:29Z", "type": "forcePushed"}, {"oid": "502edcd17f84c254e74a42242e8c08409d86c078", "url": "https://github.com/eclipse-openj9/openj9/commit/502edcd17f84c254e74a42242e8c08409d86c078", "message": "Sampling allocation bytes precisely without compromising the performance\n\nin order to sampling heap allocation bytes precisely without\ncompromising the performance, we have the below changes.\n\nHandle instrumentableAllocateHook and\nVM_OBJECT_ALLOCATE_WITHIN_THRESHOLD is still via disabling inline\nallocation\nHandle smapling for tracepoint is still during out of line allocation\nHandle smapling for JEP331 is via setTLHSamplingTop(size)\n\nUsing fake Heap Top instead of fake Heap Alloc for disabling inline\nallocation (realHeapAlloc-->realHeapTop,\nset/getRealAlloc()-->set/getRealTop(), getRealSize(), getUsedSize())\nUsing fake Heap Top to force out of line allocation at sampling thresold\nfor sampling heap allocation (setTLHSamplingTop()/resetTLHSamplingTop())\nsetTLHSamplingTop(size) are only called in the below 3 cases\n\t1, sampling threshold has been changed via GC-VM api\nj9gc_set_allocation_sampling_interval()\n\t2, TLH is refreshed\n\t3, after sampling is done\n\nCounting trace allocation byte includes allocation bytes inside TLH\nCache before flushing(_stats.bytesAllocated(true),\nstats->_tlhAllocatedUsed, )\nHandle traceAllocationByte for Health\nCenter(_oolTraceAllocationBytesForTracepoint,\noolObjectSamplingBytesGranularityForTracepoint) and traceAllocationByte\nfor JEP331(_traceAllocationBytesForHook,\nobjectSamplingBytesGranularityForHook) independently\n\nSigned-off-by: Lin Hu <linhu@ca.ibm.com>", "committedDate": "2020-06-02T16:02:35Z", "type": "forcePushed"}, {"oid": "5402cf7fc7be87a3c5724e66db29e8e9b2a7cbf7", "url": "https://github.com/eclipse-openj9/openj9/commit/5402cf7fc7be87a3c5724e66db29e8e9b2a7cbf7", "message": "Sampling allocation bytes precisely without compromising the performance\n\nin order to sampling heap allocation bytes precisely without\ncompromising the performance, we have the below changes.\n\nHandle instrumentableAllocateHook and\nVM_OBJECT_ALLOCATE_WITHIN_THRESHOLD is still via disabling inline\nallocation\nHandle smapling for tracepoint is still during out of line allocation\nHandle smapling for JEP331 is via setTLHSamplingTop(size)\n\nUsing fake Heap Top instead of fake Heap Alloc for disabling inline\nallocation (realHeapAlloc-->realHeapTop,\nset/getRealAlloc()-->set/getRealTop(), getRealSize(), getUsedSize())\nUsing fake Heap Top to force out of line allocation at sampling thresold\nfor sampling heap allocation (setTLHSamplingTop()/resetTLHSamplingTop())\nsetTLHSamplingTop(size) are only called in the below 3 cases\n\t1, sampling threshold has been changed via GC-VM api\nj9gc_set_allocation_sampling_interval()\n\t2, TLH is refreshed\n\t3, after sampling is done\n\nCounting trace allocation byte includes allocation bytes inside TLH\nCache before flushing(_stats.bytesAllocated(true),\nstats->_tlhAllocatedUsed, )\nHandle traceAllocationByte for Health\nCenter(_oolTraceAllocationBytesForTracepoint,\noolObjectSamplingBytesGranularityForTracepoint) and traceAllocationByte\nfor JEP331(_traceAllocationBytesForHook,\nobjectSamplingBytesGranularityForHook) independently\n\nSigned-off-by: Lin Hu <linhu@ca.ibm.com>", "committedDate": "2020-06-02T19:17:00Z", "type": "forcePushed"}, {"oid": "e07dcc466b56a6fb26b1bc499a62adcebb1e6549", "url": "https://github.com/eclipse-openj9/openj9/commit/e07dcc466b56a6fb26b1bc499a62adcebb1e6549", "message": "Sampling allocation bytes precisely without compromising the performance\n\nin order to sampling heap allocation bytes precisely without\ncompromising the performance, we have the below changes.\n\nHandle instrumentableAllocateHook and\nVM_OBJECT_ALLOCATE_WITHIN_THRESHOLD is still via disabling inline\nallocation\nHandle smapling for tracepoint is still during out of line allocation\nHandle smapling for JEP331 is via setTLHSamplingTop(size)\n\nUsing fake Heap Top instead of fake Heap Alloc for disabling inline\nallocation (realHeapAlloc-->realHeapTop,\nset/getRealAlloc()-->set/getRealTop(), getRealSize(), getUsedSize())\nUsing fake Heap Top to force out of line allocation at sampling thresold\nfor sampling heap allocation (setTLHSamplingTop()/resetTLHSamplingTop())\nsetTLHSamplingTop(size) are only called in the below 3 cases\n\t1, sampling threshold has been changed via GC-VM api\nj9gc_set_allocation_sampling_interval()\n\t2, TLH is refreshed\n\t3, after sampling is done\n\nCounting trace allocation byte includes allocation bytes inside TLH\nCache before flushing(_stats.bytesAllocated(true),\nstats->_tlhAllocatedUsed, )\nHandle traceAllocationByte for Health\nCenter(_oolTraceAllocationBytesForTracepoint,\noolObjectSamplingBytesGranularityForTracepoint) and traceAllocationByte\nfor JEP331(_traceAllocationBytesForHook,\nobjectSamplingBytesGranularityForHook) independently\n\nSigned-off-by: Lin Hu <linhu@ca.ibm.com>", "committedDate": "2020-06-03T20:14:00Z", "type": "forcePushed"}, {"oid": "02d2c1bb10337124fa21680748a004cc72083808", "url": "https://github.com/eclipse-openj9/openj9/commit/02d2c1bb10337124fa21680748a004cc72083808", "message": "Sampling allocation bytes precisely without compromising the performance\n\nin order to sampling heap allocation bytes precisely without\ncompromising the performance, we have the below changes.\n\nHandle instrumentableAllocateHook and\nVM_OBJECT_ALLOCATE_WITHIN_THRESHOLD is still via disabling inline\nallocation\nHandle smapling for tracepoint is still during out of line allocation\nHandle smapling for JEP331 is via setTLHSamplingTop(size)\n\nUsing fake Heap Top instead of fake Heap Alloc for disabling inline\nallocation (realHeapAlloc-->realHeapTop,\nset/getRealAlloc()-->set/getRealTop(), getRealSize(), getUsedSize())\nUsing fake Heap Top to force out of line allocation at sampling thresold\nfor sampling heap allocation (setTLHSamplingTop()/resetTLHSamplingTop())\nsetTLHSamplingTop(size) are only called in the below 3 cases\n\t1, sampling threshold has been changed via GC-VM api\nj9gc_set_allocation_sampling_interval()\n\t2, TLH is refreshed\n\t3, after sampling is done\n\nCounting trace allocation byte includes allocation bytes inside TLH\nCache before flushing(_stats.bytesAllocated(true),\nstats->_tlhAllocatedUsed, )\nHandle traceAllocationByte for Health\nCenter(_oolTraceAllocationBytesForTracepoint,\noolObjectSamplingBytesGranularityForTracepoint) and traceAllocationByte\nfor JEP331(_traceAllocationBytesForHook,\nobjectSamplingBytesGranularityForHook) independently\n\nSigned-off-by: Lin Hu <linhu@ca.ibm.com>", "committedDate": "2020-06-03T20:50:02Z", "type": "forcePushed"}, {"oid": "3e1814067f92394aa73a773e15a8f83e9c43990c", "url": "https://github.com/eclipse-openj9/openj9/commit/3e1814067f92394aa73a773e15a8f83e9c43990c", "message": "Sampling allocation bytes precisely without compromising the performance\n\nin order to sampling heap allocation bytes precisely without\ncompromising the performance, we have the below changes.\n\nHandle instrumentableAllocateHook and\nVM_OBJECT_ALLOCATE_WITHIN_THRESHOLD is still via disabling inline\nallocation\nHandle smapling for tracepoint is still during out of line allocation\nHandle smapling for JEP331 is via setTLHSamplingTop(size)\n\nUsing fake Heap Top instead of fake Heap Alloc for disabling inline\nallocation (realHeapAlloc-->realHeapTop,\nset/getRealAlloc()-->set/getRealTop(), getRealSize(), getUsedSize())\nUsing fake Heap Top to force out of line allocation at sampling thresold\nfor sampling heap allocation (setTLHSamplingTop()/resetTLHSamplingTop())\nsetTLHSamplingTop(size) are only called in the below 3 cases\n\t1, sampling threshold has been changed via GC-VM api\nj9gc_set_allocation_sampling_interval()\n\t2, TLH is refreshed\n\t3, after sampling is done\n\nCounting trace allocation byte includes allocation bytes inside TLH\nCache before flushing(_stats.bytesAllocated(true),\nstats->_tlhAllocatedUsed, )\nHandle traceAllocationByte for Health\nCenter(_oolTraceAllocationBytesForTracepoint,\noolObjectSamplingBytesGranularityForTracepoint) and traceAllocationByte\nfor JEP331(_traceAllocationBytesForHook,\nobjectSamplingBytesGranularityForHook) independently\n\nSigned-off-by: Lin Hu <linhu@ca.ibm.com>", "committedDate": "2020-06-03T21:12:34Z", "type": "forcePushed"}, {"oid": "86eb95857b3d16128ee37448649f80ab7615d635", "url": "https://github.com/eclipse-openj9/openj9/commit/86eb95857b3d16128ee37448649f80ab7615d635", "message": "Sampling allocation bytes precisely without compromising the performance\n\nin order to sampling heap allocation bytes precisely without\ncompromising the performance, we have the below changes.\n\nHandle instrumentableAllocateHook and\nVM_OBJECT_ALLOCATE_WITHIN_THRESHOLD is still via disabling inline\nallocation\nHandle smapling for tracepoint is still during out of line allocation\nHandle smapling for JEP331 is via setTLHSamplingTop(size)\n\nUsing fake Heap Top instead of fake Heap Alloc for disabling inline\nallocation (realHeapAlloc-->realHeapTop,\nset/getRealAlloc()-->set/getRealTop(), getRealSize(), getUsedSize())\nUsing fake Heap Top to force out of line allocation at sampling thresold\nfor sampling heap allocation (setTLHSamplingTop()/resetTLHSamplingTop())\nsetTLHSamplingTop(size) are only called in the below 3 cases\n\t1, sampling threshold has been changed via GC-VM api\nj9gc_set_allocation_sampling_interval()\n\t2, TLH is refreshed\n\t3, after sampling is done\n\nCounting trace allocation byte includes allocation bytes inside TLH\nCache before flushing(_stats.bytesAllocated(true),\nstats->_tlhAllocatedUsed, )\nHandle traceAllocationByte for Health\nCenter(_oolTraceAllocationBytesForTracepoint,\noolObjectSamplingBytesGranularityForTracepoint) and traceAllocationByte\nfor JEP331(_traceAllocationBytesForHook,\nobjectSamplingBytesGranularityForHook) independently\n\nSigned-off-by: Lin Hu <linhu@ca.ibm.com>", "committedDate": "2020-06-04T13:48:55Z", "type": "forcePushed"}, {"oid": "d2dd5591146ad6d9c1690cd2be03d9dd7e187452", "url": "https://github.com/eclipse-openj9/openj9/commit/d2dd5591146ad6d9c1690cd2be03d9dd7e187452", "message": "Sampling allocation bytes precisely without compromising the performance\n\nin order to sampling heap allocation bytes precisely without\ncompromising the performance, we have the below changes.\n\nHandle instrumentableAllocateHook and\nVM_OBJECT_ALLOCATE_WITHIN_THRESHOLD is still via disabling inline\nallocation\nHandle smapling for tracepoint is still during out of line allocation\nHandle smapling for JEP331 is via setTLHSamplingTop(size)\n\nUsing fake Heap Top instead of fake Heap Alloc for disabling inline\nallocation (realHeapAlloc-->realHeapTop,\nset/getRealAlloc()-->set/getRealTop(), getRealSize(), getUsedSize())\nUsing fake Heap Top to force out of line allocation at sampling thresold\nfor sampling heap allocation (setTLHSamplingTop()/resetTLHSamplingTop())\nsetTLHSamplingTop(size) are only called in the below 3 cases\n\t1, sampling threshold has been changed via GC-VM api\nj9gc_set_allocation_sampling_interval()\n\t2, TLH is refreshed\n\t3, after sampling is done\n\nCounting trace allocation byte includes allocation bytes inside TLH\nCache before flushing(_stats.bytesAllocated(true),\nstats->_tlhAllocatedUsed, )\nHandle traceAllocationByte for Health\nCenter(_oolTraceAllocationBytesForTracepoint,\noolObjectSamplingBytesGranularityForTracepoint) and traceAllocationByte\nfor JEP331(_traceAllocationBytesForHook,\nobjectSamplingBytesGranularityForHook) independently\n\nSigned-off-by: Lin Hu <linhu@ca.ibm.com>", "committedDate": "2020-06-04T13:53:34Z", "type": "commit"}, {"oid": "d2dd5591146ad6d9c1690cd2be03d9dd7e187452", "url": "https://github.com/eclipse-openj9/openj9/commit/d2dd5591146ad6d9c1690cd2be03d9dd7e187452", "message": "Sampling allocation bytes precisely without compromising the performance\n\nin order to sampling heap allocation bytes precisely without\ncompromising the performance, we have the below changes.\n\nHandle instrumentableAllocateHook and\nVM_OBJECT_ALLOCATE_WITHIN_THRESHOLD is still via disabling inline\nallocation\nHandle smapling for tracepoint is still during out of line allocation\nHandle smapling for JEP331 is via setTLHSamplingTop(size)\n\nUsing fake Heap Top instead of fake Heap Alloc for disabling inline\nallocation (realHeapAlloc-->realHeapTop,\nset/getRealAlloc()-->set/getRealTop(), getRealSize(), getUsedSize())\nUsing fake Heap Top to force out of line allocation at sampling thresold\nfor sampling heap allocation (setTLHSamplingTop()/resetTLHSamplingTop())\nsetTLHSamplingTop(size) are only called in the below 3 cases\n\t1, sampling threshold has been changed via GC-VM api\nj9gc_set_allocation_sampling_interval()\n\t2, TLH is refreshed\n\t3, after sampling is done\n\nCounting trace allocation byte includes allocation bytes inside TLH\nCache before flushing(_stats.bytesAllocated(true),\nstats->_tlhAllocatedUsed, )\nHandle traceAllocationByte for Health\nCenter(_oolTraceAllocationBytesForTracepoint,\noolObjectSamplingBytesGranularityForTracepoint) and traceAllocationByte\nfor JEP331(_traceAllocationBytesForHook,\nobjectSamplingBytesGranularityForHook) independently\n\nSigned-off-by: Lin Hu <linhu@ca.ibm.com>", "committedDate": "2020-06-04T13:53:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2Mzk0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9745#discussion_r435563949", "bodyText": "This will fail with NoSuchFieldError when examining core files created before the addition of realHeapTop.", "author": "keithc-ca", "createdAt": "2020-06-04T21:29:56Z", "path": "debugtools/DDR_VM/src/com/ibm/j9ddr/vm29/j9/gc/GCObjectHeapIteratorAddressOrderedList_V1.java", "diffHunk": "@@ -75,9 +75,9 @@ protected GCObjectHeapIteratorAddressOrderedList_V1(U8Pointer base, U8Pointer to\n \t\t\t\t\t\texcludedRangeList.add(new U8Pointer[] {heapAlloc, heapTop});\n \t\t\t\t\t} else {\n \t\t\t\t\t\t/* Might be an instrumented VM */\n-\t\t\t\t\t\tU8Pointer realHeapAlloc = adjustedToRange(vmThread.allocateThreadLocalHeap().realHeapAlloc(), base, top);\n-\t\t\t\t\t\tif(realHeapAlloc.notNull() && isSomethingToAdd(realHeapAlloc, heapTop)) {\n-\t\t\t\t\t\t\texcludedRangeList.add(new U8Pointer[] {realHeapAlloc, heapTop});\n+\t\t\t\t\t\tU8Pointer realHeapTop = adjustedToRange(vmThread.allocateThreadLocalHeap().realHeapTop(), base, top);", "originalCommit": "d2dd5591146ad6d9c1690cd2be03d9dd7e187452", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5MDAyNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9745#discussion_r435590025", "bodyText": "Good point, thank you very much.", "author": "dmitripivkine", "createdAt": "2020-06-04T22:37:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2Mzk0OQ=="}], "type": "inlineReview"}]}