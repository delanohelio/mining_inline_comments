{"pr_number": 11489, "pr_title": "Refine receiver class based on CP class of callsite", "pr_createdAt": "2020-12-16T14:24:18Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/11489", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ4OTk3Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11489#discussion_r544489973", "bodyText": "Should you output the new refined receiver class address that was found as part of this trace message?  Outputting which invokevirtual it was would also be useful.", "author": "0xdaryl", "createdAt": "2020-12-16T17:34:00Z", "path": "runtime/compiler/optimizer/J9Inliner.cpp", "diffHunk": "@@ -552,6 +552,29 @@ bool TR_J9VirtualCallSite::findCallSiteTarget(TR_CallStack *callStack, TR_Inline\n \n    tryToRefineReceiverClassBasedOnResolvedTypeArgInfo(inliner);\n \n+   // Refine receiver class based on CP class\n+   // When we have an invokevirtual on an abstract method defined in an interface class,\n+   // the call site's class will be more concrete than class of method.\n+   // This happens when an abstract class implements an interface class without providing\n+   // implementation for the given method, and the call site is refering to the method of\n+   // the abstract class, the cp entry of the method ref will be resolved to j9method of\n+   // the interface class. However, the class ref from cp will be resolved to the abstract\n+   // class, which is more concrete\n+   //\n+   if (_cpIndex != -1 && _receiverClass && TR::Compiler->cls.isInterfaceClass(comp(), _receiverClass))\n+      {\n+      TR_ResolvedMethod* owningMethod = _initialCalleeMethod->owningMethod();\n+      int32_t classRefCPIndex = owningMethod->classCPIndexOfMethod(_cpIndex);\n+      TR_OpaqueClassBlock* callSiteClass = owningMethod->getClassFromConstantPool(comp(), classRefCPIndex);\n+      if (callSiteClass &&\n+          callSiteClass != _receiverClass &&\n+          fe()->isInstanceOf(callSiteClass, _receiverClass, true, true, false) == TR_yes)\n+         {\n+         heuristicTrace(inliner->tracer(), \"Receiver type is class of an interface method for invokevirtual, improve it to call site receiver type\\n\");", "originalCommit": "d1cd10645acacd3fc59d6946382897ae7d949b66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2NjA3Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/11489#discussion_r545366076", "bodyText": "@0xdaryl Added change to print out the old and new class info", "author": "liqunl", "createdAt": "2020-12-17T19:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ4OTk3Mw=="}], "type": "inlineReview"}, {"oid": "02f66821939cca297cfb325317710c53d97c55e3", "url": "https://github.com/eclipse-openj9/openj9/commit/02f66821939cca297cfb325317710c53d97c55e3", "message": "Refine receiver class based on CP class of callsite\n\nWhen we have an invokevirtual on an abstract method defined in an\ninterface class, the call site's class will be more concrete than class\nof method.\n\nThis happens when an abstract class implements an interface class\nwithout providing implementation for the given method, and the call site\nis refering to the method of the abstract class, the cp entry of the\nmethod ref will be resolved to j9method of the interface class. However,\nthe class ref from cp will be resolved to the abstract class, which is\nmore concrete\n\nSigned-off-by: Liqun Liu <liqunl@ca.ibm.com>", "committedDate": "2020-12-17T15:55:42Z", "type": "forcePushed"}, {"oid": "f65c35c8cb06b69f84f42ebef2eb4e03646b4030", "url": "https://github.com/eclipse-openj9/openj9/commit/f65c35c8cb06b69f84f42ebef2eb4e03646b4030", "message": "Refine receiver class based on CP class of callsite\n\nWhen we have an invokevirtual on an abstract method defined in an\ninterface class, the call site's class will be more concrete than class\nof method.\n\nThis happens when an abstract class implements an interface class\nwithout providing implementation for the given method, and the call site\nis refering to the method of the abstract class, the cp entry of the\nmethod ref will be resolved to j9method of the interface class. However,\nthe class ref from cp will be resolved to the abstract class, which is\nmore concrete\n\nSigned-off-by: Liqun Liu <liqunl@ca.ibm.com>", "committedDate": "2020-12-17T17:10:56Z", "type": "commit"}, {"oid": "f65c35c8cb06b69f84f42ebef2eb4e03646b4030", "url": "https://github.com/eclipse-openj9/openj9/commit/f65c35c8cb06b69f84f42ebef2eb4e03646b4030", "message": "Refine receiver class based on CP class of callsite\n\nWhen we have an invokevirtual on an abstract method defined in an\ninterface class, the call site's class will be more concrete than class\nof method.\n\nThis happens when an abstract class implements an interface class\nwithout providing implementation for the given method, and the call site\nis refering to the method of the abstract class, the cp entry of the\nmethod ref will be resolved to j9method of the interface class. However,\nthe class ref from cp will be resolved to the abstract class, which is\nmore concrete\n\nSigned-off-by: Liqun Liu <liqunl@ca.ibm.com>", "committedDate": "2020-12-17T17:10:56Z", "type": "forcePushed"}]}