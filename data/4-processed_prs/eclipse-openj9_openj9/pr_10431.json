{"pr_number": 10431, "pr_title": "Fix class unloading processing in classBySignature cache", "pr_createdAt": "2020-08-20T17:09:33Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10431", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY3Mzg5MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10431#discussion_r475673890", "bodyText": "Why don't we add methodClassLoader in this case?", "author": "mpirvu", "createdAt": "2020-08-24T14:55:41Z", "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -299,19 +299,64 @@ TR_J9ServerVM::getClassFromSignature(const char *sig, int32_t length, TR_Resolve\n    TR_OpaqueClassBlock * clazz = NULL;\n    J9ClassLoader * cl = ((TR_ResolvedJ9Method *)method)->getClassLoader();\n    ClassLoaderStringPair key = {cl, std::string(sig, length)};\n-   PersistentUnorderedMap<ClassLoaderStringPair, TR_OpaqueClassBlock*> & classBySignatureMap = _compInfoPT->getClientData()->getClassBySignatureMap();\n+   PersistentUnorderedMap<ClassLoaderStringPair, ClassFromSignatureData> &classBySignatureMap = _compInfoPT->getClientData()->getClassBySignatureMap();\n       {\n       OMR::CriticalSection classFromSigCS(_compInfoPT->getClientData()->getClassMapMonitor());\n       auto it = classBySignatureMap.find(key);\n       if (it != classBySignatureMap.end())\n-         return it->second;\n+         clazz = it->second._clazz;\n+\n+      if (!clazz)\n+         {\n+         key._classLoader = reinterpret_cast<J9ClassLoader *>(getSystemClassLoader());\n+         it = classBySignatureMap.find(key);\n+         if (it != classBySignatureMap.end())\n+            {\n+            // if this class loader previously referenced system class loader, we can return safely\n+            if (it->second.isClassLoaderVisible(cl))\n+               clazz = it->second._clazz;\n+            }\n+         }\n+      }\n+   if (clazz)\n+      {\n+#if defined(DEBUG)\n+      // make sure the cached class matches the client class\n+      TR_OpaqueClassBlock *clientClass = getClassFromSignature(sig, length, (TR_OpaqueMethodBlock *)method->getPersistentIdentifier(), isVettedForAOT);\n+      TR_ASSERT_FATAL(clientClass == clazz, \"Client and cached classes do not match: clientClass=%p cachedClass=%p\\n\", clientClass, clazz);\n+#endif\n+      return clazz;\n       }\n    // classname not found; ask the client and cache the answer\n    clazz = getClassFromSignature(sig, length, (TR_OpaqueMethodBlock *)method->getPersistentIdentifier(), isVettedForAOT);\n+   return clazz;\n+   }\n+\n+\n+TR_OpaqueClassBlock *\n+TR_J9ServerVM::getClassFromSignature(const char *sig, int32_t length, TR_OpaqueMethodBlock *method, bool isVettedForAOT)\n+   {\n+   JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+   std::string str(sig, length);\n+   stream->write(JITServer::MessageType::VM_getClassFromSignature, str, method, isVettedForAOT);\n+   auto recv = stream->read<TR_OpaqueClassBlock *, J9ClassLoader *, J9ClassLoader *>();\n+   TR_OpaqueClassBlock *clazz = std::get<0>(recv);\n+   J9ClassLoader *cl = std::get<1>(recv);\n+   J9ClassLoader *methodClassLoader = std::get<2>(recv);\n    if (clazz)\n       {\n       OMR::CriticalSection classFromSigCS(_compInfoPT->getClientData()->getClassMapMonitor());\n-      classBySignatureMap[key] = clazz;\n+      PersistentUnorderedMap<ClassLoaderStringPair, ClassFromSignatureData> &classBySignatureMap = _compInfoPT->getClientData()->getClassBySignatureMap();\n+      ClassLoaderStringPair key = {cl, std::string(sig, length)};\n+      auto it = classBySignatureMap.find(key);\n+      if (it != classBySignatureMap.end())\n+         {\n+         // if we are here, that means the current class loader hasn't been encountered yet\n+         it->second.addClassLoader(methodClassLoader);\n+         TR_ASSERT_FATAL(clazz == it->second._clazz, \"Cached and client answers do not match: cached=%p client=%p\\n\", it->second._clazz, clazz);\n+         return it->second._clazz;\n+         }\n+      classBySignatureMap.insert({ key, ClassFromSignatureData(clazz) });", "originalCommit": "de5194d1d31c91b6f64e0ddab4784e36d4619267", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY4Mzg3Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10431#discussion_r475683873", "bodyText": "Is it possible to have a NULL cached clazz? If not, then we don't need another test, but rather add an else statement to if (it != classBySignatureMap.end())", "author": "mpirvu", "createdAt": "2020-08-24T15:04:35Z", "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -299,19 +299,64 @@ TR_J9ServerVM::getClassFromSignature(const char *sig, int32_t length, TR_Resolve\n    TR_OpaqueClassBlock * clazz = NULL;\n    J9ClassLoader * cl = ((TR_ResolvedJ9Method *)method)->getClassLoader();\n    ClassLoaderStringPair key = {cl, std::string(sig, length)};\n-   PersistentUnorderedMap<ClassLoaderStringPair, TR_OpaqueClassBlock*> & classBySignatureMap = _compInfoPT->getClientData()->getClassBySignatureMap();\n+   PersistentUnorderedMap<ClassLoaderStringPair, ClassFromSignatureData> &classBySignatureMap = _compInfoPT->getClientData()->getClassBySignatureMap();\n       {\n       OMR::CriticalSection classFromSigCS(_compInfoPT->getClientData()->getClassMapMonitor());\n       auto it = classBySignatureMap.find(key);\n       if (it != classBySignatureMap.end())\n-         return it->second;\n+         clazz = it->second._clazz;\n+\n+      if (!clazz)", "originalCommit": "de5194d1d31c91b6f64e0ddab4784e36d4619267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTczMTEwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10431#discussion_r475731107", "bodyText": "True, will fix.", "author": "dmitry-ten", "createdAt": "2020-08-24T16:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY4Mzg3Mw=="}], "type": "inlineReview"}, {"oid": "59779772b56857d536038a82fde92515b7931345", "url": "https://github.com/eclipse-openj9/openj9/commit/59779772b56857d536038a82fde92515b7931345", "message": "Fix class loader mismatch in classBySignature cache\n\nWhen caching the result of `getClassFromSignature` we incorrectly\nassume that the class loader of the referencing constant pool\nis the same as class loader of the resulting class.\nThe most frequent case when that is not true is when a non-system\nclass references a system class, thus the class loader of the result\nwill be the system class loader. The problem is that when we delete\nunloaded classes from the cache, we use the actual class loader\nas key, instead of referencing one which will result in entries\nfor unloaded classes not being deleted properly.\n\nThis commit fixes the issue by caching using the actual class loader\nof the result and storing which class loaders referenced each cache\nentry.\nIn the case that we have a cached entry but detect class loader\nmismatch, we are allowed to use the cached entry only if the class\nloader\nreferenced this class previously.\n\nCloses: #10397\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-08-24T17:06:49Z", "type": "forcePushed"}, {"oid": "fcd2ddbc1cfd52e185d2553c77974bad75bec8b5", "url": "https://github.com/eclipse-openj9/openj9/commit/fcd2ddbc1cfd52e185d2553c77974bad75bec8b5", "message": "Fix class unloading processing in classBySignature cache\n\nWhen caching the result of `TR_J9ServerVM::getClassFromSignature`\nwe incorrectly assume that the class loader of the referencing constant pool\nis the same as class loader of the resulting class.\nThe problem is that when we delete unloaded classes from the cache,\nwe use the actual class loader as key, instead of referencing one\nwhich will result in entries for unloaded classes not being deleted properly.\n\nThis commit fixes it by keeping track of which class loaders reference\na class in `ClassInfo`. When processing unloaded classes, we find\ncorrect entries for deletion by retrieving class loaders from\n`ClassInfo`.\n\nCloses: #10397\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-08-25T18:31:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjgxNjQ2Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10431#discussion_r476816467", "bodyText": "This is a typo: == needs to become !=", "author": "mpirvu", "createdAt": "2020-08-25T22:50:34Z", "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -332,7 +332,26 @@ TR_J9ServerVM::getClassFromSignature(const char *sig, int32_t length, TR_OpaqueM\n    JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n    std::string str(sig, length);\n    stream->write(JITServer::MessageType::VM_getClassFromSignature, str, method, isVettedForAOT);\n-   return std::get<0>(stream->read<TR_OpaqueClassBlock *>());\n+   auto recv = stream->read<TR_OpaqueClassBlock *, J9ClassLoader *, J9ClassLoader *>();\n+   TR_OpaqueClassBlock *clazz = std::get<0>(recv);\n+   J9ClassLoader *cl = std::get<1>(recv);\n+   J9ClassLoader *methodClassLoader = std::get<2>(recv);\n+   if (clazz && cl != methodClassLoader)\n+      {\n+      // make sure that the class is cached\n+      J9ROMClass *romClass = TR::Compiler->cls.romClassOf(clazz);\n+      TR_ASSERT_FATAL(romClass, \"class %p could not be cached\", clazz);\n+      OMR::CriticalSection getRemoteROMClass(_compInfoPT->getClientData()->getROMMapMonitor());\n+      auto it = _compInfoPT->getClientData()->getROMClassMap().find(reinterpret_cast<J9Class *>(clazz));\n+      if (it == _compInfoPT->getClientData()->getROMClassMap().end())", "originalCommit": "fcd2ddbc1cfd52e185d2553c77974bad75bec8b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM2OTM5Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10431#discussion_r477369397", "bodyText": "Fixed.", "author": "dmitry-ten", "createdAt": "2020-08-26T14:59:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjgxNjQ2Nw=="}], "type": "inlineReview"}, {"oid": "4eb2fbd1c3a716265269c8c9b60f79a63c09d6a5", "url": "https://github.com/eclipse-openj9/openj9/commit/4eb2fbd1c3a716265269c8c9b60f79a63c09d6a5", "message": "Fix class unloading processing in classBySignature cache\n\nWhen caching the result of `TR_J9ServerVM::getClassFromSignature`\nwe incorrectly assume that the class loader of the referencing constant pool\nis the same as class loader of the resulting class.\nThe problem is that when we delete unloaded classes from the cache,\nwe use the actual class loader as key, instead of referencing one\nwhich will result in entries for unloaded classes not being deleted properly.\n\nThis commit fixes it by keeping track of which class loaders reference\na class in `ClassInfo`. When processing unloaded classes, we find\ncorrect entries for deletion by retrieving class loaders from\n`ClassInfo`.\n\nCloses: #10397\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-08-26T14:59:40Z", "type": "commit"}, {"oid": "4eb2fbd1c3a716265269c8c9b60f79a63c09d6a5", "url": "https://github.com/eclipse-openj9/openj9/commit/4eb2fbd1c3a716265269c8c9b60f79a63c09d6a5", "message": "Fix class unloading processing in classBySignature cache\n\nWhen caching the result of `TR_J9ServerVM::getClassFromSignature`\nwe incorrectly assume that the class loader of the referencing constant pool\nis the same as class loader of the resulting class.\nThe problem is that when we delete unloaded classes from the cache,\nwe use the actual class loader as key, instead of referencing one\nwhich will result in entries for unloaded classes not being deleted properly.\n\nThis commit fixes it by keeping track of which class loaders reference\na class in `ClassInfo`. When processing unloaded classes, we find\ncorrect entries for deletion by retrieving class loaders from\n`ClassInfo`.\n\nCloses: #10397\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-08-26T14:59:40Z", "type": "forcePushed"}]}