{"pr_number": 10274, "pr_title": "JEP383 Support Part 4", "pr_createdAt": "2020-07-28T17:11:47Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10274", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkzNTI1Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r461935252", "bodyText": "This IAE was triggered by JEP383 tests. I initially disabled it for Java15 but it didn't look correct. I have introduced a better solution in the HEAD commit, Avoid Lookup doCheck if full privilege access is acquired.", "author": "babsingh", "createdAt": "2020-07-28T22:44:42Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -204,12 +204,14 @@\n \t\t\n \t\tLookup(Class<?> lookupClass, Class<?> prevLookupClass, int lookupMode, boolean doCheck) {\n \t\t\tthis.performSecurityCheck = doCheck;\n+\t\t\t/*[IF !Java15]*/\n \t\t\tif (doCheck && (INTERNAL_PRIVILEGED != lookupMode)) {\n \t\t\t\tif (lookupClass.getName().startsWith(\"java.lang.invoke.\")) {  //$NON-NLS-1$\n \t\t\t\t\t/*[MSG \"K0588\", \"Illegal Lookup object - originated from java.lang.invoke: {0}\"]*/\n \t\t\t\t\tthrow new IllegalArgumentException(com.ibm.oti.util.Msg.getString(\"K0588\", lookupClass.getName())); //$NON-NLS-1$", "originalCommit": "d86d846e1829eca5afe7fff14ba305bb078bc864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4NDQ2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r466584464", "bodyText": "@JasonFengJ9 has a PR to address the java.lang.invoke package check that's being reviewed now.  It takes a different approach to handle the existing APIs but should cover this case as well", "author": "DanHeidinga", "createdAt": "2020-08-06T17:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkzNTI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkzOTc3MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r461939771", "bodyText": "The below code is indented into an else block. It is just old code.", "author": "babsingh", "createdAt": "2020-07-28T22:56:12Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -375,64 +375,75 @@ MethodType accessModeType(Class<?> receiver, Class<?> type, Class<?>... args) {\n \t * @param varForm an instance of VarForm.\n \t */\n \tVarHandle(VarForm varForm) {\n-\t\tAccessMode[] accessModes = AccessMode.values();\n-\t\tint numAccessModes = accessModes.length;\n-\n-\t\t/* The first argument in AccessType.GET MethodType is the receiver class. */\n-\t\tClass<?> receiverActual = accessModeTypeUncached(AccessMode.GET).parameterType(0);\n-\t\tClass<?> receiverVarForm = varForm.methodType_table[AccessType.GET.ordinal()].parameterType(0);\n-\t\t\n-\t\t/* Specify the exact operation method types if the actual receiver doesn't match the\n-\t\t * receiver derived from VarForm.\n-\t\t */\n-\t\tMethodType[] operationMTsExact = null;\n-\t\tif (receiverActual != receiverVarForm) {\n-\t\t\toperationMTsExact = new MethodType[numAccessModes];\n-\t\t}\n-\t\t\n-\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n-\t\tClass<?> operationsClass = null;\n-\n-\t\tfor (int i = 0; i < numAccessModes; i++) {\n-\t\t\tMemberName memberName = varForm.memberName_table[i];\n-\t\t\tif (memberName != null) {\n-\t\t\t\toperationMTs[i] = memberName.getMethodType();\n-\t\t\t\tif (operationMTsExact != null) {\n-\t\t\t\t\t/* Replace with the actual receiver, which is expected when the operation method\n-\t\t\t\t\t * is invoked. The receiver is the second argument.\n-\t\t\t\t\t */\n-\t\t\t\t\toperationMTsExact[i] = operationMTs[i].changeParameterType(1, receiverActual);\n-\t\t\t\t}\n-\t\t\t\tif (operationsClass == null) {\n-\t\t\t\t\toperationsClass = memberName.getDeclaringClass();\n+\t\tif (varForm.memberName_table == null) {\n+\t\t\t/* Indirect VarHandle. */\n+\t\t\tMethodType getter = varForm.methodType_table[VarHandle.AccessType.GET.ordinal()];\n+\t\t\tthis.fieldType = getter.returnType();\n+\t\t\tthis.coordinateTypes = getter.parameterArray();\n+\t\t\tthis.modifiers = 0;\n+\t\t\tthis.vform = varForm;\n+\t\t\treturn;\n+\t\t} else {\n+\t\t\t/* Direct VarHandle. */", "originalCommit": "d86d846e1829eca5afe7fff14ba305bb078bc864", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0MDE3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r461940177", "bodyText": "These new changes for IndirectVarHandle don't set handleTable. It is set in the constructor of IndirectVarHandle.", "author": "babsingh", "createdAt": "2020-07-28T22:57:27Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -375,64 +375,75 @@ MethodType accessModeType(Class<?> receiver, Class<?> type, Class<?>... args) {\n \t * @param varForm an instance of VarForm.\n \t */\n \tVarHandle(VarForm varForm) {\n-\t\tAccessMode[] accessModes = AccessMode.values();\n-\t\tint numAccessModes = accessModes.length;\n-\n-\t\t/* The first argument in AccessType.GET MethodType is the receiver class. */\n-\t\tClass<?> receiverActual = accessModeTypeUncached(AccessMode.GET).parameterType(0);\n-\t\tClass<?> receiverVarForm = varForm.methodType_table[AccessType.GET.ordinal()].parameterType(0);\n-\t\t\n-\t\t/* Specify the exact operation method types if the actual receiver doesn't match the\n-\t\t * receiver derived from VarForm.\n-\t\t */\n-\t\tMethodType[] operationMTsExact = null;\n-\t\tif (receiverActual != receiverVarForm) {\n-\t\t\toperationMTsExact = new MethodType[numAccessModes];\n-\t\t}\n-\t\t\n-\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n-\t\tClass<?> operationsClass = null;\n-\n-\t\tfor (int i = 0; i < numAccessModes; i++) {\n-\t\t\tMemberName memberName = varForm.memberName_table[i];\n-\t\t\tif (memberName != null) {\n-\t\t\t\toperationMTs[i] = memberName.getMethodType();\n-\t\t\t\tif (operationMTsExact != null) {\n-\t\t\t\t\t/* Replace with the actual receiver, which is expected when the operation method\n-\t\t\t\t\t * is invoked. The receiver is the second argument.\n-\t\t\t\t\t */\n-\t\t\t\t\toperationMTsExact[i] = operationMTs[i].changeParameterType(1, receiverActual);\n-\t\t\t\t}\n-\t\t\t\tif (operationsClass == null) {\n-\t\t\t\t\toperationsClass = memberName.getDeclaringClass();\n+\t\tif (varForm.memberName_table == null) {\n+\t\t\t/* Indirect VarHandle. */", "originalCommit": "d86d846e1829eca5afe7fff14ba305bb078bc864", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0MTk4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r461941982", "bodyText": "Creates a MethodHandle (MH) with MethodType (MT) for a VarHandle (VH) similar to the reference implementation and permutes/translates it to a MH/MT for an OpenJ9 VarHandle.", "author": "babsingh", "createdAt": "2020-07-28T23:02:39Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -515,6 +526,91 @@ static MethodHandle permuateHandleJEP370(MethodHandle methodHandle) {\n \t}\n /*[ENDIF] Java14 */\n \n+/*[IF Java15]*/\n+    /**\n+     * Generate a MethodHandle which translates:\n+     *     FROM {VarHandle, Receiver, Intermediate ..., Value}ReturnType\n+     *     TO   {Receiver, Intermediate ..., Value, VarHandle}ReturnType\n+     *\n+     * @param methodHandle to be permuted.\n+     * @return the adapter MethodHandle which performs the translation.\n+     */\n+    static MethodHandle permuateHandleReferenceToJ9(MethodHandle methodHandle) {", "originalCommit": "d86d846e1829eca5afe7fff14ba305bb078bc864", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0MjY4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r461942683", "bodyText": "This is set from java.lang.invoke.IndirectVarHandle. So, it can no longer be private or final. We can possibly add a protected method to set it, which will allow us to keep it private. Also, we can tag these changes with the Java15 flag to avoid perf impact on previous versions.", "author": "babsingh", "createdAt": "2020-07-28T23:04:54Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -345,7 +345,7 @@ MethodType accessModeType(Class<?> receiver, Class<?> type, Class<?>... args) {\n \tVarForm vform = null;\n /*[ENDIF] Java14 */\n \t\n-\tprivate final MethodHandle[] handleTable;\n+\tMethodHandle[] handleTable;", "originalCommit": "d86d846e1829eca5afe7fff14ba305bb078bc864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4NTE5NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r466585195", "bodyText": "Can you add the preprocessor tags for the private final bit so JDK11 still has the existing behaviour  (and any optimizations keyed off the access flags)", "author": "DanHeidinga", "createdAt": "2020-08-06T17:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0MjY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0Mjk4MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r461942980", "bodyText": "This method generates the handleTable for IndirectVarHandle. In this method, the permutations can be avoided if OpenJ9 VarHandle moves the VarHandle argument to the start of the MH invocation. But, it will require a massive rewrite of OpenJ9 VarHandles (Java, VM and JIT code). The current approach is taken since OpenJ9 plans to adopt OpenJDK VarHandles soon.", "author": "babsingh", "createdAt": "2020-07-28T23:05:45Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -515,6 +526,91 @@ static MethodHandle permuateHandleJEP370(MethodHandle methodHandle) {\n \t}\n /*[ENDIF] Java14 */\n \n+/*[IF Java15]*/\n+    /**\n+     * Generate a MethodHandle which translates:\n+     *     FROM {VarHandle, Receiver, Intermediate ..., Value}ReturnType\n+     *     TO   {Receiver, Intermediate ..., Value, VarHandle}ReturnType\n+     *\n+     * @param methodHandle to be permuted.\n+     * @return the adapter MethodHandle which performs the translation.\n+     */\n+    static MethodHandle permuateHandleReferenceToJ9(MethodHandle methodHandle) {\n+        /* HandleType = {Receiver, Intermediate ..., Value, VarHandle}\n+         * PermuteType = {VarHandle, Receiver, Intermediate ..., Value}\n+         */\n+\t\tMethodType permuteMethodType = methodHandle.type();\n+\t\tint parameterCount = permuteMethodType.parameterCount();\n+\t\tClass<?>[] params = permuteMethodType.parameterArray();\n+\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == 0) {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[parameterCount - 1]);\n+\t\t\t} else {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[i - 1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * reorder specifies the mapping between PermuteType and HandleType.\n+\t\t * reorder = {1, 2, ..., parameterCount - 1, 0}\n+\t\t */\n+\t\tint[] reorder = new int[parameterCount];\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == (parameterCount - 1)) {\n+\t\t\t\treorder[i] = 0;\n+\t\t\t} else {\n+\t\t\t\treorder[i] = i + 1;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn MethodHandles.permuteArguments(methodHandle, permuteMethodType, reorder);\n+    }\n+\n+\t/**\n+\t * Generates handleTable for Indirect VarHandles (supports JEP383).\n+\t *\n+\t * @param target the target VarHandle for the Indirect VarHandle.\n+\t * @param handleFactory used to transform an AccessMode MethodHandle accordingly.\n+\t * \n+\t * @return a MethodHandle array which is used to initialize the handleTable.\n+\t */\n+\tstatic MethodHandle[] populateMHsJEP383(VarHandle target, BiFunction<AccessMode, MethodHandle, MethodHandle> handleFactory) {", "originalCommit": "d86d846e1829eca5afe7fff14ba305bb078bc864", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0MzEyMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r461943120", "bodyText": "1st MH permutation. J9 -> Reference conversion, before applying handleFactory.", "author": "babsingh", "createdAt": "2020-07-28T23:06:11Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -515,6 +526,91 @@ static MethodHandle permuateHandleJEP370(MethodHandle methodHandle) {\n \t}\n /*[ENDIF] Java14 */\n \n+/*[IF Java15]*/\n+    /**\n+     * Generate a MethodHandle which translates:\n+     *     FROM {VarHandle, Receiver, Intermediate ..., Value}ReturnType\n+     *     TO   {Receiver, Intermediate ..., Value, VarHandle}ReturnType\n+     *\n+     * @param methodHandle to be permuted.\n+     * @return the adapter MethodHandle which performs the translation.\n+     */\n+    static MethodHandle permuateHandleReferenceToJ9(MethodHandle methodHandle) {\n+        /* HandleType = {Receiver, Intermediate ..., Value, VarHandle}\n+         * PermuteType = {VarHandle, Receiver, Intermediate ..., Value}\n+         */\n+\t\tMethodType permuteMethodType = methodHandle.type();\n+\t\tint parameterCount = permuteMethodType.parameterCount();\n+\t\tClass<?>[] params = permuteMethodType.parameterArray();\n+\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == 0) {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[parameterCount - 1]);\n+\t\t\t} else {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[i - 1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * reorder specifies the mapping between PermuteType and HandleType.\n+\t\t * reorder = {1, 2, ..., parameterCount - 1, 0}\n+\t\t */\n+\t\tint[] reorder = new int[parameterCount];\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == (parameterCount - 1)) {\n+\t\t\t\treorder[i] = 0;\n+\t\t\t} else {\n+\t\t\t\treorder[i] = i + 1;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn MethodHandles.permuteArguments(methodHandle, permuteMethodType, reorder);\n+    }\n+\n+\t/**\n+\t * Generates handleTable for Indirect VarHandles (supports JEP383).\n+\t *\n+\t * @param target the target VarHandle for the Indirect VarHandle.\n+\t * @param handleFactory used to transform an AccessMode MethodHandle accordingly.\n+\t * \n+\t * @return a MethodHandle array which is used to initialize the handleTable.\n+\t */\n+\tstatic MethodHandle[] populateMHsJEP383(VarHandle target, BiFunction<AccessMode, MethodHandle, MethodHandle> handleFactory) {\n+\t\tMethodHandle[] operationMHs = new MethodHandle[AccessMode.values().length];\n+\n+\t\ttry {\n+\t\t\tMethodType replaceWithDirectType = MethodType.methodType(VarHandle.class, VarHandle.class);\n+\t\t\tMethodHandle replaceWithDirect = MethodHandles.publicLookup().findStatic(VarHandle.class, \"asDirect\", replaceWithDirectType);\n+\n+\t\t\tfor (AccessMode mode : AccessMode.values()) {\n+\t\t\t\tint index = mode.ordinal();\n+\t\t\t\tMethodHandle targetHandle = target.getMethodHandle(index);\n+\n+\t\t\t\tif (targetHandle != null) {\n+\t\t\t\t\tMethodType targetType = targetHandle.type();\n+\t\t\t\t\tif (targetType.parameterType(targetType.parameterCount() - 1) == VarHandle.class) {\n+\t\t\t\t\t\t/*\n+\t\t\t\t\t\t * Permute a J9 VarHandle to an equivalent reference implementation VarHandle\n+\t\t\t\t\t\t * before applying handleFactory.\n+\t\t\t\t\t\t */\n+\t\t\t\t\t\ttargetHandle = permuateHandleReferenceToJ9(targetHandle);", "originalCommit": "d86d846e1829eca5afe7fff14ba305bb078bc864", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0MzE4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r461943182", "bodyText": "2nd MH permutation. Reference -> J9 conversion, in order to work with the J9 interpreter.", "author": "babsingh", "createdAt": "2020-07-28T23:06:21Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -515,6 +526,91 @@ static MethodHandle permuateHandleJEP370(MethodHandle methodHandle) {\n \t}\n /*[ENDIF] Java14 */\n \n+/*[IF Java15]*/\n+    /**\n+     * Generate a MethodHandle which translates:\n+     *     FROM {VarHandle, Receiver, Intermediate ..., Value}ReturnType\n+     *     TO   {Receiver, Intermediate ..., Value, VarHandle}ReturnType\n+     *\n+     * @param methodHandle to be permuted.\n+     * @return the adapter MethodHandle which performs the translation.\n+     */\n+    static MethodHandle permuateHandleReferenceToJ9(MethodHandle methodHandle) {\n+        /* HandleType = {Receiver, Intermediate ..., Value, VarHandle}\n+         * PermuteType = {VarHandle, Receiver, Intermediate ..., Value}\n+         */\n+\t\tMethodType permuteMethodType = methodHandle.type();\n+\t\tint parameterCount = permuteMethodType.parameterCount();\n+\t\tClass<?>[] params = permuteMethodType.parameterArray();\n+\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == 0) {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[parameterCount - 1]);\n+\t\t\t} else {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[i - 1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * reorder specifies the mapping between PermuteType and HandleType.\n+\t\t * reorder = {1, 2, ..., parameterCount - 1, 0}\n+\t\t */\n+\t\tint[] reorder = new int[parameterCount];\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == (parameterCount - 1)) {\n+\t\t\t\treorder[i] = 0;\n+\t\t\t} else {\n+\t\t\t\treorder[i] = i + 1;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn MethodHandles.permuteArguments(methodHandle, permuteMethodType, reorder);\n+    }\n+\n+\t/**\n+\t * Generates handleTable for Indirect VarHandles (supports JEP383).\n+\t *\n+\t * @param target the target VarHandle for the Indirect VarHandle.\n+\t * @param handleFactory used to transform an AccessMode MethodHandle accordingly.\n+\t * \n+\t * @return a MethodHandle array which is used to initialize the handleTable.\n+\t */\n+\tstatic MethodHandle[] populateMHsJEP383(VarHandle target, BiFunction<AccessMode, MethodHandle, MethodHandle> handleFactory) {\n+\t\tMethodHandle[] operationMHs = new MethodHandle[AccessMode.values().length];\n+\n+\t\ttry {\n+\t\t\tMethodType replaceWithDirectType = MethodType.methodType(VarHandle.class, VarHandle.class);\n+\t\t\tMethodHandle replaceWithDirect = MethodHandles.publicLookup().findStatic(VarHandle.class, \"asDirect\", replaceWithDirectType);\n+\n+\t\t\tfor (AccessMode mode : AccessMode.values()) {\n+\t\t\t\tint index = mode.ordinal();\n+\t\t\t\tMethodHandle targetHandle = target.getMethodHandle(index);\n+\n+\t\t\t\tif (targetHandle != null) {\n+\t\t\t\t\tMethodType targetType = targetHandle.type();\n+\t\t\t\t\tif (targetType.parameterType(targetType.parameterCount() - 1) == VarHandle.class) {\n+\t\t\t\t\t\t/*\n+\t\t\t\t\t\t * Permute a J9 VarHandle to an equivalent reference implementation VarHandle\n+\t\t\t\t\t\t * before applying handleFactory.\n+\t\t\t\t\t\t */\n+\t\t\t\t\t\ttargetHandle = permuateHandleReferenceToJ9(targetHandle);\n+\t\t\t\t\t}\n+\t\t\t\t\toperationMHs[index] = handleFactory.apply(mode, targetHandle);\n+\t\t\t\t\toperationMHs[index] = permuateHandleJ9ToReference(operationMHs[index]);", "originalCommit": "d86d846e1829eca5afe7fff14ba305bb078bc864", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0MzIyOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r461943228", "bodyText": "3rd MH permutation. Retrieve the direct-target VarHandle and pass it as an input before invoking the AccessMode MethodHandle since an IndirectVarHandle cannot be used during MH invocation.", "author": "babsingh", "createdAt": "2020-07-28T23:06:32Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -515,6 +526,91 @@ static MethodHandle permuateHandleJEP370(MethodHandle methodHandle) {\n \t}\n /*[ENDIF] Java14 */\n \n+/*[IF Java15]*/\n+    /**\n+     * Generate a MethodHandle which translates:\n+     *     FROM {VarHandle, Receiver, Intermediate ..., Value}ReturnType\n+     *     TO   {Receiver, Intermediate ..., Value, VarHandle}ReturnType\n+     *\n+     * @param methodHandle to be permuted.\n+     * @return the adapter MethodHandle which performs the translation.\n+     */\n+    static MethodHandle permuateHandleReferenceToJ9(MethodHandle methodHandle) {\n+        /* HandleType = {Receiver, Intermediate ..., Value, VarHandle}\n+         * PermuteType = {VarHandle, Receiver, Intermediate ..., Value}\n+         */\n+\t\tMethodType permuteMethodType = methodHandle.type();\n+\t\tint parameterCount = permuteMethodType.parameterCount();\n+\t\tClass<?>[] params = permuteMethodType.parameterArray();\n+\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == 0) {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[parameterCount - 1]);\n+\t\t\t} else {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[i - 1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * reorder specifies the mapping between PermuteType and HandleType.\n+\t\t * reorder = {1, 2, ..., parameterCount - 1, 0}\n+\t\t */\n+\t\tint[] reorder = new int[parameterCount];\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == (parameterCount - 1)) {\n+\t\t\t\treorder[i] = 0;\n+\t\t\t} else {\n+\t\t\t\treorder[i] = i + 1;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn MethodHandles.permuteArguments(methodHandle, permuteMethodType, reorder);\n+    }\n+\n+\t/**\n+\t * Generates handleTable for Indirect VarHandles (supports JEP383).\n+\t *\n+\t * @param target the target VarHandle for the Indirect VarHandle.\n+\t * @param handleFactory used to transform an AccessMode MethodHandle accordingly.\n+\t * \n+\t * @return a MethodHandle array which is used to initialize the handleTable.\n+\t */\n+\tstatic MethodHandle[] populateMHsJEP383(VarHandle target, BiFunction<AccessMode, MethodHandle, MethodHandle> handleFactory) {\n+\t\tMethodHandle[] operationMHs = new MethodHandle[AccessMode.values().length];\n+\n+\t\ttry {\n+\t\t\tMethodType replaceWithDirectType = MethodType.methodType(VarHandle.class, VarHandle.class);\n+\t\t\tMethodHandle replaceWithDirect = MethodHandles.publicLookup().findStatic(VarHandle.class, \"asDirect\", replaceWithDirectType);\n+\n+\t\t\tfor (AccessMode mode : AccessMode.values()) {\n+\t\t\t\tint index = mode.ordinal();\n+\t\t\t\tMethodHandle targetHandle = target.getMethodHandle(index);\n+\n+\t\t\t\tif (targetHandle != null) {\n+\t\t\t\t\tMethodType targetType = targetHandle.type();\n+\t\t\t\t\tif (targetType.parameterType(targetType.parameterCount() - 1) == VarHandle.class) {\n+\t\t\t\t\t\t/*\n+\t\t\t\t\t\t * Permute a J9 VarHandle to an equivalent reference implementation VarHandle\n+\t\t\t\t\t\t * before applying handleFactory.\n+\t\t\t\t\t\t */\n+\t\t\t\t\t\ttargetHandle = permuateHandleReferenceToJ9(targetHandle);\n+\t\t\t\t\t}\n+\t\t\t\t\toperationMHs[index] = handleFactory.apply(mode, targetHandle);\n+\t\t\t\t\toperationMHs[index] = permuateHandleJ9ToReference(operationMHs[index]);\n+\t\t\t\t\toperationMHs[index] = MethodHandles.collectArguments(operationMHs[index], operationMHs[index].type().parameterCount() - 1, replaceWithDirect);", "originalCommit": "d86d846e1829eca5afe7fff14ba305bb078bc864", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "07024e46399fea0a8bb59491f4fdeb98229d6289", "url": "https://github.com/eclipse-openj9/openj9/commit/07024e46399fea0a8bb59491f4fdeb98229d6289", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-08-06T20:33:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4ODAyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r466588022", "bodyText": "Can the zero case be moved out of the loop?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfor (int i = 0; i < parameterCount; i++) {\n          \n          \n            \n            \t\t\tif (i == 0) {\n          \n          \n            \n            \t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[parameterCount - 1]);\n          \n          \n            \n            \t\t\t} else {\n          \n          \n            \n            \t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[i - 1]);\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \tif (parameterCount > 0) {\n          \n          \n            \n            \t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[parameterCount - 1]);\n          \n          \n            \n            \t\tfor (int i = 1; i < parameterCount; i++) {\n          \n          \n            \n            \t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[i - 1]);\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t}", "author": "DanHeidinga", "createdAt": "2020-08-06T17:55:58Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -515,6 +526,91 @@ static MethodHandle permuateHandleJEP370(MethodHandle methodHandle) {\n \t}\n /*[ENDIF] Java14 */\n \n+/*[IF Java15]*/\n+    /**\n+     * Generate a MethodHandle which translates:\n+     *     FROM {VarHandle, Receiver, Intermediate ..., Value}ReturnType\n+     *     TO   {Receiver, Intermediate ..., Value, VarHandle}ReturnType\n+     *\n+     * @param methodHandle to be permuted.\n+     * @return the adapter MethodHandle which performs the translation.\n+     */\n+    static MethodHandle permuateHandleReferenceToJ9(MethodHandle methodHandle) {\n+        /* HandleType = {Receiver, Intermediate ..., Value, VarHandle}\n+         * PermuteType = {VarHandle, Receiver, Intermediate ..., Value}\n+         */\n+\t\tMethodType permuteMethodType = methodHandle.type();\n+\t\tint parameterCount = permuteMethodType.parameterCount();\n+\t\tClass<?>[] params = permuteMethodType.parameterArray();\n+\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == 0) {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[parameterCount - 1]);\n+\t\t\t} else {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[i - 1]);\n+\t\t\t}\n+\t\t}", "originalCommit": "d86d846e1829eca5afe7fff14ba305bb078bc864", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4ODgwNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r466588804", "bodyText": "Same here and it can sit inside the same if (parameterCount > 0) { as above:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tint[] reorder = new int[parameterCount];\n          \n          \n            \n            \t\tfor (int i = 0; i < parameterCount; i++) {\n          \n          \n            \n            \t\t\tif (i == (parameterCount - 1)) {\n          \n          \n            \n            \t\t\t\treorder[i] = 0;\n          \n          \n            \n            \t\t\t} else {\n          \n          \n            \n            \t\t\t\treorder[i] = i + 1;\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tint[] reorder = new int[parameterCount];\n          \n          \n            \n            \t\treorder[i] = 0;\n          \n          \n            \n            \t\tfor (int i = 0; i < parameterCount; i++) {\n          \n          \n            \n            \t\t\treorder[i] = i + 1;\n          \n          \n            \n            \t\t}", "author": "DanHeidinga", "createdAt": "2020-08-06T17:57:15Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -515,6 +526,91 @@ static MethodHandle permuateHandleJEP370(MethodHandle methodHandle) {\n \t}\n /*[ENDIF] Java14 */\n \n+/*[IF Java15]*/\n+    /**\n+     * Generate a MethodHandle which translates:\n+     *     FROM {VarHandle, Receiver, Intermediate ..., Value}ReturnType\n+     *     TO   {Receiver, Intermediate ..., Value, VarHandle}ReturnType\n+     *\n+     * @param methodHandle to be permuted.\n+     * @return the adapter MethodHandle which performs the translation.\n+     */\n+    static MethodHandle permuateHandleReferenceToJ9(MethodHandle methodHandle) {\n+        /* HandleType = {Receiver, Intermediate ..., Value, VarHandle}\n+         * PermuteType = {VarHandle, Receiver, Intermediate ..., Value}\n+         */\n+\t\tMethodType permuteMethodType = methodHandle.type();\n+\t\tint parameterCount = permuteMethodType.parameterCount();\n+\t\tClass<?>[] params = permuteMethodType.parameterArray();\n+\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == 0) {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[parameterCount - 1]);\n+\t\t\t} else {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[i - 1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * reorder specifies the mapping between PermuteType and HandleType.\n+\t\t * reorder = {1, 2, ..., parameterCount - 1, 0}\n+\t\t */\n+\t\tint[] reorder = new int[parameterCount];\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == (parameterCount - 1)) {\n+\t\t\t\treorder[i] = 0;\n+\t\t\t} else {\n+\t\t\t\treorder[i] = i + 1;\n+\t\t\t}\n+\t\t}", "originalCommit": "d86d846e1829eca5afe7fff14ba305bb078bc864", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3ODExMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r467178113", "bodyText": "Include the reference kind in the exception message to help with debugging", "author": "DanHeidinga", "createdAt": "2020-08-07T17:37:03Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -5466,12 +5494,255 @@ public Object helper(Object[] arguments) throws Throwable {\n \t}\n \n \t/*[IF Java15]*/\n-\tstatic boolean permuteArgumentChecks(int[] arr, MethodType mt1, MethodType mt2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Validates that the permute[] specifies a valid permutation from permuteType to handleType.\n+\t * This method throws IllegalArgumentException on failure and returns true on success. This\n+\t * disjointness allows it to be used in asserts.\n+\t * \n+\t * @param permute array specifies the conversion from permuteType to handleType.\n+\t * @param permuteType source method type.\n+\t * @param handleType target method type.\n+\t * \n+\t * @return true on success.\n+\t * @throws IllegalArgumentException on failure.\n+\t */\n+\tstatic boolean permuteArgumentChecks(int[] permute, MethodType permuteType, MethodType handleType) {\n+\t\treturn validatePermutationArray(permuteType, handleType, permute);\n \t}\n \t\n-\tstatic MethodHandle collectReturnValue(MethodHandle mh1, MethodHandle mh2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Return the classData stored in the accessClass of the Lookup object.\n+\t * \n+\t * @param caller Lookup object used to verify privileged access and retrieve classData.\n+\t * @param unused.\n+\t * @param type used to cast the classData of the accessClass.\n+\t * \n+\t * @return the classData casted to the appropriate type.\n+\t * @throws IllegalAccessException in the absence of full privilege access.\n+\t */\n+\tstatic <T> T classData(Lookup caller, String unused, Class<T> type) throws IllegalAccessException {\n+\t\tif (caller.hasFullPrivilegeAccess()) {\n+\t\t\tObject classData = MethodHandleNatives.classData(caller.accessClass);\n+\t\t\treturn type.cast(classData);\n+\t\t}\n+\t\tthrow new IllegalAccessException(\"No full privilege access found for \" + caller);\n+\t}\n+\n+\t/**\n+\t * Helper class used by collectReturnValue.\n+\t */\n+\tprivate static final class CollectReturnHelper implements ArgumentHelper {\n+\t\tprivate final MethodHandle target;\n+\t\tprivate final MethodHandle filter;\n+\n+\t\tCollectReturnHelper(MethodHandle target, MethodHandle filter) {\n+\t\t\tthis.target = target;\n+\t\t\tthis.filter = filter;\n+\t\t}\n+\n+\t\tpublic Object helper(Object[] arguments) throws Throwable {\n+\t\t\t// Invoke target\n+\t\t\tint targetArity = target.type.parameterCount();\n+\t\t\tObject targetReturn = target.invokeWithArguments(Arrays.copyOfRange(arguments, 0, targetArity));\n+\n+\t\t\t// Construct filter arguments\n+\t\t\tint filterArity = filter.type.parameterCount();\n+\t\t\tObject[] newArguments = new Object[filterArity];\n+\t\t\tSystem.arraycopy(arguments, targetArity, newArguments, 0, filterArity - 1);\n+\t\t\tnewArguments[filterArity - 1] = targetReturn;\n+\n+\t\t\t// Invoke filter\n+\t\t\treturn filter.invokeWithArguments(newArguments);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Creates an adapter MethodHandle (MH) which invokes the target MH and then\n+\t * invokes the filter MH while passing the output from the target MH as an\n+\t * input to the filter MH.\n+\t * \n+\t * targetMH:  O target(P...)\n+\t * filterMH:  Q filter(R..., O)\n+\t * adapterMH: Q adapter(P... p, R... r) {\n+\t *                O o = target(p);\n+\t *                return filter(r, o);  \n+\t *            }\n+\t *\n+\t * @param target represents the above targetMH.\n+\t * @param filter represent the above filterMH.\n+\t * \n+\t * @return a MH similar to the above adapterMH.\n+\t */\n+\tstatic MethodHandle collectReturnValue(MethodHandle target, MethodHandle filter) {\n+\t\tMethodType targetType = target.type();\n+\t\tMethodType filterType = filter.type();\n+\t\tMethodType resultType = targetType.changeReturnType(filterType.returnType());\n+\t\tint filterParamCount = filterType.parameterCount();\n+\t\tif (filterParamCount > 1) {\n+\t\t\tfor (int i = 0; i < filterParamCount - 1; i++) {\n+\t\t\t\tresultType = resultType.appendParameterTypes(filterType.parameterType(i));\n+\t\t\t}\n+\t\t}\n+\t\treturn buildTransformHandle(new CollectReturnHelper(target, filter), resultType);\n+\t}\n+\t\n+\t/**\n+\t * Return an array of checked exceptions for a MethodHandle.\n+\t * \n+\t * @param mh A MethodHandle to lookup for checked exceptions.\n+\t * \n+\t * @return an array of checked exception classes if any or null.\n+\t * \n+\t * @throws InternalError for an error.\n+\t */\n+\tstatic Class<?>[] checkedExceptions(MethodHandle mh) {\n+\t\tif (mh == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tList<MethodHandle> relatedMHsList = null;\n+\t\tList<Class<?>> exceptionTypesList = null;\n+\t\twhile (mh != null) {\n+\t\t\tif (mh instanceof PrimitiveHandle) {\n+\t\t\t\tClass<?>[] exceptionTypes = null;\n+\t\t\t\tMethodHandleInfoImpl mhi = new MethodHandleInfoImpl((PrimitiveHandle)mh);\n+\t\t\t\tif (mhi.isConstructor()) {\n+\t\t\t\t\texceptionTypes = mhi.reflectAs(Constructor.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n+\t\t\t\t} else if (mhi.isMethod()) {\n+\t\t\t\t\texceptionTypes = mhi.reflectAs(Method.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n+\t\t\t\t} else if (mhi.isField()) {\n+\t\t\t\t\t/* Field reference kind has no checked exceptions. */\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new InternalError(\"Unknown reference kind.\"); //$NON-NLS-1$", "originalCommit": "07024e46399fea0a8bb59491f4fdeb98229d6289", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3ODQ4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r467178488", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\tif (relatedMHsList == null) {\n          \n          \n            \n            \t\t\t\t\t\t\treturn exceptionTypes;\n          \n          \n            \n            \t\t\t\t\t\t} else {\n          \n          \n            \n            \t\t\t\t\t\t\texceptionTypesList = new ArrayList<>();\n          \n          \n            \n            \t\t\t\t\t\t}\n          \n          \n            \n            \t\t\t\t\t\tif (relatedMHsList == null) {\n          \n          \n            \n            \t\t\t\t\t\t\treturn exceptionTypes;\n          \n          \n            \n            \t\t\t\t\t\t}\n          \n          \n            \n            \t\t\t\t\t\texceptionTypesList = new ArrayList<>();", "author": "DanHeidinga", "createdAt": "2020-08-07T17:37:47Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -5466,12 +5494,255 @@ public Object helper(Object[] arguments) throws Throwable {\n \t}\n \n \t/*[IF Java15]*/\n-\tstatic boolean permuteArgumentChecks(int[] arr, MethodType mt1, MethodType mt2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Validates that the permute[] specifies a valid permutation from permuteType to handleType.\n+\t * This method throws IllegalArgumentException on failure and returns true on success. This\n+\t * disjointness allows it to be used in asserts.\n+\t * \n+\t * @param permute array specifies the conversion from permuteType to handleType.\n+\t * @param permuteType source method type.\n+\t * @param handleType target method type.\n+\t * \n+\t * @return true on success.\n+\t * @throws IllegalArgumentException on failure.\n+\t */\n+\tstatic boolean permuteArgumentChecks(int[] permute, MethodType permuteType, MethodType handleType) {\n+\t\treturn validatePermutationArray(permuteType, handleType, permute);\n \t}\n \t\n-\tstatic MethodHandle collectReturnValue(MethodHandle mh1, MethodHandle mh2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Return the classData stored in the accessClass of the Lookup object.\n+\t * \n+\t * @param caller Lookup object used to verify privileged access and retrieve classData.\n+\t * @param unused.\n+\t * @param type used to cast the classData of the accessClass.\n+\t * \n+\t * @return the classData casted to the appropriate type.\n+\t * @throws IllegalAccessException in the absence of full privilege access.\n+\t */\n+\tstatic <T> T classData(Lookup caller, String unused, Class<T> type) throws IllegalAccessException {\n+\t\tif (caller.hasFullPrivilegeAccess()) {\n+\t\t\tObject classData = MethodHandleNatives.classData(caller.accessClass);\n+\t\t\treturn type.cast(classData);\n+\t\t}\n+\t\tthrow new IllegalAccessException(\"No full privilege access found for \" + caller);\n+\t}\n+\n+\t/**\n+\t * Helper class used by collectReturnValue.\n+\t */\n+\tprivate static final class CollectReturnHelper implements ArgumentHelper {\n+\t\tprivate final MethodHandle target;\n+\t\tprivate final MethodHandle filter;\n+\n+\t\tCollectReturnHelper(MethodHandle target, MethodHandle filter) {\n+\t\t\tthis.target = target;\n+\t\t\tthis.filter = filter;\n+\t\t}\n+\n+\t\tpublic Object helper(Object[] arguments) throws Throwable {\n+\t\t\t// Invoke target\n+\t\t\tint targetArity = target.type.parameterCount();\n+\t\t\tObject targetReturn = target.invokeWithArguments(Arrays.copyOfRange(arguments, 0, targetArity));\n+\n+\t\t\t// Construct filter arguments\n+\t\t\tint filterArity = filter.type.parameterCount();\n+\t\t\tObject[] newArguments = new Object[filterArity];\n+\t\t\tSystem.arraycopy(arguments, targetArity, newArguments, 0, filterArity - 1);\n+\t\t\tnewArguments[filterArity - 1] = targetReturn;\n+\n+\t\t\t// Invoke filter\n+\t\t\treturn filter.invokeWithArguments(newArguments);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Creates an adapter MethodHandle (MH) which invokes the target MH and then\n+\t * invokes the filter MH while passing the output from the target MH as an\n+\t * input to the filter MH.\n+\t * \n+\t * targetMH:  O target(P...)\n+\t * filterMH:  Q filter(R..., O)\n+\t * adapterMH: Q adapter(P... p, R... r) {\n+\t *                O o = target(p);\n+\t *                return filter(r, o);  \n+\t *            }\n+\t *\n+\t * @param target represents the above targetMH.\n+\t * @param filter represent the above filterMH.\n+\t * \n+\t * @return a MH similar to the above adapterMH.\n+\t */\n+\tstatic MethodHandle collectReturnValue(MethodHandle target, MethodHandle filter) {\n+\t\tMethodType targetType = target.type();\n+\t\tMethodType filterType = filter.type();\n+\t\tMethodType resultType = targetType.changeReturnType(filterType.returnType());\n+\t\tint filterParamCount = filterType.parameterCount();\n+\t\tif (filterParamCount > 1) {\n+\t\t\tfor (int i = 0; i < filterParamCount - 1; i++) {\n+\t\t\t\tresultType = resultType.appendParameterTypes(filterType.parameterType(i));\n+\t\t\t}\n+\t\t}\n+\t\treturn buildTransformHandle(new CollectReturnHelper(target, filter), resultType);\n+\t}\n+\t\n+\t/**\n+\t * Return an array of checked exceptions for a MethodHandle.\n+\t * \n+\t * @param mh A MethodHandle to lookup for checked exceptions.\n+\t * \n+\t * @return an array of checked exception classes if any or null.\n+\t * \n+\t * @throws InternalError for an error.\n+\t */\n+\tstatic Class<?>[] checkedExceptions(MethodHandle mh) {\n+\t\tif (mh == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tList<MethodHandle> relatedMHsList = null;\n+\t\tList<Class<?>> exceptionTypesList = null;\n+\t\twhile (mh != null) {\n+\t\t\tif (mh instanceof PrimitiveHandle) {\n+\t\t\t\tClass<?>[] exceptionTypes = null;\n+\t\t\t\tMethodHandleInfoImpl mhi = new MethodHandleInfoImpl((PrimitiveHandle)mh);\n+\t\t\t\tif (mhi.isConstructor()) {\n+\t\t\t\t\texceptionTypes = mhi.reflectAs(Constructor.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n+\t\t\t\t} else if (mhi.isMethod()) {\n+\t\t\t\t\texceptionTypes = mhi.reflectAs(Method.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n+\t\t\t\t} else if (mhi.isField()) {\n+\t\t\t\t\t/* Field reference kind has no checked exceptions. */\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new InternalError(\"Unknown reference kind.\"); //$NON-NLS-1$\n+\t\t\t\t}\n+\t\t\t\tif (exceptionTypes != null) {\n+\t\t\t\t\tif (exceptionTypesList == null) {\n+\t\t\t\t\t\tif (relatedMHsList == null) {\n+\t\t\t\t\t\t\treturn exceptionTypes;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\texceptionTypesList = new ArrayList<>();\n+\t\t\t\t\t\t}", "originalCommit": "07024e46399fea0a8bb59491f4fdeb98229d6289", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NTkwNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r467185905", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * @param mh A MethodHandle to lookup for checked exceptions.\n          \n          \n            \n            \t * @param mh A MethodHandle to lookup for checked exceptions.\n          \n      \n    \n    \n  \n\nlookup tends to be a loaded word here.  Might be better to rephrase this", "author": "DanHeidinga", "createdAt": "2020-08-07T17:52:45Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -5466,12 +5494,255 @@ public Object helper(Object[] arguments) throws Throwable {\n \t}\n \n \t/*[IF Java15]*/\n-\tstatic boolean permuteArgumentChecks(int[] arr, MethodType mt1, MethodType mt2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Validates that the permute[] specifies a valid permutation from permuteType to handleType.\n+\t * This method throws IllegalArgumentException on failure and returns true on success. This\n+\t * disjointness allows it to be used in asserts.\n+\t * \n+\t * @param permute array specifies the conversion from permuteType to handleType.\n+\t * @param permuteType source method type.\n+\t * @param handleType target method type.\n+\t * \n+\t * @return true on success.\n+\t * @throws IllegalArgumentException on failure.\n+\t */\n+\tstatic boolean permuteArgumentChecks(int[] permute, MethodType permuteType, MethodType handleType) {\n+\t\treturn validatePermutationArray(permuteType, handleType, permute);\n \t}\n \t\n-\tstatic MethodHandle collectReturnValue(MethodHandle mh1, MethodHandle mh2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Return the classData stored in the accessClass of the Lookup object.\n+\t * \n+\t * @param caller Lookup object used to verify privileged access and retrieve classData.\n+\t * @param unused.\n+\t * @param type used to cast the classData of the accessClass.\n+\t * \n+\t * @return the classData casted to the appropriate type.\n+\t * @throws IllegalAccessException in the absence of full privilege access.\n+\t */\n+\tstatic <T> T classData(Lookup caller, String unused, Class<T> type) throws IllegalAccessException {\n+\t\tif (caller.hasFullPrivilegeAccess()) {\n+\t\t\tObject classData = MethodHandleNatives.classData(caller.accessClass);\n+\t\t\treturn type.cast(classData);\n+\t\t}\n+\t\tthrow new IllegalAccessException(\"No full privilege access found for \" + caller);\n+\t}\n+\n+\t/**\n+\t * Helper class used by collectReturnValue.\n+\t */\n+\tprivate static final class CollectReturnHelper implements ArgumentHelper {\n+\t\tprivate final MethodHandle target;\n+\t\tprivate final MethodHandle filter;\n+\n+\t\tCollectReturnHelper(MethodHandle target, MethodHandle filter) {\n+\t\t\tthis.target = target;\n+\t\t\tthis.filter = filter;\n+\t\t}\n+\n+\t\tpublic Object helper(Object[] arguments) throws Throwable {\n+\t\t\t// Invoke target\n+\t\t\tint targetArity = target.type.parameterCount();\n+\t\t\tObject targetReturn = target.invokeWithArguments(Arrays.copyOfRange(arguments, 0, targetArity));\n+\n+\t\t\t// Construct filter arguments\n+\t\t\tint filterArity = filter.type.parameterCount();\n+\t\t\tObject[] newArguments = new Object[filterArity];\n+\t\t\tSystem.arraycopy(arguments, targetArity, newArguments, 0, filterArity - 1);\n+\t\t\tnewArguments[filterArity - 1] = targetReturn;\n+\n+\t\t\t// Invoke filter\n+\t\t\treturn filter.invokeWithArguments(newArguments);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Creates an adapter MethodHandle (MH) which invokes the target MH and then\n+\t * invokes the filter MH while passing the output from the target MH as an\n+\t * input to the filter MH.\n+\t * \n+\t * targetMH:  O target(P...)\n+\t * filterMH:  Q filter(R..., O)\n+\t * adapterMH: Q adapter(P... p, R... r) {\n+\t *                O o = target(p);\n+\t *                return filter(r, o);  \n+\t *            }\n+\t *\n+\t * @param target represents the above targetMH.\n+\t * @param filter represent the above filterMH.\n+\t * \n+\t * @return a MH similar to the above adapterMH.\n+\t */\n+\tstatic MethodHandle collectReturnValue(MethodHandle target, MethodHandle filter) {\n+\t\tMethodType targetType = target.type();\n+\t\tMethodType filterType = filter.type();\n+\t\tMethodType resultType = targetType.changeReturnType(filterType.returnType());\n+\t\tint filterParamCount = filterType.parameterCount();\n+\t\tif (filterParamCount > 1) {\n+\t\t\tfor (int i = 0; i < filterParamCount - 1; i++) {\n+\t\t\t\tresultType = resultType.appendParameterTypes(filterType.parameterType(i));\n+\t\t\t}\n+\t\t}\n+\t\treturn buildTransformHandle(new CollectReturnHelper(target, filter), resultType);\n+\t}\n+\t\n+\t/**\n+\t * Return an array of checked exceptions for a MethodHandle.\n+\t * \n+\t * @param mh A MethodHandle to lookup for checked exceptions.", "originalCommit": "07024e46399fea0a8bb59491f4fdeb98229d6289", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NzkzNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r467187937", "bodyText": "Is this method as in the RI?  The OO way to do something like this is to add a helper method to each of the MH subclasses that returns its \"next\" methodhandles, similar to a visitor pattern.\nThis avoids needing to make the fields non-private\nie: each MH subclass would add a MH[] getRelatedMHs() method.", "author": "DanHeidinga", "createdAt": "2020-08-07T17:56:57Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -5466,12 +5494,255 @@ public Object helper(Object[] arguments) throws Throwable {\n \t}\n \n \t/*[IF Java15]*/\n-\tstatic boolean permuteArgumentChecks(int[] arr, MethodType mt1, MethodType mt2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Validates that the permute[] specifies a valid permutation from permuteType to handleType.\n+\t * This method throws IllegalArgumentException on failure and returns true on success. This\n+\t * disjointness allows it to be used in asserts.\n+\t * \n+\t * @param permute array specifies the conversion from permuteType to handleType.\n+\t * @param permuteType source method type.\n+\t * @param handleType target method type.\n+\t * \n+\t * @return true on success.\n+\t * @throws IllegalArgumentException on failure.\n+\t */\n+\tstatic boolean permuteArgumentChecks(int[] permute, MethodType permuteType, MethodType handleType) {\n+\t\treturn validatePermutationArray(permuteType, handleType, permute);\n \t}\n \t\n-\tstatic MethodHandle collectReturnValue(MethodHandle mh1, MethodHandle mh2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Return the classData stored in the accessClass of the Lookup object.\n+\t * \n+\t * @param caller Lookup object used to verify privileged access and retrieve classData.\n+\t * @param unused.\n+\t * @param type used to cast the classData of the accessClass.\n+\t * \n+\t * @return the classData casted to the appropriate type.\n+\t * @throws IllegalAccessException in the absence of full privilege access.\n+\t */\n+\tstatic <T> T classData(Lookup caller, String unused, Class<T> type) throws IllegalAccessException {\n+\t\tif (caller.hasFullPrivilegeAccess()) {\n+\t\t\tObject classData = MethodHandleNatives.classData(caller.accessClass);\n+\t\t\treturn type.cast(classData);\n+\t\t}\n+\t\tthrow new IllegalAccessException(\"No full privilege access found for \" + caller);\n+\t}\n+\n+\t/**\n+\t * Helper class used by collectReturnValue.\n+\t */\n+\tprivate static final class CollectReturnHelper implements ArgumentHelper {\n+\t\tprivate final MethodHandle target;\n+\t\tprivate final MethodHandle filter;\n+\n+\t\tCollectReturnHelper(MethodHandle target, MethodHandle filter) {\n+\t\t\tthis.target = target;\n+\t\t\tthis.filter = filter;\n+\t\t}\n+\n+\t\tpublic Object helper(Object[] arguments) throws Throwable {\n+\t\t\t// Invoke target\n+\t\t\tint targetArity = target.type.parameterCount();\n+\t\t\tObject targetReturn = target.invokeWithArguments(Arrays.copyOfRange(arguments, 0, targetArity));\n+\n+\t\t\t// Construct filter arguments\n+\t\t\tint filterArity = filter.type.parameterCount();\n+\t\t\tObject[] newArguments = new Object[filterArity];\n+\t\t\tSystem.arraycopy(arguments, targetArity, newArguments, 0, filterArity - 1);\n+\t\t\tnewArguments[filterArity - 1] = targetReturn;\n+\n+\t\t\t// Invoke filter\n+\t\t\treturn filter.invokeWithArguments(newArguments);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Creates an adapter MethodHandle (MH) which invokes the target MH and then\n+\t * invokes the filter MH while passing the output from the target MH as an\n+\t * input to the filter MH.\n+\t * \n+\t * targetMH:  O target(P...)\n+\t * filterMH:  Q filter(R..., O)\n+\t * adapterMH: Q adapter(P... p, R... r) {\n+\t *                O o = target(p);\n+\t *                return filter(r, o);  \n+\t *            }\n+\t *\n+\t * @param target represents the above targetMH.\n+\t * @param filter represent the above filterMH.\n+\t * \n+\t * @return a MH similar to the above adapterMH.\n+\t */\n+\tstatic MethodHandle collectReturnValue(MethodHandle target, MethodHandle filter) {\n+\t\tMethodType targetType = target.type();\n+\t\tMethodType filterType = filter.type();\n+\t\tMethodType resultType = targetType.changeReturnType(filterType.returnType());\n+\t\tint filterParamCount = filterType.parameterCount();\n+\t\tif (filterParamCount > 1) {\n+\t\t\tfor (int i = 0; i < filterParamCount - 1; i++) {\n+\t\t\t\tresultType = resultType.appendParameterTypes(filterType.parameterType(i));\n+\t\t\t}\n+\t\t}\n+\t\treturn buildTransformHandle(new CollectReturnHelper(target, filter), resultType);\n+\t}\n+\t\n+\t/**\n+\t * Return an array of checked exceptions for a MethodHandle.\n+\t * \n+\t * @param mh A MethodHandle to lookup for checked exceptions.\n+\t * \n+\t * @return an array of checked exception classes if any or null.\n+\t * \n+\t * @throws InternalError for an error.\n+\t */\n+\tstatic Class<?>[] checkedExceptions(MethodHandle mh) {\n+\t\tif (mh == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tList<MethodHandle> relatedMHsList = null;\n+\t\tList<Class<?>> exceptionTypesList = null;\n+\t\twhile (mh != null) {\n+\t\t\tif (mh instanceof PrimitiveHandle) {\n+\t\t\t\tClass<?>[] exceptionTypes = null;\n+\t\t\t\tMethodHandleInfoImpl mhi = new MethodHandleInfoImpl((PrimitiveHandle)mh);\n+\t\t\t\tif (mhi.isConstructor()) {\n+\t\t\t\t\texceptionTypes = mhi.reflectAs(Constructor.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n+\t\t\t\t} else if (mhi.isMethod()) {\n+\t\t\t\t\texceptionTypes = mhi.reflectAs(Method.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n+\t\t\t\t} else if (mhi.isField()) {\n+\t\t\t\t\t/* Field reference kind has no checked exceptions. */\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new InternalError(\"Unknown reference kind.\"); //$NON-NLS-1$\n+\t\t\t\t}\n+\t\t\t\tif (exceptionTypes != null) {\n+\t\t\t\t\tif (exceptionTypesList == null) {\n+\t\t\t\t\t\tif (relatedMHsList == null) {\n+\t\t\t\t\t\t\treturn exceptionTypes;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\texceptionTypesList = new ArrayList<>();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tCollections.addAll(exceptionTypesList, exceptionTypes);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif (relatedMHsList == null) {\n+\t\t\t\t\trelatedMHsList = new ArrayList<>();\n+\t\t\t\t}\n+\t\t\t\tfindRelatedMHs(mh, relatedMHsList);\n+\t\t\t}\n+\t\t\tif ((relatedMHsList == null) || relatedMHsList.isEmpty()) {\n+\t\t\t\tbreak;\n+\t\t\t} else {\n+\t\t\t\tmh = relatedMHsList.remove(relatedMHsList.size() - 1);\n+\t\t\t}\n+\t\t}\n+\t\tClass<?>[] exceptionTypesArray = null;\n+\t\tif (exceptionTypesList != null) {\n+\t\t\texceptionTypesArray = exceptionTypesList.toArray(new Class<?>[exceptionTypesList.size()]);\n+\t\t}\n+\t\treturn exceptionTypesArray;\n+\t}\n+\t\n+\t/**\n+\t * A MethodHandle can be combination of multiple MethodHandles. This helper finds all the related\n+\t * MethodHandles for a MethodHandle and appends the related MethodHandles to the relatedMHs list.\n+\t * \n+\t * @param mh The MethodHandle to evaluate.\n+\t * @param[out] relatedMHs A list of related MethodHandles.\n+\t * \n+\t * @return void.\n+\t * @throws InternalError for an unknown MethodHandle kind or an exception during a privileged\n+\t * operation for ReceiverBoundHandle.\n+\t */\n+\tprivate static void findRelatedMHs(MethodHandle mh, List<MethodHandle> relatedMHs) {", "originalCommit": "07024e46399fea0a8bb59491f4fdeb98229d6289", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAyMjM3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r468022377", "bodyText": "Is this method as in the RI?\n\nNo. It has similar functionality to VarHandles.noCheckedExceptions.\n\nThis avoids needing to make the fields non-private\n\nThis method was derived from SecurityFrameInjector.penetrateSecurityFrame, which directly accesses the package-protected MH fields. There are discrepancies in OpenJ9 MHs where identical fields, such as next, are private and package-protected in some cases; example: FilterArgumentsHandle.next (private) and FilterReturnHandle.next (package-protected). SecurityFrameInjector.penetrateSecurityFrame is also in need of an update since it does not cover all of the OpenJ9 MHs. Do we ignore this discrepancy?\n\nThe OO way ...\n\nI like the OO approach (visitor pattern). I will be happy to take it. Shall I preserve the current implementation (commit) for reference and verifying behavior?\nfyi - @DanHeidinga", "author": "babsingh", "createdAt": "2020-08-10T16:16:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NzkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MzM5Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r467193397", "bodyText": "Is this the expected behaviour?  I think you can create an infinite loop here by doing something like:\nMutableCallSite mcs = new MutableCallSite(MethodType.type(void.class));\nMH dynInvoker = mcs.dynamicInvoker();\nmcs.setTarget(dynInvoker);\ncheckedExceptions.dynInvoker();", "author": "DanHeidinga", "createdAt": "2020-08-07T18:08:16Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -5466,12 +5494,255 @@ public Object helper(Object[] arguments) throws Throwable {\n \t}\n \n \t/*[IF Java15]*/\n-\tstatic boolean permuteArgumentChecks(int[] arr, MethodType mt1, MethodType mt2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Validates that the permute[] specifies a valid permutation from permuteType to handleType.\n+\t * This method throws IllegalArgumentException on failure and returns true on success. This\n+\t * disjointness allows it to be used in asserts.\n+\t * \n+\t * @param permute array specifies the conversion from permuteType to handleType.\n+\t * @param permuteType source method type.\n+\t * @param handleType target method type.\n+\t * \n+\t * @return true on success.\n+\t * @throws IllegalArgumentException on failure.\n+\t */\n+\tstatic boolean permuteArgumentChecks(int[] permute, MethodType permuteType, MethodType handleType) {\n+\t\treturn validatePermutationArray(permuteType, handleType, permute);\n \t}\n \t\n-\tstatic MethodHandle collectReturnValue(MethodHandle mh1, MethodHandle mh2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Return the classData stored in the accessClass of the Lookup object.\n+\t * \n+\t * @param caller Lookup object used to verify privileged access and retrieve classData.\n+\t * @param unused.\n+\t * @param type used to cast the classData of the accessClass.\n+\t * \n+\t * @return the classData casted to the appropriate type.\n+\t * @throws IllegalAccessException in the absence of full privilege access.\n+\t */\n+\tstatic <T> T classData(Lookup caller, String unused, Class<T> type) throws IllegalAccessException {\n+\t\tif (caller.hasFullPrivilegeAccess()) {\n+\t\t\tObject classData = MethodHandleNatives.classData(caller.accessClass);\n+\t\t\treturn type.cast(classData);\n+\t\t}\n+\t\tthrow new IllegalAccessException(\"No full privilege access found for \" + caller);\n+\t}\n+\n+\t/**\n+\t * Helper class used by collectReturnValue.\n+\t */\n+\tprivate static final class CollectReturnHelper implements ArgumentHelper {\n+\t\tprivate final MethodHandle target;\n+\t\tprivate final MethodHandle filter;\n+\n+\t\tCollectReturnHelper(MethodHandle target, MethodHandle filter) {\n+\t\t\tthis.target = target;\n+\t\t\tthis.filter = filter;\n+\t\t}\n+\n+\t\tpublic Object helper(Object[] arguments) throws Throwable {\n+\t\t\t// Invoke target\n+\t\t\tint targetArity = target.type.parameterCount();\n+\t\t\tObject targetReturn = target.invokeWithArguments(Arrays.copyOfRange(arguments, 0, targetArity));\n+\n+\t\t\t// Construct filter arguments\n+\t\t\tint filterArity = filter.type.parameterCount();\n+\t\t\tObject[] newArguments = new Object[filterArity];\n+\t\t\tSystem.arraycopy(arguments, targetArity, newArguments, 0, filterArity - 1);\n+\t\t\tnewArguments[filterArity - 1] = targetReturn;\n+\n+\t\t\t// Invoke filter\n+\t\t\treturn filter.invokeWithArguments(newArguments);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Creates an adapter MethodHandle (MH) which invokes the target MH and then\n+\t * invokes the filter MH while passing the output from the target MH as an\n+\t * input to the filter MH.\n+\t * \n+\t * targetMH:  O target(P...)\n+\t * filterMH:  Q filter(R..., O)\n+\t * adapterMH: Q adapter(P... p, R... r) {\n+\t *                O o = target(p);\n+\t *                return filter(r, o);  \n+\t *            }\n+\t *\n+\t * @param target represents the above targetMH.\n+\t * @param filter represent the above filterMH.\n+\t * \n+\t * @return a MH similar to the above adapterMH.\n+\t */\n+\tstatic MethodHandle collectReturnValue(MethodHandle target, MethodHandle filter) {\n+\t\tMethodType targetType = target.type();\n+\t\tMethodType filterType = filter.type();\n+\t\tMethodType resultType = targetType.changeReturnType(filterType.returnType());\n+\t\tint filterParamCount = filterType.parameterCount();\n+\t\tif (filterParamCount > 1) {\n+\t\t\tfor (int i = 0; i < filterParamCount - 1; i++) {\n+\t\t\t\tresultType = resultType.appendParameterTypes(filterType.parameterType(i));\n+\t\t\t}\n+\t\t}\n+\t\treturn buildTransformHandle(new CollectReturnHelper(target, filter), resultType);\n+\t}\n+\t\n+\t/**\n+\t * Return an array of checked exceptions for a MethodHandle.\n+\t * \n+\t * @param mh A MethodHandle to lookup for checked exceptions.\n+\t * \n+\t * @return an array of checked exception classes if any or null.\n+\t * \n+\t * @throws InternalError for an error.\n+\t */\n+\tstatic Class<?>[] checkedExceptions(MethodHandle mh) {\n+\t\tif (mh == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tList<MethodHandle> relatedMHsList = null;\n+\t\tList<Class<?>> exceptionTypesList = null;\n+\t\twhile (mh != null) {\n+\t\t\tif (mh instanceof PrimitiveHandle) {\n+\t\t\t\tClass<?>[] exceptionTypes = null;\n+\t\t\t\tMethodHandleInfoImpl mhi = new MethodHandleInfoImpl((PrimitiveHandle)mh);\n+\t\t\t\tif (mhi.isConstructor()) {\n+\t\t\t\t\texceptionTypes = mhi.reflectAs(Constructor.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n+\t\t\t\t} else if (mhi.isMethod()) {\n+\t\t\t\t\texceptionTypes = mhi.reflectAs(Method.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n+\t\t\t\t} else if (mhi.isField()) {\n+\t\t\t\t\t/* Field reference kind has no checked exceptions. */\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new InternalError(\"Unknown reference kind.\"); //$NON-NLS-1$\n+\t\t\t\t}\n+\t\t\t\tif (exceptionTypes != null) {\n+\t\t\t\t\tif (exceptionTypesList == null) {\n+\t\t\t\t\t\tif (relatedMHsList == null) {\n+\t\t\t\t\t\t\treturn exceptionTypes;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\texceptionTypesList = new ArrayList<>();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tCollections.addAll(exceptionTypesList, exceptionTypes);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif (relatedMHsList == null) {\n+\t\t\t\t\trelatedMHsList = new ArrayList<>();\n+\t\t\t\t}\n+\t\t\t\tfindRelatedMHs(mh, relatedMHsList);\n+\t\t\t}\n+\t\t\tif ((relatedMHsList == null) || relatedMHsList.isEmpty()) {\n+\t\t\t\tbreak;\n+\t\t\t} else {\n+\t\t\t\tmh = relatedMHsList.remove(relatedMHsList.size() - 1);\n+\t\t\t}\n+\t\t}\n+\t\tClass<?>[] exceptionTypesArray = null;\n+\t\tif (exceptionTypesList != null) {\n+\t\t\texceptionTypesArray = exceptionTypesList.toArray(new Class<?>[exceptionTypesList.size()]);\n+\t\t}\n+\t\treturn exceptionTypesArray;\n+\t}\n+\t\n+\t/**\n+\t * A MethodHandle can be combination of multiple MethodHandles. This helper finds all the related\n+\t * MethodHandles for a MethodHandle and appends the related MethodHandles to the relatedMHs list.\n+\t * \n+\t * @param mh The MethodHandle to evaluate.\n+\t * @param[out] relatedMHs A list of related MethodHandles.\n+\t * \n+\t * @return void.\n+\t * @throws InternalError for an unknown MethodHandle kind or an exception during a privileged\n+\t * operation for ReceiverBoundHandle.\n+\t */\n+\tprivate static void findRelatedMHs(MethodHandle mh, List<MethodHandle> relatedMHs) {\n+\t\tbyte kind = mh.kind;\n+\t\tif (mh instanceof PrimitiveHandle) {\n+\t\t\t/* Do not append to relatedMHs. */\n+\t\t} else if ((kind == MethodHandle.KIND_CONSTANTOBJECT)\n+\t\t\t|| (kind == MethodHandle.KIND_CONSTANTINT)\n+\t\t\t|| (kind == MethodHandle.KIND_CONSTANTFLOAT)\n+\t\t\t|| (kind == MethodHandle.KIND_CONSTANTFLOAT)\n+\t\t\t|| (kind == MethodHandle.KIND_CONSTANTLONG)\n+\t\t\t|| (kind == MethodHandle.KIND_CONSTANTDOUBLE)\n+\t\t) {\n+\t\t\t/* Does not support checked exceptions. */\n+\t\t} else if (kind == MethodHandle.KIND_VARARGSCOLLECT) {\n+\t\t\trelatedMHs.add(((VarargsCollectorHandle)mh).next);\n+\t\t} else if (kind == MethodHandle.KIND_ASTYPE) {\n+\t\t\trelatedMHs.add(((AsTypeHandle)mh).next);\n+\t\t} else if (kind == MethodHandle.KIND_FILTERRETURN) {\n+\t\t\trelatedMHs.add(((FilterReturnHandle)mh).next);\n+\t\t} else if (kind == MethodHandle.KIND_EXPLICITCAST) {\n+\t\t\trelatedMHs.add(((ExplicitCastHandle)mh).next);\n+\t\t} else if (kind == MethodHandle.KIND_SPREAD) {\n+\t\t\trelatedMHs.add(((SpreadHandle)mh).next);\n+\t\t} else if (kind == MethodHandle.KIND_FOLDHANDLE) {\n+\t\t\trelatedMHs.add(((FoldHandle)mh).next);\n+\t\t\trelatedMHs.add(((FoldHandle)mh).combiner);\n+\t\t} else if (kind == MethodHandle.KIND_GUARDWITHTEST) {\n+\t\t\trelatedMHs.add(((GuardWithTestHandle)mh).guard);\n+\t\t\trelatedMHs.add(((GuardWithTestHandle)mh).trueTarget);\n+\t\t\trelatedMHs.add(((GuardWithTestHandle)mh).falseTarget);\n+\t\t} else if (kind == MethodHandle.KIND_FILTERARGUMENTS) {\n+\t\t\trelatedMHs.add(((FilterArgumentsHandle)mh).next);\n+\t\t\tCollections.addAll(relatedMHs, ((FilterArgumentsHandle)mh).filters);\n+\t\t} else if (kind == MethodHandle.KIND_FILTERARGUMENTS_WITHCOMBINER) {\n+\t\t\trelatedMHs.add(((FilterArgumentsWithCombinerHandle)mh).next);\n+\t\t\trelatedMHs.add(((FilterArgumentsWithCombinerHandle)mh).combiner);\n+\t\t} else if (kind == MethodHandle.KIND_DYNAMICINVOKER) {\n+\t\t\trelatedMHs.add(((DynamicInvokerHandle)mh).site.getTarget());", "originalCommit": "07024e46399fea0a8bb59491f4fdeb98229d6289", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAyMzk4NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r468023985", "bodyText": "@DanHeidinga No, we want to avoid such cycles (infinite loops). If the parent and next MHs are the same, then the next MH should be skipped. Is this scenario only possible for DynamicInvokerHandle?", "author": "babsingh", "createdAt": "2020-08-10T16:19:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MzM5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0MzQ5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r468643494", "bodyText": "DynamicInvokerHandle is the only case where I know this can occur as other other handles are immutable once built so they can't refer to themselves.\nThe question of \"expected behaviour\" was whether checkedExceptions should be found in the target MH chain or not.  I would have expected the chain to the dynamicInvoker to be considered \"complete\" and the target MH chain to be separate, at least for the case of MutableCallSite or VolatileCallSite", "author": "DanHeidinga", "createdAt": "2020-08-11T14:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MzM5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc1MjAyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r468752021", "bodyText": "Ok. Shall I use CallSite.dynamicInvoker() instead of CallSite.getTarget() to retrieve the DynamicInvokerHandle's target MH since it's \"complete\"?", "author": "babsingh", "createdAt": "2020-08-11T17:39:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MzM5Nw=="}], "type": "inlineReview"}, {"oid": "aead271667c0c8ad48cd40119aa6e1158ae65f49", "url": "https://github.com/eclipse-openj9/openj9/commit/aead271667c0c8ad48cd40119aa6e1158ae65f49", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-08-10T15:32:53Z", "type": "forcePushed"}, {"oid": "70b0510c6656df24641c0861c781ab3b4e27c496", "url": "https://github.com/eclipse-openj9/openj9/commit/70b0510c6656df24641c0861c781ab3b4e27c496", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-08-10T16:25:28Z", "type": "forcePushed"}, {"oid": "b98401b8e5b4d5a8ef8071369435b85b8e718a82", "url": "https://github.com/eclipse-openj9/openj9/commit/b98401b8e5b4d5a8ef8071369435b85b8e718a82", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-08-10T16:33:31Z", "type": "forcePushed"}, {"oid": "8e9a4a37981a6ac8680a0876da8c0b9a4ff6d475", "url": "https://github.com/eclipse-openj9/openj9/commit/8e9a4a37981a6ac8680a0876da8c0b9a4ff6d475", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-08-10T16:37:40Z", "type": "forcePushed"}, {"oid": "9d633ae41513568aca528e49694291e21f725cc4", "url": "https://github.com/eclipse-openj9/openj9/commit/9d633ae41513568aca528e49694291e21f725cc4", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles (OO variant)\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-08-10T21:36:48Z", "type": "forcePushed"}, {"oid": "83356acc89db2f53fb42ecbfb5a0156f8498b6ab", "url": "https://github.com/eclipse-openj9/openj9/commit/83356acc89db2f53fb42ecbfb5a0156f8498b6ab", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles (OO variant)\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-08-10T21:43:51Z", "type": "forcePushed"}, {"oid": "c09bb8a374ea3cd4550a480d9b888da1a5441d65", "url": "https://github.com/eclipse-openj9/openj9/commit/c09bb8a374ea3cd4550a480d9b888da1a5441d65", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles (OO variant)\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-08-10T22:05:08Z", "type": "forcePushed"}, {"oid": "981e4d98777631a5ed1a97e70d0cb70a7bbc33e3", "url": "https://github.com/eclipse-openj9/openj9/commit/981e4d98777631a5ed1a97e70d0cb70a7bbc33e3", "message": "[JEP383] Scan for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-08-10T22:45:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NDI3MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r468644271", "bodyText": "Should this depend on the type of the site?  ie: a ConstantCallSite should include the target and others shouldn't?", "author": "DanHeidinga", "createdAt": "2020-08-11T14:54:08Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/DynamicInvokerHandle.java", "diffHunk": "@@ -37,6 +37,16 @@\n \t\tthis.site = originalHandle.site;\n \t}\n \n+/*[IF Java15]*/\n+\tMethodHandle[] getRelatedMHs() {\n+\t\tMethodHandle targetMH = site.getTarget();", "originalCommit": "981e4d98777631a5ed1a97e70d0cb70a7bbc33e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM1NDkyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r469354921", "bodyText": "All three ([Mutable|Volatile|Constant]CallSite) include a target. The only difference is that ConstantCallSite uses its target as the dynamicInvoker() where as [Mutable|Volatile]CallSite generate a new dynamicInvoker() MH, equivalent to an invokedynamic instruction, in order to execute the target.", "author": "babsingh", "createdAt": "2020-08-12T15:41:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NDI3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQwOTkxNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r469409914", "bodyText": "Right - a ConstantCallSite can be viewed as part of the calling MH chain as there is no option to \"break\" the chain there.  The other types of CS are different as they have a calling chain, and a callee chain where the callee chain can be changed.\nDoes the RI treat that as a single thing?  Maybe test with a MCS that targets a DirectMH that throws an exception to validate the assumptions here", "author": "DanHeidinga", "createdAt": "2020-08-12T17:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NDI3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2Mjg1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r469562850", "bodyText": "Still confused about this. Did I properly identify callee dynamicInvoker() and calling getTarget() chains in the below example? We want to verify if dynamicInvoker() MH behaves similar to getTarget() MH for MutableCallSite?\nMutableCallSite exceptionCS = new MutableCallSite(MethodType.methodType(String.class, Throwable.class));\nMethodHandle MH_exception = exceptionCS.dynamicInvoker();\n\nexceptionCS.setTarget(MethodHandles.throwException(String.class, Throwable.class));\n\ntry {\n        MH_exception.invoke(new SQLException());\n} catch (SQLException ex) {\n        System.out.println(\"Caught SQLException callee chain\");\n}\n\ntry {\n        exceptionCS.getTarget().invoke(new MalformedURLException());\n} catch (MalformedURLException ex) {\n        System.out.println(\"Caught MalformedURLException calling chain\");\n}", "author": "babsingh", "createdAt": "2020-08-12T21:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NDI3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY5NzgyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r469697822", "bodyText": "Not quite.  We want to validate that the RI's equivalent of hasCheckedException() follows the MH chain thru the target of a Mutable or Volatile CallSite.\nWe already know - by spec - how all the CS operate when invoked.  It's the hasCheckedException() behaviour that's in question.\nSo something like:\nclass C {\npublic static void m() throws IOException /* a checked exception */ {\n}\n}\n\nMutableCallSite mcs = new MCS(MethodType.methodType(void.class));\nboolean nullTarget = MethodHandles.hasCheckedException(mcs.dynamicInvoker());\n\nMethodHandle mh = Lookup.lookup().findStatic(C.class, \"m\", methodType(void.class));\nmcs.setTarget(mh);\nboolean throwingTarget = MethodHandles.hasCheckedException(mcs.dynamicInvoker());\n\nSystem.out.println(\"nullTarget = \"+nullTaget+\"\\t throwingTarget = \"+throwingTarget);", "author": "DanHeidinga", "createdAt": "2020-08-13T05:01:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NDI3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA3MTMyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r470071321", "bodyText": "RI doesn't find a checked exception in case of mcs.dynamicInvoker() but it does in case of mcs.getTarget(). So, RI's equivalent of hasCheckedException() does not follow the MH chain thru the target of a Mutable or Volatile CallSite. With the below suggestion,  hasCheckedException() should match the RI.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tMethodHandle targetMH = site.getTarget();\n          \n          \n            \n            \t\tMethodHandle targetMH = site.dynamicInvoker();", "author": "babsingh", "createdAt": "2020-08-13T16:20:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NDI3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4MDY1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r470080655", "bodyText": "Presumably, we've already processed the dynamicInvoker or we wouldn't be able to get the site.  Removing the line should be sufficient", "author": "DanHeidinga", "createdAt": "2020-08-13T16:35:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NDI3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA5MDcyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r470090722", "bodyText": "DynamicInvokerHandle.getRelatedMHs ends up just returning false after removing the above line. Change completed.", "author": "babsingh", "createdAt": "2020-08-13T16:53:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NDI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NjIxMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r468646212", "bodyText": "How often will this API get called?  It generates a lot of garbage arrays.\nIf it's rare, then I won't worry.  If it's a lot, then a API that adds the next handles to an existing ArrayList is probably better - boolean addRelatedMHs(List<? extends MH> relatedMHs)", "author": "DanHeidinga", "createdAt": "2020-08-11T14:56:45Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandle.java", "diffHunk": "@@ -1587,6 +1587,15 @@ String mapKindToBytecode() {\n \t\treturn \"KIND_#\"+kind; //$NON-NLS-1$\n \t}\n \n+/*[IF Java15]*/\n+\t/**\n+\t * Get an array of child MethodHandle(s) which form \"this\" (parent MethodHandle).\n+\t * \n+\t * @return an array of MethodHandles, or null if no child MethodHandles are found.\n+\t */\n+\tabstract MethodHandle[] getRelatedMHs();", "originalCommit": "981e4d98777631a5ed1a97e70d0cb70a7bbc33e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM0Mjg3Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r469342876", "bodyText": "it will be called multiple times from VarHandle adapter methods such as VarHandles.filterValue, VarHandles.filterCoordinates, VarHandles.collectCoordinates, etc. so, i will change it to the List approach.", "author": "babsingh", "createdAt": "2020-08-12T15:24:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NjIxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2NDM4NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r469564384", "bodyText": "Updated to use the List approach.", "author": "babsingh", "createdAt": "2020-08-12T21:44:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NjIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAxODE2OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r469018169", "bodyText": "This is more complicated than it needs to be as it tries to lazy init the lists.  Something like the code below is more explicit that it's processing the MH chain as a worklist until it has found all the ExceptionTypes in the MH chain:\n\tstatic Class<?>[] getExceptions(MethodHandle mh) {\n\t\tif (mh == null) {\n\t\t\treturn null;\n\t\t}\n\t\tDeque<MethodHandle> workList = = new ArrayDeque<>();\n\t\trelatedMHsList.push(mh);\n\t\tList<Class<?>> exceptionTypesList = new ArrayList<>(4);\n\n\t\twhile (!workList.isEmpty()) {\n\t\t\tmh = workList.pop();\n\t\t\tif (mh instanceof PrimitiveHandle) {\n\t\t\t\tClass<?>[] exceptionTypes = null;\n\t\t\t\tMethodHandleInfoImpl mhi = new MethodHandleInfoImpl((PrimitiveHandle)mh);\n\t\t\t\tif (mhi.isConstructor()) {\n\t\t\t\t\texceptionTypes = mhi.reflectAs(Constructor.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n\t\t\t\t} else if (mhi.isMethod()) {\n\t\t\t\t\texceptionTypes = mhi.reflectAs(Method.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n\t\t\t\t} else if (mhi.isField()) {\n\t\t\t\t\t/* Field reference kind has no checked exceptions. */\n\t\t\t\t} else {\n\t\t\t\t\t/*[MSG \"K0686\", \"Unknown reference kind: '{0}'\"]*/\n\t\t\t\t\tthrow new InternalError(com.ibm.oti.util.Msg.getString(\"K0686\", mhi.getReferenceKind())); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t\tCollections.addAll(exceptionTypesList, exceptionTypes);\n\t\t\t} else {\n\t\t\t\tMethodHandle[] relatedMHs = mh.getRelatedMHs();\n\t\t\t\tworkList.addAll(relatedMHs);\n\t\t\t}\n\t\t}\n\t\tClass<?>[] exceptionTypesArray = null;\n\t\tif (!exceptionTypesList.isEmpty()) {\n\t\t\texceptionTypesArray = exceptionTypesList.toArray(new Class<?>[0]);\n\t\t}\n\t\treturn exceptionTypesArray;\n\t}\nI left exceptionTypesList as a List though it may be better as a HashSet to avoid repeated processing of the same exception classes.  An even better approach may be to check the exception types as they are fetched to see if any are checked or not.  The caller only cares for a boolean response, correct?", "author": "DanHeidinga", "createdAt": "2020-08-12T05:45:53Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -5599,6 +5600,66 @@ static MethodHandle collectReturnValue(MethodHandle target, MethodHandle filter)\n \t\t}\n \t\treturn buildTransformHandle(new CollectReturnHelper(target, filter), resultType);\n \t}\n+\t\n+\t/**\n+\t * Return an array of checked exceptions for a MethodHandle.\n+\t * \n+\t * @param mh A MethodHandle to scan for checked exceptions.\n+\t * \n+\t * @return an array of checked exception classes if any or null.\n+\t * \n+\t * @throws InternalError for an error.\n+\t */\n+\tstatic Class<?>[] checkedExceptions(MethodHandle mh) {", "originalCommit": "981e4d98777631a5ed1a97e70d0cb70a7bbc33e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2NzY5NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r469567695", "bodyText": "Correct, caller only cares about a boolean response. Updated to return a boolean type and process the exception types are they are fetched. I continue to use an ArrayList for supporting addRelatedMHs. Removing the last element from an ArrayList is inexpensive. Also, accounted for other explicit changes.", "author": "babsingh", "createdAt": "2020-08-12T21:52:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAxODE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAxODQxMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r469018412", "bodyText": "Also, I think this method should be renamed as currently implemented, it's about exceptions in general, not just checked ones.", "author": "DanHeidinga", "createdAt": "2020-08-12T05:46:44Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -5599,6 +5600,66 @@ static MethodHandle collectReturnValue(MethodHandle target, MethodHandle filter)\n \t\t}\n \t\treturn buildTransformHandle(new CollectReturnHelper(target, filter), resultType);\n \t}\n+\t\n+\t/**\n+\t * Return an array of checked exceptions for a MethodHandle.\n+\t * \n+\t * @param mh A MethodHandle to scan for checked exceptions.\n+\t * \n+\t * @return an array of checked exception classes if any or null.\n+\t * \n+\t * @throws InternalError for an error.\n+\t */\n+\tstatic Class<?>[] checkedExceptions(MethodHandle mh) {", "originalCommit": "981e4d98777631a5ed1a97e70d0cb70a7bbc33e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2NzcyNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r469567724", "bodyText": "Renamed to hasCheckedException since a boolean is returned.", "author": "babsingh", "createdAt": "2020-08-12T21:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAxODQxMg=="}], "type": "inlineReview"}, {"oid": "e43950c7c96cb2fbb47c4fc39ae2e641472638f8", "url": "https://github.com/eclipse-openj9/openj9/commit/e43950c7c96cb2fbb47c4fc39ae2e641472638f8", "message": "[JEP383] Scan for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-08-12T19:33:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5MDU0Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r469990546", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tstatic MethodHandle permuateHandleJ9ToReference(MethodHandle methodHandle) {\n          \n          \n            \n            \tstatic MethodHandle permuteHandleJ9ToReference(MethodHandle methodHandle) {", "author": "DanHeidinga", "createdAt": "2020-08-13T14:23:56Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -489,7 +505,7 @@ MethodType accessModeType(Class<?> receiver, Class<?> type, Class<?>... args) {\n \t * @param methodHandle to be permuted.\n \t * @return the adapter MethodHandle which performs the translation.\n \t */\n-\tstatic MethodHandle permuateHandleJEP370(MethodHandle methodHandle) {\n+\tstatic MethodHandle permuateHandleJ9ToReference(MethodHandle methodHandle) {", "originalCommit": "e43950c7c96cb2fbb47c4fc39ae2e641472638f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA5MDkzNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r470090937", "bodyText": "Fixed.", "author": "babsingh", "createdAt": "2020-08-13T16:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5MDU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5MDY3MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r469990670", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tstatic MethodHandle permuateHandleReferenceToJ9(MethodHandle methodHandle) {\n          \n          \n            \n            \tstatic MethodHandle permuteHandleReferenceToJ9(MethodHandle methodHandle) {", "author": "DanHeidinga", "createdAt": "2020-08-13T14:24:06Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -515,6 +530,87 @@ static MethodHandle permuateHandleJEP370(MethodHandle methodHandle) {\n \t}\n /*[ENDIF] Java14 */\n \n+/*[IF Java15]*/\n+\t/**\n+\t * Generate a MethodHandle which translates:\n+\t *     FROM {VarHandle, Receiver, Intermediate ..., Value}ReturnType\n+\t *     TO   {Receiver, Intermediate ..., Value, VarHandle}ReturnType\n+\t *\n+\t * @param methodHandle to be permuted.\n+\t * @return the adapter MethodHandle which performs the translation.\n+\t */\n+\tstatic MethodHandle permuateHandleReferenceToJ9(MethodHandle methodHandle) {", "originalCommit": "e43950c7c96cb2fbb47c4fc39ae2e641472638f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA5MTAyMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r470091020", "bodyText": "Fixed.", "author": "babsingh", "createdAt": "2020-08-13T16:53:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5MDY3MA=="}], "type": "inlineReview"}, {"oid": "e99e1296209e44d7ea90dea176cc34836bab5e41", "url": "https://github.com/eclipse-openj9/openj9/commit/e99e1296209e44d7ea90dea176cc34836bab5e41", "message": "[JEP383] Add support for IndirectVarHandle\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-08-13T16:33:18Z", "type": "commit"}, {"oid": "71b3455ea8e331d335188ed5a6873419881002a8", "url": "https://github.com/eclipse-openj9/openj9/commit/71b3455ea8e331d335188ed5a6873419881002a8", "message": "[JEP383] Scan for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-08-13T16:41:02Z", "type": "commit"}, {"oid": "71b3455ea8e331d335188ed5a6873419881002a8", "url": "https://github.com/eclipse-openj9/openj9/commit/71b3455ea8e331d335188ed5a6873419881002a8", "message": "[JEP383] Scan for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-08-13T16:41:02Z", "type": "forcePushed"}]}