{"pr_number": 11051, "pr_title": "Add Dynamic Breadth First Scan Ordering to Balanced GC", "pr_createdAt": "2020-10-29T20:53:12Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/11051", "timeline": [{"oid": "ae3fb2abdeb9e56e73b3238989914fd0885847cb", "url": "https://github.com/eclipse-openj9/openj9/commit/ae3fb2abdeb9e56e73b3238989914fd0885847cb", "message": "Add Dynamic Breadth First Scan Ordering to Balanced GC\n\nAdd a gc scavenger scan ordering feature that enables the\ncopying of a hot field marked by the JIT immediately after the\nobject containing the hot field is copied for balanced gc policy.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>", "committedDate": "2020-10-29T21:01:09Z", "type": "forcePushed"}, {"oid": "f4d59d9e6896cabb34c4fb74dd2632fe5accd7bb", "url": "https://github.com/eclipse-openj9/openj9/commit/f4d59d9e6896cabb34c4fb74dd2632fe5accd7bb", "message": "Add Dynamic Breadth First Scan Ordering to Balanced GC\n\nAdd a gc scavenger scan ordering feature that enables the\ncopying of a hot field marked by the JIT immediately after the\nobject containing the hot field is copied for balanced gc policy.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>", "committedDate": "2020-11-12T15:30:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM4MTI5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r524381294", "bodyText": "We should share this sorting code with Scavenger(Delegate).\nWe could also move it to core VM, and pass a few GC specific parameters from GC Extensions through method arguments.\n@dmitripivkine do you have a preference if this should stay in GC or VM?", "author": "amicic", "createdAt": "2020-11-16T16:04:23Z", "path": "runtime/gc_vlhgc/CopyForwardScheme.cpp", "diffHunk": "@@ -1452,6 +1463,92 @@ MM_CopyForwardScheme::mainSetupForCopyForward(MM_EnvironmentVLHGC *env)\n \t_shouldScanFinalizableObjects = _extensions->finalizeListManager->isFinalizableObjectProcessingRequired();\n }\n \n+void\n+MM_CopyForwardScheme::sortAllHotFieldData()", "originalCommit": "f4d59d9e6896cabb34c4fb74dd2632fe5accd7bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQxNjc1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r524416756", "bodyText": "I agree this code should be shared between GC policies. We can strip out core functionality and leave policy dependable code (like stats update) in the place.\nI think we can keep this code in GC for now. We can put it in gc_base. We can make this code more independent from other GC code by replacing direct references to GC Extensions (like _extensions->depthCopyThreePaths) to parameters. This will make move to VM easier if we need it in the future.", "author": "dmitripivkine", "createdAt": "2020-11-16T16:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM4MTI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQzNTE5NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r524435195", "bodyText": "ok, let's create gc_base/HotFieldUtil.hpp/cpp and move those 2 sorting methods from ScavDelegate there", "author": "amicic", "createdAt": "2020-11-16T17:13:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM4MTI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUwOTg4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r524509882", "bodyText": "Ok \ud83d\udc4d   Although a large portion of the sorting methods are the same, there are differences between the sorting methods in ScavengerDelegate and CopyForwardScheme unique to the  gc policy which is what prevented me to share this sorting code in a cleaner manner (balanced does not use _extensions->allowPermanantHotFields and _extensions->adaptiveGcCountBetweenHotFieldSort). The only method that could be easily shared was resetAllHotFieldData which I moved to the VM. The core elements of the sorting methods are the same and could be shared. With that said, should I move the resetAllHotFieldData and core elements of the hot field sorting methods to the newly created gc_base/HotFieldUtil.hpp/cpp? @dmitripivkine @amicic", "author": "jonoommen", "createdAt": "2020-11-16T19:12:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM4MTI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQzNjA0OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r524436048", "bodyText": "this should probably move together with sorting code", "author": "amicic", "createdAt": "2020-11-16T17:14:33Z", "path": "runtime/vm/jvmfree.c", "diffHunk": "@@ -341,6 +341,31 @@ freeJ9Module(J9JavaVM *javaVM, J9Module *j9module) {\n \tTrc_MODULE_freeJ9Module_exit(j9module);\n }\n \n+/**\n+ * Reset all hot fields for all classes.\n+ * Used when scavenger dynamicBreadthFirstScanOrdering is enabled and hotFieldResettingEnabled is true.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ */\n+void\n+resetAllHotFieldData(J9JavaVM *javaVM)\n+{", "originalCommit": "f4d59d9e6896cabb34c4fb74dd2632fe5accd7bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ2NDE4NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525464184", "bodyText": "It's enough to just pass Ext - you can get JavaVM from there.", "author": "amicic", "createdAt": "2020-11-17T19:59:10Z", "path": "runtime/gc_base/HotFieldUtil.cpp", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+\n+#if defined(J9VM_GC_MODRON_SCAVENGER) || defined(J9VM_GC_VLHGC)\n+\n+#include \"HotFieldUtil.hpp\"\n+#include \"GCExtensions.hpp\"\n+\n+/* Value used to help with the incrementing of the gc count between hot field sorting for dynamicBreadthFirstScanOrdering */\n+#define INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT 100\n+\n+/* Minimum hotness value for a third hot field offset if depthCopyThreePaths is enabled for dynamicBreadthFirstScanOrdering */\n+#define MINIMUM_THIRD_HOT_FIELD_HOTNESS 50000\n+\n+void\n+MM_HotFieldUtil::sortAllHotFieldData(J9JavaVM *javaVM, MM_GCExtensions *extensions)\n+{\t", "originalCommit": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ4Njk5OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525486999", "bodyText": "I think would be better to pass JavaVM and get GCExtensions from it", "author": "dmitripivkine", "createdAt": "2020-11-17T20:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ2NDE4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5ODU2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525498568", "bodyText": "i'm fine with that, too.", "author": "amicic", "createdAt": "2020-11-17T20:27:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ2NDE4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUwNTYwMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525505601", "bodyText": "I looked to implementations for both functions and there is no difference really, so I am fine with either way...", "author": "dmitripivkine", "createdAt": "2020-11-17T20:33:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ2NDE4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyMjQ1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525522451", "bodyText": "Ok \ud83d\udc4d  I made the change to pass Extensions and then changed it to pass JavaVM. If both are fine then I will just pass JavaVM.", "author": "jonoommen", "createdAt": "2020-11-17T21:02:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ2NDE4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNTY5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525525694", "bodyText": "pass just JavaVM (here and then to be consistent in the other methods, too)", "author": "amicic", "createdAt": "2020-11-17T21:08:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ2NDE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ2NTQyNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525465427", "bodyText": "a file needs to finish with an empty line", "author": "amicic", "createdAt": "2020-11-17T20:00:11Z", "path": "runtime/gc_base/HotFieldUtil.cpp", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+\n+#if defined(J9VM_GC_MODRON_SCAVENGER) || defined(J9VM_GC_VLHGC)\n+\n+#include \"HotFieldUtil.hpp\"\n+#include \"GCExtensions.hpp\"\n+\n+/* Value used to help with the incrementing of the gc count between hot field sorting for dynamicBreadthFirstScanOrdering */\n+#define INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT 100\n+\n+/* Minimum hotness value for a third hot field offset if depthCopyThreePaths is enabled for dynamicBreadthFirstScanOrdering */\n+#define MINIMUM_THIRD_HOT_FIELD_HOTNESS 50000\n+\n+void\n+MM_HotFieldUtil::sortAllHotFieldData(J9JavaVM *javaVM, MM_GCExtensions *extensions)\n+{\t\n+\t/* update hottest fields for all elements of the hotFieldClassInfoPool where isClassHotFieldListDirty is true */\n+\tif ((NULL != javaVM->hotFieldClassInfoPool) && ((extensions->scavengerStats._gcCount  % extensions->gcCountBetweenHotFieldSort) == 0)) {\n+\t\tpool_state hotFieldClassInfoPoolState;\n+\t\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp;\n+\t\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_startDo(javaVM->hotFieldClassInfoPool, &hotFieldClassInfoPoolState);\n+\t\t\n+\t\t/* sort hot field list for the class if the hot field list of the class is dirty */\n+\t\twhile ((NULL != hotFieldClassInfoTemp) && (U_8_MAX != hotFieldClassInfoTemp->consecutiveHotFieldSelections)) {\n+\t\t\tif (hotFieldClassInfoTemp->isClassHotFieldListDirty) {\n+\t\t\t\tsortClassHotFieldList(hotFieldClassInfoTemp, extensions);\n+\t\t\t}\n+\t\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_nextDo(&hotFieldClassInfoPoolState);\n+\t\t}\n+\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t}\n+\t/* If adaptiveGcCountBetweenHotFieldSort, update the gc count required between sorting all hot fields as the application runs longer */\n+\tif ((extensions->adaptiveGcCountBetweenHotFieldSort) && (extensions->gcCountBetweenHotFieldSort < extensions->gcCountBetweenHotFieldSortMax) && ((extensions->scavengerStats._gcCount % INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT) == 0)) {\n+\t\textensions->gcCountBetweenHotFieldSort++;\n+\t}\n+\t/* If hotFieldResettingEnabled, update the gc count required between resetting all hot fields */\n+\tif ((extensions->hotFieldResettingEnabled) && ((extensions->scavengerStats._gcCount % extensions->gcCountBetweenHotFieldReset) == 0)) {\n+\t\tresetAllHotFieldData(javaVM);\n+\t}\n+}\n+\n+MMINLINE void\n+MM_HotFieldUtil::sortClassHotFieldList(J9ClassHotFieldsInfo* hotFieldClassInfo, MM_GCExtensions *extensions) {\n+\t/* store initial hot field offsets before hotFieldClassInfo hot field offsets are updated */\n+\tuint8_t initialHotFieldOffset1 = hotFieldClassInfo->hotFieldOffset1;\n+\tuint8_t initialHotFieldOffset2 = hotFieldClassInfo->hotFieldOffset2;\n+\tuint8_t initialHotFieldOffset3 = hotFieldClassInfo->hotFieldOffset3;\n+\n+\t/* compute and update the hot fields for each class */\n+\tif (1 == hotFieldClassInfo->hotFieldListLength) {\n+\t\thotFieldClassInfo->hotFieldOffset1 = hotFieldClassInfo->hotFieldListHead->hotFieldOffset;\n+\t} else {\n+\t\tJ9HotField* currentHotField = hotFieldClassInfo->hotFieldListHead;\n+\t\tuint64_t hottest = 0;\n+\t\tuint64_t secondHottest = 0;\n+\t\tuint64_t thirdHottest = 0;\n+\t\tuint64_t current = 0;\n+\t\twhile (NULL != currentHotField) {\n+\t\t\tif(currentHotField->cpuUtil > extensions->minCpuUtil) {\n+\t\t\t\tcurrent = currentHotField->hotness;\n+\t\t\t\t/* compute the three hottest fields if depthCopyThreePaths is enabled, or the two hottest fields if only depthCopyTwoPaths is enabled, otherwise, compute just the hottest field if both depthCopyTwoPaths and depthCopyThreePaths are disabled */\n+\t\t\t\tif (extensions->depthCopyThreePaths) {\n+\t\t\t\t\tif (current > hottest) {\n+\t\t\t\t\t\tthirdHottest = secondHottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset3 = hotFieldClassInfo->hotFieldOffset2;\n+\t\t\t\t\t\tsecondHottest = hottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = hotFieldClassInfo->hotFieldOffset1;\n+\t\t\t\t\t\thottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t} else if (current > secondHottest) {\n+\t\t\t\t\t\tthirdHottest = secondHottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset3 = hotFieldClassInfo->hotFieldOffset2;\n+\t\t\t\t\t\tsecondHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = currentHotField->hotFieldOffset;\t\t\n+\t\t\t\t\t} else if (current > thirdHottest) {\n+\t\t\t\t\t\tthirdHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset3 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t}\n+\t\t\t\t} else if (extensions->depthCopyTwoPaths) {\n+\t\t\t\t\tif (current > hottest) {\n+\t\t\t\t\t\tsecondHottest = hottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = hotFieldClassInfo->hotFieldOffset1;\n+\t\t\t\t\t\thottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t} else if (current > secondHottest) {\n+\t\t\t\t\t\tsecondHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = currentHotField->hotFieldOffset;\t\t\n+\t\t\t\t\t}\n+\t\t\t\t} else if (current > hottest) {\n+\t\t\t\t\thottest = current;\n+\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcurrentHotField = currentHotField->next;\n+\t\t}\n+\t\tif (thirdHottest < MINIMUM_THIRD_HOT_FIELD_HOTNESS) { \n+\t\t\thotFieldClassInfo->hotFieldOffset3 = U_8_MAX;\n+\t\t}\n+\t}\n+\t/* if permanantHotFields are allowed, update consecutiveHotFieldSelections counter if hot field offsets are the same as the previous time the class hot field list was sorted  */\n+\tif (extensions->allowPermanantHotFields) {\n+\t\tif ((initialHotFieldOffset1 == hotFieldClassInfo->hotFieldOffset1) && (initialHotFieldOffset2 == hotFieldClassInfo->hotFieldOffset2) && (initialHotFieldOffset3 == hotFieldClassInfo->hotFieldOffset3)) {\n+\t\t\thotFieldClassInfo->consecutiveHotFieldSelections++;\n+\t\t\tif (hotFieldClassInfo->consecutiveHotFieldSelections == extensions->maxConsecutiveHotFieldSelections) { \n+\t\t\t\thotFieldClassInfo->consecutiveHotFieldSelections = U_8_MAX;\n+\t\t\t}\n+\t\t} else {\n+\t\t\thotFieldClassInfo->consecutiveHotFieldSelections = 0;\n+\t\t}\n+\t}\n+\thotFieldClassInfo->isClassHotFieldListDirty = false;\n+}\n+\n+/**\n+ * Reset all hot fields for all classes.\n+ * Used when dynamicBreadthFirstScanOrdering is enabled and hotFieldResettingEnabled is true.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ */\n+MMINLINE void\n+MM_HotFieldUtil::resetAllHotFieldData(J9JavaVM *javaVM)\n+{\n+\tpool_state hotFieldClassInfoPoolState;\n+\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp;\n+\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo *)pool_startDo(javaVM->hotFieldClassInfoPool, &hotFieldClassInfoPoolState);\n+\twhile (NULL != hotFieldClassInfoTemp) {\n+\t\tJ9HotField* currentHotField = hotFieldClassInfoTemp->hotFieldListHead;\n+\t\twhile (NULL != currentHotField) {\n+\t\t\tcurrentHotField->hotness = 0;\n+\t\t\tcurrentHotField->cpuUtil = 0;\n+\t\t\tcurrentHotField = currentHotField->next;\n+\t\t}\n+\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_nextDo(&hotFieldClassInfoPoolState);\n+\t}\n+\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+}\n+\n+#endif /* J9VM_GC_MODRON_SCAVENGER || J9VM_GC_VLHGC */", "originalCommit": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ2NjQ0Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525466446", "bodyText": "move the declaration down, where you initialize it", "author": "amicic", "createdAt": "2020-11-17T20:01:02Z", "path": "runtime/gc_base/HotFieldUtil.cpp", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+\n+#if defined(J9VM_GC_MODRON_SCAVENGER) || defined(J9VM_GC_VLHGC)\n+\n+#include \"HotFieldUtil.hpp\"\n+#include \"GCExtensions.hpp\"\n+\n+/* Value used to help with the incrementing of the gc count between hot field sorting for dynamicBreadthFirstScanOrdering */\n+#define INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT 100\n+\n+/* Minimum hotness value for a third hot field offset if depthCopyThreePaths is enabled for dynamicBreadthFirstScanOrdering */\n+#define MINIMUM_THIRD_HOT_FIELD_HOTNESS 50000\n+\n+void\n+MM_HotFieldUtil::sortAllHotFieldData(J9JavaVM *javaVM, MM_GCExtensions *extensions)\n+{\t\n+\t/* update hottest fields for all elements of the hotFieldClassInfoPool where isClassHotFieldListDirty is true */\n+\tif ((NULL != javaVM->hotFieldClassInfoPool) && ((extensions->scavengerStats._gcCount  % extensions->gcCountBetweenHotFieldSort) == 0)) {\n+\t\tpool_state hotFieldClassInfoPoolState;\n+\t\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp;", "originalCommit": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ2NzY1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525467658", "bodyText": "move declaration down", "author": "amicic", "createdAt": "2020-11-17T20:02:05Z", "path": "runtime/gc_base/HotFieldUtil.cpp", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+\n+#if defined(J9VM_GC_MODRON_SCAVENGER) || defined(J9VM_GC_VLHGC)\n+\n+#include \"HotFieldUtil.hpp\"\n+#include \"GCExtensions.hpp\"\n+\n+/* Value used to help with the incrementing of the gc count between hot field sorting for dynamicBreadthFirstScanOrdering */\n+#define INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT 100\n+\n+/* Minimum hotness value for a third hot field offset if depthCopyThreePaths is enabled for dynamicBreadthFirstScanOrdering */\n+#define MINIMUM_THIRD_HOT_FIELD_HOTNESS 50000\n+\n+void\n+MM_HotFieldUtil::sortAllHotFieldData(J9JavaVM *javaVM, MM_GCExtensions *extensions)\n+{\t\n+\t/* update hottest fields for all elements of the hotFieldClassInfoPool where isClassHotFieldListDirty is true */\n+\tif ((NULL != javaVM->hotFieldClassInfoPool) && ((extensions->scavengerStats._gcCount  % extensions->gcCountBetweenHotFieldSort) == 0)) {\n+\t\tpool_state hotFieldClassInfoPoolState;\n+\t\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp;\n+\t\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_startDo(javaVM->hotFieldClassInfoPool, &hotFieldClassInfoPoolState);\n+\t\t\n+\t\t/* sort hot field list for the class if the hot field list of the class is dirty */\n+\t\twhile ((NULL != hotFieldClassInfoTemp) && (U_8_MAX != hotFieldClassInfoTemp->consecutiveHotFieldSelections)) {\n+\t\t\tif (hotFieldClassInfoTemp->isClassHotFieldListDirty) {\n+\t\t\t\tsortClassHotFieldList(hotFieldClassInfoTemp, extensions);\n+\t\t\t}\n+\t\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_nextDo(&hotFieldClassInfoPoolState);\n+\t\t}\n+\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t}\n+\t/* If adaptiveGcCountBetweenHotFieldSort, update the gc count required between sorting all hot fields as the application runs longer */\n+\tif ((extensions->adaptiveGcCountBetweenHotFieldSort) && (extensions->gcCountBetweenHotFieldSort < extensions->gcCountBetweenHotFieldSortMax) && ((extensions->scavengerStats._gcCount % INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT) == 0)) {\n+\t\textensions->gcCountBetweenHotFieldSort++;\n+\t}\n+\t/* If hotFieldResettingEnabled, update the gc count required between resetting all hot fields */\n+\tif ((extensions->hotFieldResettingEnabled) && ((extensions->scavengerStats._gcCount % extensions->gcCountBetweenHotFieldReset) == 0)) {\n+\t\tresetAllHotFieldData(javaVM);\n+\t}\n+}\n+\n+MMINLINE void\n+MM_HotFieldUtil::sortClassHotFieldList(J9ClassHotFieldsInfo* hotFieldClassInfo, MM_GCExtensions *extensions) {\n+\t/* store initial hot field offsets before hotFieldClassInfo hot field offsets are updated */\n+\tuint8_t initialHotFieldOffset1 = hotFieldClassInfo->hotFieldOffset1;\n+\tuint8_t initialHotFieldOffset2 = hotFieldClassInfo->hotFieldOffset2;\n+\tuint8_t initialHotFieldOffset3 = hotFieldClassInfo->hotFieldOffset3;\n+\n+\t/* compute and update the hot fields for each class */\n+\tif (1 == hotFieldClassInfo->hotFieldListLength) {\n+\t\thotFieldClassInfo->hotFieldOffset1 = hotFieldClassInfo->hotFieldListHead->hotFieldOffset;\n+\t} else {\n+\t\tJ9HotField* currentHotField = hotFieldClassInfo->hotFieldListHead;\n+\t\tuint64_t hottest = 0;\n+\t\tuint64_t secondHottest = 0;\n+\t\tuint64_t thirdHottest = 0;\n+\t\tuint64_t current = 0;\n+\t\twhile (NULL != currentHotField) {\n+\t\t\tif(currentHotField->cpuUtil > extensions->minCpuUtil) {\n+\t\t\t\tcurrent = currentHotField->hotness;\n+\t\t\t\t/* compute the three hottest fields if depthCopyThreePaths is enabled, or the two hottest fields if only depthCopyTwoPaths is enabled, otherwise, compute just the hottest field if both depthCopyTwoPaths and depthCopyThreePaths are disabled */\n+\t\t\t\tif (extensions->depthCopyThreePaths) {\n+\t\t\t\t\tif (current > hottest) {\n+\t\t\t\t\t\tthirdHottest = secondHottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset3 = hotFieldClassInfo->hotFieldOffset2;\n+\t\t\t\t\t\tsecondHottest = hottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = hotFieldClassInfo->hotFieldOffset1;\n+\t\t\t\t\t\thottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t} else if (current > secondHottest) {\n+\t\t\t\t\t\tthirdHottest = secondHottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset3 = hotFieldClassInfo->hotFieldOffset2;\n+\t\t\t\t\t\tsecondHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = currentHotField->hotFieldOffset;\t\t\n+\t\t\t\t\t} else if (current > thirdHottest) {\n+\t\t\t\t\t\tthirdHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset3 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t}\n+\t\t\t\t} else if (extensions->depthCopyTwoPaths) {\n+\t\t\t\t\tif (current > hottest) {\n+\t\t\t\t\t\tsecondHottest = hottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = hotFieldClassInfo->hotFieldOffset1;\n+\t\t\t\t\t\thottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t} else if (current > secondHottest) {\n+\t\t\t\t\t\tsecondHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = currentHotField->hotFieldOffset;\t\t\n+\t\t\t\t\t}\n+\t\t\t\t} else if (current > hottest) {\n+\t\t\t\t\thottest = current;\n+\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcurrentHotField = currentHotField->next;\n+\t\t}\n+\t\tif (thirdHottest < MINIMUM_THIRD_HOT_FIELD_HOTNESS) { \n+\t\t\thotFieldClassInfo->hotFieldOffset3 = U_8_MAX;\n+\t\t}\n+\t}\n+\t/* if permanantHotFields are allowed, update consecutiveHotFieldSelections counter if hot field offsets are the same as the previous time the class hot field list was sorted  */\n+\tif (extensions->allowPermanantHotFields) {\n+\t\tif ((initialHotFieldOffset1 == hotFieldClassInfo->hotFieldOffset1) && (initialHotFieldOffset2 == hotFieldClassInfo->hotFieldOffset2) && (initialHotFieldOffset3 == hotFieldClassInfo->hotFieldOffset3)) {\n+\t\t\thotFieldClassInfo->consecutiveHotFieldSelections++;\n+\t\t\tif (hotFieldClassInfo->consecutiveHotFieldSelections == extensions->maxConsecutiveHotFieldSelections) { \n+\t\t\t\thotFieldClassInfo->consecutiveHotFieldSelections = U_8_MAX;\n+\t\t\t}\n+\t\t} else {\n+\t\t\thotFieldClassInfo->consecutiveHotFieldSelections = 0;\n+\t\t}\n+\t}\n+\thotFieldClassInfo->isClassHotFieldListDirty = false;\n+}\n+\n+/**\n+ * Reset all hot fields for all classes.\n+ * Used when dynamicBreadthFirstScanOrdering is enabled and hotFieldResettingEnabled is true.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ */\n+MMINLINE void\n+MM_HotFieldUtil::resetAllHotFieldData(J9JavaVM *javaVM)\n+{\n+\tpool_state hotFieldClassInfoPoolState;\n+\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp;", "originalCommit": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ3MjgxNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525472815", "bodyText": "could've been just plain C methods without a class. not a strong preference, so you can leave it as is (@dmitripivkine do you prefer one or the other?)", "author": "amicic", "createdAt": "2020-11-17T20:06:21Z", "path": "runtime/gc_base/HotFieldUtil.hpp", "diffHunk": "@@ -0,0 +1,69 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+/**\n+ * @file\n+ * @ingroup GC_Base\n+ */\n+\n+#if !defined(HOTFIELDUTIL_HPP_)\n+#define HOTFIELDUTIL_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+\n+#if defined(J9VM_GC_MODRON_SCAVENGER) || defined(J9VM_GC_VLHGC)\n+\n+#include \"BaseNonVirtual.hpp\"\n+#include \"GCExtensions.hpp\"\n+\n+\n+/**\n+ * @todo Provide class documentation\n+ * @ingroup GC_Base\n+ */\n+class MM_HotFieldUtil : public MM_BaseNonVirtual\n+{\n+public:\n+    /**\n+\t * Sort all hot fields for all classes.\n+\t * Used when scavenger dynamicBreadthFirstScanOrdering is enabled\n+\t */\n+\tstatic void sortAllHotFieldData(J9JavaVM *javaVM, MM_GCExtensions *extensions);\n+\n+\t/**\n+\t * Sort all hot fields for a single class.\n+\t * Used when scavenger dynamicBreadthFirstScanOrdering is enabled\n+\t */\n+\tMMINLINE static void sortClassHotFieldList(J9ClassHotFieldsInfo* hotFieldClassInfo, MM_GCExtensions *extensions);\n+\n+\t/**\n+\t * Reset all hot fields for all classes.\n+\t * Used when scavenger dynamicBreadthFirstScanOrdering is enabled and hotFieldResettingEnabled is true.\n+\t *\n+\t * @param javaVM[in] pointer to the J9JavaVM\n+\t */\n+\tMMINLINE static void resetAllHotFieldData(J9JavaVM *javaVM);", "originalCommit": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxNjc5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525516792", "bodyText": "I think C++ methods (with class) would be better", "author": "dmitripivkine", "createdAt": "2020-11-17T20:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ3MjgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ3MzU0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525473549", "bodyText": "put Ext as first arg", "author": "amicic", "createdAt": "2020-11-17T20:06:58Z", "path": "runtime/gc_base/HotFieldUtil.cpp", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+\n+#if defined(J9VM_GC_MODRON_SCAVENGER) || defined(J9VM_GC_VLHGC)\n+\n+#include \"HotFieldUtil.hpp\"\n+#include \"GCExtensions.hpp\"\n+\n+/* Value used to help with the incrementing of the gc count between hot field sorting for dynamicBreadthFirstScanOrdering */\n+#define INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT 100\n+\n+/* Minimum hotness value for a third hot field offset if depthCopyThreePaths is enabled for dynamicBreadthFirstScanOrdering */\n+#define MINIMUM_THIRD_HOT_FIELD_HOTNESS 50000\n+\n+void\n+MM_HotFieldUtil::sortAllHotFieldData(J9JavaVM *javaVM, MM_GCExtensions *extensions)\n+{\t\n+\t/* update hottest fields for all elements of the hotFieldClassInfoPool where isClassHotFieldListDirty is true */\n+\tif ((NULL != javaVM->hotFieldClassInfoPool) && ((extensions->scavengerStats._gcCount  % extensions->gcCountBetweenHotFieldSort) == 0)) {\n+\t\tpool_state hotFieldClassInfoPoolState;\n+\t\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp;\n+\t\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_startDo(javaVM->hotFieldClassInfoPool, &hotFieldClassInfoPoolState);\n+\t\t\n+\t\t/* sort hot field list for the class if the hot field list of the class is dirty */\n+\t\twhile ((NULL != hotFieldClassInfoTemp) && (U_8_MAX != hotFieldClassInfoTemp->consecutiveHotFieldSelections)) {\n+\t\t\tif (hotFieldClassInfoTemp->isClassHotFieldListDirty) {\n+\t\t\t\tsortClassHotFieldList(hotFieldClassInfoTemp, extensions);\n+\t\t\t}\n+\t\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_nextDo(&hotFieldClassInfoPoolState);\n+\t\t}\n+\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t}\n+\t/* If adaptiveGcCountBetweenHotFieldSort, update the gc count required between sorting all hot fields as the application runs longer */\n+\tif ((extensions->adaptiveGcCountBetweenHotFieldSort) && (extensions->gcCountBetweenHotFieldSort < extensions->gcCountBetweenHotFieldSortMax) && ((extensions->scavengerStats._gcCount % INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT) == 0)) {\n+\t\textensions->gcCountBetweenHotFieldSort++;\n+\t}\n+\t/* If hotFieldResettingEnabled, update the gc count required between resetting all hot fields */\n+\tif ((extensions->hotFieldResettingEnabled) && ((extensions->scavengerStats._gcCount % extensions->gcCountBetweenHotFieldReset) == 0)) {\n+\t\tresetAllHotFieldData(javaVM);\n+\t}\n+}\n+\n+MMINLINE void\n+MM_HotFieldUtil::sortClassHotFieldList(J9ClassHotFieldsInfo* hotFieldClassInfo, MM_GCExtensions *extensions) {", "originalCommit": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ3NDM0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525474343", "bodyText": "to be more consistent with other methods, you can pass Ext", "author": "amicic", "createdAt": "2020-11-17T20:07:38Z", "path": "runtime/gc_base/HotFieldUtil.cpp", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+\n+#if defined(J9VM_GC_MODRON_SCAVENGER) || defined(J9VM_GC_VLHGC)\n+\n+#include \"HotFieldUtil.hpp\"\n+#include \"GCExtensions.hpp\"\n+\n+/* Value used to help with the incrementing of the gc count between hot field sorting for dynamicBreadthFirstScanOrdering */\n+#define INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT 100\n+\n+/* Minimum hotness value for a third hot field offset if depthCopyThreePaths is enabled for dynamicBreadthFirstScanOrdering */\n+#define MINIMUM_THIRD_HOT_FIELD_HOTNESS 50000\n+\n+void\n+MM_HotFieldUtil::sortAllHotFieldData(J9JavaVM *javaVM, MM_GCExtensions *extensions)\n+{\t\n+\t/* update hottest fields for all elements of the hotFieldClassInfoPool where isClassHotFieldListDirty is true */\n+\tif ((NULL != javaVM->hotFieldClassInfoPool) && ((extensions->scavengerStats._gcCount  % extensions->gcCountBetweenHotFieldSort) == 0)) {\n+\t\tpool_state hotFieldClassInfoPoolState;\n+\t\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp;\n+\t\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_startDo(javaVM->hotFieldClassInfoPool, &hotFieldClassInfoPoolState);\n+\t\t\n+\t\t/* sort hot field list for the class if the hot field list of the class is dirty */\n+\t\twhile ((NULL != hotFieldClassInfoTemp) && (U_8_MAX != hotFieldClassInfoTemp->consecutiveHotFieldSelections)) {\n+\t\t\tif (hotFieldClassInfoTemp->isClassHotFieldListDirty) {\n+\t\t\t\tsortClassHotFieldList(hotFieldClassInfoTemp, extensions);\n+\t\t\t}\n+\t\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_nextDo(&hotFieldClassInfoPoolState);\n+\t\t}\n+\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t}\n+\t/* If adaptiveGcCountBetweenHotFieldSort, update the gc count required between sorting all hot fields as the application runs longer */\n+\tif ((extensions->adaptiveGcCountBetweenHotFieldSort) && (extensions->gcCountBetweenHotFieldSort < extensions->gcCountBetweenHotFieldSortMax) && ((extensions->scavengerStats._gcCount % INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT) == 0)) {\n+\t\textensions->gcCountBetweenHotFieldSort++;\n+\t}\n+\t/* If hotFieldResettingEnabled, update the gc count required between resetting all hot fields */\n+\tif ((extensions->hotFieldResettingEnabled) && ((extensions->scavengerStats._gcCount % extensions->gcCountBetweenHotFieldReset) == 0)) {\n+\t\tresetAllHotFieldData(javaVM);\n+\t}\n+}\n+\n+MMINLINE void\n+MM_HotFieldUtil::sortClassHotFieldList(J9ClassHotFieldsInfo* hotFieldClassInfo, MM_GCExtensions *extensions) {\n+\t/* store initial hot field offsets before hotFieldClassInfo hot field offsets are updated */\n+\tuint8_t initialHotFieldOffset1 = hotFieldClassInfo->hotFieldOffset1;\n+\tuint8_t initialHotFieldOffset2 = hotFieldClassInfo->hotFieldOffset2;\n+\tuint8_t initialHotFieldOffset3 = hotFieldClassInfo->hotFieldOffset3;\n+\n+\t/* compute and update the hot fields for each class */\n+\tif (1 == hotFieldClassInfo->hotFieldListLength) {\n+\t\thotFieldClassInfo->hotFieldOffset1 = hotFieldClassInfo->hotFieldListHead->hotFieldOffset;\n+\t} else {\n+\t\tJ9HotField* currentHotField = hotFieldClassInfo->hotFieldListHead;\n+\t\tuint64_t hottest = 0;\n+\t\tuint64_t secondHottest = 0;\n+\t\tuint64_t thirdHottest = 0;\n+\t\tuint64_t current = 0;\n+\t\twhile (NULL != currentHotField) {\n+\t\t\tif(currentHotField->cpuUtil > extensions->minCpuUtil) {\n+\t\t\t\tcurrent = currentHotField->hotness;\n+\t\t\t\t/* compute the three hottest fields if depthCopyThreePaths is enabled, or the two hottest fields if only depthCopyTwoPaths is enabled, otherwise, compute just the hottest field if both depthCopyTwoPaths and depthCopyThreePaths are disabled */\n+\t\t\t\tif (extensions->depthCopyThreePaths) {\n+\t\t\t\t\tif (current > hottest) {\n+\t\t\t\t\t\tthirdHottest = secondHottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset3 = hotFieldClassInfo->hotFieldOffset2;\n+\t\t\t\t\t\tsecondHottest = hottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = hotFieldClassInfo->hotFieldOffset1;\n+\t\t\t\t\t\thottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t} else if (current > secondHottest) {\n+\t\t\t\t\t\tthirdHottest = secondHottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset3 = hotFieldClassInfo->hotFieldOffset2;\n+\t\t\t\t\t\tsecondHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = currentHotField->hotFieldOffset;\t\t\n+\t\t\t\t\t} else if (current > thirdHottest) {\n+\t\t\t\t\t\tthirdHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset3 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t}\n+\t\t\t\t} else if (extensions->depthCopyTwoPaths) {\n+\t\t\t\t\tif (current > hottest) {\n+\t\t\t\t\t\tsecondHottest = hottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = hotFieldClassInfo->hotFieldOffset1;\n+\t\t\t\t\t\thottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t} else if (current > secondHottest) {\n+\t\t\t\t\t\tsecondHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = currentHotField->hotFieldOffset;\t\t\n+\t\t\t\t\t}\n+\t\t\t\t} else if (current > hottest) {\n+\t\t\t\t\thottest = current;\n+\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcurrentHotField = currentHotField->next;\n+\t\t}\n+\t\tif (thirdHottest < MINIMUM_THIRD_HOT_FIELD_HOTNESS) { \n+\t\t\thotFieldClassInfo->hotFieldOffset3 = U_8_MAX;\n+\t\t}\n+\t}\n+\t/* if permanantHotFields are allowed, update consecutiveHotFieldSelections counter if hot field offsets are the same as the previous time the class hot field list was sorted  */\n+\tif (extensions->allowPermanantHotFields) {\n+\t\tif ((initialHotFieldOffset1 == hotFieldClassInfo->hotFieldOffset1) && (initialHotFieldOffset2 == hotFieldClassInfo->hotFieldOffset2) && (initialHotFieldOffset3 == hotFieldClassInfo->hotFieldOffset3)) {\n+\t\t\thotFieldClassInfo->consecutiveHotFieldSelections++;\n+\t\t\tif (hotFieldClassInfo->consecutiveHotFieldSelections == extensions->maxConsecutiveHotFieldSelections) { \n+\t\t\t\thotFieldClassInfo->consecutiveHotFieldSelections = U_8_MAX;\n+\t\t\t}\n+\t\t} else {\n+\t\t\thotFieldClassInfo->consecutiveHotFieldSelections = 0;\n+\t\t}\n+\t}\n+\thotFieldClassInfo->isClassHotFieldListDirty = false;\n+}\n+\n+/**\n+ * Reset all hot fields for all classes.\n+ * Used when dynamicBreadthFirstScanOrdering is enabled and hotFieldResettingEnabled is true.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ */\n+MMINLINE void\n+MM_HotFieldUtil::resetAllHotFieldData(J9JavaVM *javaVM)", "originalCommit": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NDQ2Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525494466", "bodyText": "I don't think we need to change anything here, until we enable dynamic ordering by default.", "author": "amicic", "createdAt": "2020-11-17T20:24:24Z", "path": "runtime/gc_vlhgc/ConfigurationIncrementalGenerational.cpp", "diffHunk": "@@ -272,8 +272,16 @@ MM_ConfigurationIncrementalGenerational::initialize(MM_EnvironmentBase *env)\n \n \tbool result = MM_Configuration::initialize(env);\n \n+\t/* By default disable hot field depth copying */\n+\tenv->disableHotFieldDepthCopy();\n+\n \tif (result) {\n-\t\textensions->scavengerScanOrdering = MM_GCExtensions::OMR_GC_SCAVENGER_SCANORDERING_BREADTH_FIRST;\n+\t\tif (extensions->scavengerScanOrdering != MM_GCExtensions::OMR_GC_SCAVENGER_SCANORDERING_DYNAMIC_BREADTH_FIRST) {", "originalCommit": "e1aea6ba0a805778b85f0db15246c9ecdf627794", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzMzM3NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525533375", "bodyText": "Without this change, won't scan ordering be forced to breadthFirstScanOrdering even if the user selects dynamicBreadthFirstScanOrdering?", "author": "jonoommen", "createdAt": "2020-11-17T21:23:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NDQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzOTAyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525539026", "bodyText": "you are probably right. I was probably thinking that command parsing occurs after this, which would be a case with some other early initialization code, but not this one.", "author": "amicic", "createdAt": "2020-11-17T21:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NDQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NjE5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525496192", "bodyText": "Do we really have to force disabling of these two flags - what bad can happen if somebody enables them through an option?", "author": "amicic", "createdAt": "2020-11-17T20:25:44Z", "path": "runtime/gc_vlhgc/ConfigurationIncrementalGenerational.cpp", "diffHunk": "@@ -272,8 +272,16 @@ MM_ConfigurationIncrementalGenerational::initialize(MM_EnvironmentBase *env)\n \n \tbool result = MM_Configuration::initialize(env);\n \n+\t/* By default disable hot field depth copying */\n+\tenv->disableHotFieldDepthCopy();\n+\n \tif (result) {\n-\t\textensions->scavengerScanOrdering = MM_GCExtensions::OMR_GC_SCAVENGER_SCANORDERING_BREADTH_FIRST;\n+\t\tif (extensions->scavengerScanOrdering != MM_GCExtensions::OMR_GC_SCAVENGER_SCANORDERING_DYNAMIC_BREADTH_FIRST) {\n+\t\t\textensions->scavengerScanOrdering = MM_GCExtensions::OMR_GC_SCAVENGER_SCANORDERING_BREADTH_FIRST;\n+\t\t} else {\n+\t\t\textensions->adaptiveGcCountBetweenHotFieldSort = false;\n+\t\t\textensions->hotFieldResettingEnabled = false;", "originalCommit": "e1aea6ba0a805778b85f0db15246c9ecdf627794", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNzQ1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525527450", "bodyText": "Nothing bad, there would then just be unnecessary checks for balanced as adaptiveGcCountBetweenHotFieldSort and gcCountBetweenHotFieldReset are dependant on extensions->scavengerStats._gcCount in MM_HotFieldUtil::sortAllHotFieldData. Since extensions->scavengerStats._gcCount will always be zero for balanced, forcing these flags would avoid the unnecessary checks and computations.", "author": "jonoommen", "createdAt": "2020-11-17T21:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NjE5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0MDQwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525540408", "bodyText": "should we then add gcCount param to the method and pass it from the caller?", "author": "amicic", "createdAt": "2020-11-17T21:36:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NjE5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1Nzc0OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525557748", "bodyText": "Yes I could definitely do that and would just have to test the effects of adaptiveGcCountBetweenHotFieldSort for balanced. It proved to be effective for gencon so I have it enabled by default, however with 1000+ regions where different regions are selected for each pgc, this feature did not make sense to me in balanced and I was fairly certain it would not have a positive effect. hotFieldResettingEnabled does not need to be forced here as it is by default disabled, however for adaptiveGcCountBetweenHotFieldSort, should I either:\na) force it disabled for balanced (current implementation)\nb) add gcCount param and disable adaptiveGcCountBetweenHotFieldSort by default (negative effect on gencon with dynamic breadth first)\nc) enable it by default for gencon and balanced (I would need to test the effects of adaptiveGcCountBetweenHotFieldSort in balanced)\nI will do c) first and we take it from there. depending on the results.", "author": "jonoommen", "createdAt": "2020-11-17T22:09:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NjE5Mg=="}], "type": "inlineReview"}, {"oid": "0ab7051b3baff2ba6d5a6acbb62bc6548eb9f547", "url": "https://github.com/eclipse-openj9/openj9/commit/0ab7051b3baff2ba6d5a6acbb62bc6548eb9f547", "message": "disable adaptiveGcCountBetweenHotFieldSort", "committedDate": "2020-11-19T19:25:59Z", "type": "forcePushed"}, {"oid": "187929992bd296659245ca55d2bf57c2ff9fb90b", "url": "https://github.com/eclipse-openj9/openj9/commit/187929992bd296659245ca55d2bf57c2ff9fb90b", "message": "Add Dynamic Breadth First Scan Ordering to Balanced GC\n\nAdd a gc scavenger scan ordering feature that enables the\ncopying of a hot field marked by the JIT immediately after the\nobject containing the hot field is copied for balanced gc policy.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>", "committedDate": "2020-11-25T16:35:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyMTY5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r530521691", "bodyText": "use C style comment", "author": "amicic", "createdAt": "2020-11-25T17:00:02Z", "path": "runtime/gc_vlhgc/CopyForwardScheme.cpp", "diffHunk": "@@ -2096,6 +2107,43 @@ MM_CopyForwardScheme::updateInternalLeafPointersAfterCopy(J9IndexableObject *des\n \t}\n }\n \n+MMINLINE void\n+MM_CopyForwardScheme::depthCopyHotFields(MM_EnvironmentVLHGC *env, J9Class *clazz, J9Object *destinationObjectPtr, MM_AllocationContextTarok *reservingContext) {\n+\t/* depth copy the hot fields of an object up to a depth specified by depthCopyMax */\n+\tJ9ClassHotFieldsInfo* hotFieldsInfo = clazz->hotFieldsInfo;\n+\tif (env->_hotFieldCopyDepthCount < _extensions->depthCopyMax && NULL != hotFieldsInfo) {\n+\t\tU_8 hotFieldOffset = hotFieldsInfo->hotFieldOffset1;\n+\t\tif (U_8_MAX != hotFieldOffset) {\n+\t\t\tcopyHotField(env, destinationObjectPtr, hotFieldOffset, reservingContext);\n+\t\t\tU_8 hotFieldOffset2 = hotFieldsInfo->hotFieldOffset2;\n+\t\t\tif (U_8_MAX !=hotFieldOffset2) {\n+\t\t\t\tcopyHotField(env, destinationObjectPtr, hotFieldOffset2, reservingContext);\n+\t\t\t\tU_8 hotFieldOffset3 = hotFieldsInfo->hotFieldOffset3;\n+\t\t\t\tif (U_8_MAX != hotFieldOffset3) {\n+\t\t\t\t\tcopyHotField(env, destinationObjectPtr, hotFieldOffset3, reservingContext);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else if ((_extensions->alwaysDepthCopyFirstOffset) && (false == _extensions->objectModel.isIndexable(destinationObjectPtr))) {\n+\t\t\tcopyHotField(env, destinationObjectPtr, DEFAULT_HOT_FIELD_OFFSET, reservingContext);\n+\t\t}\n+\t}\t\n+}\n+\n+MMINLINE void\n+MM_CopyForwardScheme::copyHotField(MM_EnvironmentVLHGC *env, J9Object *destinationObjectPtr, U_8 offset, MM_AllocationContextTarok *reservingContext) {\n+\tGC_SlotObject hotFieldObject(_javaVM->omrVM, (fomrobject_t*)(destinationObjectPtr + offset));\n+\tomrobjectptr_t objectPtr = hotFieldObject.readReferenceFromSlot();\t\t\t\t\t\t\t\n+\tif (isObjectInEvacuateMemory(objectPtr)) {\n+\t\t// Hot field needs to be copy and forwarded.  Check if the work has already been done", "originalCommit": "187929992bd296659245ca55d2bf57c2ff9fb90b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "221774d8125af8af4df4b3f035b0762eeb95fc97", "url": "https://github.com/eclipse-openj9/openj9/commit/221774d8125af8af4df4b3f035b0762eeb95fc97", "message": "Add Dynamic Breadth First Scan Ordering to Balanced GC\n\nAdd a gc scavenger scan ordering feature that enables the\ncopying of a hot field marked by the JIT immediately after the\nobject containing the hot field is copied for balanced gc policy.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>", "committedDate": "2020-11-25T17:39:20Z", "type": "commit"}, {"oid": "221774d8125af8af4df4b3f035b0762eeb95fc97", "url": "https://github.com/eclipse-openj9/openj9/commit/221774d8125af8af4df4b3f035b0762eeb95fc97", "message": "Add Dynamic Breadth First Scan Ordering to Balanced GC\n\nAdd a gc scavenger scan ordering feature that enables the\ncopying of a hot field marked by the JIT immediately after the\nobject containing the hot field is copied for balanced gc policy.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>", "committedDate": "2020-11-25T17:39:20Z", "type": "forcePushed"}]}