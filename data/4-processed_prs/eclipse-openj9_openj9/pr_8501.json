{"pr_number": 8501, "pr_title": "JEP-370 Implementation (Part 3)", "pr_createdAt": "2020-02-04T22:30:24Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/8501", "timeline": [{"oid": "21a245c6554eb140e6e9adc861013d0298c96477", "url": "https://github.com/eclipse-openj9/openj9/commit/21a245c6554eb140e6e9adc861013d0298c96477", "message": "Handle NULL VarHandle.handleTable entries in VarHandle.toMethodHandle\n\nOpenJ9 VarHandle.handleTable entries are null for unsupported AccessMode\noperations when supporting derived OpenJDK VarHandle classes.\n\nWhen supporting derived OpenJDK VarHandle classes,\naccessModeTypeUncached is used to retrieve the AccessMode MethodType in\ncase VarHandle.handleTable entries are null.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-04T22:40:05Z", "type": "forcePushed"}, {"oid": "d721d801dfeb56975eea117c09c88cdad5457825", "url": "https://github.com/eclipse-openj9/openj9/commit/d721d801dfeb56975eea117c09c88cdad5457825", "message": "Handle NULL VarHandle.handleTable entries in VarHandle.toMethodHandle\n\nOpenJ9 VarHandle.handleTable entries are null for unsupported AccessMode\noperations when supporting derived OpenJDK VarHandle classes.\n\nWhen supporting derived OpenJDK VarHandle classes,\naccessModeTypeUncached is used to retrieve the AccessMode MethodType in\ncase VarHandle.handleTable entries are null.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-05T00:55:52Z", "type": "forcePushed"}, {"oid": "1d24c19e1f497a72445f10422d61f4e13248b952", "url": "https://github.com/eclipse-openj9/openj9/commit/1d24c19e1f497a72445f10422d61f4e13248b952", "message": "Handle NULL VarHandle.handleTable entries in VarHandle.toMethodHandle\n\nOpenJ9 VarHandle.handleTable entries are null for unsupported AccessMode\noperations when supporting derived OpenJDK VarHandle classes.\n\nWhen supporting derived OpenJDK VarHandle classes,\naccessModeTypeUncached is used to retrieve the AccessMode MethodType in\ncase VarHandle.handleTable entries are null.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-05T01:28:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4NTQzOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r375385439", "bodyText": "Would be good to comment here on why this is being done", "author": "DanHeidinga", "createdAt": "2020-02-05T17:02:33Z", "path": "runtime/bcutil/ConstantPoolMap.cpp", "diffHunk": "@@ -302,6 +302,14 @@ ConstantPoolMap::computeConstantPoolMapAndSizes()\n \t\t\t}\n \t\t}\n \t}\n+\n+\tJ9ClassPatchMap *map = _context->patchMap();", "originalCommit": "1d24c19e1f497a72445f10422d61f4e13248b952", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5MTk3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r375391977", "bodyText": "These are @fengxue-IS changes for Constant Pool Patching (#8460). These should go away after #8460 is merged, and this pull request is rebased. Only the four commits listed in the header description need to be reviewed for this pull request.", "author": "babsingh", "createdAt": "2020-02-05T17:13:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4NTQzOQ=="}], "type": "inlineReview"}, {"oid": "5efc135983dcb26d248f2c97fe75b6767021ec21", "url": "https://github.com/eclipse-openj9/openj9/commit/5efc135983dcb26d248f2c97fe75b6767021ec21", "message": "Handle NULL VarHandle.handleTable entries in VarHandle.toMethodHandle\n\nOpenJ9 VarHandle.handleTable entries are null for unsupported AccessMode\noperations when supporting derived OpenJDK VarHandle classes.\n\nWhen supporting derived OpenJDK VarHandle classes,\naccessModeTypeUncached is used to retrieve the AccessMode MethodType in\ncase VarHandle.handleTable entries are null.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-13T21:22:29Z", "type": "forcePushed"}, {"oid": "3a4672ab7f03d4440988c82758ada838292dfb64", "url": "https://github.com/eclipse-openj9/openj9/commit/3a4672ab7f03d4440988c82758ada838292dfb64", "message": "Handle NULL VarHandle.handleTable entries in VarHandle.toMethodHandle\n\nOpenJ9 VarHandle.handleTable entries are null for unsupported AccessMode\noperations when supporting derived OpenJDK VarHandle classes.\n\nWhen supporting derived OpenJDK VarHandle classes,\naccessModeTypeUncached is used to retrieve the AccessMode MethodType in\ncase VarHandle.handleTable entries are null.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-14T16:35:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcxMjI4NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r379712285", "bodyText": "Does this need to use the vmconstantpool?  Can we look up the class here if it's needed as it will only be used in error cases?\nI prefer not to grow the vmconstantpool if we can avoid it as every class in the pool is loaded at startup.", "author": "DanHeidinga", "createdAt": "2020-02-15T02:46:31Z", "path": "runtime/vm/MHInterpreter.cpp", "diffHunk": "@@ -555,6 +555,13 @@ VM_MHInterpreter::dispatchLoop(j9object_t methodHandle)\n \t\t\t/* Get MethodHandle for this operation from the VarHandle's handleTable */\n \t\t\tj9object_t handleTable = J9VMJAVALANGINVOKEVARHANDLE_HANDLETABLE(_currentThread, varHandle);\n \t\t\tj9object_t methodHandleFromTable = J9JAVAARRAYOFOBJECT_LOAD(_currentThread, handleTable, operation);\n+\n+\t\t\tif (NULL == methodHandleFromTable) {\n+\t\t\t\tprepareForExceptionThrow(_currentThread);\n+\t\t\t\tsetCurrentExceptionUTF(_currentThread, J9VMCONSTANTPOOL_JAVALANGUNSUPPORTEDOPERATIONEXCEPTION, NULL);", "originalCommit": "3a4672ab7f03d4440988c82758ada838292dfb64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDcyMjU1NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r380722554", "bodyText": "I have not noticed setCurrentException* examples without J9VMCONSTANTPOOL_* macros. So, vmconstantpool is required to throw the UnsupportedOperationException from setCurrentException*.", "author": "babsingh", "createdAt": "2020-02-18T14:55:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcxMjI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDcyNTU3Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r380725573", "bodyText": "I also observed that JEP370 testcases catch and ignore UnsupportedOperationException. We will under-perform in such scenarios if we look up for the exception class.", "author": "babsingh", "createdAt": "2020-02-18T14:59:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcxMjI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDczMjU0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r380732549", "bodyText": "I would rather we lookup the class, allocate an instance, and then throw with VM_VMHelpers::setExceptionPending than putting the class in the vm CP.\nTest cases will of course trigger the UnsupportedOperationException, real applications won't.  I'd rather optimize for real apps then tests :)", "author": "DanHeidinga", "createdAt": "2020-02-18T15:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcxMjI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzMzY5OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r380933698", "bodyText": "Updated: look up the class + setExceptionPending to throw UnsupportedOperationException.", "author": "babsingh", "createdAt": "2020-02-18T21:04:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcxMjI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcxMjMxNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r379712315", "bodyText": "See comment below - this should be removed or if it can't be, have a version tag added", "author": "DanHeidinga", "createdAt": "2020-02-15T02:46:58Z", "path": "runtime/oti/vmconstantpool.xml", "diffHunk": "@@ -110,6 +110,7 @@ SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-excepti\n \t<classref name=\"java/lang/invoke/MutableCallSite\" flags=\"opt_methodHandle\"/>\n \t<classref name=\"java/lang/invoke/MethodType\" flags=\"opt_methodHandle\"/>\n \t<classref name=\"java/lang/invoke/WrongMethodTypeException\" flags=\"opt_methodHandle\"/>\n+\t<classref name=\"java/lang/UnsupportedOperationException\" flags=\"opt_methodHandle\"/>", "originalCommit": "3a4672ab7f03d4440988c82758ada838292dfb64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDcyNjk3OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r380726979", "bodyText": "I have added a version tag for the above vmconstantpool entry:\n<classref name=\"java/lang/UnsupportedOperationException\" versions=\"14-\"/>", "author": "babsingh", "createdAt": "2020-02-18T15:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcxMjMxNQ=="}], "type": "inlineReview"}, {"oid": "35c892cf91ba20699ad0d4c17d55a67811857f49", "url": "https://github.com/eclipse-openj9/openj9/commit/35c892cf91ba20699ad0d4c17d55a67811857f49", "message": "Use OpenJDK ViewHandles in Java14+ to support JEP-370\n\nOpenJDK implementation of ByteArrayViewHandle and ByteBufferViewHandle\nis used to support JEP-370 in Java14+.\n\nOpenJ9 ViewHandles don't handle memory scopes properly. Example:\n\ntry (MemorySegment segment = MemorySegment.allocateNative(bytes)) {\n   ByteBuffer byteBuffer = segment.asByteBuffer();\n   MethodHandle handle = Derived from ByteBuffer & ByteBufferViewHandle;\n   handle.invoke();\n}\n\nInvoking handle.invoke() outside the memory scope should result in\nIllegalStateException, which is thrown from\njdk.internal.foreign.MemoryScope.\n\nWith OpenJ9 ViewHandles, the IllegalStateException is not thrown. The\naforementioned behavior is achieved by using OpenJDK ViewHandles.\n\nThe deficiency in OpenJ9 ViewHandles could not be identified.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-18T03:03:34Z", "type": "commit"}, {"oid": "acea87e0dc94dd5c37aabf6b979573de5b6d9537", "url": "https://github.com/eclipse-openj9/openj9/commit/acea87e0dc94dd5c37aabf6b979573de5b6d9537", "message": "Handle NULL VarHandle.handleTable entries in VarHandle.accessModeType\n\nIn OpenJ9, derived VarHandle classes define all AccessMode operations,\nand UnsupportedOperationException is thrown from the operation methods\nthat are not supported. All OpenJ9 VarHandle.handleTable entries are\nnon-null when supporting derived OpenJ9 VarHandle classes.\n\nIn OpenJDK, derived VarHandle classes do not define unsupported\nAccessMode operations. Thus, OpenJ9 VarHandle.handleTable entries are\nnull for unsupported AccessMode operations when supporting derived\nOpenJDK VarHandle classes.\n\nVarHandle.accessModeType relies upon VarHandle.handleTable to derive the\nAccessMode MethodType. When supporting derived OpenJDK VarHandle\nclasses, accessModeTypeUncached is used to retrieve the AccessMode\nMethodType in case VarHandle.handleTable entries are null.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-18T03:03:34Z", "type": "commit"}, {"oid": "a894bae9343cac6483ce71465abbfabdd7c8c071", "url": "https://github.com/eclipse-openj9/openj9/commit/a894bae9343cac6483ce71465abbfabdd7c8c071", "message": "Handle NULL VarHandle.handleTable entries in VarHandle.toMethodHandle\n\nOpenJ9 VarHandle.handleTable entries are null for unsupported AccessMode\noperations when supporting derived OpenJDK VarHandle classes.\n\nWhen supporting derived OpenJDK VarHandle classes,\naccessModeTypeUncached is used to retrieve the AccessMode MethodType in\ncase VarHandle.handleTable entries are null.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-18T03:03:34Z", "type": "forcePushed"}, {"oid": "1f80a9f22c1c11619e080a683720251f74e6d0ad", "url": "https://github.com/eclipse-openj9/openj9/commit/1f80a9f22c1c11619e080a683720251f74e6d0ad", "message": "Handle NULL VarHandle.handleTable entries in VarHandle.toMethodHandle\n\nOpenJ9 VarHandle.handleTable entries are null for unsupported AccessMode\noperations when supporting derived OpenJDK VarHandle classes.\n\nWhen supporting derived OpenJDK VarHandle classes,\naccessModeTypeUncached is used to retrieve the AccessMode MethodType in\ncase VarHandle.handleTable entries are null.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-18T20:59:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3OTAzOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r383979039", "bodyText": "The stack needs to be walkable at this point as looking up the class may cause a GC or another exception to occur.\nThis gives us two options, move the prepareForExceptionThrow call before looking up the exception class so we have a clean stack, or build a MT frame here.\nMy preference is to build the MT frame as it will be easier to debug & service as the VarHandle will still be on the stack and findable with DDR.", "author": "DanHeidinga", "createdAt": "2020-02-25T16:08:40Z", "path": "runtime/vm/MHInterpreter.cpp", "diffHunk": "@@ -555,6 +555,26 @@ VM_MHInterpreter::dispatchLoop(j9object_t methodHandle)\n \t\t\t/* Get MethodHandle for this operation from the VarHandle's handleTable */\n \t\t\tj9object_t handleTable = J9VMJAVALANGINVOKEVARHANDLE_HANDLETABLE(_currentThread, varHandle);\n \t\t\tj9object_t methodHandleFromTable = J9JAVAARRAYOFOBJECT_LOAD(_currentThread, handleTable, operation);\n+\n+\t\t\tif (NULL == methodHandleFromTable) {\n+\t\t\t\tconst char *exceptionClassName = \"java/lang/UnsupportedOperationException\";", "originalCommit": "1f80a9f22c1c11619e080a683720251f74e6d0ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk4MjcyNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r383982724", "bodyText": "Note, we won't tear down the frame as throwing the exception will handle it appropritately", "author": "DanHeidinga", "createdAt": "2020-02-25T16:14:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3OTAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NDI3Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r384094273", "bodyText": "Added buildMethodTypeFrame.", "author": "babsingh", "createdAt": "2020-02-25T20:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3OTAzOQ=="}], "type": "inlineReview"}, {"oid": "8b055bed7941f2870839df408a34068bd7685752", "url": "https://github.com/eclipse-openj9/openj9/commit/8b055bed7941f2870839df408a34068bd7685752", "message": "Handle NULL VarHandle.handleTable entries in VarHandle.toMethodHandle\n\nOpenJ9 VarHandle.handleTable entries are null for unsupported AccessMode\noperations when supporting derived OpenJDK VarHandle classes.\n\nWhen supporting derived OpenJDK VarHandle classes,\naccessModeTypeUncached is used to retrieve the AccessMode MethodType in\ncase VarHandle.handleTable entries are null.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-25T19:19:22Z", "type": "forcePushed"}, {"oid": "8caf911fe4154563ee39a61f42d357b43a547b7b", "url": "https://github.com/eclipse-openj9/openj9/commit/8caf911fe4154563ee39a61f42d357b43a547b7b", "message": "Support isAccessModeSupportedHelper method with VarForm constructor\n\nOpenJ9 ViewVarHandles have their own implementation for the\nisAccessModeSupported method. OpenJDK ViewVarHandles are used in OpenJ9\nJava 14+ which rely upon VarHandle.isAccessModeSupported instead of\ntheir own isAccessModeSupported implementation. \n\nVarHandle.isAccessModeSupported is updated to support OpenJDK\nVarHandles, which rely upon OpenJ9's VarHandle(VarForm varForm)\nconstructor.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-26T16:18:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYyMDAwMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r384620000", "bodyText": "@DanHeidinga New code to address the segfault seen in the four View-(BE|LE)-(On|Off)Heap_0 testcases. I couldn't build a method type frame since no method type is available. So, I ended up moving prepareForExceptionThrow before looking up the exception class.\nNew code is included in the following commit:\n\nHandle NULL VarHandle.handleTable entries in (Bytecode|MH)Interpreter", "author": "babsingh", "createdAt": "2020-02-26T16:43:11Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8269,6 +8269,29 @@ done:;\n \t\t\t/* Get MethodHandle for this operation from the VarHandles handleTable */\n \t\t\tj9object_t handleTable = J9VMJAVALANGINVOKEVARHANDLE_HANDLETABLE(_currentThread, varHandle);\n \t\t\tj9object_t methodHandle = J9JAVAARRAYOFOBJECT_LOAD(_currentThread, handleTable, operation);\n+\n+\t\t\tif (NULL == methodHandle) {\n+\t\t\t\tprepareForExceptionThrow(_currentThread);\n+\n+\t\t\t\tconst char *exceptionClassName = \"java/lang/UnsupportedOperationException\";\n+\t\t\t\tJ9Class *exceptionClass = internalFindClassUTF8(\n+\t\t\t\t\t\t_currentThread,\n+\t\t\t\t\t\t(U_8 *)exceptionClassName,\n+\t\t\t\t\t\tstrlen(exceptionClassName),\n+\t\t\t\t\t\t_currentThread->javaVM->systemClassLoader,\n+\t\t\t\t\t\tJ9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\n+\t\t\t\tj9object_t exception = _objectAllocate.inlineAllocateObject(_currentThread, exceptionClass);\n+\t\t\t\tif (NULL == exception) {\n+\t\t\t\t\trc = THROW_HEAP_OOM;\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\n+\t\t\t\tVM_VMHelpers::setExceptionPending(_currentThread, exception);\n+\t\t\t\trc = GOTO_THROW_CURRENT_EXCEPTION;\n+\t\t\t\tgoto done;\n+\t\t\t}", "originalCommit": "8caf911fe4154563ee39a61f42d357b43a547b7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1802734f729f8928588429aea01e55406b4584cd", "url": "https://github.com/eclipse-openj9/openj9/commit/1802734f729f8928588429aea01e55406b4584cd", "message": "Support isAccessModeSupportedHelper method with VarForm constructor\n\nOpenJ9 ViewVarHandles have their own implementation for the\nisAccessModeSupported method. OpenJDK ViewVarHandles are used in OpenJ9\nJava 14+ which rely upon VarHandle.isAccessModeSupported instead of\nhaving their own isAccessModeSupported implementation. \n\nVarHandle.isAccessModeSupported is updated to support OpenJDK\nVarHandles, which rely upon OpenJ9's VarHandle(VarForm varForm)\nconstructor.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-26T16:49:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0MTQ4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r384941483", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tif (NULL == methodHandle) {\n          \n          \n            \n            \t\t\tif (NULL == methodHandle) {\n          \n          \n            \n            \t\t\t\tupdateVMStruct(REGISTER_ARGS);", "author": "DanHeidinga", "createdAt": "2020-02-27T06:55:02Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8269,6 +8269,29 @@ done:;\n \t\t\t/* Get MethodHandle for this operation from the VarHandles handleTable */\n \t\t\tj9object_t handleTable = J9VMJAVALANGINVOKEVARHANDLE_HANDLETABLE(_currentThread, varHandle);\n \t\t\tj9object_t methodHandle = J9JAVAARRAYOFOBJECT_LOAD(_currentThread, handleTable, operation);\n+\n+\t\t\tif (NULL == methodHandle) {", "originalCommit": "1802734f729f8928588429aea01e55406b4584cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0MjU5Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r384942596", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\tJ9_FINDCLASS_FLAG_THROW_ON_FAIL);\n          \n          \n            \n            \t\t\t\t\t\tJ9_FINDCLASS_FLAG_THROW_ON_FAIL);\n          \n          \n            \n            \t\t\t\tVMStructHasBeenUpdated(REGISTER_ARGS);", "author": "DanHeidinga", "createdAt": "2020-02-27T06:58:26Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8269,6 +8269,29 @@ done:;\n \t\t\t/* Get MethodHandle for this operation from the VarHandles handleTable */\n \t\t\tj9object_t handleTable = J9VMJAVALANGINVOKEVARHANDLE_HANDLETABLE(_currentThread, varHandle);\n \t\t\tj9object_t methodHandle = J9JAVAARRAYOFOBJECT_LOAD(_currentThread, handleTable, operation);\n+\n+\t\t\tif (NULL == methodHandle) {\n+\t\t\t\tprepareForExceptionThrow(_currentThread);\n+\n+\t\t\t\tconst char *exceptionClassName = \"java/lang/UnsupportedOperationException\";\n+\t\t\t\tJ9Class *exceptionClass = internalFindClassUTF8(\n+\t\t\t\t\t\t_currentThread,\n+\t\t\t\t\t\t(U_8 *)exceptionClassName,\n+\t\t\t\t\t\tstrlen(exceptionClassName),\n+\t\t\t\t\t\t_currentThread->javaVM->systemClassLoader,\n+\t\t\t\t\t\tJ9_FINDCLASS_FLAG_THROW_ON_FAIL);", "originalCommit": "1802734f729f8928588429aea01e55406b4584cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0NTI0OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r384945248", "bodyText": "A null return here says that we can't allocate without doing a GC.  It's not going to have an exception pending.  Since we're on an error path, better to use the out of line allocate _vm->memoryManagerFunctions->J9AllocateObject(.\nThe prepareForExceptionThrow will have built a special frame for us already so we don't have to build another one here.\nWe will need to add a VMStructHasBeenUpdated(REGISTER_ARGS); after the J9AllocateObject call", "author": "DanHeidinga", "createdAt": "2020-02-27T07:07:52Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8269,6 +8269,29 @@ done:;\n \t\t\t/* Get MethodHandle for this operation from the VarHandles handleTable */\n \t\t\tj9object_t handleTable = J9VMJAVALANGINVOKEVARHANDLE_HANDLETABLE(_currentThread, varHandle);\n \t\t\tj9object_t methodHandle = J9JAVAARRAYOFOBJECT_LOAD(_currentThread, handleTable, operation);\n+\n+\t\t\tif (NULL == methodHandle) {\n+\t\t\t\tprepareForExceptionThrow(_currentThread);\n+\n+\t\t\t\tconst char *exceptionClassName = \"java/lang/UnsupportedOperationException\";\n+\t\t\t\tJ9Class *exceptionClass = internalFindClassUTF8(\n+\t\t\t\t\t\t_currentThread,\n+\t\t\t\t\t\t(U_8 *)exceptionClassName,\n+\t\t\t\t\t\tstrlen(exceptionClassName),\n+\t\t\t\t\t\t_currentThread->javaVM->systemClassLoader,\n+\t\t\t\t\t\tJ9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\n+\t\t\t\tj9object_t exception = _objectAllocate.inlineAllocateObject(_currentThread, exceptionClass);\n+\t\t\t\tif (NULL == exception) {", "originalCommit": "1802734f729f8928588429aea01e55406b4584cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0NTczMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r384945733", "bodyText": "Same issue here - the inlineAllocateObject only indicates if we can allocate without a GC or not.  When it returns null, we usually need to build a frame / make the stack walkable & then call the gc'ing version of the allocate helpers", "author": "DanHeidinga", "createdAt": "2020-02-27T07:09:11Z", "path": "runtime/vm/MHInterpreter.cpp", "diffHunk": "@@ -555,6 +555,33 @@ VM_MHInterpreter::dispatchLoop(j9object_t methodHandle)\n \t\t\t/* Get MethodHandle for this operation from the VarHandle's handleTable */\n \t\t\tj9object_t handleTable = J9VMJAVALANGINVOKEVARHANDLE_HANDLETABLE(_currentThread, varHandle);\n \t\t\tj9object_t methodHandleFromTable = J9JAVAARRAYOFOBJECT_LOAD(_currentThread, handleTable, operation);\n+\n+\t\t\tif (NULL == methodHandleFromTable) {\n+\t\t\t\t/* Building a method type (MT) frame makes the stack walkable since looking up the class below may\n+\t\t\t\t * cause a GC or another exception. Also, the MT frame will make it easier to debug and service the\n+\t\t\t\t * error as the VarHandle will be on the stack and findable with DDR. The MT frame does not need to\n+\t\t\t\t * be restored since throwing the exception will handle it appropriately.\n+\t\t\t\t */\n+\t\t\t\tbuildMethodTypeFrame(_currentThread, type);\n+\n+\t\t\t\tconst char *exceptionClassName = \"java/lang/UnsupportedOperationException\";\n+\t\t\t\tJ9Class *exceptionClass = internalFindClassUTF8(\n+\t\t\t\t\t\t_currentThread,\n+\t\t\t\t\t\t(U_8 *)exceptionClassName,\n+\t\t\t\t\t\tstrlen(exceptionClassName),\n+\t\t\t\t\t\t_currentThread->javaVM->systemClassLoader,\n+\t\t\t\t\t\tJ9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\n+\t\t\t\tj9object_t exception = _objectAllocate->inlineAllocateObject(_currentThread, exceptionClass);", "originalCommit": "1802734f729f8928588429aea01e55406b4584cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3NDQ4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r385274488", "bodyText": "Although the compiler will likely fold it, you can use the LITERAL_STRLEN macro instead of strlen here.", "author": "gacholio", "createdAt": "2020-02-27T17:55:41Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8269,6 +8269,29 @@ done:;\n \t\t\t/* Get MethodHandle for this operation from the VarHandles handleTable */\n \t\t\tj9object_t handleTable = J9VMJAVALANGINVOKEVARHANDLE_HANDLETABLE(_currentThread, varHandle);\n \t\t\tj9object_t methodHandle = J9JAVAARRAYOFOBJECT_LOAD(_currentThread, handleTable, operation);\n+\n+\t\t\tif (NULL == methodHandle) {\n+\t\t\t\tprepareForExceptionThrow(_currentThread);\n+\n+\t\t\t\tconst char *exceptionClassName = \"java/lang/UnsupportedOperationException\";\n+\t\t\t\tJ9Class *exceptionClass = internalFindClassUTF8(\n+\t\t\t\t\t\t_currentThread,\n+\t\t\t\t\t\t(U_8 *)exceptionClassName,\n+\t\t\t\t\t\tstrlen(exceptionClassName),", "originalCommit": "1802734f729f8928588429aea01e55406b4584cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyMDM0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r385420343", "bodyText": "LITERAL_STRLEN doesn't work with const char *. it only works if a string is passed directly or as a macro.", "author": "babsingh", "createdAt": "2020-02-27T23:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3NDQ4OA=="}], "type": "inlineReview"}, {"oid": "1b56e1aaa07c0ae7b4935b885ed2a035b24beb29", "url": "https://github.com/eclipse-openj9/openj9/commit/1b56e1aaa07c0ae7b4935b885ed2a035b24beb29", "message": "Support isAccessModeSupportedHelper method with VarForm constructor\n\nOpenJ9 ViewVarHandles have their own implementation for the\nisAccessModeSupported method. OpenJDK ViewVarHandles are used in OpenJ9\nJava 14+ which rely upon VarHandle.isAccessModeSupported instead of\nhaving their own isAccessModeSupported implementation. \n\nVarHandle.isAccessModeSupported is updated to support OpenJDK\nVarHandles, which rely upon OpenJ9's VarHandle(VarForm varForm)\nconstructor.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-27T22:36:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5OTM4OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r385899389", "bodyText": "This still needs a methodtype frame to be built as we don't know what MH operations have lead to this point.  The stack needs to be kept walkable here", "author": "DanHeidinga", "createdAt": "2020-02-28T20:08:26Z", "path": "runtime/vm/MHInterpreter.cpp", "diffHunk": "@@ -555,6 +555,12 @@ VM_MHInterpreter::dispatchLoop(j9object_t methodHandle)\n \t\t\t/* Get MethodHandle for this operation from the VarHandle's handleTable */\n \t\t\tj9object_t handleTable = J9VMJAVALANGINVOKEVARHANDLE_HANDLETABLE(_currentThread, varHandle);\n \t\t\tj9object_t methodHandleFromTable = J9JAVAARRAYOFOBJECT_LOAD(_currentThread, handleTable, operation);\n+\n+\t\t\tif (NULL == methodHandleFromTable) {", "originalCommit": "1b56e1aaa07c0ae7b4935b885ed2a035b24beb29", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxMDA1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r385910050", "bodyText": "Re-added buildMethodTypeFrame.", "author": "babsingh", "createdAt": "2020-02-28T20:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5OTM4OQ=="}], "type": "inlineReview"}, {"oid": "bfe3828eaeb91de9adecd1cefaf9e5b85c8fb56c", "url": "https://github.com/eclipse-openj9/openj9/commit/bfe3828eaeb91de9adecd1cefaf9e5b85c8fb56c", "message": "Handle NULL VarHandle.handleTable entries in (Bytecode|MH)Interpreter\n\nOpenJ9 VarHandle.handleTable entries are null for unsupported AccessMode\noperations when supporting derived OpenJDK VarHandle classes.\n\nVM_MHInterpreter::dispatchLoop and BytecodeInterpreter::invokevarhandle\nlook up entries in VarHandle.handleTable to invoke the operation method.\nA null handleTable entry reflects a unsupported AccessMode operation. In\nthis case, an UnsupportedOperationException should be thrown.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-28T20:32:20Z", "type": "commit"}, {"oid": "6f2e7c857929108754643da8b2ced19519594c4f", "url": "https://github.com/eclipse-openj9/openj9/commit/6f2e7c857929108754643da8b2ced19519594c4f", "message": "Handle NULL VarHandle.handleTable entries in VarHandle.toMethodHandle\n\nOpenJ9 VarHandle.handleTable entries are null for unsupported AccessMode\noperations when supporting derived OpenJDK VarHandle classes.\n\nWhen supporting derived OpenJDK VarHandle classes,\naccessModeTypeUncached is used to retrieve the AccessMode MethodType in\ncase VarHandle.handleTable entries are null.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-28T20:32:49Z", "type": "commit"}, {"oid": "0c32d79501136a9b352bcb353c9fbbc4e3a145c0", "url": "https://github.com/eclipse-openj9/openj9/commit/0c32d79501136a9b352bcb353c9fbbc4e3a145c0", "message": "Support isAccessModeSupportedHelper method with VarForm constructor\n\nOpenJ9 ViewVarHandles have their own implementation for the\nisAccessModeSupported method. OpenJDK ViewVarHandles are used in OpenJ9\nJava 14+ which rely upon VarHandle.isAccessModeSupported instead of\nhaving their own isAccessModeSupported implementation. \n\nVarHandle.isAccessModeSupported is updated to support OpenJDK\nVarHandles, which rely upon OpenJ9's VarHandle(VarForm varForm)\nconstructor.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-28T20:32:49Z", "type": "commit"}, {"oid": "0c32d79501136a9b352bcb353c9fbbc4e3a145c0", "url": "https://github.com/eclipse-openj9/openj9/commit/0c32d79501136a9b352bcb353c9fbbc4e3a145c0", "message": "Support isAccessModeSupportedHelper method with VarForm constructor\n\nOpenJ9 ViewVarHandles have their own implementation for the\nisAccessModeSupported method. OpenJDK ViewVarHandles are used in OpenJ9\nJava 14+ which rely upon VarHandle.isAccessModeSupported instead of\nhaving their own isAccessModeSupported implementation. \n\nVarHandle.isAccessModeSupported is updated to support OpenJDK\nVarHandles, which rely upon OpenJ9's VarHandle(VarForm varForm)\nconstructor.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-28T20:32:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ3NzczOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r386477738", "bodyText": "Other callers of internalFindClassUTF8 that use J9_FINDCLASS_FLAG_THROW_ON_FAIL anticipate a NULL return value; J9AllocateObject will crash if exceptionClass  is NULL.", "author": "keithc-ca", "createdAt": "2020-03-02T15:52:35Z", "path": "runtime/vm/exceptionsupport.c", "diffHunk": "@@ -82,6 +82,33 @@ setCurrentExceptionNLS(J9VMThread * vmThread, UDATA exceptionNumber, U_32 module\n \tsetCurrentExceptionUTF(vmThread, exceptionNumber, msg);\n }\n \n+void\n+prepareExceptionUsingClassName(J9VMThread *vmThread, const char *exceptionClassName)\n+{\n+\tJ9Class *exceptionClass = NULL;\n+\tj9object_t exception = NULL;\n+\n+\tprepareForExceptionThrow(vmThread);\n+\n+\texceptionClass = internalFindClassUTF8(\n+\t\t\tvmThread,\n+\t\t\t(U_8 *)exceptionClassName,\n+\t\t\tstrlen(exceptionClassName),\n+\t\t\tvmThread->javaVM->systemClassLoader,\n+\t\t\tJ9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\n+\texception = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(\n+\t\t\tvmThread,\n+\t\t\texceptionClass,\n+\t\t\tJ9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\n+\tif (J9_UNEXPECTED(NULL == exception)) {\n+\t\tsetHeapOutOfMemoryError(vmThread);\n+\t} else {\n+\t\tvmThread->currentException = exception;\n+\t\tvmThread->privateFlags |= J9_PRIVATE_FLAGS_REPORT_EXCEPTION_THROW;\n+\t}", "originalCommit": "0c32d79501136a9b352bcb353c9fbbc4e3a145c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4NzQ2MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r386487460", "bodyText": "Thanks for catching that @keithc-ca!  @babsingh can you put together a PR that adds the NULL check and port it to the 0.19 branch as well?", "author": "DanHeidinga", "createdAt": "2020-03-02T16:06:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ3NzczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUwNDgwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8501#discussion_r386504806", "bodyText": "yes.", "author": "babsingh", "createdAt": "2020-03-02T16:33:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ3NzczOA=="}], "type": "inlineReview"}]}