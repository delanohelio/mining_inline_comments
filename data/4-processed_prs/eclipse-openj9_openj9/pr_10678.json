{"pr_number": 10678, "pr_title": "Use a separate mutex for small freed block lists of persistent allocator", "pr_createdAt": "2020-09-23T16:52:49Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10678", "timeline": [{"oid": "2f2f4e67c6fba259d41686c6a52f9b4492205c27", "url": "https://github.com/eclipse-openj9/openj9/commit/2f2f4e67c6fba259d41686c6a52f9b4492205c27", "message": "Increase number of buckets for fixed size blocks from 12 to 16\n\nAllocations from fixed size block lists are very fast because\nwe only need to access the head of a linked list. Increasing\nthe number of such lists may speed up the persistent allocator\na little.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-09-23T00:35:37Z", "type": "commit"}, {"oid": "939f3f838a5e4960a63459e54a69b14241c0c498", "url": "https://github.com/eclipse-openj9/openj9/commit/939f3f838a5e4960a63459e54a69b14241c0c498", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only containes blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-09-23T16:54:35Z", "type": "forcePushed"}, {"oid": "9d44752c1c70789c2e430f34dd8fe411a925dbda", "url": "https://github.com/eclipse-openj9/openj9/commit/9d44752c1c70789c2e430f34dd8fe411a925dbda", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only containes blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-09-23T17:41:42Z", "type": "forcePushed"}, {"oid": "c7253e3a972daecedeb280787f8d1b8687e72937", "url": "https://github.com/eclipse-openj9/openj9/commit/c7253e3a972daecedeb280787f8d1b8687e72937", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only containes blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-09-23T19:00:31Z", "type": "forcePushed"}, {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649", "url": "https://github.com/eclipse-openj9/openj9/commit/76e2109024567dcc6d7757bcc604ab0dc73d9649", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only contains blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-09-23T19:03:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0ODQyMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493848420", "bodyText": "Is the 0th index special? If so then maybe it's worth having an enum or maybe a static const size_t rather than using the literal 0.", "author": "dsouzai", "createdAt": "2020-09-23T19:38:27Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();", "originalCommit": "76e2109024567dcc6d7757bcc604ab0dc73d9649", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3MDI0OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493870248", "bodyText": "Yes, the first list is the variable-size one used for larger blocks. I'll use a static const size_t", "author": "mpirvu", "createdAt": "2020-09-23T20:19:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0ODQyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0ODU5Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493848597", "bodyText": "Better to use OMR::Critical Section(_smallBlockListsMonitor);", "author": "dsouzai", "createdAt": "2020-09-23T19:38:47Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();\n+\n+      block->_next = NULL;\n+      }\n+   return block;\n+   }\n+\n void *\n-PersistentAllocator::allocateLocked(size_t requestedSize)\n+PersistentAllocator::allocateInternal(size_t requestedSize)\n    {\n    TR_ASSERT( sizeof(Block) == mem_round( sizeof(Block) ),\"Persistent block size will prevent us from properly aligning allocations.\");\n    size_t const dataSize = mem_round(requestedSize);\n    size_t const allocSize = sizeof(Block) + dataSize;\n \n-   TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      // Use _smallBlockListsMonitor to protect TR::AllocatedMemoryMeter::update_allocated\n+      // because accessing the variable-size-block list protected by ::memoryAllocMonitor\n+      // takes longer and we may be penalizing access to fixed size block which should be very fast\n+      j9thread_monitor_enter(_smallBlockListsMonitor);", "originalCommit": "76e2109024567dcc6d7757bcc604ab0dc73d9649", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3MzQ2Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493873463", "bodyText": "Persistent memory is created very early when TR monitors don't even exist. This is why that ugliness\n      if (::memoryAllocMonitor)\n         ::memoryAllocMonitor->enter();\n\nexists. In here I decided to use VM constructs for the mutexes, rather than repeating the pattern above.\nDue to these complications OMR::Critical Section(_smallBlockListsMonitor); will not work.", "author": "mpirvu", "createdAt": "2020-09-23T20:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0ODU5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM4NDk2MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r494384961", "bodyText": "Ah....that's unfortunate :/", "author": "dsouzai", "createdAt": "2020-09-24T14:53:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0ODU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0OTE2MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493849161", "bodyText": "Same comment as above regarding the literal 0.", "author": "dsouzai", "createdAt": "2020-09-23T19:39:53Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();\n+\n+      block->_next = NULL;\n+      }\n+   return block;\n+   }\n+\n void *\n-PersistentAllocator::allocateLocked(size_t requestedSize)\n+PersistentAllocator::allocateInternal(size_t requestedSize)\n    {\n    TR_ASSERT( sizeof(Block) == mem_round( sizeof(Block) ),\"Persistent block size will prevent us from properly aligning allocations.\");\n    size_t const dataSize = mem_round(requestedSize);\n    size_t const allocSize = sizeof(Block) + dataSize;\n \n-   TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      // Use _smallBlockListsMonitor to protect TR::AllocatedMemoryMeter::update_allocated\n+      // because accessing the variable-size-block list protected by ::memoryAllocMonitor\n+      // takes longer and we may be penalizing access to fixed size block which should be very fast\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n \n    // If this is a small block try to allocate it from the appropriate\n    // fixed-size-block chain.\n    //\n    size_t const index = freeBlocksIndex(allocSize);\n-   Block * block = 0;\n-   Block * prev = 0;\n-   for (\n-      block = _freeBlocks[index];\n-      block && block->_size < allocSize;\n-      prev = block, block = prev->next()\n-      )\n-      { TR_ASSERT(index == 0, \"Iterating through a fixed-size block bin.\"); }\n-\n-   if (block)\n+   if (index != 0) // fixed-size-block chain", "originalCommit": "76e2109024567dcc6d7757bcc604ab0dc73d9649", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0OTQwNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493849405", "bodyText": "Same comment as above regarding OMR::CriticalSection.", "author": "dsouzai", "createdAt": "2020-09-23T19:40:17Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();\n+\n+      block->_next = NULL;\n+      }\n+   return block;\n+   }\n+\n void *\n-PersistentAllocator::allocateLocked(size_t requestedSize)\n+PersistentAllocator::allocateInternal(size_t requestedSize)\n    {\n    TR_ASSERT( sizeof(Block) == mem_round( sizeof(Block) ),\"Persistent block size will prevent us from properly aligning allocations.\");\n    size_t const dataSize = mem_round(requestedSize);\n    size_t const allocSize = sizeof(Block) + dataSize;\n \n-   TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      // Use _smallBlockListsMonitor to protect TR::AllocatedMemoryMeter::update_allocated\n+      // because accessing the variable-size-block list protected by ::memoryAllocMonitor\n+      // takes longer and we may be penalizing access to fixed size block which should be very fast\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n \n    // If this is a small block try to allocate it from the appropriate\n    // fixed-size-block chain.\n    //\n    size_t const index = freeBlocksIndex(allocSize);\n-   Block * block = 0;\n-   Block * prev = 0;\n-   for (\n-      block = _freeBlocks[index];\n-      block && block->_size < allocSize;\n-      prev = block, block = prev->next()\n-      )\n-      { TR_ASSERT(index == 0, \"Iterating through a fixed-size block bin.\"); }\n-\n-   if (block)\n+   if (index != 0) // fixed-size-block chain\n       {\n-\n-      TR_ASSERT(\n-         ( index == 0 ) || ( block->_size == allocSize ),\n-         \"block %p in chain for index %d has size %d (not %d)\\n\",\n-         block,\n-         index,\n-         block->_size,\n-         (index * sizeof(void *)) + sizeof(Block)\n-         );\n-\n-      if (prev)\n-         prev->_next = block->next();\n-      else\n+      j9thread_monitor_enter(_smallBlockListsMonitor);", "originalCommit": "76e2109024567dcc6d7757bcc604ab0dc73d9649", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MTcyNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493851727", "bodyText": "I don't think this is a good idea; it's better to just wrap the call to allocateFromSegmentLocked in a scope and use OMR::CriticalSection(::memoryAllocMonitor)", "author": "dsouzai", "createdAt": "2020-09-23T19:44:29Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();\n+\n+      block->_next = NULL;\n+      }\n+   return block;\n+   }\n+\n void *\n-PersistentAllocator::allocateLocked(size_t requestedSize)\n+PersistentAllocator::allocateInternal(size_t requestedSize)\n    {\n    TR_ASSERT( sizeof(Block) == mem_round( sizeof(Block) ),\"Persistent block size will prevent us from properly aligning allocations.\");\n    size_t const dataSize = mem_round(requestedSize);\n    size_t const allocSize = sizeof(Block) + dataSize;\n \n-   TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      // Use _smallBlockListsMonitor to protect TR::AllocatedMemoryMeter::update_allocated\n+      // because accessing the variable-size-block list protected by ::memoryAllocMonitor\n+      // takes longer and we may be penalizing access to fixed size block which should be very fast\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n \n    // If this is a small block try to allocate it from the appropriate\n    // fixed-size-block chain.\n    //\n    size_t const index = freeBlocksIndex(allocSize);\n-   Block * block = 0;\n-   Block * prev = 0;\n-   for (\n-      block = _freeBlocks[index];\n-      block && block->_size < allocSize;\n-      prev = block, block = prev->next()\n-      )\n-      { TR_ASSERT(index == 0, \"Iterating through a fixed-size block bin.\"); }\n-\n-   if (block)\n+   if (index != 0) // fixed-size-block chain\n       {\n-\n-      TR_ASSERT(\n-         ( index == 0 ) || ( block->_size == allocSize ),\n-         \"block %p in chain for index %d has size %d (not %d)\\n\",\n-         block,\n-         index,\n-         block->_size,\n-         (index * sizeof(void *)) + sizeof(Block)\n-         );\n-\n-      if (prev)\n-         prev->_next = block->next();\n-      else\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      Block * block = _freeBlocks[index];\n+      if (block)\n+         {\n          _freeBlocks[index] = block->next();\n-\n-      block->_next = NULL;\n-\n-      size_t const excess = block->_size - allocSize;\n-\n-      if (excess > sizeof(Block))\n+         block->_next = NULL;\n+         j9thread_monitor_exit(_smallBlockListsMonitor);\n+         return block + 1; // Return pointer after the header\n+         }\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      // Need to allocate from segment\n+      // Preemtively acquire the mutex that protects the segment allocation\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();", "originalCommit": "76e2109024567dcc6d7757bcc604ab0dc73d9649", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NDk5Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493874996", "bodyText": "As explained above ::CriticalSection(::memoryAllocMonitor) will not work because ::memoryAllocMonitor can be NULL.\nAnother goal of this implementation was to reduce the number of monitor->enter()/monitor->exit() as much as possible. Otherwise I wouldn't rush into acquiring the monitor at this point", "author": "mpirvu", "createdAt": "2020-09-23T20:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM5MzQ1OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r494393459", "bodyText": "Given that this is at the end of the if block, why does the monitor need to be acquired here? Wouldn't it be better to just move it right before the call to allocateFromSegmentLocked below? The else block looks self contained, so the only way to end up in the call to allocateFromSegmentLocked is if the code enter the if block here.", "author": "dsouzai", "createdAt": "2020-09-24T15:04:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ3MzM3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r494473377", "bodyText": "When we try to allocate from the variable-size-block list and fail we have the corresponding lock in hand. The next action is to allocate from segments, operation which is protected by the same lock. Instead of releasing the lock just to acquire it immediately when segment allocation needs to happen, I decided to keep it on.  So we enter the section of code that allocates from segments with the monitor already held. This means that if we fail to allocate from the small-block list (the code above) we also need to lock the variable-size-block mutex in preparation of allocating from a segment.\nThe pseudo code looks like this:\nIf (need to allocate a small block)\n   {\n    try to allocate small block\n    if (success) return\n    else acquire LargeBlockMutex in preparation for segment allocation\n    }\nelse // Large block allocation\n   {\n    acquire LargeBlockMutex\n    try to allocate large block\n    if (success)   release mutex and return\n     else\n         {\n        // LargeBlockMutex is still held\n        // Do not release it just to acquire it again immediately\n         }\n     }\n  AllocateFromSegment()\n  release LargeBlockMutex", "author": "mpirvu", "createdAt": "2020-09-24T17:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ3NTY2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r494475668", "bodyText": "If it feels cleaner I could repeat the code that does AllocateFromSegment into the two cases above (one for small blocks and one for large block)", "author": "mpirvu", "createdAt": "2020-09-24T17:04:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ4MDc3OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r494480779", "bodyText": "Ah I see your point. Yeah I think this is one of those few places where code duplication is a good idea. It would only be a duplication of\n   allocation = allocateFromSegmentLocked(allocSize);\n   if (::memoryAllocMonitor)\n      ::memoryAllocMonitor->exit();\n\nin both the if and else blocks, so I think the duplication is well worth the increased clarity it would provide.", "author": "dsouzai", "createdAt": "2020-09-24T17:13:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MTcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MjQwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493852406", "bodyText": "Better to use OMR::CriticalSection. Is it ever possible that ::memoryAllocMonitor is NULL? Wouldn't that cause all sorts of issues?", "author": "dsouzai", "createdAt": "2020-09-23T19:45:51Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();\n+\n+      block->_next = NULL;\n+      }\n+   return block;\n+   }\n+\n void *\n-PersistentAllocator::allocateLocked(size_t requestedSize)\n+PersistentAllocator::allocateInternal(size_t requestedSize)\n    {\n    TR_ASSERT( sizeof(Block) == mem_round( sizeof(Block) ),\"Persistent block size will prevent us from properly aligning allocations.\");\n    size_t const dataSize = mem_round(requestedSize);\n    size_t const allocSize = sizeof(Block) + dataSize;\n \n-   TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      // Use _smallBlockListsMonitor to protect TR::AllocatedMemoryMeter::update_allocated\n+      // because accessing the variable-size-block list protected by ::memoryAllocMonitor\n+      // takes longer and we may be penalizing access to fixed size block which should be very fast\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n \n    // If this is a small block try to allocate it from the appropriate\n    // fixed-size-block chain.\n    //\n    size_t const index = freeBlocksIndex(allocSize);\n-   Block * block = 0;\n-   Block * prev = 0;\n-   for (\n-      block = _freeBlocks[index];\n-      block && block->_size < allocSize;\n-      prev = block, block = prev->next()\n-      )\n-      { TR_ASSERT(index == 0, \"Iterating through a fixed-size block bin.\"); }\n-\n-   if (block)\n+   if (index != 0) // fixed-size-block chain\n       {\n-\n-      TR_ASSERT(\n-         ( index == 0 ) || ( block->_size == allocSize ),\n-         \"block %p in chain for index %d has size %d (not %d)\\n\",\n-         block,\n-         index,\n-         block->_size,\n-         (index * sizeof(void *)) + sizeof(Block)\n-         );\n-\n-      if (prev)\n-         prev->_next = block->next();\n-      else\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      Block * block = _freeBlocks[index];\n+      if (block)\n+         {\n          _freeBlocks[index] = block->next();\n-\n-      block->_next = NULL;\n-\n-      size_t const excess = block->_size - allocSize;\n-\n-      if (excess > sizeof(Block))\n+         block->_next = NULL;\n+         j9thread_monitor_exit(_smallBlockListsMonitor);\n+         return block + 1; // Return pointer after the header\n+         }\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      // Need to allocate from segment\n+      // Preemtively acquire the mutex that protects the segment allocation\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      }\n+   else // Variable size block allocation\n+      {\n+      if (::memoryAllocMonitor)", "originalCommit": "76e2109024567dcc6d7757bcc604ab0dc73d9649", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NTU0NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493875545", "bodyText": "Yes ::memoryAllocMonitor can be NULL very early on, during JIT initialization. Because there is only one thread there are no race conditions", "author": "mpirvu", "createdAt": "2020-09-23T20:29:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MjQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NjI1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493856250", "bodyText": "Might be worth just 1. using OMR::CriticalSection, and 2. moving the critical section to inside freeFixedSizeBlock.\nAn unfortunate side effect of using a critical section for ::memoryAllocMonitor though is that we'll end up acquiring both monitors here. Maybe this is an infrequent enough scenario that it shouldn't be a problem?", "author": "dsouzai", "createdAt": "2020-09-23T19:52:52Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();\n+\n+      block->_next = NULL;\n+      }\n+   return block;\n+   }\n+\n void *\n-PersistentAllocator::allocateLocked(size_t requestedSize)\n+PersistentAllocator::allocateInternal(size_t requestedSize)\n    {\n    TR_ASSERT( sizeof(Block) == mem_round( sizeof(Block) ),\"Persistent block size will prevent us from properly aligning allocations.\");\n    size_t const dataSize = mem_round(requestedSize);\n    size_t const allocSize = sizeof(Block) + dataSize;\n \n-   TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      // Use _smallBlockListsMonitor to protect TR::AllocatedMemoryMeter::update_allocated\n+      // because accessing the variable-size-block list protected by ::memoryAllocMonitor\n+      // takes longer and we may be penalizing access to fixed size block which should be very fast\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n \n    // If this is a small block try to allocate it from the appropriate\n    // fixed-size-block chain.\n    //\n    size_t const index = freeBlocksIndex(allocSize);\n-   Block * block = 0;\n-   Block * prev = 0;\n-   for (\n-      block = _freeBlocks[index];\n-      block && block->_size < allocSize;\n-      prev = block, block = prev->next()\n-      )\n-      { TR_ASSERT(index == 0, \"Iterating through a fixed-size block bin.\"); }\n-\n-   if (block)\n+   if (index != 0) // fixed-size-block chain\n       {\n-\n-      TR_ASSERT(\n-         ( index == 0 ) || ( block->_size == allocSize ),\n-         \"block %p in chain for index %d has size %d (not %d)\\n\",\n-         block,\n-         index,\n-         block->_size,\n-         (index * sizeof(void *)) + sizeof(Block)\n-         );\n-\n-      if (prev)\n-         prev->_next = block->next();\n-      else\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      Block * block = _freeBlocks[index];\n+      if (block)\n+         {\n          _freeBlocks[index] = block->next();\n-\n-      block->_next = NULL;\n-\n-      size_t const excess = block->_size - allocSize;\n-\n-      if (excess > sizeof(Block))\n+         block->_next = NULL;\n+         j9thread_monitor_exit(_smallBlockListsMonitor);\n+         return block + 1; // Return pointer after the header\n+         }\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      // Need to allocate from segment\n+      // Preemtively acquire the mutex that protects the segment allocation\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      }\n+   else // Variable size block allocation\n+      {\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      Block * block = allocateFromVariableSizeListLocked(allocSize);\n+      if (block)\n          {\n-         block->_size = allocSize;\n-         freeBlock( new (pointer_cast<uint8_t *>(block) + allocSize) Block(excess) );\n+         // If the block I found is bigger than what I need,\n+         // split it and put the remaining block back onto the free list\n+         size_t const excess = block->_size - allocSize;\n+         if (excess > sizeof(Block))\n+            {\n+            block->_size = allocSize;\n+            const size_t excessIndex = freeBlocksIndex(excess);\n+            if (excessIndex > 0)\n+               {\n+               // Exit the variable size list monitor and grab a fixed size list monitor\n+               if (::memoryAllocMonitor)\n+                  ::memoryAllocMonitor->exit();\n+\n+               j9thread_monitor_enter(_smallBlockListsMonitor);\n+               freeFixedSizeBlock( new (pointer_cast<uint8_t *>(block) + allocSize) Block(excess) );\n+               j9thread_monitor_exit(_smallBlockListsMonitor);", "originalCommit": "76e2109024567dcc6d7757bcc604ab0dc73d9649", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NjA0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493876049", "bodyText": "As stated above a goal of this implementation was to reduce the number of monitor->enter()/monitor->exit() as much as possible.", "author": "mpirvu", "createdAt": "2020-09-23T20:30:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NjI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NzQxOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493857419", "bodyText": "Same comment as above regarding literal 0.", "author": "dsouzai", "createdAt": "2020-09-23T19:55:02Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();\n+\n+      block->_next = NULL;\n+      }\n+   return block;\n+   }\n+\n void *\n-PersistentAllocator::allocateLocked(size_t requestedSize)\n+PersistentAllocator::allocateInternal(size_t requestedSize)\n    {\n    TR_ASSERT( sizeof(Block) == mem_round( sizeof(Block) ),\"Persistent block size will prevent us from properly aligning allocations.\");\n    size_t const dataSize = mem_round(requestedSize);\n    size_t const allocSize = sizeof(Block) + dataSize;\n \n-   TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      // Use _smallBlockListsMonitor to protect TR::AllocatedMemoryMeter::update_allocated\n+      // because accessing the variable-size-block list protected by ::memoryAllocMonitor\n+      // takes longer and we may be penalizing access to fixed size block which should be very fast\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n \n    // If this is a small block try to allocate it from the appropriate\n    // fixed-size-block chain.\n    //\n    size_t const index = freeBlocksIndex(allocSize);\n-   Block * block = 0;\n-   Block * prev = 0;\n-   for (\n-      block = _freeBlocks[index];\n-      block && block->_size < allocSize;\n-      prev = block, block = prev->next()\n-      )\n-      { TR_ASSERT(index == 0, \"Iterating through a fixed-size block bin.\"); }\n-\n-   if (block)\n+   if (index != 0) // fixed-size-block chain\n       {\n-\n-      TR_ASSERT(\n-         ( index == 0 ) || ( block->_size == allocSize ),\n-         \"block %p in chain for index %d has size %d (not %d)\\n\",\n-         block,\n-         index,\n-         block->_size,\n-         (index * sizeof(void *)) + sizeof(Block)\n-         );\n-\n-      if (prev)\n-         prev->_next = block->next();\n-      else\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      Block * block = _freeBlocks[index];\n+      if (block)\n+         {\n          _freeBlocks[index] = block->next();\n-\n-      block->_next = NULL;\n-\n-      size_t const excess = block->_size - allocSize;\n-\n-      if (excess > sizeof(Block))\n+         block->_next = NULL;\n+         j9thread_monitor_exit(_smallBlockListsMonitor);\n+         return block + 1; // Return pointer after the header\n+         }\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      // Need to allocate from segment\n+      // Preemtively acquire the mutex that protects the segment allocation\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      }\n+   else // Variable size block allocation\n+      {\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      Block * block = allocateFromVariableSizeListLocked(allocSize);\n+      if (block)\n          {\n-         block->_size = allocSize;\n-         freeBlock( new (pointer_cast<uint8_t *>(block) + allocSize) Block(excess) );\n+         // If the block I found is bigger than what I need,\n+         // split it and put the remaining block back onto the free list\n+         size_t const excess = block->_size - allocSize;\n+         if (excess > sizeof(Block))\n+            {\n+            block->_size = allocSize;\n+            const size_t excessIndex = freeBlocksIndex(excess);\n+            if (excessIndex > 0)", "originalCommit": "76e2109024567dcc6d7757bcc604ab0dc73d9649", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NjEyMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493876123", "bodyText": "ok", "author": "mpirvu", "createdAt": "2020-09-23T20:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NzQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1Nzc0NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493857744", "bodyText": "As stated above, better to use a critical section here in a nested scope.", "author": "dsouzai", "createdAt": "2020-09-23T19:55:38Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();\n+\n+      block->_next = NULL;\n+      }\n+   return block;\n+   }\n+\n void *\n-PersistentAllocator::allocateLocked(size_t requestedSize)\n+PersistentAllocator::allocateInternal(size_t requestedSize)\n    {\n    TR_ASSERT( sizeof(Block) == mem_round( sizeof(Block) ),\"Persistent block size will prevent us from properly aligning allocations.\");\n    size_t const dataSize = mem_round(requestedSize);\n    size_t const allocSize = sizeof(Block) + dataSize;\n \n-   TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      // Use _smallBlockListsMonitor to protect TR::AllocatedMemoryMeter::update_allocated\n+      // because accessing the variable-size-block list protected by ::memoryAllocMonitor\n+      // takes longer and we may be penalizing access to fixed size block which should be very fast\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n \n    // If this is a small block try to allocate it from the appropriate\n    // fixed-size-block chain.\n    //\n    size_t const index = freeBlocksIndex(allocSize);\n-   Block * block = 0;\n-   Block * prev = 0;\n-   for (\n-      block = _freeBlocks[index];\n-      block && block->_size < allocSize;\n-      prev = block, block = prev->next()\n-      )\n-      { TR_ASSERT(index == 0, \"Iterating through a fixed-size block bin.\"); }\n-\n-   if (block)\n+   if (index != 0) // fixed-size-block chain\n       {\n-\n-      TR_ASSERT(\n-         ( index == 0 ) || ( block->_size == allocSize ),\n-         \"block %p in chain for index %d has size %d (not %d)\\n\",\n-         block,\n-         index,\n-         block->_size,\n-         (index * sizeof(void *)) + sizeof(Block)\n-         );\n-\n-      if (prev)\n-         prev->_next = block->next();\n-      else\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      Block * block = _freeBlocks[index];\n+      if (block)\n+         {\n          _freeBlocks[index] = block->next();\n-\n-      block->_next = NULL;\n-\n-      size_t const excess = block->_size - allocSize;\n-\n-      if (excess > sizeof(Block))\n+         block->_next = NULL;\n+         j9thread_monitor_exit(_smallBlockListsMonitor);\n+         return block + 1; // Return pointer after the header\n+         }\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      // Need to allocate from segment\n+      // Preemtively acquire the mutex that protects the segment allocation\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      }\n+   else // Variable size block allocation\n+      {\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      Block * block = allocateFromVariableSizeListLocked(allocSize);\n+      if (block)\n          {\n-         block->_size = allocSize;\n-         freeBlock( new (pointer_cast<uint8_t *>(block) + allocSize) Block(excess) );\n+         // If the block I found is bigger than what I need,\n+         // split it and put the remaining block back onto the free list\n+         size_t const excess = block->_size - allocSize;\n+         if (excess > sizeof(Block))\n+            {\n+            block->_size = allocSize;\n+            const size_t excessIndex = freeBlocksIndex(excess);\n+            if (excessIndex > 0)\n+               {\n+               // Exit the variable size list monitor and grab a fixed size list monitor\n+               if (::memoryAllocMonitor)\n+                  ::memoryAllocMonitor->exit();\n+\n+               j9thread_monitor_enter(_smallBlockListsMonitor);\n+               freeFixedSizeBlock( new (pointer_cast<uint8_t *>(block) + allocSize) Block(excess) );\n+               j9thread_monitor_exit(_smallBlockListsMonitor);\n+               // No monitor held at this point, so we can return\n+               return block + 1;\n+               }\n+            else\n+               {\n+               freeVariableSizeBlock( new (pointer_cast<uint8_t *>(block) + allocSize) Block(excess) );\n+               }\n+            }\n+         if (::memoryAllocMonitor)\n+            ::memoryAllocMonitor->exit();\n+         return block + 1;\n          }\n-\n-      return block + 1;\n       }\n-\n+   // At this point I have to allocate memory from a segment\n    // Find the first persistent segment with enough free space\n+   // Required mutex has already been obtained\n    //\n+   void *allocation = allocateFromSegmentLocked(allocSize);", "originalCommit": "76e2109024567dcc6d7757bcc604ab0dc73d9649", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1ODExMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493858111", "bodyText": "Might even be worth considering creating the critical section inside allocateFromSegmentLocked now that I think of it.", "author": "dsouzai", "createdAt": "2020-09-23T19:56:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1Nzc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1OTY2MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493859661", "bodyText": "Same comment as above regarding literal 0", "author": "dsouzai", "createdAt": "2020-09-23T19:59:12Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -164,26 +216,34 @@ PersistentAllocator::remainingSpace(J9MemorySegment &segment) throw()\n    }\n \n void\n-PersistentAllocator::freeBlock(Block * block)\n+PersistentAllocator::freeFixedSizeBlock(Block * block)\n+   {\n+   // Appropriate lock should have been obtained\n+   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n+   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(index, \"freeFixedSizeBlock should be used for small blocks, so index cannot be 0\");", "originalCommit": "76e2109024567dcc6d7757bcc604ab0dc73d9649", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg2MDI0MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493860240", "bodyText": "same comment as above regarding literal 0.", "author": "dsouzai", "createdAt": "2020-09-23T20:00:12Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -164,26 +216,34 @@ PersistentAllocator::remainingSpace(J9MemorySegment &segment) throw()\n    }\n \n void\n-PersistentAllocator::freeBlock(Block * block)\n+PersistentAllocator::freeFixedSizeBlock(Block * block)\n+   {\n+   // Appropriate lock should have been obtained\n+   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n+   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(index, \"freeFixedSizeBlock should be used for small blocks, so index cannot be 0\");\n+   block->_next = _freeBlocks[index];\n+   _freeBlocks[index] = block;\n+   }\n+\n+void\n+PersistentAllocator::freeVariableSizeBlock(Block * block)\n    {\n+   // Appropriate lock should have been obtained\n    TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   TR_ASSERT(block->_next == NULL, \"In-use persistent memory block @ belongs to a free block chain.\", block);\n    block->_next = NULL;\n \n-   // If this is a small block, add it to the appropriate fixed-size-block\n-   // chain. Otherwise add it to the variable-size-block chain which is in\n-   // ascending size order.\n+   // Add block to the variable-size-block chain which is in ascending size order.\n    //\n-   size_t const index = freeBlocksIndex(block->_size);\n-   Block * blockIterator = _freeBlocks[index];\n+   TR_ASSERT(freeBlocksIndex(block->_size) == 0, \"freeVariableSizeBlock should be used for large blocks, so index should be 0\");\n+   Block * blockIterator = _freeBlocks[0];\n    if (!blockIterator || !(blockIterator->_size < block->_size) )\n       {\n-      block->_next = _freeBlocks[index];\n-      _freeBlocks[index] = block;\n+      block->_next = _freeBlocks[0];\n+      _freeBlocks[0] = block;", "originalCommit": "76e2109024567dcc6d7757bcc604ab0dc73d9649", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg2MjUxMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493862513", "bodyText": "Shouldn't the message say something like \"Freeing a block that is in the free list\"?", "author": "dsouzai", "createdAt": "2020-09-23T20:04:29Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -194,25 +254,49 @@ PersistentAllocator::freeBlock(Block * block)\n    }\n \n void\n-PersistentAllocator::deallocate(void * mem, size_t) throw()\n+PersistentAllocator::freeBlock(Block * block)\n    {\n-   if (::memoryAllocMonitor)\n-      ::memoryAllocMonitor->enter();\n-\n-\n-   Block * block = static_cast<Block *>(mem) - 1;\n+   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n \n-   // adjust the used persistent memory here and not in freePersistentmemory(block, size)\n+   // Adjust the used persistent memory here and not in freePersistentmemory(block, size)\n    // because that call is also used to free memory that wasn't actually committed\n-   TR::AllocatedMemoryMeter::update_freed(block->_size, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_freed(block->_size, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n+  \n+   // If this is a small block, add it to the appropriate fixed-size-block\n+   // chain. Otherwise add it to the variable-size-block chain which is in\n+   // ascending size order.\n+   //\n+   size_t const index = freeBlocksIndex(block->_size);\n+   if (index > 0)\n+      {\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      freeFixedSizeBlock(block);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n+   else\n+      {\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      freeVariableSizeBlock(block);\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->exit();\n+      }\n+   }\n \n+void\n+PersistentAllocator::deallocate(void * mem, size_t) throw()\n+   {\n+   Block * block = static_cast<Block *>(mem) - 1;\n+   TR_ASSERT_FATAL(block->_next == NULL, \"Freeing a block that is in use. block=%p next=%p\", block, block->_next);", "originalCommit": "76e2109024567dcc6d7757bcc604ab0dc73d9649", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3Njc2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493876764", "bodyText": "Right. The message was meant to alert for double free which we see from time to time", "author": "mpirvu", "createdAt": "2020-09-23T20:31:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg2MjUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg2NDI3OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493864279", "bodyText": "Same comments as above regarding critical section and the literal 0.", "author": "dsouzai", "createdAt": "2020-09-23T20:07:44Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -194,25 +254,49 @@ PersistentAllocator::freeBlock(Block * block)\n    }\n \n void\n-PersistentAllocator::deallocate(void * mem, size_t) throw()\n+PersistentAllocator::freeBlock(Block * block)\n    {\n-   if (::memoryAllocMonitor)\n-      ::memoryAllocMonitor->enter();\n-\n-\n-   Block * block = static_cast<Block *>(mem) - 1;\n+   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n \n-   // adjust the used persistent memory here and not in freePersistentmemory(block, size)\n+   // Adjust the used persistent memory here and not in freePersistentmemory(block, size)\n    // because that call is also used to free memory that wasn't actually committed\n-   TR::AllocatedMemoryMeter::update_freed(block->_size, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_freed(block->_size, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n+  \n+   // If this is a small block, add it to the appropriate fixed-size-block\n+   // chain. Otherwise add it to the variable-size-block chain which is in\n+   // ascending size order.\n+   //\n+   size_t const index = freeBlocksIndex(block->_size);\n+   if (index > 0)\n+      {\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      freeFixedSizeBlock(block);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n+   else\n+      {\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      freeVariableSizeBlock(block);\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->exit();\n+      }", "originalCommit": "76e2109024567dcc6d7757bcc604ab0dc73d9649", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9fe189119d74d146713adff18fb774ec4da5a2e4", "url": "https://github.com/eclipse-openj9/openj9/commit/9fe189119d74d146713adff18fb774ec4da5a2e4", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only contains blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-09-23T20:44:33Z", "type": "forcePushed"}, {"oid": "fc67d852c87273d0cc9b26c6745dc86e0f7b5596", "url": "https://github.com/eclipse-openj9/openj9/commit/fc67d852c87273d0cc9b26c6745dc86e0f7b5596", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only contains blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-09-24T17:57:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUxMzA4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r494513083", "bodyText": "This line was added as part of your last update; doesn't seem to be used.", "author": "dsouzai", "createdAt": "2020-09-24T18:08:41Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -164,26 +225,34 @@ PersistentAllocator::remainingSpace(J9MemorySegment &segment) throw()\n    }\n \n void\n-PersistentAllocator::freeBlock(Block * block)\n+PersistentAllocator::freeFixedSizeBlock(Block * block)\n    {\n+   // Appropriate lock should have been obtained\n    TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   TR_ASSERT(block->_next == NULL, \"In-use persistent memory block @ belongs to a free block chain.\", block);\n-   block->_next = NULL;\n+   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(index != LARGE_BLOCK_LIST_INDEX, \"freeFixedSizeBlock should be used for small blocks, so index cannot be LARGE_BLOCK_LIST_INDEX\");\n+   block->_next = _freeBlocks[index];\n+   _freeBlocks[index] = block;\n+   }\n \n-   // If this is a small block, add it to the appropriate fixed-size-block\n-   // chain. Otherwise add it to the variable-size-block chain which is in\n-   // ascending size order.\n+void\n+PersistentAllocator::freeVariableSizeBlock(Block * block)\n+   {\n+   // Appropriate lock should have been obtained\n+   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n+   block->_next = NULL;\n+   Block * volatile next = block->_next;", "originalCommit": "fc67d852c87273d0cc9b26c6745dc86e0f7b5596", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyNzA5NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r494527095", "bodyText": "Good catch! This is me trying to determine the effect/correctness of volatile in connection to the other defect involving j9method->extra.", "author": "mpirvu", "createdAt": "2020-09-24T18:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUxMzA4Mw=="}], "type": "inlineReview"}, {"oid": "0f4057ef37b649b81570ecee08ee5e04af9b93ce", "url": "https://github.com/eclipse-openj9/openj9/commit/0f4057ef37b649b81570ecee08ee5e04af9b93ce", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only contains blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-09-24T18:28:41Z", "type": "commit"}, {"oid": "0f4057ef37b649b81570ecee08ee5e04af9b93ce", "url": "https://github.com/eclipse-openj9/openj9/commit/0f4057ef37b649b81570ecee08ee5e04af9b93ce", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only contains blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-09-24T18:28:41Z", "type": "forcePushed"}]}