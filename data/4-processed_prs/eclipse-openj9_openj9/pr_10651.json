{"pr_number": 10651, "pr_title": "Introduce instanceHasRefs flag", "pr_createdAt": "2020-09-20T23:07:25Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10651", "timeline": [{"oid": "f45076fd4120a86188830b8504e516834ea1624c", "url": "https://github.com/eclipse-openj9/openj9/commit/f45076fd4120a86188830b8504e516834ea1624c", "message": "Introduce instanceHasRefs flag\n\nThere is an issue with instance description bits with respect to\nflattened types. See https://github.com/eclipse/openj9/issues/10070.\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs mode. The `backfill` has been\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs mode) has at least one single slot or ref field\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nThis PR is the first step in solving this problem. This PR introduces a\nflag on the J9Class that indicates whether the type has instances field\nwhich are references. In these cases the barrier API for copying\ninstance fields doesn't need to scan the instance description bits to\napply barrier loads/stores. It can simply use a slot sized load/store\nfor the operation.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-09-20T23:08:39Z", "type": "forcePushed"}, {"oid": "ec4387b4521eb91fa1c904311aab431765d8a8ca", "url": "https://github.com/eclipse-openj9/openj9/commit/ec4387b4521eb91fa1c904311aab431765d8a8ca", "message": "Introduce instanceHasRefs flag\n\nThere is an issue with instance description bits with respect to\nflattened types. See https://github.com/eclipse/openj9/issues/10070.\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs mode. The `backfill` has been\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs mode) has at least one single slot or ref field\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nThis PR is the first step in solving this problem. This PR introduces a\nflag on the J9Class that indicates whether the type has instances field\nwhich are references. In these cases the barrier API for copying\ninstance fields doesn't need to scan the instance description bits to\napply barrier loads/stores. It can simply use a slot sized load/store\nfor the operation.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-09-20T23:09:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEyMDg3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r492120877", "bodyText": "I think this would be better without the ClassClass", "author": "gacholio", "createdAt": "2020-09-21T15:01:05Z", "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -81,6 +81,7 @@\n #define J9ClassIsExemptFromValidation 0x2000\n #define J9ClassContainsUnflattenedFlattenables 0x4000\n #define J9ClassCanSupportFastSubstitutability 0x8000\n+#define J9ClassClassHasReferences 0x10000", "originalCommit": "ec4387b4521eb91fa1c904311aab431765d8a8ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEyMjk1Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r492122952", "bodyText": "Should this not set the alignment constraint flag from above?", "author": "gacholio", "createdAt": "2020-09-21T15:02:55Z", "path": "runtime/vm/createramclass.cpp", "diffHunk": "@@ -1868,12 +1868,15 @@ loadFlattenableFieldValueClasses(J9VMThread *currentThread, J9ClassLoader *class\n \t\t\t\t*valueTypeFlags |= J9ClassLargestAlignmentConstraintDouble;\n \t\t\t\tbreak;\n \t\t\tcase 'L':\n-\t\t\t\t*valueTypeFlags |= J9ClassLargestAlignmentConstraintReference;\n+\t\t\t\t*valueTypeFlags |= (J9ClassLargestAlignmentConstraintReference | J9ClassClassHasReferences);\n \t\t\t\teligibleForFastSubstitutability = false;\n \t\t\t\tbreak;\n \t\t\tcase 'F':\n \t\t\t\teligibleForFastSubstitutability = false;\n \t\t\t\tbreak;\n+\t\t\tcase '[':\n+\t\t\t\t*valueTypeFlags |= J9ClassClassHasReferences;", "originalCommit": "ec4387b4521eb91fa1c904311aab431765d8a8ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE4MTEzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r492181131", "bodyText": "Comment.", "author": "gacholio", "createdAt": "2020-09-21T16:10:26Z", "path": "runtime/vm/description.c", "diffHunk": "@@ -100,198 +104,208 @@ calculateInstanceDescription( J9VMThread *vmThread, J9Class *ramClass, J9Class *\n \t\tramClass->lockOffset =\twalkState->lockOffset;\n \t\tramClass->finalizeLinkOffset = walkState->finalizeLinkOffset;\n \t}\n-\t\n-\t/* convert all sizes from bytes to object slots */\n-\tsuperClassSize = walkResult->superTotalInstanceSize / referenceSize;\n-\ttotalSize = walkResult->totalInstanceSize / referenceSize;\n-\n-\t/* calculate number of slots required to store description bits */\n-\tshapeSlots = ROUND_UP_TO_POWEROF2(totalSize, slotsPerShapeElement);\n-\tshapeSlots = shapeSlots / slotsPerShapeElement;\n-\n-\t/* pick the space to store the description into */\n-\tif (totalSize < slotsPerShapeElement) {\n-\t\ttemp = 0;\n-\t\tshape = &temp;\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\tleafTemp = 0;\n-\t\tleafShape = &leafTemp;\n-#endif\n-\t} else {\n-\t\t/* this storage will be in the ram class, which is zeroed for us */\n-\t\tshape = storage;\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\tleafShape = storage + shapeSlots;\n-#endif\n-\t}\n-\n-\t/* Copy superclass description */\n-\tif (ramSuperClass) {\n-\t\tif ((UDATA)ramSuperClass->instanceDescription & 1) {\n-\t\t\t/* superclass description is tagged and fits in one slot */\n-\t\t\t*shape = (UDATA)ramSuperClass->instanceDescription >> 1;\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\t\t*leafShape = (UDATA)ramSuperClass->instanceLeafDescription >> 1;\n-#endif\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\tif (hasReferences)\n+#endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n+\t{\n+\t\t/* convert all sizes from bytes to object slots */\n+\t\tsuperClassSize = walkResult->superTotalInstanceSize / referenceSize;\n+\t\ttotalSize = walkResult->totalInstanceSize / referenceSize;\n+\n+\t\t/* calculate number of slots required to store description bits */\n+\t\tshapeSlots = ROUND_UP_TO_POWEROF2(totalSize, slotsPerShapeElement);\n+\t\tshapeSlots = shapeSlots / slotsPerShapeElement;\n+\n+\t\t/* pick the space to store the description into */\n+\t\tif (totalSize < slotsPerShapeElement) {\n+\t\t\ttemp = 0;\n+\t\t\tshape = &temp;\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\tleafTemp = 0;\n+\t\t\tleafShape = &leafTemp;\n+\t#endif\n \t\t} else {\n-\t\t\t/* superclass description is stored indirect */\n-\t\t\tUDATA i, superSlots;\n-\t\t\tsuperSlots = ROUND_UP_TO_POWEROF2(superClassSize, slotsPerShapeElement);\n-\t\t\tsuperSlots = superSlots / slotsPerShapeElement;\n+\t\t\t/* this storage will be in the ram class, which is zeroed for us */\n+\t\t\tshape = storage;\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\tleafShape = storage + shapeSlots;\n+\t#endif\n+\t\t}\n \n-\t\t\tfor (i = 0; i < superSlots; i++) {\n-\t\t\t\tshape[i] = ramSuperClass->instanceDescription[i];\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\t\t\tleafShape[i] = ramSuperClass->instanceLeafDescription[i];\n-#endif\n+\t\t/* Copy superclass description */\n+\t\tif (ramSuperClass) {\n+\t\t\tif ((UDATA)ramSuperClass->instanceDescription & 1) {\n+\t\t\t\t/* superclass description is tagged and fits in one slot */\n+\t\t\t\t*shape = (UDATA)ramSuperClass->instanceDescription >> 1;\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\t\t*leafShape = (UDATA)ramSuperClass->instanceLeafDescription >> 1;\n+\t#endif\n+\t\t\t} else {\n+\t\t\t\t/* superclass description is stored indirect */\n+\t\t\t\tUDATA i, superSlots;\n+\t\t\t\tsuperSlots = ROUND_UP_TO_POWEROF2(superClassSize, slotsPerShapeElement);\n+\t\t\t\tsuperSlots = superSlots / slotsPerShapeElement;\n+\n+\t\t\t\tfor (i = 0; i < superSlots; i++) {\n+\t\t\t\t\tshape[i] = ramSuperClass->instanceDescription[i];\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\t\t\tleafShape[i] = ramSuperClass->instanceLeafDescription[i];\n+\t#endif\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n \n-\t\t/* If there are self referencing field offsets being inherited then self referencing fields of this class should be ignored.*/\n-\t\tif (shouldSaveSelfReferencingFields) {\n-\t\t\tshouldSaveSelfReferencingFields = (ramSuperClass->selfReferencingField1 == 0);\n+\t\t\t/* If there are self referencing field offsets being inherited then self referencing fields of this class should be ignored.*/\n+\t\t\tif (shouldSaveSelfReferencingFields) {\n+\t\t\t\tshouldSaveSelfReferencingFields = (ramSuperClass->selfReferencingField1 == 0);\n+\t\t\t}\n \t\t}\n-\t}\n \n-\t/* calculate the description for this class - walk object instance fields and \n-\t * set the corresponding description bit for each \n-\t */\n-\t{\n-\t\twhile (walkResult->field) {\n-\t\t\tUDATA slotOffset = walkResult->offset / (referenceSize * slotsPerShapeElement);\n-\t\t\tJ9UTF8 *fieldSig = J9ROMFIELDSHAPE_SIGNATURE(walkResult->field);\n-\t\t\tU_8 *fieldSigBytes = J9UTF8_DATA(fieldSig);\n-\t\t\tU_16 fieldSigLength = J9UTF8_LENGTH(fieldSig);\n-\n-\t\t\t/* If the field is self referencing then store the offset to it (at most 2). Self referencing fields\n-\t\t\t * are to be scanned with priority during GC. Both self referencing fields must be from the same class.\n-\t\t\t */\n-\t\t\tif (shouldSaveSelfReferencingFields && ((ramClass->selfReferencingField1 == 0) || (ramClass->selfReferencingField2 == 0))) {\n-\t\t\t\tif (J9UTF8_DATA_EQUALS(J9UTF8_DATA(className), J9UTF8_LENGTH(className), fieldSigBytes + 1, fieldSigLength - 2)) {\n-\t\t\t\t\tif (ramClass->selfReferencingField1 == 0) {\n-\t\t\t\t\t\tramClass->selfReferencingField1 = walkResult->offset + objectHeaderSize;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tramClass->selfReferencingField2 = walkResult->offset + objectHeaderSize;\n+\t\t/* calculate the description for this class - walk object instance fields and\n+\t\t * set the corresponding description bit for each\n+\t\t */\n+\t\t{\n+\t\t\twhile (walkResult->field) {\n+\t\t\t\tUDATA slotOffset = walkResult->offset / (referenceSize * slotsPerShapeElement);\n+\t\t\t\tJ9UTF8 *fieldSig = J9ROMFIELDSHAPE_SIGNATURE(walkResult->field);\n+\t\t\t\tU_8 *fieldSigBytes = J9UTF8_DATA(fieldSig);\n+\t\t\t\tU_16 fieldSigLength = J9UTF8_LENGTH(fieldSig);\n+\n+\t\t\t\t/* If the field is self referencing then store the offset to it (at most 2). Self referencing fields\n+\t\t\t\t * are to be scanned with priority during GC. Both self referencing fields must be from the same class.\n+\t\t\t\t */\n+\t\t\t\tif (shouldSaveSelfReferencingFields && ((ramClass->selfReferencingField1 == 0) || (ramClass->selfReferencingField2 == 0))) {\n+\t\t\t\t\tif (J9UTF8_DATA_EQUALS(J9UTF8_DATA(className), J9UTF8_LENGTH(className), fieldSigBytes + 1, fieldSigLength - 2)) {\n+\t\t\t\t\t\tif (ramClass->selfReferencingField1 == 0) {\n+\t\t\t\t\t\t\tramClass->selfReferencingField1 = walkResult->offset + objectHeaderSize;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tramClass->selfReferencingField2 = walkResult->offset + objectHeaderSize;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t}\n \n #ifdef J9VM_OPT_VALHALLA_VALUE_TYPES\n-\t\t\tif ('Q' == *fieldSigBytes) {\n-\t\t\t\tJ9Class *fieldClass = walkResult->flattenedClass;\n-\t\t\t\tif ((NULL != fieldClass) && J9_ARE_ALL_BITS_SET(fieldClass->classFlags, J9ClassIsFlattened)) {\n-\t\t\t\t\tUDATA size = fieldClass->totalInstanceSize;\n-\n-\t\t\t\t\t/* positive means the field will spill over to the next slot in the shape array */\n-\t\t\t\t\tIDATA spillAmount = ((walkResult->offset + size) - (slotOffset * (referenceSize * slotsPerShapeElement))) - (referenceSize * slotsPerShapeElement);\n-\t\t\t\t\tUDATA shift = ((walkResult->offset  % (referenceSize * slotsPerShapeElement)) / referenceSize);\n-\t\t\t\t\tif (0 >= spillAmount) {\n-\t\t\t\t\t\t/* If we are here this means the description bits for the field fits within the current\n-\t\t\t\t\t\t * slot shape word. This also means they are all low tagged.\n-\t\t\t\t\t\t */\n-\t\t\t\t\t\tUDATA bits = 0;\n-\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n-\n-\t\t\t\t\t\t/* remove low tag bit */\n-\t\t\t\t\t\tdescription >>= 1;\n-\t\t\t\t\t\tbits = (UDATA) description << shift;\n-\t\t\t\t\t\tshape[slotOffset] |= bits;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n-\n-\t\t\t\t\t\tif (J9_ARE_ALL_BITS_SET(description, 1)) {\n-\t\t\t\t\t\t\t/* simple case where the field has less than 64 (or 32 slots if in 32bit mode) slots. Split the instance\n-\t\t\t\t\t\t\t * bits into two parts, put the first part at the current slot offset put the last part in the next one */\n-\t\t\t\t\t\t\tUDATA nextDescription = 0;\n-\t\t\t\t\t\t\tUDATA spillBits = spillAmount/referenceSize;\n+\t\t\t\tif ('Q' == *fieldSigBytes) {\n+\t\t\t\t\tJ9Class *fieldClass = walkResult->flattenedClass;\n+\t\t\t\t\tif ((NULL != fieldClass) && J9_ARE_ALL_BITS_SET(fieldClass->classFlags, J9ClassIsFlattened)) {\n+\t\t\t\t\t\tUDATA size = fieldClass->totalInstanceSize;\n+\n+\t\t\t\t\t\t/* positive means the field will spill over to the next slot in the shape array */\n+\t\t\t\t\t\tIDATA spillAmount = ((walkResult->offset + size) - (slotOffset * (referenceSize * slotsPerShapeElement))) - (referenceSize * slotsPerShapeElement);\n+\t\t\t\t\t\tUDATA shift = ((walkResult->offset  % (referenceSize * slotsPerShapeElement)) / referenceSize);\n+\t\t\t\t\t\tif (0 >= spillAmount) {\n+\t\t\t\t\t\t\t/* If we are here this means the description bits for the field fits within the current\n+\t\t\t\t\t\t\t * slot shape word. This also means they are all low tagged.\n+\t\t\t\t\t\t\t */\n+\t\t\t\t\t\t\tUDATA bits = 0;\n+\t\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n \n \t\t\t\t\t\t\t/* remove low tag bit */\n \t\t\t\t\t\t\tdescription >>= 1;\n-\n-\t\t\t\t\t\t\tnextDescription = description;\n-\t\t\t\t\t\t\tnextDescription >>= ((size/referenceSize) - spillBits);\n-\t\t\t\t\t\t\tdescription <<= shift;\n-\t\t\t\t\t\t\tshape[slotOffset] |= description;\n-\t\t\t\t\t\t\tslotOffset += 1;\n-\t\t\t\t\t\t\tshape[slotOffset] |= nextDescription;\n+\t\t\t\t\t\t\tbits = (UDATA) description << shift;\n+\t\t\t\t\t\t\tshape[slotOffset] |= bits;\n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t/* complex case were field is larger than 64 slots. Just add the bits\n-\t\t\t\t\t\t\t * one at a time. */\n-\t\t\t\t\t\t\tUDATA *descriptionPtr = (UDATA *)description;\n-\t\t\t\t\t\t\tUDATA totalAmountLeft = size/referenceSize;\n-\t\t\t\t\t\t\tUDATA positionInDescriptionWord = 0;\n-\t\t\t\t\t\t\tUDATA bitsLeftInShapeSlot = slotsPerShapeElement - shift;\n-\n-\t\t\t\t\t\t\tdescription = *descriptionPtr;\n-\t\t\t\t\t\t\tdescriptionPtr += 1;\n-\n-\t\t\t\t\t\t\twhile (totalAmountLeft > 0) {\n-\t\t\t\t\t\t\t\tshape[slotOffset] |= (1 & description) << (slotsPerShapeElement - bitsLeftInShapeSlot);\n-\t\t\t\t\t\t\t\tdescription >>= 1;\n-\t\t\t\t\t\t\t\tpositionInDescriptionWord++;\n+\t\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n \n-\t\t\t\t\t\t\t\tif (slotsPerShapeElement == positionInDescriptionWord) {\n-\t\t\t\t\t\t\t\t\tdescription = *descriptionPtr;\n-\t\t\t\t\t\t\t\t\tdescriptionPtr += 1;\n-\t\t\t\t\t\t\t\t\tpositionInDescriptionWord = 0;\n-\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (J9_ARE_ALL_BITS_SET(description, 1)) {\n+\t\t\t\t\t\t\t\t/* simple case where the field has less than 64 (or 32 slots if in 32bit mode) slots. Split the instance\n+\t\t\t\t\t\t\t\t * bits into two parts, put the first part at the current slot offset put the last part in the next one */\n+\t\t\t\t\t\t\t\tUDATA nextDescription = 0;\n+\t\t\t\t\t\t\t\tUDATA spillBits = spillAmount/referenceSize;\n+\n+\t\t\t\t\t\t\t\t/* remove low tag bit */\n+\t\t\t\t\t\t\t\tdescription >>= 1;\n \n-\t\t\t\t\t\t\t\tbitsLeftInShapeSlot--;\n-\t\t\t\t\t\t\t\tif (0 == bitsLeftInShapeSlot) {\n-\t\t\t\t\t\t\t\t\tslotOffset++;\n-\t\t\t\t\t\t\t\t\tbitsLeftInShapeSlot = 64;\n+\t\t\t\t\t\t\t\tnextDescription = description;\n+\t\t\t\t\t\t\t\tnextDescription >>= ((size/referenceSize) - spillBits);\n+\t\t\t\t\t\t\t\tdescription <<= shift;\n+\t\t\t\t\t\t\t\tshape[slotOffset] |= description;\n+\t\t\t\t\t\t\t\tslotOffset += 1;\n+\t\t\t\t\t\t\t\tshape[slotOffset] |= nextDescription;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t/* complex case were field is larger than 64 slots. Just add the bits\n+\t\t\t\t\t\t\t\t * one at a time. */\n+\t\t\t\t\t\t\t\tUDATA *descriptionPtr = (UDATA *)description;\n+\t\t\t\t\t\t\t\tUDATA totalAmountLeft = size/referenceSize;\n+\t\t\t\t\t\t\t\tUDATA positionInDescriptionWord = 0;\n+\t\t\t\t\t\t\t\tUDATA bitsLeftInShapeSlot = slotsPerShapeElement - shift;\n+\n+\t\t\t\t\t\t\t\tdescription = *descriptionPtr;\n+\t\t\t\t\t\t\t\tdescriptionPtr += 1;\n+\n+\t\t\t\t\t\t\t\twhile (totalAmountLeft > 0) {\n+\t\t\t\t\t\t\t\t\tshape[slotOffset] |= (1 & description) << (slotsPerShapeElement - bitsLeftInShapeSlot);\n+\t\t\t\t\t\t\t\t\tdescription >>= 1;\n+\t\t\t\t\t\t\t\t\tpositionInDescriptionWord++;\n+\n+\t\t\t\t\t\t\t\t\tif (slotsPerShapeElement == positionInDescriptionWord) {\n+\t\t\t\t\t\t\t\t\t\tdescription = *descriptionPtr;\n+\t\t\t\t\t\t\t\t\t\tdescriptionPtr += 1;\n+\t\t\t\t\t\t\t\t\t\tpositionInDescriptionWord = 0;\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\tbitsLeftInShapeSlot--;\n+\t\t\t\t\t\t\t\t\tif (0 == bitsLeftInShapeSlot) {\n+\t\t\t\t\t\t\t\t\t\tslotOffset++;\n+\t\t\t\t\t\t\t\t\t\tbitsLeftInShapeSlot = 64;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\ttotalAmountLeft--;\n \t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\ttotalAmountLeft--;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tUDATA bit = (UDATA)1 << ((walkResult->offset % (referenceSize * slotsPerShapeElement)) / referenceSize);\n+\t\t\t\t\t\tshape[slotOffset] |= bit;\n \t\t\t\t\t}\n-\t\t\t\t} else {\n+\t\t\t\t} else\n+#endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n+\t\t\t\t{\n \t\t\t\t\tUDATA bit = (UDATA)1 << ((walkResult->offset % (referenceSize * slotsPerShapeElement)) / referenceSize);\n \t\t\t\t\tshape[slotOffset] |= bit;\n-\t\t\t\t}\n-\t\t\t} else\n-#endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n-\t\t\t{\n-\t\t\t\tUDATA bit = (UDATA)1 << ((walkResult->offset % (referenceSize * slotsPerShapeElement)) / referenceSize);\n-\t\t\t\tshape[slotOffset] |= bit;\n #ifdef J9VM_GC_LEAF_BITS\n-\t\t\t\tif (isLeafField(walkResult->field)) {\n-\t\t\t\t\tleafShape[slotOffset] |= bit;\n-\t\t\t\t} else if (isString) {\n-\t\t\t\t\tJ9UTF8 *fieldName = J9ROMFIELDSHAPE_NAME(walkResult->field);\n-\n-\t\t\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(fieldName), J9UTF8_LENGTH(fieldName), \"value\")) {\n+\t\t\t\t\tif (isLeafField(walkResult->field)) {\n \t\t\t\t\t\tleafShape[slotOffset] |= bit;\n+\t\t\t\t\t} else if (isString) {\n+\t\t\t\t\t\tJ9UTF8 *fieldName = J9ROMFIELDSHAPE_NAME(walkResult->field);\n+\n+\t\t\t\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(fieldName), J9UTF8_LENGTH(fieldName), \"value\")) {\n+\t\t\t\t\t\t\tleafShape[slotOffset] |= bit;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t}\n #endif\n-\t\t\t}\n+\t\t\t\t}\n \n-\t\t\twalkResult = fieldOffsetsNextDo(walkState);\n+\t\t\t\twalkResult = fieldOffsetsNextDo(walkState);\n+\t\t\t}\n \t\t}\n-\t}\n \n-\tif (totalSize < slotsPerShapeElement) {\n-\t\t/* tag low bit, store in place */\n-\t\ttemp <<= 1;\n-\t\ttemp |= 1;\n-\t\tramClass->instanceDescription = (UDATA *)temp;\n+\t\tif (totalSize < slotsPerShapeElement) {\n+\t\t\t/* tag low bit, store in place */\n+\t\t\ttemp <<= 1;\n+\t\t\ttemp |= 1;\n+\t\t\tramClass->instanceDescription = (UDATA *)temp;\n #ifdef J9VM_GC_LEAF_BITS\n-\t\tleafTemp <<= 1;\n-\t\tleafTemp |= 1;\n-\t\tramClass->instanceLeafDescription = (UDATA *)leafTemp;\n+\t\t\tleafTemp <<= 1;\n+\t\t\tleafTemp |= 1;\n+\t\t\tramClass->instanceLeafDescription = (UDATA *)leafTemp;\n #endif\n-\n-\t\tTrc_VM_calculateInstanceDescription_taggedResult(NULL, temp);\n-\t} else {\n-\t\t/* used extra space, store the address */\n-\t\tramClass->instanceDescription = storage;\n+\t\t\tTrc_VM_calculateInstanceDescription_taggedResult(NULL, temp);\n+\t\t} else {\n+\t\t\t/* used extra space, store the address */\n+\t\t\tramClass->instanceDescription = storage;\n #ifdef J9VM_GC_LEAF_BITS\n-\t\tramClass->instanceLeafDescription = storage + shapeSlots;\n-\n-\t\tTrc_VM_calculateInstanceDescription_indirectResult(NULL, storage[0]);\n+\t\t\tramClass->instanceLeafDescription = storage + shapeSlots;\n+#endif", "originalCommit": "ec4387b4521eb91fa1c904311aab431765d8a8ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE4MTM2Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r492181362", "bodyText": "Comment.", "author": "gacholio", "createdAt": "2020-09-21T16:10:44Z", "path": "runtime/vm/description.c", "diffHunk": "@@ -100,198 +104,208 @@ calculateInstanceDescription( J9VMThread *vmThread, J9Class *ramClass, J9Class *\n \t\tramClass->lockOffset =\twalkState->lockOffset;\n \t\tramClass->finalizeLinkOffset = walkState->finalizeLinkOffset;\n \t}\n-\t\n-\t/* convert all sizes from bytes to object slots */\n-\tsuperClassSize = walkResult->superTotalInstanceSize / referenceSize;\n-\ttotalSize = walkResult->totalInstanceSize / referenceSize;\n-\n-\t/* calculate number of slots required to store description bits */\n-\tshapeSlots = ROUND_UP_TO_POWEROF2(totalSize, slotsPerShapeElement);\n-\tshapeSlots = shapeSlots / slotsPerShapeElement;\n-\n-\t/* pick the space to store the description into */\n-\tif (totalSize < slotsPerShapeElement) {\n-\t\ttemp = 0;\n-\t\tshape = &temp;\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\tleafTemp = 0;\n-\t\tleafShape = &leafTemp;\n-#endif\n-\t} else {\n-\t\t/* this storage will be in the ram class, which is zeroed for us */\n-\t\tshape = storage;\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\tleafShape = storage + shapeSlots;\n-#endif\n-\t}\n-\n-\t/* Copy superclass description */\n-\tif (ramSuperClass) {\n-\t\tif ((UDATA)ramSuperClass->instanceDescription & 1) {\n-\t\t\t/* superclass description is tagged and fits in one slot */\n-\t\t\t*shape = (UDATA)ramSuperClass->instanceDescription >> 1;\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\t\t*leafShape = (UDATA)ramSuperClass->instanceLeafDescription >> 1;\n-#endif\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\tif (hasReferences)\n+#endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n+\t{\n+\t\t/* convert all sizes from bytes to object slots */\n+\t\tsuperClassSize = walkResult->superTotalInstanceSize / referenceSize;\n+\t\ttotalSize = walkResult->totalInstanceSize / referenceSize;\n+\n+\t\t/* calculate number of slots required to store description bits */\n+\t\tshapeSlots = ROUND_UP_TO_POWEROF2(totalSize, slotsPerShapeElement);\n+\t\tshapeSlots = shapeSlots / slotsPerShapeElement;\n+\n+\t\t/* pick the space to store the description into */\n+\t\tif (totalSize < slotsPerShapeElement) {\n+\t\t\ttemp = 0;\n+\t\t\tshape = &temp;\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\tleafTemp = 0;\n+\t\t\tleafShape = &leafTemp;\n+\t#endif\n \t\t} else {\n-\t\t\t/* superclass description is stored indirect */\n-\t\t\tUDATA i, superSlots;\n-\t\t\tsuperSlots = ROUND_UP_TO_POWEROF2(superClassSize, slotsPerShapeElement);\n-\t\t\tsuperSlots = superSlots / slotsPerShapeElement;\n+\t\t\t/* this storage will be in the ram class, which is zeroed for us */\n+\t\t\tshape = storage;\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\tleafShape = storage + shapeSlots;\n+\t#endif\n+\t\t}\n \n-\t\t\tfor (i = 0; i < superSlots; i++) {\n-\t\t\t\tshape[i] = ramSuperClass->instanceDescription[i];\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\t\t\tleafShape[i] = ramSuperClass->instanceLeafDescription[i];\n-#endif\n+\t\t/* Copy superclass description */\n+\t\tif (ramSuperClass) {\n+\t\t\tif ((UDATA)ramSuperClass->instanceDescription & 1) {\n+\t\t\t\t/* superclass description is tagged and fits in one slot */\n+\t\t\t\t*shape = (UDATA)ramSuperClass->instanceDescription >> 1;\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\t\t*leafShape = (UDATA)ramSuperClass->instanceLeafDescription >> 1;\n+\t#endif\n+\t\t\t} else {\n+\t\t\t\t/* superclass description is stored indirect */\n+\t\t\t\tUDATA i, superSlots;\n+\t\t\t\tsuperSlots = ROUND_UP_TO_POWEROF2(superClassSize, slotsPerShapeElement);\n+\t\t\t\tsuperSlots = superSlots / slotsPerShapeElement;\n+\n+\t\t\t\tfor (i = 0; i < superSlots; i++) {\n+\t\t\t\t\tshape[i] = ramSuperClass->instanceDescription[i];\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\t\t\tleafShape[i] = ramSuperClass->instanceLeafDescription[i];\n+\t#endif\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n \n-\t\t/* If there are self referencing field offsets being inherited then self referencing fields of this class should be ignored.*/\n-\t\tif (shouldSaveSelfReferencingFields) {\n-\t\t\tshouldSaveSelfReferencingFields = (ramSuperClass->selfReferencingField1 == 0);\n+\t\t\t/* If there are self referencing field offsets being inherited then self referencing fields of this class should be ignored.*/\n+\t\t\tif (shouldSaveSelfReferencingFields) {\n+\t\t\t\tshouldSaveSelfReferencingFields = (ramSuperClass->selfReferencingField1 == 0);\n+\t\t\t}\n \t\t}\n-\t}\n \n-\t/* calculate the description for this class - walk object instance fields and \n-\t * set the corresponding description bit for each \n-\t */\n-\t{\n-\t\twhile (walkResult->field) {\n-\t\t\tUDATA slotOffset = walkResult->offset / (referenceSize * slotsPerShapeElement);\n-\t\t\tJ9UTF8 *fieldSig = J9ROMFIELDSHAPE_SIGNATURE(walkResult->field);\n-\t\t\tU_8 *fieldSigBytes = J9UTF8_DATA(fieldSig);\n-\t\t\tU_16 fieldSigLength = J9UTF8_LENGTH(fieldSig);\n-\n-\t\t\t/* If the field is self referencing then store the offset to it (at most 2). Self referencing fields\n-\t\t\t * are to be scanned with priority during GC. Both self referencing fields must be from the same class.\n-\t\t\t */\n-\t\t\tif (shouldSaveSelfReferencingFields && ((ramClass->selfReferencingField1 == 0) || (ramClass->selfReferencingField2 == 0))) {\n-\t\t\t\tif (J9UTF8_DATA_EQUALS(J9UTF8_DATA(className), J9UTF8_LENGTH(className), fieldSigBytes + 1, fieldSigLength - 2)) {\n-\t\t\t\t\tif (ramClass->selfReferencingField1 == 0) {\n-\t\t\t\t\t\tramClass->selfReferencingField1 = walkResult->offset + objectHeaderSize;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tramClass->selfReferencingField2 = walkResult->offset + objectHeaderSize;\n+\t\t/* calculate the description for this class - walk object instance fields and\n+\t\t * set the corresponding description bit for each\n+\t\t */\n+\t\t{\n+\t\t\twhile (walkResult->field) {\n+\t\t\t\tUDATA slotOffset = walkResult->offset / (referenceSize * slotsPerShapeElement);\n+\t\t\t\tJ9UTF8 *fieldSig = J9ROMFIELDSHAPE_SIGNATURE(walkResult->field);\n+\t\t\t\tU_8 *fieldSigBytes = J9UTF8_DATA(fieldSig);\n+\t\t\t\tU_16 fieldSigLength = J9UTF8_LENGTH(fieldSig);\n+\n+\t\t\t\t/* If the field is self referencing then store the offset to it (at most 2). Self referencing fields\n+\t\t\t\t * are to be scanned with priority during GC. Both self referencing fields must be from the same class.\n+\t\t\t\t */\n+\t\t\t\tif (shouldSaveSelfReferencingFields && ((ramClass->selfReferencingField1 == 0) || (ramClass->selfReferencingField2 == 0))) {\n+\t\t\t\t\tif (J9UTF8_DATA_EQUALS(J9UTF8_DATA(className), J9UTF8_LENGTH(className), fieldSigBytes + 1, fieldSigLength - 2)) {\n+\t\t\t\t\t\tif (ramClass->selfReferencingField1 == 0) {\n+\t\t\t\t\t\t\tramClass->selfReferencingField1 = walkResult->offset + objectHeaderSize;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tramClass->selfReferencingField2 = walkResult->offset + objectHeaderSize;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t}\n \n #ifdef J9VM_OPT_VALHALLA_VALUE_TYPES\n-\t\t\tif ('Q' == *fieldSigBytes) {\n-\t\t\t\tJ9Class *fieldClass = walkResult->flattenedClass;\n-\t\t\t\tif ((NULL != fieldClass) && J9_ARE_ALL_BITS_SET(fieldClass->classFlags, J9ClassIsFlattened)) {\n-\t\t\t\t\tUDATA size = fieldClass->totalInstanceSize;\n-\n-\t\t\t\t\t/* positive means the field will spill over to the next slot in the shape array */\n-\t\t\t\t\tIDATA spillAmount = ((walkResult->offset + size) - (slotOffset * (referenceSize * slotsPerShapeElement))) - (referenceSize * slotsPerShapeElement);\n-\t\t\t\t\tUDATA shift = ((walkResult->offset  % (referenceSize * slotsPerShapeElement)) / referenceSize);\n-\t\t\t\t\tif (0 >= spillAmount) {\n-\t\t\t\t\t\t/* If we are here this means the description bits for the field fits within the current\n-\t\t\t\t\t\t * slot shape word. This also means they are all low tagged.\n-\t\t\t\t\t\t */\n-\t\t\t\t\t\tUDATA bits = 0;\n-\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n-\n-\t\t\t\t\t\t/* remove low tag bit */\n-\t\t\t\t\t\tdescription >>= 1;\n-\t\t\t\t\t\tbits = (UDATA) description << shift;\n-\t\t\t\t\t\tshape[slotOffset] |= bits;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n-\n-\t\t\t\t\t\tif (J9_ARE_ALL_BITS_SET(description, 1)) {\n-\t\t\t\t\t\t\t/* simple case where the field has less than 64 (or 32 slots if in 32bit mode) slots. Split the instance\n-\t\t\t\t\t\t\t * bits into two parts, put the first part at the current slot offset put the last part in the next one */\n-\t\t\t\t\t\t\tUDATA nextDescription = 0;\n-\t\t\t\t\t\t\tUDATA spillBits = spillAmount/referenceSize;\n+\t\t\t\tif ('Q' == *fieldSigBytes) {\n+\t\t\t\t\tJ9Class *fieldClass = walkResult->flattenedClass;\n+\t\t\t\t\tif ((NULL != fieldClass) && J9_ARE_ALL_BITS_SET(fieldClass->classFlags, J9ClassIsFlattened)) {\n+\t\t\t\t\t\tUDATA size = fieldClass->totalInstanceSize;\n+\n+\t\t\t\t\t\t/* positive means the field will spill over to the next slot in the shape array */\n+\t\t\t\t\t\tIDATA spillAmount = ((walkResult->offset + size) - (slotOffset * (referenceSize * slotsPerShapeElement))) - (referenceSize * slotsPerShapeElement);\n+\t\t\t\t\t\tUDATA shift = ((walkResult->offset  % (referenceSize * slotsPerShapeElement)) / referenceSize);\n+\t\t\t\t\t\tif (0 >= spillAmount) {\n+\t\t\t\t\t\t\t/* If we are here this means the description bits for the field fits within the current\n+\t\t\t\t\t\t\t * slot shape word. This also means they are all low tagged.\n+\t\t\t\t\t\t\t */\n+\t\t\t\t\t\t\tUDATA bits = 0;\n+\t\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n \n \t\t\t\t\t\t\t/* remove low tag bit */\n \t\t\t\t\t\t\tdescription >>= 1;\n-\n-\t\t\t\t\t\t\tnextDescription = description;\n-\t\t\t\t\t\t\tnextDescription >>= ((size/referenceSize) - spillBits);\n-\t\t\t\t\t\t\tdescription <<= shift;\n-\t\t\t\t\t\t\tshape[slotOffset] |= description;\n-\t\t\t\t\t\t\tslotOffset += 1;\n-\t\t\t\t\t\t\tshape[slotOffset] |= nextDescription;\n+\t\t\t\t\t\t\tbits = (UDATA) description << shift;\n+\t\t\t\t\t\t\tshape[slotOffset] |= bits;\n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t/* complex case were field is larger than 64 slots. Just add the bits\n-\t\t\t\t\t\t\t * one at a time. */\n-\t\t\t\t\t\t\tUDATA *descriptionPtr = (UDATA *)description;\n-\t\t\t\t\t\t\tUDATA totalAmountLeft = size/referenceSize;\n-\t\t\t\t\t\t\tUDATA positionInDescriptionWord = 0;\n-\t\t\t\t\t\t\tUDATA bitsLeftInShapeSlot = slotsPerShapeElement - shift;\n-\n-\t\t\t\t\t\t\tdescription = *descriptionPtr;\n-\t\t\t\t\t\t\tdescriptionPtr += 1;\n-\n-\t\t\t\t\t\t\twhile (totalAmountLeft > 0) {\n-\t\t\t\t\t\t\t\tshape[slotOffset] |= (1 & description) << (slotsPerShapeElement - bitsLeftInShapeSlot);\n-\t\t\t\t\t\t\t\tdescription >>= 1;\n-\t\t\t\t\t\t\t\tpositionInDescriptionWord++;\n+\t\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n \n-\t\t\t\t\t\t\t\tif (slotsPerShapeElement == positionInDescriptionWord) {\n-\t\t\t\t\t\t\t\t\tdescription = *descriptionPtr;\n-\t\t\t\t\t\t\t\t\tdescriptionPtr += 1;\n-\t\t\t\t\t\t\t\t\tpositionInDescriptionWord = 0;\n-\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (J9_ARE_ALL_BITS_SET(description, 1)) {\n+\t\t\t\t\t\t\t\t/* simple case where the field has less than 64 (or 32 slots if in 32bit mode) slots. Split the instance\n+\t\t\t\t\t\t\t\t * bits into two parts, put the first part at the current slot offset put the last part in the next one */\n+\t\t\t\t\t\t\t\tUDATA nextDescription = 0;\n+\t\t\t\t\t\t\t\tUDATA spillBits = spillAmount/referenceSize;\n+\n+\t\t\t\t\t\t\t\t/* remove low tag bit */\n+\t\t\t\t\t\t\t\tdescription >>= 1;\n \n-\t\t\t\t\t\t\t\tbitsLeftInShapeSlot--;\n-\t\t\t\t\t\t\t\tif (0 == bitsLeftInShapeSlot) {\n-\t\t\t\t\t\t\t\t\tslotOffset++;\n-\t\t\t\t\t\t\t\t\tbitsLeftInShapeSlot = 64;\n+\t\t\t\t\t\t\t\tnextDescription = description;\n+\t\t\t\t\t\t\t\tnextDescription >>= ((size/referenceSize) - spillBits);\n+\t\t\t\t\t\t\t\tdescription <<= shift;\n+\t\t\t\t\t\t\t\tshape[slotOffset] |= description;\n+\t\t\t\t\t\t\t\tslotOffset += 1;\n+\t\t\t\t\t\t\t\tshape[slotOffset] |= nextDescription;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t/* complex case were field is larger than 64 slots. Just add the bits\n+\t\t\t\t\t\t\t\t * one at a time. */\n+\t\t\t\t\t\t\t\tUDATA *descriptionPtr = (UDATA *)description;\n+\t\t\t\t\t\t\t\tUDATA totalAmountLeft = size/referenceSize;\n+\t\t\t\t\t\t\t\tUDATA positionInDescriptionWord = 0;\n+\t\t\t\t\t\t\t\tUDATA bitsLeftInShapeSlot = slotsPerShapeElement - shift;\n+\n+\t\t\t\t\t\t\t\tdescription = *descriptionPtr;\n+\t\t\t\t\t\t\t\tdescriptionPtr += 1;\n+\n+\t\t\t\t\t\t\t\twhile (totalAmountLeft > 0) {\n+\t\t\t\t\t\t\t\t\tshape[slotOffset] |= (1 & description) << (slotsPerShapeElement - bitsLeftInShapeSlot);\n+\t\t\t\t\t\t\t\t\tdescription >>= 1;\n+\t\t\t\t\t\t\t\t\tpositionInDescriptionWord++;\n+\n+\t\t\t\t\t\t\t\t\tif (slotsPerShapeElement == positionInDescriptionWord) {\n+\t\t\t\t\t\t\t\t\t\tdescription = *descriptionPtr;\n+\t\t\t\t\t\t\t\t\t\tdescriptionPtr += 1;\n+\t\t\t\t\t\t\t\t\t\tpositionInDescriptionWord = 0;\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\tbitsLeftInShapeSlot--;\n+\t\t\t\t\t\t\t\t\tif (0 == bitsLeftInShapeSlot) {\n+\t\t\t\t\t\t\t\t\t\tslotOffset++;\n+\t\t\t\t\t\t\t\t\t\tbitsLeftInShapeSlot = 64;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\ttotalAmountLeft--;\n \t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\ttotalAmountLeft--;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tUDATA bit = (UDATA)1 << ((walkResult->offset % (referenceSize * slotsPerShapeElement)) / referenceSize);\n+\t\t\t\t\t\tshape[slotOffset] |= bit;\n \t\t\t\t\t}\n-\t\t\t\t} else {\n+\t\t\t\t} else\n+#endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n+\t\t\t\t{\n \t\t\t\t\tUDATA bit = (UDATA)1 << ((walkResult->offset % (referenceSize * slotsPerShapeElement)) / referenceSize);\n \t\t\t\t\tshape[slotOffset] |= bit;\n-\t\t\t\t}\n-\t\t\t} else\n-#endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n-\t\t\t{\n-\t\t\t\tUDATA bit = (UDATA)1 << ((walkResult->offset % (referenceSize * slotsPerShapeElement)) / referenceSize);\n-\t\t\t\tshape[slotOffset] |= bit;\n #ifdef J9VM_GC_LEAF_BITS\n-\t\t\t\tif (isLeafField(walkResult->field)) {\n-\t\t\t\t\tleafShape[slotOffset] |= bit;\n-\t\t\t\t} else if (isString) {\n-\t\t\t\t\tJ9UTF8 *fieldName = J9ROMFIELDSHAPE_NAME(walkResult->field);\n-\n-\t\t\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(fieldName), J9UTF8_LENGTH(fieldName), \"value\")) {\n+\t\t\t\t\tif (isLeafField(walkResult->field)) {\n \t\t\t\t\t\tleafShape[slotOffset] |= bit;\n+\t\t\t\t\t} else if (isString) {\n+\t\t\t\t\t\tJ9UTF8 *fieldName = J9ROMFIELDSHAPE_NAME(walkResult->field);\n+\n+\t\t\t\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(fieldName), J9UTF8_LENGTH(fieldName), \"value\")) {\n+\t\t\t\t\t\t\tleafShape[slotOffset] |= bit;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t}\n #endif\n-\t\t\t}\n+\t\t\t\t}\n \n-\t\t\twalkResult = fieldOffsetsNextDo(walkState);\n+\t\t\t\twalkResult = fieldOffsetsNextDo(walkState);\n+\t\t\t}\n \t\t}\n-\t}\n \n-\tif (totalSize < slotsPerShapeElement) {\n-\t\t/* tag low bit, store in place */\n-\t\ttemp <<= 1;\n-\t\ttemp |= 1;\n-\t\tramClass->instanceDescription = (UDATA *)temp;\n+\t\tif (totalSize < slotsPerShapeElement) {\n+\t\t\t/* tag low bit, store in place */\n+\t\t\ttemp <<= 1;\n+\t\t\ttemp |= 1;\n+\t\t\tramClass->instanceDescription = (UDATA *)temp;\n #ifdef J9VM_GC_LEAF_BITS\n-\t\tleafTemp <<= 1;\n-\t\tleafTemp |= 1;\n-\t\tramClass->instanceLeafDescription = (UDATA *)leafTemp;\n+\t\t\tleafTemp <<= 1;\n+\t\t\tleafTemp |= 1;\n+\t\t\tramClass->instanceLeafDescription = (UDATA *)leafTemp;\n #endif\n-\n-\t\tTrc_VM_calculateInstanceDescription_taggedResult(NULL, temp);\n-\t} else {\n-\t\t/* used extra space, store the address */\n-\t\tramClass->instanceDescription = storage;\n+\t\t\tTrc_VM_calculateInstanceDescription_taggedResult(NULL, temp);\n+\t\t} else {\n+\t\t\t/* used extra space, store the address */\n+\t\t\tramClass->instanceDescription = storage;\n #ifdef J9VM_GC_LEAF_BITS\n-\t\tramClass->instanceLeafDescription = storage + shapeSlots;\n-\n-\t\tTrc_VM_calculateInstanceDescription_indirectResult(NULL, storage[0]);\n+\t\t\tramClass->instanceLeafDescription = storage + shapeSlots;\n+#endif\n+\t\t\tTrc_VM_calculateInstanceDescription_indirectResult(NULL, storage[0]);\n+\t\t}\n+\t}\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\telse {\n+\t\tramClass->instanceDescription = (UDATA *)(UDATA)1;\n+#ifdef J9VM_GC_LEAF_BITS\n+\t\tramClass->instanceLeafDescription = (UDATA *)(UDATA)1;\n #endif", "originalCommit": "ec4387b4521eb91fa1c904311aab431765d8a8ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE4MTQ5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r492181491", "bodyText": "Should be if defined", "author": "gacholio", "createdAt": "2020-09-21T16:10:56Z", "path": "runtime/vm/description.c", "diffHunk": "@@ -100,198 +104,208 @@ calculateInstanceDescription( J9VMThread *vmThread, J9Class *ramClass, J9Class *\n \t\tramClass->lockOffset =\twalkState->lockOffset;\n \t\tramClass->finalizeLinkOffset = walkState->finalizeLinkOffset;\n \t}\n-\t\n-\t/* convert all sizes from bytes to object slots */\n-\tsuperClassSize = walkResult->superTotalInstanceSize / referenceSize;\n-\ttotalSize = walkResult->totalInstanceSize / referenceSize;\n-\n-\t/* calculate number of slots required to store description bits */\n-\tshapeSlots = ROUND_UP_TO_POWEROF2(totalSize, slotsPerShapeElement);\n-\tshapeSlots = shapeSlots / slotsPerShapeElement;\n-\n-\t/* pick the space to store the description into */\n-\tif (totalSize < slotsPerShapeElement) {\n-\t\ttemp = 0;\n-\t\tshape = &temp;\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\tleafTemp = 0;\n-\t\tleafShape = &leafTemp;\n-#endif\n-\t} else {\n-\t\t/* this storage will be in the ram class, which is zeroed for us */\n-\t\tshape = storage;\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\tleafShape = storage + shapeSlots;\n-#endif\n-\t}\n-\n-\t/* Copy superclass description */\n-\tif (ramSuperClass) {\n-\t\tif ((UDATA)ramSuperClass->instanceDescription & 1) {\n-\t\t\t/* superclass description is tagged and fits in one slot */\n-\t\t\t*shape = (UDATA)ramSuperClass->instanceDescription >> 1;\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\t\t*leafShape = (UDATA)ramSuperClass->instanceLeafDescription >> 1;\n-#endif\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\tif (hasReferences)\n+#endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n+\t{\n+\t\t/* convert all sizes from bytes to object slots */\n+\t\tsuperClassSize = walkResult->superTotalInstanceSize / referenceSize;\n+\t\ttotalSize = walkResult->totalInstanceSize / referenceSize;\n+\n+\t\t/* calculate number of slots required to store description bits */\n+\t\tshapeSlots = ROUND_UP_TO_POWEROF2(totalSize, slotsPerShapeElement);\n+\t\tshapeSlots = shapeSlots / slotsPerShapeElement;\n+\n+\t\t/* pick the space to store the description into */\n+\t\tif (totalSize < slotsPerShapeElement) {\n+\t\t\ttemp = 0;\n+\t\t\tshape = &temp;\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\tleafTemp = 0;\n+\t\t\tleafShape = &leafTemp;\n+\t#endif\n \t\t} else {\n-\t\t\t/* superclass description is stored indirect */\n-\t\t\tUDATA i, superSlots;\n-\t\t\tsuperSlots = ROUND_UP_TO_POWEROF2(superClassSize, slotsPerShapeElement);\n-\t\t\tsuperSlots = superSlots / slotsPerShapeElement;\n+\t\t\t/* this storage will be in the ram class, which is zeroed for us */\n+\t\t\tshape = storage;\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\tleafShape = storage + shapeSlots;\n+\t#endif\n+\t\t}\n \n-\t\t\tfor (i = 0; i < superSlots; i++) {\n-\t\t\t\tshape[i] = ramSuperClass->instanceDescription[i];\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\t\t\tleafShape[i] = ramSuperClass->instanceLeafDescription[i];\n-#endif\n+\t\t/* Copy superclass description */\n+\t\tif (ramSuperClass) {\n+\t\t\tif ((UDATA)ramSuperClass->instanceDescription & 1) {\n+\t\t\t\t/* superclass description is tagged and fits in one slot */\n+\t\t\t\t*shape = (UDATA)ramSuperClass->instanceDescription >> 1;\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\t\t*leafShape = (UDATA)ramSuperClass->instanceLeafDescription >> 1;\n+\t#endif\n+\t\t\t} else {\n+\t\t\t\t/* superclass description is stored indirect */\n+\t\t\t\tUDATA i, superSlots;\n+\t\t\t\tsuperSlots = ROUND_UP_TO_POWEROF2(superClassSize, slotsPerShapeElement);\n+\t\t\t\tsuperSlots = superSlots / slotsPerShapeElement;\n+\n+\t\t\t\tfor (i = 0; i < superSlots; i++) {\n+\t\t\t\t\tshape[i] = ramSuperClass->instanceDescription[i];\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\t\t\tleafShape[i] = ramSuperClass->instanceLeafDescription[i];\n+\t#endif\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n \n-\t\t/* If there are self referencing field offsets being inherited then self referencing fields of this class should be ignored.*/\n-\t\tif (shouldSaveSelfReferencingFields) {\n-\t\t\tshouldSaveSelfReferencingFields = (ramSuperClass->selfReferencingField1 == 0);\n+\t\t\t/* If there are self referencing field offsets being inherited then self referencing fields of this class should be ignored.*/\n+\t\t\tif (shouldSaveSelfReferencingFields) {\n+\t\t\t\tshouldSaveSelfReferencingFields = (ramSuperClass->selfReferencingField1 == 0);\n+\t\t\t}\n \t\t}\n-\t}\n \n-\t/* calculate the description for this class - walk object instance fields and \n-\t * set the corresponding description bit for each \n-\t */\n-\t{\n-\t\twhile (walkResult->field) {\n-\t\t\tUDATA slotOffset = walkResult->offset / (referenceSize * slotsPerShapeElement);\n-\t\t\tJ9UTF8 *fieldSig = J9ROMFIELDSHAPE_SIGNATURE(walkResult->field);\n-\t\t\tU_8 *fieldSigBytes = J9UTF8_DATA(fieldSig);\n-\t\t\tU_16 fieldSigLength = J9UTF8_LENGTH(fieldSig);\n-\n-\t\t\t/* If the field is self referencing then store the offset to it (at most 2). Self referencing fields\n-\t\t\t * are to be scanned with priority during GC. Both self referencing fields must be from the same class.\n-\t\t\t */\n-\t\t\tif (shouldSaveSelfReferencingFields && ((ramClass->selfReferencingField1 == 0) || (ramClass->selfReferencingField2 == 0))) {\n-\t\t\t\tif (J9UTF8_DATA_EQUALS(J9UTF8_DATA(className), J9UTF8_LENGTH(className), fieldSigBytes + 1, fieldSigLength - 2)) {\n-\t\t\t\t\tif (ramClass->selfReferencingField1 == 0) {\n-\t\t\t\t\t\tramClass->selfReferencingField1 = walkResult->offset + objectHeaderSize;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tramClass->selfReferencingField2 = walkResult->offset + objectHeaderSize;\n+\t\t/* calculate the description for this class - walk object instance fields and\n+\t\t * set the corresponding description bit for each\n+\t\t */\n+\t\t{\n+\t\t\twhile (walkResult->field) {\n+\t\t\t\tUDATA slotOffset = walkResult->offset / (referenceSize * slotsPerShapeElement);\n+\t\t\t\tJ9UTF8 *fieldSig = J9ROMFIELDSHAPE_SIGNATURE(walkResult->field);\n+\t\t\t\tU_8 *fieldSigBytes = J9UTF8_DATA(fieldSig);\n+\t\t\t\tU_16 fieldSigLength = J9UTF8_LENGTH(fieldSig);\n+\n+\t\t\t\t/* If the field is self referencing then store the offset to it (at most 2). Self referencing fields\n+\t\t\t\t * are to be scanned with priority during GC. Both self referencing fields must be from the same class.\n+\t\t\t\t */\n+\t\t\t\tif (shouldSaveSelfReferencingFields && ((ramClass->selfReferencingField1 == 0) || (ramClass->selfReferencingField2 == 0))) {\n+\t\t\t\t\tif (J9UTF8_DATA_EQUALS(J9UTF8_DATA(className), J9UTF8_LENGTH(className), fieldSigBytes + 1, fieldSigLength - 2)) {\n+\t\t\t\t\t\tif (ramClass->selfReferencingField1 == 0) {\n+\t\t\t\t\t\t\tramClass->selfReferencingField1 = walkResult->offset + objectHeaderSize;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tramClass->selfReferencingField2 = walkResult->offset + objectHeaderSize;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t}\n \n #ifdef J9VM_OPT_VALHALLA_VALUE_TYPES\n-\t\t\tif ('Q' == *fieldSigBytes) {\n-\t\t\t\tJ9Class *fieldClass = walkResult->flattenedClass;\n-\t\t\t\tif ((NULL != fieldClass) && J9_ARE_ALL_BITS_SET(fieldClass->classFlags, J9ClassIsFlattened)) {\n-\t\t\t\t\tUDATA size = fieldClass->totalInstanceSize;\n-\n-\t\t\t\t\t/* positive means the field will spill over to the next slot in the shape array */\n-\t\t\t\t\tIDATA spillAmount = ((walkResult->offset + size) - (slotOffset * (referenceSize * slotsPerShapeElement))) - (referenceSize * slotsPerShapeElement);\n-\t\t\t\t\tUDATA shift = ((walkResult->offset  % (referenceSize * slotsPerShapeElement)) / referenceSize);\n-\t\t\t\t\tif (0 >= spillAmount) {\n-\t\t\t\t\t\t/* If we are here this means the description bits for the field fits within the current\n-\t\t\t\t\t\t * slot shape word. This also means they are all low tagged.\n-\t\t\t\t\t\t */\n-\t\t\t\t\t\tUDATA bits = 0;\n-\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n-\n-\t\t\t\t\t\t/* remove low tag bit */\n-\t\t\t\t\t\tdescription >>= 1;\n-\t\t\t\t\t\tbits = (UDATA) description << shift;\n-\t\t\t\t\t\tshape[slotOffset] |= bits;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n-\n-\t\t\t\t\t\tif (J9_ARE_ALL_BITS_SET(description, 1)) {\n-\t\t\t\t\t\t\t/* simple case where the field has less than 64 (or 32 slots if in 32bit mode) slots. Split the instance\n-\t\t\t\t\t\t\t * bits into two parts, put the first part at the current slot offset put the last part in the next one */\n-\t\t\t\t\t\t\tUDATA nextDescription = 0;\n-\t\t\t\t\t\t\tUDATA spillBits = spillAmount/referenceSize;\n+\t\t\t\tif ('Q' == *fieldSigBytes) {\n+\t\t\t\t\tJ9Class *fieldClass = walkResult->flattenedClass;\n+\t\t\t\t\tif ((NULL != fieldClass) && J9_ARE_ALL_BITS_SET(fieldClass->classFlags, J9ClassIsFlattened)) {\n+\t\t\t\t\t\tUDATA size = fieldClass->totalInstanceSize;\n+\n+\t\t\t\t\t\t/* positive means the field will spill over to the next slot in the shape array */\n+\t\t\t\t\t\tIDATA spillAmount = ((walkResult->offset + size) - (slotOffset * (referenceSize * slotsPerShapeElement))) - (referenceSize * slotsPerShapeElement);\n+\t\t\t\t\t\tUDATA shift = ((walkResult->offset  % (referenceSize * slotsPerShapeElement)) / referenceSize);\n+\t\t\t\t\t\tif (0 >= spillAmount) {\n+\t\t\t\t\t\t\t/* If we are here this means the description bits for the field fits within the current\n+\t\t\t\t\t\t\t * slot shape word. This also means they are all low tagged.\n+\t\t\t\t\t\t\t */\n+\t\t\t\t\t\t\tUDATA bits = 0;\n+\t\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n \n \t\t\t\t\t\t\t/* remove low tag bit */\n \t\t\t\t\t\t\tdescription >>= 1;\n-\n-\t\t\t\t\t\t\tnextDescription = description;\n-\t\t\t\t\t\t\tnextDescription >>= ((size/referenceSize) - spillBits);\n-\t\t\t\t\t\t\tdescription <<= shift;\n-\t\t\t\t\t\t\tshape[slotOffset] |= description;\n-\t\t\t\t\t\t\tslotOffset += 1;\n-\t\t\t\t\t\t\tshape[slotOffset] |= nextDescription;\n+\t\t\t\t\t\t\tbits = (UDATA) description << shift;\n+\t\t\t\t\t\t\tshape[slotOffset] |= bits;\n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t/* complex case were field is larger than 64 slots. Just add the bits\n-\t\t\t\t\t\t\t * one at a time. */\n-\t\t\t\t\t\t\tUDATA *descriptionPtr = (UDATA *)description;\n-\t\t\t\t\t\t\tUDATA totalAmountLeft = size/referenceSize;\n-\t\t\t\t\t\t\tUDATA positionInDescriptionWord = 0;\n-\t\t\t\t\t\t\tUDATA bitsLeftInShapeSlot = slotsPerShapeElement - shift;\n-\n-\t\t\t\t\t\t\tdescription = *descriptionPtr;\n-\t\t\t\t\t\t\tdescriptionPtr += 1;\n-\n-\t\t\t\t\t\t\twhile (totalAmountLeft > 0) {\n-\t\t\t\t\t\t\t\tshape[slotOffset] |= (1 & description) << (slotsPerShapeElement - bitsLeftInShapeSlot);\n-\t\t\t\t\t\t\t\tdescription >>= 1;\n-\t\t\t\t\t\t\t\tpositionInDescriptionWord++;\n+\t\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n \n-\t\t\t\t\t\t\t\tif (slotsPerShapeElement == positionInDescriptionWord) {\n-\t\t\t\t\t\t\t\t\tdescription = *descriptionPtr;\n-\t\t\t\t\t\t\t\t\tdescriptionPtr += 1;\n-\t\t\t\t\t\t\t\t\tpositionInDescriptionWord = 0;\n-\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (J9_ARE_ALL_BITS_SET(description, 1)) {\n+\t\t\t\t\t\t\t\t/* simple case where the field has less than 64 (or 32 slots if in 32bit mode) slots. Split the instance\n+\t\t\t\t\t\t\t\t * bits into two parts, put the first part at the current slot offset put the last part in the next one */\n+\t\t\t\t\t\t\t\tUDATA nextDescription = 0;\n+\t\t\t\t\t\t\t\tUDATA spillBits = spillAmount/referenceSize;\n+\n+\t\t\t\t\t\t\t\t/* remove low tag bit */\n+\t\t\t\t\t\t\t\tdescription >>= 1;\n \n-\t\t\t\t\t\t\t\tbitsLeftInShapeSlot--;\n-\t\t\t\t\t\t\t\tif (0 == bitsLeftInShapeSlot) {\n-\t\t\t\t\t\t\t\t\tslotOffset++;\n-\t\t\t\t\t\t\t\t\tbitsLeftInShapeSlot = 64;\n+\t\t\t\t\t\t\t\tnextDescription = description;\n+\t\t\t\t\t\t\t\tnextDescription >>= ((size/referenceSize) - spillBits);\n+\t\t\t\t\t\t\t\tdescription <<= shift;\n+\t\t\t\t\t\t\t\tshape[slotOffset] |= description;\n+\t\t\t\t\t\t\t\tslotOffset += 1;\n+\t\t\t\t\t\t\t\tshape[slotOffset] |= nextDescription;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t/* complex case were field is larger than 64 slots. Just add the bits\n+\t\t\t\t\t\t\t\t * one at a time. */\n+\t\t\t\t\t\t\t\tUDATA *descriptionPtr = (UDATA *)description;\n+\t\t\t\t\t\t\t\tUDATA totalAmountLeft = size/referenceSize;\n+\t\t\t\t\t\t\t\tUDATA positionInDescriptionWord = 0;\n+\t\t\t\t\t\t\t\tUDATA bitsLeftInShapeSlot = slotsPerShapeElement - shift;\n+\n+\t\t\t\t\t\t\t\tdescription = *descriptionPtr;\n+\t\t\t\t\t\t\t\tdescriptionPtr += 1;\n+\n+\t\t\t\t\t\t\t\twhile (totalAmountLeft > 0) {\n+\t\t\t\t\t\t\t\t\tshape[slotOffset] |= (1 & description) << (slotsPerShapeElement - bitsLeftInShapeSlot);\n+\t\t\t\t\t\t\t\t\tdescription >>= 1;\n+\t\t\t\t\t\t\t\t\tpositionInDescriptionWord++;\n+\n+\t\t\t\t\t\t\t\t\tif (slotsPerShapeElement == positionInDescriptionWord) {\n+\t\t\t\t\t\t\t\t\t\tdescription = *descriptionPtr;\n+\t\t\t\t\t\t\t\t\t\tdescriptionPtr += 1;\n+\t\t\t\t\t\t\t\t\t\tpositionInDescriptionWord = 0;\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\tbitsLeftInShapeSlot--;\n+\t\t\t\t\t\t\t\t\tif (0 == bitsLeftInShapeSlot) {\n+\t\t\t\t\t\t\t\t\t\tslotOffset++;\n+\t\t\t\t\t\t\t\t\t\tbitsLeftInShapeSlot = 64;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\ttotalAmountLeft--;\n \t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\ttotalAmountLeft--;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tUDATA bit = (UDATA)1 << ((walkResult->offset % (referenceSize * slotsPerShapeElement)) / referenceSize);\n+\t\t\t\t\t\tshape[slotOffset] |= bit;\n \t\t\t\t\t}\n-\t\t\t\t} else {\n+\t\t\t\t} else\n+#endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n+\t\t\t\t{\n \t\t\t\t\tUDATA bit = (UDATA)1 << ((walkResult->offset % (referenceSize * slotsPerShapeElement)) / referenceSize);\n \t\t\t\t\tshape[slotOffset] |= bit;\n-\t\t\t\t}\n-\t\t\t} else\n-#endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n-\t\t\t{\n-\t\t\t\tUDATA bit = (UDATA)1 << ((walkResult->offset % (referenceSize * slotsPerShapeElement)) / referenceSize);\n-\t\t\t\tshape[slotOffset] |= bit;\n #ifdef J9VM_GC_LEAF_BITS\n-\t\t\t\tif (isLeafField(walkResult->field)) {\n-\t\t\t\t\tleafShape[slotOffset] |= bit;\n-\t\t\t\t} else if (isString) {\n-\t\t\t\t\tJ9UTF8 *fieldName = J9ROMFIELDSHAPE_NAME(walkResult->field);\n-\n-\t\t\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(fieldName), J9UTF8_LENGTH(fieldName), \"value\")) {\n+\t\t\t\t\tif (isLeafField(walkResult->field)) {\n \t\t\t\t\t\tleafShape[slotOffset] |= bit;\n+\t\t\t\t\t} else if (isString) {\n+\t\t\t\t\t\tJ9UTF8 *fieldName = J9ROMFIELDSHAPE_NAME(walkResult->field);\n+\n+\t\t\t\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(fieldName), J9UTF8_LENGTH(fieldName), \"value\")) {\n+\t\t\t\t\t\t\tleafShape[slotOffset] |= bit;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t}\n #endif\n-\t\t\t}\n+\t\t\t\t}\n \n-\t\t\twalkResult = fieldOffsetsNextDo(walkState);\n+\t\t\t\twalkResult = fieldOffsetsNextDo(walkState);\n+\t\t\t}\n \t\t}\n-\t}\n \n-\tif (totalSize < slotsPerShapeElement) {\n-\t\t/* tag low bit, store in place */\n-\t\ttemp <<= 1;\n-\t\ttemp |= 1;\n-\t\tramClass->instanceDescription = (UDATA *)temp;\n+\t\tif (totalSize < slotsPerShapeElement) {\n+\t\t\t/* tag low bit, store in place */\n+\t\t\ttemp <<= 1;\n+\t\t\ttemp |= 1;\n+\t\t\tramClass->instanceDescription = (UDATA *)temp;\n #ifdef J9VM_GC_LEAF_BITS\n-\t\tleafTemp <<= 1;\n-\t\tleafTemp |= 1;\n-\t\tramClass->instanceLeafDescription = (UDATA *)leafTemp;\n+\t\t\tleafTemp <<= 1;\n+\t\t\tleafTemp |= 1;\n+\t\t\tramClass->instanceLeafDescription = (UDATA *)leafTemp;\n #endif\n-\n-\t\tTrc_VM_calculateInstanceDescription_taggedResult(NULL, temp);\n-\t} else {\n-\t\t/* used extra space, store the address */\n-\t\tramClass->instanceDescription = storage;\n+\t\t\tTrc_VM_calculateInstanceDescription_taggedResult(NULL, temp);\n+\t\t} else {\n+\t\t\t/* used extra space, store the address */\n+\t\t\tramClass->instanceDescription = storage;\n #ifdef J9VM_GC_LEAF_BITS\n-\t\tramClass->instanceLeafDescription = storage + shapeSlots;\n-\n-\t\tTrc_VM_calculateInstanceDescription_indirectResult(NULL, storage[0]);\n+\t\t\tramClass->instanceLeafDescription = storage + shapeSlots;\n+#endif\n+\t\t\tTrc_VM_calculateInstanceDescription_indirectResult(NULL, storage[0]);\n+\t\t}\n+\t}\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\telse {\n+\t\tramClass->instanceDescription = (UDATA *)(UDATA)1;\n+#ifdef J9VM_GC_LEAF_BITS", "originalCommit": "ec4387b4521eb91fa1c904311aab431765d8a8ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgxNjE5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r492816194", "bodyText": "This check is not needed here, and in fact is more future proof to not have it. Also we may for example have a (non-GC functional) barrier that profiles accesses for primitive types.", "author": "amicic", "createdAt": "2020-09-22T15:11:56Z", "path": "runtime/gc_include/ObjectAccessBarrierAPI.hpp", "diffHunk": "@@ -436,10 +436,13 @@ class MM_ObjectAccessBarrierAPI\n \tVMINLINE void\n \tcopyObjectFields(J9VMThread *vmThread, J9Class *objectClass, j9object_t srcObject, UDATA srcOffset, j9object_t destObject, UDATA destOffset)\n \t{\n+\t\tbool hasReferences = J9CLASS_HAS_REFERENCES(objectClass);\n #if defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER)\n-\t\tvmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_copyObjectFields(vmThread, objectClass, srcObject, srcOffset, destObject, destOffset);\n-#else /* defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER) */\n-\t\tif (j9gc_modron_readbar_none != _readBarrierType) {\t\n+\t\tif (hasReferences) {", "originalCommit": "ec4387b4521eb91fa1c904311aab431765d8a8ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyNDI1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r492824251", "bodyText": "@RSalman This needs to be fixed eventually. This path should not be allowed if WB type is SATB.", "author": "amicic", "createdAt": "2020-09-22T15:20:48Z", "path": "runtime/gc_include/ObjectAccessBarrierAPI.hpp", "diffHunk": "@@ -436,10 +436,13 @@ class MM_ObjectAccessBarrierAPI\n \tVMINLINE void\n \tcopyObjectFields(J9VMThread *vmThread, J9Class *objectClass, j9object_t srcObject, UDATA srcOffset, j9object_t destObject, UDATA destOffset)\n \t{\n+\t\tbool hasReferences = J9CLASS_HAS_REFERENCES(objectClass);\n #if defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER)\n-\t\tvmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_copyObjectFields(vmThread, objectClass, srcObject, srcOffset, destObject, destOffset);\n-#else /* defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER) */\n-\t\tif (j9gc_modron_readbar_none != _readBarrierType) {\t\n+\t\tif (hasReferences) {\n+\t\t\tvmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_copyObjectFields(vmThread, objectClass, srcObject, srcOffset, destObject, destOffset);\n+\t\t} else\n+#endif /* defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER) */\n+\t\tif (hasReferences && (j9gc_modron_readbar_none != _readBarrierType)) {\n \t\t\tvmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_copyObjectFields(vmThread, objectClass, srcObject, srcOffset, destObject, destOffset);\n \t\t} else {\n \t\t\tUDATA offset = 0;", "originalCommit": "ec4387b4521eb91fa1c904311aab431765d8a8ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg3MzQxMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r492873413", "bodyText": "Noted to address this as part of SATB work", "author": "RSalman", "createdAt": "2020-09-22T16:27:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyNDI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzODI4Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r492838286", "bodyText": "I'm on a fence even if hasReferences is needed here, but let's leave it.\nHowever, the check was not quite complete. It was missing  '.... || (j9gc_modron_wrtbar_always == _writeBarrierType)' (see how we treat stores)\nPlease, fix it while here.", "author": "amicic", "createdAt": "2020-09-22T15:38:22Z", "path": "runtime/gc_include/ObjectAccessBarrierAPI.hpp", "diffHunk": "@@ -436,10 +436,13 @@ class MM_ObjectAccessBarrierAPI\n \tVMINLINE void\n \tcopyObjectFields(J9VMThread *vmThread, J9Class *objectClass, j9object_t srcObject, UDATA srcOffset, j9object_t destObject, UDATA destOffset)\n \t{\n+\t\tbool hasReferences = J9CLASS_HAS_REFERENCES(objectClass);\n #if defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER)\n-\t\tvmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_copyObjectFields(vmThread, objectClass, srcObject, srcOffset, destObject, destOffset);\n-#else /* defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER) */\n-\t\tif (j9gc_modron_readbar_none != _readBarrierType) {\t\n+\t\tif (hasReferences) {\n+\t\t\tvmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_copyObjectFields(vmThread, objectClass, srcObject, srcOffset, destObject, destOffset);\n+\t\t} else\n+#endif /* defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER) */\n+\t\tif (hasReferences && (j9gc_modron_readbar_none != _readBarrierType)) {", "originalCommit": "ec4387b4521eb91fa1c904311aab431765d8a8ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6400d7cf4ab6fd04c0357770aa6049019eb1c204", "url": "https://github.com/eclipse-openj9/openj9/commit/6400d7cf4ab6fd04c0357770aa6049019eb1c204", "message": "Introduce instanceHasRefs flag\n\nThere is an issue with instance description bits with respect to\nflattened types. See https://github.com/eclipse/openj9/issues/10070.\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs mode. The `backfill` has been\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs mode) has at least one single slot or ref field\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nThis PR is the first step in solving this problem. This PR introduces a\nflag on the J9Class that indicates whether the type has instances field\nwhich are references. In these cases the barrier API for copying\ninstance fields doesn't need to scan the instance description bits to\napply barrier loads/stores. It can simply use a slot sized load/store\nfor the operation.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-09-29T20:23:21Z", "type": "forcePushed"}, {"oid": "d713fee1a46ddbc254ec306bfbeeaebdfa749c8b", "url": "https://github.com/eclipse-openj9/openj9/commit/d713fee1a46ddbc254ec306bfbeeaebdfa749c8b", "message": "Introduce instanceHasRefs flag\n\nThere is an issue with instance description bits with respect to\nflattened types. See https://github.com/eclipse/openj9/issues/10070.\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs mode. The `backfill` has been\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs mode) has at least one single slot or ref field\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nThis PR is the first step in solving this problem. This PR introduces a\nflag on the J9Class that indicates whether the type has instances field\nwhich are references. In these cases the barrier API for copying\ninstance fields doesn't need to scan the instance description bits to\napply barrier loads/stores. It can simply use a slot sized load/store\nfor the operation.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-09-29T20:32:30Z", "type": "forcePushed"}, {"oid": "5ce7cabced1017728f76cbe145d5b26f835afa95", "url": "https://github.com/eclipse-openj9/openj9/commit/5ce7cabced1017728f76cbe145d5b26f835afa95", "message": "Introduce instanceHasRefs flag\n\nThere is an issue with instance description bits with respect to\nflattened types. See https://github.com/eclipse/openj9/issues/10070.\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs mode. The `backfill` has been\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs mode) has at least one single slot or ref field\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nThis PR is the first step in solving this problem. This PR introduces a\nflag on the J9Class that indicates whether the type has instances field\nwhich are references. In these cases the barrier API for copying\ninstance fields doesn't need to scan the instance description bits to\napply barrier loads/stores. It can simply use a slot sized load/store\nfor the operation.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-09-29T20:40:35Z", "type": "forcePushed"}, {"oid": "7b860d09a1f2584ca842127eaed7709ca820c985", "url": "https://github.com/eclipse-openj9/openj9/commit/7b860d09a1f2584ca842127eaed7709ca820c985", "message": "Introduce instanceHasRefs flag\n\nThere is an issue with instance description bits with respect to\nflattened types. See https://github.com/eclipse/openj9/issues/10070.\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs mode. The `backfill` has been\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs mode) has at least one single slot or ref field\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nThis PR is the first step in solving this problem. This PR introduces a\nflag on the J9Class that indicates whether the type has instances field\nwhich are references. In these cases the barrier API for copying\ninstance fields doesn't need to scan the instance description bits to\napply barrier loads/stores. It can simply use a slot sized load/store\nfor the operation.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-09-29T20:44:41Z", "type": "forcePushed"}, {"oid": "0058787a43610bbe517af08c305f72f8206e9f49", "url": "https://github.com/eclipse-openj9/openj9/commit/0058787a43610bbe517af08c305f72f8206e9f49", "message": "Introduce instanceHasRefs flag\n\nThere is an issue with instance description bits with respect to\nflattened types. See https://github.com/eclipse/openj9/issues/10070.\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs mode. The `backfill` has been\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs mode) has at least one single slot or ref field\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nThis PR is the first step in solving this problem. This PR introduces a\nflag on the J9Class that indicates whether the type has instances field\nwhich are references. In these cases the barrier API for copying\ninstance fields doesn't need to scan the instance description bits to\napply barrier loads/stores. It can simply use a slot sized load/store\nfor the operation.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-09-29T21:01:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4NDAyOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r497584029", "bodyText": "Space after if.", "author": "gacholio", "createdAt": "2020-09-30T15:04:19Z", "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "diffHunk": "@@ -1393,52 +1393,72 @@ BOOLEAN\n MM_ObjectAccessBarrier::structuralCompareFlattenedObjects(J9VMThread *vmThread, J9Class *valueClass, j9object_t lhsObject, j9object_t rhsObject, UDATA startOffset)\n {\n \tbool result = true;\n-\tconst UDATA *descriptionPtr = (UDATA *) valueClass->instanceDescription;\n-\tUDATA descriptionBits = 0;\n \tbool const compressed = J9VMTHREAD_COMPRESS_OBJECT_REFERENCES(vmThread);\n \tUDATA const referenceSize = J9VMTHREAD_REFERENCE_SIZE(vmThread);\n+\tbool hasReferences = J9CLASS_HAS_REFERENCES(valueClass);\n+\tUDATA limit = valueClass->totalInstanceSize;\n+\tU_32 firstFieldOffset = (U_32) valueClass->backfillOffset;\n+\tUDATA offset = 0;\n \n \tAssert_MM_true(J9_IS_J9CLASS_VALUETYPE(valueClass));\n \n-\tif(((UDATA)descriptionPtr) & 1) {\n-\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n-\t} else {\n-\t\tdescriptionBits = *descriptionPtr++;\n-\t}\n+\tif (hasReferences) {\n+\t\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n+\t\tconst UDATA *descriptionPtr = (UDATA *) valueClass->instanceDescription;\n+\t\tUDATA descriptionBits = 0;\n \n-\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n-\tUDATA offset = 0;\n-\tUDATA limit = valueClass->totalInstanceSize;\n+\t\tif (0 != firstFieldOffset) {\n+\t\t\t/* subtract padding */\n+\t\t\toffset += firstFieldOffset;\n+\t\t\tdescriptionBits >>= 1;\n+\t\t\tdescriptionIndex -= 1;\n+\t\t}\n \n-\tU_32 firstFieldOffset = (U_32) valueClass->backfillOffset;\n-\tif (0 != firstFieldOffset) {\n-\t\t/* subtract padding */\n-\t\toffset += firstFieldOffset;\n-\t\tdescriptionBits >>= 1;\n-\t\tdescriptionIndex -= 1;\n-\t}\n+\t\tif(((UDATA)descriptionPtr) & 1) {\n+\t\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n+\t\t} else {\n+\t\t\tdescriptionBits = *descriptionPtr++;\n+\t\t}\n \n-\twhile (offset < limit) {\n-\t\t/* Determine if the slot contains an object pointer or not */\n-\t\tif(descriptionBits & 1) {\n-\t\t\tif (mixedObjectReadObject(vmThread, lhsObject, startOffset + offset, false) != mixedObjectReadObject(vmThread, rhsObject, startOffset + offset, false)) {\n-\t\t\t\tresult = false;\n-\t\t\t\tbreak;\n+\n+\t\twhile (offset < limit) {\n+\t\t\t/* Determine if the slot contains an object pointer or not */\n+\t\t\tif(descriptionBits & 1) {", "originalCommit": "0058787a43610bbe517af08c305f72f8206e9f49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4NTUxNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r497585514", "bodyText": "I'll withdraw these as they appeared in the original code.", "author": "gacholio", "createdAt": "2020-09-30T15:06:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4NDAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4NDE3Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r497584172", "bodyText": "Space after if", "author": "gacholio", "createdAt": "2020-09-30T15:04:29Z", "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "diffHunk": "@@ -1393,52 +1393,72 @@ BOOLEAN\n MM_ObjectAccessBarrier::structuralCompareFlattenedObjects(J9VMThread *vmThread, J9Class *valueClass, j9object_t lhsObject, j9object_t rhsObject, UDATA startOffset)\n {\n \tbool result = true;\n-\tconst UDATA *descriptionPtr = (UDATA *) valueClass->instanceDescription;\n-\tUDATA descriptionBits = 0;\n \tbool const compressed = J9VMTHREAD_COMPRESS_OBJECT_REFERENCES(vmThread);\n \tUDATA const referenceSize = J9VMTHREAD_REFERENCE_SIZE(vmThread);\n+\tbool hasReferences = J9CLASS_HAS_REFERENCES(valueClass);\n+\tUDATA limit = valueClass->totalInstanceSize;\n+\tU_32 firstFieldOffset = (U_32) valueClass->backfillOffset;\n+\tUDATA offset = 0;\n \n \tAssert_MM_true(J9_IS_J9CLASS_VALUETYPE(valueClass));\n \n-\tif(((UDATA)descriptionPtr) & 1) {\n-\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n-\t} else {\n-\t\tdescriptionBits = *descriptionPtr++;\n-\t}\n+\tif (hasReferences) {\n+\t\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n+\t\tconst UDATA *descriptionPtr = (UDATA *) valueClass->instanceDescription;\n+\t\tUDATA descriptionBits = 0;\n \n-\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n-\tUDATA offset = 0;\n-\tUDATA limit = valueClass->totalInstanceSize;\n+\t\tif (0 != firstFieldOffset) {\n+\t\t\t/* subtract padding */\n+\t\t\toffset += firstFieldOffset;\n+\t\t\tdescriptionBits >>= 1;\n+\t\t\tdescriptionIndex -= 1;\n+\t\t}\n \n-\tU_32 firstFieldOffset = (U_32) valueClass->backfillOffset;\n-\tif (0 != firstFieldOffset) {\n-\t\t/* subtract padding */\n-\t\toffset += firstFieldOffset;\n-\t\tdescriptionBits >>= 1;\n-\t\tdescriptionIndex -= 1;\n-\t}\n+\t\tif(((UDATA)descriptionPtr) & 1) {\n+\t\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n+\t\t} else {\n+\t\t\tdescriptionBits = *descriptionPtr++;\n+\t\t}\n \n-\twhile (offset < limit) {\n-\t\t/* Determine if the slot contains an object pointer or not */\n-\t\tif(descriptionBits & 1) {\n-\t\t\tif (mixedObjectReadObject(vmThread, lhsObject, startOffset + offset, false) != mixedObjectReadObject(vmThread, rhsObject, startOffset + offset, false)) {\n-\t\t\t\tresult = false;\n-\t\t\t\tbreak;\n+\n+\t\twhile (offset < limit) {\n+\t\t\t/* Determine if the slot contains an object pointer or not */\n+\t\t\tif(descriptionBits & 1) {\n+\t\t\t\tif (mixedObjectReadObject(vmThread, lhsObject, startOffset + offset, false) != mixedObjectReadObject(vmThread, rhsObject, startOffset + offset, false)) {\n+\t\t\t\t\tresult = false;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfomrobject_t lhsValue = GC_SlotObject::readSlot((fomrobject_t*)((UDATA)lhsObject + startOffset + offset), compressed);\n+\t\t\t\tfomrobject_t rhsValue = GC_SlotObject::readSlot((fomrobject_t*)((UDATA)rhsObject + startOffset + offset), compressed);\n+\t\t\t\tif (lhsValue != rhsValue) {\n+\t\t\t\t\tresult = false;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t}\n-\t\t} else {\n+\t\t\tdescriptionBits >>= 1;\n+\t\t\tif(descriptionIndex-- == 0) {", "originalCommit": "0058787a43610bbe517af08c305f72f8206e9f49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4NDQ2Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r497584466", "bodyText": "Space after if", "author": "gacholio", "createdAt": "2020-09-30T15:04:51Z", "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "diffHunk": "@@ -1481,49 +1501,70 @@ MM_ObjectAccessBarrier::copyObjectFields(J9VMThread *vmThread, J9Class *objectCl\n \t\t}\n \t}\n \n-\tconst UDATA *descriptionPtr = (UDATA *) objectClass->instanceDescription;\n-\tUDATA descriptionBits = 0;\n-\tif(((UDATA)descriptionPtr) & 1) {\n-\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n-\t} else {\n-\t\tdescriptionBits = *descriptionPtr++;\n-\t}\n-\n-\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n \tUDATA offset = 0;\n \tUDATA limit = objectClass->totalInstanceSize;\n \tUDATA const referenceSize = J9VMTHREAD_REFERENCE_SIZE(vmThread);\n+\tbool hasReferences = J9CLASS_HAS_REFERENCES(objectClass);\n+\tU_32 firstFieldOffset = (U_32) objectClass->backfillOffset;\n+\n+\tif (hasReferences) {\n+\t\tconst UDATA *descriptionPtr = (UDATA *) objectClass->instanceDescription;\n+\t\tUDATA descriptionBits = 0;\n+\t\tif(((UDATA)descriptionPtr) & 1) {", "originalCommit": "0058787a43610bbe517af08c305f72f8206e9f49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU5MzM5OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r497593398", "bodyText": "There's no need for the zero check here (and elsewhere this pattern appears).", "author": "gacholio", "createdAt": "2020-09-30T15:16:23Z", "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "diffHunk": "@@ -1481,49 +1501,70 @@ MM_ObjectAccessBarrier::copyObjectFields(J9VMThread *vmThread, J9Class *objectCl\n \t\t}\n \t}\n \n-\tconst UDATA *descriptionPtr = (UDATA *) objectClass->instanceDescription;\n-\tUDATA descriptionBits = 0;\n-\tif(((UDATA)descriptionPtr) & 1) {\n-\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n-\t} else {\n-\t\tdescriptionBits = *descriptionPtr++;\n-\t}\n-\n-\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n \tUDATA offset = 0;\n \tUDATA limit = objectClass->totalInstanceSize;\n \tUDATA const referenceSize = J9VMTHREAD_REFERENCE_SIZE(vmThread);\n+\tbool hasReferences = J9CLASS_HAS_REFERENCES(objectClass);\n+\tU_32 firstFieldOffset = (U_32) objectClass->backfillOffset;\n+\n+\tif (hasReferences) {\n+\t\tconst UDATA *descriptionPtr = (UDATA *) objectClass->instanceDescription;\n+\t\tUDATA descriptionBits = 0;\n+\t\tif(((UDATA)descriptionPtr) & 1) {\n+\t\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n+\t\t} else {\n+\t\t\tdescriptionBits = *descriptionPtr++;\n+\t\t}\n \n-\tif (isValueType) {\n-\t\tU_32 firstFieldOffset = (U_32) objectClass->backfillOffset;\n-\t\tif (0 != firstFieldOffset) {\n-\t\t\t/* subtract padding */\n-\t\t\toffset += firstFieldOffset;\n-\t\t\tdescriptionBits >>= 1;\n-\t\t\tdescriptionIndex -= 1;\n+\t\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n+\n+\t\tif (isValueType) {\n+\t\t\tif (0 != firstFieldOffset) {\n+\t\t\t\t/* subtract padding */\n+\t\t\t\toffset += firstFieldOffset;\n+\t\t\t\tdescriptionBits >>= 1;\n+\t\t\t\tdescriptionIndex -= 1;\n+\t\t\t}\n \t\t}\n-\t}\n \n-\twhile (offset < limit) {\n-\t\t/* Determine if the slot contains an object pointer or not */\n-\t\tif(descriptionBits & 1) {\n-\t\t\tJ9Object *objectPtr = mixedObjectReadObject(vmThread, srcObject, srcOffset + offset, false);\n-\t\t\tmixedObjectStoreObject(vmThread, destObject, destOffset + offset, objectPtr, false);\n-\t\t} else {\n+\t\twhile (offset < limit) {\n+\t\t\t/* Determine if the slot contains an object pointer or not */\n+\t\t\tif(descriptionBits & 1) {\n+\t\t\t\tJ9Object *objectPtr = mixedObjectReadObject(vmThread, srcObject, srcOffset + offset, false);\n+\t\t\t\tmixedObjectStoreObject(vmThread, destObject, destOffset + offset, objectPtr, false);\n+\t\t\t} else {\n+\t\t\t\tUDATA srcAddress = (UDATA)srcObject + srcOffset + offset;\n+\t\t\t\tUDATA destAddress = (UDATA)destObject + destOffset + offset;\n+\t\t\t\tif (sizeof(uint32_t) == referenceSize) {\n+\t\t\t\t\t*(uint32_t *)destAddress = *(uint32_t *)srcAddress;\n+\t\t\t\t} else {\n+\t\t\t\t\t*(uintptr_t *)destAddress = *(uintptr_t *)srcAddress;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tdescriptionBits >>= 1;\n+\t\t\tif(descriptionIndex-- == 0) {\n+\t\t\t\tdescriptionBits = *descriptionPtr++;\n+\t\t\t\tdescriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n+\t\t\t}\n+\t\t\toffset += referenceSize;\n+\t\t}\n+\t} else {\n+\t\t/* no instanceDescription bits needed on this path */\n+\t\tif (isValueType) {\n+\t\t\tif (0 != firstFieldOffset) {", "originalCommit": "0058787a43610bbe517af08c305f72f8206e9f49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0NTA2Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r498845066", "bodyText": "We are currently using firstFieldOffset to indicate the presence of pre-padding in valuetypes. If this check is skipped then the instance description bits will be misalligned in the flattened representation (since pre-padding is removed in these cases).\nI plan to address this in the next PR.", "author": "tajila", "createdAt": "2020-10-02T14:08:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU5MzM5OA=="}], "type": "inlineReview"}, {"oid": "7f96afd5cdcf128f1cfad439d9b6ffeff9f067b4", "url": "https://github.com/eclipse-openj9/openj9/commit/7f96afd5cdcf128f1cfad439d9b6ffeff9f067b4", "message": "Introduce instanceHasRefs flag\n\nThere is an issue with instance description bits with respect to\nflattened types. See https://github.com/eclipse/openj9/issues/10070.\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs mode. The `backfill` has been\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs mode) has at least one single slot or ref field\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nThis PR is the first step in solving this problem. This PR introduces a\nflag on the J9Class that indicates whether the type has instances field\nwhich are references. In these cases the barrier API for copying\ninstance fields doesn't need to scan the instance description bits to\napply barrier loads/stores. It can simply use a slot sized load/store\nfor the operation.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-10-02T14:10:08Z", "type": "forcePushed"}, {"oid": "e202257664e8cf8337b5fd774f66deb9805bdcc3", "url": "https://github.com/eclipse-openj9/openj9/commit/e202257664e8cf8337b5fd774f66deb9805bdcc3", "message": "Introduce instanceHasRefs flag\n\nThere is an issue with instance description bits with respect to\nflattened types. See https://github.com/eclipse/openj9/issues/10070.\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs mode. The `backfill` has been\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs mode) has at least one single slot or ref field\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nThis PR is the first step in solving this problem. This PR introduces a\nflag on the J9Class that indicates whether the type has instances field\nwhich are references. In these cases the barrier API for copying\ninstance fields doesn't need to scan the instance description bits to\napply barrier loads/stores. It can simply use a slot sized load/store\nfor the operation.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-10-02T14:13:10Z", "type": "forcePushed"}, {"oid": "def719af0a23150da8c8694399f04b981d79699b", "url": "https://github.com/eclipse-openj9/openj9/commit/def719af0a23150da8c8694399f04b981d79699b", "message": "Introduce instanceHasRefs flag\n\nThere is an issue with instance description bits with respect to\nflattened types. See https://github.com/eclipse/openj9/issues/10070.\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs mode. The `backfill` has been\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs mode) has at least one single slot or ref field\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nThis PR is the first step in solving this problem. This PR introduces a\nflag on the J9Class that indicates whether the type has instances field\nwhich are references. In these cases the barrier API for copying\ninstance fields doesn't need to scan the instance description bits to\napply barrier loads/stores. It can simply use a slot sized load/store\nfor the operation.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-10-02T17:04:32Z", "type": "forcePushed"}, {"oid": "812ac569da026ea40bfac1d901c4fb907bb443f5", "url": "https://github.com/eclipse-openj9/openj9/commit/812ac569da026ea40bfac1d901c4fb907bb443f5", "message": "Introduce instanceHasRefs flag\n\nThere is an issue with instance description bits with respect to\nflattened types. See https://github.com/eclipse/openj9/issues/10070.\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs mode. The `backfill` has been\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs mode) has at least one single slot or ref field\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nThis PR is the first step in solving this problem. This PR introduces a\nflag on the J9Class that indicates whether the type has instances field\nwhich are references. In these cases the barrier API for copying\ninstance fields doesn't need to scan the instance description bits to\napply barrier loads/stores. It can simply use a slot sized load/store\nfor the operation.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-10-02T17:06:25Z", "type": "commit"}, {"oid": "812ac569da026ea40bfac1d901c4fb907bb443f5", "url": "https://github.com/eclipse-openj9/openj9/commit/812ac569da026ea40bfac1d901c4fb907bb443f5", "message": "Introduce instanceHasRefs flag\n\nThere is an issue with instance description bits with respect to\nflattened types. See https://github.com/eclipse/openj9/issues/10070.\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs mode. The `backfill` has been\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs mode) has at least one single slot or ref field\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nThis PR is the first step in solving this problem. This PR introduces a\nflag on the J9Class that indicates whether the type has instances field\nwhich are references. In these cases the barrier API for copying\ninstance fields doesn't need to scan the instance description bits to\napply barrier loads/stores. It can simply use a slot sized load/store\nfor the operation.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-10-02T17:06:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MDEzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r498950131", "bodyText": "expand this with '|| (j9gc_modron_wrtbar_always == _writeBarrierType))' similarly to the other site", "author": "amicic", "createdAt": "2020-10-02T17:19:36Z", "path": "runtime/gc_include/ObjectAccessBarrierAPI.hpp", "diffHunk": "@@ -411,7 +411,8 @@ class MM_ObjectAccessBarrierAPI\n #if defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER)\n \t\treturn vmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_structuralCompareFlattenedObjects(vmThread, valueClass, lhsObject, rhsObject, startOffset);\n #else /* defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER) */\n-\t\tif (j9gc_modron_readbar_none != _readBarrierType) {\n+\t\tbool hasReferences = J9CLASS_HAS_REFERENCES(valueClass);\n+\t\tif (hasReferences && (j9gc_modron_readbar_none != _readBarrierType)) {", "originalCommit": "812ac569da026ea40bfac1d901c4fb907bb443f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MzU0OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r498953548", "bodyText": "even though this is a readonly operation?", "author": "tajila", "createdAt": "2020-10-02T17:26:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MDEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1NjczNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r498956737", "bodyText": "ah, good point. then, no.\nthe other one was a mix of both reads and writes, so I was hasty to assume this was the same case.", "author": "amicic", "createdAt": "2020-10-02T17:33:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MDEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MzU4Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r498953586", "bodyText": "this is more a question for my benefit: if these are not object pointers, what are they (and still care if it's compressed or not)?", "author": "amicic", "createdAt": "2020-10-02T17:26:52Z", "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "diffHunk": "@@ -1393,52 +1393,72 @@ BOOLEAN\n MM_ObjectAccessBarrier::structuralCompareFlattenedObjects(J9VMThread *vmThread, J9Class *valueClass, j9object_t lhsObject, j9object_t rhsObject, UDATA startOffset)\n {\n \tbool result = true;\n-\tconst UDATA *descriptionPtr = (UDATA *) valueClass->instanceDescription;\n-\tUDATA descriptionBits = 0;\n \tbool const compressed = J9VMTHREAD_COMPRESS_OBJECT_REFERENCES(vmThread);\n \tUDATA const referenceSize = J9VMTHREAD_REFERENCE_SIZE(vmThread);\n+\tbool hasReferences = J9CLASS_HAS_REFERENCES(valueClass);\n+\tUDATA limit = valueClass->totalInstanceSize;\n+\tU_32 firstFieldOffset = (U_32) valueClass->backfillOffset;\n+\tUDATA offset = 0;\n \n \tAssert_MM_true(J9_IS_J9CLASS_VALUETYPE(valueClass));\n \n-\tif(((UDATA)descriptionPtr) & 1) {\n-\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n-\t} else {\n-\t\tdescriptionBits = *descriptionPtr++;\n-\t}\n+\tif (hasReferences) {\n+\t\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n+\t\tconst UDATA *descriptionPtr = (UDATA *) valueClass->instanceDescription;\n+\t\tUDATA descriptionBits = 0;\n \n-\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n-\tUDATA offset = 0;\n-\tUDATA limit = valueClass->totalInstanceSize;\n+\t\tif (0 != firstFieldOffset) {\n+\t\t\t/* subtract padding */\n+\t\t\toffset += firstFieldOffset;\n+\t\t\tdescriptionBits >>= 1;\n+\t\t\tdescriptionIndex -= 1;\n+\t\t}\n \n-\tU_32 firstFieldOffset = (U_32) valueClass->backfillOffset;\n-\tif (0 != firstFieldOffset) {\n-\t\t/* subtract padding */\n-\t\toffset += firstFieldOffset;\n-\t\tdescriptionBits >>= 1;\n-\t\tdescriptionIndex -= 1;\n-\t}\n+\t\tif (((UDATA)descriptionPtr) & 1) {\n+\t\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n+\t\t} else {\n+\t\t\tdescriptionBits = *descriptionPtr++;\n+\t\t}\n \n-\twhile (offset < limit) {\n-\t\t/* Determine if the slot contains an object pointer or not */\n-\t\tif(descriptionBits & 1) {\n-\t\t\tif (mixedObjectReadObject(vmThread, lhsObject, startOffset + offset, false) != mixedObjectReadObject(vmThread, rhsObject, startOffset + offset, false)) {\n-\t\t\t\tresult = false;\n-\t\t\t\tbreak;\n+\n+\t\twhile (offset < limit) {\n+\t\t\t/* Determine if the slot contains an object pointer or not */\n+\t\t\tif (descriptionBits & 1) {\n+\t\t\t\tif (mixedObjectReadObject(vmThread, lhsObject, startOffset + offset, false) != mixedObjectReadObject(vmThread, rhsObject, startOffset + offset, false)) {\n+\t\t\t\t\tresult = false;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfomrobject_t lhsValue = GC_SlotObject::readSlot((fomrobject_t*)((UDATA)lhsObject + startOffset + offset), compressed);\n+\t\t\t\tfomrobject_t rhsValue = GC_SlotObject::readSlot((fomrobject_t*)((UDATA)rhsObject + startOffset + offset), compressed);", "originalCommit": "812ac569da026ea40bfac1d901c4fb907bb443f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1NjEwMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r498956101", "bodyText": "These are primitive fields. We still need slot sized loads because each iteration needs to match with the instance description bits. Whether we are compressed or not will determine how bytes each description bit represents.", "author": "tajila", "createdAt": "2020-10-02T17:32:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MzU4Ng=="}], "type": "inlineReview"}]}