{"pr_number": 10788, "pr_title": "Insert arg count in VMThread's tempSlot for invokeBasic calls", "pr_createdAt": "2020-10-05T19:22:01Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10788", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NDgxMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r499864812", "bodyText": "This is going to need a different name - in the compiler a temp slot is a stack allocated variable - this usage will be very confusing. I would suggest findOrCreateVMThreadTempSlotSymbolRef or something explicit like that.", "author": "andrewcraik", "createdAt": "2020-10-05T20:50:49Z", "path": "runtime/compiler/compile/J9SymbolReferenceTable.cpp", "diffHunk": "@@ -2322,6 +2322,20 @@ J9::SymbolReferenceTable::findOrCreateProfilingBufferEndSymbolRef()\n    return element(profilingBufferEndSymbol);\n    }\n \n+TR::SymbolReference *\n+J9::SymbolReferenceTable::findOrCreateTempSlotSymbolRef()", "originalCommit": "b666e299d6199c9045a209b374435c7908e48cde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NDk3Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r499864973", "bodyText": "Please add doxygen for what this is", "author": "andrewcraik", "createdAt": "2020-10-05T20:51:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NDgxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM3NDUxMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r501374510", "bodyText": "Addressed your suggestions.", "author": "nbhuiyan", "createdAt": "2020-10-07T23:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NDgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NTI4NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r499865285", "bodyText": "This label is also potentially confusing in the lop with the other occurrences of temp slot - I think some thought needs to go into changing this to make it less confusing.", "author": "andrewcraik", "createdAt": "2020-10-05T20:51:49Z", "path": "runtime/compiler/compile/J9SymbolReferenceTable.cpp", "diffHunk": "@@ -2322,6 +2322,20 @@ J9::SymbolReferenceTable::findOrCreateProfilingBufferEndSymbolRef()\n    return element(profilingBufferEndSymbol);\n    }\n \n+TR::SymbolReference *\n+J9::SymbolReferenceTable::findOrCreateTempSlotSymbolRef()\n+   {\n+   if (!element(tempSlotSymbol))\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(fe());\n+      TR::Symbol * sym = TR::RegisterMappedSymbol::createMethodMetaDataSymbol(trHeapMemory(), \"tempSlot\");", "originalCommit": "b666e299d6199c9045a209b374435c7908e48cde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM3NDc1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r501374755", "bodyText": "Changed the label to something more explicit.", "author": "nbhuiyan", "createdAt": "2020-10-07T23:55:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NTI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2ODA3Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r499868072", "bodyText": "I assume code later will clean up the call?", "author": "andrewcraik", "createdAt": "2020-10-05T20:57:14Z", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1013,6 +1013,16 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n       self()->lowerNonhelperCallIfNeeded(node, tt);\n       }\n \n+   if (node->getOpCode().isCall() &&\n+       !node->getSymbol()->castToMethodSymbol()->isHelper() &&\n+       (node->getSymbol()->castToMethodSymbol()->getRecognizedMethod() == TR::java_lang_invoke_MethodHandle_invokeBasic))", "originalCommit": "b666e299d6199c9045a209b374435c7908e48cde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM3NDI1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r501374258", "bodyText": "I am not sure what you mean by this comment. Please explain what you were expecting the later code to do.", "author": "nbhuiyan", "createdAt": "2020-10-07T23:53:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2ODA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0NjgxNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r501746816", "bodyText": "@andrewcraik The call will remain in the tree, codegen will generate instructions for it. It's just that we need to store additional information to J9VMThread, hence this PR", "author": "liqunl", "createdAt": "2020-10-08T14:03:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2ODA3Mg=="}], "type": "inlineReview"}, {"oid": "e782c5fd9f78c62a730f4afb59f46959fd4cfbe7", "url": "https://github.com/eclipse-openj9/openj9/commit/e782c5fd9f78c62a730f4afb59f46959fd4cfbe7", "message": "Insert arg count in VMThread's tempSlot for invokeBasic calls\n\nMethodHandle.invokeBasic is implemented as an internal native\nmethod that is signature polymorphic. When calling invokeBasic\nfrom the JIT body, the VM needs to know the number of arguments\nfor the invokeBasic call in order to locate the receiver object\non the stack. This implementation inserts a node at the lowering\ntrees phase to store the number of args into the VMThread.tempSlot\nright before the call to MethodHandle.invokeBasic.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2020-10-07T23:49:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1MTM5OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r501751399", "bodyText": "We should call createStore(TR::Node *originatingByteCodeNode, TR::SymbolReference * symRef, TR::Node * value) and pass in the call node as the originatingByteCodeNode such that the store node gets the right bytecode index.", "author": "liqunl", "createdAt": "2020-10-08T14:09:24Z", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1013,6 +1013,16 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n       self()->lowerNonhelperCallIfNeeded(node, tt);\n       }\n \n+   if (node->getOpCode().isCall() &&\n+       !node->getSymbol()->castToMethodSymbol()->isHelper() &&\n+       (node->getSymbol()->castToMethodSymbol()->getRecognizedMethod() == TR::java_lang_invoke_MethodHandle_invokeBasic))\n+      {\n+      TR::SymbolReference *vmThreadTempSlotSymRef = self()->comp()->getSymRefTab()->findOrCreateVMThreadTempSlotSymbolRef();\n+      TR::Node *numArgsNode = TR::Node::iconst(node, node->getNumArguments() - 1);\n+      TR::Node *storeNode = TR::Node::createStore(vmThreadTempSlotSymRef, numArgsNode, TR::istore);", "originalCommit": "e782c5fd9f78c62a730f4afb59f46959fd4cfbe7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg0OTkzMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r501849933", "bodyText": "There is no API for creating store that allows me to specify the opcode as well as the originating bytecode. Without explicitly specifying TR::istore, we end up with TR::astore. As a workaround for setting the bytecode index, I've added the following line:\nstoreNode->setByteCodeIndex(node->getByteCodeIndex());", "author": "nbhuiyan", "createdAt": "2020-10-08T16:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1MTM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1MzQ2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r501753468", "bodyText": "Can the name be updated to findOrCreateVMThreadTempSlotFieldSymbolRef?", "author": "liqunl", "createdAt": "2020-10-08T14:12:04Z", "path": "runtime/compiler/compile/J9SymbolReferenceTable.hpp", "diffHunk": "@@ -76,6 +76,15 @@ class SymbolReferenceTable : public OMR::SymbolReferenceTableConnector\n    TR::SymbolReference * findOrCreateOSRScratchBufferSymbolRef();\n    TR::SymbolReference * findOrCreateOSRFrameIndexSymbolRef();\n \n+   /** \\brief\n+    * Find or create VMThread tempSlot symbol reference. J9VMThread.tempSlot provides a mechanism for the\n+    * compiler to provide information that the VM can use for various reasons - such as locating items on\n+    * the stack during a call to internal native methods that are signature-polymorphic.\n+    *\n+    * \\return TR::SymbolReference* the VMThreadTempSlotField symbol reference\n+    */\n+   TR::SymbolReference * findOrCreateVMThreadTempSlotSymbolRef();", "originalCommit": "e782c5fd9f78c62a730f4afb59f46959fd4cfbe7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg1MDAxNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r501850016", "bodyText": "Done.", "author": "nbhuiyan", "createdAt": "2020-10-08T16:22:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1MzQ2OA=="}], "type": "inlineReview"}, {"oid": "03c62b3613dcb47aefae3e537265dd57c03e500d", "url": "https://github.com/eclipse-openj9/openj9/commit/03c62b3613dcb47aefae3e537265dd57c03e500d", "message": "Insert arg count in VMThread's tempSlot for invokeBasic calls\n\nMethodHandle.invokeBasic is implemented as an internal native\nmethod that is signature polymorphic. When calling invokeBasic\nfrom the JIT body, the VM needs to know the number of arguments\nfor the invokeBasic call in order to locate the receiver object\non the stack. This implementation inserts a node at the lowering\ntrees phase to store the number of args into the VMThread.tempSlot\nright before the call to MethodHandle.invokeBasic.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2020-10-08T16:05:03Z", "type": "forcePushed"}, {"oid": "3348c4fb305cf8d7a16f67135c364d3222f62d4f", "url": "https://github.com/eclipse-openj9/openj9/commit/3348c4fb305cf8d7a16f67135c364d3222f62d4f", "message": "Insert arg count in VMThread's tempSlot for invokeBasic calls\n\nMethodHandle.invokeBasic is implemented as an internal native\nmethod that is signature polymorphic. When calling invokeBasic\nfrom the JIT body, the VM needs to know the number of arguments\nfor the invokeBasic call in order to locate the receiver object\non the stack. This implementation inserts a node at the lowering\ntrees phase to store the number of args into the VMThread.tempSlot\nright before the call to MethodHandle.invokeBasic.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2020-10-13T16:02:47Z", "type": "forcePushed"}, {"oid": "92980b0917a5a8c1421b75af3b3c14088fe673bb", "url": "https://github.com/eclipse-openj9/openj9/commit/92980b0917a5a8c1421b75af3b3c14088fe673bb", "message": "Add capability to create or lookup symref for VMThread.tempSlot\n\ntempSlotSymbol can be used to store additional info that the VM may\nuse during a call from JIT-ed code to the VM - such as when calling\nVM Internal Natives and needing to provide the number of parameters\nfor signature polymorphic methods.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2020-10-13T16:06:05Z", "type": "commit"}, {"oid": "705548e9bef9b30ff06dd664408735a1d1c14f0f", "url": "https://github.com/eclipse-openj9/openj9/commit/705548e9bef9b30ff06dd664408735a1d1c14f0f", "message": "Insert arg count in VMThread's tempSlot for invokeBasic calls\n\nMethodHandle.invokeBasic is implemented as an internal native\nmethod that is signature polymorphic. When calling invokeBasic\nfrom the JIT body, the VM needs to know the number of arguments\nfor the invokeBasic call in order to locate the receiver object\non the stack. This implementation inserts a node at the lowering\ntrees phase to store the number of args into the VMThread.tempSlot\nright before the call to MethodHandle.invokeBasic.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2020-10-13T16:06:05Z", "type": "commit"}, {"oid": "705548e9bef9b30ff06dd664408735a1d1c14f0f", "url": "https://github.com/eclipse-openj9/openj9/commit/705548e9bef9b30ff06dd664408735a1d1c14f0f", "message": "Insert arg count in VMThread's tempSlot for invokeBasic calls\n\nMethodHandle.invokeBasic is implemented as an internal native\nmethod that is signature polymorphic. When calling invokeBasic\nfrom the JIT body, the VM needs to know the number of arguments\nfor the invokeBasic call in order to locate the receiver object\non the stack. This implementation inserts a node at the lowering\ntrees phase to store the number of args into the VMThread.tempSlot\nright before the call to MethodHandle.invokeBasic.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2020-10-13T16:06:05Z", "type": "forcePushed"}]}