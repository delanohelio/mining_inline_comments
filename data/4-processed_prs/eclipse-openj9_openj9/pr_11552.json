{"pr_number": 11552, "pr_title": "Remove dependence of Inlining table relocations on the existence of virtual guards", "pr_createdAt": "2020-12-30T21:23:18Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/11552", "timeline": [{"oid": "c1bcdf02d354e4a15c42d746a8de5b3c31d8a042", "url": "https://github.com/eclipse-openj9/openj9/commit/c1bcdf02d354e4a15c42d746a8de5b3c31d8a042", "message": "Increment JITServer Minor Version\n\nChange in relocation requires a change to the minor version.\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2021-01-07T21:54:00Z", "type": "forcePushed"}, {"oid": "539c58285d0d90fd77daa5948f964c90876486cd", "url": "https://github.com/eclipse-openj9/openj9/commit/539c58285d0d90fd77daa5948f964c90876486cd", "message": "Increment JITServer Minor Version\n\nChange in relocation requires a change to the minor version.\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2021-01-08T18:43:29Z", "type": "forcePushed"}, {"oid": "6fe240d56eff4b6f87ea60d10ebf2f1d7444ca2c", "url": "https://github.com/eclipse-openj9/openj9/commit/6fe240d56eff4b6f87ea60d10ebf2f1d7444ca2c", "message": "Increment JITServer Minor Version\n\nChange in relocation requires a change to the minor version.\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2021-01-14T16:38:06Z", "type": "forcePushed"}, {"oid": "c439e7688fa1a376610833fdbec459ea01a95393", "url": "https://github.com/eclipse-openj9/openj9/commit/c439e7688fa1a376610833fdbec459ea01a95393", "message": "Increment JITServer Minor Version\n\nChange in relocation requires a change to the minor version.\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2021-01-14T17:12:29Z", "type": "forcePushed"}, {"oid": "4d9943ab53407e29dbff0a8b2668fe3aef241ead", "url": "https://github.com/eclipse-openj9/openj9/commit/4d9943ab53407e29dbff0a8b2668fe3aef241ead", "message": "Increment JITServer Minor Version\n\nChange in relocation requires a change to the minor version.\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2021-01-15T22:00:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgxNzc4Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559817787", "bodyText": "This looks weird. Why do you need to explicitly call the base class for a virtual method?", "author": "mstoodle", "createdAt": "2021-01-18T22:22:03Z", "path": "runtime/compiler/runtime/RelocationRecord.cpp", "diffHunk": "@@ -2907,6 +2916,32 @@ TR_RelocationRecordInlinedStaticMethodWithNopGuard::updateSucceededStats(TR_AOTS\n    aotStats->staticMethods.numSucceededValidations++;\n    }\n \n+\n+// TR_RelocationRecordInlinedStaticMethod\n+char *\n+TR_RelocationRecordInlinedStaticMethod::name()\n+   {\n+   return \"TR_InlinedStaticMethod\";\n+   }\n+\n+void\n+TR_RelocationRecordInlinedStaticMethod::print(TR_RelocationRuntime *reloRuntime)", "originalCommit": "2d39cf64d5bf1e9b2ed600f47283f6019541ce19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTA1OTI4MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561059280", "bodyText": "To keep it consistent with the way existing relo record did this heh (see TR_RelocationRecordInlinedVirtualMethod::print).  I can go clean it all up.", "author": "dsouzai", "createdAt": "2021-01-20T15:35:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgxNzc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgxODkyNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559818924", "bodyText": "same here...", "author": "mstoodle", "createdAt": "2021-01-18T22:26:14Z", "path": "runtime/compiler/runtime/RelocationRecord.cpp", "diffHunk": "@@ -2907,6 +2916,32 @@ TR_RelocationRecordInlinedStaticMethodWithNopGuard::updateSucceededStats(TR_AOTS\n    aotStats->staticMethods.numSucceededValidations++;\n    }\n \n+\n+// TR_RelocationRecordInlinedStaticMethod\n+char *\n+TR_RelocationRecordInlinedStaticMethod::name()\n+   {\n+   return \"TR_InlinedStaticMethod\";\n+   }\n+\n+void\n+TR_RelocationRecordInlinedStaticMethod::print(TR_RelocationRuntime *reloRuntime)\n+   {\n+   Base::print(reloRuntime);\n+   }\n+\n+void\n+TR_RelocationRecordInlinedStaticMethod::preparePrivateData(TR_RelocationRuntime *reloRuntime, TR_RelocationTarget *reloTarget)\n+   {\n+   Base::preparePrivateData(reloRuntime, reloTarget);", "originalCommit": "2d39cf64d5bf1e9b2ed600f47283f6019541ce19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyMDM4Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559820387", "bodyText": "Shouldn't the default reloKind be that returned by OMR's version of this function (i.e. not inlining the current implementation of it) ?", "author": "mstoodle", "createdAt": "2021-01-18T22:31:29Z", "path": "runtime/compiler/compile/J9Compilation.cpp", "diffHunk": "@@ -1135,6 +1136,61 @@ J9::Compilation::isGeneratedReflectionMethod(TR_ResolvedMethod * method)\n    return false;\n    }\n \n+TR_ExternalRelocationTargetKind\n+J9::Compilation::getReloTypeForMethodToBeInlined(TR_VirtualGuardSelection *guard, TR::Node *callNode, TR_OpaqueClassBlock *receiverClass)\n+   {\n+   TR_ExternalRelocationTargetKind reloKind = TR_NoRelocation;", "originalCommit": "8ce295be52b10fa8dad12eecea41b556947d2edb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTA2MDU1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561060550", "bodyText": "Yeah I can make a call to the OMR one.", "author": "dsouzai", "createdAt": "2021-01-20T15:36:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyMDM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyMTMwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559821306", "bodyText": "Please augment the comment to summarize the refactoring and reason why it's being refactored?", "author": "mstoodle", "createdAt": "2021-01-18T22:35:15Z", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -2904,281 +2904,303 @@ J9::CodeGenerator::populateOSRBuffer()\n    self()->comp()->getOSRCompilationData()->setMaxScratchBufferSize(maxScratchBufferSize);\n    }\n \n-\n-void\n-J9::CodeGenerator::processRelocations()\n+static void addValidationRecords(TR::CodeGenerator *cg)", "originalCommit": "91508c2995a9eb775220cafdee46b72c0e8e8d72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyMzc3Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559823776", "bodyText": "Is there a reason you wanted all these functions to be static and not functions of J9::CodeGenerator?", "author": "mstoodle", "createdAt": "2021-01-18T22:44:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyMTMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyNDE1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559824150", "bodyText": "Should this version only be in use if the SVM is not being used?", "author": "mstoodle", "createdAt": "2021-01-18T22:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyMTMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTA2MjAzOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561062039", "bodyText": "Is there a reason you wanted all these functions to be static and not functions of J9::CodeGenerator?\n\nConceptually they don't have anything to do with the CodeGenerator, they're just helpers for processRelocations.", "author": "dsouzai", "createdAt": "2021-01-20T15:38:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyMTMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTA2MjcwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561062707", "bodyText": "Should this version only be in use if the SVM is not being used?\n\nIf the SVM is being used, then addValidationRecords will just be a NOP as the list will be empty.", "author": "dsouzai", "createdAt": "2021-01-20T15:39:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyMTMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM0NjU2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561346568", "bodyText": "helpers that read and then update state in the code generator object. But ok, I don't feel that strongly about it.", "author": "mstoodle", "createdAt": "2021-01-20T22:23:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyMTMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyNTMxNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559825315", "bodyText": "Just to confirm: you're mapping all relocations to the earliest and outermost inlined site index with the same method?", "author": "mstoodle", "createdAt": "2021-01-18T22:49:27Z", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -2904,281 +2904,303 @@ J9::CodeGenerator::populateOSRBuffer()\n    self()->comp()->getOSRCompilationData()->setMaxScratchBufferSize(maxScratchBufferSize);\n    }\n \n-\n-void\n-J9::CodeGenerator::processRelocations()\n+static void addValidationRecords(TR::CodeGenerator *cg)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->comp()->fe());\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(cg->comp()->fe());\n \n-   //Project neutral non-AOT processRelocation\n-   OMR::CodeGeneratorConnector::processRelocations();\n+   TR::list<TR::AOTClassInfo*>* classInfo = cg->comp()->_aotClassInfo;\n+   if (!classInfo->empty())\n+      {\n+      for (auto info = classInfo->begin(); info != classInfo->end(); ++info)\n+         {\n+         traceMsg(cg->comp(), \"processing AOT class info: %p in %s\\n\", *info, cg->comp()->signature());\n+         traceMsg(cg->comp(), \"ramMethod: %p cp: %p cpIndex: %x relo %d\\n\", (*info)->_method, (*info)->_constantPool, (*info)->_cpIndex, (*info)->_reloKind);\n+         traceMsg(cg->comp(), \"clazz: %p classChain: %p\\n\", (*info)->_clazz, (*info)->_classChain);\n \n-   int32_t missedSite = -1;\n+         TR_OpaqueMethodBlock *ramMethod = (*info)->_method;\n \n-   if (self()->comp()->compileRelocatableCode())\n-      {\n-      uint32_t inlinedCallSize = self()->comp()->getNumInlinedCallSites();\n+         int32_t siteIndex = -1;\n \n-      // Create temporary hashtable for ordering AOT guard relocations\n-      int32_t counter = inlinedCallSize;\n-      TR_InlinedSiteHastTableEntry *orderedInlinedSiteListTable;\n-      if (inlinedCallSize > 0)\n-         {\n-         orderedInlinedSiteListTable= (TR_InlinedSiteHastTableEntry*)self()->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteHastTableEntry) * inlinedCallSize, heapAlloc);\n-         memset(orderedInlinedSiteListTable, 0, sizeof(TR_InlinedSiteHastTableEntry)*inlinedCallSize);\n+         if (ramMethod != cg->comp()->getCurrentMethod()->getPersistentIdentifier()) // && info->_reloKind != TR_ValidateArbitraryClass)\n+            {\n+            int32_t i;\n+            for (i = 0; i < cg->comp()->getNumInlinedCallSites(); i++)\n+               {\n+               TR_InlinedCallSite &ics = cg->comp()->getInlinedCallSite(i);\n+               TR_OpaqueMethodBlock *inlinedMethod = fej9->getInlinedCallSiteMethod(&ics);\n+\n+               traceMsg(cg->comp(), \"\\tinline site %d inlined method %p\\n\", i, inlinedMethod);\n+               if (ramMethod == inlinedMethod)\n+                  {\n+                  traceMsg(cg->comp(), \"\\t\\tmatch!\\n\");\n+                  siteIndex = i;\n+                  break;\n+                  }\n+               }\n+\n+            if (i >= (int32_t) cg->comp()->getNumInlinedCallSites())\n+               {\n+               // this assumption isn't associated with a method directly in the compilation\n+               // so we can't use a constant pool approach to validate: transform into TR_ValidateArbitraryClass\n+               // kind of overkill for TR_ValidateStaticField, but still correct\n+               (*info)->_reloKind = TR_ValidateArbitraryClass;\n+               siteIndex = -1;   // invalidate main compiled method\n+               traceMsg(cg->comp(), \"\\ttransformed into TR_ValidateArbitraryClass\\n\");\n+               }\n+            }\n+\n+         traceMsg(cg->comp(), \"Found inlined site %d\\n\", siteIndex);\n+\n+         TR_ASSERT(siteIndex < (int32_t) cg->comp()->getNumInlinedCallSites(), \"did not find AOTClassInfo %p method in inlined site table\", *info);\n+\n+         cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation(NULL,\n+                                                                          (uint8_t *)(intptr_t)siteIndex,\n+                                                                          (uint8_t *)(*info),\n+                                                                          (*info)->_reloKind, cg),\n+                                                                          __FILE__, __LINE__, NULL);\n          }\n-      else\n-         orderedInlinedSiteListTable = NULL;\n+      }", "originalCommit": "91508c2995a9eb775220cafdee46b72c0e8e8d72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTA2NTI0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561065243", "bodyText": "I haven't changed any of the logic that happens in here; I just moved it to its own function so that it's just easier to read the code. However, I believe something like that happens when writing the header in J9AheadOfTimeCompile.cpp; I think it's called findCorrectInlinedSiteIndex.", "author": "dsouzai", "createdAt": "2021-01-20T15:42:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyNTMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyNzcxMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559827713", "bodyText": "why remove the comment which explains a relatively subtle ordering point?", "author": "mstoodle", "createdAt": "2021-01-18T22:58:16Z", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -2904,281 +2904,303 @@ J9::CodeGenerator::populateOSRBuffer()\n    self()->comp()->getOSRCompilationData()->setMaxScratchBufferSize(maxScratchBufferSize);\n    }\n \n-\n-void\n-J9::CodeGenerator::processRelocations()\n+static void addValidationRecords(TR::CodeGenerator *cg)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->comp()->fe());\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(cg->comp()->fe());\n \n-   //Project neutral non-AOT processRelocation\n-   OMR::CodeGeneratorConnector::processRelocations();\n+   TR::list<TR::AOTClassInfo*>* classInfo = cg->comp()->_aotClassInfo;\n+   if (!classInfo->empty())\n+      {\n+      for (auto info = classInfo->begin(); info != classInfo->end(); ++info)\n+         {\n+         traceMsg(cg->comp(), \"processing AOT class info: %p in %s\\n\", *info, cg->comp()->signature());\n+         traceMsg(cg->comp(), \"ramMethod: %p cp: %p cpIndex: %x relo %d\\n\", (*info)->_method, (*info)->_constantPool, (*info)->_cpIndex, (*info)->_reloKind);\n+         traceMsg(cg->comp(), \"clazz: %p classChain: %p\\n\", (*info)->_clazz, (*info)->_classChain);\n \n-   int32_t missedSite = -1;\n+         TR_OpaqueMethodBlock *ramMethod = (*info)->_method;\n \n-   if (self()->comp()->compileRelocatableCode())\n-      {\n-      uint32_t inlinedCallSize = self()->comp()->getNumInlinedCallSites();\n+         int32_t siteIndex = -1;\n \n-      // Create temporary hashtable for ordering AOT guard relocations\n-      int32_t counter = inlinedCallSize;\n-      TR_InlinedSiteHastTableEntry *orderedInlinedSiteListTable;\n-      if (inlinedCallSize > 0)\n-         {\n-         orderedInlinedSiteListTable= (TR_InlinedSiteHastTableEntry*)self()->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteHastTableEntry) * inlinedCallSize, heapAlloc);\n-         memset(orderedInlinedSiteListTable, 0, sizeof(TR_InlinedSiteHastTableEntry)*inlinedCallSize);\n+         if (ramMethod != cg->comp()->getCurrentMethod()->getPersistentIdentifier()) // && info->_reloKind != TR_ValidateArbitraryClass)\n+            {\n+            int32_t i;\n+            for (i = 0; i < cg->comp()->getNumInlinedCallSites(); i++)\n+               {\n+               TR_InlinedCallSite &ics = cg->comp()->getInlinedCallSite(i);\n+               TR_OpaqueMethodBlock *inlinedMethod = fej9->getInlinedCallSiteMethod(&ics);\n+\n+               traceMsg(cg->comp(), \"\\tinline site %d inlined method %p\\n\", i, inlinedMethod);\n+               if (ramMethod == inlinedMethod)\n+                  {\n+                  traceMsg(cg->comp(), \"\\t\\tmatch!\\n\");\n+                  siteIndex = i;\n+                  break;\n+                  }\n+               }\n+\n+            if (i >= (int32_t) cg->comp()->getNumInlinedCallSites())\n+               {\n+               // this assumption isn't associated with a method directly in the compilation\n+               // so we can't use a constant pool approach to validate: transform into TR_ValidateArbitraryClass\n+               // kind of overkill for TR_ValidateStaticField, but still correct\n+               (*info)->_reloKind = TR_ValidateArbitraryClass;\n+               siteIndex = -1;   // invalidate main compiled method\n+               traceMsg(cg->comp(), \"\\ttransformed into TR_ValidateArbitraryClass\\n\");\n+               }\n+            }\n+\n+         traceMsg(cg->comp(), \"Found inlined site %d\\n\", siteIndex);\n+\n+         TR_ASSERT(siteIndex < (int32_t) cg->comp()->getNumInlinedCallSites(), \"did not find AOTClassInfo %p method in inlined site table\", *info);\n+\n+         cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation(NULL,\n+                                                                          (uint8_t *)(intptr_t)siteIndex,\n+                                                                          (uint8_t *)(*info),\n+                                                                          (*info)->_reloKind, cg),\n+                                                                          __FILE__, __LINE__, NULL);\n          }\n-      else\n-         orderedInlinedSiteListTable = NULL;\n+      }\n+   }\n \n-      TR_InlinedSiteLinkedListEntry *entry = NULL;\n+static void addSVMValidationRecords(TR::CodeGenerator *cg)\n+   {\n+   TR::SymbolValidationManager::SymbolValidationRecordList &validationRecords = cg->comp()->getSymbolValidationManager()->getValidationRecordList();\n+   if (cg->comp()->getOption(TR_UseSymbolValidationManager))\n+      {\n+      // Add the flags in TR_AOTMethodHeader on the compile run\n+      J9JITDataCacheHeader *aotMethodHeader = (J9JITDataCacheHeader *)cg->comp()->getAotMethodDataStart();\n+      TR_AOTMethodHeader *aotMethodHeaderEntry = (TR_AOTMethodHeader *)(aotMethodHeader + 1);\n+      aotMethodHeaderEntry->flags |= TR_AOTMethodHeader_UsesSymbolValidationManager;\n \n-      // Traverse list of AOT-specific guards and create relocation records\n-      TR::list<TR_AOTGuardSite*> *aotGuardSites = self()->comp()->getAOTGuardPatchSites();\n-      for(auto it = aotGuardSites->begin(); it != aotGuardSites->end(); ++it)\n+      for (auto it = validationRecords.begin(); it != validationRecords.end(); it++)\n          {\n-         intptr_t inlinedSiteIndex = -1;\n+         cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation(NULL,\n+                                                                          (uint8_t *)(*it),\n+                                                                          (*it)->_kind, cg),\n+                                                                          __FILE__, __LINE__, NULL);\n+         }\n+      }\n+   }\n \n-         // first, figure out the appropriate relocation record type from the guard type and symbol\n-         TR_ExternalRelocationTargetKind type;\n-         switch ((*it)->getType())\n-            {\n-            case TR_DirectMethodGuard:\n-               if ((*it)->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isStatic())\n-                  type = TR_InlinedStaticMethodWithNopGuard;\n-               else if ((*it)->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isSpecial())\n-                  type = TR_InlinedSpecialMethodWithNopGuard;\n-               else if ((*it)->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isVirtual())\n-                  type = TR_InlinedVirtualMethodWithNopGuard;\n-               else\n-                  TR_ASSERT(0, \"unexpected AOTDirectMethodGuard method symbol\");\n-               break;\n+static TR_ExternalRelocationTargetKind getReloKindFromGuardSite(TR::CodeGenerator *cg, TR_AOTGuardSite *site)\n+   {\n+   TR_ExternalRelocationTargetKind type;\n \n-            case TR_NonoverriddenGuard:\n-               type = TR_InlinedVirtualMethodWithNopGuard;\n-               break;\n-            case TR_RemovedNonoverriddenGuard:\n-               type = TR_InlinedVirtualMethod;\n-               break;\n+   switch (site->getType())\n+      {\n+      case TR_DirectMethodGuard:\n+         if (site->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isStatic())\n+            type = TR_InlinedStaticMethodWithNopGuard;\n+         else if (site->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isSpecial())\n+            type = TR_InlinedSpecialMethodWithNopGuard;\n+         else if (site->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isVirtual())\n+            type = TR_InlinedVirtualMethodWithNopGuard;\n+         else\n+            TR_ASSERT(0, \"unexpected AOTDirectMethodGuard method symbol\");\n+         break;\n \n-            case TR_InterfaceGuard:\n-               type = TR_InlinedInterfaceMethodWithNopGuard;\n-               break;\n-            case TR_RemovedInterfaceGuard:\n-               traceMsg(self()->comp(), \"TR_RemovedInterfaceMethod\\n\");\n-               type = TR_InlinedInterfaceMethod;\n-               break;\n+      case TR_NonoverriddenGuard:\n+         type = TR_InlinedVirtualMethodWithNopGuard;\n+         break;\n+      case TR_RemovedNonoverriddenGuard:\n+         type = TR_InlinedVirtualMethod;\n+         break;\n \n-            case TR_AbstractGuard:\n-               type = TR_InlinedAbstractMethodWithNopGuard;\n-               break;\n+      case TR_InterfaceGuard:\n+         type = TR_InlinedInterfaceMethodWithNopGuard;\n+         break;\n+      case TR_RemovedInterfaceGuard:\n+         traceMsg(cg->comp(), \"TR_RemovedInterfaceMethod\\n\");\n+         type = TR_InlinedInterfaceMethod;\n+         break;\n \n-            case TR_HCRGuard:\n-               // devinmp: TODO/FIXME this should arrange to create an AOT\n-               // relocation which, when loaded, creates a\n-               // TR_PatchNOPedGuardSiteOnClassRedefinition or similar.\n-               // Here we would previously create a TR_HCR relocation,\n-               // which is for replacing J9Class or J9Method pointers.\n-               // These would be the 'unresolved' variant\n-               // (TR_RedefinedClassUPicSite), which would (hopefully) never\n-               // get patched. If it were patched, it seems like it would\n-               // replace code with a J9Method pointer.\n-               if (!self()->comp()->getOption(TR_UseOldHCRGuardAOTRelocations))\n-                  continue;\n-               type = TR_HCR;\n-               break;\n+      case TR_AbstractGuard:\n+         type = TR_InlinedAbstractMethodWithNopGuard;\n+         break;\n \n-            case TR_MethodEnterExitGuard:\n-               if ((*it)->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodEnterHook)\n-                  type = TR_CheckMethodEnter;\n-               else if ((*it)->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodExitHook)\n-                  type = TR_CheckMethodExit;\n-               else\n-                  TR_ASSERT(0,\"Unexpected TR_MethodEnterExitGuard at site %p guard %p node %p\\n\",\n-                                    *it, (*it)->getGuard(), (*it)->getGuard()->getCallNode());\n-               break;\n+      case TR_HCRGuard:\n+         // devinmp: TODO/FIXME this should arrange to create an AOT\n+         // relocation which, when loaded, creates a\n+         // TR_PatchNOPedGuardSiteOnClassRedefinition or similar.\n+         // Here we would previously create a TR_HCR relocation,\n+         // which is for replacing J9Class or J9Method pointers.\n+         // These would be the 'unresolved' variant\n+         // (TR_RedefinedClassUPicSite), which would (hopefully) never\n+         // get patched. If it were patched, it seems like it would\n+         // replace code with a J9Method pointer.\n+         if (!cg->comp()->getOption(TR_UseOldHCRGuardAOTRelocations))\n+            type = TR_NoRelocation;\n+         else\n+            type = TR_HCR;\n+         break;\n \n-            case TR_RemovedProfiledGuard:\n-               traceMsg(self()->comp(), \"TR_ProfiledInlinedMethodRelocation\\n\");\n-               type = TR_ProfiledInlinedMethodRelocation;\n-               break;\n+      case TR_MethodEnterExitGuard:\n+         if (site->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodEnterHook)\n+            type = TR_CheckMethodEnter;\n+         else if (site->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodExitHook)\n+            type = TR_CheckMethodExit;\n+         else\n+            TR_ASSERT(0,\"Unexpected TR_MethodEnterExitGuard at site %p guard %p node %p\\n\",\n+                              *it, site->getGuard(), site->getGuard()->getCallNode());\n+         break;\n \n-            case TR_ProfiledGuard:\n-               if ((*it)->getGuard()->getTestType() == TR_MethodTest)\n-                  {\n-                  type = TR_ProfiledMethodGuardRelocation;\n-                  traceMsg(self()->comp(), \"TR_ProfiledMethodGuardRelocation\\n\");\n-                  }\n-               else if ((*it)->getGuard()->getTestType() == TR_VftTest)\n-                  {\n-                  type = TR_ProfiledClassGuardRelocation;\n-                  traceMsg(self()->comp(), \"TR_ProfiledClassGuardRelocation\\n\");\n-                  }\n-               else\n-                  TR_ASSERT(false, \"unexpected profiled guard test type\");\n-               break;\n+      case TR_RemovedProfiledGuard:\n+         traceMsg(cg->comp(), \"TR_ProfiledInlinedMethodRelocation\\n\");\n+         type = TR_ProfiledInlinedMethodRelocation;\n+         break;\n \n-            default:\n-               TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n-               break;\n+      case TR_ProfiledGuard:\n+         if (site->getGuard()->getTestType() == TR_MethodTest)\n+            {\n+            type = TR_ProfiledMethodGuardRelocation;\n+            traceMsg(cg->comp(), \"TR_ProfiledMethodGuardRelocation\\n\");\n             }\n-\n-         switch (type)  // relocation record type\n+         else if (site->getGuard()->getTestType() == TR_VftTest)\n             {\n-            case TR_InlinedStaticMethodWithNopGuard:\n-            case TR_InlinedSpecialMethodWithNopGuard:\n-            case TR_InlinedVirtualMethodWithNopGuard:\n-            case TR_InlinedInterfaceMethodWithNopGuard:\n-            case TR_InlinedAbstractMethodWithNopGuard:\n-            case TR_ProfiledClassGuardRelocation:\n-            case TR_ProfiledMethodGuardRelocation:\n-            case TR_ProfiledInlinedMethodRelocation:\n-            case TR_InlinedVirtualMethod:\n-            case TR_InlinedInterfaceMethod:\n-               TR_ASSERT(inlinedCallSize, \"TR_AOT expect inlinedCallSize to be larger than 0\\n\");\n-               inlinedSiteIndex = (intptr_t)(*it)->getGuard()->getCurrentInlinedSiteIndex();\n-               entry = (TR_InlinedSiteLinkedListEntry *)self()->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteLinkedListEntry), heapAlloc);\n-\n-               entry->reloType = type;\n-               entry->location = (uint8_t *)(*it)->getLocation();\n-               entry->destination = (uint8_t *)(*it)->getDestination();\n-               entry->guard = (uint8_t *)(*it)->getGuard();\n-               entry->next = NULL;\n-\n-               if (orderedInlinedSiteListTable[inlinedSiteIndex].first)\n-                  {\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].last->next = entry;\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n-                  }\n-               else\n-                  {\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].first = entry;\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n-                  }\n-               break;\n+            type = TR_ProfiledClassGuardRelocation;\n+            traceMsg(cg->comp(), \"TR_ProfiledClassGuardRelocation\\n\");\n+            }\n+         else\n+            TR_ASSERT(false, \"unexpected profiled guard test type\");\n+         break;\n \n-            case TR_CheckMethodEnter:\n-            case TR_CheckMethodExit:\n-            case TR_HCR:\n-               self()->addExternalRelocation(new (self()->trHeapMemory()) TR::ExternalRelocation((uint8_t *)(*it)->getLocation(),\n-                                                                                (uint8_t *)(*it)->getDestination(),\n-                                                                                type, self()),\n-                                __FILE__, __LINE__, NULL);\n-               break;\n+      default:\n+         TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n+         cg->comp()->failCompilation<J9::AOTRelocationRecordGenerationFailure>(\"Unknown/non-AOT guard at AOT site\");\n+         break;\n+      }\n \n-            default:\n-               TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n-               break;\n-            }\n-         }\n+   return type;\n+   }\n \n-      TR::list<TR::AOTClassInfo*>* classInfo = self()->comp()->_aotClassInfo;\n-      if (!classInfo->empty())\n+static void processAOTGuardSites(TR::CodeGenerator *cg, uint32_t inlinedCallSize, TR_InlinedSiteHastTableEntry *orderedInlinedSiteListTable)\n+   {\n+   TR::list<TR_AOTGuardSite*> *aotGuardSites = cg->comp()->getAOTGuardPatchSites();\n+   for(auto it = aotGuardSites->begin(); it != aotGuardSites->end(); ++it)\n+      {\n+      // first, figure out the appropriate relocation record type from the guard type and symbol\n+      TR_ExternalRelocationTargetKind type = getReloKindFromGuardSite(cg, (*it));\n+\n+      switch (type)  // relocation record type\n          {\n-         for (auto info = classInfo->begin(); info != classInfo->end(); ++info)\n+         case TR_InlinedStaticMethodWithNopGuard:\n+         case TR_InlinedSpecialMethodWithNopGuard:\n+         case TR_InlinedVirtualMethodWithNopGuard:\n+         case TR_InlinedInterfaceMethodWithNopGuard:\n+         case TR_InlinedAbstractMethodWithNopGuard:\n+         case TR_ProfiledClassGuardRelocation:\n+         case TR_ProfiledMethodGuardRelocation:\n+         case TR_ProfiledInlinedMethodRelocation:\n+         case TR_InlinedVirtualMethod:\n+         case TR_InlinedInterfaceMethod:\n             {\n-            traceMsg(self()->comp(), \"processing AOT class info: %p in %s\\n\", *info, self()->comp()->signature());\n-            traceMsg(self()->comp(), \"ramMethod: %p cp: %p cpIndex: %x relo %d\\n\", (*info)->_method, (*info)->_constantPool, (*info)->_cpIndex, (*info)->_reloKind);\n-            traceMsg(self()->comp(), \"clazz: %p classChain: %p\\n\", (*info)->_clazz, (*info)->_classChain);\n+            TR_ASSERT(inlinedCallSize, \"TR_AOT expect inlinedCallSize to be larger than 0\\n\");\n+            intptr_t inlinedSiteIndex = (intptr_t)(*it)->getGuard()->getCurrentInlinedSiteIndex();\n+            TR_InlinedSiteLinkedListEntry *entry = (TR_InlinedSiteLinkedListEntry *)cg->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteLinkedListEntry), heapAlloc);\n \n-            TR_OpaqueMethodBlock *ramMethod = (*info)->_method;\n+            entry->reloType = type;\n+            entry->location = (uint8_t *)(*it)->getLocation();\n+            entry->destination = (uint8_t *)(*it)->getDestination();\n+            entry->guard = (uint8_t *)(*it)->getGuard();\n+            entry->next = NULL;\n \n-            int32_t siteIndex = -1;\n-\n-            if (ramMethod != self()->comp()->getCurrentMethod()->getPersistentIdentifier()) // && info->_reloKind != TR_ValidateArbitraryClass)\n+            if (orderedInlinedSiteListTable[inlinedSiteIndex].first)\n                {\n-               int32_t i;\n-               for (i = 0; i < self()->comp()->getNumInlinedCallSites(); i++)\n-                  {\n-                  TR_InlinedCallSite &ics = self()->comp()->getInlinedCallSite(i);\n-                  TR_OpaqueMethodBlock *inlinedMethod = fej9->getInlinedCallSiteMethod(&ics);\n-\n-                  traceMsg(self()->comp(), \"\\tinline site %d inlined method %p\\n\", i, inlinedMethod);\n-                  if (ramMethod == inlinedMethod)\n-                     {\n-                     traceMsg(self()->comp(), \"\\t\\tmatch!\\n\");\n-                     siteIndex = i;\n-                     break;\n-                     }\n-                  }\n-\n-               if (i >= (int32_t) self()->comp()->getNumInlinedCallSites())\n-                  {\n-                  // this assumption isn't associated with a method directly in the compilation\n-                  // so we can't use a constant pool approach to validate: transform into TR_ValidateArbitraryClass\n-                  // kind of overkill for TR_ValidateStaticField, but still correct\n-                  (*info)->_reloKind = TR_ValidateArbitraryClass;\n-                  siteIndex = -1;   // invalidate main compiled method\n-                  traceMsg(self()->comp(), \"\\ttransformed into TR_ValidateArbitraryClass\\n\");\n-                  }\n+               orderedInlinedSiteListTable[inlinedSiteIndex].last->next = entry;\n+               orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n                }\n+            else\n+               {\n+               orderedInlinedSiteListTable[inlinedSiteIndex].first = entry;\n+               orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n+               }\n+            }\n+            break;\n \n-            traceMsg(self()->comp(), \"Found inlined site %d\\n\", siteIndex);\n+         case TR_CheckMethodEnter:\n+         case TR_CheckMethodExit:\n+         case TR_HCR:\n+            cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation((uint8_t *)(*it)->getLocation(),\n+                                                                             (uint8_t *)(*it)->getDestination(),\n+                                                                             type, cg),\n+                             __FILE__, __LINE__, NULL);\n+            break;\n \n-            TR_ASSERT(siteIndex < (int32_t) self()->comp()->getNumInlinedCallSites(), \"did not find AOTClassInfo %p method in inlined site table\", *info);\n+         case TR_NoRelocation:\n+            break;\n \n-            self()->addExternalRelocation(new (self()->trHeapMemory()) TR::ExternalRelocation(NULL,\n-                                                                             (uint8_t *)(intptr_t)siteIndex,\n-                                                                             (uint8_t *)(*info),\n-                                                                             (*info)->_reloKind, self()),\n-                                                                             __FILE__, __LINE__, NULL);\n-            }\n+         default:\n+            TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n+            cg->comp()->failCompilation<J9::AOTRelocationRecordGenerationFailure>(\"Unknown/non-AOT guard at AOT site\");\n+            break;\n          }\n+      }\n+   }\n \n-      // If have inlined calls, now add the relocation records in descending order of inlined site index (at relocation time, the order is reverse)", "originalCommit": "91508c2995a9eb775220cafdee46b72c0e8e8d72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTA2NTM4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561065383", "bodyText": "Not really sure, will add back.", "author": "dsouzai", "createdAt": "2021-01-20T15:42:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyNzcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyODIwMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559828202", "bodyText": "Maybe add a \"should be done first\" to this comment, and explain why?", "author": "mstoodle", "createdAt": "2021-01-18T23:00:10Z", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -2904,281 +2904,303 @@ J9::CodeGenerator::populateOSRBuffer()\n    self()->comp()->getOSRCompilationData()->setMaxScratchBufferSize(maxScratchBufferSize);\n    }\n \n-\n-void\n-J9::CodeGenerator::processRelocations()\n+static void addValidationRecords(TR::CodeGenerator *cg)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->comp()->fe());\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(cg->comp()->fe());\n \n-   //Project neutral non-AOT processRelocation\n-   OMR::CodeGeneratorConnector::processRelocations();\n+   TR::list<TR::AOTClassInfo*>* classInfo = cg->comp()->_aotClassInfo;\n+   if (!classInfo->empty())\n+      {\n+      for (auto info = classInfo->begin(); info != classInfo->end(); ++info)\n+         {\n+         traceMsg(cg->comp(), \"processing AOT class info: %p in %s\\n\", *info, cg->comp()->signature());\n+         traceMsg(cg->comp(), \"ramMethod: %p cp: %p cpIndex: %x relo %d\\n\", (*info)->_method, (*info)->_constantPool, (*info)->_cpIndex, (*info)->_reloKind);\n+         traceMsg(cg->comp(), \"clazz: %p classChain: %p\\n\", (*info)->_clazz, (*info)->_classChain);\n \n-   int32_t missedSite = -1;\n+         TR_OpaqueMethodBlock *ramMethod = (*info)->_method;\n \n-   if (self()->comp()->compileRelocatableCode())\n-      {\n-      uint32_t inlinedCallSize = self()->comp()->getNumInlinedCallSites();\n+         int32_t siteIndex = -1;\n \n-      // Create temporary hashtable for ordering AOT guard relocations\n-      int32_t counter = inlinedCallSize;\n-      TR_InlinedSiteHastTableEntry *orderedInlinedSiteListTable;\n-      if (inlinedCallSize > 0)\n-         {\n-         orderedInlinedSiteListTable= (TR_InlinedSiteHastTableEntry*)self()->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteHastTableEntry) * inlinedCallSize, heapAlloc);\n-         memset(orderedInlinedSiteListTable, 0, sizeof(TR_InlinedSiteHastTableEntry)*inlinedCallSize);\n+         if (ramMethod != cg->comp()->getCurrentMethod()->getPersistentIdentifier()) // && info->_reloKind != TR_ValidateArbitraryClass)\n+            {\n+            int32_t i;\n+            for (i = 0; i < cg->comp()->getNumInlinedCallSites(); i++)\n+               {\n+               TR_InlinedCallSite &ics = cg->comp()->getInlinedCallSite(i);\n+               TR_OpaqueMethodBlock *inlinedMethod = fej9->getInlinedCallSiteMethod(&ics);\n+\n+               traceMsg(cg->comp(), \"\\tinline site %d inlined method %p\\n\", i, inlinedMethod);\n+               if (ramMethod == inlinedMethod)\n+                  {\n+                  traceMsg(cg->comp(), \"\\t\\tmatch!\\n\");\n+                  siteIndex = i;\n+                  break;\n+                  }\n+               }\n+\n+            if (i >= (int32_t) cg->comp()->getNumInlinedCallSites())\n+               {\n+               // this assumption isn't associated with a method directly in the compilation\n+               // so we can't use a constant pool approach to validate: transform into TR_ValidateArbitraryClass\n+               // kind of overkill for TR_ValidateStaticField, but still correct\n+               (*info)->_reloKind = TR_ValidateArbitraryClass;\n+               siteIndex = -1;   // invalidate main compiled method\n+               traceMsg(cg->comp(), \"\\ttransformed into TR_ValidateArbitraryClass\\n\");\n+               }\n+            }\n+\n+         traceMsg(cg->comp(), \"Found inlined site %d\\n\", siteIndex);\n+\n+         TR_ASSERT(siteIndex < (int32_t) cg->comp()->getNumInlinedCallSites(), \"did not find AOTClassInfo %p method in inlined site table\", *info);\n+\n+         cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation(NULL,\n+                                                                          (uint8_t *)(intptr_t)siteIndex,\n+                                                                          (uint8_t *)(*info),\n+                                                                          (*info)->_reloKind, cg),\n+                                                                          __FILE__, __LINE__, NULL);\n          }\n-      else\n-         orderedInlinedSiteListTable = NULL;\n+      }\n+   }\n \n-      TR_InlinedSiteLinkedListEntry *entry = NULL;\n+static void addSVMValidationRecords(TR::CodeGenerator *cg)\n+   {\n+   TR::SymbolValidationManager::SymbolValidationRecordList &validationRecords = cg->comp()->getSymbolValidationManager()->getValidationRecordList();\n+   if (cg->comp()->getOption(TR_UseSymbolValidationManager))\n+      {\n+      // Add the flags in TR_AOTMethodHeader on the compile run\n+      J9JITDataCacheHeader *aotMethodHeader = (J9JITDataCacheHeader *)cg->comp()->getAotMethodDataStart();\n+      TR_AOTMethodHeader *aotMethodHeaderEntry = (TR_AOTMethodHeader *)(aotMethodHeader + 1);\n+      aotMethodHeaderEntry->flags |= TR_AOTMethodHeader_UsesSymbolValidationManager;\n \n-      // Traverse list of AOT-specific guards and create relocation records\n-      TR::list<TR_AOTGuardSite*> *aotGuardSites = self()->comp()->getAOTGuardPatchSites();\n-      for(auto it = aotGuardSites->begin(); it != aotGuardSites->end(); ++it)\n+      for (auto it = validationRecords.begin(); it != validationRecords.end(); it++)\n          {\n-         intptr_t inlinedSiteIndex = -1;\n+         cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation(NULL,\n+                                                                          (uint8_t *)(*it),\n+                                                                          (*it)->_kind, cg),\n+                                                                          __FILE__, __LINE__, NULL);\n+         }\n+      }\n+   }\n \n-         // first, figure out the appropriate relocation record type from the guard type and symbol\n-         TR_ExternalRelocationTargetKind type;\n-         switch ((*it)->getType())\n-            {\n-            case TR_DirectMethodGuard:\n-               if ((*it)->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isStatic())\n-                  type = TR_InlinedStaticMethodWithNopGuard;\n-               else if ((*it)->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isSpecial())\n-                  type = TR_InlinedSpecialMethodWithNopGuard;\n-               else if ((*it)->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isVirtual())\n-                  type = TR_InlinedVirtualMethodWithNopGuard;\n-               else\n-                  TR_ASSERT(0, \"unexpected AOTDirectMethodGuard method symbol\");\n-               break;\n+static TR_ExternalRelocationTargetKind getReloKindFromGuardSite(TR::CodeGenerator *cg, TR_AOTGuardSite *site)\n+   {\n+   TR_ExternalRelocationTargetKind type;\n \n-            case TR_NonoverriddenGuard:\n-               type = TR_InlinedVirtualMethodWithNopGuard;\n-               break;\n-            case TR_RemovedNonoverriddenGuard:\n-               type = TR_InlinedVirtualMethod;\n-               break;\n+   switch (site->getType())\n+      {\n+      case TR_DirectMethodGuard:\n+         if (site->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isStatic())\n+            type = TR_InlinedStaticMethodWithNopGuard;\n+         else if (site->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isSpecial())\n+            type = TR_InlinedSpecialMethodWithNopGuard;\n+         else if (site->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isVirtual())\n+            type = TR_InlinedVirtualMethodWithNopGuard;\n+         else\n+            TR_ASSERT(0, \"unexpected AOTDirectMethodGuard method symbol\");\n+         break;\n \n-            case TR_InterfaceGuard:\n-               type = TR_InlinedInterfaceMethodWithNopGuard;\n-               break;\n-            case TR_RemovedInterfaceGuard:\n-               traceMsg(self()->comp(), \"TR_RemovedInterfaceMethod\\n\");\n-               type = TR_InlinedInterfaceMethod;\n-               break;\n+      case TR_NonoverriddenGuard:\n+         type = TR_InlinedVirtualMethodWithNopGuard;\n+         break;\n+      case TR_RemovedNonoverriddenGuard:\n+         type = TR_InlinedVirtualMethod;\n+         break;\n \n-            case TR_AbstractGuard:\n-               type = TR_InlinedAbstractMethodWithNopGuard;\n-               break;\n+      case TR_InterfaceGuard:\n+         type = TR_InlinedInterfaceMethodWithNopGuard;\n+         break;\n+      case TR_RemovedInterfaceGuard:\n+         traceMsg(cg->comp(), \"TR_RemovedInterfaceMethod\\n\");\n+         type = TR_InlinedInterfaceMethod;\n+         break;\n \n-            case TR_HCRGuard:\n-               // devinmp: TODO/FIXME this should arrange to create an AOT\n-               // relocation which, when loaded, creates a\n-               // TR_PatchNOPedGuardSiteOnClassRedefinition or similar.\n-               // Here we would previously create a TR_HCR relocation,\n-               // which is for replacing J9Class or J9Method pointers.\n-               // These would be the 'unresolved' variant\n-               // (TR_RedefinedClassUPicSite), which would (hopefully) never\n-               // get patched. If it were patched, it seems like it would\n-               // replace code with a J9Method pointer.\n-               if (!self()->comp()->getOption(TR_UseOldHCRGuardAOTRelocations))\n-                  continue;\n-               type = TR_HCR;\n-               break;\n+      case TR_AbstractGuard:\n+         type = TR_InlinedAbstractMethodWithNopGuard;\n+         break;\n \n-            case TR_MethodEnterExitGuard:\n-               if ((*it)->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodEnterHook)\n-                  type = TR_CheckMethodEnter;\n-               else if ((*it)->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodExitHook)\n-                  type = TR_CheckMethodExit;\n-               else\n-                  TR_ASSERT(0,\"Unexpected TR_MethodEnterExitGuard at site %p guard %p node %p\\n\",\n-                                    *it, (*it)->getGuard(), (*it)->getGuard()->getCallNode());\n-               break;\n+      case TR_HCRGuard:\n+         // devinmp: TODO/FIXME this should arrange to create an AOT\n+         // relocation which, when loaded, creates a\n+         // TR_PatchNOPedGuardSiteOnClassRedefinition or similar.\n+         // Here we would previously create a TR_HCR relocation,\n+         // which is for replacing J9Class or J9Method pointers.\n+         // These would be the 'unresolved' variant\n+         // (TR_RedefinedClassUPicSite), which would (hopefully) never\n+         // get patched. If it were patched, it seems like it would\n+         // replace code with a J9Method pointer.\n+         if (!cg->comp()->getOption(TR_UseOldHCRGuardAOTRelocations))\n+            type = TR_NoRelocation;\n+         else\n+            type = TR_HCR;\n+         break;\n \n-            case TR_RemovedProfiledGuard:\n-               traceMsg(self()->comp(), \"TR_ProfiledInlinedMethodRelocation\\n\");\n-               type = TR_ProfiledInlinedMethodRelocation;\n-               break;\n+      case TR_MethodEnterExitGuard:\n+         if (site->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodEnterHook)\n+            type = TR_CheckMethodEnter;\n+         else if (site->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodExitHook)\n+            type = TR_CheckMethodExit;\n+         else\n+            TR_ASSERT(0,\"Unexpected TR_MethodEnterExitGuard at site %p guard %p node %p\\n\",\n+                              *it, site->getGuard(), site->getGuard()->getCallNode());\n+         break;\n \n-            case TR_ProfiledGuard:\n-               if ((*it)->getGuard()->getTestType() == TR_MethodTest)\n-                  {\n-                  type = TR_ProfiledMethodGuardRelocation;\n-                  traceMsg(self()->comp(), \"TR_ProfiledMethodGuardRelocation\\n\");\n-                  }\n-               else if ((*it)->getGuard()->getTestType() == TR_VftTest)\n-                  {\n-                  type = TR_ProfiledClassGuardRelocation;\n-                  traceMsg(self()->comp(), \"TR_ProfiledClassGuardRelocation\\n\");\n-                  }\n-               else\n-                  TR_ASSERT(false, \"unexpected profiled guard test type\");\n-               break;\n+      case TR_RemovedProfiledGuard:\n+         traceMsg(cg->comp(), \"TR_ProfiledInlinedMethodRelocation\\n\");\n+         type = TR_ProfiledInlinedMethodRelocation;\n+         break;\n \n-            default:\n-               TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n-               break;\n+      case TR_ProfiledGuard:\n+         if (site->getGuard()->getTestType() == TR_MethodTest)\n+            {\n+            type = TR_ProfiledMethodGuardRelocation;\n+            traceMsg(cg->comp(), \"TR_ProfiledMethodGuardRelocation\\n\");\n             }\n-\n-         switch (type)  // relocation record type\n+         else if (site->getGuard()->getTestType() == TR_VftTest)\n             {\n-            case TR_InlinedStaticMethodWithNopGuard:\n-            case TR_InlinedSpecialMethodWithNopGuard:\n-            case TR_InlinedVirtualMethodWithNopGuard:\n-            case TR_InlinedInterfaceMethodWithNopGuard:\n-            case TR_InlinedAbstractMethodWithNopGuard:\n-            case TR_ProfiledClassGuardRelocation:\n-            case TR_ProfiledMethodGuardRelocation:\n-            case TR_ProfiledInlinedMethodRelocation:\n-            case TR_InlinedVirtualMethod:\n-            case TR_InlinedInterfaceMethod:\n-               TR_ASSERT(inlinedCallSize, \"TR_AOT expect inlinedCallSize to be larger than 0\\n\");\n-               inlinedSiteIndex = (intptr_t)(*it)->getGuard()->getCurrentInlinedSiteIndex();\n-               entry = (TR_InlinedSiteLinkedListEntry *)self()->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteLinkedListEntry), heapAlloc);\n-\n-               entry->reloType = type;\n-               entry->location = (uint8_t *)(*it)->getLocation();\n-               entry->destination = (uint8_t *)(*it)->getDestination();\n-               entry->guard = (uint8_t *)(*it)->getGuard();\n-               entry->next = NULL;\n-\n-               if (orderedInlinedSiteListTable[inlinedSiteIndex].first)\n-                  {\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].last->next = entry;\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n-                  }\n-               else\n-                  {\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].first = entry;\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n-                  }\n-               break;\n+            type = TR_ProfiledClassGuardRelocation;\n+            traceMsg(cg->comp(), \"TR_ProfiledClassGuardRelocation\\n\");\n+            }\n+         else\n+            TR_ASSERT(false, \"unexpected profiled guard test type\");\n+         break;\n \n-            case TR_CheckMethodEnter:\n-            case TR_CheckMethodExit:\n-            case TR_HCR:\n-               self()->addExternalRelocation(new (self()->trHeapMemory()) TR::ExternalRelocation((uint8_t *)(*it)->getLocation(),\n-                                                                                (uint8_t *)(*it)->getDestination(),\n-                                                                                type, self()),\n-                                __FILE__, __LINE__, NULL);\n-               break;\n+      default:\n+         TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n+         cg->comp()->failCompilation<J9::AOTRelocationRecordGenerationFailure>(\"Unknown/non-AOT guard at AOT site\");\n+         break;\n+      }\n \n-            default:\n-               TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n-               break;\n-            }\n-         }\n+   return type;\n+   }\n \n-      TR::list<TR::AOTClassInfo*>* classInfo = self()->comp()->_aotClassInfo;\n-      if (!classInfo->empty())\n+static void processAOTGuardSites(TR::CodeGenerator *cg, uint32_t inlinedCallSize, TR_InlinedSiteHastTableEntry *orderedInlinedSiteListTable)\n+   {\n+   TR::list<TR_AOTGuardSite*> *aotGuardSites = cg->comp()->getAOTGuardPatchSites();\n+   for(auto it = aotGuardSites->begin(); it != aotGuardSites->end(); ++it)\n+      {\n+      // first, figure out the appropriate relocation record type from the guard type and symbol\n+      TR_ExternalRelocationTargetKind type = getReloKindFromGuardSite(cg, (*it));\n+\n+      switch (type)  // relocation record type\n          {\n-         for (auto info = classInfo->begin(); info != classInfo->end(); ++info)\n+         case TR_InlinedStaticMethodWithNopGuard:\n+         case TR_InlinedSpecialMethodWithNopGuard:\n+         case TR_InlinedVirtualMethodWithNopGuard:\n+         case TR_InlinedInterfaceMethodWithNopGuard:\n+         case TR_InlinedAbstractMethodWithNopGuard:\n+         case TR_ProfiledClassGuardRelocation:\n+         case TR_ProfiledMethodGuardRelocation:\n+         case TR_ProfiledInlinedMethodRelocation:\n+         case TR_InlinedVirtualMethod:\n+         case TR_InlinedInterfaceMethod:\n             {\n-            traceMsg(self()->comp(), \"processing AOT class info: %p in %s\\n\", *info, self()->comp()->signature());\n-            traceMsg(self()->comp(), \"ramMethod: %p cp: %p cpIndex: %x relo %d\\n\", (*info)->_method, (*info)->_constantPool, (*info)->_cpIndex, (*info)->_reloKind);\n-            traceMsg(self()->comp(), \"clazz: %p classChain: %p\\n\", (*info)->_clazz, (*info)->_classChain);\n+            TR_ASSERT(inlinedCallSize, \"TR_AOT expect inlinedCallSize to be larger than 0\\n\");\n+            intptr_t inlinedSiteIndex = (intptr_t)(*it)->getGuard()->getCurrentInlinedSiteIndex();\n+            TR_InlinedSiteLinkedListEntry *entry = (TR_InlinedSiteLinkedListEntry *)cg->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteLinkedListEntry), heapAlloc);\n \n-            TR_OpaqueMethodBlock *ramMethod = (*info)->_method;\n+            entry->reloType = type;\n+            entry->location = (uint8_t *)(*it)->getLocation();\n+            entry->destination = (uint8_t *)(*it)->getDestination();\n+            entry->guard = (uint8_t *)(*it)->getGuard();\n+            entry->next = NULL;\n \n-            int32_t siteIndex = -1;\n-\n-            if (ramMethod != self()->comp()->getCurrentMethod()->getPersistentIdentifier()) // && info->_reloKind != TR_ValidateArbitraryClass)\n+            if (orderedInlinedSiteListTable[inlinedSiteIndex].first)\n                {\n-               int32_t i;\n-               for (i = 0; i < self()->comp()->getNumInlinedCallSites(); i++)\n-                  {\n-                  TR_InlinedCallSite &ics = self()->comp()->getInlinedCallSite(i);\n-                  TR_OpaqueMethodBlock *inlinedMethod = fej9->getInlinedCallSiteMethod(&ics);\n-\n-                  traceMsg(self()->comp(), \"\\tinline site %d inlined method %p\\n\", i, inlinedMethod);\n-                  if (ramMethod == inlinedMethod)\n-                     {\n-                     traceMsg(self()->comp(), \"\\t\\tmatch!\\n\");\n-                     siteIndex = i;\n-                     break;\n-                     }\n-                  }\n-\n-               if (i >= (int32_t) self()->comp()->getNumInlinedCallSites())\n-                  {\n-                  // this assumption isn't associated with a method directly in the compilation\n-                  // so we can't use a constant pool approach to validate: transform into TR_ValidateArbitraryClass\n-                  // kind of overkill for TR_ValidateStaticField, but still correct\n-                  (*info)->_reloKind = TR_ValidateArbitraryClass;\n-                  siteIndex = -1;   // invalidate main compiled method\n-                  traceMsg(self()->comp(), \"\\ttransformed into TR_ValidateArbitraryClass\\n\");\n-                  }\n+               orderedInlinedSiteListTable[inlinedSiteIndex].last->next = entry;\n+               orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n                }\n+            else\n+               {\n+               orderedInlinedSiteListTable[inlinedSiteIndex].first = entry;\n+               orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n+               }\n+            }\n+            break;\n \n-            traceMsg(self()->comp(), \"Found inlined site %d\\n\", siteIndex);\n+         case TR_CheckMethodEnter:\n+         case TR_CheckMethodExit:\n+         case TR_HCR:\n+            cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation((uint8_t *)(*it)->getLocation(),\n+                                                                             (uint8_t *)(*it)->getDestination(),\n+                                                                             type, cg),\n+                             __FILE__, __LINE__, NULL);\n+            break;\n \n-            TR_ASSERT(siteIndex < (int32_t) self()->comp()->getNumInlinedCallSites(), \"did not find AOTClassInfo %p method in inlined site table\", *info);\n+         case TR_NoRelocation:\n+            break;\n \n-            self()->addExternalRelocation(new (self()->trHeapMemory()) TR::ExternalRelocation(NULL,\n-                                                                             (uint8_t *)(intptr_t)siteIndex,\n-                                                                             (uint8_t *)(*info),\n-                                                                             (*info)->_reloKind, self()),\n-                                                                             __FILE__, __LINE__, NULL);\n-            }\n+         default:\n+            TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n+            cg->comp()->failCompilation<J9::AOTRelocationRecordGenerationFailure>(\"Unknown/non-AOT guard at AOT site\");\n+            break;\n          }\n+      }\n+   }\n \n-      // If have inlined calls, now add the relocation records in descending order of inlined site index (at relocation time, the order is reverse)\n-      if (inlinedCallSize > 0)\n+static void addInliningTableRelocations(TR::CodeGenerator *cg, uint32_t inlinedCallSize, TR_InlinedSiteHastTableEntry *orderedInlinedSiteListTable)\n+   {\n+   if (inlinedCallSize > 0)\n+      {\n+      for (int32_t counter = inlinedCallSize - 1; counter >= 0 ; counter--)\n          {\n-         counter= inlinedCallSize - 1;\n-         int numSitesAdded = 0;\n-         for (; counter >= 0 ; counter--)\n+         TR_InlinedSiteLinkedListEntry *currentSite = orderedInlinedSiteListTable[counter].first;\n+         while (currentSite)\n             {\n-            TR_InlinedSiteLinkedListEntry *currentSite = orderedInlinedSiteListTable[counter].first;\n-            if (!currentSite)\n-               missedSite = counter;\n-\n-            while (currentSite)\n-               {\n-               self()->addExternalRelocation(new (self()->trHeapMemory()) TR::ExternalRelocation(currentSite->location,\n-                                                                                currentSite->destination,\n-                                                                                currentSite->guard,\n-                                                                                currentSite->reloType, self()),\n-                               __FILE__,__LINE__, NULL);\n-               currentSite = currentSite->next;\n-               numSitesAdded++;\n-               }\n+            cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation(currentSite->location,\n+                                                                             currentSite->destination,\n+                                                                             currentSite->guard,\n+                                                                             currentSite->reloType, cg),\n+                            __FILE__,__LINE__, NULL);\n+            currentSite = currentSite->next;\n             }\n          }\n       }\n+   }\n+\n+void\n+J9::CodeGenerator::processRelocations()\n+   {\n+   //Project neutral non-AOT processRelocation\n+   OMR::CodeGeneratorConnector::processRelocations();", "originalCommit": "91508c2995a9eb775220cafdee46b72c0e8e8d72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyOTIyOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559829228", "bodyText": "better not have virtual methods (i'm sure it doesn't, but...)", "author": "mstoodle", "createdAt": "2021-01-18T23:04:58Z", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -3137,21 +3137,53 @@ static void processAOTGuardSites(TR::CodeGenerator *cg, uint32_t inlinedCallSize\n       }\n    }\n \n+static void addInlinedSiteRelocation(TR::CodeGenerator *cg,\n+                                     TR_ExternalRelocationTargetKind reloType,\n+                                     uint8_t *reloLocation,\n+                                     int32_t inlinedSiteIndex,\n+                                     TR::SymbolReference *callSymref,\n+                                     TR_OpaqueClassBlock *receiver,\n+                                     uint8_t *destinationAddress)\n+   {\n+   TR_ASSERT_FATAL(reloType != TR_NoRelocation, \"TR_NoRelocation specified as reloType for inlinedSiteIndex=%d, reloLocation=%p, callSymref=%p, receiver=%p\",\n+                   inlinedSiteIndex, reloLocation, callSymref, receiver);\n+\n+   TR_RelocationRecordInformation *info = (TR_RelocationRecordInformation *)cg->comp()->region().allocate(sizeof(TR_RelocationRecordInformation));", "originalCommit": "daddd669abc7c68f64cd9108f4a62e68239df4ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTA2NjIwOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561066209", "bodyText": "you mean allocate()? It doesn't, but if it did, would it be a problem? All other parts of the code would also be using the same allocate() right?", "author": "dsouzai", "createdAt": "2021-01-20T15:43:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyOTIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM1MzA0MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561353040", "bodyText": "i meant TR_RelocationRecordInformation. Wouldn't it be better to initialize this structure with a placement new, which would also have the benefit of initializing any vft needed? I'm not that concerned about it, but it's not a completely outrageous evolution someone could dream up :) .", "author": "mstoodle", "createdAt": "2021-01-20T22:36:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyOTIyOA=="}], "type": "inlineReview"}, {"oid": "eb5edf98728d6f7bac9013810e2efc2711969cc9", "url": "https://github.com/eclipse-openj9/openj9/commit/eb5edf98728d6f7bac9013810e2efc2711969cc9", "message": "Update Copyrights\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2021-01-20T16:25:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTEyODU3Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561128572", "bodyText": "We were never calling TR_RelocationRecordInlinedVirtualMethod::getMethodFromCP when the relo kind was TR_InlinedVirtualMethod because this virtual method was missing the TR_OpaqueMethodBlock *callerMethod param; TR_RelocationRecordInlinedMethod::getMethodFromCP ended up getting called, which would just cause a load failure...", "author": "dsouzai", "createdAt": "2021-01-20T17:03:29Z", "path": "runtime/compiler/runtime/RelocationRecord.cpp", "diffHunk": "@@ -2973,20 +3009,8 @@ TR_RelocationRecordInlinedVirtualMethod::name()\n    return \"TR_InlinedVirtualMethod\";\n    }\n \n-void\n-TR_RelocationRecordInlinedVirtualMethod::print(TR_RelocationRuntime *reloRuntime)\n-   {\n-   Base::print(reloRuntime);\n-   }\n-\n-void\n-TR_RelocationRecordInlinedVirtualMethod::preparePrivateData(TR_RelocationRuntime *reloRuntime, TR_RelocationTarget *reloTarget)\n-   {\n-   Base::preparePrivateData(reloRuntime, reloTarget);\n-   }\n-\n TR_OpaqueMethodBlock *\n-TR_RelocationRecordInlinedVirtualMethod::getMethodFromCP(TR_RelocationRuntime *reloRuntime, void *void_cp, int32_t cpIndex)\n+TR_RelocationRecordInlinedVirtualMethod::getMethodFromCP(TR_RelocationRuntime *reloRuntime, void *void_cp, int32_t cpIndex, TR_OpaqueMethodBlock *callerMethod)", "originalCommit": "eb5edf98728d6f7bac9013810e2efc2711969cc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM0MzM1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561343355", "bodyText": "do you still need this typedef?", "author": "mstoodle", "createdAt": "2021-01-20T22:16:40Z", "path": "runtime/compiler/runtime/RelocationRecord.hpp", "diffHunk": "@@ -808,6 +808,17 @@ class TR_RelocationRecordInlinedStaticMethodWithNopGuard : public TR_RelocationR\n       virtual void updateSucceededStats(TR_AOTStats *aotStats);\n    };\n \n+class TR_RelocationRecordInlinedStaticMethod: public TR_RelocationRecordInlinedMethod\n+   {\n+   typedef TR_RelocationRecordInlinedMethod Base;", "originalCommit": "c6133fe4ea478b87b12b485ba2e1e204be566a5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM0MzY0MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561343640", "bodyText": "do you still need this typedef?", "author": "mstoodle", "createdAt": "2021-01-20T22:17:12Z", "path": "runtime/compiler/runtime/RelocationRecord.hpp", "diffHunk": "@@ -890,6 +908,17 @@ class TR_RelocationRecordInlinedAbstractMethodWithNopGuard : public TR_Relocatio\n       virtual void createAssumptions(TR_RelocationRuntime *reloRuntime, uint8_t *reloLocation);\n    };\n \n+class TR_RelocationRecordInlinedAbstractMethod: public TR_RelocationRecordInlinedMethod\n+   {\n+   typedef TR_RelocationRecordInlinedMethod Base;", "originalCommit": "c6133fe4ea478b87b12b485ba2e1e204be566a5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM0NzY1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561347656", "bodyText": "by your earlier logic, wouldn't this list be empty if not using SVM?", "author": "mstoodle", "createdAt": "2021-01-20T22:25:51Z", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -2904,281 +2904,308 @@ J9::CodeGenerator::populateOSRBuffer()\n    self()->comp()->getOSRCompilationData()->setMaxScratchBufferSize(maxScratchBufferSize);\n    }\n \n-\n-void\n-J9::CodeGenerator::processRelocations()\n+static void addValidationRecords(TR::CodeGenerator *cg)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->comp()->fe());\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(cg->comp()->fe());\n \n-   //Project neutral non-AOT processRelocation\n-   OMR::CodeGeneratorConnector::processRelocations();\n+   TR::list<TR::AOTClassInfo*>* classInfo = cg->comp()->_aotClassInfo;\n+   if (!classInfo->empty())\n+      {\n+      for (auto info = classInfo->begin(); info != classInfo->end(); ++info)\n+         {\n+         traceMsg(cg->comp(), \"processing AOT class info: %p in %s\\n\", *info, cg->comp()->signature());\n+         traceMsg(cg->comp(), \"ramMethod: %p cp: %p cpIndex: %x relo %d\\n\", (*info)->_method, (*info)->_constantPool, (*info)->_cpIndex, (*info)->_reloKind);\n+         traceMsg(cg->comp(), \"clazz: %p classChain: %p\\n\", (*info)->_clazz, (*info)->_classChain);\n \n-   int32_t missedSite = -1;\n+         TR_OpaqueMethodBlock *ramMethod = (*info)->_method;\n \n-   if (self()->comp()->compileRelocatableCode())\n-      {\n-      uint32_t inlinedCallSize = self()->comp()->getNumInlinedCallSites();\n+         int32_t siteIndex = -1;\n \n-      // Create temporary hashtable for ordering AOT guard relocations\n-      int32_t counter = inlinedCallSize;\n-      TR_InlinedSiteHastTableEntry *orderedInlinedSiteListTable;\n-      if (inlinedCallSize > 0)\n-         {\n-         orderedInlinedSiteListTable= (TR_InlinedSiteHastTableEntry*)self()->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteHastTableEntry) * inlinedCallSize, heapAlloc);\n-         memset(orderedInlinedSiteListTable, 0, sizeof(TR_InlinedSiteHastTableEntry)*inlinedCallSize);\n+         if (ramMethod != cg->comp()->getCurrentMethod()->getPersistentIdentifier()) // && info->_reloKind != TR_ValidateArbitraryClass)\n+            {\n+            int32_t i;\n+            for (i = 0; i < cg->comp()->getNumInlinedCallSites(); i++)\n+               {\n+               TR_InlinedCallSite &ics = cg->comp()->getInlinedCallSite(i);\n+               TR_OpaqueMethodBlock *inlinedMethod = fej9->getInlinedCallSiteMethod(&ics);\n+\n+               traceMsg(cg->comp(), \"\\tinline site %d inlined method %p\\n\", i, inlinedMethod);\n+               if (ramMethod == inlinedMethod)\n+                  {\n+                  traceMsg(cg->comp(), \"\\t\\tmatch!\\n\");\n+                  siteIndex = i;\n+                  break;\n+                  }\n+               }\n+\n+            if (i >= (int32_t) cg->comp()->getNumInlinedCallSites())\n+               {\n+               // this assumption isn't associated with a method directly in the compilation\n+               // so we can't use a constant pool approach to validate: transform into TR_ValidateArbitraryClass\n+               // kind of overkill for TR_ValidateStaticField, but still correct\n+               (*info)->_reloKind = TR_ValidateArbitraryClass;\n+               siteIndex = -1;   // invalidate main compiled method\n+               traceMsg(cg->comp(), \"\\ttransformed into TR_ValidateArbitraryClass\\n\");\n+               }\n+            }\n+\n+         traceMsg(cg->comp(), \"Found inlined site %d\\n\", siteIndex);\n+\n+         TR_ASSERT(siteIndex < (int32_t) cg->comp()->getNumInlinedCallSites(), \"did not find AOTClassInfo %p method in inlined site table\", *info);\n+\n+         cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation(NULL,\n+                                                                          (uint8_t *)(intptr_t)siteIndex,\n+                                                                          (uint8_t *)(*info),\n+                                                                          (*info)->_reloKind, cg),\n+                                                                          __FILE__, __LINE__, NULL);\n          }\n-      else\n-         orderedInlinedSiteListTable = NULL;\n+      }\n+   }\n \n-      TR_InlinedSiteLinkedListEntry *entry = NULL;\n+static void addSVMValidationRecords(TR::CodeGenerator *cg)\n+   {\n+   TR::SymbolValidationManager::SymbolValidationRecordList &validationRecords = cg->comp()->getSymbolValidationManager()->getValidationRecordList();\n+   if (cg->comp()->getOption(TR_UseSymbolValidationManager))", "originalCommit": "78dd9660c0fb96f73cb7707c0472c914eb839753", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTk4NjgzMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561986830", "bodyText": "Yeah, same idea. However, the reason why they're two different functions is because the traditional validation records are added after relo records but before the inlining table records, whereas the SVM records are added after the inlining table records.", "author": "dsouzai", "createdAt": "2021-01-21T15:47:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM0NzY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM1MzE4OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561353189", "bodyText": "do you still need this typedef?", "author": "mstoodle", "createdAt": "2021-01-20T22:37:01Z", "path": "runtime/compiler/runtime/RelocationRecord.hpp", "diffHunk": "@@ -822,6 +833,17 @@ class TR_RelocationRecordInlinedSpecialMethodWithNopGuard : public TR_Relocation\n       virtual void updateSucceededStats(TR_AOTStats *aotStats);\n    };\n \n+class TR_RelocationRecordInlinedSpecialMethod: public TR_RelocationRecordInlinedMethod\n+   {\n+   typedef TR_RelocationRecordInlinedMethod Base;", "originalCommit": "c6133fe4ea478b87b12b485ba2e1e204be566a5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3fabfc9e6525df75821ec88f1130c2f02398d24e", "url": "https://github.com/eclipse-openj9/openj9/commit/3fabfc9e6525df75821ec88f1130c2f02398d24e", "message": "Update Documentation\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2021-01-21T22:49:38Z", "type": "forcePushed"}, {"oid": "5069cdbbaca1b0baf8165221be02bcd8628d35d7", "url": "https://github.com/eclipse-openj9/openj9/commit/5069cdbbaca1b0baf8165221be02bcd8628d35d7", "message": "Add new relocation records for inlined methods without guards\n\nCurrently, there is a coupling between the relocation of the inlining\ntable in the J9JITExceptionTable struct and inlined method guards; as a\nconsequence, if a guard was removed in a way that the AOT infrastructure\nwas not aware of, the associated inlined method would not get relocated.\n\nThis commit facilitates removing the dependence on guards by adding\nrelocation records for inlined methods that may not have a guard. There\nalready exists such records for Interface and Virtual methods; this\ncommit adds records for Special, Static, and Abstract methods as well.\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2021-01-25T15:38:21Z", "type": "commit"}, {"oid": "980caa46c59bc81721048b82ab570f82a54b4ef6", "url": "https://github.com/eclipse-openj9/openj9/commit/980caa46c59bc81721048b82ab570f82a54b4ef6", "message": "Add missing param to TR_RelocationRecordInlinedVirtualMethod::getMethodFromCP\n\nBecause TR_RelocationRecordInlinedVirtualMethod::getMethodFromCP was\nmissing the currentMethod param, when the relo type is\nTR_InlinedVirtualMethod, the call to getMethodFromCP ends up going to\nTR_RelocationRecordInlinedMethod::getMethodFromCP which unconditionally\nreturns NULL, which ensures that the AOT load fails. This commit fixes\nthis bug.\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2021-01-25T15:38:21Z", "type": "commit"}, {"oid": "d59736636815c7492aaf9152c6cd5c92d8ca712e", "url": "https://github.com/eclipse-openj9/openj9/commit/d59736636815c7492aaf9152c6cd5c92d8ca712e", "message": "Use new incInlineDepth API\n\nUse the new incInlineDepth API to ensure that the inlined site contains\nall the information needed for relocation in case a guard does not exist\nfor that site. Additionally, add an assert in the old API to ensure that\nit is not called except for when the callsite is not actually\nincremented (such as when estimating the bytecode size in the inliner\nprior to actually inlining).\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2021-01-25T15:38:21Z", "type": "commit"}, {"oid": "687ef46f94c0668c8c315ad270e7b31875c790f8", "url": "https://github.com/eclipse-openj9/openj9/commit/687ef46f94c0668c8c315ad270e7b31875c790f8", "message": "Extend API to provide relo type for method to be inlined\n\nThe default implementation in OMR is to return TR_NoRelocation. However,\nin OpenJ9 we need to be able to specify the relo type for the current\ninlined site in case there isn't a guard available. Therefore, this API\nis extended to determine the type of the relocation needed.\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2021-01-25T15:38:21Z", "type": "commit"}, {"oid": "289a3bd186f7b39bc917b332c11e0ef08112d5c1", "url": "https://github.com/eclipse-openj9/openj9/commit/289a3bd186f7b39bc917b332c11e0ef08112d5c1", "message": "Refactor J9::CodeGenerator::processRelocations\n\nprocessRelocations is a very big method that does a lot of different\ntasks. In order to make the code easier to read, this commit refactors\nthis method. Now, each helper method has a well defined role.\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2021-01-25T15:38:21Z", "type": "commit"}, {"oid": "cddde8f61e662dff2babae13932710020d7d786a", "url": "https://github.com/eclipse-openj9/openj9/commit/cddde8f61e662dff2babae13932710020d7d786a", "message": "Change data passed in to inlining table relocations\n\nBecause an inlined site may not have a guard, this commit changes the\ndata that's passed in when creating the external relocation. Previously\nthe virtual guard would be passed in, which would be used to acquire all\nthe necessary information; now the data is put into a\nTR_RelocationRecordInformation struct first, and this struct is passed\ninto the external relocation.\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2021-01-25T15:38:21Z", "type": "commit"}, {"oid": "f3b48881dea2a604731d2240f1d92b11e6cbff06", "url": "https://github.com/eclipse-openj9/openj9/commit/f3b48881dea2a604731d2240f1d92b11e6cbff06", "message": "Increment JITServer Minor Version\n\nChange in relocation requires a change to the minor version.\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2021-01-25T15:38:37Z", "type": "commit"}, {"oid": "718d069d1a36db9264ce56fb15bc71a857182764", "url": "https://github.com/eclipse-openj9/openj9/commit/718d069d1a36db9264ce56fb15bc71a857182764", "message": "Update Copyrights\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2021-01-25T15:39:42Z", "type": "commit"}, {"oid": "bc3e5dd2cb66ef40b5bb3e37ed37900b66559e4a", "url": "https://github.com/eclipse-openj9/openj9/commit/bc3e5dd2cb66ef40b5bb3e37ed37900b66559e4a", "message": "Update Documentation\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2021-01-25T15:39:42Z", "type": "commit"}, {"oid": "bc3e5dd2cb66ef40b5bb3e37ed37900b66559e4a", "url": "https://github.com/eclipse-openj9/openj9/commit/bc3e5dd2cb66ef40b5bb3e37ed37900b66559e4a", "message": "Update Documentation\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2021-01-25T15:39:42Z", "type": "forcePushed"}]}