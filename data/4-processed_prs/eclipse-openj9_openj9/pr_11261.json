{"pr_number": 11261, "pr_title": "Stash the right number of arguments for invokehandle/invokedynamic", "pr_createdAt": "2020-11-24T16:41:04Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/11261", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIzNTc1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11261#discussion_r534235750", "bodyText": "I think the comment you have in your commit message is a better description of this code.  Could you use something like that instead?\n// invokehandle/invokedynamic bytecode implicitly push an object from side\n// table as the last argument of the call. This is part of the behavior of\n// the bytecode in OpenJDK MethodHandle implementation. The object should\n// not be stashed because the interpreter will load the object itself.\n//", "author": "0xdaryl", "createdAt": "2020-12-02T15:01:39Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -1672,6 +1672,15 @@ TR_J9ByteCodeIlGenerator::stashArgumentsForOSR(TR_J9ByteCode byteCode)\n    TR::MethodSymbol *symbol = symRef->getSymbol()->castToMethodSymbol();\n    int32_t numArgs = symbol->getMethod()->numberOfExplicitParameters() + (symbol->isStatic() ? 0 : 1);\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   // The method expects one more argument than we need to stashed, which is the appendix object\n+   // from side table. Interpreter will load the object itself", "originalCommit": "7d256a8fe0c783052923b57f15bd2f2b99d8cedf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3MTgwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11261#discussion_r534371806", "bodyText": "Thanks. I've put more detailed comment there", "author": "liqunl", "createdAt": "2020-12-02T18:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIzNTc1MA=="}], "type": "inlineReview"}, {"oid": "b53faa9e4a6ff22bb97e16da1179478b03c8c497", "url": "https://github.com/eclipse-openj9/openj9/commit/b53faa9e4a6ff22bb97e16da1179478b03c8c497", "message": "Stash the right number of arguments for invokehandle/invokedyhamic\n\ninvokehandle/invokedynamic bytecode implicitly push an object from side\ntable as the last argument of the call. This is part of the behavior of\nthe bytecode in Openjdk MethodHandle implementation. The object should\nnot be stashed.\n\nThe unresolved case will have one more implicit argument pushed onto the\nstack, as the MemberName from side table is unknown, the target method\nis not known at compile time, thus, the JIT uses\nMethodHandle.linkToStatic to represent the call. linkToStatic expects\nthe last argument to be MemberName object.\n\nSigned-off-by: Liqun Liu <liqunl@ca.ibm.com>", "committedDate": "2020-12-02T18:00:05Z", "type": "forcePushed"}, {"oid": "d49096b3f686341762767fef4069510abb105f8a", "url": "https://github.com/eclipse-openj9/openj9/commit/d49096b3f686341762767fef4069510abb105f8a", "message": "Stash the right number of arguments for invokehandle/invokedyhamic\n\ninvokehandle/invokedynamic bytecode implicitly push an object from side\ntable as the last argument of the call. This is part of the behavior of\nthe bytecode in Openjdk MethodHandle implementation. The object should\nnot be stashed.\n\nThe unresolved case will have one more implicit argument pushed onto the\nstack, as the MemberName from side table is unknown, the target method\nis not known at compile time, thus, the JIT uses\nMethodHandle.linkToStatic to represent the call. linkToStatic expects\nthe last argument to be MemberName object.\n\nSigned-off-by: Liqun Liu <liqunl@ca.ibm.com>", "committedDate": "2021-03-11T18:21:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM0MTEzNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11261#discussion_r603341135", "bodyText": "sp:  whether", "author": "0xdaryl", "createdAt": "2021-03-29T14:26:51Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -1672,6 +1674,36 @@ TR_J9ByteCodeIlGenerator::stashArgumentsForOSR(TR_J9ByteCode byteCode)\n    TR::MethodSymbol *symbol = symRef->getSymbol()->castToMethodSymbol();\n    int32_t numArgs = symbol->getMethod()->numberOfExplicitParameters() + (symbol->isStatic() ? 0 : 1);\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   // invokehandle/invokedynamic bytecode implicitly push an object from side\n+   // table as the last argument of the call. This is part of the behavior of\n+   // the bytecode in Openjdk MethodHandle implementation. The object should\n+   // not be stashed.\n+   // The unresolved case will have one more implicit argument pushed onto the stack,\n+   // as the MemberName from side table is unknown, the target method is not known at\n+   // compile time, thus, the JIT uses MethodHandle.linkToStatic to represent the call.\n+   // MethodHandle.linkToStatic expects the last argument to be MemberName object\n+   //\n+   // Resolved case:\n+   // adapter(arg1, arg2, ..., argN, appendixObject)\n+   // Unresolved case:\n+   // MethodHandle.linkToStatic(arg1, arg2, ..., argN, appendixObject, MemberName)\n+   //\n+   // Notice that we always generate a resolved call, thus we use unresolvedInCP to tell\n+   // us whehter the side table entry is resolved", "originalCommit": "d49096b3f686341762767fef4069510abb105f8a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM1MTQ4Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11261#discussion_r603351487", "bodyText": "Can you also make it clear in the comment here that the MemberName object isn't being stashed either.  At least that's what I think is happening based on the code below.", "author": "0xdaryl", "createdAt": "2021-03-29T14:39:23Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -1672,6 +1674,36 @@ TR_J9ByteCodeIlGenerator::stashArgumentsForOSR(TR_J9ByteCode byteCode)\n    TR::MethodSymbol *symbol = symRef->getSymbol()->castToMethodSymbol();\n    int32_t numArgs = symbol->getMethod()->numberOfExplicitParameters() + (symbol->isStatic() ? 0 : 1);\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   // invokehandle/invokedynamic bytecode implicitly push an object from side\n+   // table as the last argument of the call. This is part of the behavior of\n+   // the bytecode in Openjdk MethodHandle implementation. The object should\n+   // not be stashed.\n+   // The unresolved case will have one more implicit argument pushed onto the stack,\n+   // as the MemberName from side table is unknown, the target method is not known at\n+   // compile time, thus, the JIT uses MethodHandle.linkToStatic to represent the call.\n+   // MethodHandle.linkToStatic expects the last argument to be MemberName object", "originalCommit": "d49096b3f686341762767fef4069510abb105f8a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a9712c257c40653bdeea158bc43f530249d8dbc8", "url": "https://github.com/eclipse-openj9/openj9/commit/a9712c257c40653bdeea158bc43f530249d8dbc8", "message": "Stash the right number of arguments for invokehandle/invokedynamic\n\nIf the transition target is invokehandle/invokedynamic, the arguments to\nbe stashed are those already pushed onto the stack before generating the\nbytecode, regardless of the number of arguments needed by the generated\ncall.\n\nThe generated call requires one (in resolved case) or two (in unresolved\ncase) implicit arguments, so we need to substract them to get the actual\nnumber of arguments needed.\n\nThe reason why we don't need to stash the implicit arguments is because\nwhen we transition to the VM, VM will push the implicit argument onto\nthe stack which is part of the behavior of the\ninvokehandle/invokedynamic bytecode.\n\nSigned-off-by: Liqun Liu <liqunl@ca.ibm.com>", "committedDate": "2021-03-30T01:56:54Z", "type": "commit"}, {"oid": "a9712c257c40653bdeea158bc43f530249d8dbc8", "url": "https://github.com/eclipse-openj9/openj9/commit/a9712c257c40653bdeea158bc43f530249d8dbc8", "message": "Stash the right number of arguments for invokehandle/invokedynamic\n\nIf the transition target is invokehandle/invokedynamic, the arguments to\nbe stashed are those already pushed onto the stack before generating the\nbytecode, regardless of the number of arguments needed by the generated\ncall.\n\nThe generated call requires one (in resolved case) or two (in unresolved\ncase) implicit arguments, so we need to substract them to get the actual\nnumber of arguments needed.\n\nThe reason why we don't need to stash the implicit arguments is because\nwhen we transition to the VM, VM will push the implicit argument onto\nthe stack which is part of the behavior of the\ninvokehandle/invokedynamic bytecode.\n\nSigned-off-by: Liqun Liu <liqunl@ca.ibm.com>", "committedDate": "2021-03-30T01:56:54Z", "type": "forcePushed"}]}