{"pr_number": 10143, "pr_title": "Relax condition to require no exclusive VM access when generating jitdump", "pr_createdAt": "2020-07-10T16:46:48Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10143", "timeline": [{"oid": "6da9b376d25f86cfb70e7fb9f06b9b6a7572e01e", "url": "https://github.com/eclipse-openj9/openj9/commit/6da9b376d25f86cfb70e7fb9f06b9b6a7572e01e", "message": "Fix deadlock during jitdump when compilation thread releases VM access\n\nThis change fixes a deadlock which can occur where a thread is trying\nto acquire exclusive VM access but is unable to. The following\nconditions can be observed:\n\n- GC thread is attempting to acquire exclusive, but it is waiting for\n`vm->exclusiveAccessResponseCount` to be zero\n- All compilation threads except one are stuck waiting on the dump\nmonitor to trigger a dump agent\n- One thread is executing the jitdump and it has just released VM\naccess and is waiting on the diagnostic thread to finish compiling the\nqueued JIT method on the compilation queue\n- The diagnostic thread is attempting to process the compilation queue\nbut it attempts to acquire VM access, so it blocks because GC wants\nexclusive\n\nThis three way deadlock can be resolved by allowing the GC to acquire\nexclusive VM access. The reason it is unable to is because the jitdump\nthread (crashed thread) has released VM access even though it was not\nholding it in the first place. This decrements\n`vm->exclusiveAccessResponseCount` one too many times and the GC thread\nis unable to acquire exclusive access so that everyone can proceed.\n\nThe fix is to simply acquire VM access before requesting the jitdump\nrecompilation since we will go down a code path that assumes we have VM\naccess already. i.e. synchronous compilations are synonymous with\nrequesting the compile on an application thread, which should always\nhold (non-exclusive) VM access.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>", "committedDate": "2020-07-10T16:42:22Z", "type": "commit"}, {"oid": "da80b48bf0d176510d5e2801a1d5a14794ebeeae", "url": "https://github.com/eclipse-openj9/openj9/commit/da80b48bf0d176510d5e2801a1d5a14794ebeeae", "message": "Fix deadlock during jitdump when a compilation interruption occurs\n\nThis change fixes a deadlock which can occur right before the VM is\nabout to terminate. The following conditions can be observed:\n\n- The jitdump file contains `=== EXCEPTION THROWN (JIT Shutdown) ===`\nor similar message\n- The crashed thread is generating the jitdump and an interruption\nexception is thrown forcing the thread to shut down\n- A number of other compilation threads have crashed and are waiting to\nacquire the dump lock so they can execute their dump agents\n\nThe deadlock happens because the thread generating the jitdump has not\nunwound the stack to release the dump lock and so the other crashed\nthreads can never proceed. The exception that is most commonly thrown\nis the `JitShutdown` exception which is thrown in\n`acquireVMaccessIfNeeded` when we check if the compilation should be\ninterrupted. The location where we try to acquire VM access is on the\npath which dumps Known Object Table during the jitdump process. Because\nwe are lacking a try/catch block around this piece of code, any\nexception which occurs will flow up and past the dump locking code in\n`dmpagent.c`, and all the way past the crash point until we reach the\ncatch handler in the crashed thread. This means the dump lock never\ngets released and we are in a deadlock situation with other crashed\nthreads just waiting around.\n\nThe fix is to simply wrap the jitdump process in a try/catch block and\nhandle such exceptions by reporting the error and aborting the jitdump\nprocess.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>", "committedDate": "2020-07-10T16:42:22Z", "type": "commit"}, {"oid": "b3a17a11503440154815fceda40aff01bb6e4400", "url": "https://github.com/eclipse-openj9/openj9/commit/b3a17a11503440154815fceda40aff01bb6e4400", "message": "Fix deadlock when VM access is requested while freeing the KOT\n\nThis change fixes a deadlock which can occur when freeing the Known\nObject Table (KOT). The following conditions can be observed:\n\n- The application thread wants to queue an asynchronous compile, but it\ncan't because it wants to acquire the comp monitor which the diagnostic\nthread owns\n- The diagnostic thread acquired the comp monitor in\n`postCompilationTasks` and is trying to free the known object table,\nfor which it requires VM access. It tries to get it but it can't\nbecause some other compilation thread has requested exclusive.\n- The compilation thread which requested exclusive is trying to reserve\na codecache but it can't get exclusive because the application thread\nhas VM access since it is still executing\n\nThis results in a three way deadlock. The fix here is to ensure in the\nlocations where we free the KOT we do not hold the comp monitor before\nacquiring VM access. To ensure no future bugs occur in this area we\nalso add a fatal assert in the VM access acquire logic to ensure the\ncomp monitor is not held.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>", "committedDate": "2020-07-10T16:42:22Z", "type": "commit"}, {"oid": "e1582c84de0b6d7b84671801eb327dc1bd5b0b82", "url": "https://github.com/eclipse-openj9/openj9/commit/e1582c84de0b6d7b84671801eb327dc1bd5b0b82", "message": "Relax condition to require exclusive VM access when generating jitdump\n\nNow that all known deadlock situations have been fixed we can relax the\ncondition that no thread is holding exclusive VM access when generating\nthe jitdump. The process should still work even if some thread is\nholding exclusive VM access.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>", "committedDate": "2020-07-10T16:42:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk1NzY4NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10143#discussion_r452957684", "bodyText": "Curious why are we not calling postCompilationTasks here instead?", "author": "fjeremic", "createdAt": "2020-07-10T16:48:33Z", "path": "runtime/compiler/control/CompilationThread.cpp", "diffHunk": "@@ -8654,6 +8659,8 @@ TR::CompilationInfoPerThreadBase::wrappedCompile(J9PortLibrary *portLib, void *\n \n       if (compiler)\n          {\n+         // The KOT needs to survive at least until we're done committing virtual guards and we must not be holding the\n+         // comp monitor prior to freeing the KOT because it requires VM access.\n          if (compiler->getKnownObjectTable())\n             compiler->freeKnownObjectTable();", "originalCommit": "e1582c84de0b6d7b84671801eb327dc1bd5b0b82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk2NDI4NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10143#discussion_r452964285", "bodyText": "postCompilationTasks is relatively new; it was code that was refactored to cover a gap in the exception handling (see #1118). As such, I refactored the code to not change the order in which things happen. It might be possible to make the call here but I would have to read the code in detail.", "author": "dsouzai", "createdAt": "2020-07-10T17:01:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk1NzY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk1ODg0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10143#discussion_r452958843", "bodyText": "The releaseVMAccess macro that we call in compileOnSeparateThread should have asserted I would have thought, because prior to this change we would not have held VM access while trying to release it. Any ideas why we don't assert in today's world?", "author": "fjeremic", "createdAt": "2020-07-10T16:50:49Z", "path": "runtime/compiler/control/JitDump.cpp", "diffHunk": "@@ -526,174 +517,198 @@ runJitdump(char *label, J9RASdumpContext *context, J9RASdumpAgent *agent)\n       compInfo->releaseCompMonitor(crashedThread);\n       }\n \n-   // if our compinfo is null, we are an application thread\n-   if (threadCompInfo == 0)\n+   try\n       {\n-      if (options->getVerboseOption(TR_VerboseDump))\n-         TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"Crashed in application thread\");\n-      trfprintf(logFile, \"#INFO: Crashed in application thread %p.\\n\", crashedThread);\n-\n-      // only bother doing anything if we have a healthy compilation thread available\n-      if (recompilationThread)\n+      // if our compinfo is null, we are an application thread\n+      if (threadCompInfo == 0)\n          {\n-         // make space for methods to be recompiled\n-         // FIXME: this is on the stack... is the stack big enough?\n-         int currentMethodIndex = 0;\n-         TR_MethodToBeCompiledForDump jittedMethodsOnStack[STACK_WALK_DEPTH] = { 0 };\n-\n-         // set up the stack walk object\n-         J9StackWalkState walkState;\n-\n-         walkState.userData1 = (void *)jittedMethodsOnStack;\n-         walkState.userData2 = (void *)&currentMethodIndex;\n-         walkState.walkThread = crashedThread;\n-         walkState.skipCount = 0;\n-         walkState.maxFrames = STACK_WALK_DEPTH;\n-         walkState.flags = (\n-            // J9_STACKWALK_LINEAR |\n-            // J9_STACKWALK_START_AT_JIT_FRAME |\n-            // J9_STACKWALK_INCLUDE_NATIVES |\n-            // J9_STACKWALK_HIDE_EXCEPTION_FRAMES |\n-            // J9_STACKWALK_ITERATE_HIDDEN_JIT_FRAMES |\n-            J9_STACKWALK_VISIBLE_ONLY |\n-            J9_STACKWALK_SKIP_INLINES |\n-            J9_STACKWALK_COUNT_SPECIFIED |\n-            J9_STACKWALK_ITERATE_FRAMES\n-            );\n-         walkState.frameWalkFunction = logStackIterator;\n-\n-         /*\n-          * NOTE [March 6th, 2013]:\n-          *\n-          *    Graham Chapman said:\n-          *\n-          *    This will make the stack walker jump back to the last\n-          *    interpreter transition point if a bad return address is found,\n-          *    rather than asserting.  You'll miss a bunch of frames, but\n-          *    there's really nothing better to be done in that case.\n-          */\n-         walkState.errorMode = J9_STACKWALK_ERROR_MODE_IGNORE;\n-\n-         // actually walk the stack, adding all JITed methods to the queue\n-         compInfo->acquireCompMonitor(crashedThread);\n-         crashedThread->javaVM->walkStackFrames(crashedThread, &walkState);\n-         compInfo->releaseCompMonitor(crashedThread);\n-\n          if (options->getVerboseOption(TR_VerboseDump))\n-            TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"found %d JITed methods on Java stack\", currentMethodIndex);\n-         trfprintf(logFile, \"#INFO: Found %d JITed methods on Java stack.\\n\", currentMethodIndex);\n-\n-         // resume the compilation thread\n-         recompilationThreadInfo->resumeCompilationThread();\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"Crashed in application thread\");\n+         trfprintf(logFile, \"#INFO: Crashed in application thread %p.\\n\", crashedThread);\n \n-         // compile our methods\n-         for (int i = 0; i < currentMethodIndex; i++)\n+         // only bother doing anything if we have a healthy compilation thread available\n+         if (recompilationThread)\n             {\n-            // skip if method is somehow null\n-            if (!(jittedMethodsOnStack[i]._method))\n-               continue;\n-\n-            TR_CompilationErrorCode compErrCode;\n-            compErrCode = recompileMethodForLog(\n-               crashedThread,\n-               jittedMethodsOnStack[i]._method,\n-               compInfo,\n-               frontendOfThread,\n-               jittedMethodsOnStack[i]._optLevel,\n-               false,\n-               jittedMethodsOnStack[i]._oldStartPC,\n-               logFile\n+            // make space for methods to be recompiled\n+            // FIXME: this is on the stack... is the stack big enough?\n+            int currentMethodIndex = 0;\n+            TR_MethodToBeCompiledForDump jittedMethodsOnStack[STACK_WALK_DEPTH] = { 0 };\n+\n+            // set up the stack walk object\n+            J9StackWalkState walkState;\n+\n+            walkState.userData1 = (void *)jittedMethodsOnStack;\n+            walkState.userData2 = (void *)&currentMethodIndex;\n+            walkState.walkThread = crashedThread;\n+            walkState.skipCount = 0;\n+            walkState.maxFrames = STACK_WALK_DEPTH;\n+            walkState.flags = (\n+               // J9_STACKWALK_LINEAR |\n+               // J9_STACKWALK_START_AT_JIT_FRAME |\n+               // J9_STACKWALK_INCLUDE_NATIVES |\n+               // J9_STACKWALK_HIDE_EXCEPTION_FRAMES |\n+               // J9_STACKWALK_ITERATE_HIDDEN_JIT_FRAMES |\n+               J9_STACKWALK_VISIBLE_ONLY |\n+               J9_STACKWALK_SKIP_INLINES |\n+               J9_STACKWALK_COUNT_SPECIFIED |\n+               J9_STACKWALK_ITERATE_FRAMES\n                );\n-            } // for\n-\n-         if (currentMethodIndex == 0)\n-            trfprintf(logFile, \"#INFO: DUMP FAILED: no methods to recompile\\n\");\n+            walkState.frameWalkFunction = logStackIterator;\n+\n+            /*\n+             * NOTE [March 6th, 2013]:\n+             *\n+             *    Graham Chapman said:\n+             *\n+             *    This will make the stack walker jump back to the last\n+             *    interpreter transition point if a bad return address is found,\n+             *    rather than asserting.  You'll miss a bunch of frames, but\n+             *    there's really nothing better to be done in that case.\n+             */\n+            walkState.errorMode = J9_STACKWALK_ERROR_MODE_IGNORE;\n+\n+            // actually walk the stack, adding all JITed methods to the queue\n+            compInfo->acquireCompMonitor(crashedThread);\n+            crashedThread->javaVM->walkStackFrames(crashedThread, &walkState);\n+            compInfo->releaseCompMonitor(crashedThread);\n+\n+            if (options->getVerboseOption(TR_VerboseDump))\n+               TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"found %d JITed methods on Java stack\", currentMethodIndex);\n+            trfprintf(logFile, \"#INFO: Found %d JITed methods on Java stack.\\n\", currentMethodIndex);\n+\n+            // resume the compilation thread\n+            recompilationThreadInfo->resumeCompilationThread();\n+\n+            // compile our methods\n+            for (int i = 0; i < currentMethodIndex; i++)\n+               {\n+               // skip if method is somehow null\n+               if (!(jittedMethodsOnStack[i]._method))\n+                  continue;\n \n-         if (options->getVerboseOption(TR_VerboseDump))\n-            TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"recompilations complete\");\n+               TR_CompilationErrorCode compErrCode;\n+               compErrCode = recompileMethodForLog(\n+                  crashedThread,\n+                  jittedMethodsOnStack[i]._method,\n+                  compInfo,\n+                  frontendOfThread,\n+                  jittedMethodsOnStack[i]._optLevel,\n+                  false,\n+                  jittedMethodsOnStack[i]._oldStartPC,\n+                  logFile\n+               );\n+               } // for\n \n-         } // if recompilationThread\n-      else\n-         {\n-         trfprintf(logFile, \"#INFO: DUMP FAILED: no diagnostic thread\\n\");\n-         jitDumpFailedBecause(crashedThread, \"no thread available to compile for dump\");\n-         }\n+            if (currentMethodIndex == 0)\n+               trfprintf(logFile, \"#INFO: DUMP FAILED: no methods to recompile\\n\");\n \n-      } // if threadcompinfo\n+            if (options->getVerboseOption(TR_VerboseDump))\n+               TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"recompilations complete\");\n \n-   // if our compinfo is not null, we are a compilation thread\n-   else\n-      {\n-      if (options->getVerboseOption(TR_VerboseDump))\n-         TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"crashed in compilation thread\");\n-      trfprintf(logFile, \"#INFO: Crashed in compilation thread %p.\\n\", crashedThread);\n+            } // if recompilationThread\n+         else\n+            {\n+            trfprintf(logFile, \"#INFO: DUMP FAILED: no diagnostic thread\\n\");\n+            jitDumpFailedBecause(crashedThread, \"no thread available to compile for dump\");\n+            }\n \n-      // get current compilation\n-      TR::Compilation *comp = threadCompInfo->getCompilation();\n+         } // if threadcompinfo\n \n-      // if the compilation is in progress, dump interesting things from it and then recompile\n-      if (comp)\n+      // if our compinfo is not null, we are a compilation thread\n+      else\n          {\n          if (options->getVerboseOption(TR_VerboseDump))\n-            TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"Found compilation object\");\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"crashed in compilation thread\");\n+         trfprintf(logFile, \"#INFO: Crashed in compilation thread %p.\\n\", crashedThread);\n \n-         // dump IL of current compilation\n-         dumpCurrentIL(comp, crashedThread, jitConfig, logFile);\n+         // get current compilation\n+         TR::Compilation *comp = threadCompInfo->getCompilation();\n \n-         // if there was an available compilation thread, recompile the current method\n-         if (recompilationThread)\n+         // if the compilation is in progress, dump interesting things from it and then recompile\n+         if (comp)\n             {\n-            // only proceed to recompile if the method is a regular Java method\n-            if (currentMethodBeingCompiled &&\n-               currentMethodBeingCompiled->getMethodDetails().isOrdinaryMethod())\n-               {\n-               // resume the healthy compilation thread\n-               recompilationThreadInfo->resumeCompilationThread();  // TODO: Postpone this so that the thread does not get to sleep again\n-               if (options->getVerboseOption(TR_VerboseDump))\n-                  TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"Resuming DiagCompThread\");\n+            if (options->getVerboseOption(TR_VerboseDump))\n+               TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"Found compilation object\");\n \n-               // get old start PC if method was available\n-               void *oldStartPC = 0;\n-               if (currentMethodBeingCompiled)\n-                  oldStartPC = currentMethodBeingCompiled->_oldStartPC;\n+            // dump IL of current compilation\n+            dumpCurrentIL(comp, crashedThread, jitConfig, logFile);\n \n-               // request the compilation\n-               TR_CompilationErrorCode compErrCode;\n-               compErrCode = recompileMethodForLog(\n-                  crashedThread,\n-                  (J9Method *)(comp->getCurrentMethod()->getPersistentIdentifier()),\n-                  compInfo,\n-                  frontendOfThread,\n-                  (TR_Hotness)comp->getOptLevel(),\n-                  comp->isProfilingCompilation(),\n-                  oldStartPC,\n-                  logFile\n+            // if there was an available compilation thread, recompile the current method\n+            if (recompilationThread)\n+               {\n+               // only proceed to recompile if the method is a regular Java method\n+               if (currentMethodBeingCompiled &&\n+                  currentMethodBeingCompiled->getMethodDetails().isOrdinaryMethod())\n+                  {\n+                  // resume the healthy compilation thread\n+                  recompilationThreadInfo->resumeCompilationThread();  // TODO: Postpone this so that the thread does not get to sleep again\n+                  if (options->getVerboseOption(TR_VerboseDump))\n+                     TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"Resuming DiagCompThread\");\n+\n+                  // get old start PC if method was available\n+                  void *oldStartPC = 0;\n+                  if (currentMethodBeingCompiled)\n+                     oldStartPC = currentMethodBeingCompiled->_oldStartPC;\n+\n+                  // The current thread is a compilation thread which may or may not currently hold VM access. The request\n+                  // for recompilation to generate the jitdump will be performed synchronously for which the code path we\n+                  // will take will be the same as if we were an application thread. We will take the synchronous request\n+                  // path in `compileOnSeparateThread` which ends up releasing VM access prior to waiting on the diagnostic\n+                  // thread to finish the queued compile. To avoid deadlocks we must acquire VM access here.\n+                  TR::VMAccessCriticalSection requestSynchronousCompilation(TR_J9VMBase::get(jitConfig, crashedThread));", "originalCommit": "e1582c84de0b6d7b84671801eb327dc1bd5b0b82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk2ODE1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10143#discussion_r452968156", "bodyText": "It looks like in [1] we go to call [2]:\nVM_VMAccess::inlineReleaseVMAccess (vmThread=0x8c200) at /openjdk/openj9/runtime/oti/VMAccess.hpp:179\n\nThere is no assert there. This looks like the \"fast\" version of release VM access. Looks dangerous IMO. Should we be calling the API which does assert throughout the JIT?\n[1] https://github.com/eclipse/openj9/blob/3fe51ff39281bf1c5e316b021164eea41256febe/runtime/compiler/control/CompilationThread.cpp#L6223\n[2] https://github.com/eclipse/openj9/blob/3fe51ff39281bf1c5e316b021164eea41256febe/runtime/oti/VMAccess.hpp#L165-L193", "author": "fjeremic", "createdAt": "2020-07-10T17:09:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk1ODg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA0MTk2Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10143#discussion_r453041963", "bodyText": "It's better that you add the brace brackets to explicitly scope the critical section.", "author": "dsouzai", "createdAt": "2020-07-10T19:36:45Z", "path": "runtime/compiler/control/JitDump.cpp", "diffHunk": "@@ -657,6 +658,13 @@ runJitdump(char *label, J9RASdumpContext *context, J9RASdumpAgent *agent)\n                if (currentMethodBeingCompiled)\n                   oldStartPC = currentMethodBeingCompiled->_oldStartPC;\n \n+               // The current thread is a compilation thread which may or may not currently hold VM access. The request\n+               // for recompilation to generate the jitdump will be performed synchronously for which the code path we\n+               // will take will be the same as if we were an application thread. We will take the synchronous request\n+               // path in `compileOnSeparateThread` which ends up releasing VM access prior to waiting on the diagnostic\n+               // thread to finish the queued compile. To avoid deadlocks we must acquire VM access here.\n+               TR::VMAccessCriticalSection requestSynchronousCompilation(TR_J9VMBase::get(jitConfig, crashedThread));", "originalCommit": "6da9b376d25f86cfb70e7fb9f06b9b6a7572e01e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkwNDUyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10143#discussion_r453904526", "bodyText": "Fixed in 9cc7a45", "author": "fjeremic", "createdAt": "2020-07-13T20:13:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA0MTk2Mw=="}], "type": "inlineReview"}, {"oid": "9cc7a4529057f67af8a9ad80a9dabdba19667723", "url": "https://github.com/eclipse-openj9/openj9/commit/9cc7a4529057f67af8a9ad80a9dabdba19667723", "message": "Add explicit scope around VM access critical section\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>", "committedDate": "2020-07-13T20:13:12Z", "type": "commit"}]}