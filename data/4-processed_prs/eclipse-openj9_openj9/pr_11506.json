{"pr_number": 11506, "pr_title": "Fix resolved trampoline reservation on JITServer", "pr_createdAt": "2020-12-17T16:33:16Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/11506", "timeline": [{"oid": "391d16213f48950b2adec492b5003d9695835737", "url": "https://github.com/eclipse-openj9/openj9/commit/391d16213f48950b2adec492b5003d9695835737", "message": "Fix resolved trampoline reservation on JITServer\n\nPreviously, we didn't have JITServer specific code\nfor handling method trampoline reservations because we assumed\nthat all methods can be called without trampolines.\nThis is true for x86, where code repository is enabled by default,\nbut leads to crashes on Power.\n\nThere are 2 types of method trampolines: resolved and unresolved,\ncorresponding to the types of method calls they enable.\nIn baseline JIT compilation (no JITServer, no AOT) we reserve\ntrampolines during codegen and they are patched during method execution.\nHowever, for AOT and JITServer reservation during codegen would not\nwork, since compiled code is executed by a different VM that doesn't\nhave trampolines reserved.\nAOT uses 2 relocation types to handle this:\n\n1. For unresolved trampolines, we create a `TR_Trampolines` relocation.\nThis relocation is also added for JITServer compilations so this case\nis already handled.\n\n2. For resolved trampolines, AOT only allows their use (and thus resolved\ncall dispatch) when SVM is enabled because `TR_ResolvedTrampolines`\nrelocation requires SVM. This is a problem for JITServer, since non-AOT\ncompilations do not use SVM and we don't want to use unresolved dispatch\nfor every call.\n\nThis commit keeps track of methods for which resolved trampoline is\nneeded during compilation on the server and sends the list to the client\nat the end of the compilation. Once the client receives compiled method\nand allocates code cache, it will reserve trampolines.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-12-17T18:28:16Z", "type": "forcePushed"}, {"oid": "e472263e3247d741b8974f7c6971cdc8ddedfba4", "url": "https://github.com/eclipse-openj9/openj9/commit/e472263e3247d741b8974f7c6971cdc8ddedfba4", "message": "Fix resolved trampoline reservation on JITServer\n\nPreviously, we didn't have JITServer specific code\nfor handling method trampoline reservations because we assumed\nthat all methods can be called without trampolines.\nThis is true for x86, where code repository is enabled by default,\nbut leads to crashes on Power.\n\nThere are 2 types of method trampolines: resolved and unresolved,\ncorresponding to the types of method calls they enable.\nIn baseline JIT compilation (no JITServer, no AOT) we reserve\ntrampolines during codegen and they are patched during method execution.\nHowever, for AOT and JITServer reservation during codegen would not\nwork, since compiled code is executed by a different VM that doesn't\nhave trampolines reserved.\nAOT uses 2 relocation types to handle this:\n\n1. For unresolved trampolines, we create a `TR_Trampolines` relocation.\nThis relocation is also added for JITServer compilations so this case\nis already handled.\n\n2. For resolved trampolines, AOT only allows their use (and thus resolved\ncall dispatch) when SVM is enabled because `TR_ResolvedTrampolines`\nrelocation requires SVM. This is a problem for JITServer, since non-AOT\ncompilations do not use SVM and we don't want to use unresolved dispatch\nfor every call.\n\nThis commit keeps track of methods for which resolved trampoline is\nneeded during compilation on the server and sends the list to the client\nat the end of the compilation. Once the client receives compiled method\nand allocates code cache, it will reserve trampolines.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2021-02-19T17:49:27Z", "type": "forcePushed"}, {"oid": "9943e16a566ff448628b3303698e6ffe4338a2ae", "url": "https://github.com/eclipse-openj9/openj9/commit/9943e16a566ff448628b3303698e6ffe4338a2ae", "message": "Fix resolved trampoline reservation on JITServer\n\nPreviously, we didn't have JITServer specific code\nfor handling method trampoline reservations because we assumed\nthat all methods can be called without trampolines.\nThis is true for x86, where code repository is enabled by default,\nbut leads to crashes on Power.\n\nThere are 2 types of method trampolines: resolved and unresolved,\ncorresponding to the types of method calls they enable.\nIn baseline JIT compilation (no JITServer, no AOT) we reserve\ntrampolines during codegen and they are patched during method execution.\nHowever, for AOT and JITServer reservation during codegen would not\nwork, since compiled code is executed by a different VM that doesn't\nhave trampolines reserved.\nAOT uses 2 relocation types to handle this:\n\n1. For unresolved trampolines, we create a `TR_Trampolines` relocation.\nThis relocation is also added for JITServer compilations so this case\nis already handled.\n\n2. For resolved trampolines, AOT only allows their use (and thus resolved\ncall dispatch) when SVM is enabled because `TR_ResolvedTrampolines`\nrelocation requires SVM. This is a problem for JITServer, since non-AOT\ncompilations do not use SVM and we don't want to use unresolved dispatch\nfor every call.\n\nThis commit keeps track of methods for which resolved trampoline is\nneeded during compilation on the server and sends the list to the client\nat the end of the compilation. Once the client receives compiled method\nand allocates code cache, it will reserve trampolines.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2021-02-19T18:40:05Z", "type": "forcePushed"}, {"oid": "9de844db539e7fa8208dd727cf8c458af9f98f26", "url": "https://github.com/eclipse-openj9/openj9/commit/9de844db539e7fa8208dd727cf8c458af9f98f26", "message": "Fix resolved trampoline reservation on JITServer\n\nPreviously, we didn't have JITServer specific code\nfor handling method trampoline reservations because we assumed\nthat all methods can be called without trampolines.\nThis is true for x86, where code repository is enabled by default,\nbut leads to crashes on Power.\n\nThere are 2 types of method trampolines: resolved and unresolved,\ncorresponding to the types of method calls they enable.\nIn baseline JIT compilation (no JITServer, no AOT) we reserve\ntrampolines during codegen and they are patched during method execution.\nHowever, for AOT and JITServer reservation during codegen would not\nwork, since compiled code is executed by a different VM that doesn't\nhave trampolines reserved.\nAOT uses 2 relocation types to handle this:\n\n1. For unresolved trampolines, we create a `TR_Trampolines` relocation.\nThis relocation is also added for JITServer compilations so this case\nis already handled.\n\n2. For resolved trampolines, AOT only allows their use (and thus resolved\ncall dispatch) when SVM is enabled because `TR_ResolvedTrampolines`\nrelocation requires SVM. This is a problem for JITServer, since non-AOT\ncompilations do not use SVM and we don't want to use unresolved dispatch\nfor every call.\n\nThis commit keeps track of methods for which resolved trampoline is\nneeded during compilation on the server and sends the list to the client\nat the end of the compilation. Once the client receives compiled method\nand allocates code cache, it will reserve trampolines.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2021-02-19T18:47:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTUwNTcwNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11506#discussion_r579505705", "bodyText": "Don' we have to dereference the iterator: *it ?", "author": "mpirvu", "createdAt": "2021-02-19T22:12:27Z", "path": "runtime/compiler/control/JITServerCompilationThread.cpp", "diffHunk": "@@ -148,13 +148,25 @@ outOfProcessCompilationEnd(\n \n    JITServer::ServerMemoryState memoryState = computeServerMemoryState(compInfoPT->getCompilationInfo());\n \n+   // Send methods requring resolved trampolines in this compilation to the client\n+   std::vector<TR_OpaqueMethodBlock *> methodsRequiringTrampolines;\n+   if (comp->getMethodsRequiringTrampolines().size() > 0)\n+      {\n+      methodsRequiringTrampolines.reserve(comp->getMethodsRequiringTrampolines().size());\n+      for (auto it : comp->getMethodsRequiringTrampolines())\n+         {\n+         methodsRequiringTrampolines.push_back(it);", "originalCommit": "9de844db539e7fa8208dd727cf8c458af9f98f26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDM4MTM4Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11506#discussion_r580381387", "bodyText": "No we don't, because we don't explicitly use an iterator here, but we use a range-based for loop, which gives us elements of the vector directly.\nThe same method is used to iterate over SerializedRuntimeAssumption vector just a few lines above, so I used it here as well.", "author": "dmitry-ten", "createdAt": "2021-02-22T16:16:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTUwNTcwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDQyMDIxOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11506#discussion_r580420218", "bodyText": "Could you please double check? In the SerializedRuntimeAssumption code we push_back(*it).", "author": "mpirvu", "createdAt": "2021-02-22T17:03:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTUwNTcwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDQyNDg3NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11506#discussion_r580424874", "bodyText": "We dereference SerializedRuntimeAssumption because getSerializedRuntimeAssumptions returns TR::list<SerializedRuntimeAssumption *>, but the vector we send to the client is std::vector<SerializedRuntimeAssumption> so in this case dereference is the actual dereference, not iterator dereference.", "author": "dmitry-ten", "createdAt": "2021-02-22T17:09:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTUwNTcwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDY5OTE2MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11506#discussion_r580699160", "bodyText": "ok", "author": "mpirvu", "createdAt": "2021-02-23T00:56:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTUwNTcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU1MTE5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11506#discussion_r579551194", "bodyText": "The generate code and the trampoline reservations need to stay in the same code cache. If we cannot reserve a trampoline here we need to take some corrective action, possibly leading to failing the compilation.\nif you look at how we reserve trampolines in the non-jitserver case you'll see it's quite complicated.", "author": "mpirvu", "createdAt": "2021-02-20T00:26:05Z", "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -3269,6 +3275,11 @@ remoteCompile(\n                   } // end switch (it->getKind())\n                }\n             metaData->runtimeAssumptionList = *(compiler->getMetadataAssumptionList());\n+\n+            for (auto& it : methodsRequiringTrampolines)\n+               {\n+               compInfoPT->reloRuntime()->codeCache()->reserveResolvedTrampoline(it, true);", "originalCommit": "9de844db539e7fa8208dd727cf8c458af9f98f26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDQxOTUwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11506#discussion_r580419506", "bodyText": "I see that in TR_J9VMBase::getResolvedTrampoline failing to allocate a trampoline always results in failing the compilation when we are in binary encoding. If I understand correctly, it's because we start populating the code cache in the binary encoding phase, so we can't just start using a new cache at that point and have to fail a compilation.\nI think for JITServer it would be reasonable to fail with TR::RecoverableTrampolineError if reserveResolvedTrampoline returns an error code because by that point we already received the code cache from the server so we can't just create a new one.", "author": "dmitry-ten", "createdAt": "2021-02-22T17:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU1MTE5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDY5OTAxMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11506#discussion_r580699013", "bodyText": "ok", "author": "mpirvu", "createdAt": "2021-02-23T00:55:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU1MTE5NA=="}], "type": "inlineReview"}, {"oid": "a329856fd58d2ca0ea77a95f5d046b274cbcce9e", "url": "https://github.com/eclipse-openj9/openj9/commit/a329856fd58d2ca0ea77a95f5d046b274cbcce9e", "message": "Fix resolved trampoline reservation on JITServer\n\nPreviously, we didn't have JITServer specific code\nfor handling method trampoline reservations because we assumed\nthat all methods can be called without trampolines.\nThis is true for x86, where code repository is enabled by default,\nbut leads to crashes on Power.\n\nThere are 2 types of method trampolines: resolved and unresolved,\ncorresponding to the types of method calls they enable.\nIn baseline JIT compilation (no JITServer, no AOT) we reserve\ntrampolines during codegen and they are patched during method execution.\nHowever, for AOT and JITServer reservation during codegen would not\nwork, since compiled code is executed by a different VM that doesn't\nhave trampolines reserved.\nAOT uses 2 relocation types to handle this:\n\n1. For unresolved trampolines, we create a `TR_Trampolines` relocation.\nThis relocation is also added for JITServer compilations so this case\nis already handled.\n\n2. For resolved trampolines, AOT only allows their use (and thus resolved\ncall dispatch) when SVM is enabled because `TR_ResolvedTrampolines`\nrelocation requires SVM. This is a problem for JITServer, since non-AOT\ncompilations do not use SVM and we don't want to use unresolved dispatch\nfor every call.\n\nThis commit keeps track of methods for which resolved trampoline is\nneeded during compilation on the server and sends the list to the client\nat the end of the compilation. Once the client receives compiled method\nand allocates code cache, it will reserve trampolines.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2021-02-22T17:05:01Z", "type": "forcePushed"}, {"oid": "66fe2a5a071c986e2e5e6048a00b16c30d202210", "url": "https://github.com/eclipse-openj9/openj9/commit/66fe2a5a071c986e2e5e6048a00b16c30d202210", "message": "Fix resolved trampoline reservation on JITServer\n\nPreviously, we didn't have JITServer specific code\nfor handling method trampoline reservations because we assumed\nthat all methods can be called without trampolines.\nThis is true for x86, where code repository is enabled by default,\nbut leads to crashes on Power.\n\nThere are 2 types of method trampolines: resolved and unresolved,\ncorresponding to the types of method calls they enable.\nIn baseline JIT compilation (no JITServer, no AOT) we reserve\ntrampolines during codegen and they are patched during method execution.\nHowever, for AOT and JITServer reservation during codegen would not\nwork, since compiled code is executed by a different VM that doesn't\nhave trampolines reserved.\nAOT uses 2 relocation types to handle this:\n\n1. For unresolved trampolines, we create a `TR_Trampolines` relocation.\nThis relocation is also added for JITServer compilations so this case\nis already handled.\n\n2. For resolved trampolines, AOT only allows their use (and thus resolved\ncall dispatch) when SVM is enabled because `TR_ResolvedTrampolines`\nrelocation requires SVM. This is a problem for JITServer, since non-AOT\ncompilations do not use SVM and we don't want to use unresolved dispatch\nfor every call.\n\nThis commit keeps track of methods for which resolved trampoline is\nneeded during compilation on the server and sends the list to the client\nat the end of the compilation. Once the client receives compiled method\nand allocates code cache, it will reserve trampolines.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2021-02-22T17:13:41Z", "type": "forcePushed"}, {"oid": "cd1515105e98bd7b0139e431dc20b097c8f8e823", "url": "https://github.com/eclipse-openj9/openj9/commit/cd1515105e98bd7b0139e431dc20b097c8f8e823", "message": "Fix resolved trampoline reservation on JITServer\n\nPreviously, we didn't have JITServer specific code\nfor handling method trampoline reservations because we assumed\nthat all methods can be called without trampolines.\nThis is true for x86, where code repository is enabled by default,\nbut leads to crashes on Power.\n\nThere are 2 types of method trampolines: resolved and unresolved,\ncorresponding to the types of method calls they enable.\nIn baseline JIT compilation (no JITServer, no AOT) we reserve\ntrampolines during codegen and they are patched during method execution.\nHowever, for AOT and JITServer reservation during codegen would not\nwork, since compiled code is executed by a different VM that doesn't\nhave trampolines reserved.\nAOT uses 2 relocation types to handle this:\n\n1. For unresolved trampolines, we create a `TR_Trampolines` relocation.\nThis relocation is also added for JITServer compilations so this case\nis already handled.\n\n2. For resolved trampolines, AOT only allows their use (and thus resolved\ncall dispatch) when SVM is enabled because `TR_ResolvedTrampolines`\nrelocation requires SVM. This is a problem for JITServer, since non-AOT\ncompilations do not use SVM and we don't want to use unresolved dispatch\nfor every call.\n\nThis commit keeps track of methods for which resolved trampoline is\nneeded during compilation on the server and sends the list to the client\nat the end of the compilation. Once the client receives compiled method\nand allocates code cache, it will reserve trampolines.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2021-02-23T18:44:59Z", "type": "commit"}, {"oid": "cd1515105e98bd7b0139e431dc20b097c8f8e823", "url": "https://github.com/eclipse-openj9/openj9/commit/cd1515105e98bd7b0139e431dc20b097c8f8e823", "message": "Fix resolved trampoline reservation on JITServer\n\nPreviously, we didn't have JITServer specific code\nfor handling method trampoline reservations because we assumed\nthat all methods can be called without trampolines.\nThis is true for x86, where code repository is enabled by default,\nbut leads to crashes on Power.\n\nThere are 2 types of method trampolines: resolved and unresolved,\ncorresponding to the types of method calls they enable.\nIn baseline JIT compilation (no JITServer, no AOT) we reserve\ntrampolines during codegen and they are patched during method execution.\nHowever, for AOT and JITServer reservation during codegen would not\nwork, since compiled code is executed by a different VM that doesn't\nhave trampolines reserved.\nAOT uses 2 relocation types to handle this:\n\n1. For unresolved trampolines, we create a `TR_Trampolines` relocation.\nThis relocation is also added for JITServer compilations so this case\nis already handled.\n\n2. For resolved trampolines, AOT only allows their use (and thus resolved\ncall dispatch) when SVM is enabled because `TR_ResolvedTrampolines`\nrelocation requires SVM. This is a problem for JITServer, since non-AOT\ncompilations do not use SVM and we don't want to use unresolved dispatch\nfor every call.\n\nThis commit keeps track of methods for which resolved trampoline is\nneeded during compilation on the server and sends the list to the client\nat the end of the compilation. Once the client receives compiled method\nand allocates code cache, it will reserve trampolines.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2021-02-23T18:44:59Z", "type": "forcePushed"}]}