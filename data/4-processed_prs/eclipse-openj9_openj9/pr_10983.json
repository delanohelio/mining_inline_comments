{"pr_number": 10983, "pr_title": "Use flattened types as backfill", "pr_createdAt": "2020-10-23T20:34:51Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10983", "timeline": [{"oid": "e6c98dcfe87ab1f292796205001f83fc5ca2be97", "url": "https://github.com/eclipse-openj9/openj9/commit/e6c98dcfe87ab1f292796205001f83fc5ca2be97", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs mode. The backfill has been\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs mode) has at least one single slot or ref field\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-10-23T20:51:48Z", "type": "forcePushed"}, {"oid": "e4b766146b75067db38154799f53c937835e53dd", "url": "https://github.com/eclipse-openj9/openj9/commit/e4b766146b75067db38154799f53c937835e53dd", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs mode. The backfill has been\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs mode) has at least one single slot or ref field\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-02T15:54:40Z", "type": "forcePushed"}, {"oid": "ab5aa709a41190cdc54ad3c0bfaf4d621e888ab3", "url": "https://github.com/eclipse-openj9/openj9/commit/ab5aa709a41190cdc54ad3c0bfaf4d621e888ab3", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs mode. The backfill has been\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs mode) has at least one single slot or ref field\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-02T16:05:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc0NjM2MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10983#discussion_r516746360", "bodyText": "The final sentence is a bit clumsy (and doesn't end in a period).", "author": "gacholio", "createdAt": "2020-11-03T15:20:05Z", "path": "runtime/compiler/env/J9ClassEnv.cpp", "diffHunk": "@@ -515,6 +515,15 @@ static void addEntryForFieldImpl(TR_VMField *field, TR::TypeLayoutBuilder &tlb,\n       ListIterator<TR_VMField> iter(fieldsInfo.getFields());\n       for (TR_VMField *childField = iter.getFirst(); childField; childField = iter.getNext())\n          {\n+         IDATA offsetBaseForChild = field->offset + offsetBase;\n+         if (vm->internalVMFunctions->doesClassHave4BytePrePadding(fieldClass))\n+            {\n+               /* Types with fields (flat or non-flat) that require double (64bit) alignment are pre-padded if there isn't\n+                * a smaller type that can be used as pre-padding. Pre-padding is eliminated when a type is flattened within\n+                * its container. As a result the base offset must subtracted by the size of pre-padding", "originalCommit": "ab5aa709a41190cdc54ad3c0bfaf4d621e888ab3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc0NzgwNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10983#discussion_r516747805", "bodyText": "Does this mean that arrays of padded VTs will pad the start of each element?", "author": "gacholio", "createdAt": "2020-11-03T15:22:02Z", "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "diffHunk": "@@ -1131,13 +1131,18 @@ MM_ObjectAccessBarrier::indexableStoreI64(J9VMThread *vmThread, J9IndexableObjec\n void\n MM_ObjectAccessBarrier::copyObjectFieldsToFlattenedArrayElement(J9VMThread *vmThread, J9ArrayClass *arrayClazz, j9object_t srcObject, J9IndexableObject *arrayRef, I_32 index)\n {\n-\tUDATA const objectHeaderSize = J9VMTHREAD_OBJECT_HEADER_SIZE(vmThread);\n+\tUDATA elementStartOffset = J9VMTHREAD_OBJECT_HEADER_SIZE(vmThread);\n \tU_8 *elementAddress = (U_8*)indexableEffectiveAddress(vmThread, arrayRef, index, J9ARRAYCLASS_GET_STRIDE((J9Class *) arrayClazz));\n \tIDATA elementOffset = (elementAddress - (U_8*)arrayRef);\n \tJ9Class *elementClazz = J9GC_J9OBJECT_CLAZZ_THREAD(srcObject, vmThread);\n \tAssert_MM_true(J9_IS_J9CLASS_VALUETYPE(elementClazz));\n \tAssert_MM_true(elementClazz == arrayClazz->leafComponentType);\n-\tcopyObjectFields(vmThread, elementClazz, srcObject, objectHeaderSize, (j9object_t) arrayRef, elementOffset);\n+\n+\tif (J9CLASS_HAS_4BYTE_PREPADDING(elementClazz)) {", "originalCommit": "ab5aa709a41190cdc54ad3c0bfaf4d621e888ab3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ2NDM0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10983#discussion_r517464343", "bodyText": "No VT array elements will not include pre-padding. See https://github.com/eclipse/openj9/blob/master/runtime/vm/createramclass.cpp#L3039", "author": "tajila", "createdAt": "2020-11-04T16:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc0NzgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ2OTcwNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10983#discussion_r517469704", "bodyText": "I suppose since VTs are immuteable, there are no volatile/atomic concerns.", "author": "gacholio", "createdAt": "2020-11-04T16:26:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc0NzgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc2ODEyNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10983#discussion_r516768125", "bodyText": "No doc, and why do we need a function to wrap a macro?", "author": "gacholio", "createdAt": "2020-11-03T15:48:32Z", "path": "runtime/oti/vm_api.h", "diffHunk": "@@ -2376,6 +2376,9 @@ BOOLEAN\n isNameOrSignatureQtype(J9UTF8 *utfWrapper);\n \n \n+BOOLEAN", "originalCommit": "ab5aa709a41190cdc54ad3c0bfaf4d621e888ab3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc2OTY1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10983#discussion_r516769651", "bodyText": "This would better either before or after the bit constants.", "author": "gacholio", "createdAt": "2020-11-03T15:50:34Z", "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -1597,18 +1598,23 @@ typedef struct J9ROMFieldOffsetWalkState {\n \tUDATA currentFlatSingleOffset;\n \tUDATA currentFlatObjectOffset;\n \tUDATA currentFlatDoubleOffset;\n+\tBOOLEAN classRequiresPrePadding;\n+\tUDATA flatBackFillSize;\n #endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n } J9ROMFieldOffsetWalkState;\n \n-#define J9VM_FIELD_OFFSET_WALK_INCLUDE_STATIC  1\n-#define J9VM_FIELD_OFFSET_WALK_BACKFILL_OBJECT_FIELD  32\n-#define J9VM_FIELD_OFFSET_WALK_INCLUDE_HIDDEN  4\n-#define J9VM_FIELD_OFFSET_WALK_ONLY_OBJECT_SLOTS  8\n-#define J9VM_FIELD_OFFSET_WALK_CALCULATE_INSTANCE_SIZE  16\n-#define J9VM_FIELD_OFFSET_WALK_BACKFILL_SINGLE_FIELD  64\n+#define J9VM_FIELD_OFFSET_WALK_INCLUDE_STATIC  0x1\n+#define J9VM_FIELD_OFFSET_WALK_BACKFILL_OBJECT_FIELD  0x20\n+#define J9VM_FIELD_OFFSET_WALK_INCLUDE_HIDDEN  0x4\n+#define J9VM_FIELD_OFFSET_WALK_ONLY_OBJECT_SLOTS  0x8\n+#define J9VM_FIELD_OFFSET_WALK_CALCULATE_INSTANCE_SIZE  0x10\n+#define J9VM_FIELD_OFFSET_WALK_BACKFILL_SINGLE_FIELD  0x40\n #define J9VM_FIELD_OFFSET_WALK_MAXIMUM_HIDDEN_FIELDS_PER_CLASS  J9VM_MAX_HIDDEN_FIELDS_PER_CLASS", "originalCommit": "ab5aa709a41190cdc54ad3c0bfaf4d621e888ab3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "85076696aef9e031288e8e9eb236e69d3eb80d92", "url": "https://github.com/eclipse-openj9/openj9/commit/85076696aef9e031288e8e9eb236e69d3eb80d92", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-04T16:33:27Z", "type": "forcePushed"}, {"oid": "7d5adb024da26c6b34611afe028b7ebe7dad290e", "url": "https://github.com/eclipse-openj9/openj9/commit/7d5adb024da26c6b34611afe028b7ebe7dad290e", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-04T16:37:55Z", "type": "forcePushed"}, {"oid": "ef1de792584a705bbe241b252c6a7216ce72cde5", "url": "https://github.com/eclipse-openj9/openj9/commit/ef1de792584a705bbe241b252c6a7216ce72cde5", "message": "layout examples", "committedDate": "2020-11-04T17:29:09Z", "type": "forcePushed"}, {"oid": "2a08be106e7eb9792c244c74fd46982dc0cd6bd7", "url": "https://github.com/eclipse-openj9/openj9/commit/2a08be106e7eb9792c244c74fd46982dc0cd6bd7", "message": "layout examples", "committedDate": "2020-11-09T00:11:50Z", "type": "forcePushed"}, {"oid": "b1439320fd65666ba1a6afb9f14942dd0baac869", "url": "https://github.com/eclipse-openj9/openj9/commit/b1439320fd65666ba1a6afb9f14942dd0baac869", "message": "layout examples", "committedDate": "2020-11-09T16:26:07Z", "type": "forcePushed"}, {"oid": "0cdaeac6b523594b28d3ee7c47320d3e214b3062", "url": "https://github.com/eclipse-openj9/openj9/commit/0cdaeac6b523594b28d3ee7c47320d3e214b3062", "message": "layout examples", "committedDate": "2020-11-09T16:33:32Z", "type": "forcePushed"}, {"oid": "9ef6e6f7661286510d450427f1d600b75163cec5", "url": "https://github.com/eclipse-openj9/openj9/commit/9ef6e6f7661286510d450427f1d600b75163cec5", "message": "layout examples", "committedDate": "2020-11-09T16:50:38Z", "type": "forcePushed"}, {"oid": "1e3b5c568c6f5da7248dde499cbddd8025b13059", "url": "https://github.com/eclipse-openj9/openj9/commit/1e3b5c568c6f5da7248dde499cbddd8025b13059", "message": "layout examples", "committedDate": "2020-11-09T18:03:57Z", "type": "forcePushed"}, {"oid": "8e779daf64a8ca9cf82ab806f74c69050702a4a0", "url": "https://github.com/eclipse-openj9/openj9/commit/8e779daf64a8ca9cf82ab806f74c69050702a4a0", "message": "layout examples", "committedDate": "2020-11-09T18:15:08Z", "type": "forcePushed"}, {"oid": "737467fa8c9c47240a0321d75d746100ffb71b19", "url": "https://github.com/eclipse-openj9/openj9/commit/737467fa8c9c47240a0321d75d746100ffb71b19", "message": "layout examples", "committedDate": "2020-11-09T18:41:09Z", "type": "forcePushed"}, {"oid": "87959fef1fc2720adde2fe54de070b30b27894c3", "url": "https://github.com/eclipse-openj9/openj9/commit/87959fef1fc2720adde2fe54de070b30b27894c3", "message": "layout examples", "committedDate": "2020-11-09T18:53:40Z", "type": "forcePushed"}, {"oid": "dc7b52477a8df4d53930c60a601f0a88c9c66b96", "url": "https://github.com/eclipse-openj9/openj9/commit/dc7b52477a8df4d53930c60a601f0a88c9c66b96", "message": "layout examples", "committedDate": "2020-11-09T20:38:49Z", "type": "forcePushed"}, {"oid": "101ab457f701e0310811d7217268e357a36e3f41", "url": "https://github.com/eclipse-openj9/openj9/commit/101ab457f701e0310811d7217268e357a36e3f41", "message": "layout examples", "committedDate": "2020-11-09T20:47:26Z", "type": "forcePushed"}, {"oid": "8f81df33fc635a28c7242a150312be57053eba10", "url": "https://github.com/eclipse-openj9/openj9/commit/8f81df33fc635a28c7242a150312be57053eba10", "message": "layout examples", "committedDate": "2020-11-09T21:49:02Z", "type": "forcePushed"}, {"oid": "ffc2a1f7818b7f0a411cab54891084f85429427c", "url": "https://github.com/eclipse-openj9/openj9/commit/ffc2a1f7818b7f0a411cab54891084f85429427c", "message": "layout examples", "committedDate": "2020-11-09T22:46:03Z", "type": "forcePushed"}, {"oid": "cb505208b1f4422a2580950e2175a4458621d235", "url": "https://github.com/eclipse-openj9/openj9/commit/cb505208b1f4422a2580950e2175a4458621d235", "message": "layout examples", "committedDate": "2020-11-09T22:55:28Z", "type": "forcePushed"}, {"oid": "4c599a6fc99c51b669c3e3fab8651a577cbbed2c", "url": "https://github.com/eclipse-openj9/openj9/commit/4c599a6fc99c51b669c3e3fab8651a577cbbed2c", "message": "layout examples", "committedDate": "2020-11-09T23:11:09Z", "type": "forcePushed"}, {"oid": "452ff6220565d5a8f7772eadab300997c7d37b02", "url": "https://github.com/eclipse-openj9/openj9/commit/452ff6220565d5a8f7772eadab300997c7d37b02", "message": "layout examples", "committedDate": "2020-11-09T23:25:17Z", "type": "forcePushed"}, {"oid": "818e066a8cbefa18fc051ea264fa7d5212733427", "url": "https://github.com/eclipse-openj9/openj9/commit/818e066a8cbefa18fc051ea264fa7d5212733427", "message": "layout examples", "committedDate": "2020-11-09T23:30:30Z", "type": "forcePushed"}, {"oid": "2b8fc111243da50de291de81c26f2cb0708b4a1a", "url": "https://github.com/eclipse-openj9/openj9/commit/2b8fc111243da50de291de81c26f2cb0708b4a1a", "message": "layout examples", "committedDate": "2020-11-10T20:31:55Z", "type": "forcePushed"}, {"oid": "e69178f983d7ff6b66989b117386ceb1ba796bb7", "url": "https://github.com/eclipse-openj9/openj9/commit/e69178f983d7ff6b66989b117386ceb1ba796bb7", "message": "layout examples", "committedDate": "2020-11-10T23:12:36Z", "type": "forcePushed"}, {"oid": "7cdabb1dbf552d321f5d6ab80073ff591397f37f", "url": "https://github.com/eclipse-openj9/openj9/commit/7cdabb1dbf552d321f5d6ab80073ff591397f37f", "message": "layout examples", "committedDate": "2020-11-10T23:39:06Z", "type": "forcePushed"}, {"oid": "72dc879e8e6cf4fa2621e1bdc4c65051c98d806f", "url": "https://github.com/eclipse-openj9/openj9/commit/72dc879e8e6cf4fa2621e1bdc4c65051c98d806f", "message": "layout examples", "committedDate": "2020-11-10T23:52:32Z", "type": "forcePushed"}, {"oid": "33219c2205a0c7873efe40f422af247fabb450b6", "url": "https://github.com/eclipse-openj9/openj9/commit/33219c2205a0c7873efe40f422af247fabb450b6", "message": "layout examples", "committedDate": "2020-11-11T00:06:20Z", "type": "forcePushed"}, {"oid": "bc708f6fa63907d0dc11c369bc3bd12bf589cb69", "url": "https://github.com/eclipse-openj9/openj9/commit/bc708f6fa63907d0dc11c369bc3bd12bf589cb69", "message": "layout examples", "committedDate": "2020-11-11T15:57:51Z", "type": "forcePushed"}, {"oid": "be19f9545a11cd734930cb90d8e9d9838fc440af", "url": "https://github.com/eclipse-openj9/openj9/commit/be19f9545a11cd734930cb90d8e9d9838fc440af", "message": "layout examples", "committedDate": "2020-11-11T16:16:04Z", "type": "forcePushed"}, {"oid": "2d4769e15ade40736c6602356248eb7aadb45ffe", "url": "https://github.com/eclipse-openj9/openj9/commit/2d4769e15ade40736c6602356248eb7aadb45ffe", "message": "layout examples", "committedDate": "2020-11-11T16:27:37Z", "type": "forcePushed"}, {"oid": "d3887fc0d788db9dfa957fdcebc2e5fcc575c906", "url": "https://github.com/eclipse-openj9/openj9/commit/d3887fc0d788db9dfa957fdcebc2e5fcc575c906", "message": "layout examples", "committedDate": "2020-11-11T16:33:16Z", "type": "forcePushed"}, {"oid": "52ca3c54c4cf155d5a3c6c2c3359bb313863861c", "url": "https://github.com/eclipse-openj9/openj9/commit/52ca3c54c4cf155d5a3c6c2c3359bb313863861c", "message": "layout examples", "committedDate": "2020-11-11T16:50:19Z", "type": "forcePushed"}, {"oid": "7dd5de09473e599f1b6af12345f8affb8260425c", "url": "https://github.com/eclipse-openj9/openj9/commit/7dd5de09473e599f1b6af12345f8affb8260425c", "message": "layout examples", "committedDate": "2020-11-11T22:20:23Z", "type": "forcePushed"}, {"oid": "2b00e5b906ea3d0f80cc838e0de9a0bb31cda3af", "url": "https://github.com/eclipse-openj9/openj9/commit/2b00e5b906ea3d0f80cc838e0de9a0bb31cda3af", "message": "layout examples", "committedDate": "2020-11-11T22:24:57Z", "type": "forcePushed"}, {"oid": "0abcbd0eb6d67a92773d3ee9ff11363e54e123fa", "url": "https://github.com/eclipse-openj9/openj9/commit/0abcbd0eb6d67a92773d3ee9ff11363e54e123fa", "message": "layout examples", "committedDate": "2020-11-11T22:52:05Z", "type": "forcePushed"}, {"oid": "3fd97a18530cc76424ef1bcea387cbe8b4664386", "url": "https://github.com/eclipse-openj9/openj9/commit/3fd97a18530cc76424ef1bcea387cbe8b4664386", "message": "layout examples", "committedDate": "2020-11-11T22:57:46Z", "type": "forcePushed"}, {"oid": "a9e186f442f41e62f4f8bed7c7c4735e8c123187", "url": "https://github.com/eclipse-openj9/openj9/commit/a9e186f442f41e62f4f8bed7c7c4735e8c123187", "message": "layout examples", "committedDate": "2020-11-11T23:03:48Z", "type": "forcePushed"}, {"oid": "2938f21d6d871d82c49983a226592c1b6da51883", "url": "https://github.com/eclipse-openj9/openj9/commit/2938f21d6d871d82c49983a226592c1b6da51883", "message": "layout examples", "committedDate": "2020-11-11T23:16:26Z", "type": "forcePushed"}, {"oid": "72231cc0262fa416794b27e0373b7c1dd3201f2c", "url": "https://github.com/eclipse-openj9/openj9/commit/72231cc0262fa416794b27e0373b7c1dd3201f2c", "message": "layout examples", "committedDate": "2020-11-11T23:20:35Z", "type": "forcePushed"}, {"oid": "a9b10958220b50332f594b5e636e210073eb6c70", "url": "https://github.com/eclipse-openj9/openj9/commit/a9b10958220b50332f594b5e636e210073eb6c70", "message": "layout examples", "committedDate": "2020-11-11T23:46:45Z", "type": "forcePushed"}, {"oid": "c27e3c7a6259cd9d3547f8006751af74b123d18d", "url": "https://github.com/eclipse-openj9/openj9/commit/c27e3c7a6259cd9d3547f8006751af74b123d18d", "message": "layout examples", "committedDate": "2020-11-11T23:55:48Z", "type": "forcePushed"}, {"oid": "7037f665ae19b0568da652b5525761ef9df092d6", "url": "https://github.com/eclipse-openj9/openj9/commit/7037f665ae19b0568da652b5525761ef9df092d6", "message": "layout examples", "committedDate": "2020-11-12T15:23:07Z", "type": "forcePushed"}, {"oid": "8120d829d058f0e05ae99e01e5c39815dac95ddf", "url": "https://github.com/eclipse-openj9/openj9/commit/8120d829d058f0e05ae99e01e5c39815dac95ddf", "message": "layout examples", "committedDate": "2020-11-12T15:55:30Z", "type": "forcePushed"}, {"oid": "59e0ff3aeee0e4a8d9cf80f584b1d2304440fdfc", "url": "https://github.com/eclipse-openj9/openj9/commit/59e0ff3aeee0e4a8d9cf80f584b1d2304440fdfc", "message": "layout examples", "committedDate": "2020-11-12T16:05:16Z", "type": "forcePushed"}, {"oid": "c857c366d8a8704ea95b46a90c32ff2e2a0f1a46", "url": "https://github.com/eclipse-openj9/openj9/commit/c857c366d8a8704ea95b46a90c32ff2e2a0f1a46", "message": "layout examples", "committedDate": "2020-11-12T16:24:57Z", "type": "forcePushed"}, {"oid": "7b04a066e631a3da25ce9c826522a9f6712b64aa", "url": "https://github.com/eclipse-openj9/openj9/commit/7b04a066e631a3da25ce9c826522a9f6712b64aa", "message": "layout examples", "committedDate": "2020-11-12T16:44:42Z", "type": "forcePushed"}, {"oid": "e64f3895f8831e8ad2a3ce136d3338d905303a09", "url": "https://github.com/eclipse-openj9/openj9/commit/e64f3895f8831e8ad2a3ce136d3338d905303a09", "message": "layout examples", "committedDate": "2020-11-12T17:02:18Z", "type": "forcePushed"}, {"oid": "1da7d77900c986a9b4ca3db3094511b37f5a2ed4", "url": "https://github.com/eclipse-openj9/openj9/commit/1da7d77900c986a9b4ca3db3094511b37f5a2ed4", "message": "layout examples", "committedDate": "2020-11-12T18:28:34Z", "type": "forcePushed"}, {"oid": "9f9a3316655db5d748e240a72acc850d0b82d9d2", "url": "https://github.com/eclipse-openj9/openj9/commit/9f9a3316655db5d748e240a72acc850d0b82d9d2", "message": "layout examples", "committedDate": "2020-11-12T18:32:00Z", "type": "forcePushed"}, {"oid": "24762a62742baa26e7415c2e1c64e07db882f878", "url": "https://github.com/eclipse-openj9/openj9/commit/24762a62742baa26e7415c2e1c64e07db882f878", "message": "layout examples", "committedDate": "2020-11-12T18:35:10Z", "type": "forcePushed"}, {"oid": "3ac83ed7c92665956e9357c6744bd15043482818", "url": "https://github.com/eclipse-openj9/openj9/commit/3ac83ed7c92665956e9357c6744bd15043482818", "message": "layout examples", "committedDate": "2020-11-12T18:37:50Z", "type": "forcePushed"}, {"oid": "e8703048e47824a961d5df10561b75ecfcadb28a", "url": "https://github.com/eclipse-openj9/openj9/commit/e8703048e47824a961d5df10561b75ecfcadb28a", "message": "layout examples", "committedDate": "2020-11-12T18:44:15Z", "type": "forcePushed"}, {"oid": "960495d3c1caf409d544b05e62a51955f1c123eb", "url": "https://github.com/eclipse-openj9/openj9/commit/960495d3c1caf409d544b05e62a51955f1c123eb", "message": "layout examples", "committedDate": "2020-11-12T19:34:29Z", "type": "forcePushed"}, {"oid": "a4ec5cfb09a5466d3e178e46217e8d05ad4c03db", "url": "https://github.com/eclipse-openj9/openj9/commit/a4ec5cfb09a5466d3e178e46217e8d05ad4c03db", "message": "layout examples", "committedDate": "2020-11-12T19:38:41Z", "type": "forcePushed"}, {"oid": "078a0a25ed2943d94669c9963f52b0fa5acdb448", "url": "https://github.com/eclipse-openj9/openj9/commit/078a0a25ed2943d94669c9963f52b0fa5acdb448", "message": "layout examples", "committedDate": "2020-11-12T19:53:08Z", "type": "forcePushed"}, {"oid": "1bf639b80b2419ca6e0548bfc96ee4a7acb15d72", "url": "https://github.com/eclipse-openj9/openj9/commit/1bf639b80b2419ca6e0548bfc96ee4a7acb15d72", "message": "layout examples", "committedDate": "2020-11-12T19:56:08Z", "type": "forcePushed"}, {"oid": "759760616d15f8245fbda24ffaf5babab752b56f", "url": "https://github.com/eclipse-openj9/openj9/commit/759760616d15f8245fbda24ffaf5babab752b56f", "message": "layout examples", "committedDate": "2020-11-12T20:09:28Z", "type": "forcePushed"}, {"oid": "79371c8ad969005faf61549d04c6126e296f5529", "url": "https://github.com/eclipse-openj9/openj9/commit/79371c8ad969005faf61549d04c6126e296f5529", "message": "layout examples", "committedDate": "2020-11-12T20:16:22Z", "type": "forcePushed"}, {"oid": "35d2b00488dbb50dc911277c72a3a7235a27a626", "url": "https://github.com/eclipse-openj9/openj9/commit/35d2b00488dbb50dc911277c72a3a7235a27a626", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-12T23:04:04Z", "type": "forcePushed"}, {"oid": "4ed2e87e155df226eb387867dfe3b2acc75daada", "url": "https://github.com/eclipse-openj9/openj9/commit/4ed2e87e155df226eb387867dfe3b2acc75daada", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-12T23:07:40Z", "type": "forcePushed"}, {"oid": "f6cfcde295bf0ae22a65f55c0a72169165f29d16", "url": "https://github.com/eclipse-openj9/openj9/commit/f6cfcde295bf0ae22a65f55c0a72169165f29d16", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>\n\n# Conflicts:\n#\truntime/vm/intfunc.c", "committedDate": "2020-11-12T23:26:34Z", "type": "forcePushed"}, {"oid": "4280cf9f6a7d947d5ee0e47c3c855ef202a5863c", "url": "https://github.com/eclipse-openj9/openj9/commit/4280cf9f6a7d947d5ee0e47c3c855ef202a5863c", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>\n\n# Conflicts:\n#\truntime/vm/intfunc.c", "committedDate": "2020-11-13T14:33:21Z", "type": "forcePushed"}, {"oid": "39688537835f2f671c8bfaa4f21673b3ab2cb3ea", "url": "https://github.com/eclipse-openj9/openj9/commit/39688537835f2f671c8bfaa4f21673b3ab2cb3ea", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>\n\n# Conflicts:\n#\truntime/vm/intfunc.c", "committedDate": "2020-11-13T14:44:28Z", "type": "forcePushed"}, {"oid": "7856ab11d3dc22b4c537c3a75acd59dde96353f6", "url": "https://github.com/eclipse-openj9/openj9/commit/7856ab11d3dc22b4c537c3a75acd59dde96353f6", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-13T14:46:07Z", "type": "forcePushed"}, {"oid": "0f9c8c2f45bdcd48cb431fcd78db9e152c2420d0", "url": "https://github.com/eclipse-openj9/openj9/commit/0f9c8c2f45bdcd48cb431fcd78db9e152c2420d0", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-13T14:46:59Z", "type": "forcePushed"}, {"oid": "0fe6854731461adb1052e2703205e41f53bb9a08", "url": "https://github.com/eclipse-openj9/openj9/commit/0fe6854731461adb1052e2703205e41f53bb9a08", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-13T14:49:19Z", "type": "forcePushed"}, {"oid": "1e0d6582e93f2edf0a442dd060fc41baa4df12c9", "url": "https://github.com/eclipse-openj9/openj9/commit/1e0d6582e93f2edf0a442dd060fc41baa4df12c9", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-13T15:05:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0MjI3NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10983#discussion_r523142275", "bodyText": "Why isn't this accounted for in the offset itself?", "author": "andrewcraik", "createdAt": "2020-11-13T18:22:04Z", "path": "runtime/compiler/env/J9ClassEnv.cpp", "diffHunk": "@@ -515,6 +515,15 @@ static void addEntryForFieldImpl(TR_VMField *field, TR::TypeLayoutBuilder &tlb,\n       ListIterator<TR_VMField> iter(fieldsInfo.getFields());\n       for (TR_VMField *childField = iter.getFirst(); childField; childField = iter.getNext())\n          {\n+         IDATA offsetBaseForChild = field->offset + offsetBase;\n+         if (J9CLASS_HAS_4BYTE_PREPADDING(fieldClass))", "originalCommit": "1e0d6582e93f2edf0a442dd060fc41baa4df12c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI2MDc2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10983#discussion_r523260764", "bodyText": "There are two kinds of layout, the standalone layout and the flattened layout. For example given : inline class ValueLong { long l; } the standalone layout is:\nValueLong {\n    clazz \n    /* 4byte pre-padding */\n    long l (offset = 4) \n}\n\n//note `instanceFieldOffset` returns offset from header not from start of the object\n\nWe need to insert prepadding in order to statisfy alignment constraints for the long.\nHowever if it were flattened within another type,inline class ValueLongRef {ValueLong l; } the layout would be:\nValueLongRef {\n    clazz \n    /* 4byte pre-padding */\n    ValueLong { (offset = 4 in ValueLongRef) \n         //Value Long flattened layout, no pre-padding\n         long l (offset = 0 in ValueLong) //`instanceFieldOffset` still returns 4, this is why we need to subtract prepadding\n   }\n}\n\ninstanceFieldOffset always returns the offsets based on the standalone layout. So when a type is flattened we need to know if the standalone layout has pre-padding since that will be removed when its flattened.", "author": "tajila", "createdAt": "2020-11-13T22:12:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0MjI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ1MjY1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10983#discussion_r526452658", "bodyText": "This pattern repeats a few times.\nConsider introducing macros like J9CLASS_PREPADDING_SIZE, in which case this would convert into one liner:\nelementStartOffset += J9CLASS_PREPADDING_SIZE(class)\nAnother macro to consider is J9VMTHREAD_OBJECT_HEADER_WITHPREPADDING_SIZE", "author": "amicic", "createdAt": "2020-11-18T22:03:02Z", "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "diffHunk": "@@ -1152,13 +1157,18 @@ MM_ObjectAccessBarrier::copyObjectFieldsToFlattenedArrayElement(J9VMThread *vmTh\n void\n MM_ObjectAccessBarrier::copyObjectFieldsFromFlattenedArrayElement(J9VMThread *vmThread, J9ArrayClass *arrayClazz, j9object_t destObject, J9IndexableObject *arrayRef, I_32 index)\n {\n-\tUDATA const objectHeaderSize = J9VMTHREAD_OBJECT_HEADER_SIZE(vmThread);\n+\tUDATA elementStartOffset = J9VMTHREAD_OBJECT_HEADER_SIZE(vmThread);\n \tU_8 *elementAddress = (U_8*)indexableEffectiveAddress(vmThread, arrayRef, index, J9ARRAYCLASS_GET_STRIDE((J9Class *) arrayClazz));\n \tIDATA elementOffset = (elementAddress - (U_8*)arrayRef);\n \tJ9Class *elementClazz = J9GC_J9OBJECT_CLAZZ_THREAD(destObject, vmThread);\n \tAssert_MM_true(J9_IS_J9CLASS_VALUETYPE(elementClazz));\n \tAssert_MM_true(elementClazz == arrayClazz->leafComponentType);\n-\tcopyObjectFields(vmThread, elementClazz, (j9object_t) arrayRef, elementOffset, destObject, objectHeaderSize);\n+\n+\tif (J9CLASS_HAS_4BYTE_PREPADDING(elementClazz)) {\n+\t\telementStartOffset += sizeof(U_32);\n+\t}", "originalCommit": "1e0d6582e93f2edf0a442dd060fc41baa4df12c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2MDk1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10983#discussion_r526460951", "bodyText": "perhaps another macro ?\nlimit = J9CLASS_TOTAL_INSTANCE_SIZE_WITH_PREPADDING()", "author": "amicic", "createdAt": "2020-11-18T22:19:08Z", "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "diffHunk": "@@ -1445,9 +1453,9 @@ MM_ObjectAccessBarrier::structuralCompareFlattenedObjects(J9VMThread *vmThread,\n \t\t}\n \t} else {\n \t\t/* no instanceDescription bits needed on this path */\n-\t\tif (0 != firstFieldOffset) {\n+\t\tif (J9CLASS_HAS_4BYTE_PREPADDING(valueClass)) {\n \t\t\t/* subtract padding */\n-\t\t\toffset += firstFieldOffset;\n+\t\t\tlimit -= sizeof(U_32);", "originalCommit": "1e0d6582e93f2edf0a442dd060fc41baa4df12c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2MzQ3MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10983#discussion_r526463470", "bodyText": "Similar comment as before... I'd rather see mixedObjectGetHeaderSize/mixedObjectGetDataSize handle prepadding case which would slighly simplify caller's sites.", "author": "amicic", "createdAt": "2020-11-18T22:24:04Z", "path": "runtime/gc_include/ObjectAccessBarrierAPI.hpp", "diffHunk": "@@ -388,7 +388,12 @@ class MM_ObjectAccessBarrierAPI\n \tVMINLINE void\n \tcloneObject(J9VMThread *currentThread, j9object_t original, j9object_t copy, J9Class *objectClass)\n \t{\n-\t\tcopyObjectFields(currentThread, objectClass, original, mixedObjectGetHeaderSize(), copy, mixedObjectGetHeaderSize());\n+\t\tUDATA offset = mixedObjectGetHeaderSize();", "originalCommit": "1e0d6582e93f2edf0a442dd060fc41baa4df12c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b8af440797533c01fcac66e2e17c67ee81ef0bf1", "url": "https://github.com/eclipse-openj9/openj9/commit/b8af440797533c01fcac66e2e17c67ee81ef0bf1", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-19T21:19:48Z", "type": "forcePushed"}, {"oid": "045eb56befa7332e3bf5a684d01d7db7d5015c02", "url": "https://github.com/eclipse-openj9/openj9/commit/045eb56befa7332e3bf5a684d01d7db7d5015c02", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-19T21:29:02Z", "type": "forcePushed"}, {"oid": "1b13a81055b609d9261e3c12b244b073a034c30e", "url": "https://github.com/eclipse-openj9/openj9/commit/1b13a81055b609d9261e3c12b244b073a034c30e", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-19T21:30:28Z", "type": "forcePushed"}, {"oid": "05286298a3057ebe4b9fa27b3a639c3f455af696", "url": "https://github.com/eclipse-openj9/openj9/commit/05286298a3057ebe4b9fa27b3a639c3f455af696", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-19T21:38:27Z", "type": "forcePushed"}, {"oid": "db29461a548bdce9aa749d2c0748e554bfe79ecf", "url": "https://github.com/eclipse-openj9/openj9/commit/db29461a548bdce9aa749d2c0748e554bfe79ecf", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-23T00:05:34Z", "type": "forcePushed"}, {"oid": "0ef32dfc2621bd4861f78998e0d9ff15a404a0e8", "url": "https://github.com/eclipse-openj9/openj9/commit/0ef32dfc2621bd4861f78998e0d9ff15a404a0e8", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-26T17:25:58Z", "type": "forcePushed"}, {"oid": "d8b91a8161205a5b910fbe7a594bd3e0a6abab2a", "url": "https://github.com/eclipse-openj9/openj9/commit/d8b91a8161205a5b910fbe7a594bd3e0a6abab2a", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-26T23:18:10Z", "type": "forcePushed"}, {"oid": "8040e1b97d1e7efbfc5fd592a09275f988e99a21", "url": "https://github.com/eclipse-openj9/openj9/commit/8040e1b97d1e7efbfc5fd592a09275f988e99a21", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-27T02:26:44Z", "type": "forcePushed"}, {"oid": "7a6fbc9cb90fc0c8f39dcb16e70d0cd5d9296c57", "url": "https://github.com/eclipse-openj9/openj9/commit/7a6fbc9cb90fc0c8f39dcb16e70d0cd5d9296c57", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-27T02:28:08Z", "type": "forcePushed"}, {"oid": "8087ba3359d7b74384e8971d8a901dc740d5a520", "url": "https://github.com/eclipse-openj9/openj9/commit/8087ba3359d7b74384e8971d8a901dc740d5a520", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-27T02:55:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYzNTY5Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10983#discussion_r531635696", "bodyText": "nitpick: other macros start with J9CLASS_ (not J9_CLASS_)", "author": "amicic", "createdAt": "2020-11-27T14:34:38Z", "path": "runtime/oti/j9.h", "diffHunk": "@@ -310,11 +310,13 @@ static const struct { \\\n \n /* Macros for ValueTypes */\n #ifdef J9VM_OPT_VALHALLA_VALUE_TYPES\n+#define J9_CLASS_PAYLOAD_SIZE(clazz) J9_VALUETYPE_FLATTENED_SIZE(clazz)", "originalCommit": "8087ba3359d7b74384e8971d8a901dc740d5a520", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e2305b88b0049535aa1011d0ac6339d4cac444f5", "url": "https://github.com/eclipse-openj9/openj9/commit/e2305b88b0049535aa1011d0ac6339d4cac444f5", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-27T15:55:06Z", "type": "forcePushed"}, {"oid": "420514de5343aa9f4612d6a201a2cb868871a6da", "url": "https://github.com/eclipse-openj9/openj9/commit/420514de5343aa9f4612d6a201a2cb868871a6da", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-27T18:08:25Z", "type": "commit"}, {"oid": "420514de5343aa9f4612d6a201a2cb868871a6da", "url": "https://github.com/eclipse-openj9/openj9/commit/420514de5343aa9f4612d6a201a2cb868871a6da", "message": "Use flattened types as backfill\n\nThere is an issue with instance description bits with respect to\nflattened types. See #10070.\n\nCurrently, there is a mistach between the layout of a type on its own,\nand when it is flattened. This is due to the pre-padding required for\nstandalone valuetypes on compressedrefs and 32bit mode. The backfill has\nbeen\nused to track pre-padding. This is an error prone approach and has cause\nbugs in the past.\n\nThe only cases where pre-padding is needed is on compressedRefs where\nthere is at least one double-slot sized field. A better solution (to\nbackfill approach) is, instead of pre-padding, insert a single slot\nfield in the spot where the padding would be. This this means that if a\ntype (in compressedrefs/32bit mode) has at least one single slot or ref\nfield\nthe pre-padding is not needed. This leaves fields with only double slot\nfields. In these cases, we do not need to track the padding because\ndouble-slot fields cannot be references, so there is no mismatch with\nthe instance description bits between the standalone layout and the\nflattened layout.\n\nInstead of using backfill this PR proposes an approach that makes\npre-padding explicit ie `J9CLASS_HAS_4BYTE_PREPADDING`. When a type is\nflattened the pre-padding is eliminated, so offsets into flattened types\nneed to take this into account.\n\nThe backfill logic has been updated. The new back fill ordering is:\n1. instance singles\n2. instance objects\n3. flat end-aligned singles\n4. flat end-aligned objects\n5. flat end-unaligned singles\n6. flat end-unaligned objects\n7. hidden singles\n8. hidden objects\n\nThis ordering only applies to valuetypes, in the future this may be\nextended to reference types as well.\n\nIf a flattenable type requires double alignment in the past the type\nwill be pre-padded. Instead we will now try to use up the pre-padding\nwith the fields that do not require double alignment (the precedence is\nshown above). If no types are available then we will insert pre-padding\njust as before. If the type used for pre-padding is sized in manner that\na double can not be placed after it contiguously then the type is\npost-padded, this is no worse than adding pre-padding.\n\nThis PR also re-enables tests that previously didnt work due to issues\nwith field layouts.\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-11-27T18:08:25Z", "type": "forcePushed"}]}