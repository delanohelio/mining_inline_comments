{"pr_number": 9315, "pr_title": "Send CHTable updates with compilation requests", "pr_createdAt": "2020-04-22T05:05:29Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9315", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyMDUxMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9315#discussion_r413220512", "bodyText": "Incomplete comment.", "author": "ymanton", "createdAt": "2020-04-22T18:30:25Z", "path": "runtime/compiler/runtime/JITClientSession.hpp", "diffHunk": "@@ -346,14 +347,17 @@ class ClientSessionData\n    PersistentUnorderedMap<ClassLoaderStringPair, TR_OpaqueClassBlock*> & getClassByNameMap() { return _classByNameMap; }\n    PersistentUnorderedMap<J9Class *, UDATA *> & getClassChainDataCache() { return _classChainDataMap; }\n    PersistentUnorderedMap<J9ConstantPool *, TR_OpaqueClassBlock*> & getConstantPoolToClassMap() { return _constantPoolToClassMap; }\n-   void processUnloadedClasses(JITServer::ServerStream *stream, const std::vector<TR_OpaqueClassBlock*> &classes);\n+   void initializeUnloadedClassAddrRanges(const std::vector<TR_AddressRange> &unloadedClassRanges, int32_t maxRanges);\n+   void processUnloadedClasses(const std::vector<TR_OpaqueClassBlock*> &classes, bool updateUnloadedClasses);\n    TR::Monitor *getROMMapMonitor() { return _romMapMonitor; }\n    TR::Monitor *getClassMapMonitor() { return _classMapMonitor; }\n    TR::Monitor *getClassChainDataMapMonitor() { return _classChainDataMapMonitor; }\n    TR_IPBytecodeHashTableEntry *getCachedIProfilerInfo(TR_OpaqueMethodBlock *method, uint32_t byteCodeIndex, bool *methodInfoPresent);\n    bool cacheIProfilerInfo(TR_OpaqueMethodBlock *method, uint32_t byteCodeIndex, TR_IPBytecodeHashTableEntry *entry, bool isCompiled);\n    VMInfo *getOrCacheVMInfo(JITServer::ServerStream *stream);\n-   void clearCaches(); // destroys _chTableClassMap, _romClassMap and _J9MethodMap\n+   void clearCaches(); // destroys _chTableClassMap, _romClassMap and _J9MethodMap and ", "originalCommit": "87df459cb235103b300c6c8b41df6a4c3abf96a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ4MTIxNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9315#discussion_r413481217", "bodyText": "Fixed", "author": "mpirvu", "createdAt": "2020-04-23T03:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyMDUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4NTI3Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9315#discussion_r413285272", "bodyText": "Can we add a comment to explain the false? e.g.\n// This function updates multiple caches based on the newly unloaded classes list. Pass false here to indicate\n// that we want the unloaded class ranges table cache excluded since we just retrieved the entire table and it\n// should therefore already be up to date.", "author": "ymanton", "createdAt": "2020-04-22T19:59:33Z", "path": "runtime/compiler/control/JITServerCompilationThread.cpp", "diffHunk": "@@ -373,29 +375,56 @@ TR::CompilationInfoPerThreadRemote::processEntry(TR_MethodToBeCompiled &entry, J\n       clientSession->getSequencingMonitor()->exit();\n \n       // At this point I know that all preceeding requests have been processed\n-      // Free data for all classes that were unloaded for this sequence number\n-      // Redefined classes are marked as unloaded, since they need to be cleared\n-      // from the ROM class cache.\n-      clientSession->processUnloadedClasses(stream, unloadedClasses); // this locks getROMMapMonitor()\n-\n-      auto chTable = (JITServerPersistentCHTable*)compInfo->getPersistentInfo()->getPersistentCHTable();\n-      // TODO: is chTable always non-null?\n-      // TODO: we could send JVM info that is global and does not change together with CHTable\n-      // The following will acquire CHTable monitor and VMAccess, send a message and then release them\n-      bool initialized = chTable->initializeIfNeeded(_vm);\n-\n-      // A thread that initialized the CHTable does not have to apply the incremental update\n-      if (!initialized)\n+      // and only thread can ever be present in this section\n+      if (!clientSession->cachesAreCleared())\n          {\n+         // Free data for all classes that were unloaded for this sequence number\n+         // Redefined classes are marked as unloaded, since they need to be cleared\n+         // from the ROM class cache.\n+         if (unloadedClasses.empty())\n+            {\n+            if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+               TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"compThreadID=%d has no class to unload for clientUID %llu\", \n+                  getCompThreadId(), (unsigned long long)clientId);\n+            }\n+          else\n+            {\n+            clientSession->processUnloadedClasses(unloadedClasses, true); // this locks getROMMapMonitor()\n+            }\n+\n          // Process the CHTable updates in order\n-         stream->write(JITServer::MessageType::CHTable_getClassInfoUpdates, JITServer::Void());\n-         auto recv = stream->read<std::string, std::string>();\n-         const std::string &chtableUnloads = std::get<0>(recv);\n-         const std::string &chtableMods = std::get<1>(recv);\n          // Note that applying the updates will acquire the CHTable monitor and VMAccess\n+         auto chTable = (JITServerPersistentCHTable*)compInfo->getPersistentInfo()->getPersistentCHTable();\n+         TR_ASSERT_FATAL(chTable->isInitialized() || (chtableUnloads.empty() && chtableMods.empty()), \n+                         \"CHTable must have been initialized for clientUID=%llu\", (unsigned long long)clientId);\n          if (!chtableUnloads.empty() || !chtableMods.empty())\n             chTable->doUpdate(_vm, chtableUnloads, chtableMods);\n          }\n+      else // Internal caches are empty\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"compThreadID=%d will ask for address ranges of unloaded classes and CHTable for clientUID %llu\", \n+               getCompThreadId(), (unsigned long long)clientId);\n+         stream->write(JITServer::MessageType::getUnloadedClassRanges, JITServer::Void());\n+         auto response = stream->read<std::vector<TR_AddressRange>, int32_t, std::string>();\n+         // TODO: we could send JVM info that is global and does not change together with CHTable\n+         auto &unloadedClassRanges = std::get<0>(response);\n+         auto maxRanges = std::get<1>(response);\n+         std::string &serializedCHTable = std::get<2>(response);\n+\n+         clientSession->initializeUnloadedClassAddrRanges(unloadedClassRanges, maxRanges);\n+         if (!unloadedClasses.empty())\n+            clientSession->processUnloadedClasses(unloadedClasses, false);", "originalCommit": "87df459cb235103b300c6c8b41df6a4c3abf96a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ4MTI2Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9315#discussion_r413481263", "bodyText": "Added", "author": "mpirvu", "createdAt": "2020-04-23T03:26:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4NTI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4NjE2NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9315#discussion_r413286165", "bodyText": "Can we change the message name to getUnloadedClassRangesAndCHTable or something like that? It would make the rest of the code a little clearer.", "author": "ymanton", "createdAt": "2020-04-22T20:00:41Z", "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -209,7 +209,11 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n             OMR::CriticalSection getAddressSetRanges(assumptionTableMutex);\n             unloadedClasses->getRanges(ranges);\n             }\n-         client->write(response, ranges, unloadedClasses->getMaxRanges());\n+         // Add the entire CHTable as well\n+         auto table = (JITClientPersistentCHTable*)comp->getPersistentInfo()->getPersistentCHTable();\n+         std::string encoded = FlatPersistentClassInfo::serializeHierarchy(table);\n+\n+         client->write(response, ranges, unloadedClasses->getMaxRanges(), encoded);", "originalCommit": "87df459cb235103b300c6c8b41df6a4c3abf96a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ4MTMzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9315#discussion_r413481331", "bodyText": "Done", "author": "mpirvu", "createdAt": "2020-04-23T03:26:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4NjE2NQ=="}], "type": "inlineReview"}, {"oid": "481d5c3e71665ebb77d66f15155d1d58643b12e1", "url": "https://github.com/eclipse-openj9/openj9/commit/481d5c3e71665ebb77d66f15155d1d58643b12e1", "message": "Send CHTable updates with compilation requests\n\nIn this commit the list of unloaded classes and the serialized version\nof the CHTable updates are sent to the JITServer together with the\ncompilation request, rather than in a separate message. This has\ntwo advantages:\n(1) Fewer messages\n(2) Serialization of compilation requests is sped up because it does\nnot have to wait for a round trip to ask for CHTable updates.\nIf caches are cleared (this includes the server version of CHTable)\nthen JITServer will still have to ask for the entire set of ranges\nof unloaded classes and the entire CHTable (not just modifications\nsince the last message).\nAll these updates are processed in order based on the seqNo sent by\nthe client.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-04-23T03:25:08Z", "type": "commit"}, {"oid": "481d5c3e71665ebb77d66f15155d1d58643b12e1", "url": "https://github.com/eclipse-openj9/openj9/commit/481d5c3e71665ebb77d66f15155d1d58643b12e1", "message": "Send CHTable updates with compilation requests\n\nIn this commit the list of unloaded classes and the serialized version\nof the CHTable updates are sent to the JITServer together with the\ncompilation request, rather than in a separate message. This has\ntwo advantages:\n(1) Fewer messages\n(2) Serialization of compilation requests is sped up because it does\nnot have to wait for a round trip to ask for CHTable updates.\nIf caches are cleared (this includes the server version of CHTable)\nthen JITServer will still have to ask for the entire set of ranges\nof unloaded classes and the entire CHTable (not just modifications\nsince the last message).\nAll these updates are processed in order based on the seqNo sent by\nthe client.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-04-23T03:25:08Z", "type": "forcePushed"}]}