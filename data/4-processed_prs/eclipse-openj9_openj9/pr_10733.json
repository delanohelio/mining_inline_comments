{"pr_number": 10733, "pr_title": "BytecodeInterpreter changes to adopt OpenJDK MethodHandles", "pr_createdAt": "2020-09-28T22:11:48Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10733", "timeline": [{"oid": "a92f85449b18a11f2aa9825a5febc503d596dea9", "url": "https://github.com/eclipse-openj9/openj9/commit/a92f85449b18a11f2aa9825a5febc503d596dea9", "message": "Note that invokehandlegeneric is unused with OpenJDK MethodHandles\n\nFor OpenJDK MethodHandles (MH), MH.invoke and MH.invokeExact both share\ncommon functionality. So, they are both translated to invokehandle.\n\nThus, invokehandlegeneric stays unused with OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-09-28T22:19:55Z", "type": "forcePushed"}, {"oid": "1d0255f86b0bb0d8db2d6686e8e2cb8bcef3f50b", "url": "https://github.com/eclipse-openj9/openj9/commit/1d0255f86b0bb0d8db2d6686e8e2cb8bcef3f50b", "message": "Note that invokehandlegeneric is unused with OpenJDK MethodHandles\n\nFor OpenJDK MethodHandles (MH), MH.invoke and MH.invokeExact both share\ncommon functionality. So, they are both translated to invokehandle.\n\nThus, invokehandlegeneric stays unused with OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-09-28T22:37:17Z", "type": "forcePushed"}, {"oid": "1ab36bbac1ffd18fdef13d6e67e6d59c99f533a9", "url": "https://github.com/eclipse-openj9/openj9/commit/1ab36bbac1ffd18fdef13d6e67e6d59c99f533a9", "message": "Note that invokehandlegeneric is unused with OpenJDK MethodHandles\n\nFor OpenJDK MethodHandles (MH), MH.invoke and MH.invokeExact both share\ncommon functionality. So, they are both translated to invokehandle.\n\nThus, invokehandlegeneric stays unused with OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-09-28T22:41:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3NTU3NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r496975574", "bodyText": "I dont think we really need volatile here?", "author": "fengxue-IS", "createdAt": "2020-09-29T19:11:57Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8054,26 +8109,75 @@ class INTERPRETER_CLASS\n \t\t}\n done:\n \t\treturn rc;\n-#else\n-\tAssert_VM_unreachable();\n-\treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n \t}\n+#elif defined(J9VM_OPT_OPENJDK_METHODHANDLE) /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\tVMINLINE VM_BytecodeAction\n+\tinvokehandle(REGISTER_ARGS_LIST)\n+\t{\n+retry:\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\n+\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef *)ramConstantPool) + index;\n+\n+\t\tUDATA invokeCacheIndex = ramMethodRef->methodIndexAndArgCount >> 8;\n+\t\tJ9InvokeCacheEntry *resultEntry = ((J9InvokeCacheEntry *)J9_CLASS_FROM_CP(ramConstantPool)->invokeCache) + invokeCacheIndex;\n+\n+\t\tj9object_t volatile memberNameObject = resultEntry->target;", "originalCommit": "1ab36bbac1ffd18fdef13d6e67e6d59c99f533a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU5MzMxNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497593315", "bodyText": "Updated.", "author": "babsingh", "createdAt": "2020-09-30T15:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3NTU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3NTcwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r496975707", "bodyText": "Maybe put the casting in brackets? This help to make the pointer addition target more clear\n((J9InvokeCacheEntry *)ramConstantPool->ramClass->callSites) + index;", "author": "fengxue-IS", "createdAt": "2020-09-29T19:12:03Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8004,35 +8007,87 @@ class INTERPRETER_CLASS\n \t\t\t\tgoto retry;\n \t\t\t}\n \t\t}\n+\n \t\treturn rc;\n-#else\n-\tAssert_VM_unreachable();\n-\treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n \t}\n+#elif defined(J9VM_OPT_OPENJDK_METHODHANDLE) /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\tVMINLINE VM_BytecodeAction\n+\tinvokedynamic(REGISTER_ARGS_LIST)\n+\t{\n+retry:\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\n+\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\tJ9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *)ramConstantPool->ramClass->callSites + index;", "originalCommit": "1ab36bbac1ffd18fdef13d6e67e6d59c99f533a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU5MzM5Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497593396", "bodyText": "Updated.", "author": "babsingh", "createdAt": "2020-09-30T15:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3NTcwNw=="}], "type": "inlineReview"}, {"oid": "f43a6978bcb3a63dfad417ad18bf80ac0ccd6030", "url": "https://github.com/eclipse-openj9/openj9/commit/f43a6978bcb3a63dfad417ad18bf80ac0ccd6030", "message": "Note that invokehandlegeneric is unused with OpenJDK MethodHandles\n\nFor OpenJDK MethodHandles (MH), MH.invoke and MH.invokeExact both share\ncommon functionality. So, they are both translated to invokehandle.\n\nThus, invokehandlegeneric stays unused with OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-09-30T15:14:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYxOTMwMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497619302", "bodyText": "Please use sp -= 1", "author": "gacholio", "createdAt": "2020-09-30T15:52:04Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8119,11 +8223,186 @@ class INTERPRETER_CLASS\n \t\t}\n done:\n \t\treturn rc;\n-#else\n+#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t/* When J9VM_OPT_OPENJDK_METHODHANDLE is enabled, MH.invoke and MH.invokeExact are\n+\t * both translated to invokehandle. So, invokehandlegeneric is not used with OpenJDK\n+\t * MethodHandles.\n+\t */\n \tAssert_VM_unreachable();\n \treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n+#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t}\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tVMINLINE VM_BytecodeAction\n+\tinvokeBasic(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\t\tUDATA methodArgCount = 0;\n+\n+\t\tif (fromJIT) {\n+\t\t\tmethodArgCount = _currentThread->tempSlot;\n+\t\t} else {\n+\t\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\t\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\t\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef *)ramConstantPool) + index;\n+\t\t\tUDATA volatile methodIndexAndArgCount = ramMethodRef->methodIndexAndArgCount;\n+\t\t\tmethodArgCount = (methodIndexAndArgCount & 0xFF);\n+\t\t}\n+\n+\t\tj9object_t mhReceiver = ((j9object_t *)_sp)[methodArgCount];\n+\t\tif (J9_UNEXPECTED(NULL == mhReceiver)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tj9object_t lambdaForm = J9VMJAVALANGINVOKEMETHODHANDLE_FORM(_currentThread, mhReceiver);\n+\t\tj9object_t memberName = J9VMJAVALANGINVOKELAMBDAFORM_VMENTRY(_currentThread, lambdaForm);\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberName, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToStaticSpecial(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(_sendMethod);\n+\t\t\tUDATA methodArgCount = romMethod->argCount;\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;", "originalCommit": "f43a6978bcb3a63dfad417ad18bf80ac0ccd6030", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgwMTc2NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497801765", "bodyText": "Updated.", "author": "babsingh", "createdAt": "2020-09-30T21:09:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYxOTMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYxOTYwNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497619605", "bodyText": "Same comment as above.", "author": "gacholio", "createdAt": "2020-09-30T15:52:32Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8119,11 +8223,186 @@ class INTERPRETER_CLASS\n \t\t}\n done:\n \t\treturn rc;\n-#else\n+#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t/* When J9VM_OPT_OPENJDK_METHODHANDLE is enabled, MH.invoke and MH.invokeExact are\n+\t * both translated to invokehandle. So, invokehandlegeneric is not used with OpenJDK\n+\t * MethodHandles.\n+\t */\n \tAssert_VM_unreachable();\n \treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n+#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t}\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tVMINLINE VM_BytecodeAction\n+\tinvokeBasic(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\t\tUDATA methodArgCount = 0;\n+\n+\t\tif (fromJIT) {\n+\t\t\tmethodArgCount = _currentThread->tempSlot;\n+\t\t} else {\n+\t\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\t\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\t\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef *)ramConstantPool) + index;\n+\t\t\tUDATA volatile methodIndexAndArgCount = ramMethodRef->methodIndexAndArgCount;\n+\t\t\tmethodArgCount = (methodIndexAndArgCount & 0xFF);\n+\t\t}\n+\n+\t\tj9object_t mhReceiver = ((j9object_t *)_sp)[methodArgCount];\n+\t\tif (J9_UNEXPECTED(NULL == mhReceiver)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tj9object_t lambdaForm = J9VMJAVALANGINVOKEMETHODHANDLE_FORM(_currentThread, mhReceiver);\n+\t\tj9object_t memberName = J9VMJAVALANGINVOKELAMBDAFORM_VMENTRY(_currentThread, lambdaForm);\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberName, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToStaticSpecial(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(_sendMethod);\n+\t\t\tUDATA methodArgCount = romMethod->argCount;\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;\n+\t\t\t\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToVirtual(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\t_sendMethod = *(J9Method **)(((UDATA)receiverClass) + methodID->vTableIndex);\n+\n+\t\tif (fromJIT) {\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;", "originalCommit": "f43a6978bcb3a63dfad417ad18bf80ac0ccd6030", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgwMTIyOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497801228", "bodyText": "Updated.", "author": "babsingh", "createdAt": "2020-09-30T21:07:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYxOTYwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYxOTgzMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497619833", "bodyText": "Extra line.", "author": "gacholio", "createdAt": "2020-09-30T15:52:51Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8119,11 +8223,186 @@ class INTERPRETER_CLASS\n \t\t}\n done:\n \t\treturn rc;\n-#else\n+#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t/* When J9VM_OPT_OPENJDK_METHODHANDLE is enabled, MH.invoke and MH.invokeExact are\n+\t * both translated to invokehandle. So, invokehandlegeneric is not used with OpenJDK\n+\t * MethodHandles.\n+\t */\n \tAssert_VM_unreachable();\n \treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n+#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t}\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tVMINLINE VM_BytecodeAction\n+\tinvokeBasic(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\t\tUDATA methodArgCount = 0;\n+\n+\t\tif (fromJIT) {\n+\t\t\tmethodArgCount = _currentThread->tempSlot;\n+\t\t} else {\n+\t\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\t\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\t\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef *)ramConstantPool) + index;\n+\t\t\tUDATA volatile methodIndexAndArgCount = ramMethodRef->methodIndexAndArgCount;\n+\t\t\tmethodArgCount = (methodIndexAndArgCount & 0xFF);\n+\t\t}\n+\n+\t\tj9object_t mhReceiver = ((j9object_t *)_sp)[methodArgCount];\n+\t\tif (J9_UNEXPECTED(NULL == mhReceiver)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tj9object_t lambdaForm = J9VMJAVALANGINVOKEMETHODHANDLE_FORM(_currentThread, mhReceiver);\n+\t\tj9object_t memberName = J9VMJAVALANGINVOKELAMBDAFORM_VMENTRY(_currentThread, lambdaForm);\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberName, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToStaticSpecial(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(_sendMethod);\n+\t\t\tUDATA methodArgCount = romMethod->argCount;\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;\n+\t\t\t\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToVirtual(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\t_sendMethod = *(J9Method **)(((UDATA)receiverClass) + methodID->vTableIndex);\n+\n+\t\tif (fromJIT) {\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;\n+\t\t\t\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToInterface(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\tJ9Method *method = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\t\tUDATA vTableOffset = methodID->vTableIndex;\n+", "originalCommit": "f43a6978bcb3a63dfad417ad18bf80ac0ccd6030", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgwMTQ4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497801488", "bodyText": "Updated.", "author": "babsingh", "createdAt": "2020-09-30T21:08:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYxOTgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYyMDU2Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497620563", "bodyText": "And again.", "author": "gacholio", "createdAt": "2020-09-30T15:53:57Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8119,11 +8223,186 @@ class INTERPRETER_CLASS\n \t\t}\n done:\n \t\treturn rc;\n-#else\n+#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t/* When J9VM_OPT_OPENJDK_METHODHANDLE is enabled, MH.invoke and MH.invokeExact are\n+\t * both translated to invokehandle. So, invokehandlegeneric is not used with OpenJDK\n+\t * MethodHandles.\n+\t */\n \tAssert_VM_unreachable();\n \treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n+#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t}\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tVMINLINE VM_BytecodeAction\n+\tinvokeBasic(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\t\tUDATA methodArgCount = 0;\n+\n+\t\tif (fromJIT) {\n+\t\t\tmethodArgCount = _currentThread->tempSlot;\n+\t\t} else {\n+\t\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\t\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\t\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef *)ramConstantPool) + index;\n+\t\t\tUDATA volatile methodIndexAndArgCount = ramMethodRef->methodIndexAndArgCount;\n+\t\t\tmethodArgCount = (methodIndexAndArgCount & 0xFF);\n+\t\t}\n+\n+\t\tj9object_t mhReceiver = ((j9object_t *)_sp)[methodArgCount];\n+\t\tif (J9_UNEXPECTED(NULL == mhReceiver)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tj9object_t lambdaForm = J9VMJAVALANGINVOKEMETHODHANDLE_FORM(_currentThread, mhReceiver);\n+\t\tj9object_t memberName = J9VMJAVALANGINVOKELAMBDAFORM_VMENTRY(_currentThread, lambdaForm);\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberName, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToStaticSpecial(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(_sendMethod);\n+\t\t\tUDATA methodArgCount = romMethod->argCount;\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;\n+\t\t\t\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToVirtual(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\t_sendMethod = *(J9Method **)(((UDATA)receiverClass) + methodID->vTableIndex);\n+\n+\t\tif (fromJIT) {\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;\n+\t\t\t\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToInterface(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\tJ9Method *method = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\t\tUDATA vTableOffset = methodID->vTableIndex;\n+\n+\n+\t\tif (J9_ARE_ANY_BITS_SET(vTableOffset, J9_JNI_MID_INTERFACE)) {\n+\t\t\tUDATA iTableIndex = vTableOffset & ~(UDATA)J9_JNI_MID_INTERFACE;\n+\t\t\tJ9Class *interfaceClass = J9_CLASS_FROM_METHOD(method);\n+\t\t\tvTableOffset = 0;\n+\t\t\tJ9ITable * iTable = receiverClass->lastITable;\n+\t\t\tif (interfaceClass == iTable->interfaceClass) {\n+\t\t\t\tgoto foundITable;\n+\t\t\t}\n+\t\t\tiTable = (J9ITable*)receiverClass->iTable;\n+\t\t\twhile (NULL != iTable) {\n+\t\t\t\tif (interfaceClass == iTable->interfaceClass) {\n+\t\t\t\t\treceiverClass->lastITable = iTable;\n+foundITable:\n+\t\t\t\t\tvTableOffset = ((UDATA*)(iTable + 1))[iTableIndex];\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tiTable = iTable->next;\n+\t\t\t}\n+\t\t}\n+\n+\t\t_sendMethod = *(J9Method **)(((UDATA)receiverClass) + vTableOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;", "originalCommit": "f43a6978bcb3a63dfad417ad18bf80ac0ccd6030", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgwMTY3OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497801678", "bodyText": "Updated.", "author": "babsingh", "createdAt": "2020-09-30T21:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYyMDU2Mw=="}], "type": "inlineReview"}, {"oid": "d1813f49ae841492aa4dd9bb66f99271cfacdd51", "url": "https://github.com/eclipse-openj9/openj9/commit/d1813f49ae841492aa4dd9bb66f99271cfacdd51", "message": "Note that invokehandlegeneric is unused with OpenJDK MethodHandles\n\nFor OpenJDK MethodHandles (MH), MH.invoke and MH.invokeExact both share\ncommon functionality. So, they are both translated to invokehandle.\n\nThus, invokehandlegeneric stays unused with OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-09-30T21:06:23Z", "type": "forcePushed"}, {"oid": "738098532ba7af2ebc5f8f197426a5cbcd8ede9d", "url": "https://github.com/eclipse-openj9/openj9/commit/738098532ba7af2ebc5f8f197426a5cbcd8ede9d", "message": "Add INLs to support OpenJDK MethodHandles\n\nThe new INLs lead to GOTO_RUN_METHOD.\n\n1. invokeBasic: [Virtual] this.invokeBasic(args ..., mn)\nThe MH receiver is located before the arguments.\n  - java_lang_invoke_MethodHandle::form -> LambdaForm\n  -- java_lang_invoke_LambdaForm::vmentry -> MemberName\n  --- java_lang_invoke_MemberName::vmtarget -> J9Method*\n  ---- invoke_target(vmtarget)\n\n2. linkToStaticSpecial: [Static] MH.linkTo*(this, args ..., mn)\nThe object at the top of the stack is a MemberName instance.\n  - java_lang_invoke_MemberName::vmtarget -> J9Method*\n  -- invoke_target(vmtarget)\n\n3. linkToVirtual: [Static] MH.linkTo*(this, args ..., mn)\nThe object at the top of the stack is a MemberName instance.\n  - java_lang_invoke_MemberName::vmtarget -> J9JNIMethodID*\n  -- invoke_target(receiverClass + vmtarget->vTableIndex)\n\n4. linkToInterface: [Static] MH.linkTo*(this, args ..., mn)\nThe object at the top of the stack is a MemberName instance.\n  - java_lang_invoke_MemberName::vmtarget -> J9JNIMethodID*\n  -- iTable query to find the vTableOffset\n  --- invoke_target(receiverClass + vTableOffset)\n\nFor INL invocations from the JIT,\n1. invokeBasic: JIT return address is restored and j2i transition is\ninvoked.\n2. linkTo*: the MemberName object is moved in front of the first\nargument before the JIT return address is restored and j2i transition is\ninvoked.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-09-30T21:14:43Z", "type": "commit"}, {"oid": "66575d2705cd234940398540c9f0d6d9d77642cc", "url": "https://github.com/eclipse-openj9/openj9/commit/66575d2705cd234940398540c9f0d6d9d77642cc", "message": "Rewrite invokedynamic to work with OpenJDK MethodHandles\n\nThe execution bytecode has changed to GOTO_RUN_METHOD.\n\nThe resolution method has changed. MethodHandleNatives.linkCallSite is\ncalled for resolution. It returns two items: 1) MemberName object and 2)\nMethodHandle object.\n\nThe _sendMethod is derived from the MemberName object:\njava_lang_invoke_MemberName::vmtarget -> J9Method*.\n\nThe MethodHandle object is pushed on top of the stack since it is the\nlast argument for the _sendMethod.\n\nThen, the _sendMethod is invoked.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-09-30T21:14:46Z", "type": "commit"}, {"oid": "a378f4877543c3464ddfda630e099130c2446915", "url": "https://github.com/eclipse-openj9/openj9/commit/a378f4877543c3464ddfda630e099130c2446915", "message": "Rewrite invokehandle to work with OpenJDK MethodHandles\n\nThe execution bytecode has changed to GOTO_RUN_METHOD.\n\nThe resolution method has changed. MethodHandleNatives.linkMethod is\ncalled for resolution. It returns two items: 1) MemberName object and 2)\nMethodHandle object.\n\nThe _sendMethod is derived from the MemberName object:\njava_lang_invoke_MemberName::vmtarget -> J9Method*.\n\nThe MethodHandle object is pushed on top of the stack since it is the\nlast argument for the _sendMethod.\n\nThen, the _sendMethod is invoked.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-09-30T21:14:46Z", "type": "commit"}, {"oid": "de2822dc95c6e752972651cdca0e17109d3c67b7", "url": "https://github.com/eclipse-openj9/openj9/commit/de2822dc95c6e752972651cdca0e17109d3c67b7", "message": "Note that invokehandlegeneric is unused with OpenJDK MethodHandles\n\nFor OpenJDK MethodHandles (MH), MH.invoke and MH.invokeExact both share\ncommon functionality. So, they are both translated to invokehandle.\n\nThus, invokehandlegeneric stays unused with OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-09-30T21:14:46Z", "type": "commit"}, {"oid": "de2822dc95c6e752972651cdca0e17109d3c67b7", "url": "https://github.com/eclipse-openj9/openj9/commit/de2822dc95c6e752972651cdca0e17109d3c67b7", "message": "Note that invokehandlegeneric is unused with OpenJDK MethodHandles\n\nFor OpenJDK MethodHandles (MH), MH.invoke and MH.invokeExact both share\ncommon functionality. So, they are both translated to invokehandle.\n\nThus, invokehandlegeneric stays unused with OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-09-30T21:14:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NzcwMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497977703", "bodyText": "This doesn't handle the J9_ITABLE_OFFSET_TAG_BITS special cases.  Are they filtered somewhere else?", "author": "DanHeidinga", "createdAt": "2020-10-01T04:31:32Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8119,11 +8223,186 @@ class INTERPRETER_CLASS\n \t\t}\n done:\n \t\treturn rc;\n-#else\n+#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t/* When J9VM_OPT_OPENJDK_METHODHANDLE is enabled, MH.invoke and MH.invokeExact are\n+\t * both translated to invokehandle. So, invokehandlegeneric is not used with OpenJDK\n+\t * MethodHandles.\n+\t */\n \tAssert_VM_unreachable();\n \treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n+#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t}\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tVMINLINE VM_BytecodeAction\n+\tinvokeBasic(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\t\tUDATA methodArgCount = 0;\n+\n+\t\tif (fromJIT) {\n+\t\t\tmethodArgCount = _currentThread->tempSlot;\n+\t\t} else {\n+\t\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\t\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\t\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef *)ramConstantPool) + index;\n+\t\t\tUDATA volatile methodIndexAndArgCount = ramMethodRef->methodIndexAndArgCount;\n+\t\t\tmethodArgCount = (methodIndexAndArgCount & 0xFF);\n+\t\t}\n+\n+\t\tj9object_t mhReceiver = ((j9object_t *)_sp)[methodArgCount];\n+\t\tif (J9_UNEXPECTED(NULL == mhReceiver)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tj9object_t lambdaForm = J9VMJAVALANGINVOKEMETHODHANDLE_FORM(_currentThread, mhReceiver);\n+\t\tj9object_t memberName = J9VMJAVALANGINVOKELAMBDAFORM_VMENTRY(_currentThread, lambdaForm);\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberName, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToStaticSpecial(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(_sendMethod);\n+\t\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t_sp -= 1;\n+\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToVirtual(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\t_sendMethod = *(J9Method **)(((UDATA)receiverClass) + methodID->vTableIndex);\n+\n+\t\tif (fromJIT) {\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t_sp -= 1;\n+\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToInterface(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\tJ9Method *method = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\t\tUDATA vTableOffset = methodID->vTableIndex;\n+\n+\t\tif (J9_ARE_ANY_BITS_SET(vTableOffset, J9_JNI_MID_INTERFACE)) {\n+\t\t\tUDATA iTableIndex = vTableOffset & ~(UDATA)J9_JNI_MID_INTERFACE;\n+\t\t\tJ9Class *interfaceClass = J9_CLASS_FROM_METHOD(method);\n+\t\t\tvTableOffset = 0;\n+\t\t\tJ9ITable * iTable = receiverClass->lastITable;\n+\t\t\tif (interfaceClass == iTable->interfaceClass) {\n+\t\t\t\tgoto foundITable;\n+\t\t\t}\n+\t\t\tiTable = (J9ITable*)receiverClass->iTable;\n+\t\t\twhile (NULL != iTable) {\n+\t\t\t\tif (interfaceClass == iTable->interfaceClass) {\n+\t\t\t\t\treceiverClass->lastITable = iTable;\n+foundITable:\n+\t\t\t\t\tvTableOffset = ((UDATA*)(iTable + 1))[iTableIndex];", "originalCommit": "de2822dc95c6e752972651cdca0e17109d3c67b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzMTMyOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r498231329", "bodyText": "I don't think they are being filtered (++ @fengxue-IS to confirm?). We have missed the J9_ITABLE_OFFSET_TAG_BITS special cases.\nhttps://github.com/eclipse/openj9/blob/bdd5791eebf1356c6736dffab8b9e8edfc0c89c1/runtime/codert_vm/cnathelp.cpp#L123-L131\nWe will add similar code here to handle J9_ITABLE_OFFSET_TAG_BITS.", "author": "babsingh", "createdAt": "2020-10-01T13:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NzcwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk4MTU5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497981591", "bodyText": "I don't see the definition of J9InvokeCacheEntry in this PR or in the already committed code.  Am I missing it?\nHard to tell if the barriers are correct in this path without seeing that code and the updates to resolveInvokeDynmaic", "author": "DanHeidinga", "createdAt": "2020-10-01T04:48:37Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8004,35 +8007,87 @@ class INTERPRETER_CLASS\n \t\t\t\tgoto retry;\n \t\t\t}\n \t\t}\n+\n \t\treturn rc;\n-#else\n-\tAssert_VM_unreachable();\n-\treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n \t}\n+#elif defined(J9VM_OPT_OPENJDK_METHODHANDLE) /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\tVMINLINE VM_BytecodeAction\n+\tinvokedynamic(REGISTER_ARGS_LIST)\n+\t{\n+retry:\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\n+\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\tJ9InvokeCacheEntry *invokeCache = ((J9InvokeCacheEntry *)ramConstantPool->ramClass->callSites) + index;", "originalCommit": "de2822dc95c6e752972651cdca0e17109d3c67b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIyMzEwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r498223106", "bodyText": "J9InvokeCacheEntry is not part of this PR.\ntypedef struct J9InvokeCacheEntry {\n\tj9object_t target;\n\tj9object_t appendix;\n} J9InvokeCacheEntry;\n\nJ9InvokeCacheEntry is planned to be added in the resolvesupport.cpp changes (separate PR).", "author": "babsingh", "createdAt": "2020-10-01T12:57:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk4MTU5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzMjg3Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r498232873", "bodyText": "We read both values from the cache here without a memory barrier.  How do we ensure that both are visible at this point?  Are they always written such that:\ncache->appendix = ....;\n<membarrier>\ncache->target = ....;\n\nso that the store of appendix can't be moved passed the store of target or another racing thread can read incompletely resolved values", "author": "DanHeidinga", "createdAt": "2020-10-01T13:12:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk4MTU5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzNDA0Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r498234042", "bodyText": "Can you link the separate PR here?  We need to review both parts together to tell if there's a problem.\nAlso, multiple threads can race to resolve an invokedynamic.  The old resolve code used a CAS to resolve the race.  How is that handled with the two slot solution?", "author": "DanHeidinga", "createdAt": "2020-10-01T13:14:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk4MTU5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI0MzQ1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r498243456", "bodyText": "In resolvesupport.cpp, @fengxue-IS has added sync code. The sync code will assure that both values are written before any thread reads them.\ntarget will be NULL until the resolution is complete. So, all threads will take the resolve path if target is NULL. In the resolve path, there will be a spin loop which will prevent the threads to proceed until the resolved values are successfully written. target will be written last to indicate the completion of resolution.\n@fengxue-IS thumbs up to confirm?", "author": "babsingh", "createdAt": "2020-10-01T13:27:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk4MTU5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI1MjEzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r498252138", "bodyText": "Can you link the separate PR here?\n\nyes, the resolution PR will be linked with this PR. it still needs to be created.\n\nThe old resolve code used a CAS to resolve the race. How is that handled with the two slot solution?\n\nSimilar spin loop / CAS approach. The last slot to be written is used to indicate the end of resolution. The first slot is used to indicate the start of resolution.", "author": "babsingh", "createdAt": "2020-10-01T13:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk4MTU5MQ=="}], "type": "inlineReview"}]}