{"pr_number": 10245, "pr_title": "Alternative implementation of collect implementor", "pr_createdAt": "2020-07-24T18:58:09Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10245", "timeline": [{"oid": "d900c32bfaf17c2e87b6963142f7d0dbce11be0c", "url": "https://github.com/eclipse-openj9/openj9/commit/d900c32bfaf17c2e87b6963142f7d0dbce11be0c", "message": "Alternative implementation of collect implementor\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-24T19:04:38Z", "type": "forcePushed"}, {"oid": "cf1680e58529988a346fb2152869548330040edc", "url": "https://github.com/eclipse-openj9/openj9/commit/cf1680e58529988a346fb2152869548330040edc", "message": "Delegate implementor collection to JITServer client\n\nAlternative implementation of #10118.\nInstead of walking the class tree on the server, constructing\nthe list of resolved implementor methods that are not currently\ncached and asking client to provide them, this commit delegates\nall work to the client.\nEvery `collectImplementorsCapped` call is delegated to the client,\nwhich finds and creates all required resolved methods and sends\nmethod info back to the server, so that it can create server-side\nmethods.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-24T19:04:58Z", "type": "forcePushed"}, {"oid": "a3a9754a4a2ef317f7227d2832352c42c065090f", "url": "https://github.com/eclipse-openj9/openj9/commit/a3a9754a4a2ef317f7227d2832352c42c065090f", "message": "Delegate implementor collection to JITServer client\n\nAlternative implementation of #10118.\nInstead of walking the class tree on the server, constructing\nthe list of resolved implementor methods that are not currently\ncached and asking client to provide them, this commit delegates\nall work to the client.\nEvery `collectImplementorsCapped` call is delegated to the client,\nwhich finds and creates all required resolved methods and sends\nmethod infos back to the server, so that it can create server-side\nmethods.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-08-05T17:28:10Z", "type": "forcePushed"}, {"oid": "d0c323b92884c1e0874d020ad681247be14ab580", "url": "https://github.com/eclipse-openj9/openj9/commit/d0c323b92884c1e0874d020ad681247be14ab580", "message": "Delegate implementor collection to JITServer client\n\nAlternative implementation of #10118.\nInstead of walking the class tree on the server, constructing\nthe list of resolved implementor methods that are not currently\ncached and asking client to provide them, this commit delegates\nall work to the client.\nEvery `collectImplementorsCapped` call is delegated to the client,\nwhich finds and creates all required resolved methods and sends\nmethod infos back to the server, so that it can create server-side\nmethods.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-08-05T17:31:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwMjQ1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10245#discussion_r466602451", "bodyText": "Let's avoid the double call to getCachedResolvedMethod() when we found it the first time", "author": "mpirvu", "createdAt": "2020-08-06T18:22:10Z", "path": "runtime/compiler/env/j9methodServer.cpp", "diffHunk": "@@ -1954,37 +1954,64 @@ TR_ResolvedJ9JITServerMethod::cacheFields()\n       }\n    }\n \n-void\n-TR_ResolvedJ9JITServerMethod::cacheImplementorMethods(\n-   std::vector<TR_OpaqueClassBlock *> &subClasses,\n+int32_t\n+TR_ResolvedJ9JITServerMethod::collectImplementorsCapped(\n+   TR_OpaqueClassBlock *topClass,\n+   int32_t maxCount,\n    int32_t cpIndexOrOffset,\n-   bool isInterface,\n-   int32_t ttlForUnresolved)\n+   TR_YesNoMaybe useGetResolvedInterfaceMethod,\n+   TR_ResolvedMethod **implArray)\n    {\n-   auto compInfoPT = (TR::CompilationInfoPerThreadRemote *) _fe->_compInfoPT;\n-   int32_t numMethods = subClasses.size();\n-\n-   _stream->write(JITServer::MessageType::ResolvedMethod_getResolvedImplementorMethods, (TR_ResolvedJ9Method *) _remoteMirror, subClasses, cpIndexOrOffset, isInterface);\n-   auto recv = _stream->read<std::vector<J9Method *>, std::vector<TR_ResolvedJ9JITServerMethodInfo>>();\n+   auto compInfoPT = static_cast<TR::CompilationInfoPerThreadRemote *>(_fe->_compInfoPT);\n+   JITServer::ServerStream *stream = compInfoPT->getMethodBeingCompiled()->_stream;\n+   stream->write(\n+      JITServer::MessageType::ResolvedMethod_getResolvedImplementorMethods,\n+      topClass,\n+      maxCount,\n+      cpIndexOrOffset,\n+      _remoteMirror,\n+      useGetResolvedInterfaceMethod);\n+   auto recv = stream->read<std::vector<TR_ResolvedJ9JITServerMethodInfo>, std::vector<J9Method *>, int32_t>();\n+   auto &methodInfos = std::get<0>(recv);\n+   auto &ramMethods = std::get<1>(recv);\n+\n+   bool isInterface = TR::Compiler->cls.isInterfaceClass(compInfoPT->getCompilation(), topClass);\n+\n+   // refine if requested by a caller\n+   if (useGetResolvedInterfaceMethod != TR_maybe)\n+      isInterface = useGetResolvedInterfaceMethod == TR_yes ? true : false;\n+   for (int32_t i = 0; i < methodInfos.size(); ++i)\n+      {\n+      TR_ResolvedMethodType type = isInterface ?\n+         TR_ResolvedMethodType::Interface :\n+         TR_ResolvedMethodType::VirtualFromOffset;\n \n-   // Note: the number of received methods can be smaller\n-   // than the requsted number, because client will abort after\n-   // the first unresolved method.\n-   auto &ramMethods = std::get<0>(recv);\n-   auto &methodInfos = std::get<1>(recv);\n-   for (int32_t i = 0; i < ramMethods.size(); ++i)\n-      {\n-      TR_ResolvedMethodType type = isInterface ? TR_ResolvedMethodType::Interface : TR_ResolvedMethodType::VirtualFromOffset;\n       TR_ResolvedMethod *resolvedMethod;\n-      TR_ResolvedMethodKey key = compInfoPT->getResolvedMethodKey(type, (TR_OpaqueClassBlock *) _ramClass, cpIndexOrOffset, subClasses[i]);\n-      // Assume that we already checked that none of the methods have already been cached\n-      compInfoPT->cacheResolvedMethod(\n-         key,\n-         (TR_OpaqueMethodBlock *) ramMethods[i],\n-         0,\n-         methodInfos[i],\n-         ttlForUnresolved);\n+      TR_ResolvedMethodKey key =\n+         compInfoPT->getResolvedMethodKey(\n+            type,\n+            reinterpret_cast<TR_OpaqueClassBlock *>(_ramClass),\n+            cpIndexOrOffset,\n+            reinterpret_cast<TR_OpaqueClassBlock *>(std::get<0>(methodInfos[i]).ramClass));\n+      if (!compInfoPT->getCachedResolvedMethod(\n+             key,\n+             this,\n+             &resolvedMethod))\n+         {\n+         compInfoPT->cacheResolvedMethod(\n+            key,\n+            (TR_OpaqueMethodBlock *) ramMethods[i],\n+            cpIndexOrOffset,\n+            methodInfos[i],\n+            0); // all received methods should be resolved\n+         }\n+\n+      bool success = compInfoPT->getCachedResolvedMethod(key, this, &resolvedMethod);", "originalCommit": "d0c323b92884c1e0874d020ad681247be14ab580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "59dc41ce1567f7a5b205695b1a8db08303726686", "url": "https://github.com/eclipse-openj9/openj9/commit/59dc41ce1567f7a5b205695b1a8db08303726686", "message": "Delegate implementor collection to JITServer client\n\nAlternative implementation of #10118.\nInstead of walking the class tree on the server, constructing\nthe list of resolved implementor methods that are not currently\ncached and asking client to provide them, this commit delegates\nall work to the client.\nEvery `collectImplementorsCapped` call is delegated to the client,\nwhich finds and creates all required resolved methods and sends\nmethod infos back to the server, so that it can create server-side\nmethods.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-08-07T14:28:01Z", "type": "forcePushed"}, {"oid": "58949a16d9f4ee1560680c4406c818112ac51af1", "url": "https://github.com/eclipse-openj9/openj9/commit/58949a16d9f4ee1560680c4406c818112ac51af1", "message": "Delegate implementor collection to JITServer client\n\nAlternative implementation of #10118.\nInstead of walking the class tree on the server, constructing\nthe list of resolved implementor methods that are not currently\ncached and asking client to provide them, this commit delegates\nall work to the client.\nEvery `collectImplementorsCapped` call is delegated to the client,\nwhich finds and creates all required resolved methods and sends\nmethod infos back to the server, so that it can create server-side\nmethods.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-08-10T16:13:09Z", "type": "commit"}, {"oid": "58949a16d9f4ee1560680c4406c818112ac51af1", "url": "https://github.com/eclipse-openj9/openj9/commit/58949a16d9f4ee1560680c4406c818112ac51af1", "message": "Delegate implementor collection to JITServer client\n\nAlternative implementation of #10118.\nInstead of walking the class tree on the server, constructing\nthe list of resolved implementor methods that are not currently\ncached and asking client to provide them, this commit delegates\nall work to the client.\nEvery `collectImplementorsCapped` call is delegated to the client,\nwhich finds and creates all required resolved methods and sends\nmethod infos back to the server, so that it can create server-side\nmethods.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-08-10T16:13:09Z", "type": "forcePushed"}]}