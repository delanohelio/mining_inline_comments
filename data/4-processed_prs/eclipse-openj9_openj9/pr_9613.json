{"pr_number": 9613, "pr_title": "Fixed imm value for addis and lis", "pr_createdAt": "2020-05-19T17:55:24Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9613", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkyMzI0MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9613#discussion_r429923240", "bodyText": "This is wrong. It deals with legitimate offsets such as 0x80000000 wrongly, turning them into positive offsets. You need to test specifically the other situations.", "author": "zl-wang", "createdAt": "2020-05-25T13:02:33Z", "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -1235,7 +1235,15 @@ void loadFieldWatchSnippet(TR::CodeGenerator *cg, TR::Node *node, TR::Snippet *d\n       {\n       if (beginIndex<LOWER_IMMED || beginIndex>UPPER_IMMED)\n          {\n-         generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addis, node, scratchReg, cg->getTOCBaseRegister(), HI_VALUE(beginIndex));\n+         if (0x00008000 == HI_VALUE(beginIndex))\n+            {", "originalCommit": "7189324aeacf873df83829ab6281a106efcc83e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkzMTY0MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9613#discussion_r429931640", "bodyText": "If beginIndex is equal to 0x80000000 then HI_VALUE(beginIndex) will become 0xFFFF8000 so it won't trigger the if statement.\nHI_VALUE(beginIndex) will only become 0x00008000 when the upper 16 bits of beginIndex are equal to 0x7FFF and the highest bit of the lower 16 bits is set.\nSo beginIndex has to look like this in binary:\n0111 1111 1111 1111 1XXX XXXX XXXX XXXX\nHI_VALUE will first shift right by 16 bits:\n0000 0000 0000 0000 0111 1111 1111 1111\nThen add 1 because the highest bit of the original lowest 16 bits was set:\n0000 0000 0000 0000 1000 0000 0000 0000 = 0x00008000", "author": "IBMJimmyk", "createdAt": "2020-05-25T13:21:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkyMzI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk0NTg4MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9613#discussion_r429945880", "bodyText": "fair enough.", "author": "zl-wang", "createdAt": "2020-05-25T13:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkyMzI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMDEwMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9613#discussion_r436230101", "bodyText": "Could you please clarify why this instruction is needed? I thought just lis would be enough for any HI_VALUE.", "author": "gita-omr", "createdAt": "2020-06-06T02:37:47Z", "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6738,8 +6751,16 @@ static void genHeapAlloc(TR::Node *node, TR::Instruction *&iCursor, TR_OpaqueCla\n          iCursor = generateTrg1ImmInstruction(cg, TR::InstOpCode::li, node, zeroReg, 0, iCursor);\n          if (sizeInReg)\n             {\n-            iCursor = generateTrg1ImmInstruction(cg, TR::InstOpCode::lis, node, sizeReg, (allocSize >> 16) + ((allocSize & (1 << 15)) ? 1 : 0), iCursor);\n-            iCursor = generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, sizeReg, sizeReg, allocSize & 0x0000FFFF, iCursor);\n+            if (0x00008000 == HI_VALUE(allocSize))\n+               {\n+               iCursor = generateTrg1ImmInstruction(cg, TR::InstOpCode::lis, node, sizeReg, HI_VALUE(allocSize), iCursor);\n+               iCursor = generateTrg1Src1Imm2Instruction(cg, TR::InstOpCode::rlwinm, node, sizeReg, sizeReg, 0, 0xFFFFFFFF, iCursor);", "originalCommit": "ea26fdb552ee3a61a224614c35250321b4e57b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5ODc4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9613#discussion_r436698782", "bodyText": "I made a mistake there. Those two lines are just wrong. They should be a lis instruction followed by an addis instruction with the intent of putting 0x000000008000000 into a register.", "author": "IBMJimmyk", "createdAt": "2020-06-08T13:25:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMDEwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE0NTkzNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9613#discussion_r439145936", "bodyText": "I think we could've just called lis with 0xFFFF8000. This is just to avoid the ASSERT but the register will end up with the same bit pattern.", "author": "gita-omr", "createdAt": "2020-06-12T00:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMDEwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2NDM3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9613#discussion_r439364377", "bodyText": "No, we can't do that. As I pointed out previously in eclipse/omr#5213 (comment), the assert would not be a false positive in these instances. When using the full 64-bit result (as is done here when running on 64-bit systems), using -0x8000 instead of 0x8000 will not end up with the correct bit pattern in the register and will result in incorrect behaviour.", "author": "aviansie-ben", "createdAt": "2020-06-12T11:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMDEwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQyODYwMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9613#discussion_r439428600", "bodyText": "Right! Forgot that lis is the same as addis with 0.", "author": "gita-omr", "createdAt": "2020-06-12T13:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMDEwMQ=="}], "type": "inlineReview"}, {"oid": "992dfa1cb78d16232c9259e55b04d79d84d3687b", "url": "https://github.com/eclipse-openj9/openj9/commit/992dfa1cb78d16232c9259e55b04d79d84d3687b", "message": "Fixed imm value for addis and lis\n\naddis and lis accept a signed 16 bit value as an immediate. They are passed\ninto generateTrg1Src1ImmInstruction as signed 32 bit values. In some edge\ncases, the sign extension was not handled properly. In most cases this was\ndue to the value being incremented after sign extension. In other cases it\nwas due to an unnecessary mask clearing the upper 16 bits.\n\nOne case in genInstanceOfOrCheckCastSuperClassTest was handled incorrectly.\naddis should be used instead of lis to reconstruct the 32 bit immediate value\nto be added.\n\nFor cases where the TOC offset is unusually large, I put in an assert instead\nof generating instructions. The reasoning was TOC offsets of this size should\nnever occur so those code paths would never be tested. Also TOC offsets of\nthat size are likely an indication of a problem elsewhere.\n\nCloses: #9612\nSigned-off-by: jimmyk <jimmyk@ca.ibm.com>", "committedDate": "2020-06-11T16:13:42Z", "type": "commit"}, {"oid": "992dfa1cb78d16232c9259e55b04d79d84d3687b", "url": "https://github.com/eclipse-openj9/openj9/commit/992dfa1cb78d16232c9259e55b04d79d84d3687b", "message": "Fixed imm value for addis and lis\n\naddis and lis accept a signed 16 bit value as an immediate. They are passed\ninto generateTrg1Src1ImmInstruction as signed 32 bit values. In some edge\ncases, the sign extension was not handled properly. In most cases this was\ndue to the value being incremented after sign extension. In other cases it\nwas due to an unnecessary mask clearing the upper 16 bits.\n\nOne case in genInstanceOfOrCheckCastSuperClassTest was handled incorrectly.\naddis should be used instead of lis to reconstruct the 32 bit immediate value\nto be added.\n\nFor cases where the TOC offset is unusually large, I put in an assert instead\nof generating instructions. The reasoning was TOC offsets of this size should\nnever occur so those code paths would never be tested. Also TOC offsets of\nthat size are likely an indication of a problem elsewhere.\n\nCloses: #9612\nSigned-off-by: jimmyk <jimmyk@ca.ibm.com>", "committedDate": "2020-06-11T16:13:42Z", "type": "forcePushed"}]}