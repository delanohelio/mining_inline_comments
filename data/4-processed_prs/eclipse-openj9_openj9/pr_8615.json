{"pr_number": 8615, "pr_title": "Improve performance of iterateStackTrace", "pr_createdAt": "2020-02-19T17:45:49Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/8615", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r381509021", "bodyText": "I'm not sure if the PR testing will catch it but there seems to almost certainly be a problem with the this code from da33dfb. It seems when this code is enabled we hit the assert in [1] for some reason. Another (internal) test seems to fail where I can see a bunch of:\nat <unknown class>.<unknown method>(Unknown Source)\n\nIn the backtrace which looks incorrect. Previously the code on line 359 was:\nif ((methodPC >= (UDATA)J9_BYTECODE_START_FROM_ROM_METHOD(possibleMethod)) && (methodPC < (UDATA)J9_BYTECODE_END_FROM_ROM_METHOD(possibleMethod))) {\n\t...\n}\n\nWhich did not work because it broke the test case in [2]. It was returning the following:\n\"main\" Id=1 RUNNABLE\n        at <unknown class>.<unknown method>(Unknown Source)\n        at com.ibm.java.lang.management.internal.ThreadMXBeanImpl.getThreadInfo(ThreadMXBeanImpl.java:266)\n\ninstead of:\n\"main\" prio=5 Id=1 RUNNABLE\n        at com.ibm.java.lang.management.internal.ThreadMXBeanImpl.getMultiThreadInfoImpl(Native Method)\n        at com.ibm.java.lang.management.internal.ThreadMXBeanImpl.getThreadInfo(ThreadMXBeanImpl.java:266)\n\nThe reason seems to be that native methods have a different methodPC. This is also confirmed by looking at the implementation of findROMMethodInROMClass [3] which also does not use J9_BYTECODE_START_FROM_ROM_METHOD and compares the methodPC directly against the J9ROMMethod*.\nThere seems to be another bug here now which is causing the assert [1] to be triggered and other backtrace strings not to be generated.\n[1] https://github.com/eclipse/openj9/blob/60ed51cffd39410084955081e3f37667ace61717/runtime/jcl/common/jclexception.c#L263\n[2] https://github.com/eclipse/openj9/blob/60ed51cffd39410084955081e3f37667ace61717/test/functional/JLM_Tests/src/org/openj9/test/java/lang/management/TestManagementFactory.java#L1306-L1307\n[3] https://github.com/eclipse/openj9/blob/60ed51cffd39410084955081e3f37667ace61717/runtime/vm/findmethod.c#L60-L63", "author": "fjeremic", "createdAt": "2020-02-19T19:54:17Z", "path": "runtime/vm/exceptiondescribe.c", "diffHunk": "@@ -343,10 +343,25 @@ iterateStackTrace(J9VMThread * vmThread, j9object_t* exception, callback_func_t\n \t\t\t\t\tpruneConstructors = FALSE;\n #endif\n \t\t\t\t\tromClass = findROMClassFromPC(vmThread, methodPC, &classLoader);\n-\t\t\t\t\tif(romClass) {\n-\t\t\t\t\t\tromMethod = findROMMethodInROMClass(vmThread, romClass, methodPC);\n-\t\t\t\t\t\tif (romMethod != NULL) {\n-\t\t\t\t\t\t\tmethodPC -= (UDATA) J9_BYTECODE_START_FROM_ROM_METHOD(romMethod);\n+\t\t\t\t\tif (NULL != romClass) {\n+\t\t\t\t\t\tJ9UTF8 const *utfClassName = J9ROMCLASS_CLASSNAME(romClass);\n+\n+\t\t\t\t\t\tramClass = peekClassHashTable(vmThread, classLoader, J9UTF8_DATA(utfClassName), J9UTF8_LENGTH(utfClassName));\n+\t\t\t\t\t\tif (NULL != ramClass) {\n+\t\t\t\t\t\t\tU_32 i = 0;\n+\t\t\t\t\t\t\tJ9Method *methods = ramClass->ramMethods;\n+\t\t\t\t\t\t\tfor (i = 0; i < romClass->romMethodCount; ++i) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *possibleMethod = J9_ROM_METHOD_FROM_RAM_METHOD(&methods[i]);\n+\n+\t\t\t\t\t\t\t\t/* Note that we cannot use `J9_BYTECODE_START_FROM_ROM_METHOD` here because native method PCs\n+\t\t\t\t\t\t\t\t * point to the start of the J9ROMMethod data structure\n+\t\t\t\t\t\t\t\t */\n+\t\t\t\t\t\t\t\tif ((methodPC >= (UDATA)possibleMethod) && (methodPC < (UDATA)J9_BYTECODE_END_FROM_ROM_METHOD(possibleMethod))) {\n+\t\t\t\t\t\t\t\t\tromMethod = possibleMethod;\n+\t\t\t\t\t\t\t\t\tmethodPC -= (UDATA)J9_BYTECODE_START_FROM_ROM_METHOD(romMethod);\n+\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}", "originalCommit": "da33dfbfeb87922355e5259b5883af88dd8de8cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTI4NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r381509285", "bodyText": "@DanHeidinga was wondering if you could have a glance and maybe your expertise may be able to eyeball what the issue might be.", "author": "fjeremic", "createdAt": "2020-02-19T19:54:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxODAwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r381518006", "bodyText": "The code also needs to handle redefined classes.  If we don't find the method in the ramClass returned by peekClassHashTable(...), then we need to check its ramClass->replacedClass linked list to see if the method is found in one of the previous versions of this class.\nThe scenario would be a stacktrace is collected and then one of the classes in the stacktrace is redefined, which would lead to a new ROMClass being created.  The PC stored in the stacktrace wouldn't map to the current version of the J9Class.\nAddressing this should cover some (all?) of the <unknown class>.<unknown method>(Unknown Source) cases", "author": "DanHeidinga", "createdAt": "2020-02-19T20:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyNTUyMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r381525520", "bodyText": "https://github.com/eclipse/openj9/blob/60ed51cffd39410084955081e3f37667ace61717/runtime/jcl/common/jclexception.c#L254\nCan you also assert immediately after this line?  It would help to determine which case has the error.  I assume it must be this one but ....\nIs it always the same test that asserts?  If so, we can add code that explicitly checks for null and then printfs the result, element, & currentIndex - 1 and then we can look at the values in DDR to see if there's a logical code path that explains them being null", "author": "DanHeidinga", "createdAt": "2020-02-19T20:28:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU4MjY1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r381582656", "bodyText": "I tried the replacedClass fix but it did not fix the problems observed on the internal tests:\nfjeremic@24566ad\nIt is always the same test that fails. There are two classes of errors. One is the assert triggering and the other is some weird NPE error where the backtrace looks like this:\n[ERROR   ] CNTR0020E: EJB threw an unexpected (non-declared) exception during invocation of method \"getAccountData\" on bean \"BeanId(daytrader3#dt-ejb.jar#TradeSLSBBean, null)\". Exception data: java.lang.NullPointerException\n\tat com.ibm.websphere.samples.daytrader.ejb3.TradeSLSBBean.getAccountData(TradeSLSBBean.java:479)\n\tat com.ibm.websphere.samples.daytrader.ejb3.EJSLocal0SLTradeSLSBBean_13a83d61.getAccountData(EJSLocal0SLTradeSLSBBean_13a83d61.java)\n\tat com.ibm.websphere.samples.daytrader.web.jsf.AccountBean.userLookup(AccountBean.java:68)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:90)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:55)\n\tat java.lang.reflect.Method.invoke(Method.java:508)\n\tat <unknown class>.<unknown method>(Unknown Source)\n\tat <unknown class>.<unknown method>(Unknown Source)\n\tat <unknown class>.<unknown method>(Unknown Source)\n\tat <unknown class>.<unknown method>(Unknown Source)\n\tat <unknown class>.<unknown method>(Unknown Source)\n\tat <unknown class>.<unknown method>(Unknown Source)\n\tat <unknown class>.<unknown method>(Unknown Source)\n...\n\tat <unknown class>.<unknown method>(Unknown Source)\n\tat <unknown class>.<unknown method>(Unknown Source)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1160)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)\n\tat java.lang.Thread.run(Thread.java:820)\n\nI'll get a build going with printfs and see where we can get.", "author": "fjeremic", "createdAt": "2020-02-19T22:27:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI1ODUxMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r382258511", "bodyText": "I dug a bit deeper with DDR to find out why we asserted. We do indeed enter the if (previousFileName == fileName) block and we fail to extract a valid string. Looking at the value of result we see the following array:\n> !j9indexableobject 0x000003FF9AD50980 0 38\n!J9IndexableObject 0x000003FF9AD50980 {\n    struct J9Class* clazz = !j9arrayclass 0x3FFB019A000   // [L\n    Object flags = 0x00000000;\n    U_32 size = 0x00000026;\n        [0] = !fj9object 0x3ff9ad50ac0 = !j9object 0x3ff9ad50ac0\n        [1] = !fj9object 0x3ff9ad50af8 = !j9object 0x3ff9ad50af8\n        [2] = !fj9object 0x3ff9ad50b30 = !j9object 0x3ff9ad50b30\n        [3] = !fj9object 0x3ff9ad50b68 = !j9object 0x3ff9ad50b68\n        [4] = !fj9object 0x3ff9ad50ba0 = !j9object 0x3ff9ad50ba0\n        [5] = !fj9object 0x3ff9ad50bd8 = !j9object 0x3ff9ad50bd8\n        [6] = !fj9object 0x3ff9ad50c10 = !j9object 0x3ff9ad50c10\n        [7] = !fj9object 0x3ff9ad50c48 = !j9object 0x3ff9ad50c48\n        [8] = !fj9object 0x3ff9ad50c80 = !j9object 0x3ff9ad50c80\n        [9] = !fj9object 0x3ff9ad50cb8 = !j9object 0x3ff9ad50cb8\n        [10] = !fj9object 0x3ff9ad50cf0 = !j9object 0x3ff9ad50cf0\n        [11] = !fj9object 0x3ff9ad50d28 = !j9object 0x3ff9ad50d28\n        [12] = !fj9object 0x3ff9ad50d60 = !j9object 0x3ff9ad50d60\n        [13] = !fj9object 0x3ff9ad50d98 = !j9object 0x3ff9ad50d98\n        [14] = !fj9object 0x3ff9ad50dd0 = !j9object 0x3ff9ad50dd0\n        [15] = !fj9object 0x3ff9ad50e08 = !j9object 0x3ff9ad50e08\n        [16] = !fj9object 0x3ff9ad50e40 = !j9object 0x3ff9ad50e40\n        [17] = !fj9object 0x3ff9ad50e78 = !j9object 0x3ff9ad50e78\n        [18] = !fj9object 0x3ff9ad50eb0 = !j9object 0x3ff9ad50eb0\n        [19] = !fj9object 0x3ff9ad50ee8 = !j9object 0x3ff9ad50ee8\n        [20] = !fj9object 0x3ff9ad50f20 = !j9object 0x3ff9ad50f20\n        [21] = !fj9object 0x3ff9ad50f58 = !j9object 0x3ff9ad50f58\n        [22] = !fj9object 0x3ff9ad50f90 = !j9object 0x3ff9ad50f90\n        [23] = !fj9object 0x3ff9ad50fc8 = !j9object 0x3ff9ad50fc8\n        [24] = !fj9object 0x3ff9ad51000 = !j9object 0x3ff9ad51000\n        [25] = !fj9object 0x3ff9ad51038 = !j9object 0x3ff9ad51038\n        [26] = !fj9object 0x3ff9ad51070 = !j9object 0x3ff9ad51070\n        [27] = !fj9object 0x3ff9ad510a8 = !j9object 0x3ff9ad510a8\n        [28] = !fj9object 0x3ff9ad510e0 = !j9object 0x3ff9ad510e0\n        [29] = !fj9object 0x3ff9ad51118 = !j9object 0x3ff9ad51118\n        [30] = null\n        [31] = null\n        [32] = null\n        [33] = null\n        [34] = null\n        [35] = null\n        [36] = null\n        [37] = null\n}\n\nWhat is interesting here is that only the first index holds a valid StackTraceElement:\n> !fj9object 0x3ff9ad50ac0\n!J9Object 0x000003FF9AD50AC0 {\n        struct J9Class* clazz = !j9class 0x3FFB0198A00 // java/lang/StackTraceElement\n        Object flags = 0x00000000;\n        J lockword = 0x0000000000000000 (offset = 0) (java/lang/Object) <hidden>\n        Ljava/lang/String; declaringClass = !fj9object 0x3ff8ee72b30 (offset = 8) (java/lang/StackTraceElement)\n        Ljava/lang/String; methodName = !fj9object 0x3ff8f84f478 (offset = 16) (java/lang/StackTraceElement)\n        Ljava/lang/String; fileName = !fj9object 0x3ff8ee727f0 (offset = 24) (java/lang/StackTraceElement)\n        I lineNumber = 0x0000048A (offset = 40) (java/lang/StackTraceElement)\n        Ljava/lang/Object; source = !fj9object 0x0 (offset = 32) (java/lang/StackTraceElement)\n}\n> !fj9object 0x3ff9ad50af8\n!J9Object 0x000003FF9AD50AF8 {\n        struct J9Class* clazz = !j9class 0x3FFB0198A00 // java/lang/StackTraceElement\n        Object flags = 0x00000000;\n        J lockword = 0x0000000000000000 (offset = 0) (java/lang/Object) <hidden>\n        Ljava/lang/String; declaringClass = !fj9object 0x0 (offset = 8) (java/lang/StackTraceElement)\n        Ljava/lang/String; methodName = !fj9object 0x0 (offset = 16) (java/lang/StackTraceElement)\n        Ljava/lang/String; fileName = !fj9object 0x0 (offset = 24) (java/lang/StackTraceElement)\n        I lineNumber = 0x00000000 (offset = 40) (java/lang/StackTraceElement)\n        Ljava/lang/Object; source = !fj9object 0x0 (offset = 32) (java/lang/StackTraceElement)\n}\n\nThe rest of them are all valid objects but have NULL for declaringClass, methodName, and fileName. The printf printed the following:\nFilip: result = 0x3ff9ad50980, element = 0x3ff9ad510e0, currentIndex - 1 = 28, romClass = 0x3ff5f34d260, romMethod = 0x3ff5f34da20, fileName = 0x3ff5f34e3d0, lineNumber = 236, classLoader = 0x3ffb0070990, ramClass = 0x3ffb0570300\n\nWhich means we compared previousFileName == fileName and found it to be true on the 28th index. However looking at the 27th object in the array:\n> !fj9object 0x3ff9ad510a8\n!J9Object 0x000003FF9AD510A8 {\n        struct J9Class* clazz = !j9class 0x3FFB0198A00 // java/lang/StackTraceElement\n        Object flags = 0x00000000;\n        J lockword = 0x0000000000000000 (offset = 0) (java/lang/Object) <hidden>\n        Ljava/lang/String; declaringClass = !fj9object 0x0 (offset = 8) (java/lang/StackTraceElement)\n        Ljava/lang/String; methodName = !fj9object 0x0 (offset = 16) (java/lang/StackTraceElement)\n        Ljava/lang/String; fileName = !fj9object 0x0 (offset = 24) (java/lang/StackTraceElement)\n        I lineNumber = 0x00000000 (offset = 40) (java/lang/StackTraceElement)\n        Ljava/lang/Object; source = !fj9object 0x0 (offset = 32) (java/lang/StackTraceElement)\n}\n\nThe fileName is NULL. I'm sure having all these NULL values within these objects is not normal. So I set out for another experiment which fixes the problem. I'll describe that in the following comment.", "author": "fjeremic", "createdAt": "2020-02-20T21:07:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2MDc2OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r382260769", "bodyText": "Using the branch with the printf to gather more information I tried the following change:\nfjeremic@87f058f\nAfter trying to iterate J9Method*, it turns out we were sometimes unable to find the corresponding J9ROMMethod*, because the peekClassHashTable returned a NULL class pointer. So we were proceeding with a bogus value for romMethod and not extracting proper information.\nAdding in the fallback path on lines 369-374:\nfjeremic@87f058f#diff-32ef01e828ed7705ed9d726657f20b8dR369-R374\nfixes the issue and we are now passing all the tests. It seems that quite frequently we will get back a NULL result from peekClassHashTable. I'm unsure as to why that is the case.\n@DanHeidinga do you may have any ideas? Should we go forward with this new implementation which does a fallback if we can't find the ROM method because we have a NULL class pointer?", "author": "fjeremic", "createdAt": "2020-02-20T21:12:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTU3NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r383935574", "bodyText": "@DanHeidinga apologies for the spam. Tagging you again just in case you missed the previous question.", "author": "fjeremic", "createdAt": "2020-02-25T15:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk1Nzk0Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r383957947", "bodyText": "@fjeremic thanks for the ping on this.  I had missed the previously question while at DevNexus.\nI'm trying to understand the case that's causing peekClassHashTable to return NULL and the only thing I can think of is that the class has been unloaded but we're keeping the ram/rom classes around to describe the \"dark matter\" on the heap for the GC.  This would mean the classes can't be found from the ClassHashTable but would still be findable by walking the Segments.\nIf you have a core from the problematic case, can you check the classloader being used and see if it has the J9_GC_CLASS_LOADER_DEAD bit set in the gcFlags field?  ie: (J9_GC_CLASS_LOADER_DEAD == (classLoader->gcFlags & J9_GC_CLASS_LOADER_DEAD) \nOr if the class has the J9AccClassDying bit set in the J9CLASS_FLAGS(clazz) - ie: (J9AccClassDying == (J9CLASS_FLAGS(clazz) & J9AccClassDying))?", "author": "DanHeidinga", "createdAt": "2020-02-25T15:38:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzMTgyMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r384031820", "bodyText": "I checked the core file which the previous DDR comments were based on:\n> !j9classloader 0x3ffb0070990\nJ9ClassLoader at 0x3ffb0070990 {\n  Fields for J9ClassLoader:\n  ...\n          0x60: UDATA flags = 0x0000000000000118 (280)\n\n> !j9class 0x3ffb0570300\nJ9Class at 0x3ffb0570300 {\n  Fields for J9Class:\n  ...\n        0x18: UDATA classDepthAndFlags = 0x00000000021E0002 (35520514)\n        0x20: U32 classDepthWithFlags = 0x00000000 (0)\n        0x24: U32 classFlags = 0x00000000 (0)\n\nIt seems the class loader is not dead (0x2 flag) and there are no class flags. I also added some print statements to see which classes we couldn't find via peekClassHashTable using the following commit:\nfjeremic@2d44913\nHere is a snapshot of the output on one of the problematic tests:\nj> 12:54:30 Filip: counterFound = 9, class name = java/lang/Thread\nj> 12:54:30 Filip: counter **NOT** found = 95, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = com/ibm/test/binaryData/TestBinaryConverters\nj> 12:54:30 Filip: counterFound = 10, class name = sun/reflect/NativeMethodAccessorImpl\nj> 12:54:30 Filip: counter **NOT** found = 96, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = org/junit/runners/ParentRunner$3\nj> 12:54:30 Filip: counter **NOT** found = 97, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = org/junit/runners/ParentRunner$1\nj> 12:54:30 Filip: counter **NOT** found = 98, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = org/junit/runners/ParentRunner\nj> 12:54:30 Filip: counter **NOT** found = 99, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = org/junit/runners/ParentRunner\nj> 12:54:30 Filip: counter **NOT** found = 100, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = org/junit/runners/ParentRunner$2\nj> 12:54:30 Filip: counter **NOT** found = 101, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = org/junit/internal/runners/statements/RunBefores\nj> 12:54:30 Filip: counter **NOT** found = 102, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = org/junit/runners/ParentRunner\nj> 12:54:30 Filip: counter **NOT** found = 103, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = org/junit/runners/Suite\nj> 12:54:30 Filip: counter **NOT** found = 104, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = org/junit/runners/Suite\nj> 12:54:30 Filip: counter **NOT** found = 105, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = org/junit/runners/ParentRunner$3\nj> 12:54:30 Filip: counter **NOT** found = 106, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = org/junit/runners/ParentRunner$1\nj> 12:54:30 Filip: counter **NOT** found = 107, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = org/junit/runners/ParentRunner\nj> 12:54:30 Filip: counter **NOT** found = 108, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = org/junit/runners/ParentRunner\nj> 12:54:30 Filip: counter **NOT** found = 109, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = org/junit/runners/ParentRunner$2\nj> 12:54:30 Filip: counter **NOT** found = 110, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = org/junit/runners/ParentRunner\nj> 12:54:30 Filip: counter **NOT** found = 111, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = org/junit/runner/JUnitCore\nj> 12:54:30 Filip: counter **NOT** found = 112, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = org/junit/runner/JUnitCore\nj> 12:54:30 Filip: counter **NOT** found = 113, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = com/ibm/jtc/test/jltf/workunitadapters/JUnit4WorkUnit\nj> 12:54:30 Filip: counter **NOT** found = 114, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = com/ibm/jtc/test/jltf/threads/WorkUnitRunner\nj> 12:54:30 Filip: counter **NOT** found = 115, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = com/ibm/jtc/test/jltf/threads/pooling/PooledRunnable\nj> 12:54:30 Filip: counter **NOT** found = 116, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = com/ibm/jtc/test/jltf/threads/pooling/PooledRunnable\nj> 12:54:30 Filip: counter **NOT** found = 117, ramClassFound = 0, loaderDead = 0, gcFlags = 0, class name = com/ibm/jtc/test/jltf/threads/PooledLangThreadFactory$JavaLangPooledThread\n\nThe classes which were not found via peekClassHashTable by their name definitely look like short lived classes. It also seems they are classes loaded by the application class loader. I could not test the J9AccClassDying flag as I don't have a J9Class* in hand.", "author": "fjeremic", "createdAt": "2020-02-25T18:00:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA0MDQzNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r384040436", "bodyText": "I also tried iterating the classLoader->classSegments to look for the J9Class* for the romClass we have in hand via:\n                                        J9MemorySegment *segment = classLoader->classSegments;\n                                        while (NULL != segment) {\n                                                if (MEMORY_TYPE_RAM_CLASS == (segment->type & MEMORY_TYPE_RAM_CLASS)) {\n                                                        J9Class* segClass = *((J9Class**)segment->heapBase);\n                                                        while (NULL != segClass) {\n                                                                if (segClass->romClass == romClass) {\n                                                                        fprintf(stderr, \"Filip: Found RAMClass = %p\\n\", segClass);\n                                                                }\n                                                                segClass = segClass->nextClassInSegment;\n                                                        }\n                                                }\n                                                segment = segment->nextSegmentInClassLoader;\n                                        }\n\nAnd it was not printing anything. I assume there has to be a J9Class* for every J9ROMClass* we have in hand, right? Not sure if the above algorithm covers all cases.", "author": "fjeremic", "createdAt": "2020-02-25T18:21:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2Mzk1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r384063950", "bodyText": "@fjeremic J9Classloader has both a flags and a gcFlags field.  Can you dump the gcFlags field (or the whole structure) for !j9classloader 0x3ffb0070990?", "author": "DanHeidinga", "createdAt": "2020-02-25T19:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5MDExOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r384090118", "bodyText": "> !j9classloader 0x3ffb0070990\nJ9ClassLoader at 0x3ffb0070990 {\n  Fields for J9ClassLoader:\n        0x0: struct J9Pool * sharedLibraries = !j9pool 0x0000000000000000\n        0x8: struct J9HashTable * classHashTable = !j9hashtable 0x000003FFB028C9A0\n        0x10: struct J9HashTable * romClassOrphansHashTable = !j9hashtable 0x0000000000000000\n        0x18: j9object_t classLoaderObject = !j9object 0x000003FF8E6E64C0 // sun/misc/Launcher$AppClassLoader\n        0x20: struct J9ClassPathEntry * classPathEntries = !j9classpathentry 0x000003FFB04CC210\n        0x28: UDATA classPathEntryCount = 0x0000000000000000 (0)\n        0x30: struct J9ClassLoader * unloadLink = !j9classloader 0x0000000000000000\n        0x38: struct J9ClassLoader * gcLinkNext = !j9classloader 0x0000000000000000\n        0x40: struct J9ClassLoader * gcLinkPrevious = !j9classloader 0x0000000000000000\n        0x48: UDATA gcFlags = 0x0000000000000000 (0)\n        0x50: struct J9VMThread * gcThreadNotification = !j9vmthread 0x0000000000000000\n        0x58: struct J9Pool * jniIDs = !j9pool 0x000003FFB028CA80\n        0x60: UDATA flags = 0x0000000000000118 (280)\n        0x68: struct J9JITExceptionTable * jitMetaDataList = !j9jitexceptiontable 0x000003FF41843AF8\n        0x70: struct J9MemorySegment * classSegments = !j9memorysegment 0x000003FF4C0D1DB8\n        0x78: struct J9RAMClassFreeListBlock * ramClassLargeBlockFreeList = !j9ramclassfreelistblock 0x000003FF4C0D45D0\n        0x80: struct J9RAMClassFreeListBlock * ramClassSmallBlockFreeList = !j9ramclassfreelistblock 0x0000000000000000\n        0x88: struct J9RAMClassFreeListBlock * ramClassTinyBlockFreeList = !j9ramclassfreelistblock 0x000003FF7408E3A8\n        0x90: UDATA * ramClassUDATABlockFreeList = !j9x 0x000003FF4C0D43E8\n        0x98: struct J9HashTable * redefinedClasses = !j9hashtable 0x0000000000000000\n        0xa0: struct J9NativeLibrary * librariesHead = !j9nativelibrary 0x0000000000000000\n        0xa8: struct J9NativeLibrary * librariesTail = !j9nativelibrary 0x0000000000000000\n        0xb0: volatile UDATA gcRememberedSet = 0x0000000000000000 (0)\n        0xb8: struct J9HashTable * moduleHashTable = !j9hashtable 0x0000000000000000\n        0xc0: struct J9HashTable * packageHashTable = !j9hashtable 0x0000000000000000\n        0xc8: struct J9HashTable * moduleExtraInfoHashTable = !j9hashtable 0x0000000000000000\n        0xd0: struct J9HashTable * classLocationHashTable = !j9hashtable 0x0000000000000000\n        0xd8: struct J9HashTable * classRelationshipsHashTable = !j9hashtable 0x0000000000000000\n}\n\nHere are also the flags with the printfs:\nj> 14:48:50 Filip: counter **NOT** found = 245, ramClassFound = 0, loaderDead = 0, flags = 30, gcFlags = 0, class name = org/junit/runners/Suite\nj> 14:48:50 Filip: counter **NOT** found = 246, ramClassFound = 0, loaderDead = 0, flags = 30, gcFlags = 0, class name = org/junit/runners/Suite\nj> 14:48:50 Filip: counter **NOT** found = 247, ramClassFound = 0, loaderDead = 0, flags = 30, gcFlags = 0, class name = org/junit/runners/ParentRunner$3\nj> 14:48:50 Filip: counter **NOT** found = 248, ramClassFound = 0, loaderDead = 0, flags = 30, gcFlags = 0, class name = org/junit/runners/ParentRunner$1\nj> 14:48:50 Filip: counter **NOT** found = 249, ramClassFound = 0, loaderDead = 0, flags = 30, gcFlags = 0, class name = org/junit/runners/ParentRunner\nj> 14:48:50 Filip: counter **NOT** found = 250, ramClassFound = 0, loaderDead = 0, flags = 30, gcFlags = 0, class name = org/junit/runners/ParentRunner\nj> 14:48:50 Filip: counter **NOT** found = 251, ramClassFound = 0, loaderDead = 0, flags = 30, gcFlags = 0, class name = org/junit/runners/ParentRunner$2\nj> 14:48:50 Filip: counter **NOT** found = 252, ramClassFound = 0, loaderDead = 0, flags = 30, gcFlags = 0, class name = org/junit/runners/ParentRunner\nj> 14:48:50 Filip: counter **NOT** found = 253, ramClassFound = 0, loaderDead = 0, flags = 30, gcFlags = 0, class name = org/junit/runner/JUnitCore\nj> 14:48:50 Filip: counter **NOT** found = 254, ramClassFound = 0, loaderDead = 0, flags = 30, gcFlags = 0, class name = org/junit/runner/JUnitCore\nj> 14:48:50 Filip: counter **NOT** found = 255, ramClassFound = 0, loaderDead = 0, flags = 30, gcFlags = 0, class name = com/ibm/jtc/test/jltf/workunitadapters/JUnit4WorkUnit\n\nThey are always 0x1E for flags and 0 for gcFlags whenever we can't find the class via peekClassHashTable.", "author": "fjeremic", "createdAt": "2020-02-25T19:52:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0NjQ0NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r384746444", "bodyText": "@DanHeidinga any thoughts on the above? It seems that sometimes we are just unable to find the J9Class* while the J9ROMMethod* can be found.", "author": "fjeremic", "createdAt": "2020-02-26T20:29:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM2NjY5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r385366691", "bodyText": "@fjeremic That would make sense if we had only loaded the J9ROMClass and hadn't yet created the J9Class but that can't happen for a case were we've been running the methods.\nIf the class has been loaded, we should be able to find it in the classHashTable given the name and the right classloader.\nDoes the !classforname org/junit/runners/Suite DDR extension find the class?  (Assuming that's the right name for missing class in the core).  And if it does, does its classloader match the one used in the peekClassHashTable call?\nI think having a fallback for when the J9Class can't be found is necessary as the class may have been unloaded already but I'd like to ensure that the peekClassHashTable is working as expected and as effectively as it can", "author": "DanHeidinga", "createdAt": "2020-02-27T20:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2NzQzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r385767431", "bodyText": "@DanHeidinga so I re-ran the unit test and made it crash via *(int*)(0) = 0 the first time we were unable to find the J9Class*. It spit out this:\nj> 10:33:20 Filip: counter **NOT** found = 1, ramClassFound = 0, loaderDead = 0, flags = 30, gcFlags = 0, class name = com/ibm/test/decimals/TestDecimalData, classLoader = 0x3ff980705d8, romClass = 0x3ff66233bb8\n\nOpening the core file in DDR and looking for the class yields the following:\n> !classforname com/ibm/test/decimals/TestDecimalData\nSearching for classes named 'com/ibm/test/decimals/TestDecimalData' in VM=3ff98013a70\n!j9class 0x000003FF986C7A00 named com/ibm/test/decimals/TestDecimalData\nFound 1 class(es) named com/ibm/test/decimals/TestDecimalData\n\nMeaning that the class was found, however the classloader printed (and used in peekClassHashTable) is not the correct classloader which loaded the class:\n> !j9class 0x000003FF986C7A00\nJ9Class at 0x3ff986c7a00 {\n  Fields for J9Class:\n        0x0: UDATA eyecatcher = 0x0000000099669966 (2573637990)\n        0x8: struct J9ROMClass * romClass = !j9romclass 0x000003FF66233BB8\n        0x10: struct J9Class ** superclasses = !j9x 0x000003FF986C77E8\n        0x18: UDATA classDepthAndFlags = 0x00000000020E0001 (34471937)\n        0x20: U32 classDepthWithFlags = 0x00000000 (0)\n        0x24: U32 classFlags = 0x00000000 (0)\n        0x28: struct J9ClassLoader * classLoader = !j9classloader 0x000003FF98070890\n\n> !j9classloader 0x000003FF98070890\nJ9ClassLoader at 0x3ff98070890 {\n  Fields for J9ClassLoader:\n        0x0: struct J9Pool * sharedLibraries = !j9pool 0x0000000000000000\n        0x8: struct J9HashTable * classHashTable = !j9hashtable 0x000003FF98259330\n        0x10: struct J9HashTable * romClassOrphansHashTable = !j9hashtable 0x0000000000000000\n        0x18: j9object_t classLoaderObject = !j9object 0x000003FF78070300 // sun/misc/Launcher$AppClassLoader\n\nsun/misc/Launcher$AppClassLoader is the class loader which loaded the class we couldn't find. And the class loader we used in peekClassHashTable is com/ibm/oti/vm/BootstrapClassLoader:\n> !j9classloader 0x3ff980705d8\nJ9ClassLoader at 0x3ff980705d8 {\n  Fields for J9ClassLoader:\n        0x0: struct J9Pool * sharedLibraries = !j9pool 0x000003FF98137A10\n        0x8: struct J9HashTable * classHashTable = !j9hashtable 0x000003FF98082620\n        0x10: struct J9HashTable * romClassOrphansHashTable = !j9hashtable 0x0000000000000000\n        0x18: j9object_t classLoaderObject = !j9object 0x000003FF78035260 // com/ibm/oti/vm/BootstrapClassLoader\n\nSo the problem seems to be that findROMClassFromPC is not returning the correct classloader for the particular class. Any ideas as to why? Are we using this API correctly?\n[1] https://github.com/eclipse/openj9/blob/b25d2d63793c8d12bba32f97c3848e4cb16409b7/runtime/vm/findmethod.c#L70-L90", "author": "fjeremic", "createdAt": "2020-02-28T15:42:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNDc2Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r385804766", "bodyText": "My current theory is that all ROM classes in the shared classes cache appear to be from the bootloader.  Working on proving that and then will propose a potential work around", "author": "DanHeidinga", "createdAt": "2020-02-28T16:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxNTAwNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r385815004", "bodyText": "I just did a quick test and ran with -Xshareclasses:none -Xnoaot and the tests are passing now. We seem to no longer be encountering any NULL results from peekClassHashTable", "author": "fjeremic", "createdAt": "2020-02-28T17:09:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0NjQ0MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r385846440", "bodyText": "@pshipton helped me find the way we create segments for the SCC - code is here and assigning the bootloader to the scc segments: https://github.com/eclipse/openj9/blob/b25d2d63793c8d12bba32f97c3848e4cb16409b7/runtime/shared_common/CacheMap.cpp#L905", "author": "DanHeidinga", "createdAt": "2020-02-28T18:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3MDY5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r385870694", "bodyText": "peekClassHashTable will fail for non-bootclasspath classes defined in the SCC as the classLoader from findROMClassFromPC will always be the bootloader.  There is a large chance that SCC classes will be from the apploader as well so we should attempt to probe that loader as well before we fail back to the segment search.\nSomething like:\nif (ramClass == NULL) {\n  if (j9shr_Query_IsAddressInCache(vm, romClass, romClass->size)) {\n    /* Probe the application loader to determine if it has the J9Class for the current class.\n     * This secondary probe is required as all ROMClasses from the SCC appear to be owned\n     * by the bootstrap classloader.\n     */\n      ramClass = peekClassHashTable(vmThread, vm->applicationClassLoader, J9UTF8_DATA(utfClassName), J9UTF8_LENGTH(utfClassName));\n  }\n}\nWe'll still need a fallback path as this won't catch all cases but should catch substantially more.", "author": "DanHeidinga", "createdAt": "2020-02-28T19:06:40Z", "path": "runtime/vm/exceptiondescribe.c", "diffHunk": "@@ -343,10 +343,25 @@ iterateStackTrace(J9VMThread * vmThread, j9object_t* exception, callback_func_t\n \t\t\t\t\tpruneConstructors = FALSE;\n #endif\n \t\t\t\t\tromClass = findROMClassFromPC(vmThread, methodPC, &classLoader);\n-\t\t\t\t\tif(romClass) {\n-\t\t\t\t\t\tromMethod = findROMMethodInROMClass(vmThread, romClass, methodPC);\n-\t\t\t\t\t\tif (romMethod != NULL) {\n-\t\t\t\t\t\t\tmethodPC -= (UDATA) J9_BYTECODE_START_FROM_ROM_METHOD(romMethod);\n+\t\t\t\t\tif (NULL != romClass) {\n+\t\t\t\t\t\tJ9UTF8 const *utfClassName = J9ROMCLASS_CLASSNAME(romClass);\n+\n+\t\t\t\t\t\tramClass = peekClassHashTable(vmThread, classLoader, J9UTF8_DATA(utfClassName), J9UTF8_LENGTH(utfClassName));", "originalCommit": "da33dfbfeb87922355e5259b5883af88dd8de8cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3OTk2Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r385879966", "bodyText": "Thanks @DanHeidinga. I just tried this out and it is working fine. We are finding all the classes. I'll amend the PR with all the changes.\nHowever one minor issue stands. j9shr_Query_IsAddressInCache is declared as a static function in a header file [1]. This will make every compilation unit which includes this header to have a separate copy of that function. Moreover, if one includes that header file (SCQueryFunctions.h) then you cannot compile the compilation unit without errors because you have to use all the static functions defined in the header:\nmake[1]: Entering directory `/team/fjeremic/defects/iterateStackTrace/sdk/jre/lib/s390x/default/vm'\ngcc -O3 -mtune=z10 -march=z9-109 -mzarch -g -DLINUX -D_REENTRANT -D_FILE_OFFSET_BITS=64 -fPIC -DIPv6_FUNCTION_SUPPORT  -DS390 -D_LONG_LONG -DJ9VM_TIERED_CODE_CACHE -fno-strict-aliasing -DS39064 -Wimplicit -Wreturn-type -Werror -Wall -I. -I../include -I../oti -I../util -I../gc_include -I../omr/gc/include -I../shared_common/include -I../gc_glue_java -I../nls -I../omr/include_core    -DTR_HOST_S390 -c -o exceptiondescribe.o exceptiondescribe.c\ncc1: warnings being treated as errors\n../shared_common/include/SCQueryFunctions.h:40: error: 'j9shr_Query_IsCacheFull' defined but not used\n../shared_common/include/SCQueryFunctions.h:97: error: 'j9shr_Query_IsAddressInReadWriteCache' defined but not used\n../shared_common/include/SCQueryFunctions.h:112: error: 'j9shr_Query_PopulatePreinitConfigDefaults' defined but not used\n\nI think we may need to move these function definitions to a separate compilation unit or make them inline. Which do you prefer?\n[1] https://github.com/eclipse/openj9/blob/b25d2d63793c8d12bba32f97c3848e4cb16409b7/runtime/shared_common/include/SCQueryFunctions.h#L73-L84", "author": "fjeremic", "createdAt": "2020-02-28T19:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3MDY5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg4NzczNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r385887734", "bodyText": "@pshipton @hangshao0 Any preference on how we modify the SCQueryFunctions.h to deal with cases that only want to call 1 of the apis?  Or is there a better interface we should be using to check if a J9ROMClass is in the cache?", "author": "DanHeidinga", "createdAt": "2020-02-28T19:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3MDY5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkwMDc0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r385900749", "bodyText": "I am fine with making them inline.", "author": "hangshao0", "createdAt": "2020-02-28T20:11:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3MDY5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4NjgzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r386686838", "bodyText": "Fixed in e706c52 and a7aa8a4", "author": "fjeremic", "createdAt": "2020-03-02T22:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3MDY5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcyNjY3OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r418726679", "bodyText": "Post-approval nix - declaring functions (inline or not) in a .h file simply isn't the right thing to do. If the compiler (say, XLC) decides to ignore the inline directive, or someone wants to do a real debug build (disabling inlining entirely), this will fail.", "author": "gacholio", "createdAt": "2020-05-01T20:36:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3MDY5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ5NzE4NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r419497184", "bodyText": "I'll withdraw the comment above (though not my objection about doing this in general). It follows the same pattern as j9accessbarrierhelpers.h.", "author": "gacholio", "createdAt": "2020-05-04T14:53:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3MDY5NA=="}], "type": "inlineReview"}, {"oid": "0a9989dca0837bd49f1d405665928f090458d70e", "url": "https://github.com/eclipse-openj9/openj9/commit/0a9989dca0837bd49f1d405665928f090458d70e", "message": "Cache J9Class in iterateStackTrace callback\n\nAvoid having to lookup the `J9Class*` within `getStackTraceIterator`\nby optionally passing the `J9Class*` as an argument. If the caller\nhas the `J9Class*` available we will avoid an extra call to\n`peekClassHashTable` which will improve the performance of the\ncallback.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>", "committedDate": "2020-03-02T18:19:22Z", "type": "commit"}, {"oid": "4d7bb309bfca95d5d08e0d055e3074b7557ccdf5", "url": "https://github.com/eclipse-openj9/openj9/commit/4d7bb309bfca95d5d08e0d055e3074b7557ccdf5", "message": "Iterate over J9Method* rather than J9ROMMethod* for performance\n\nROMMethods are variable sized making walking them more expensive. For\nJITTed methods, we have the RAMClass in hand already which would\nallow walking the J9Methods which are fixed sized. This improves the\nspeed of that operation.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>", "committedDate": "2020-03-02T18:19:22Z", "type": "forcePushed"}, {"oid": "e706c526de871fb7cfbaa7b41a3282d0b08d9fe3", "url": "https://github.com/eclipse-openj9/openj9/commit/e706c526de871fb7cfbaa7b41a3282d0b08d9fe3", "message": "Make SCQueryFunctions helpers inline\n\nDefining static utility functions in header files is typically not\nwanted because each compilation unit which includes the header will get\nit's own copy of the defined functions. Moreover when building with\nwarnings as errors (which is the default today) we cannot compile such\ncompilation units without using all defined APIs as the compiler will\nemit a(n) (warning) error.\n\nWe define the functions within SCQueryFunctions.h as inline functions\nto avoid such problems.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>", "committedDate": "2020-03-02T22:23:30Z", "type": "commit"}, {"oid": "a7aa8a4b37aed9c08825841319d2639bec3917f4", "url": "https://github.com/eclipse-openj9/openj9/commit/a7aa8a4b37aed9c08825841319d2639bec3917f4", "message": "Iterate over J9Method* rather than J9ROMMethod* for performance\n\nROMMethods are variable sized making walking them more expensive. For\nJITTed methods, we have the RAMClass in hand already which would\nallow walking the J9Methods which are fixed sized. This improves the\nspeed of that operation.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>", "committedDate": "2020-03-02T22:23:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU2NjUxNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r418566514", "bodyText": "Two braces here are overindented.", "author": "gacholio", "createdAt": "2020-05-01T14:31:00Z", "path": "runtime/vm/exceptiondescribe.c", "diffHunk": "@@ -343,11 +344,46 @@ iterateStackTrace(J9VMThread * vmThread, j9object_t* exception, callback_func_t\n \t\t\t\t\tpruneConstructors = FALSE;\n #endif\n \t\t\t\t\tromClass = findROMClassFromPC(vmThread, methodPC, &classLoader);\n-\t\t\t\t\tif(romClass) {\n-\t\t\t\t\t\tromMethod = findROMMethodInROMClass(vmThread, romClass, methodPC);\n-\t\t\t\t\t\tif (romMethod != NULL) {\n-\t\t\t\t\t\t\tmethodPC -= (UDATA) J9_BYTECODE_START_FROM_ROM_METHOD(romMethod);\n+\t\t\t\t\tif (NULL != romClass) {\n+\t\t\t\t\t\tJ9UTF8 const *utfClassName = J9ROMCLASS_CLASSNAME(romClass);\n+\n+\t\t\t\t\t\tramClass = peekClassHashTable(vmThread, classLoader, J9UTF8_DATA(utfClassName), J9UTF8_LENGTH(utfClassName));\n+\t\t\t\t\t\tif (ramClass == NULL) {\n+\t\t\t\t\t\t\tif (j9shr_Query_IsAddressInCache(vm, romClass, romClass->romSize)) {\n+\t\t\t\t\t\t\t\t/* Probe the application loader to determine if it has the J9Class for the current class.\n+\t\t\t\t\t\t\t\t * This secondary probe is required as all ROMClasses from the SCC appear to be owned\n+\t\t\t\t\t\t\t\t * by the bootstrap classloader.\n+\t\t\t\t\t\t\t\t */\n+\t\t\t\t\t\t\t\tramClass = peekClassHashTable(vmThread, vm->applicationClassLoader, J9UTF8_DATA(utfClassName), J9UTF8_LENGTH(utfClassName));\n+\t\t\t\t\t\t\t\t}", "originalCommit": "a7aa8a4b37aed9c08825841319d2639bec3917f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY3Njk1Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r418676957", "bodyText": "Fixed in force-push.", "author": "fjeremic", "createdAt": "2020-05-01T18:35:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU2NjUxNA=="}], "type": "inlineReview"}, {"oid": "0921605921fb6482be5eb990637e36a8bf741cbc", "url": "https://github.com/eclipse-openj9/openj9/commit/0921605921fb6482be5eb990637e36a8bf741cbc", "message": "Iterate over J9Method* rather than J9ROMMethod* for performance\n\nROMMethods are variable sized making walking them more expensive. For\nJITTed methods, we have the RAMClass in hand already which would\nallow walking the J9Methods which are fixed sized. This improves the\nspeed of that operation.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>", "committedDate": "2020-05-01T18:34:54Z", "type": "commit"}, {"oid": "0921605921fb6482be5eb990637e36a8bf741cbc", "url": "https://github.com/eclipse-openj9/openj9/commit/0921605921fb6482be5eb990637e36a8bf741cbc", "message": "Iterate over J9Method* rather than J9ROMMethod* for performance\n\nROMMethods are variable sized making walking them more expensive. For\nJITTed methods, we have the RAMClass in hand already which would\nallow walking the J9Methods which are fixed sized. This improves the\nspeed of that operation.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>", "committedDate": "2020-05-01T18:34:54Z", "type": "forcePushed"}]}