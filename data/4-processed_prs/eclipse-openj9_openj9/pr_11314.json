{"pr_number": 11314, "pr_title": "Improve the mechanism of accepting new request at JITServer", "pr_createdAt": "2020-12-01T13:25:43Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/11314", "timeline": [{"oid": "cc45d1403a0ceef7d89761e2101564047a899247", "url": "https://github.com/eclipse-openj9/openj9/commit/cc45d1403a0ceef7d89761e2101564047a899247", "message": "Improve the mechanism of accepting new request at JITServer\n\nTo reduce network communication overhead, the JITServer keeps a cache for\nthe CHTable (segregated by client UID), which is kept up-to-date with\nincremental updates sent by the client. The client keeps track of all the\n\"new\" changes to the CHTable since the last update was sent. When it needs\nto send a new compilation request, the client packs all these updates into\na std::string and sends them together with the compilation request.\nAt the same time, the set of \"new\" CHTable changes is reset and built anew.\n\nFor this mechanism to work, the set of updates needs to be applied at the\nserver in the same order it was computed at the client. The proper ordering\nis accomplished with a sequencing number scheme: when the client computes the\nset of CHTable changes to be sent, it will acquire a \"ticket\" which is nothing\nmore than a sequenceNumber that is sent together with the updates.\nThe JITServer receives the updates and must ensure that they are applied in\nthe order dictated by the sequenceNumber. If an update arrives out-of-order,\nthe client will \"park\" the corresponding compilation thread (make it sleep on\na monitor) until its turn comes. The waiting on the monitor has a timeout to\navoid scenarios where a sequenceNumber is completely lost. In that situation,\nthe JITServer must clear its cache because some important updates may be missing.\nStarting with a clear CHTable cache, the JITServer will ask the client for the\nentire CHTable, after which the incremental CHTable updates mechanism may start\nagain.\n\nThe mechanism described above is already implemented, but has a shortcoming:\nthe incoming requests are processed strictly in the order dictated by the client\neven though they may not cary any information related to CHTable updates.\nThis PR relaxes this requirement.\n\nWe can distinguish two types of compilation requests: the ones that carry class\nload/unload information (critical requests) and the ones that do not.\nWe must process critical requests strictly in the order in which they were encountered\nat the client based on their sequence number. Non-critical requests may be executed\nin any order, however, we will impose the following rules:\n1) A non-critical request can be executed after a critical request with a higher seqNo.\nThe reason is that the non-critical request will have more up-to-date information.\n2) The opposite is not allowed: a non-critical request with a higher seqNo than a\ncritical request must wait for the critical request to be processed first.\n\nImplementation\nThe client will send not only the SeqNo of the current request, but also the SeqNo\nof the last critical request. The server receives request seqNo_N and the last critical\nrequest seqNo_M. It then checks whether seqNo_M has been processed and if it did,\nthen this request can go as well. If not, this request will be parked (put to sleep\ninto a waiting queue). When a request has been processed, it may need to notify\nother requests that are waiting in the queue. It needs to notify all waiting\nrequests up to and including the next critical request (if there is any).\nOnly critical requests need to activate threads because a comp request can only\nbe waiting for a critical request. When activating, we must check that the request\nthat is being activated does not depend on a critical request that hasn't arrived yet.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-12-02T04:54:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIyMjcxMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11314#discussion_r534222713", "bodyText": "Does this TODO still need to be addressed? If so, can we put it in an issue with some description of what needs to be done to clean it up? If not, let's just delete this code.", "author": "ymanton", "createdAt": "2020-12-02T14:45:55Z", "path": "runtime/compiler/control/JITServerCompilationThread.cpp", "diffHunk": "@@ -664,28 +687,34 @@ TR::CompilationInfoPerThreadRemote::processEntry(TR_MethodToBeCompiled &entry, J\n       // If the client aborted this compilation it could have happened only while asking for entire\n       // CHTable and unloaded class address ranges and at that point the seqNo was not updated.\n       // We must update seqNo now to allow for blocking threads to pass through.\n+      // Since the caches are already cleared there is no harm in discarding this message.\n       clientSession->getSequencingMonitor()->enter();\n \n-      if (seqNo != clientSession->getExpectedSeqNo())\n+     // if (isCriticalRequest) TODO: what should we do here?\n          {\n-         Trc_JITServerUnexpectedSeqNo(compThread, getCompThreadId(), clientSession,\n-               (unsigned long long)clientId, seqNo, clientSession->getExpectedSeqNo(), clientSession->getNumActiveThreads());\n+         if (seqNo > clientSession->getLastProcessedCriticalSeqNo())\n+            {\n+           \n+            clientSession->setLastProcessedCriticalSeqNo(seqNo);\n+      \n+     \n+            //Trc_JITServerUnexpectedSeqNo(compThread, getCompThreadId(), clientSession,\n+            //   (unsigned long long)clientId, seqNo, clientSession->getExpectedSeqNo(), clientSession->getNumActiveThreads());\n \n-         TR_ASSERT(false, \"compThreadID=%d clientSessionData=%p clientUID=%llu (seqNo=%u, expectedSeqNo=%u, numActiveThreads=%d) unexpected seqNo\",\n-               getCompThreadId(), clientSession, (unsigned long long)clientId,\n-               seqNo, clientSession->getExpectedSeqNo(), clientSession->getNumActiveThreads());\n+            //TR_ASSERT(false, \"compThreadID=%d clientSessionData=%p clientUID=%llu (seqNo=%u, expectedSeqNo=%u, numActiveThreads=%d) unexpected seqNo\",\n+            //   getCompThreadId(), clientSession, (unsigned long long)clientId,\n+            //   seqNo, clientSession->getExpectedSeqNo(), clientSession->getNumActiveThreads());\n \n-         clientSession->setExpectedSeqNo(seqNo);\n+            }\n          }\n \n-      updateSeqNo(clientSession);\n+      //updateSeqNo(clientSession);", "originalCommit": "cc45d1403a0ceef7d89761e2101564047a899247", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY1Nzg2MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11314#discussion_r534657861", "bodyText": "I changed the code to address the TODO", "author": "mpirvu", "createdAt": "2020-12-03T04:23:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIyMjcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIyNDUwMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11314#discussion_r534224502", "bodyText": "Can we put this into an issue that describes how/why it must be changed?", "author": "ymanton", "createdAt": "2020-12-02T14:48:15Z", "path": "runtime/compiler/control/JITServerCompilationThread.cpp", "diffHunk": "@@ -393,42 +401,54 @@ TR::CompilationInfoPerThreadRemote::processEntry(TR_MethodToBeCompiled &entry, J\n       // Use a sequencing scheme to re-order compilation requests\n       //\n       clientSession->getSequencingMonitor()->enter();\n-      clientSession->updateMaxReceivedSeqNo(seqNo);\n-      if (seqNo > clientSession->getExpectedSeqNo()) // Out of order messages\n+      clientSession->updateMaxReceivedSeqNo(seqNo); // TODO: why do I need this?\n+      // This request can go through as long as criticalSeqNo has been processed\n+      if (criticalSeqNo > clientSession->getLastProcessedCriticalSeqNo())\n          {\n-         // Park this request until the missing ones arrive\n+         // Park this request until `criticalSeqNo` arrives and is processed\n          if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n-            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"compThreadID=%d out-of-sequence msg detected for clientUID=%llu seqNo=%u > expectedSeqNo=%u. Parking this thread (entry=%p)\",\n-            getCompThreadId(), (unsigned long long)clientId, seqNo, clientSession->getExpectedSeqNo(), &entry);\n-\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"compThreadID=%d out-of-sequence msg=%u detected for clientUID=%llu criticalSeqNo=%u > lastCriticalSeqNo=%u. Parking this thread (entry=%p)\",\n+            getCompThreadId(), seqNo, (unsigned long long)clientId, criticalSeqNo, clientSession->getLastProcessedCriticalSeqNo(), &entry);\n+         // TODO: must change this trace point\n          Trc_JITServerOutOfSequenceMessage(compThread, getCompThreadId(), clientSession,\n-               (unsigned long long)clientId, &entry, seqNo, clientSession->getExpectedSeqNo(), clientSession->getNumActiveThreads());\n+               (unsigned long long)clientId, &entry, seqNo, clientSession->getLastProcessedCriticalSeqNo(), clientSession->getNumActiveThreads());", "originalCommit": "cc45d1403a0ceef7d89761e2101564047a899247", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY1ODAzMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11314#discussion_r534658033", "bodyText": "I added a new tracepoint to reflect the change in the message I wanted to convey", "author": "mpirvu", "createdAt": "2020-12-03T04:24:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIyNDUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIyNzEyMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11314#discussion_r534227120", "bodyText": "Can we put this in an issue that describes what needs to be done? It's not clear what \"this\" refers to.", "author": "ymanton", "createdAt": "2020-12-02T14:51:26Z", "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -3266,6 +3266,7 @@ remoteCompile(\n    std::string optionsStr = TR::Options::packOptions(compiler->getOptions());\n    std::string recompMethodInfoStr = compiler->isRecompilationEnabled() ? std::string((char *) compiler->getRecompilationInfo()->getMethodInfo(), sizeof(TR_PersistentMethodInfo)) : std::string();\n \n+   // TODO: make this a synchronized region to avoid bad_alloc exceptions", "originalCommit": "cc45d1403a0ceef7d89761e2101564047a899247", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2MTk0MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11314#discussion_r534661941", "bodyText": "Opened issue #11349 to address the TODO", "author": "mpirvu", "createdAt": "2020-12-03T04:36:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIyNzEyMA=="}], "type": "inlineReview"}, {"oid": "1dec903336a03141fb72de99f50d0299d8c368a0", "url": "https://github.com/eclipse-openj9/openj9/commit/1dec903336a03141fb72de99f50d0299d8c368a0", "message": "Improve the mechanism of accepting new request at JITServer\n\nTo reduce network communication overhead, the JITServer keeps a cache for\nthe CHTable (segregated by client UID), which is kept up-to-date with\nincremental updates sent by the client. The client keeps track of all the\n\"new\" changes to the CHTable since the last update was sent. When it needs\nto send a new compilation request, the client packs all these updates into\na std::string and sends them together with the compilation request.\nAt the same time, the set of \"new\" CHTable changes is reset and built anew.\n\nFor this mechanism to work, the set of updates needs to be applied at the\nserver in the same order it was computed at the client. The proper ordering\nis accomplished with a sequencing number scheme: when the client computes the\nset of CHTable changes to be sent, it will acquire a \"ticket\" which is nothing\nmore than a sequenceNumber that is sent together with the updates.\nThe JITServer receives the updates and must ensure that they are applied in\nthe order dictated by the sequenceNumber. If an update arrives out-of-order,\nthe client will \"park\" the corresponding compilation thread (make it sleep on\na monitor) until its turn comes. The waiting on the monitor has a timeout to\navoid scenarios where a sequenceNumber is completely lost. In that situation,\nthe JITServer must clear its cache because some important updates may be missing.\nStarting with a clear CHTable cache, the JITServer will ask the client for the\nentire CHTable, after which the incremental CHTable updates mechanism may start\nagain.\n\nThe mechanism described above is already implemented, but has a shortcoming:\nthe incoming requests are processed strictly in the order dictated by the client\neven though they may not cary any information related to CHTable updates.\nThis PR relaxes this requirement.\n\nWe can distinguish two types of compilation requests: the ones that carry class\nload/unload information (critical requests) and the ones that do not.\nWe must process critical requests strictly in the order in which they were encountered\nat the client based on their sequence number. Non-critical requests may be executed\nin any order, however, we will impose the following rules:\n1) A non-critical request can be executed after a critical request with a higher seqNo.\nThe reason is that the non-critical request will have more up-to-date information.\n2) The opposite is not allowed: a non-critical request with a higher seqNo than a\ncritical request must wait for the critical request to be processed first.\n\nImplementation\nThe client will send not only the SeqNo of the current request, but also the SeqNo\nof the last critical request. The server receives request seqNo_N and the last critical\nrequest seqNo_M. It then checks whether seqNo_M has been processed and if it did,\nthen this request can go as well. If not, this request will be parked (put to sleep\ninto a waiting queue). When a request has been processed, it may need to notify\nother requests that are waiting in the queue. It needs to notify all waiting\nrequests up to and including the next critical request (if there is any).\nOnly critical requests need to activate threads because a comp request can only\nbe waiting for a critical request. When activating, we must check that the request\nthat is being activated does not depend on a critical request that hasn't arrived yet.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-12-03T04:21:50Z", "type": "commit"}, {"oid": "1dec903336a03141fb72de99f50d0299d8c368a0", "url": "https://github.com/eclipse-openj9/openj9/commit/1dec903336a03141fb72de99f50d0299d8c368a0", "message": "Improve the mechanism of accepting new request at JITServer\n\nTo reduce network communication overhead, the JITServer keeps a cache for\nthe CHTable (segregated by client UID), which is kept up-to-date with\nincremental updates sent by the client. The client keeps track of all the\n\"new\" changes to the CHTable since the last update was sent. When it needs\nto send a new compilation request, the client packs all these updates into\na std::string and sends them together with the compilation request.\nAt the same time, the set of \"new\" CHTable changes is reset and built anew.\n\nFor this mechanism to work, the set of updates needs to be applied at the\nserver in the same order it was computed at the client. The proper ordering\nis accomplished with a sequencing number scheme: when the client computes the\nset of CHTable changes to be sent, it will acquire a \"ticket\" which is nothing\nmore than a sequenceNumber that is sent together with the updates.\nThe JITServer receives the updates and must ensure that they are applied in\nthe order dictated by the sequenceNumber. If an update arrives out-of-order,\nthe client will \"park\" the corresponding compilation thread (make it sleep on\na monitor) until its turn comes. The waiting on the monitor has a timeout to\navoid scenarios where a sequenceNumber is completely lost. In that situation,\nthe JITServer must clear its cache because some important updates may be missing.\nStarting with a clear CHTable cache, the JITServer will ask the client for the\nentire CHTable, after which the incremental CHTable updates mechanism may start\nagain.\n\nThe mechanism described above is already implemented, but has a shortcoming:\nthe incoming requests are processed strictly in the order dictated by the client\neven though they may not cary any information related to CHTable updates.\nThis PR relaxes this requirement.\n\nWe can distinguish two types of compilation requests: the ones that carry class\nload/unload information (critical requests) and the ones that do not.\nWe must process critical requests strictly in the order in which they were encountered\nat the client based on their sequence number. Non-critical requests may be executed\nin any order, however, we will impose the following rules:\n1) A non-critical request can be executed after a critical request with a higher seqNo.\nThe reason is that the non-critical request will have more up-to-date information.\n2) The opposite is not allowed: a non-critical request with a higher seqNo than a\ncritical request must wait for the critical request to be processed first.\n\nImplementation\nThe client will send not only the SeqNo of the current request, but also the SeqNo\nof the last critical request. The server receives request seqNo_N and the last critical\nrequest seqNo_M. It then checks whether seqNo_M has been processed and if it did,\nthen this request can go as well. If not, this request will be parked (put to sleep\ninto a waiting queue). When a request has been processed, it may need to notify\nother requests that are waiting in the queue. It needs to notify all waiting\nrequests up to and including the next critical request (if there is any).\nOnly critical requests need to activate threads because a comp request can only\nbe waiting for a critical request. When activating, we must check that the request\nthat is being activated does not depend on a critical request that hasn't arrived yet.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-12-03T04:21:50Z", "type": "forcePushed"}]}