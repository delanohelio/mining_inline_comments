{"pr_number": 10599, "pr_title": "Fix GCMap issue for read only unresolved field resolution and resolve virtual call sequence", "pr_createdAt": "2020-09-15T15:42:09Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10599", "timeline": [{"oid": "3e82f0896ddf131c965ca251765635b1ea57d3da", "url": "https://github.com/eclipse-openj9/openj9/commit/3e82f0896ddf131c965ca251765635b1ea57d3da", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-09-21T16:01:32Z", "type": "forcePushed"}, {"oid": "27cadae793bd317f4c6fbd475dfddca423245cc8", "url": "https://github.com/eclipse-openj9/openj9/commit/27cadae793bd317f4c6fbd475dfddca423245cc8", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-09-23T19:08:30Z", "type": "forcePushed"}, {"oid": "c5f6f000c11c73729e9a8f136a21a40a7fe38416", "url": "https://github.com/eclipse-openj9/openj9/commit/c5f6f000c11c73729e9a8f136a21a40a7fe38416", "message": "Remove the un-needed NOP added for adjusting GCMap\n\nFor Unresolved Virtual Call Dispatch sequence in read only code, we had\nto add a NOP in mainline before the start of the resolve sequence for\nsuch calls to make sure that if a GC is triggered while calling C helper\nfunction, it sees correct GCMap. This was a hack with potential bug where\nlocal register assigner can shuffles the register between NOP and start\nof virtual call resolution sequence which can alter the state of\nregisters.\nCorrect fix for this issue is implemented in this commit where while\ncalling C helper from PicBuilder, it passes the address of the next\ninstruction in mainline after snippet call.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-09-23T19:45:54Z", "type": "commit"}, {"oid": "7b338abb5dd0f20fafbafcf06353059bd235de0a", "url": "https://github.com/eclipse-openj9/openj9/commit/7b338abb5dd0f20fafbafcf06353059bd235de0a", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-09-23T19:46:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk4ODU2OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10599#discussion_r495988569", "bodyText": "Tabs should be spaces here for consistency.", "author": "fjeremic", "createdAt": "2020-09-28T14:36:57Z", "path": "runtime/compiler/z/codegen/J9UnresolvedDataReadOnlySnippet.cpp", "diffHunk": "@@ -122,12 +123,11 @@ J9::Z::UnresolvedDataReadOnlySnippet::emitSnippetBody()\n       // Branch to doneLabel (BRCL 0xF,[doneLabel])\n       *reinterpret_cast<int16_t*>(cursor) = 0xC0F4;\n \n-      addressA = reinterpret_cast<intptr_t>(doneLabel->getCodeLocation());\n-      addressB = reinterpret_cast<intptr_t>(cursor);\n+\t\tintptr_t doneLabelAddress = reinterpret_cast<intptr_t>(doneLabel->getCodeLocation());", "originalCommit": "7b338abb5dd0f20fafbafcf06353059bd235de0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwMzY2OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10599#discussion_r496203669", "bodyText": "Fixed in https://github.com/eclipse/openj9/compare/ee40f0a3614cab3847b46a4b61c6fb2795d4b775..3ac390dbe99682be85f71980c4568d19c47c35dd", "author": "r30shah", "createdAt": "2020-09-28T20:09:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk4ODU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5MDQ4NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10599#discussion_r495990485", "bodyText": "How about calling it what is is, i.e. returnLabel?", "author": "fjeremic", "createdAt": "2020-09-28T14:39:40Z", "path": "runtime/compiler/z/codegen/J9UnresolvedDataReadOnlySnippet.cpp", "diffHunk": "@@ -67,12 +67,14 @@ J9::Z::UnresolvedDataReadOnlySnippet::UnresolvedDataReadOnlySnippet(\n       intptr_t resolveDataAddress,\n       TR::LabelSymbol *startResolveSequenceLabel,\n       TR::LabelSymbol *volatileFenceLabel,\n+      TR::LabelSymbol *snippetCallNextInstrLabel,", "originalCommit": "7b338abb5dd0f20fafbafcf06353059bd235de0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNDkxOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10599#discussion_r496204918", "bodyText": "I chose this name it represents the nextInstruction after snippet call for GC, and in none of the path we actually return to this point.", "author": "r30shah", "createdAt": "2020-09-28T20:12:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5MDQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5MjAyNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10599#discussion_r495992025", "bodyText": "We should probably leave this comment in.", "author": "fjeremic", "createdAt": "2020-09-28T14:41:45Z", "path": "runtime/compiler/z/codegen/J9UnresolvedDataReadOnlySnippet.cpp", "diffHunk": "@@ -89,26 +91,25 @@ J9::Z::UnresolvedDataReadOnlySnippet::emitSnippetBody()\n    TR::GlobalFunctionCallData dataDestination(glueSymRef, getNode(), cursor, cg(), self());\n    cursor = cg()->getObjFmt()->encodeGlobalFunctionCall(dataDestination);\n \n-   // Relative address to the CCUnresolvedData*", "originalCommit": "7b338abb5dd0f20fafbafcf06353059bd235de0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwMjA5OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10599#discussion_r496202098", "bodyText": "Added the comment back in https://github.com/eclipse/openj9/compare/ee40f0a3614cab3847b46a4b61c6fb2795d4b775..3ac390dbe99682be85f71980c4568d19c47c35dd", "author": "r30shah", "createdAt": "2020-09-28T20:06:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5MjAyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5NTAyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10599#discussion_r495995022", "bodyText": "How about naming this startResolveSequenceLabelAddr?", "author": "fjeremic", "createdAt": "2020-09-28T14:45:40Z", "path": "runtime/compiler/z/codegen/J9UnresolvedDataReadOnlySnippet.cpp", "diffHunk": "@@ -89,26 +91,25 @@ J9::Z::UnresolvedDataReadOnlySnippet::emitSnippetBody()\n    TR::GlobalFunctionCallData dataDestination(glueSymRef, getNode(), cursor, cg(), self());\n    cursor = cg()->getObjFmt()->encodeGlobalFunctionCall(dataDestination);\n \n-   // Relative address to the CCUnresolvedData*\n-   intptr_t addressA = reinterpret_cast<intptr_t>(resolveDataAddress);\n-   intptr_t addressB = reinterpret_cast<intptr_t>(cursor);\n+   uint8_t *helperCallRA = cursor;\n \n-   TR_ASSERT_FATAL(cg()->canUseRelativeLongInstructions(addressA), \"CCUnresolvedData* [%p] is outside relative immediate range\", addressA);\n+   TR_ASSERT_FATAL(cg()->canUseRelativeLongInstructions(resolveDataAddress), \"CCUnresolvedData* [%p] is outside relative immediate range\", resolveDataAddress);\n \n-   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(addressA - addressB);\n+   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(resolveDataAddress - (intptr_t)helperCallRA);\n    cursor += 4;\n \n    // Constant pool index\n    *reinterpret_cast<int32_t*>(cursor) = getCPIndex();\n    cursor += 4;\n \n    // Relative address to the start of the mainline resolution\n-   addressA = reinterpret_cast<intptr_t>(startResolveSequenceLabel->getCodeLocation());\n-   addressB = reinterpret_cast<intptr_t>(cursor);\n-\n-   TR_ASSERT_FATAL(cg()->canUseRelativeLongInstructions(addressA), \"startResolveSequenceLabel [%p] is outside relative immediate range\", addressA);\n+   intptr_t startOfResolutionSeqLabelAddr = reinterpret_cast<intptr_t>(startResolveSequenceLabel->getCodeLocation());", "originalCommit": "7b338abb5dd0f20fafbafcf06353059bd235de0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5Njc1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10599#discussion_r495996758", "bodyText": "We should add a comment above this similar to others about what it is trying to encode. For example Relative address to the return label following the snippet call.", "author": "fjeremic", "createdAt": "2020-09-28T14:48:04Z", "path": "runtime/compiler/z/codegen/J9UnresolvedDataReadOnlySnippet.cpp", "diffHunk": "@@ -89,26 +91,25 @@ J9::Z::UnresolvedDataReadOnlySnippet::emitSnippetBody()\n    TR::GlobalFunctionCallData dataDestination(glueSymRef, getNode(), cursor, cg(), self());\n    cursor = cg()->getObjFmt()->encodeGlobalFunctionCall(dataDestination);\n \n-   // Relative address to the CCUnresolvedData*\n-   intptr_t addressA = reinterpret_cast<intptr_t>(resolveDataAddress);\n-   intptr_t addressB = reinterpret_cast<intptr_t>(cursor);\n+   uint8_t *helperCallRA = cursor;\n \n-   TR_ASSERT_FATAL(cg()->canUseRelativeLongInstructions(addressA), \"CCUnresolvedData* [%p] is outside relative immediate range\", addressA);\n+   TR_ASSERT_FATAL(cg()->canUseRelativeLongInstructions(resolveDataAddress), \"CCUnresolvedData* [%p] is outside relative immediate range\", resolveDataAddress);\n \n-   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(addressA - addressB);\n+   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(resolveDataAddress - (intptr_t)helperCallRA);\n    cursor += 4;\n \n    // Constant pool index\n    *reinterpret_cast<int32_t*>(cursor) = getCPIndex();\n    cursor += 4;\n \n    // Relative address to the start of the mainline resolution\n-   addressA = reinterpret_cast<intptr_t>(startResolveSequenceLabel->getCodeLocation());\n-   addressB = reinterpret_cast<intptr_t>(cursor);\n-\n-   TR_ASSERT_FATAL(cg()->canUseRelativeLongInstructions(addressA), \"startResolveSequenceLabel [%p] is outside relative immediate range\", addressA);\n+   intptr_t startOfResolutionSeqLabelAddr = reinterpret_cast<intptr_t>(startResolveSequenceLabel->getCodeLocation());\n+   TR_ASSERT_FATAL(cg()->canUseRelativeLongInstructions(startOfResolutionSeqLabelAddr), \"startResolveSequenceLabel [%p] is outside relative immediate range\", startOfResolutionSeqLabelAddr);\n+   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(startOfResolutionSeqLabelAddr - (intptr_t)helperCallRA);\n+   cursor += 4;\n \n-   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(addressA - addressB);\n+   intptr_t snippetCallNextInstrLabelAddress = reinterpret_cast<intptr_t>(snippetCallNextInstrLabel->getCodeLocation());\n+   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(snippetCallNextInstrLabelAddress - (intptr_t)helperCallRA);\n    cursor += 4;", "originalCommit": "7b338abb5dd0f20fafbafcf06353059bd235de0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwMzI1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10599#discussion_r496203255", "bodyText": "Added the comment in https://github.com/eclipse/openj9/compare/3ac390dbe99682be85f71980c4568d19c47c35dd..602be0121b2e925ba5801a153abb585fe9008379", "author": "r30shah", "createdAt": "2020-09-28T20:08:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5Njc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5NzIyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10599#discussion_r495997222", "bodyText": "We should order these in the same way as the parameters to the constructor. I'll ignore the fact that we're missing documentation which is true for a wide scope of this effort. We will get to it though before we merge into mainline.", "author": "fjeremic", "createdAt": "2020-09-28T14:48:42Z", "path": "runtime/compiler/z/codegen/J9UnresolvedDataReadOnlySnippet.hpp", "diffHunk": "@@ -89,6 +90,7 @@ class UnresolvedDataReadOnlySnippet : public TR::Snippet\n    TR::LabelSymbol *startResolveSequenceLabel;\n    TR::LabelSymbol *volatileFenceLabel;\n    TR::LabelSymbol *doneLabel;\n+   TR::LabelSymbol *snippetCallNextInstrLabel;", "originalCommit": "7b338abb5dd0f20fafbafcf06353059bd235de0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ee40f0a3614cab3847b46a4b61c6fb2795d4b775", "url": "https://github.com/eclipse-openj9/openj9/commit/ee40f0a3614cab3847b46a4b61c6fb2795d4b775", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-09-28T19:54:43Z", "type": "forcePushed"}, {"oid": "3ac390dbe99682be85f71980c4568d19c47c35dd", "url": "https://github.com/eclipse-openj9/openj9/commit/3ac390dbe99682be85f71980c4568d19c47c35dd", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-09-28T20:05:26Z", "type": "forcePushed"}, {"oid": "602be0121b2e925ba5801a153abb585fe9008379", "url": "https://github.com/eclipse-openj9/openj9/commit/602be0121b2e925ba5801a153abb585fe9008379", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-09-28T20:08:04Z", "type": "commit"}, {"oid": "602be0121b2e925ba5801a153abb585fe9008379", "url": "https://github.com/eclipse-openj9/openj9/commit/602be0121b2e925ba5801a153abb585fe9008379", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-09-28T20:08:04Z", "type": "forcePushed"}]}