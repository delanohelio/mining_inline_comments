{"pr_number": 9341, "pr_title": "Java 14: track interrupt state when thread is dead", "pr_createdAt": "2020-04-23T15:20:35Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9341", "timeline": [{"oid": "d0f53a8c489079fd059b1e92d3d5ada006aa4753", "url": "https://github.com/eclipse-openj9/openj9/commit/d0f53a8c489079fd059b1e92d3d5ada006aa4753", "message": "Java 14: track interrupt state when thread is dead\n\nA new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-04-23T15:26:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NjM2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r413956364", "bodyText": "Why bother introducing this variable at all in versions < 14? In the vmconstantpool.xml the versions can be specified via versions=\"14-\". Similarly the VM code can use #if JAVA_SPEC_VERSION >= 14", "author": "pshipton", "createdAt": "2020-04-23T16:45:08Z", "path": "jcl/src/java.base/share/classes/java/lang/Thread.java", "diffHunk": "@@ -80,6 +80,13 @@\n \t// Instance variables\n \tprivate long threadRef;\t\t\t\t\t\t\t\t\t// Used by the VM\n \tlong stackSize = 0;\n+    /* For Java 14+:\n+     * deadInterrupt tracks the thread interrupt state when threadRef has no reference (ie thread is not alive). \n+     * Note that this value need not be updated while the thread is running since the interrupt state will be \n+     * tracked by the vm during that time. Because of this the value should not be used over calling\n+     *  isInterrupted() or interrupted().\n+     */\n+\tprivate volatile boolean deadInterrupt;", "originalCommit": "d0f53a8c489079fd059b1e92d3d5ada006aa4753", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NjgyNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r413956824", "bodyText": "Pls use the preprocessor to only include this in Java 14+. Similarly for isInterrupted().", "author": "pshipton", "createdAt": "2020-04-23T16:45:46Z", "path": "jcl/src/java.base/share/classes/java/lang/Thread.java", "diffHunk": "@@ -677,6 +684,8 @@ public final ThreadGroup getThreadGroup() {\n \n /**\n  * Posts an interrupt request to the receiver\n+ * \n+ * From Java 14, the interrupt state for threads that are not alive is tracked.", "originalCommit": "d0f53a8c489079fd059b1e92d3d5ada006aa4753", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8", "url": "https://github.com/eclipse-openj9/openj9/commit/c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8", "message": "Java 14: track interrupt state when thread is dead\n\nA new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-04-24T18:47:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzMTM5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r414831394", "bodyText": "The indenting is off in the new section. Using spaces instead of tabs like the surrounding code.", "author": "pshipton", "createdAt": "2020-04-24T20:04:35Z", "path": "jcl/src/java.base/share/classes/java/lang/Thread.java", "diffHunk": "@@ -79,7 +79,15 @@\n \n \t// Instance variables\n \tprivate long threadRef;\t\t\t\t\t\t\t\t\t// Used by the VM\n-\tlong stackSize = 0;\n+    long stackSize = 0;", "originalCommit": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNDI1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r414834256", "bodyText": "Is the whitespace change for Jep359Tests intentional?", "author": "pshipton", "createdAt": "2020-04-24T20:10:09Z", "path": "test/functional/Java14andUp/playlist.xml", "diffHunk": "@@ -23,28 +23,51 @@\n -->\n \n <playlist xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../../TestConfig/playlist.xsd\">\n-      <test>\n-          <testCaseName>Jep359Tests</testCaseName>\n-          <variations>\n-                  <variation>NoOptions</variation>\n-          </variations>\n-          <command>$(JAVA_COMMAND) $(JVM_OPTIONS) \\\n-                  --enable-preview \\\n-                  -cp $(Q)$(LIB_DIR)$(D)asm-7.3.jar$(P)$(RESOURCES_DIR)$(P)$(TESTNG)$(P)$(TEST_RESROOT)$(D)GeneralTest.jar$(Q) \\\n-                  org.testng.TestNG -d $(REPORTDIR) $(Q)$(TEST_RESROOT)$(D)testng.xml$(Q) -testnames Jep359Tests \\\n-                  -groups $(TEST_GROUP) \\\n-                  -excludegroups $(DEFAULT_EXCLUDE); \\\n-                  $(TEST_STATUS)\n-          </command>\n-          <levels>\n-                  <level>sanity</level>\n-          </levels>\n-          <groups>\n-                  <group>functional</group>\n-          </groups>\n-          <!-- Run for Java 14 only since this is a preview feature. -->\n-          <subsets>\n-                  <subset>14</subset>\n-          </subsets>\n-        </test>\n+    <test>", "originalCommit": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxMjU0Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r417512542", "bodyText": "Yes. I found it was off when compared to other playlist files. I'll add that to the issue details.", "author": "theresa-m", "createdAt": "2020-04-29T18:09:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNDI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNDkwNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r414834905", "bodyText": "This test should be just rolled into test_interruptAtStartSetAfterRun()", "author": "pshipton", "createdAt": "2020-04-24T20:11:26Z", "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.AssertJUnit;\n+\n+/**\n+ * This test is to verify matching behavior to the RI from the following implementation change\n+ * discussed in the Java 14 release notes:\n+ * \n+ * \"The specification for java.lang.Thread::interrupt allows for an implementation to only track the \n+ * interrupt state for live threads, and previously this is what occurred. As of this release, the \n+ * interrupt state of a Thread is always available, and if you interrupt a thread t before it is started, \n+ * or after it has terminated, the query t.isInterrupted() will return true.\"\n+ */\n+\n+@Test(groups = { \"level.sanity\" })\n+public class Test_Thread {\n+\n+    /* interrupt thread before it has started */\n+    @Test\n+    public void test_interruptBeforeRun() {\n+        String name = \"interruptBeforeRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());", "originalCommit": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNzUwMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r414837501", "bodyText": "Pls set a volatile boolean field here, and test it after join(). Similarly in the next test.", "author": "pshipton", "createdAt": "2020-04-24T20:16:27Z", "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.AssertJUnit;\n+\n+/**\n+ * This test is to verify matching behavior to the RI from the following implementation change\n+ * discussed in the Java 14 release notes:\n+ * \n+ * \"The specification for java.lang.Thread::interrupt allows for an implementation to only track the \n+ * interrupt state for live threads, and previously this is what occurred. As of this release, the \n+ * interrupt state of a Thread is always available, and if you interrupt a thread t before it is started, \n+ * or after it has terminated, the query t.isInterrupted() will return true.\"\n+ */\n+\n+@Test(groups = { \"level.sanity\" })\n+public class Test_Thread {\n+\n+    /* interrupt thread before it has started */\n+    @Test\n+    public void test_interruptBeforeRun() {\n+        String name = \"interruptBeforeRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+    }\n+\n+    /* interrupt thread after it has ended */\n+    @Test\n+    public void test_interruptAfterRun() throws Throwable {\n+        String name = \"interruptAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+       t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has ended was was interrupted\", t.isInterrupted());    \n+    }\n+\n+    /* if thread is interrupted before start, verify that flag is still set after run. */\n+    @Test\n+    public void test_interruptAtStartSetAfterRun() throws Throwable {\n+        String name = \"interruptAtStartSetAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* run thread */\n+        t.run();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should be dead\", t.isAlive());\n+        AssertJUnit.assertTrue(name + \"interrupt flag should be set\", t.isInterrupted()); \n+    }\n+\n+    /* Interrupt thread during run, verify that interrupt flag is not set when thread stops running. \n+     * isInterrupted becomes false after InterruptedException is thrown. */\n+    @Test\n+    public void test_interruptDuringRun() throws Throwable {\n+        String name = \"interruptDuringRun: \";\n+        Thread t = new Thread() {\n+            public void run() {\n+                synchronized(this) {\n+                    try {\n+                        wait();\n+                        AssertJUnit.fail(); /* not interrupted */\n+                    } catch (InterruptedException e) {\n+                        /* expected */", "originalCommit": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MTcwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r414841706", "bodyText": "This and the join() don't do anything, so this is really the same test as test_interruptBeforeRun().", "author": "pshipton", "createdAt": "2020-04-24T20:24:47Z", "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.AssertJUnit;\n+\n+/**\n+ * This test is to verify matching behavior to the RI from the following implementation change\n+ * discussed in the Java 14 release notes:\n+ * \n+ * \"The specification for java.lang.Thread::interrupt allows for an implementation to only track the \n+ * interrupt state for live threads, and previously this is what occurred. As of this release, the \n+ * interrupt state of a Thread is always available, and if you interrupt a thread t before it is started, \n+ * or after it has terminated, the query t.isInterrupted() will return true.\"\n+ */\n+\n+@Test(groups = { \"level.sanity\" })\n+public class Test_Thread {\n+\n+    /* interrupt thread before it has started */\n+    @Test\n+    public void test_interruptBeforeRun() {\n+        String name = \"interruptBeforeRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+    }\n+\n+    /* interrupt thread after it has ended */\n+    @Test\n+    public void test_interruptAfterRun() throws Throwable {\n+        String name = \"interruptAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+       t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has ended was was interrupted\", t.isInterrupted());    \n+    }\n+\n+    /* if thread is interrupted before start, verify that flag is still set after run. */\n+    @Test\n+    public void test_interruptAtStartSetAfterRun() throws Throwable {\n+        String name = \"interruptAtStartSetAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* run thread */\n+        t.run();", "originalCommit": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0NDQ1NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r414844454", "bodyText": "This and join() don't do anything, this test is the same as test_interruptAtStartSetAfterRun()", "author": "pshipton", "createdAt": "2020-04-24T20:29:42Z", "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.AssertJUnit;\n+\n+/**\n+ * This test is to verify matching behavior to the RI from the following implementation change\n+ * discussed in the Java 14 release notes:\n+ * \n+ * \"The specification for java.lang.Thread::interrupt allows for an implementation to only track the \n+ * interrupt state for live threads, and previously this is what occurred. As of this release, the \n+ * interrupt state of a Thread is always available, and if you interrupt a thread t before it is started, \n+ * or after it has terminated, the query t.isInterrupted() will return true.\"\n+ */\n+\n+@Test(groups = { \"level.sanity\" })\n+public class Test_Thread {\n+\n+    /* interrupt thread before it has started */\n+    @Test\n+    public void test_interruptBeforeRun() {\n+        String name = \"interruptBeforeRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+    }\n+\n+    /* interrupt thread after it has ended */\n+    @Test\n+    public void test_interruptAfterRun() throws Throwable {\n+        String name = \"interruptAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+       t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has ended was was interrupted\", t.isInterrupted());    \n+    }\n+\n+    /* if thread is interrupted before start, verify that flag is still set after run. */\n+    @Test\n+    public void test_interruptAtStartSetAfterRun() throws Throwable {\n+        String name = \"interruptAtStartSetAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* run thread */\n+        t.run();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should be dead\", t.isAlive());\n+        AssertJUnit.assertTrue(name + \"interrupt flag should be set\", t.isInterrupted()); \n+    }\n+\n+    /* Interrupt thread during run, verify that interrupt flag is not set when thread stops running. \n+     * isInterrupted becomes false after InterruptedException is thrown. */\n+    @Test\n+    public void test_interruptDuringRun() throws Throwable {\n+        String name = \"interruptDuringRun: \";\n+        Thread t = new Thread() {\n+            public void run() {\n+                synchronized(this) {\n+                    try {\n+                        wait();\n+                        AssertJUnit.fail(); /* not interrupted */\n+                    } catch (InterruptedException e) {\n+                        /* expected */\n+                    }\n+                }\n+            }\n+        };\n+\n+        /* run thread */\n+        t.start();\n+        AssertJUnit.assertFalse(name + \"thread not yet interrupted during run\", t.isInterrupted());\n+        t.interrupt();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should be dead\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted()); \n+    }\n+\n+    /* Interrupt thread at start and during run, verify that interrupt flag is not set when thread stops running.\n+     * isInterrupted becomes false after InterruptedException is thrown. */\n+    @Test\n+    public void test_interruptBeforeAndDuringRun() throws Throwable {\n+        String name = \"interruptBeforeAndDuringRun: \";\n+        Thread t = new Thread() {\n+            public void run() {\n+                synchronized(this) {\n+                    try {\n+                        wait();\n+                        AssertJUnit.fail(); /* not interrupted */\n+                    } catch (InterruptedException e) {\n+                        /* expected */\n+                    }\n+                }\n+            }\n+        };\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        /* interrupt before run */\n+        t.interrupt();\n+\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+\n+        /* run thread */\n+        t.start();\n+        t.interrupt();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should be dead\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should be cleared\", t.isInterrupted()); \n+    }\n+\n+    /* If thread is interrupted before start, Thread.interrupted is set */\n+    @Test\n+    public void test_interruptedStart() throws Throwable {\n+        String name = \"interruptedStart: \";\n+        Thread t = new Thread(){\n+            public void run() throws AssertionError {\n+                AssertJUnit.assertTrue(Thread.interrupted());\n+            }\n+          };\n+\n+        /* interrupt before start */\n+        t.interrupt();\n+\n+        t.start();\n+        t.join();\n+\n+        AssertJUnit.assertFalse(name + \"interrupt flag should be cleared\", t.isInterrupted()); \n+    }\n+\n+    /* If thread is interrupted before run, Thread.interrupted is not set */\n+    @Test\n+    public void test_interruptedRun() throws Throwable {\n+        String name = \"interrupted\";\n+        Thread t = new Thread(){\n+            public void run() throws AssertionError {\n+                AssertJUnit.assertFalse(Thread.interrupted());\n+            }\n+            };\n+\n+        /* interrupt before start */\n+        t.interrupt();\n+\n+        t.run();", "originalCommit": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c2c9a1cb6fa359b15723150e1d0f7a1644557667", "url": "https://github.com/eclipse-openj9/openj9/commit/c2c9a1cb6fa359b15723150e1d0f7a1644557667", "message": "Fix formatting", "committedDate": "2020-04-24T20:53:21Z", "type": "forcePushed"}, {"oid": "c4b895791d3ef2f9e254d6317fbbadc02edfa95d", "url": "https://github.com/eclipse-openj9/openj9/commit/c4b895791d3ef2f9e254d6317fbbadc02edfa95d", "message": "Fix formatting", "committedDate": "2020-04-24T20:54:19Z", "type": "forcePushed"}, {"oid": "99c75c37e3309c53314dbfa310ae3efe4202a60a", "url": "https://github.com/eclipse-openj9/openj9/commit/99c75c37e3309c53314dbfa310ae3efe4202a60a", "message": "Fix formatting", "committedDate": "2020-04-24T20:55:03Z", "type": "forcePushed"}, {"oid": "88c5e35d29688065ac52933a616c805702e4de8b", "url": "https://github.com/eclipse-openj9/openj9/commit/88c5e35d29688065ac52933a616c805702e4de8b", "message": "Formatting", "committedDate": "2020-04-24T20:56:51Z", "type": "forcePushed"}, {"oid": "7db4f6e386800ab9451a3a646d1656d9d035e71a", "url": "https://github.com/eclipse-openj9/openj9/commit/7db4f6e386800ab9451a3a646d1656d9d035e71a", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-04-29T18:10:49Z", "type": "forcePushed"}, {"oid": "ba295f22a72c6877721b6b71d3ffaaedcfff215b", "url": "https://github.com/eclipse-openj9/openj9/commit/ba295f22a72c6877721b6b71d3ffaaedcfff215b", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-04-29T20:55:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4ODEzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420288131", "bodyText": "Is --enable-preview needed for this test?", "author": "pshipton", "createdAt": "2020-05-05T17:37:07Z", "path": "test/functional/Java14andUp/playlist.xml", "diffHunk": "@@ -23,28 +23,51 @@\n -->\n \n <playlist xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../../TestConfig/playlist.xsd\">\n-      <test>\n-          <testCaseName>Jep359Tests</testCaseName>\n-          <variations>\n-                  <variation>NoOptions</variation>\n-          </variations>\n-          <command>$(JAVA_COMMAND) $(JVM_OPTIONS) \\\n-                  --enable-preview \\\n-                  -cp $(Q)$(LIB_DIR)$(D)asm-7.3.jar$(P)$(RESOURCES_DIR)$(P)$(TESTNG)$(P)$(TEST_RESROOT)$(D)GeneralTest.jar$(Q) \\\n-                  org.testng.TestNG -d $(REPORTDIR) $(Q)$(TEST_RESROOT)$(D)testng.xml$(Q) -testnames Jep359Tests \\\n-                  -groups $(TEST_GROUP) \\\n-                  -excludegroups $(DEFAULT_EXCLUDE); \\\n-                  $(TEST_STATUS)\n-          </command>\n-          <levels>\n-                  <level>sanity</level>\n-          </levels>\n-          <groups>\n-                  <group>functional</group>\n-          </groups>\n-          <!-- Run for Java 14 only since this is a preview feature. -->\n-          <subsets>\n-                  <subset>14</subset>\n-          </subsets>\n-        </test>\n+    <test>\n+        <testCaseName>Jep359Tests</testCaseName>\n+        <variations>\n+            <variation>NoOptions</variation>\n+        </variations>\n+        <command>$(JAVA_COMMAND) $(JVM_OPTIONS) \\\n+            --enable-preview \\\n+            -cp $(Q)$(LIB_DIR)$(D)asm-7.3.jar$(P)$(RESOURCES_DIR)$(P)$(TESTNG)$(P)$(TEST_RESROOT)$(D)GeneralTest.jar$(Q) \\\n+            org.testng.TestNG -d $(REPORTDIR) $(Q)$(TEST_RESROOT)$(D)testng.xml$(Q) -testnames Jep359Tests \\\n+            -groups $(TEST_GROUP) \\\n+            -excludegroups $(DEFAULT_EXCLUDE); \\\n+            $(TEST_STATUS)\n+        </command>\n+        <levels>\n+            <level>sanity</level>\n+        </levels>\n+        <groups>\n+            <group>functional</group>\n+        </groups>\n+        <!-- Run for Java 14 only since this is a preview feature. -->\n+        <subsets>\n+            <subset>14</subset>\n+        </subsets>\n+    </test>\n+    <test>\n+        <testCaseName>ThreadInterruptImplTest</testCaseName>\n+        <variations>\n+            <variation>NoOptions</variation>\n+        </variations>\n+        <command>$(JAVA_COMMAND) $(JVM_OPTIONS) \\\n+            --enable-preview \\", "originalCommit": "ba295f22a72c6877721b6b71d3ffaaedcfff215b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMxNTMyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420315321", "bodyText": "Without --enable-preview here I am getting java.lang.UnsupportedClassVersionError: Preview features are not enabled for org/openj9/test/java/lang/Test_Class when I try to run ThreadInterruptImplTest.\nIs there a preferable way to set this up @llxia? Note Test_Class is part of Jep359Tests and is not related to ThreadInterruptImplTest.", "author": "theresa-m", "createdAt": "2020-05-05T18:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4ODEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM0ODU4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420348583", "bodyText": "Will we remove --enable-preview option in the future? If so, you can move it in variation  <variation>--enable-preview</variation>, so it is more visible.", "author": "llxia", "createdAt": "2020-05-05T19:19:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4ODEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM2NjQ2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420366464", "bodyText": "So now I am curious why org/openj9/test/java/lang/Test_Class is involved when we're running tests from org/openj9/test/java/lang/Test_Thread. Is it just some side affect of testng? Do you have the stack trace?", "author": "pshipton", "createdAt": "2020-05-05T19:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4ODEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQyMjUzNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420422534", "bodyText": "Exception in thread \"main\" java.lang.UnsupportedClassVersionError: Preview features are not enabled for org/openj9/test/java/lang/Test_Class (class file version 58.65535). Try running with '--enable-preview'\n        at java.base/java.lang.ClassLoader.defineClass1(Native Method)\n        at java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1017)\n        at java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:151)\n        at java.base/jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:821)\n        at java.base/jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:719)\n        at java.base/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:642)\n        at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:600)\n        at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)\n        at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)\n        at org.testng.internal.ClassHelper.forName(ClassHelper.java:117)\n        at org.testng.xml.XmlClass.loadClass(XmlClass.java:74)\n        at org.testng.xml.XmlClass.init(XmlClass.java:69)\n        at org.testng.xml.XmlClass.<init>(XmlClass.java:55)\n        at org.testng.xml.TestNGContentHandler.startElement(TestNGContentHandler.java:575)\n        at java.xml/com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.startElement(AbstractSAXParser.java:518)\n        at java.xml/com.sun.org.apache.xerces.internal.parsers.AbstractXMLDocumentParser.emptyElement(AbstractXMLDocumentParser.java:183)\n        at java.xml/com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDValidator.emptyElement(XMLDTDValidator.java:752)\n        at java.xml/com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.scanStartElement(XMLNSDocumentScannerImpl.java:351)\n        at java.xml/com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2725)\n        at java.xml/com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:605)\n        at java.xml/com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.next(XMLNSDocumentScannerImpl.java:112)\n        at java.xml/com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:541)\n        at java.xml/com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:888)\n        at java.xml/com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:824)\n        at java.xml/com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:141)\n        at java.xml/com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1224)\n        at java.xml/com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:635)\n        at java.xml/com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl.parse(SAXParserImpl.java:324)\n        at java.xml/javax.xml.parsers.SAXParser.parse(SAXParser.java:197)\n        at org.testng.xml.XMLParser.parse(XMLParser.java:38)\n        at org.testng.xml.SuiteXmlParser.parse(SuiteXmlParser.java:16)\n        at org.testng.xml.SuiteXmlParser.parse(SuiteXmlParser.java:9)\n        at org.testng.xml.Parser.parse(Parser.java:152)\n        at org.testng.xml.Parser.parse(Parser.java:233)\n        at org.testng.TestNG.parseSuite(TestNG.java:295)\n        at org.testng.TestNG.initializeSuitesAndJarFile(TestNG.java:348)\n        at org.testng.TestNG.initializeEverything(TestNG.java:995)\n        at org.testng.TestNG.run(TestNG.java:1009)\n        at org.testng.TestNG.privateMain(TestNG.java:1354)\n        at org.testng.TestNG.main(TestNG.java:1323)", "author": "theresa-m", "createdAt": "2020-05-05T21:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4ODEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzOTY4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420439683", "bodyText": "I think the issue is that TestNG includes all tests from the suite on the classpath. I tried out a java program locally and added an unrelated record on the classpath and the same error happened.", "author": "theresa-m", "createdAt": "2020-05-05T22:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4ODEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4MzU1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420383556", "bodyText": "Formating nitpick\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t/*  deadInterrupt tracks the thread interrupt state when threadRef has no reference (ie thread is not alive). \n          \n          \n            \n            \t* Note that this value need not be updated while the thread is running since the interrupt state will be \n          \n          \n            \n            \t* tracked by the vm during that time. Because of this the value should not be used over calling\n          \n          \n            \n            \t*  isInterrupted() or interrupted().\n          \n          \n            \n            \t*/\n          \n          \n            \n            \t/* deadInterrupt tracks the thread interrupt state when threadRef has no reference (ie thread is not alive). \n          \n          \n            \n            \t * Note that this value need not be updated while the thread is running since the interrupt state will be \n          \n          \n            \n            \t * tracked by the vm during that time. Because of this the value should not be used over calling\n          \n          \n            \n            \t * isInterrupted() or interrupted().\n          \n          \n            \n            \t */", "author": "DanHeidinga", "createdAt": "2020-05-05T20:24:15Z", "path": "jcl/src/java.base/share/classes/java/lang/Thread.java", "diffHunk": "@@ -80,6 +80,14 @@\n \t// Instance variables\n \tprivate long threadRef;\t\t\t\t\t\t\t\t\t// Used by the VM\n \tlong stackSize = 0;\n+\t/*[IF Java14]*/\n+\t/*  deadInterrupt tracks the thread interrupt state when threadRef has no reference (ie thread is not alive). \n+\t* Note that this value need not be updated while the thread is running since the interrupt state will be \n+\t* tracked by the vm during that time. Because of this the value should not be used over calling\n+\t*  isInterrupted() or interrupted().\n+\t*/", "originalCommit": "ba295f22a72c6877721b6b71d3ffaaedcfff215b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4NDI0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420384249", "bodyText": "Formatting seems odd here too\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tdeadInterrupt = true;\n          \n          \n            \n            \t\tdeadInterrupt = true;", "author": "DanHeidinga", "createdAt": "2020-05-05T20:25:32Z", "path": "jcl/src/java.base/share/classes/java/lang/Thread.java", "diffHunk": "@@ -700,7 +712,12 @@ public void interrupt() {\n \t\tsun.nio.ch.Interruptible localBlockOn = blockOn;\n \t\tif (localBlockOn != null) {\n \t\t\tlocalBlockOn.interrupt(this);\n-\t\t}\n+        }\n+        /*[IF Java14]*/\n+        if (!isAlive()) {\n+\t\t\tdeadInterrupt = true;", "originalCommit": "ba295f22a72c6877721b6b71d3ffaaedcfff215b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4NTE1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420385158", "bodyText": "We can't modify an object without vm access.  This will need to be done before the call to releaseVMAccess", "author": "DanHeidinga", "createdAt": "2020-05-05T20:27:16Z", "path": "runtime/vm/vmthread.c", "diffHunk": "@@ -399,6 +399,11 @@ void threadCleanup(J9VMThread * vmThread, UDATA forkedByVM)\n \t/* We are dead at this point. Clear the suspend bit prior to triggering the thread end hook */\n \tclearHaltFlag(vmThread, J9_PUBLIC_FLAGS_HALT_THREAD_JAVA_SUSPEND);\n \n+#if (JAVA_SPEC_VERSION >= 14)\n+    /* Refresh java.lang.Thread interrupt value so it is acessible when vm thread is cleaned up. */\n+    J9VMJAVALANGTHREAD_SET_DEADINTERRUPT(vmThread, vmThread->threadObject, omrthread_interrupted(vmThread->osThread));", "originalCommit": "ba295f22a72c6877721b6b71d3ffaaedcfff215b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4NjE2NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420386165", "bodyText": "Should this clear DEADINTERRUPT as well since it's being transferred to the native thread's interrupted state?  Otherwise, when the thread dies, it will appear to be interrupted as this will still be set", "author": "DanHeidinga", "createdAt": "2020-05-05T20:29:06Z", "path": "runtime/vm/vmthread.c", "diffHunk": "@@ -1959,6 +1964,13 @@ startJavaThreadInternal(J9VMThread * currentThread, UDATA privateFlags, UDATA os\n \t}\n \tJ9VMJAVALANGTHREAD_SET_THREADREF(currentThread, threadObject, newThread);\n \n+#if (JAVA_SPEC_VERSION >= 14)\n+    /* If thread was interrupted before start, make sure interrupt flag is set for running thread. */\n+    if (J9VMJAVALANGTHREAD_DEADINTERRUPT(currentThread, threadObject)) {\n+        omrthread_interrupt(osThread);", "originalCommit": "ba295f22a72c6877721b6b71d3ffaaedcfff215b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQyOTUyNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420429525", "bodyText": "I don't think its necessary since DEADINTERRUPT will be updated with the native state when the thread dies. I've made a comment over the deadInterrupt declaration in Thread.java to indicate that the state will not be updated when the thread is running.", "author": "theresa-m", "createdAt": "2020-05-05T21:54:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4NjE2NQ=="}], "type": "inlineReview"}, {"oid": "9e2f0d88f51b6e5e8743019d8fe1c1e9d88481f8", "url": "https://github.com/eclipse-openj9/openj9/commit/9e2f0d88f51b6e5e8743019d8fe1c1e9d88481f8", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-05-05T22:33:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUzNDUwOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420534509", "bodyText": "Can this be moved into the existing java \"cleanUpAttachedThread\" call?\nThe call path, starting below in cleanUpAttachedThread is:\nhttps://github.com/eclipse/openj9/blob/ed6c69f07441718bb9ab8cbf65c4d755f9ca56c3/runtime/vm/callin.cpp#L459\nhttps://github.com/eclipse/openj9/blob/906d4009533c1c313e9e31a9e5db895e9ff0dcdf/jcl/src/java.base/share/classes/java/lang/J9VMInternals.java#L318\nhttps://github.com/eclipse/openj9/blob/5a2386c150d3277d326c05224b206ef041ffbc73/jcl/src/java.base/share/classes/java/lang/Thread.java#L1527\nCould this cleanup method call isInterrupted() and handle this final set in java?  Using the java native to do the set would also clear the native thread's interrupted state which would be a plus, given we recycle the native threads at the vm level", "author": "DanHeidinga", "createdAt": "2020-05-06T04:08:14Z", "path": "runtime/vm/vmthread.c", "diffHunk": "@@ -391,6 +391,12 @@ void threadCleanup(J9VMThread * vmThread, UDATA forkedByVM)\n \t\t/* Safe to call this whether handleUncaughtException clears the exception or not */\n \t\tinternalExceptionDescribe(vmThread);\n \t}\n+\n+\t#if (JAVA_SPEC_VERSION >= 14)\n+\t\t/* Refresh java.lang.Thread interrupt value so it is acessible when vm thread is cleaned up. */\n+\t\tJ9VMJAVALANGTHREAD_SET_DEADINTERRUPT(vmThread, vmThread->threadObject, omrthread_interrupted(vmThread->osThread));", "originalCommit": "9e2f0d88f51b6e5e8743019d8fe1c1e9d88481f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUzNTk0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420535943", "bodyText": "If we can't do it in java, then I'd like to see this moved as late as possible - so it's done in the same acquire / release block as the cleanUpAttachedThread call", "author": "DanHeidinga", "createdAt": "2020-05-06T04:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUzNDUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MDAwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r421040008", "bodyText": "Why the second interrupt in this test?  The interrupt state should still be set from the previous interrupt call", "author": "DanHeidinga", "createdAt": "2020-05-06T19:30:58Z", "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.AssertJUnit;\n+\n+/**\n+ * This test is to verify matching behavior to the RI from the following implementation change\n+ * discussed in the Java 14 release notes:\n+ * \n+ * \"The specification for java.lang.Thread::interrupt allows for an implementation to only track the \n+ * interrupt state for live threads, and previously this is what occurred. As of this release, the \n+ * interrupt state of a Thread is always available, and if you interrupt a thread t before it is started, \n+ * or after it has terminated, the query t.isInterrupted() will return true.\"\n+ */\n+\n+@Test(groups = { \"level.sanity\" })\n+public class Test_Thread {\n+\n+    /* interrupt thread after it has ended */\n+    @Test\n+    public void test_interruptAfterRun() throws Throwable {\n+        String name = \"interruptAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+        \n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has ended was was interrupted\", t.isInterrupted());    \n+    }\n+\n+    /* Verify that thread was sucessfully interrupted before it is started, and that the interrupt flag is \n+     * still set after it is run. */\n+    @Test\n+    public void test_interruptAtStartSetAfterRun() throws Throwable {\n+        String name = \"interruptAtStartSetAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should be dead\", t.isAlive());\n+        AssertJUnit.assertTrue(name + \"interrupt flag should be set\", t.isInterrupted()); \n+    }\n+\n+    /* Interrupt thread during run, verify that interrupt flag is not set when thread stops running. \n+     * isInterrupted becomes false after InterruptedException is thrown. */\n+    private volatile boolean bool_interruptDuringRun = false;\n+    @Test\n+    public void test_interruptDuringRun() throws Throwable {\n+        String name = \"interruptDuringRun: \";\n+        Thread t = new Thread() {\n+            public void run() {\n+                synchronized(this) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                        /* expected */\n+                        bool_interruptDuringRun = true;\n+                    }\n+                }\n+            }\n+        };\n+\n+        /* run thread */\n+        t.start();\n+        AssertJUnit.assertFalse(name + \"thread not yet interrupted during run\", t.isInterrupted());\n+        t.interrupt();\n+        t.join();\n+\n+        AssertJUnit.assertTrue(name + \"InterruptedException was thrown during run\", bool_interruptDuringRun);\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should be dead\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted()); \n+    }\n+\n+    /* Interrupt thread at start and during run, verify that interrupt flag is not set when thread stops running.\n+     * isInterrupted becomes false after InterruptedException is thrown. */\n+    private volatile boolean bool_interruptBeforeAndDuringRun = false;\n+    @Test\n+    public void test_interruptBeforeAndDuringRun() throws Throwable {\n+        String name = \"interruptBeforeAndDuringRun: \";\n+        Thread t = new Thread() {\n+            public void run() {\n+                synchronized(this) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                        bool_interruptBeforeAndDuringRun = true;\n+                    }\n+                }\n+            }\n+        };\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        /* interrupt before run */\n+        t.interrupt();\n+\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+\n+        /* run thread */\n+        t.start();\n+        t.interrupt();", "originalCommit": "f926cc1b1c5176688b72ec10dcba320e7e18d2e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1NjE5OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r421056199", "bodyText": "I think the first one can be removed. This interrupt makes the test confusing.", "author": "theresa-m", "createdAt": "2020-05-06T19:59:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MDAwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2MjkwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r421062908", "bodyText": "I thought the point of this test was the interrupt status from before the thread starts is still relevant when running - which would mean we'd want to remove the 2nd, not the first.  Did I misunderstand?", "author": "DanHeidinga", "createdAt": "2020-05-06T20:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MDAwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjkzMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r421086930", "bodyText": "That case should be covered by test_interruptedStart", "author": "theresa-m", "createdAt": "2020-05-06T20:56:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MDAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MTE0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r421041149", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /* Verify thread is dead and has not been interrupted */\n          \n          \n            \n                    /* Verify thread is dead and has been interrupted */", "author": "DanHeidinga", "createdAt": "2020-05-06T19:33:05Z", "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.AssertJUnit;\n+\n+/**\n+ * This test is to verify matching behavior to the RI from the following implementation change\n+ * discussed in the Java 14 release notes:\n+ * \n+ * \"The specification for java.lang.Thread::interrupt allows for an implementation to only track the \n+ * interrupt state for live threads, and previously this is what occurred. As of this release, the \n+ * interrupt state of a Thread is always available, and if you interrupt a thread t before it is started, \n+ * or after it has terminated, the query t.isInterrupted() will return true.\"\n+ */\n+\n+@Test(groups = { \"level.sanity\" })\n+public class Test_Thread {\n+\n+    /* interrupt thread after it has ended */\n+    @Test\n+    public void test_interruptAfterRun() throws Throwable {\n+        String name = \"interruptAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+        \n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has ended was was interrupted\", t.isInterrupted());    \n+    }\n+\n+    /* Verify that thread was sucessfully interrupted before it is started, and that the interrupt flag is \n+     * still set after it is run. */\n+    @Test\n+    public void test_interruptAtStartSetAfterRun() throws Throwable {\n+        String name = \"interruptAtStartSetAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */", "originalCommit": "f926cc1b1c5176688b72ec10dcba320e7e18d2e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MjA1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r421042058", "bodyText": "I like this approach.  Can you confirm that the thread is \"isAlive\" at this point?  Otherwise the interrupted() call will return the previous setting of deadInterrupt.", "author": "DanHeidinga", "createdAt": "2020-05-06T19:34:37Z", "path": "jcl/src/java.base/share/classes/java/lang/Thread.java", "diffHunk": "@@ -1525,6 +1551,11 @@ void uncaughtException(Throwable e) {\n  * @see J9VMInternals#threadCleanup()\n  */\n void cleanup() {\n+/*[IF Java14]*/\n+\t/* Refresh deadInterrupt value so it is accurate when vm thread is cleaned up. */\t\n+\tdeadInterrupt = interrupted();", "originalCommit": "f926cc1b1c5176688b72ec10dcba320e7e18d2e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2MjM0NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r421062344", "bodyText": "The thread will still be considered alive at this point. isAlive will start to return false when threadRef is cleared: https://github.com/eclipse/openj9/blob/5a2386c150d3277d326c05224b206ef041ffbc73/jcl/src/java.base/share/classes/java/lang/Thread.java#L1545", "author": "theresa-m", "createdAt": "2020-05-06T20:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MjA1OA=="}], "type": "inlineReview"}, {"oid": "d43bd50fd28e68ab5f1836291fc6083ebdac28c9", "url": "https://github.com/eclipse-openj9/openj9/commit/d43bd50fd28e68ab5f1836291fc6083ebdac28c9", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-05-06T19:36:03Z", "type": "forcePushed"}, {"oid": "64f97efabbcf97a5f3fe54a7866319a4e7f0788c", "url": "https://github.com/eclipse-openj9/openj9/commit/64f97efabbcf97a5f3fe54a7866319a4e7f0788c", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-05-06T20:04:35Z", "type": "commit"}, {"oid": "64f97efabbcf97a5f3fe54a7866319a4e7f0788c", "url": "https://github.com/eclipse-openj9/openj9/commit/64f97efabbcf97a5f3fe54a7866319a4e7f0788c", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-05-06T20:04:35Z", "type": "forcePushed"}]}