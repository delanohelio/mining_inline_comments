{"pr_number": 9811, "pr_title": "Minimize contention between \"finders\" using SCC JCL helper", "pr_createdAt": "2020-06-05T15:27:54Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9811", "timeline": [{"oid": "46efbacf5e5d8e43a994d6ec92ef6b60c3e53e3d", "url": "https://github.com/eclipse-openj9/openj9/commit/46efbacf5e5d8e43a994d6ec92ef6b60c3e53e3d", "message": "Minimize contention between \"finders\" using SCC JCL helper.\n\nThere are 2 issues with findSharedClass() in SCC Helpers being\nsynchronized:\n\nA. For classLoader with isParallelCapable = true, the parallel \nclass loading capability is lost.\nB. In the case that there are multiple custom Classloaders setting \nthe app ClassLoader as the parent, they all delegate to the app\nClassLoader first when finding classes. So all of them need to go \nthrough the synchronized method appClassloader.findSharedClass() \none by one, which becomes a bottleneck.\n\nThe changes here are:\n1. Change findSharedClass() as well as storeSharedClass() to be\nnon-synchronized.\n\n2. Use a readWriteLock in SharedClassURLClasspathHelperImpl \ninstead.\n\n3. Do not enter classTableMutex and class segmentMutex in the \nnative implementation of findSharedClass() in shared.c, as\nentering these mutexes is essentially making findSharedClass()\nsynchronized in the native level.\n\n4. Enter class segmentMutex only when necessary in \nhookFindSharedClass() and cacheMap::findROMClass().\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-06-05T15:30:53Z", "type": "forcePushed"}, {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d", "url": "https://github.com/eclipse-openj9/openj9/commit/1b70681c95131a2d4c73bc2d203ff2cd8436e53d", "message": "Minimize contention between \"finders\" using SCC JCL helper\n\nThere are 2 issues with findSharedClass() in SCC Helpers being\nsynchronized:\n\nA. For classLoader with isParallelCapable = true, the parallel \nclass loading capability is lost.\nB. In the case that there are multiple custom Classloaders setting \nthe app ClassLoader as the parent, they all delegate to the app\nClassLoader first when finding classes. So all of them need to go \nthrough the synchronized method appClassloader.findSharedClass() \none by one, which becomes a bottleneck.\n\nThe changes here are:\n1. Change findSharedClass() as well as storeSharedClass() to be\nnon-synchronized.\n\n2. Use a readWriteLock in SharedClassURLClasspathHelperImpl \ninstead.\n\n3. Do not enter classTableMutex and class segmentMutex in the \nnative implementation of findSharedClass() in shared.c, as\nentering these mutexes is essentially making findSharedClass()\nsynchronized in the native level.\n\n4. Enter class segmentMutex only when necessary in \nhookFindSharedClass() and cacheMap::findROMClass().\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-06-05T16:10:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5ODI2MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436098261", "bodyText": "The function comment \"If VM class segment is held, hasClassSegmentMutex must be true\" seems obsolete even before this change.", "author": "pshipton", "createdAt": "2020-06-05T18:36:30Z", "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -1735,9 +1736,10 @@ SH_CacheMap::addClasspathToCache(J9VMThread* currentThread, ClasspathItem* obj)\n  * @return the number of items read, or -1 on error\n  */\n IDATA \n-SH_CacheMap::runEntryPointChecks(J9VMThread* currentThread, void* address, const char** p_subcstr)\n+SH_CacheMap::runEntryPointChecks(J9VMThread* currentThread, void* address, const char** p_subcstr, bool acquireClassSegmentMutex)", "originalCommit": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1NjYxNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436956614", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-08T19:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5ODI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5OTE0MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436099140", "bodyText": "Pls fix the function comment, \"findROMClass and storeROMClass prereq that the class segment mutex is held\"", "author": "pshipton", "createdAt": "2020-06-05T18:38:16Z", "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -932,6 +932,7 @@ SH_CacheMap::updateROMSegmentList(J9VMThread* currentThread, bool hasClassSegmen\n #if defined(J9VM_THR_PREEMPTIVE)\n \tif (!hasClassSegmentMutex) {\n \t\tTrc_SHR_Assert_ShouldNotHaveLocalMutex(classSegmentMutex);\n+\t\tTrc_SHR_Assert_False(_ccHead->hasWriteMutex(currentThread));", "originalCommit": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1NzIzOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436957239", "bodyText": "Fixed", "author": "hangshao0", "createdAt": "2020-06-08T19:42:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5OTE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5OTYwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436099608", "bodyText": "Pls fix the function comment \"Caller must have VM class segment mutex.\"", "author": "pshipton", "createdAt": "2020-06-05T18:39:21Z", "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2692,8 +2707,6 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \tUDATA hash = 0;\n \tbool useWriteHash = _ccHead->isUsingWriteHash();\n \n-\tTrc_SHR_Assert_ShouldHaveLocalMutex(currentThread->javaVM->classMemorySegments->segmentMutex);", "originalCommit": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1NzQ3Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436957473", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-08T19:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5OTYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjE3MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436106170", "bodyText": "The call to markStale() above needs to have the segmentMutex.", "author": "pshipton", "createdAt": "2020-06-05T18:53:07Z", "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2913,7 +2935,7 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \n \tif (returnVal) {\n \t\t/* Call updateROMSegmentList() to ensure that heapAlloc of the romClass segment is always updated to include the returned romClass */\n-\t\tupdateROMSegmentList(currentThread, true);\n+\t\tupdateROMSegmentList(currentThread, omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);", "originalCommit": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1Njc4Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436156786", "bodyText": "I guess markStale() only touches metadata, not romclass segment.  Why do we need segmentMutex ?", "author": "hangshao0", "createdAt": "2020-06-05T20:47:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjE3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2NDQ5OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436164498", "bodyText": "I was going by the comment which says THREADING: Caller must have VM class segment mutex.", "author": "pshipton", "createdAt": "2020-06-05T21:06:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjE3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2NjYzNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436166635", "bodyText": "I see a call to localCPM->markClasspathsStale, something needs to protect that.", "author": "pshipton", "createdAt": "2020-06-05T21:12:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjE3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2Nzc1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436167751", "bodyText": "I guess the write mutex does that. Not sure why the comment.", "author": "pshipton", "createdAt": "2020-06-05T21:15:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjE3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2OTg4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436169882", "bodyText": "I guess in the previous code, we should have class segmentMutex when reaching markStale(). But it is not true anymore after this change. I will delete the comment THREADING: Caller must have VM class segment mutex.", "author": "hangshao0", "createdAt": "2020-06-05T21:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjE3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1ODAxMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436958011", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-08T19:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjE3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNzk2MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436107961", "bodyText": "The calls to getBootstrapClasspathItem() above needs to have the segmentMutex as well.\nI think technically we don't need the segmentMutex for these calls, but it was protecting them in the past. Another mutex could be used to reduce contention on the segmentMutex, although this also affects storing classes. Suggest sticking with segmentMutex in this PR, and consider future optimization. Similarly for registerStoreFilter().", "author": "pshipton", "createdAt": "2020-06-05T18:57:02Z", "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1515,7 +1517,15 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \tif (!classpath) {\n \t\t/* No cached classpath found. Need to create a new one. */\n \t\tif ((NULL != eventData->classPathEntries) || (eventData->classloader == vm->systemClassLoader)) {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "originalCommit": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2MTI4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436961281", "bodyText": "Put getBootstrapClasspathItem() inside class segmentMutex.", "author": "hangshao0", "createdAt": "2020-06-08T19:50:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNzk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMjkxOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436112918", "bodyText": "Pls fix the function comment \"The caller must hold the VM class segment mutex\".", "author": "pshipton", "createdAt": "2020-06-05T19:08:04Z", "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1427,6 +1427,8 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \tUDATA localVerboseFlags;\n \tJ9SharedClassConfig* sharedClassConfig = vm->sharedClassConfig;\n \tbool isBootLoader = false;\n+\tbool releaseSegmentMutex = false;", "originalCommit": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1ODM5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436958391", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-08T19:45:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMjkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNDEwNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436124104", "bodyText": "This needs to move back before if (confirmedCount <= foundAtIndex)", "author": "pshipton", "createdAt": "2020-06-05T19:34:50Z", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +175,62 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n-\t\t}\n \t\tClassLoader actualLoader = getClassLoader();\n \t\tif (!validateClassLoader(actualLoader, clazz)) {\n \t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (confirmedCount <= foundAtIndex) {\n-\t\t\tconfirmedCount = foundAtIndex+1;\n-\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n-\t\t}\n-\t\treturn storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (confirmedCount <= foundAtIndex) {\n+\t\t\t\tconfirmedCount = foundAtIndex+1;\n+\t\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {", "originalCommit": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2MDkyNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436960927", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-08T19:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNDEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436136673", "bodyText": "readLock() should be sufficient.", "author": "pshipton", "createdAt": "2020-06-05T19:57:55Z", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -228,137 +246,160 @@ private synchronized void growURLs(int toMinSize) {\n \t}\n \n \t@Override\n-\tpublic synchronized void addClasspathEntry(URL cpe) {\n+\tpublic void addClasspathEntry(URL cpe) {\n \t\tClassLoader loader = getClassLoader();\n \t\tif (loader != null) {\n \t\t\tif (cpe==null) {\n \t\t\t\t/*[MSG \"K05ac\", \"URL is null for addClasspathEntry.\"]*/\n \t\t\t\tprintVerboseError(Msg.getString(\"K05ac\")); //$NON-NLS-1$\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\t/* If array is not big enough, grow it */\n-\t\t\tif (urls.length < (urlCount+1)) {\n-\t\t\t\tgrowURLs(urlCount+1);\n-\t\t\t}\n-\t\t\torigurls[urlCount] = cpe;\n-\t\t\turls[urlCount] = convertJarURL(cpe);\n-\t\t\tif (!validateURL(urls[urlCount], false)) {\n-\t\t\t\tinvalidURLExists = true;\n+\t\t\tURL convertedurl = convertJarURL(cpe);\n+\t\t\tboolean invalidUrl = false;\n+\t\t\tif (!validateURL(convertedurl, false)) {\n+\t\t\t\tinvalidUrl = true;\n \t\t\t}\n-\t\t\tnotifyClasspathChange2(loader);\n-\t\t\tif (!invalidURLExists) {\n-\t\t\t\tnotifyClasspathChange3(id, loader, urls, urlCount, (urlCount + 1), true);\n+\t\t\turlcpReadWriteLock.writeLock().lock();\n+\t\t\ttry {\n+\t\t\t\t/* If array is not big enough, grow it */\n+\t\t\t\tif (urls.length < (urlCount+1)) {\n+\t\t\t\t\tgrowURLs(urlCount+1);\n+\t\t\t\t}\n+\t\t\t\torigurls[urlCount] = cpe;\n+\t\t\t\turls[urlCount] = convertedurl;\n+\t\t\t\tinvalidURLExists = invalidUrl;\n+\t\t\t\tnotifyClasspathChange2(loader);\n+\t\t\t\tif (!invalidURLExists) {\n+\t\t\t\t\tnotifyClasspathChange3(id, loader, urls, urlCount, (urlCount + 1), true);\n+\t\t\t\t}\n+\t\t\t\t++urlCount;\n+\t\t\t} finally {\n+\t\t\t\turlcpReadWriteLock.writeLock().unlock();\n \t\t\t}\n-\t\t\t++urlCount;\n \t\t}\n \t}\n \n \t/* Function required by the factory */\n-\tsynchronized URL[] getClasspath() {\n+\tURL[] getClasspath() {\n \t\tURL[] correctLengthArray = new URL[urlCount];\n-\t\tSystem.arraycopy(origurls, 0, correctLengthArray, 0, urlCount);\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tSystem.arraycopy(origurls, 0, correctLengthArray, 0, urlCount);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n+\t\t}\n \t\treturn correctLengthArray;\n \t}\n \n \t@Override\n-\tpublic synchronized void confirmAllEntries() {\n-\t\tconfirmedCount = urlCount;\n+\tpublic void confirmAllEntries() {\n+\t\turlcpReadWriteLock.writeLock().lock();", "originalCommit": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MDk1Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436170952", "bodyText": "Field confirmedCount is updated by this function. readLock() only is fine ?", "author": "hangshao0", "createdAt": "2020-06-05T21:24:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NjQ0MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436176440", "bodyText": "I think so. urlCount is only modified with the writeLock(), so all readers will just get the same value.", "author": "pshipton", "createdAt": "2020-06-05T21:40:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3ODI5Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436178296", "bodyText": "Note that storeSharedClass() is also modifying confirmedCount using the readLock().", "author": "pshipton", "createdAt": "2020-06-05T21:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5NTQ1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436195458", "bodyText": "Actually this does seems problematic, I think confirmAllEntries() should stay as it is, and storeSharedClass() needs a fix.", "author": "pshipton", "createdAt": "2020-06-05T22:41:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1OTU0Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436959542", "bodyText": "Added a new function increaseConfirmedCount() that increases confirmedCount inside writeLock().", "author": "hangshao0", "createdAt": "2020-06-08T19:47:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436139755", "bodyText": "newJarFileCheck() needs internal synchronization. Also the SharedClassFilter doesn't mention synchronization, but removing synchronized changes the behavior for calling acceptFind() and acceptStore(), these calls should remain protected.", "author": "pshipton", "createdAt": "2020-06-05T20:05:26Z", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLHelperImpl.java", "diffHunk": "@@ -103,7 +103,7 @@ public boolean setMinimizeUpdateChecks() {\n \t}\n \n \t@Override\n-\tpublic synchronized byte[] findSharedClass(String partition, URL path, String className) {\n+\tpublic byte[] findSharedClass(String partition, URL path, String className) {", "originalCommit": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2NTMwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436165307", "bodyText": "Also the SharedClassFilter doesn't mention synchronization, but removing synchronized changes the behavior for calling acceptFind() and acceptStore(), these calls should remain protected.\n\nYou mean removing synchronized from getSharingFilter()/setSharingFilter(), then protect the calls of getSharingFilter(), setSharingFilter(), acceptFind() and acceptStore() within readWriteLock ?", "author": "hangshao0", "createdAt": "2020-06-05T21:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NDU0MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436174541", "bodyText": "newJarFileCheck() needs internal synchronization.\n\nI am thinking about changing jarFileNameCache from a regular Set to ConcurrentHashMap.newKeySet().", "author": "hangshao0", "createdAt": "2020-06-05T21:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NDkyMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436174923", "bodyText": "It doesn't need to use the readWriteLock(), but something should keep the synchronized behavior of calling acceptFind() and acceptStore() the same. Similarly, getSharingFilter()/setSharingFilter() are fine the way they are since they are already synchronized.", "author": "pshipton", "createdAt": "2020-06-05T21:36:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NzAwMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436177001", "bodyText": "I am thinking about changing jarFileNameCache from a regular Set to ConcurrentHashMap.newKeySet()\n\nAs long as it doesn't cause a measurable increase in footprint.", "author": "pshipton", "createdAt": "2020-06-05T21:42:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2MDM4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436960381", "bodyText": "Changed jarFileNameCache to a concurrent Set and wrap acceptFind()/acceptStore() inside a synchronized block.", "author": "hangshao0", "createdAt": "2020-06-08T19:49:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk3NjcyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436976726", "bodyText": "Better to keep the old behavior and synchronize on the instance of SharedClassURLHelperImpl than to start synchronizing on the user supplied object, which could have unexpected side effects. Or best is to synchronize on an internal Object.", "author": "pshipton", "createdAt": "2020-06-08T20:21:07Z", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLHelperImpl.java", "diffHunk": "@@ -126,12 +125,14 @@ public boolean setMinimizeUpdateChecks() {\n \t\tSharedClassFilter theFilter = getSharingFilter();\n \t\tboolean doFind, doStore;\n \t\tif (theFilter!=null) {\n-\t\t\tdoFind = theFilter.acceptFind(className);\n-\t\t\t/* Don't invoke the store filter if the cache is full */\n-\t\t\tif (nativeFlags[CACHE_FULL_FLAG] == 0) {\n-\t\t\t\tdoStore = theFilter.acceptStore(className);\n-\t\t\t} else {\n-\t\t\t\tdoStore = true;\n+\t\t\tsynchronized(theFilter) {", "originalCommit": "7849dead8a04a198c372dc35dcfc218aa5db8cd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk3OTMwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436979308", "bodyText": "Note the same synchronization changes are also needed in SharedClassURLClasspathHelperImpl and SharedClassTokenHelperImpl.", "author": "pshipton", "createdAt": "2020-06-08T20:26:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk3NjcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwNzIwOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437007209", "bodyText": "I didn't find proper internal obj to sync in SharedClassURLHelperImpl and SharedClassTokenHelperImpl, so I am synchronizing on this.", "author": "hangshao0", "createdAt": "2020-06-08T21:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk3NjcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4MzYzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436983638", "bodyText": "This is another writer.", "author": "pshipton", "createdAt": "2020-06-08T20:33:21Z", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +175,66 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n-\t\t}\n \t\tClassLoader actualLoader = getClassLoader();\n \t\tif (!validateClassLoader(actualLoader, clazz)) {\n \t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (confirmedCount <= foundAtIndex) {\n-\t\t\tconfirmedCount = foundAtIndex+1;\n-\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n+\t\tboolean storeRet = false;\n+\t\tboolean incConfirmedCount = false;\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {\n+\t\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n+\t\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tvalidated[foundAtIndex]=true;", "originalCommit": "7849dead8a04a198c372dc35dcfc218aa5db8cd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwMzQ3NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437003475", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-08T21:11:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4MzYzOA=="}], "type": "inlineReview"}, {"oid": "cf41616c6fd61ef9d10289c8261bcfda7f53c33f", "url": "https://github.com/eclipse-openj9/openj9/commit/cf41616c6fd61ef9d10289c8261bcfda7f53c33f", "message": "Minimize contention between \"finders\" using SCC JCL helper\n\n1. Delete obsolete comments on functions requiring class segment\nmutex.\n2. Wrap getBootstrapClasspathItem() inside class segment mutex.\n3. Add a new API to increase\nSharedClassURLClasspathHelperImpl.confirmedCount.\n4. Change SharedClassURLHelperImpl.jarFileNameCache from a regular \nSet to a concurrent Set.\n5. Wrap acceptFind() and acceptStore() in a synchronized block.\n6. Do not need to wrap callFindLocallyDefinedClass() inside class\nsegment mutex.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-06-08T21:08:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwOTQzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437009438", "bodyText": "Might as well combine updating validated and confirmedCount to use a single writeLock().lock().", "author": "pshipton", "createdAt": "2020-06-08T21:23:15Z", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +177,70 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\tClassLoader actualLoader = getClassLoader();\n+\t\tif (!validateClassLoader(actualLoader, clazz)) {\n+\t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\tboolean storeRet = false;\n+\t\tboolean incConfirmedCount = false;\n+\t\tboolean urlValidated = false;\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {\n+\t\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n+\t\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t} \n+\t\t\t\turlValidated = true;\n+\t\t\t}\n+\t\t\tif (confirmedCount <= foundAtIndex) {\n+\t\t\t\tincConfirmedCount = true;\n+\t\t\t}\n+\t\t\tstoreRet = storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n \t\t}\n-\t\tClassLoader actualLoader = getClassLoader();\n-\t\tif (!validateClassLoader(actualLoader, clazz)) {\n-\t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n-\t\t\treturn false;\n+\t\tif (urlValidated) {", "originalCommit": "cf41616c6fd61ef9d10289c8261bcfda7f53c33f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAxMzc0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437013743", "bodyText": "I added setValidatedAtIndex(), but I am wondering if we really need that. I guess the previous code that sets validated[foundAtIndex]=true; inside readLock should be fine, we just may have multiple threads setting it to true, which won't have any negative impact.", "author": "hangshao0", "createdAt": "2020-06-08T21:32:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwOTQzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyMzAxMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437023011", "bodyText": "I'm ok with that.", "author": "pshipton", "createdAt": "2020-06-08T21:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwOTQzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNTgwMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437025802", "bodyText": "setValidatedAtIndex() removed.", "author": "hangshao0", "createdAt": "2020-06-08T22:01:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwOTQzOA=="}], "type": "inlineReview"}, {"oid": "2446d4de57f5c06cfc09bff1620630a893755df9", "url": "https://github.com/eclipse-openj9/openj9/commit/2446d4de57f5c06cfc09bff1620630a893755df9", "message": "Minimize contention between \"finders\" using SCC JCL helper\n\n1. Delete obsolete comments on functions requiring class segment\nmutex.\n2. Wrap getBootstrapClasspathItem() inside class segment mutex.\n3. Add a new API to increase\nSharedClassURLClasspathHelperImpl.confirmedCount.\n4. Change SharedClassURLHelperImpl.jarFileNameCache from a regular \nSet to a concurrent Set.\n5. Wrap acceptFind() and acceptStore() in a synchronized block.\n6. Do not need to wrap callFindLocallyDefinedClass() inside class\nsegment mutex.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-06-08T21:59:03Z", "type": "forcePushed"}, {"oid": "b37b5ef92cf08713207384362e796f99a46aa5bd", "url": "https://github.com/eclipse-openj9/openj9/commit/b37b5ef92cf08713207384362e796f99a46aa5bd", "message": "_identifiedClasspaths should be used inside _identifiedMutex\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-06-10T21:01:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NDcyNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438484724", "bodyText": "Pls add a newline.", "author": "pshipton", "createdAt": "2020-06-11T00:53:59Z", "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -2987,3 +2987,6 @@ TraceEvent=Trc_SHR_CC_startup_getCacheUniqueID_after Overhead=1 Level=7 Template\n \n TraceEvent=Trc_SHR_API_j9shr_classStoreTransaction_start_cacheFull_Event Overhead=1 Level=3 Template=\"API j9shr_classStoreTransaction_start : J9SHR_RUNTIMEFLAG_BLOCK_SPACE_FULL is set. The shared cache is full\"\n TraceEvent=Trc_SHR_API_j9shr_classStoreTransaction_start_cacheSoftFull_Event Overhead=1 Level=3 Template=\"API j9shr_classStoreTransaction_start : J9SHR_RUNTIMEFLAG_AVAILABLE_SPACE_FULL is set. The shared cache is soft full\"\n+\n+TraceExit-Exception=Trc_SHR_CMI_Update_Exit5 Overhead=1 Level=2 Template=\"CMI Update: StoreIdentified failed to acquire _identifiedMutex. Returning -1.\"\n+TraceExit-Exception=Trc_SHR_CMI_validate_Exit_IdentifiedMutex_Failed Overhead=1 Level=2 Template=\"CMI validate: Failed to acquire _identifiedMutex. Returning -1\"", "originalCommit": "b37b5ef92cf08713207384362e796f99a46aa5bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkwNDMyOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438904329", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-11T16:09:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NDcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODE1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438488151", "bodyText": "Since the condition tested to get here isn't the same as the condition where identifiedMutex is entered further above, it seems possible for the assertion in local_StoreIdentified() to occur. Shouldn't identifiedMutex be entered if it's not already?", "author": "pshipton", "createdAt": "2020-06-11T01:07:46Z", "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1099,7 +1114,26 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \tif (localFoundAtIndex == -1) {\n \t\t/* We didn't find an exact classpath match. Walk the classpaths and check for validity. Note that the timestamp check is incorporated for efficiency. */\n \t\tlocalFoundAtIndex = localValidate_CheckAndTimestampManually(currentThread, testCP, testCPIndex, compareTo, foundIdentified, &addToIdentified, staleItem);\n+\t\t/* If the classpath has just been identified by localValidate_CheckAndTimestampManually, store it in the identified array */\n+\t\tif (addToIdentified && (compareTo->getType()==CP_TYPE_CLASSPATH) && (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING)) {\n+\t\t\t/* Identification succeeded. Store identified classpath. */\n+\t\t\tif (local_StoreIdentified(currentThread, compareTo, testCP)==-1) {", "originalCommit": "b37b5ef92cf08713207384362e796f99a46aa5bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkwNjM0Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438906342", "bodyText": "Yes, it should enter identifiedMutex if it has not. I thought about this case yesterday in the morning, but after lunch, I forgot.  Fixed now.", "author": "hangshao0", "createdAt": "2020-06-11T16:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODI1Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438488252", "bodyText": "I don't see why releaseIdentifiedMutex is needed here.", "author": "pshipton", "createdAt": "2020-06-11T01:08:12Z", "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1065,29 +1072,37 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \t\tIDATA prevMatch = ID_NOT_FOUND;\n \n \t\tfoundIdentified = -1;\n-\n-\t\t/* Multiple ClassLoaders could have the same classpath, so search until the matching helperID is found */\n-\t\tdo {\n-\t\t\tif ((foundIdentified = localValidate_FindIdentified(currentThread, testCP, foundIdentified+1)) != ID_NOT_FOUND) {\n-\t\t\t\tprevMatch = foundIdentified;\n-\t\t\t}\n-\t\t} while ((foundIdentified != ID_NOT_FOUND) && (foundIdentified != compareToID));\n-\n-\t\t/* This means we have a positive match - testCP is the same classpath as that of the caller classloader */\n-\t\tif (foundIdentified==compareToID) {\n-\t\t\tlocalFoundAtIndex = testCPIndex;\n-\t\t} else {\n-\t\t\t/* At this point, foundIdentified will always be ID_NOT_FOUND. This means that testCP is not exactly the same classpath as the caller\n-\t\t\t * classloader's, but we have identified it and it could still be a valid match. Test to see if we have tried this match before and failed it. */\n-\t\t\tfoundIdentified = prevMatch;\n-\t\t\tif (foundIdentified != ID_NOT_FOUND) {\n-\t\t\t\tif (hasMatchFailedBefore(currentThread, _identifiedClasspaths, compareToID, foundIdentified, testCPIndex, NULL, 0)) {\n-\t\t\t\t\t/* trace event is at level 1 and trace exit message is at level 2 as per CMVC 155318/157683 */\n-\t\t\t\t\tTrc_SHR_CMI_validate_ExitFailedBefore_Event(currentThread, foundROMClass, compareTo, confirmedEntries);\n-\t\t\t\t\tTrc_SHR_CMI_validate_ExitFailedBefore(currentThread);\n-\t\t\t\t\tgoto _done;\n+\t\tif (0 == _cache->enterLocalMutex(currentThread, _identifiedMutex, \"identifiedMutex\", \"validate\")) {\n+\t\t\treleaseIdentifiedMutex = true;\n+\t\t\t/* Multiple ClassLoaders could have the same classpath, so search until the matching helperID is found */\n+\t\t\tdo {\n+\t\t\t\tif ((foundIdentified = localValidate_FindIdentified(currentThread, testCP, foundIdentified+1)) != ID_NOT_FOUND) {\n+\t\t\t\t\tprevMatch = foundIdentified;\n+\t\t\t\t}\n+\t\t\t} while ((foundIdentified != ID_NOT_FOUND) && (foundIdentified != compareToID));\n+\t\n+\t\t\t/* This means we have a positive match - testCP is the same classpath as that of the caller classloader */\n+\t\t\tif (foundIdentified==compareToID) {\n+\t\t\t\tlocalFoundAtIndex = testCPIndex;\n+\t\t\t} else {\n+\t\t\t\t/* At this point, foundIdentified will always be ID_NOT_FOUND. This means that testCP is not exactly the same classpath as the caller\n+\t\t\t\t * classloader's, but we have identified it and it could still be a valid match. Test to see if we have tried this match before and failed it. */\n+\t\t\t\tfoundIdentified = prevMatch;\n+\t\t\t\tif (foundIdentified != ID_NOT_FOUND) {\n+\t\t\t\t\tif (hasMatchFailedBefore(currentThread, _identifiedClasspaths, compareToID, foundIdentified, testCPIndex, NULL, 0)) {\n+\t\t\t\t\t\t/* trace event is at level 1 and trace exit message is at level 2 as per CMVC 155318/157683 */\n+\t\t\t\t\t\tTrc_SHR_CMI_validate_ExitFailedBefore_Event(currentThread, foundROMClass, compareTo, confirmedEntries);\n+\t\t\t\t\t\tTrc_SHR_CMI_validate_ExitFailedBefore(currentThread);\n+\t\t\t\t\t\tif (releaseIdentifiedMutex) {", "originalCommit": "b37b5ef92cf08713207384362e796f99a46aa5bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkwNDg4NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438904884", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-11T16:10:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODU2Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438488562", "bodyText": "Seems if releaseIdentifiedMutex is false, the assert in local_StoreIdentified() would occur before getting here.", "author": "pshipton", "createdAt": "2020-06-11T01:09:32Z", "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1099,7 +1114,26 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \tif (localFoundAtIndex == -1) {\n \t\t/* We didn't find an exact classpath match. Walk the classpaths and check for validity. Note that the timestamp check is incorporated for efficiency. */\n \t\tlocalFoundAtIndex = localValidate_CheckAndTimestampManually(currentThread, testCP, testCPIndex, compareTo, foundIdentified, &addToIdentified, staleItem);\n+\t\t/* If the classpath has just been identified by localValidate_CheckAndTimestampManually, store it in the identified array */\n+\t\tif (addToIdentified && (compareTo->getType()==CP_TYPE_CLASSPATH) && (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING)) {\n+\t\t\t/* Identification succeeded. Store identified classpath. */\n+\t\t\tif (local_StoreIdentified(currentThread, compareTo, testCP)==-1) {\n+\t\t\t\t/* trace event is at level 1 and trace exit message is at level 2 as per CMVC 155318/157683  */\n+\t\t\t\tTrc_SHR_CMI_validate_ExitError_Event(currentThread, foundROMClass, compareTo, confirmedEntries);\n+\t\t\t\tTrc_SHR_CMI_validate_ExitError(currentThread);\n+\t\t\t\tif (releaseIdentifiedMutex) {", "originalCommit": "b37b5ef92cf08713207384362e796f99a46aa5bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkwNjQ1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438906456", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-11T16:12:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODU2Mg=="}], "type": "inlineReview"}, {"oid": "979d5b7c97340f72db2d679e287235a889eb808b", "url": "https://github.com/eclipse-openj9/openj9/commit/979d5b7c97340f72db2d679e287235a889eb808b", "message": "_identifiedClasspaths should be used inside _identifiedMutex\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-06-11T16:08:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNTEzMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438935133", "bodyText": "Pls use ! instead of false ==", "author": "pshipton", "createdAt": "2020-06-11T17:00:11Z", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +177,66 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n-\t\t}\n \t\tClassLoader actualLoader = getClassLoader();\n \t\tif (!validateClassLoader(actualLoader, clazz)) {\n \t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (confirmedCount <= foundAtIndex) {\n-\t\t\tconfirmedCount = foundAtIndex+1;\n-\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n+\t\tboolean storeRet = false;\n+\t\tboolean incConfirmedCount = false;\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {\n+\t\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n+\t\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tvalidated[foundAtIndex]=true;\n+\t\t\t}\n+\t\t\tif (confirmedCount <= foundAtIndex) {\n+\t\t\t\tincConfirmedCount = true;\n+\t\t\t}\n+\t\t\tstoreRet = storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n+\t\t}\n+\t\tif (incConfirmedCount) {\n+\t\t\tincreaseConfirmedCount(foundAtIndex + 1);\n \t\t}\n-\t\treturn storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\treturn storeRet;\n \t}\n \n-\tprivate synchronized void growURLs(int toMinSize) {\n+\tprivate void growURLs(int toMinSize) {\n+\t\tif (false == urlcpReadWriteLock.writeLock().isHeldByCurrentThread()) {", "originalCommit": "979d5b7c97340f72db2d679e287235a889eb808b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODMzNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998334", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-11T18:47:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNTEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNTg4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438935882", "bodyText": "Constant on the left.", "author": "pshipton", "createdAt": "2020-06-11T17:01:29Z", "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2810,7 +2821,16 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \t\t\t\t\t\t\tTrc_SHR_CM_findROMClass_FailedMutex(currentThread, path, cp->getHelperID());\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tIDATA rv = refreshHashtables(currentThread, true);\t\t/* We do have the class segment mutex - this is a prereq of findROMClass */\n+\t\t\t\t\t\tbool segmentMutexEntered = false;\n+\t\t\t\t\t\tif (omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) == 0) {", "originalCommit": "979d5b7c97340f72db2d679e287235a889eb808b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODM4NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998384", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-11T18:47:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNTg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNjA2Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438936066", "bodyText": "Pls add a space.", "author": "pshipton", "createdAt": "2020-06-11T17:01:49Z", "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2810,7 +2821,16 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \t\t\t\t\t\t\tTrc_SHR_CM_findROMClass_FailedMutex(currentThread, path, cp->getHelperID());\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tIDATA rv = refreshHashtables(currentThread, true);\t\t/* We do have the class segment mutex - this is a prereq of findROMClass */\n+\t\t\t\t\t\tbool segmentMutexEntered = false;\n+\t\t\t\t\t\tif (omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) == 0) {\n+\t\t\t\t\t\t\tTrc_SHR_Assert_False(_ccHead->hasWriteMutex(currentThread));\n+\t\t\t\t\t\t\tenterLocalMutex(currentThread, currentThread->javaVM->classMemorySegments->segmentMutex, \"class segment mutex\", \"CM findROMClass\");\n+\t\t\t\t\t\t\tsegmentMutexEntered= true;", "originalCommit": "979d5b7c97340f72db2d679e287235a889eb808b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODQ1Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998453", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-11T18:47:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNjA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNzY2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438937664", "bodyText": "Pls add spaces and put constants on the left. The (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING) should use OMR_ARE_ANY_BITS_SET", "author": "pshipton", "createdAt": "2020-06-11T17:04:51Z", "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1099,7 +1112,31 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \tif (localFoundAtIndex == -1) {\n \t\t/* We didn't find an exact classpath match. Walk the classpaths and check for validity. Note that the timestamp check is incorporated for efficiency. */\n \t\tlocalFoundAtIndex = localValidate_CheckAndTimestampManually(currentThread, testCP, testCPIndex, compareTo, foundIdentified, &addToIdentified, staleItem);\n+\t\t/* If the classpath has just been identified by localValidate_CheckAndTimestampManually, store it in the identified array */\n+\t\tif (addToIdentified && (compareTo->getType()==CP_TYPE_CLASSPATH) && (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING)) {", "originalCommit": "979d5b7c97340f72db2d679e287235a889eb808b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODUyMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998523", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-11T18:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNzY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODAxOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438938019", "bodyText": "Pls add spaces and put constants on the left.", "author": "pshipton", "createdAt": "2020-06-11T17:05:30Z", "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1099,7 +1112,31 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \tif (localFoundAtIndex == -1) {\n \t\t/* We didn't find an exact classpath match. Walk the classpaths and check for validity. Note that the timestamp check is incorporated for efficiency. */\n \t\tlocalFoundAtIndex = localValidate_CheckAndTimestampManually(currentThread, testCP, testCPIndex, compareTo, foundIdentified, &addToIdentified, staleItem);\n+\t\t/* If the classpath has just been identified by localValidate_CheckAndTimestampManually, store it in the identified array */\n+\t\tif (addToIdentified && (compareTo->getType()==CP_TYPE_CLASSPATH) && (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING)) {\n+\t\t\tif (!releaseIdentifiedMutex) {\n+\t\t\t\tif (0 == _cache->enterLocalMutex(currentThread, _identifiedMutex, \"identifiedMutex\", \"validate\")) {\n+\t\t\t\t\treleaseIdentifiedMutex = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t/* Identification succeeded. Store identified classpath. */\n+\t\t\tif (releaseIdentifiedMutex) {\n+\t\t\t\tif (local_StoreIdentified(currentThread, compareTo, testCP)==-1) {", "originalCommit": "979d5b7c97340f72db2d679e287235a889eb808b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODU3Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998576", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-11T18:47:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODI4NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438938285", "bodyText": "Constant on the left.", "author": "pshipton", "createdAt": "2020-06-11T17:05:57Z", "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1505,17 +1506,41 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \t\t\tif (eventData->classloader == vm->systemClassLoader) {\n \t\t\t\tisBootLoader = true;\n \t\t\t\tpathEntryCount += 1;\n+\t\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "originalCommit": "979d5b7c97340f72db2d679e287235a889eb808b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODYyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998626", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-11T18:47:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODQ5Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438938496", "bodyText": "Constant on the left.", "author": "pshipton", "createdAt": "2020-06-11T17:06:17Z", "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1505,17 +1506,41 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \t\t\tif (eventData->classloader == vm->systemClassLoader) {\n \t\t\t\tisBootLoader = true;\n \t\t\t\tpathEntryCount += 1;\n+\t\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {\n+\t\t\t\t\tomrthread_monitor_enter(classSegmentMutex);\n+\t\t\t\t\treleaseSegmentMutex = true;\n+\t\t\t\t}\n \t\t\t\tclasspath = getBootstrapClasspathItem(currentThread, vm->modulesPathEntry, pathEntryCount);\n+\t\t\t\tif (releaseSegmentMutex) {\n+\t\t\t\t\tomrthread_monitor_exit(classSegmentMutex);\n+\t\t\t\t\treleaseSegmentMutex = false;\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "originalCommit": "979d5b7c97340f72db2d679e287235a889eb808b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODY5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998691", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-11T18:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODY2Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438938667", "bodyText": "Constant on the left.", "author": "pshipton", "createdAt": "2020-06-11T17:06:35Z", "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1505,17 +1506,41 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \t\t\tif (eventData->classloader == vm->systemClassLoader) {\n \t\t\t\tisBootLoader = true;\n \t\t\t\tpathEntryCount += 1;\n+\t\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {\n+\t\t\t\t\tomrthread_monitor_enter(classSegmentMutex);\n+\t\t\t\t\treleaseSegmentMutex = true;\n+\t\t\t\t}\n \t\t\t\tclasspath = getBootstrapClasspathItem(currentThread, vm->modulesPathEntry, pathEntryCount);\n+\t\t\t\tif (releaseSegmentMutex) {\n+\t\t\t\t\tomrthread_monitor_exit(classSegmentMutex);\n+\t\t\t\t\treleaseSegmentMutex = false;\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {\n+\t\t\t\tomrthread_monitor_enter(classSegmentMutex);\n+\t\t\t\treleaseSegmentMutex = true;\n+\t\t\t}\n \t\t\tclasspath = getBootstrapClasspathItem(currentThread, eventData->classPathEntries, pathEntryCount);\n+\t\t\tif (releaseSegmentMutex) {\n+\t\t\t\tomrthread_monitor_exit(classSegmentMutex);\n+\t\t\t\treleaseSegmentMutex = false;\n+\t\t\t}\n \t\t}\n \t}\n \n \tif (!classpath) {\n \t\t/* No cached classpath found. Need to create a new one. */\n \t\tif ((NULL != eventData->classPathEntries) || (eventData->classloader == vm->systemClassLoader)) {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "originalCommit": "979d5b7c97340f72db2d679e287235a889eb808b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODgyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998826", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-11T18:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODc4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438938788", "bodyText": "Constants on the left.", "author": "pshipton", "createdAt": "2020-06-11T17:06:50Z", "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1537,7 +1562,15 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \n \tif (eventData->doPreventFind) {\n \t\tif (eventData->doPreventStore) {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "originalCommit": "979d5b7c97340f72db2d679e287235a889eb808b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODg4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998882", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-11T18:48:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODkzMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438938930", "bodyText": "Constant on the left.", "author": "pshipton", "createdAt": "2020-06-11T17:07:06Z", "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1564,7 +1597,14 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \t}\n \n \tif (eventData->doPreventStore && (NULL == eventData->result)) {\n+\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "originalCommit": "979d5b7c97340f72db2d679e287235a889eb808b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODk0NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998944", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-11T18:48:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODkzMA=="}], "type": "inlineReview"}, {"oid": "d33af83f4ae4240ff1b32b87b4632a4b5501c501", "url": "https://github.com/eclipse-openj9/openj9/commit/d33af83f4ae4240ff1b32b87b4632a4b5501c501", "message": "_identifiedClasspaths should be used inside _identifiedMutex\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-06-11T18:46:03Z", "type": "forcePushed"}, {"oid": "77b14cc5395285f662f8394988726fbb3cf1be4f", "url": "https://github.com/eclipse-openj9/openj9/commit/77b14cc5395285f662f8394988726fbb3cf1be4f", "message": "Minimize contention between \"finders\" using SCC JCL helper\n\nThere are 2 issues with findSharedClass() in SCC Helpers being\nsynchronized:\n\nA. For classLoader with isParallelCapable = true, the parallel \nclass loading capability is lost.\nB. In the case that there are multiple custom Classloaders setting \nthe app ClassLoader as the parent, they all delegate to the app\nClassLoader first when finding classes. So all of them need to go \nthrough the synchronized method appClassloader.findSharedClass() \none by one, which becomes a bottleneck.\n\nThe changes here are:\n1. Change findSharedClass() as well as storeSharedClass() to be\nnon-synchronized.\n\n2. Use a readWriteLock in SharedClassURLClasspathHelperImpl \ninstead.\n\n3. Do not enter classTableMutex and class segmentMutex in the \nnative implementation of findSharedClass() in shared.c, as\nentering these mutexes is essentially making findSharedClass()\nsynchronized in the native level.\n\n4. Enter class segmentMutex only when necessary in \nhookFindSharedClass() and cacheMap::findROMClass().\n\n5. Do not need to wrap callFindLocallyDefinedClass() inside class\nsegment mutex.\n\n6. Change SharedClassURLHelperImpl.jarFileNameCache from a regular \nSet to a concurrent Set.\n\n7. _identifiedClasspaths should be used inside _identifiedMutex.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-06-11T20:31:22Z", "type": "commit"}, {"oid": "77b14cc5395285f662f8394988726fbb3cf1be4f", "url": "https://github.com/eclipse-openj9/openj9/commit/77b14cc5395285f662f8394988726fbb3cf1be4f", "message": "Minimize contention between \"finders\" using SCC JCL helper\n\nThere are 2 issues with findSharedClass() in SCC Helpers being\nsynchronized:\n\nA. For classLoader with isParallelCapable = true, the parallel \nclass loading capability is lost.\nB. In the case that there are multiple custom Classloaders setting \nthe app ClassLoader as the parent, they all delegate to the app\nClassLoader first when finding classes. So all of them need to go \nthrough the synchronized method appClassloader.findSharedClass() \none by one, which becomes a bottleneck.\n\nThe changes here are:\n1. Change findSharedClass() as well as storeSharedClass() to be\nnon-synchronized.\n\n2. Use a readWriteLock in SharedClassURLClasspathHelperImpl \ninstead.\n\n3. Do not enter classTableMutex and class segmentMutex in the \nnative implementation of findSharedClass() in shared.c, as\nentering these mutexes is essentially making findSharedClass()\nsynchronized in the native level.\n\n4. Enter class segmentMutex only when necessary in \nhookFindSharedClass() and cacheMap::findROMClass().\n\n5. Do not need to wrap callFindLocallyDefinedClass() inside class\nsegment mutex.\n\n6. Change SharedClassURLHelperImpl.jarFileNameCache from a regular \nSet to a concurrent Set.\n\n7. _identifiedClasspaths should be used inside _identifiedMutex.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-06-11T20:31:22Z", "type": "forcePushed"}]}