{"pr_number": 9517, "pr_title": "Fix instanceOf's dynamicCache sequence on IBM Z", "pr_createdAt": "2020-05-11T14:29:16Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9517", "timeline": [{"oid": "083195889ffe858775dd19742020aaa0d69d36ee", "url": "https://github.com/eclipse-openj9/openj9/commit/083195889ffe858775dd19742020aaa0d69d36ee", "message": "Set Code Cache alignment to 16 bits on IBM Z\n\nOn IBM Z platform, to support load and store quadward\ninstruction from snippet, snippet address should be aligned to\nquadward boundary. In JIT compilation this works as when emitting\nsnippet, we align the snippets according to its size. But in AOT\nload, there was a possibility that it mess up with the alignment for\nstart of snippet address. By setting the code cache memory alignment to\n16, we make sure, that in AOT load, the snippet from where it is loading or\nstoring, will be aligned.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-05-25T20:59:56Z", "type": "forcePushed"}, {"oid": "9a5b4fc232092e87260ec0df2853c26858214e5b", "url": "https://github.com/eclipse-openj9/openj9/commit/9a5b4fc232092e87260ec0df2853c26858214e5b", "message": "Set Code Cache alignment to 16 bits on IBM Z\n\nOn IBM Z platform, to support load and store quadward\ninstruction from snippet, snippet address should be aligned to\nquadward boundary. In JIT compilation this works as when emitting\nsnippet, we align the snippets according to its size. But in AOT\nload, there was a possibility that it mess up with the alignment for\nstart of snippet address. By setting the code cache memory alignment to\n16, we make sure, that in AOT load, the snippet from where it is loading or\nstoring, will be aligned.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-05-25T21:16:02Z", "type": "forcePushed"}, {"oid": "3a4703eaf139c681caf30931dfc1308949d43e15", "url": "https://github.com/eclipse-openj9/openj9/commit/3a4703eaf139c681caf30931dfc1308949d43e15", "message": "Set Code Cache alignment to 16 bits on IBM Z\n\nOn IBM Z platform, to support load and store quadward\ninstruction from snippet, snippet address should be aligned to\nquadward boundary. In JIT compilation this works as when emitting\nsnippet, we align the snippets according to its size. But in AOT\nload, there was a possibility that it mess up with the alignment for\nstart of snippet address. By setting the code cache memory alignment to\n16, we make sure, that in AOT load, the snippet from where it is loading or\nstoring, will be aligned.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-05-26T18:20:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI3NTE2Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431275166", "bodyText": "I think we should limit this change to Z only. @dsouzai @mpirvu FYI regarding this change in AOT alignment.\nThere is a more general problem in that AOT methods are not being aligned to the same boundary that JIT methods are. I think this is due to not using the same APIs when allocating memory for an AOT load. In normal JIT compilations we will have used allocateCodeMemory [1] and a few lines below a call to alignBinaryBufferCursor [2] which aligns the entry point based off of getJitMethodEntryAlignmentBoundary which codegens override. Every codegen does this in the same way and this was all consolidated in a cross platform way in eclipse/omr#4314.\nI don't see AOT code allocations doing the same thing so we can run into various problems as seen in this PR. I think this needs to be addressed and the code being reviewed here needs to be deprecated in favor of the codegen APIs. Thoughts?\n[1] https://github.com/eclipse/omr/blob/99d7e521e1f8d083ab6bf558d3b8b9264579e46d/compiler/z/codegen/OMRCodeGenerator.cpp#L2431-L2435\n[2] https://github.com/eclipse/omr/blob/99d7e521e1f8d083ab6bf558d3b8b9264579e46d/compiler/codegen/OMRCodeGenerator.cpp#L2196-L2230", "author": "fjeremic", "createdAt": "2020-05-27T16:23:59Z", "path": "runtime/compiler/runtime/codertinit.cpp", "diffHunk": "@@ -222,7 +222,7 @@ J9JITConfig * codert_onload(J9JavaVM * javaVM)\n #elif defined(TR_HOST_64BIT) || defined(TR_HOST_S390)\n    // 390 31-bit may generate 64-bit instruction (i.e. CGRL) which requires\n    // doubleword alignment for its operands\n-   jitConfig->codeCacheAlignment = 8;\n+   jitConfig->codeCacheAlignment = 16;", "originalCommit": "3a4703eaf139c681caf30931dfc1308949d43e15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5NDc1Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431294753", "bodyText": "@fjeremic  In chat I had with @dsouzai , a solution for this issue is to have information about initial alignment in the AOT Method Header so when we start relocation we can use that to get the memory from codecache.", "author": "r30shah", "createdAt": "2020-05-27T16:52:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI3NTE2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwMDIyOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431300229", "bodyText": "Limited alignment changes to Z only in https://github.com/eclipse/openj9/compare/3a4703eaf139c681caf30931dfc1308949d43e15..836d4b19681641d3c250d756ce09c06719a3f5f7", "author": "r30shah", "createdAt": "2020-05-27T16:59:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI3NTE2Ng=="}], "type": "inlineReview"}, {"oid": "836d4b19681641d3c250d756ce09c06719a3f5f7", "url": "https://github.com/eclipse-openj9/openj9/commit/836d4b19681641d3c250d756ce09c06719a3f5f7", "message": "Set Code Cache alignment to 16 bits on IBM Z\n\nOn IBM Z platform, to support load and store quadward\ninstruction from snippet, snippet address should be aligned to\nquadward boundary. In JIT compilation this works as when emitting\nsnippet, we align the snippets according to its size. But in AOT\nload, there was a possibility that it mess up with the alignment for\nstart of snippet address. By setting the code cache memory alignment to\n16, we make sure, that in AOT load, the snippet from where it is loading or\nstoring, will be aligned.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-05-27T16:57:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI4MDA2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431280068", "bodyText": "These trace statements should be guarded by TR_TraceCG", "author": "fjeremic", "createdAt": "2020-05-27T16:31:39Z", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6327,83 +6327,150 @@ static bool graDepsConflictWithInstanceOfDeps(TR::Node * depNode, TR::Node * nod\n  *     This function generates a sequence to check per site cache for object class and cast class before calling out to jitInstanceOf helper\n  */\n static\n-void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n+void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR::RegisterDependencyConditions *deps, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n    {\n    TR::Compilation                *comp = cg->comp();\n    bool needResult = resultReg != NULL;\n    if (!castClassReg)\n-      castClassReg = cg->evaluate(node->getSecondChild());\n+      castClassReg = cg->gprClobberEvaluate(node->getSecondChild());\n+\n    int32_t maxOnsiteCacheSlots = comp->getOptions()->getMaxOnsiteCacheSlotForInstanceOf();\n-   TR::Register *dynamicCacheReg = NULL;\n-   int32_t addressSize = TR::Compiler->om.sizeofReferenceAddress();\n+   int32_t fieldSize = TR::Compiler->om.sizeofReferenceField();\n+   bool isTarget64Bit = comp->target().is64Bit();\n+   bool isCompressedRef = comp->useCompressedPointers();\n    /* Layout of the writable data snippet\n     * Case - 1 : Cast class is runtime variable\n-    * [UpdateIndex][ObjClassSlot-0][CastClassSlot-0]...[ObjClassSlot-N][CastClassSlot-N]\n-    * Case - 2 : Cast Class is interface / unresolved\n-    * [UpdateIndex][ObjClassSlot-0]...[ObjClassSlot-N]\n+    *    Case - 1A: 64 Bit Compressedrefs / 31-Bit JVM\n+    *       -----------------------------------------------------------------------------------------\n+    *       |Header | ObjectClassSlot-0 | CastClassSlot-0 |...| ObjectClassSlot-N | CastClassSlot-N |\n+    *       -----------------------------------------------------------------------------------------\n+    *       0        8                   12                ... 8n                  8n+4\n+    *    Case - 1B: 64 Bit Non Compressedrefs\n+    *       -----------------------------------------------------------------------------------------\n+    *       |Header | ObjectClassSlot-0 | CastClassSlot-0 |...| ObjectClassSlot-N | CastClassSlot-N |\n+    *       -----------------------------------------------------------------------------------------\n+    *       0        16                  24                ... 16n                 16n+8\n+    * Case - 2 : Cast Class is resolved\n+    *    Case - 2A: 64 Bit Compressedrefs / 31-Bit JVM\n+    *       --------------------------------------------------------------------------\n+    *       | Header | ObjectClassSlot-0 | ObjectClassSlot-1 |...| ObjectClassSlot-N |\n+    *       --------------------------------------------------------------------------\n+    *       0         4                   8                   ... 4n\n+    *    Case - 2B: 64 Bit Non Compressedrefs\n+    *       --------------------------------------------------------------------------\n+    *       | Header | ObjectClassSlot-0 | ObjectClassSlot-1 |...| ObjectClassSlot-N |\n+    *       --------------------------------------------------------------------------\n+    *       0         8                   16                   ... 8n\n+    *\n     * If there is only one cache slot, we will not have header.\n     * Last bit of cached objectClass will set to 1 indicating false cast\n+    *\n+    * We can request the snippet size of power 2. Following Table summarizes bytes needed for corresponding number of cache slots.\n+    * \n+    * Following is the table for the number of bytes in snippet needed by each of the Cases mentioned above\n+    *\n+    * Number Of Slots | Case 1A | Case 1B | Case 2A | Case 2B |\n+    *       1         |    8    |   16    |    4    |    8    |\n+    *       2         |    16   |   64    |    16   |    32   |\n+    *       3         |    32   |   64    |    16   |    32   |\n+    *       4         |    64   |   128   |    32   |    64   |\n+    *       5         |    64   |   128   |    32   |    64   |\n+    *       6         |    64   |   128   |    32   |    64   |\n+    *\n     */\n-   int32_t snippetSizeInBytes = ((cacheCastClass ? 2 : 1) * maxOnsiteCacheSlots * addressSize) + (addressSize * (maxOnsiteCacheSlots != 1));\n+   \n+   int32_t snippetSizeInBytes = ((cacheCastClass ? 2 : 1) * maxOnsiteCacheSlots * fieldSize) + (fieldSize * (maxOnsiteCacheSlots != 1) * (cacheCastClass ? 2 : 1));\n+   TR::Register *dynamicCacheReg = NULL;\n+   \n    if (generateDynamicCache)\n       {\n       TR::S390WritableDataSnippet *dynamicCacheSnippet = NULL;\n-      /* We can only request the snippet size of power 2, following table summarizes bytes needed for corresponding number of cache slots\n-       * Case 1 : Cast class is runtime variable\n-       * Case 2 : Cast class is interface / unresolved\n-       * Number Of Slots |  Bytes needed for Case 1 | Bytes needed for Case 2\n-       *        1        |              16          |           8\n-       *        2        |              64          |           32\n-       *        3        |              64          |           32\n-       *        4        |              128         |           64\n-       *        5        |              128         |           64\n-       *        6        |              128         |           64\n-       */\n       int32_t requestedBytes = 1 << (int) (log2(snippetSizeInBytes-1)+1);\n-      traceMsg(comp, \"Requested Bytes = %d\\n\",requestedBytes);\n-      // NOTE: For single slot cache, we initialize snippet with addressSize (4/8) assuming which can not be objectClass\n-      // In all cases, we use first addressSize bytes to store offset of the circular buffer and rest of buffer will be initialized with 0xf.\n+      traceMsg(comp, \"Number Of Dynamic Cache Slots = %d, Caching CastClass: %s\\n\"\n+                     \"Bytes needed for Snippet = %d, requested Bytes = %d\\n\",maxOnsiteCacheSlots, cacheCastClass ? \"true\" : \"false\", snippetSizeInBytes, requestedBytes);\n+", "originalCommit": "3a4703eaf139c681caf30931dfc1308949d43e15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM3MDU1Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431370552", "bodyText": "Changed in https://github.com/eclipse/openj9/compare/836d4b19681641d3c250d756ce09c06719a3f5f7..d93900d74563f5c215cc5b25dfcf7155c2df20a6", "author": "r30shah", "createdAt": "2020-05-27T18:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI4MDA2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI4NDQxNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431284416", "bodyText": "Field of what type? It can be an int, byte[], Object, etc. I think this variable is better named as sizeofJ9ClassFieldWithinReference which directly indicates that we are talking about size of the J9Class* within an object reference.", "author": "fjeremic", "createdAt": "2020-05-27T16:37:10Z", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6327,83 +6327,150 @@ static bool graDepsConflictWithInstanceOfDeps(TR::Node * depNode, TR::Node * nod\n  *     This function generates a sequence to check per site cache for object class and cast class before calling out to jitInstanceOf helper\n  */\n static\n-void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n+void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR::RegisterDependencyConditions *deps, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n    {\n    TR::Compilation                *comp = cg->comp();\n    bool needResult = resultReg != NULL;\n    if (!castClassReg)\n-      castClassReg = cg->evaluate(node->getSecondChild());\n+      castClassReg = cg->gprClobberEvaluate(node->getSecondChild());\n+\n    int32_t maxOnsiteCacheSlots = comp->getOptions()->getMaxOnsiteCacheSlotForInstanceOf();\n-   TR::Register *dynamicCacheReg = NULL;\n-   int32_t addressSize = TR::Compiler->om.sizeofReferenceAddress();\n+   int32_t fieldSize = TR::Compiler->om.sizeofReferenceField();", "originalCommit": "3a4703eaf139c681caf30931dfc1308949d43e15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM3MDQ5Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431370497", "bodyText": "Changed in https://github.com/eclipse/openj9/compare/836d4b19681641d3c250d756ce09c06719a3f5f7..d93900d74563f5c215cc5b25dfcf7155c2df20a6", "author": "r30shah", "createdAt": "2020-05-27T18:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI4NDQxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5MzUzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431293538", "bodyText": "I have a hunch this may not be correct due to @gacholio's work. I believe the size of this type is not going to be a compile time constant in the future which will cause us problems. GAC can you confirm?", "author": "fjeremic", "createdAt": "2020-05-27T16:51:21Z", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6327,83 +6327,150 @@ static bool graDepsConflictWithInstanceOfDeps(TR::Node * depNode, TR::Node * nod\n  *     This function generates a sequence to check per site cache for object class and cast class before calling out to jitInstanceOf helper\n  */\n static\n-void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n+void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR::RegisterDependencyConditions *deps, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n    {\n    TR::Compilation                *comp = cg->comp();\n    bool needResult = resultReg != NULL;\n    if (!castClassReg)\n-      castClassReg = cg->evaluate(node->getSecondChild());\n+      castClassReg = cg->gprClobberEvaluate(node->getSecondChild());\n+\n    int32_t maxOnsiteCacheSlots = comp->getOptions()->getMaxOnsiteCacheSlotForInstanceOf();\n-   TR::Register *dynamicCacheReg = NULL;\n-   int32_t addressSize = TR::Compiler->om.sizeofReferenceAddress();\n+   int32_t fieldSize = TR::Compiler->om.sizeofReferenceField();\n+   bool isTarget64Bit = comp->target().is64Bit();\n+   bool isCompressedRef = comp->useCompressedPointers();\n    /* Layout of the writable data snippet\n     * Case - 1 : Cast class is runtime variable\n-    * [UpdateIndex][ObjClassSlot-0][CastClassSlot-0]...[ObjClassSlot-N][CastClassSlot-N]\n-    * Case - 2 : Cast Class is interface / unresolved\n-    * [UpdateIndex][ObjClassSlot-0]...[ObjClassSlot-N]\n+    *    Case - 1A: 64 Bit Compressedrefs / 31-Bit JVM\n+    *       -----------------------------------------------------------------------------------------\n+    *       |Header | ObjectClassSlot-0 | CastClassSlot-0 |...| ObjectClassSlot-N | CastClassSlot-N |\n+    *       -----------------------------------------------------------------------------------------\n+    *       0        8                   12                ... 8n                  8n+4\n+    *    Case - 1B: 64 Bit Non Compressedrefs\n+    *       -----------------------------------------------------------------------------------------\n+    *       |Header | ObjectClassSlot-0 | CastClassSlot-0 |...| ObjectClassSlot-N | CastClassSlot-N |\n+    *       -----------------------------------------------------------------------------------------\n+    *       0        16                  24                ... 16n                 16n+8\n+    * Case - 2 : Cast Class is resolved\n+    *    Case - 2A: 64 Bit Compressedrefs / 31-Bit JVM\n+    *       --------------------------------------------------------------------------\n+    *       | Header | ObjectClassSlot-0 | ObjectClassSlot-1 |...| ObjectClassSlot-N |\n+    *       --------------------------------------------------------------------------\n+    *       0         4                   8                   ... 4n\n+    *    Case - 2B: 64 Bit Non Compressedrefs\n+    *       --------------------------------------------------------------------------\n+    *       | Header | ObjectClassSlot-0 | ObjectClassSlot-1 |...| ObjectClassSlot-N |\n+    *       --------------------------------------------------------------------------\n+    *       0         8                   16                   ... 8n\n+    *\n     * If there is only one cache slot, we will not have header.\n     * Last bit of cached objectClass will set to 1 indicating false cast\n+    *\n+    * We can request the snippet size of power 2. Following Table summarizes bytes needed for corresponding number of cache slots.\n+    * \n+    * Following is the table for the number of bytes in snippet needed by each of the Cases mentioned above\n+    *\n+    * Number Of Slots | Case 1A | Case 1B | Case 2A | Case 2B |\n+    *       1         |    8    |   16    |    4    |    8    |\n+    *       2         |    16   |   64    |    16   |    32   |\n+    *       3         |    32   |   64    |    16   |    32   |\n+    *       4         |    64   |   128   |    32   |    64   |\n+    *       5         |    64   |   128   |    32   |    64   |\n+    *       6         |    64   |   128   |    32   |    64   |\n+    *\n     */\n-   int32_t snippetSizeInBytes = ((cacheCastClass ? 2 : 1) * maxOnsiteCacheSlots * addressSize) + (addressSize * (maxOnsiteCacheSlots != 1));\n+   \n+   int32_t snippetSizeInBytes = ((cacheCastClass ? 2 : 1) * maxOnsiteCacheSlots * fieldSize) + (fieldSize * (maxOnsiteCacheSlots != 1) * (cacheCastClass ? 2 : 1));\n+   TR::Register *dynamicCacheReg = NULL;\n+   \n    if (generateDynamicCache)\n       {\n       TR::S390WritableDataSnippet *dynamicCacheSnippet = NULL;\n-      /* We can only request the snippet size of power 2, following table summarizes bytes needed for corresponding number of cache slots\n-       * Case 1 : Cast class is runtime variable\n-       * Case 2 : Cast class is interface / unresolved\n-       * Number Of Slots |  Bytes needed for Case 1 | Bytes needed for Case 2\n-       *        1        |              16          |           8\n-       *        2        |              64          |           32\n-       *        3        |              64          |           32\n-       *        4        |              128         |           64\n-       *        5        |              128         |           64\n-       *        6        |              128         |           64\n-       */\n       int32_t requestedBytes = 1 << (int) (log2(snippetSizeInBytes-1)+1);\n-      traceMsg(comp, \"Requested Bytes = %d\\n\",requestedBytes);\n-      // NOTE: For single slot cache, we initialize snippet with addressSize (4/8) assuming which can not be objectClass\n-      // In all cases, we use first addressSize bytes to store offset of the circular buffer and rest of buffer will be initialized with 0xf.\n+      traceMsg(comp, \"Number Of Dynamic Cache Slots = %d, Caching CastClass: %s\\n\"\n+                     \"Bytes needed for Snippet = %d, requested Bytes = %d\\n\",maxOnsiteCacheSlots, cacheCastClass ? \"true\" : \"false\", snippetSizeInBytes, requestedBytes);\n+\n       TR_ASSERT_FATAL(maxOnsiteCacheSlots <= 7, \"Maximum 7 slots per site allowed because we use a fixed stack allocated buffer to construct the snippet\\n\");\n-      UDATA initialSnippet[16] = { static_cast<UDATA>(addressSize) };\n+      j9objectclass_t initialSnippet[16] = { 0 };", "originalCommit": "3a4703eaf139c681caf30931dfc1308949d43e15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNzAxNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431307015", "bodyText": "Yes, j9objectclass_t is not a useful type any more. It's only around to keep DDR happy at this point.", "author": "gacholio", "createdAt": "2020-05-27T17:10:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5MzUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMyODc4NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431328785", "bodyText": "@gacholio  I needed a type which I can use to denote the correct header is set in the snippet. Snippet is holding the J9Class pointers. Any suggestion what I can use?", "author": "r30shah", "createdAt": "2020-05-27T17:47:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5MzUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM1NzQzMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431357432", "bodyText": "There is no type - class pointers are either 32 or 64 bits, depending on a runtime check. Is there a reason not to use an array of J9Class*? If you're getting the classes using the J9OBJECT_CLAZZ macro, that's what it's going to return anyway.", "author": "gacholio", "createdAt": "2020-05-27T18:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5MzUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM2OTk4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431369988", "bodyText": "It is guaranteed that pointer to J9Classwill fit in 32 Bits, but on 64-Bit arch, isn't the size of pointer 64 Bit. So if I use an array of J9Class* , each element will take 64-Bits.", "author": "r30shah", "createdAt": "2020-05-27T18:54:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5MzUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM3MTg2OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431371869", "bodyText": "This is a fixed-size array, so I see no reason to try and store the class pointers in their compressed format. There's no way to get your hands on a j9objectclass_t - they only exist in the obsolete header structs, which you can not use.\nThe only valid way to get the class of an object is to use the macro, which returns the uncompressed direct pointer to the J9Class.", "author": "gacholio", "createdAt": "2020-05-27T18:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5MzUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM3NzI5Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431377297", "bodyText": "This is a fixed-size array, so I see no reason to try and store the class pointers in their compressed format.\n\nReason I chose to store in compressed format is to use an instruction to load 8 byte from cache (Associated classes) which is definitely quicker than loading quadword from memory in single instruction, I am using quadword load instructions for 64 Bit Non Compressedrefs configuration", "author": "r30shah", "createdAt": "2020-05-27T19:07:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5MzUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MjQ0Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431392442", "bodyText": "I have changed the array type to U_32 instead of j9objectclass_t in eacc941\nI don't expect any errors or failures but would like to throw this under test once again. Will update the PR once test finishes.", "author": "r30shah", "createdAt": "2020-05-27T19:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5MzUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MjkzNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431392936", "bodyText": "To support mixed mode, you're going to need to support both at runtime, so the array will need to be UDATA sized anyway. For the compressed case, you could store compressed class pointers there (leaving the last half of the array unused).\nhttps://github.com/eclipse/openj9/blob/2ac59e97f9e40755f54c3cbdee417241d5f93afb/runtime/compiler/z/runtime/s390_macros.inc#L560-L602", "author": "gacholio", "createdAt": "2020-05-27T19:29:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5MzUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5Mzg0Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431393846", "bodyText": "The U32-sized array will certainly fail on 64-bit non-compressed.", "author": "gacholio", "createdAt": "2020-05-27T19:31:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5MzUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5ODYyOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431398628", "bodyText": "The U32-sized array will certainly fail on 64-bit non-compressed.\n\nThis array is just used for initialization of data in snippet. Snippet is used as circular buffer so header is used for storing the offset of update slot. On 64-Bit Non Compressed pointers,\nInstead of storing offset in first 32-Bit, it will store it in second 32-Bit. On runtime we load the 64-Bit value from the header so I do not expect it to fail.", "author": "r30shah", "createdAt": "2020-05-27T19:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5MzUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQwNTMxNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431405316", "bodyText": "To support mixed mode, you're going to need to support both at runtime, so the array will need to be UDATA sized anyway. For the compressed case, you could store compressed class pointers there (leaving the last half of the array unused).\n\nOk, I will have to make changes to support runtime compressed refs. I can open up the issue to keep track of the changes as we are close to 0.21 release and I wanted to get this fixes in to get enough testing.\n@fjeremic  What do you suggest? I believe to support runtime compressed refs, fix will need to  LPQ/STPQ for 64 Bit platform and LG/STG for 31 Bit (In case of dynamic cast class) but that I will need to test the changes.", "author": "r30shah", "createdAt": "2020-05-27T19:53:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5MzUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxMzkyOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431413928", "bodyText": "@fjeremic What do you suggest? I believe to support runtime compressed refs, fix will need to LPQ/STPQ for 64 Bit platform and LG/STG for 31 Bit (In case of dynamic cast class) but that I will need to test the changes.\n\nI don't think you understood that correctly. The choice of whether the JVM will run in compressedrefs mode vs. full 64-bit pointers is changing to be dynamic at JVM startup, rather than having two separate JVMs to be able to do this. From the compiler perspective nothing changes on our end because the choice of compressedrefs vs. not is made at JVM initialization and it is never changed after that. The code is fine as is.\nThe only problem is use of that j9objectclass_t type which today has a different size on compressedrefs JVM vs. full 64-bit pointer JVM, but that will change as soon as we live in a world where those JVMs are one and the same. You need to ensure correct size of the snippet in this world, and it cannot rely on the sizeof(j9objectclass_t) at compile time. IMO just use uintptr_t or UDATA. You will end up allocating double the size when running in compressedrefs but who cares, it's just a stack object we temporarily use and feed into cg->CreateConstant.", "author": "fjeremic", "createdAt": "2020-05-27T20:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5MzUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxODc0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431418743", "bodyText": "The only problem is use of that j9objectclass_t type which today has a different size on compressedrefs JVM vs. full 64-bit pointer JVM, but that will change as soon as we live in a world where those JVMs are one and the same. You need to ensure correct size of the snippet in this world, and it cannot rely on the sizeof(j9objectclass_t) at compile time. IMO just use uintptr_t or UDATA. You will end up allocating double the size when running in compressedrefs but who cares, it's just a stack object we temporarily use and feed into cg->CreateConstant.\n\nOhh, Got that.  So current solution uses useCompressedPointers query to know if it is compressed refs or not. In last commit I have changed the j9objectclass_t to U_32 and update the second element with the update offset if header needs to be 8 bit, else updates first element.\nNothing changed in generated instructions.", "author": "r30shah", "createdAt": "2020-05-27T20:20:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5MzUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5NzA4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431297083", "bodyText": "This code is starting to become a mess by allocating these data snippets inline. This is outside the scope of this PR but I'd like to see these data snippets be implemented using a standalone documented snippet class eventually. Food for thought.", "author": "fjeremic", "createdAt": "2020-05-27T16:54:50Z", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6327,83 +6327,150 @@ static bool graDepsConflictWithInstanceOfDeps(TR::Node * depNode, TR::Node * nod\n  *     This function generates a sequence to check per site cache for object class and cast class before calling out to jitInstanceOf helper\n  */\n static\n-void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n+void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR::RegisterDependencyConditions *deps, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n    {\n    TR::Compilation                *comp = cg->comp();\n    bool needResult = resultReg != NULL;\n    if (!castClassReg)\n-      castClassReg = cg->evaluate(node->getSecondChild());\n+      castClassReg = cg->gprClobberEvaluate(node->getSecondChild());\n+\n    int32_t maxOnsiteCacheSlots = comp->getOptions()->getMaxOnsiteCacheSlotForInstanceOf();\n-   TR::Register *dynamicCacheReg = NULL;\n-   int32_t addressSize = TR::Compiler->om.sizeofReferenceAddress();\n+   int32_t fieldSize = TR::Compiler->om.sizeofReferenceField();\n+   bool isTarget64Bit = comp->target().is64Bit();\n+   bool isCompressedRef = comp->useCompressedPointers();\n    /* Layout of the writable data snippet\n     * Case - 1 : Cast class is runtime variable\n-    * [UpdateIndex][ObjClassSlot-0][CastClassSlot-0]...[ObjClassSlot-N][CastClassSlot-N]\n-    * Case - 2 : Cast Class is interface / unresolved\n-    * [UpdateIndex][ObjClassSlot-0]...[ObjClassSlot-N]\n+    *    Case - 1A: 64 Bit Compressedrefs / 31-Bit JVM\n+    *       -----------------------------------------------------------------------------------------\n+    *       |Header | ObjectClassSlot-0 | CastClassSlot-0 |...| ObjectClassSlot-N | CastClassSlot-N |\n+    *       -----------------------------------------------------------------------------------------\n+    *       0        8                   12                ... 8n                  8n+4\n+    *    Case - 1B: 64 Bit Non Compressedrefs\n+    *       -----------------------------------------------------------------------------------------\n+    *       |Header | ObjectClassSlot-0 | CastClassSlot-0 |...| ObjectClassSlot-N | CastClassSlot-N |\n+    *       -----------------------------------------------------------------------------------------\n+    *       0        16                  24                ... 16n                 16n+8\n+    * Case - 2 : Cast Class is resolved\n+    *    Case - 2A: 64 Bit Compressedrefs / 31-Bit JVM\n+    *       --------------------------------------------------------------------------\n+    *       | Header | ObjectClassSlot-0 | ObjectClassSlot-1 |...| ObjectClassSlot-N |\n+    *       --------------------------------------------------------------------------\n+    *       0         4                   8                   ... 4n\n+    *    Case - 2B: 64 Bit Non Compressedrefs\n+    *       --------------------------------------------------------------------------\n+    *       | Header | ObjectClassSlot-0 | ObjectClassSlot-1 |...| ObjectClassSlot-N |\n+    *       --------------------------------------------------------------------------\n+    *       0         8                   16                   ... 8n\n+    *\n     * If there is only one cache slot, we will not have header.\n     * Last bit of cached objectClass will set to 1 indicating false cast\n+    *\n+    * We can request the snippet size of power 2. Following Table summarizes bytes needed for corresponding number of cache slots.\n+    * \n+    * Following is the table for the number of bytes in snippet needed by each of the Cases mentioned above\n+    *\n+    * Number Of Slots | Case 1A | Case 1B | Case 2A | Case 2B |\n+    *       1         |    8    |   16    |    4    |    8    |\n+    *       2         |    16   |   64    |    16   |    32   |\n+    *       3         |    32   |   64    |    16   |    32   |\n+    *       4         |    64   |   128   |    32   |    64   |\n+    *       5         |    64   |   128   |    32   |    64   |\n+    *       6         |    64   |   128   |    32   |    64   |\n+    *\n     */\n-   int32_t snippetSizeInBytes = ((cacheCastClass ? 2 : 1) * maxOnsiteCacheSlots * addressSize) + (addressSize * (maxOnsiteCacheSlots != 1));\n+   \n+   int32_t snippetSizeInBytes = ((cacheCastClass ? 2 : 1) * maxOnsiteCacheSlots * fieldSize) + (fieldSize * (maxOnsiteCacheSlots != 1) * (cacheCastClass ? 2 : 1));\n+   TR::Register *dynamicCacheReg = NULL;\n+   \n    if (generateDynamicCache)\n       {\n       TR::S390WritableDataSnippet *dynamicCacheSnippet = NULL;\n-      /* We can only request the snippet size of power 2, following table summarizes bytes needed for corresponding number of cache slots\n-       * Case 1 : Cast class is runtime variable\n-       * Case 2 : Cast class is interface / unresolved\n-       * Number Of Slots |  Bytes needed for Case 1 | Bytes needed for Case 2\n-       *        1        |              16          |           8\n-       *        2        |              64          |           32\n-       *        3        |              64          |           32\n-       *        4        |              128         |           64\n-       *        5        |              128         |           64\n-       *        6        |              128         |           64\n-       */\n       int32_t requestedBytes = 1 << (int) (log2(snippetSizeInBytes-1)+1);\n-      traceMsg(comp, \"Requested Bytes = %d\\n\",requestedBytes);\n-      // NOTE: For single slot cache, we initialize snippet with addressSize (4/8) assuming which can not be objectClass\n-      // In all cases, we use first addressSize bytes to store offset of the circular buffer and rest of buffer will be initialized with 0xf.\n+      traceMsg(comp, \"Number Of Dynamic Cache Slots = %d, Caching CastClass: %s\\n\"\n+                     \"Bytes needed for Snippet = %d, requested Bytes = %d\\n\",maxOnsiteCacheSlots, cacheCastClass ? \"true\" : \"false\", snippetSizeInBytes, requestedBytes);\n+\n       TR_ASSERT_FATAL(maxOnsiteCacheSlots <= 7, \"Maximum 7 slots per site allowed because we use a fixed stack allocated buffer to construct the snippet\\n\");\n-      UDATA initialSnippet[16] = { static_cast<UDATA>(addressSize) };\n+      j9objectclass_t initialSnippet[16] = { 0 };\n+\n+      if (cacheCastClass)\n+         initialSnippet[isTarget64Bit && !isCompressedRef ? 0 : 1] = static_cast<j9objectclass_t>(fieldSize * 2);\n+      else\n+         initialSnippet[0] = static_cast<j9objectclass_t>(fieldSize);", "originalCommit": "3a4703eaf139c681caf30931dfc1308949d43e15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d93900d74563f5c215cc5b25dfcf7155c2df20a6", "url": "https://github.com/eclipse-openj9/openj9/commit/d93900d74563f5c215cc5b25dfcf7155c2df20a6", "message": "Set Code Cache alignment to 16 bits on IBM Z\n\nOn IBM Z platform, to support load and store quadword instruction from\nsnippet, snippet address should be aligned to quadword boundary. In JIT\ncompilation this works as when emitting snippet, we align the snippets\naccording to its size. But in AOT load, there was a possibility that it\nmess up with the alignment for start of snippet address. By setting the\ncode cache memory alignment to 16, we make sure, that in AOT load, the\nsnippet from where it is loading or storing, will be aligned.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-05-27T18:36:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0NTcyMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431445723", "bodyText": "This seems needlessly complicated. Why not just store the index at [0] always and use LLGF always to load and ST to store? Then all bytes from offset 4 until ObjectClassSlot-0 is just alignment bytes in all cases.", "author": "fjeremic", "createdAt": "2020-05-27T21:13:27Z", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6327,83 +6327,153 @@ static bool graDepsConflictWithInstanceOfDeps(TR::Node * depNode, TR::Node * nod\n  *     This function generates a sequence to check per site cache for object class and cast class before calling out to jitInstanceOf helper\n  */\n static\n-void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n+void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR::RegisterDependencyConditions *deps, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n    {\n    TR::Compilation                *comp = cg->comp();\n    bool needResult = resultReg != NULL;\n    if (!castClassReg)\n-      castClassReg = cg->evaluate(node->getSecondChild());\n+      castClassReg = cg->gprClobberEvaluate(node->getSecondChild());\n+\n    int32_t maxOnsiteCacheSlots = comp->getOptions()->getMaxOnsiteCacheSlotForInstanceOf();\n-   TR::Register *dynamicCacheReg = NULL;\n-   int32_t addressSize = TR::Compiler->om.sizeofReferenceAddress();\n+   int32_t sizeofJ9ClassFieldWithinReference = TR::Compiler->om.sizeofReferenceField();\n+   bool isTarget64Bit = comp->target().is64Bit();\n+   bool isCompressedRef = comp->useCompressedPointers();\n    /* Layout of the writable data snippet\n     * Case - 1 : Cast class is runtime variable\n-    * [UpdateIndex][ObjClassSlot-0][CastClassSlot-0]...[ObjClassSlot-N][CastClassSlot-N]\n-    * Case - 2 : Cast Class is interface / unresolved\n-    * [UpdateIndex][ObjClassSlot-0]...[ObjClassSlot-N]\n+    *    Case - 1A: 64 Bit Compressedrefs / 31-Bit JVM\n+    *       -----------------------------------------------------------------------------------------\n+    *       |Header | ObjectClassSlot-0 | CastClassSlot-0 |...| ObjectClassSlot-N | CastClassSlot-N |\n+    *       -----------------------------------------------------------------------------------------\n+    *       0        8                   12                ... 8n                  8n+4\n+    *    Case - 1B: 64 Bit Non Compressedrefs\n+    *       -----------------------------------------------------------------------------------------\n+    *       |Header | ObjectClassSlot-0 | CastClassSlot-0 |...| ObjectClassSlot-N | CastClassSlot-N |\n+    *       -----------------------------------------------------------------------------------------\n+    *       0        16                  24                ... 16n                 16n+8\n+    * Case - 2 : Cast Class is resolved\n+    *    Case - 2A: 64 Bit Compressedrefs / 31-Bit JVM\n+    *       --------------------------------------------------------------------------\n+    *       | Header | ObjectClassSlot-0 | ObjectClassSlot-1 |...| ObjectClassSlot-N |\n+    *       --------------------------------------------------------------------------\n+    *       0         4                   8                   ... 4n\n+    *    Case - 2B: 64 Bit Non Compressedrefs\n+    *       --------------------------------------------------------------------------\n+    *       | Header | ObjectClassSlot-0 | ObjectClassSlot-1 |...| ObjectClassSlot-N |\n+    *       --------------------------------------------------------------------------\n+    *       0         8                   16                   ... 8n\n+    *\n     * If there is only one cache slot, we will not have header.\n     * Last bit of cached objectClass will set to 1 indicating false cast\n+    *\n+    * We can request the snippet size of power 2. Following Table summarizes bytes needed for corresponding number of cache slots.\n+    * \n+    * Following is the table for the number of bytes in snippet needed by each of the Cases mentioned above\n+    *\n+    * Number Of Slots | Case 1A | Case 1B | Case 2A | Case 2B |\n+    *       1         |    8    |   16    |    4    |    8    |\n+    *       2         |    16   |   64    |    16   |    32   |\n+    *       3         |    32   |   64    |    16   |    32   |\n+    *       4         |    64   |   128   |    32   |    64   |\n+    *       5         |    64   |   128   |    32   |    64   |\n+    *       6         |    64   |   128   |    32   |    64   |\n+    *\n     */\n-   int32_t snippetSizeInBytes = ((cacheCastClass ? 2 : 1) * maxOnsiteCacheSlots * addressSize) + (addressSize * (maxOnsiteCacheSlots != 1));\n+   \n+   int32_t snippetSizeInBytes = ((cacheCastClass ? 2 : 1) * maxOnsiteCacheSlots * sizeofJ9ClassFieldWithinReference) + (sizeofJ9ClassFieldWithinReference * (maxOnsiteCacheSlots != 1) * (cacheCastClass ? 2 : 1));\n+   TR::Register *dynamicCacheReg = NULL;\n+   \n    if (generateDynamicCache)\n       {\n       TR::S390WritableDataSnippet *dynamicCacheSnippet = NULL;\n-      /* We can only request the snippet size of power 2, following table summarizes bytes needed for corresponding number of cache slots\n-       * Case 1 : Cast class is runtime variable\n-       * Case 2 : Cast class is interface / unresolved\n-       * Number Of Slots |  Bytes needed for Case 1 | Bytes needed for Case 2\n-       *        1        |              16          |           8\n-       *        2        |              64          |           32\n-       *        3        |              64          |           32\n-       *        4        |              128         |           64\n-       *        5        |              128         |           64\n-       *        6        |              128         |           64\n-       */\n       int32_t requestedBytes = 1 << (int) (log2(snippetSizeInBytes-1)+1);\n-      traceMsg(comp, \"Requested Bytes = %d\\n\",requestedBytes);\n-      // NOTE: For single slot cache, we initialize snippet with addressSize (4/8) assuming which can not be objectClass\n-      // In all cases, we use first addressSize bytes to store offset of the circular buffer and rest of buffer will be initialized with 0xf.\n+      if (comp->getOption(TR_TraceCG))\n+         {\n+         traceMsg(comp, \"Number Of Dynamic Cache Slots = %d, Caching CastClass: %s\\n\"\n+                        \"Bytes needed for Snippet = %d, requested Bytes = %d\\n\",maxOnsiteCacheSlots, cacheCastClass ? \"true\" : \"false\", snippetSizeInBytes, requestedBytes);\n+         }\n+\n       TR_ASSERT_FATAL(maxOnsiteCacheSlots <= 7, \"Maximum 7 slots per site allowed because we use a fixed stack allocated buffer to construct the snippet\\n\");\n-      UDATA initialSnippet[16] = { static_cast<UDATA>(addressSize) };\n+      U_32 initialSnippet[32] = { 0 };\n+\n+      if (cacheCastClass)\n+         initialSnippet[1] = static_cast<U_32>(sizeofJ9ClassFieldWithinReference * 2);\n+      else\n+         initialSnippet[isTarget64Bit && !isCompressedRef ? 1 : 0] = static_cast<U_32>(sizeofJ9ClassFieldWithinReference);\n+", "originalCommit": "eacc941c50cd958900914c934e54ebeeac8a0e6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3MjU4OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431572589", "bodyText": "Thanks a lot for the suggestion, made changes in https://github.com/eclipse/openj9/compare/eacc941c50cd958900914c934e54ebeeac8a0e6a..a2430d97387cbde73cf795f75a6d84927a67ee15", "author": "r30shah", "createdAt": "2020-05-28T04:19:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0NTcyMw=="}], "type": "inlineReview"}, {"oid": "2cdc5948b514751443da1fc93d1dc78f686b3c81", "url": "https://github.com/eclipse-openj9/openj9/commit/2cdc5948b514751443da1fc93d1dc78f686b3c81", "message": "Fix instanceOf's dynamicCache sequence on IBM Z\n\nOn IBM Z, for instanceOf node, we have a codegen optimization which\ncaches the encountered classes for which it failed all the inline tests\nand has to call JIT helper to get the result. This cache is first\ntested to avoid a call to JIT helper. There was a bug in case we have to\ncache class of child when cast class child of the node is runtime\nvariable. We were loading and storing associated fields using two load\nand store instructions. This causes a potential data race condition\nwhich was exploited by highly parallel application where more than 500\nthreads were running same method and all were trying to update the\ncache, leaving with the classes in the cache which were not related and\nin the code it can later cause an incorrect result for instanceof.\n\nFixes: #9457\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-05-28T04:17:19Z", "type": "commit"}, {"oid": "a2430d97387cbde73cf795f75a6d84927a67ee15", "url": "https://github.com/eclipse-openj9/openj9/commit/a2430d97387cbde73cf795f75a6d84927a67ee15", "message": "Set Code Cache alignment to 16 bits on IBM Z\n\nOn IBM Z platform, to support load and store quadword instruction from\nsnippet, snippet address should be aligned to quadword boundary. In JIT\ncompilation this works as when emitting snippet, we align the snippets\naccording to its size. But in AOT load, there was a possibility that it\nmess up with the alignment for start of snippet address. By setting the\ncode cache memory alignment to 16, we make sure, that in AOT load, the\nsnippet from where it is loading or storing, will be aligned.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-05-28T04:17:42Z", "type": "commit"}, {"oid": "a2430d97387cbde73cf795f75a6d84927a67ee15", "url": "https://github.com/eclipse-openj9/openj9/commit/a2430d97387cbde73cf795f75a6d84927a67ee15", "message": "Set Code Cache alignment to 16 bits on IBM Z\n\nOn IBM Z platform, to support load and store quadword instruction from\nsnippet, snippet address should be aligned to quadword boundary. In JIT\ncompilation this works as when emitting snippet, we align the snippets\naccording to its size. But in AOT load, there was a possibility that it\nmess up with the alignment for start of snippet address. By setting the\ncode cache memory alignment to 16, we make sure, that in AOT load, the\nsnippet from where it is loading or storing, will be aligned.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-05-28T04:17:42Z", "type": "forcePushed"}]}