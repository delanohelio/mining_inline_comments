{"pr_number": 10124, "pr_title": "Add Dynamic Breadth First Scan Ordering to GC", "pr_createdAt": "2020-07-08T20:05:26Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10124", "timeline": [{"oid": "2f9845022f2b6376da38c9b3ad840b0d5055dd03", "url": "https://github.com/eclipse-openj9/openj9/commit/2f9845022f2b6376da38c9b3ad840b0d5055dd03", "message": "Modify Dynamic BF Scan Ordering to use new JIT Hot Field Marking\n\nModify GC Dynamic Breadth First Scan Ordering to use the\nnewly implemented JIT Hot Field Hot Marking Pass.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>", "committedDate": "2020-07-08T20:15:50Z", "type": "forcePushed"}, {"oid": "52a47ed47e7f267126c8b2f43e8d79d570d121f8", "url": "https://github.com/eclipse-openj9/openj9/commit/52a47ed47e7f267126c8b2f43e8d79d570d121f8", "message": "Modify Dynamic BF Scan Ordering to use new JIT Hot Field Marking\n\nModify GC Dynamic Breadth First Scan Ordering to use the\nnewly implemented JIT Hot Field Hot Marking Pass.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>", "committedDate": "2020-07-08T20:40:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk4OTExMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r455989110", "bodyText": "can we get these so they can be overridden by environment variables", "author": "andrewcraik", "createdAt": "2020-07-16T18:29:48Z", "path": "runtime/compiler/optimizer/HotFieldMarking.cpp", "diffHunk": "@@ -0,0 +1,173 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"optimizer/HotFieldMarking.hpp\"\n+#include \"env/j9method.h\"\n+#include \"il/Block.hpp\"\n+#include \"il/Node.hpp\"\n+#include \"il/Node_inlines.hpp\"\n+#include \"il/SymbolReference.hpp\"\n+#include \"il/TreeTop.hpp\"\n+#include \"infra/ILWalk.hpp\"\n+#include \"optimizer/Optimizer.hpp\"\n+#include \"optimizer/Optimization.hpp\"\n+#include \"optimizer/Optimization_inlines.hpp\"\n+#include \"optimizer/OptimizationManager.hpp\"\n+\n+#include <map>\n+\n+struct SymStats\n+   {\n+   int32_t _count;\n+   int32_t _score;\n+   int32_t _fieldNameLength;\n+   char* _fieldName;\n+   int32_t _fieldSigLength;\n+   char* _fieldSig;\n+   TR_OpaqueClassBlock *_clazz;\n+   SymStats(int32_t count, int32_t score, int32_t fieldNameLength, char* fieldName, int32_t fieldSigLength, char* fieldSig, TR_OpaqueClassBlock *clazz) :\n+      _count(count), _score(score), _fieldNameLength(fieldNameLength), _fieldName(fieldName), _fieldSigLength(fieldSigLength), _fieldSig(fieldSig), _clazz(clazz) {}\n+   };\n+\n+typedef TR::typed_allocator<std::pair<TR::Symbol *, SymStats *>, TR::Region&> SymAggMapAllocator;\n+typedef std::less<TR::Symbol *> SymAggMapComparator;\n+typedef std::map<TR::Symbol *, SymStats *, SymAggMapComparator, SymAggMapAllocator> SymAggMap;\n+\n+static int32_t getReducedFrequencySum(int32_t currentValue, int32_t newFrequency)\n+   {\n+   return (currentValue + newFrequency);\n+   }\n+\n+static int32_t getReducedFrequencyAverage(int32_t currentValue, int32_t count, int32_t newFrequency)\n+   {\n+   return ((currentValue * count) + newFrequency) / (count + 1);\n+   }\n+\n+int32_t TR_HotFieldMarking::perform()\n+   {\n+   if (!jitConfig->javaVM->memoryManagerFunctions->j9gc_hot_reference_field_required(jitConfig->javaVM))\n+      {\n+      if (trace())\n+         traceMsg(comp(), \"Skipping hot field marking since dynamic breadth first scan ordering is disabled\\n\");\n+      return 0;\n+      }\n+\n+   SymAggMap stats(SymAggMapComparator(), comp()->trMemory()->currentStackRegion());\n+   TR::Block *block = NULL;\n+   for (TR::PostorderNodeIterator it(comp()->getStartTree(), comp()); it != NULL; ++it)\n+      {\n+      TR::Node * const node = it.currentNode();\n+      if (node->getOpCodeValue() == TR::BBStart)\n+         {\n+         block = node->getBlock();\n+         }\n+      else if ((node->getOpCode().isLoadIndirect() || node->getOpCode().isStoreIndirect())\n+               && node->getOpCode().hasSymbolReference()\n+               && !node->getSymbolReference()->isUnresolved()\n+               && node->getSymbolReference()->getSymbol()->isShadow()\n+               && !node->isInternalPointer()\n+               && !node->getOpCode().isArrayLength()\n+               && node->getSymbolReference()->getSymbol()->isCollectedReference()\n+              )\n+         {\n+         TR::SymbolReference *symRef = node->getSymbolReference();\n+         if (symRef->getCPIndex() >= 0 && !symRef->getSymbol()->isArrayShadowSymbol())\n+            {\n+            auto itr = stats.find(symRef->getSymbol());\n+            if (itr != stats.end())\n+               {\n+               if(TR::Options::getReductionAlgorithm(TR_HotFieldReductionAlgorithmSum))\n+                  {\n+                  itr->second->_score = getReducedFrequencySum(itr->second->_score, block->getFrequency());\n+                  } \n+               else\n+                  {\n+                  itr->second->_score = getReducedFrequencyAverage(itr->second->_score, itr->second->_count, block->getFrequency());\n+                  itr->second->_count += 1;\n+                  }\n+               continue;\n+               }\n+\n+            TR::ResolvedMethodSymbol *rms = comp()->getOwningMethodSymbol(symRef->getOwningMethodIndex());\n+            TR_ResolvedMethod *method = rms->getResolvedMethod();\n+\n+            int32_t fieldNameLength = 0;\n+            char *fieldName = method->fieldNameChars(symRef->getCPIndex(), fieldNameLength);\n+            int32_t fieldSigLength = 0;\n+            char *fieldSig = method->fieldSignatureChars(symRef->getCPIndex(), fieldSigLength);\n+            bool isStatic = false;\n+            TR_OpaqueClassBlock *containingClass = static_cast<TR_ResolvedJ9Method*>(method)->definingClassFromCPFieldRef(comp(), symRef->getCPIndex(), isStatic);\n+            if (isStatic)\n+               continue;\n+\n+            stats[symRef->getSymbol()] = new (trStackMemory()) SymStats(1, block->getFrequency(), fieldNameLength, fieldName, fieldSigLength, fieldSig, containingClass);\n+            }\n+         }\n+      }\n+\n+   for (auto itr = stats.begin(), end = stats.end(); itr != end; ++itr)\n+      {\n+      if (itr->second->_score >= TR::Options::_hotFieldThreshold)\n+         {\n+         int32_t fieldOffset = (comp()->fej9()->getInstanceFieldOffset(itr->second->_clazz, itr->second->_fieldName, itr->second->_fieldNameLength, itr->second->_fieldSig, itr->second->_fieldSigLength) + TR::Compiler->om.objectHeaderSizeInBytes()) / TR::Compiler->om.sizeofReferenceField();\n+            \n+         if (!comp()->fej9()->isAnonymousClass(itr->second->_clazz))\n+            {\n+            comp()->fej9()->reportHotField(getUtilization(), TR::Compiler->cls.convertClassOffsetToClassPtr(itr->second->_clazz), fieldOffset, itr->second->_score);\n+            \n+            if (comp()->getOption(TR_TraceMarkingOfHotFields))\n+               {\n+               int32_t classNameLength = 0;\n+               char *className = comp()->fej9()->getClassNameChars(itr->second->_clazz, classNameLength);\n+               //dumpOptDetails(comp(), \"HFM: %s notifying hot field %.*s%.*s.%.*s = %d\\n\", itr->second->_fieldSigLength, itr->second->_fieldSig, classNameLength, className, itr->second->_fieldNameLength, itr->second->_fieldName, itr->second->_score);           \n+               printf(\"HFM: signature: %.*s; class:%.*s; fieldName: %.*s; frequencyScore = %d; fieldOffset1: %d; \\n\", J9UTF8_LENGTH(itr->second->_fieldSig), J9UTF8_DATA(itr->second->_fieldSig), J9UTF8_LENGTH(className), J9UTF8_DATA(className), J9UTF8_LENGTH(itr->second->_fieldName), J9UTF8_DATA(itr->second->_fieldName), itr->second->_score, fieldOffset);\n+               }\n+            } \n+         }\n+      }\n+   return 1;\n+   }\n+\n+int32_t TR_HotFieldMarking::getUtilization()\n+   {\n+   switch (comp()->getMethodHotness())\n+      {\n+      case noOpt:\n+      case cold:\n+      case warm:\n+         return 1;", "originalCommit": "52a47ed47e7f267126c8b2f43e8d79d570d121f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA1NjYzMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r456056630", "bodyText": "Yes, would you mean to have these values (1, 10, 100) able\u00a0to be overridden via command line?", "author": "jonoommen", "createdAt": "2020-07-16T20:25:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk4OTExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5MzcwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r458793706", "bodyText": "@andrewcraik", "author": "jonoommen", "createdAt": "2020-07-22T13:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk4OTExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxMjcwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r458812707", "bodyText": "so use feGetEnv to read environment variables for each of the return values and if the env var is set then return the value from the env var otherwise use the default. Note the env var should be read only once (convention in JIT code is a static local variable) to reduce the compile time overhead of always re-reading an unchanging env var.", "author": "andrewcraik", "createdAt": "2020-07-22T13:58:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk4OTExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxMzIyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r458813226", "bodyText": "This means that these don't get an -Xjit option, but you can a variable like TR_hotFieldMarkingUtilizationWarmAndBelow=5 for example.", "author": "andrewcraik", "createdAt": "2020-07-22T13:58:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk4OTExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk5ODQyOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r455998428", "bodyText": "there shouldn't be any printf's in the JIT code, please use the tracing framework", "author": "andrewcraik", "createdAt": "2020-07-16T18:46:35Z", "path": "runtime/compiler/optimizer/HotFieldMarking.cpp", "diffHunk": "@@ -0,0 +1,173 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"optimizer/HotFieldMarking.hpp\"\n+#include \"env/j9method.h\"\n+#include \"il/Block.hpp\"\n+#include \"il/Node.hpp\"\n+#include \"il/Node_inlines.hpp\"\n+#include \"il/SymbolReference.hpp\"\n+#include \"il/TreeTop.hpp\"\n+#include \"infra/ILWalk.hpp\"\n+#include \"optimizer/Optimizer.hpp\"\n+#include \"optimizer/Optimization.hpp\"\n+#include \"optimizer/Optimization_inlines.hpp\"\n+#include \"optimizer/OptimizationManager.hpp\"\n+\n+#include <map>\n+\n+struct SymStats\n+   {\n+   int32_t _count;\n+   int32_t _score;\n+   int32_t _fieldNameLength;\n+   char* _fieldName;\n+   int32_t _fieldSigLength;\n+   char* _fieldSig;\n+   TR_OpaqueClassBlock *_clazz;\n+   SymStats(int32_t count, int32_t score, int32_t fieldNameLength, char* fieldName, int32_t fieldSigLength, char* fieldSig, TR_OpaqueClassBlock *clazz) :\n+      _count(count), _score(score), _fieldNameLength(fieldNameLength), _fieldName(fieldName), _fieldSigLength(fieldSigLength), _fieldSig(fieldSig), _clazz(clazz) {}\n+   };\n+\n+typedef TR::typed_allocator<std::pair<TR::Symbol *, SymStats *>, TR::Region&> SymAggMapAllocator;\n+typedef std::less<TR::Symbol *> SymAggMapComparator;\n+typedef std::map<TR::Symbol *, SymStats *, SymAggMapComparator, SymAggMapAllocator> SymAggMap;\n+\n+static int32_t getReducedFrequencySum(int32_t currentValue, int32_t newFrequency)\n+   {\n+   return (currentValue + newFrequency);\n+   }\n+\n+static int32_t getReducedFrequencyAverage(int32_t currentValue, int32_t count, int32_t newFrequency)\n+   {\n+   return ((currentValue * count) + newFrequency) / (count + 1);\n+   }\n+\n+int32_t TR_HotFieldMarking::perform()\n+   {\n+   if (!jitConfig->javaVM->memoryManagerFunctions->j9gc_hot_reference_field_required(jitConfig->javaVM))\n+      {\n+      if (trace())\n+         traceMsg(comp(), \"Skipping hot field marking since dynamic breadth first scan ordering is disabled\\n\");\n+      return 0;\n+      }\n+\n+   SymAggMap stats(SymAggMapComparator(), comp()->trMemory()->currentStackRegion());\n+   TR::Block *block = NULL;\n+   for (TR::PostorderNodeIterator it(comp()->getStartTree(), comp()); it != NULL; ++it)\n+      {\n+      TR::Node * const node = it.currentNode();\n+      if (node->getOpCodeValue() == TR::BBStart)\n+         {\n+         block = node->getBlock();\n+         }\n+      else if ((node->getOpCode().isLoadIndirect() || node->getOpCode().isStoreIndirect())\n+               && node->getOpCode().hasSymbolReference()\n+               && !node->getSymbolReference()->isUnresolved()\n+               && node->getSymbolReference()->getSymbol()->isShadow()\n+               && !node->isInternalPointer()\n+               && !node->getOpCode().isArrayLength()\n+               && node->getSymbolReference()->getSymbol()->isCollectedReference()\n+              )\n+         {\n+         TR::SymbolReference *symRef = node->getSymbolReference();\n+         if (symRef->getCPIndex() >= 0 && !symRef->getSymbol()->isArrayShadowSymbol())\n+            {\n+            auto itr = stats.find(symRef->getSymbol());\n+            if (itr != stats.end())\n+               {\n+               if(TR::Options::getReductionAlgorithm(TR_HotFieldReductionAlgorithmSum))\n+                  {\n+                  itr->second->_score = getReducedFrequencySum(itr->second->_score, block->getFrequency());\n+                  } \n+               else\n+                  {\n+                  itr->second->_score = getReducedFrequencyAverage(itr->second->_score, itr->second->_count, block->getFrequency());\n+                  itr->second->_count += 1;\n+                  }\n+               continue;\n+               }\n+\n+            TR::ResolvedMethodSymbol *rms = comp()->getOwningMethodSymbol(symRef->getOwningMethodIndex());\n+            TR_ResolvedMethod *method = rms->getResolvedMethod();\n+\n+            int32_t fieldNameLength = 0;\n+            char *fieldName = method->fieldNameChars(symRef->getCPIndex(), fieldNameLength);\n+            int32_t fieldSigLength = 0;\n+            char *fieldSig = method->fieldSignatureChars(symRef->getCPIndex(), fieldSigLength);\n+            bool isStatic = false;\n+            TR_OpaqueClassBlock *containingClass = static_cast<TR_ResolvedJ9Method*>(method)->definingClassFromCPFieldRef(comp(), symRef->getCPIndex(), isStatic);\n+            if (isStatic)\n+               continue;\n+\n+            stats[symRef->getSymbol()] = new (trStackMemory()) SymStats(1, block->getFrequency(), fieldNameLength, fieldName, fieldSigLength, fieldSig, containingClass);\n+            }\n+         }\n+      }\n+\n+   for (auto itr = stats.begin(), end = stats.end(); itr != end; ++itr)\n+      {\n+      if (itr->second->_score >= TR::Options::_hotFieldThreshold)\n+         {\n+         int32_t fieldOffset = (comp()->fej9()->getInstanceFieldOffset(itr->second->_clazz, itr->second->_fieldName, itr->second->_fieldNameLength, itr->second->_fieldSig, itr->second->_fieldSigLength) + TR::Compiler->om.objectHeaderSizeInBytes()) / TR::Compiler->om.sizeofReferenceField();\n+            \n+         if (!comp()->fej9()->isAnonymousClass(itr->second->_clazz))\n+            {\n+            comp()->fej9()->reportHotField(getUtilization(), TR::Compiler->cls.convertClassOffsetToClassPtr(itr->second->_clazz), fieldOffset, itr->second->_score);\n+            \n+            if (comp()->getOption(TR_TraceMarkingOfHotFields))\n+               {\n+               int32_t classNameLength = 0;\n+               char *className = comp()->fej9()->getClassNameChars(itr->second->_clazz, classNameLength);\n+               //dumpOptDetails(comp(), \"HFM: %s notifying hot field %.*s%.*s.%.*s = %d\\n\", itr->second->_fieldSigLength, itr->second->_fieldSig, classNameLength, className, itr->second->_fieldNameLength, itr->second->_fieldName, itr->second->_score);           \n+               printf(\"HFM: signature: %.*s; class:%.*s; fieldName: %.*s; frequencyScore = %d; fieldOffset1: %d; \\n\", J9UTF8_LENGTH(itr->second->_fieldSig), J9UTF8_DATA(itr->second->_fieldSig), J9UTF8_LENGTH(className), J9UTF8_DATA(className), J9UTF8_LENGTH(itr->second->_fieldName), J9UTF8_DATA(itr->second->_fieldName), itr->second->_score, fieldOffset);", "originalCommit": "52a47ed47e7f267126c8b2f43e8d79d570d121f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA1ODQzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r456058431", "bodyText": "Ok, is the commented \"dumpOptDetails\" above the printf sufficient or should I just change the printf to use the traceMsg framework? @andrewcraik", "author": "jonoommen", "createdAt": "2020-07-16T20:29:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk5ODQyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxMTk3Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r458811972", "bodyText": "because this is a block of trace guarded code you should use traceMsg - dumpOptDetails is used when the compiler is performing a transformation that is not optional - this is just tracing code.\nEach opt gets its own trace option which you can test for enabled with trace(). Unless there is a reason for a different flag the code should use trace()", "author": "andrewcraik", "createdAt": "2020-07-22T13:57:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk5ODQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk5OTIxNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r455999215", "bodyText": "usually the side-effects of an opt pass are guarded by performTransformation calls facilitates binary searching of problematic optimizations - we might want to consider that here to allow for filtering of the field data being reported.", "author": "andrewcraik", "createdAt": "2020-07-16T18:48:02Z", "path": "runtime/compiler/optimizer/HotFieldMarking.cpp", "diffHunk": "@@ -0,0 +1,173 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"optimizer/HotFieldMarking.hpp\"\n+#include \"env/j9method.h\"\n+#include \"il/Block.hpp\"\n+#include \"il/Node.hpp\"\n+#include \"il/Node_inlines.hpp\"\n+#include \"il/SymbolReference.hpp\"\n+#include \"il/TreeTop.hpp\"\n+#include \"infra/ILWalk.hpp\"\n+#include \"optimizer/Optimizer.hpp\"\n+#include \"optimizer/Optimization.hpp\"\n+#include \"optimizer/Optimization_inlines.hpp\"\n+#include \"optimizer/OptimizationManager.hpp\"\n+\n+#include <map>\n+\n+struct SymStats\n+   {\n+   int32_t _count;\n+   int32_t _score;\n+   int32_t _fieldNameLength;\n+   char* _fieldName;\n+   int32_t _fieldSigLength;\n+   char* _fieldSig;\n+   TR_OpaqueClassBlock *_clazz;\n+   SymStats(int32_t count, int32_t score, int32_t fieldNameLength, char* fieldName, int32_t fieldSigLength, char* fieldSig, TR_OpaqueClassBlock *clazz) :\n+      _count(count), _score(score), _fieldNameLength(fieldNameLength), _fieldName(fieldName), _fieldSigLength(fieldSigLength), _fieldSig(fieldSig), _clazz(clazz) {}\n+   };\n+\n+typedef TR::typed_allocator<std::pair<TR::Symbol *, SymStats *>, TR::Region&> SymAggMapAllocator;\n+typedef std::less<TR::Symbol *> SymAggMapComparator;\n+typedef std::map<TR::Symbol *, SymStats *, SymAggMapComparator, SymAggMapAllocator> SymAggMap;\n+\n+static int32_t getReducedFrequencySum(int32_t currentValue, int32_t newFrequency)\n+   {\n+   return (currentValue + newFrequency);\n+   }\n+\n+static int32_t getReducedFrequencyAverage(int32_t currentValue, int32_t count, int32_t newFrequency)\n+   {\n+   return ((currentValue * count) + newFrequency) / (count + 1);\n+   }\n+\n+int32_t TR_HotFieldMarking::perform()\n+   {\n+   if (!jitConfig->javaVM->memoryManagerFunctions->j9gc_hot_reference_field_required(jitConfig->javaVM))\n+      {\n+      if (trace())\n+         traceMsg(comp(), \"Skipping hot field marking since dynamic breadth first scan ordering is disabled\\n\");\n+      return 0;\n+      }\n+\n+   SymAggMap stats(SymAggMapComparator(), comp()->trMemory()->currentStackRegion());\n+   TR::Block *block = NULL;\n+   for (TR::PostorderNodeIterator it(comp()->getStartTree(), comp()); it != NULL; ++it)\n+      {\n+      TR::Node * const node = it.currentNode();\n+      if (node->getOpCodeValue() == TR::BBStart)\n+         {\n+         block = node->getBlock();\n+         }\n+      else if ((node->getOpCode().isLoadIndirect() || node->getOpCode().isStoreIndirect())\n+               && node->getOpCode().hasSymbolReference()\n+               && !node->getSymbolReference()->isUnresolved()\n+               && node->getSymbolReference()->getSymbol()->isShadow()\n+               && !node->isInternalPointer()\n+               && !node->getOpCode().isArrayLength()\n+               && node->getSymbolReference()->getSymbol()->isCollectedReference()\n+              )\n+         {\n+         TR::SymbolReference *symRef = node->getSymbolReference();\n+         if (symRef->getCPIndex() >= 0 && !symRef->getSymbol()->isArrayShadowSymbol())\n+            {\n+            auto itr = stats.find(symRef->getSymbol());\n+            if (itr != stats.end())\n+               {\n+               if(TR::Options::getReductionAlgorithm(TR_HotFieldReductionAlgorithmSum))\n+                  {\n+                  itr->second->_score = getReducedFrequencySum(itr->second->_score, block->getFrequency());\n+                  } \n+               else\n+                  {\n+                  itr->second->_score = getReducedFrequencyAverage(itr->second->_score, itr->second->_count, block->getFrequency());\n+                  itr->second->_count += 1;\n+                  }\n+               continue;\n+               }\n+\n+            TR::ResolvedMethodSymbol *rms = comp()->getOwningMethodSymbol(symRef->getOwningMethodIndex());\n+            TR_ResolvedMethod *method = rms->getResolvedMethod();\n+\n+            int32_t fieldNameLength = 0;\n+            char *fieldName = method->fieldNameChars(symRef->getCPIndex(), fieldNameLength);\n+            int32_t fieldSigLength = 0;\n+            char *fieldSig = method->fieldSignatureChars(symRef->getCPIndex(), fieldSigLength);\n+            bool isStatic = false;\n+            TR_OpaqueClassBlock *containingClass = static_cast<TR_ResolvedJ9Method*>(method)->definingClassFromCPFieldRef(comp(), symRef->getCPIndex(), isStatic);\n+            if (isStatic)\n+               continue;\n+\n+            stats[symRef->getSymbol()] = new (trStackMemory()) SymStats(1, block->getFrequency(), fieldNameLength, fieldName, fieldSigLength, fieldSig, containingClass);\n+            }\n+         }\n+      }\n+\n+   for (auto itr = stats.begin(), end = stats.end(); itr != end; ++itr)\n+      {\n+      if (itr->second->_score >= TR::Options::_hotFieldThreshold)\n+         {\n+         int32_t fieldOffset = (comp()->fej9()->getInstanceFieldOffset(itr->second->_clazz, itr->second->_fieldName, itr->second->_fieldNameLength, itr->second->_fieldSig, itr->second->_fieldSigLength) + TR::Compiler->om.objectHeaderSizeInBytes()) / TR::Compiler->om.sizeofReferenceField();\n+            \n+         if (!comp()->fej9()->isAnonymousClass(itr->second->_clazz))\n+            {\n+            comp()->fej9()->reportHotField(getUtilization(), TR::Compiler->cls.convertClassOffsetToClassPtr(itr->second->_clazz), fieldOffset, itr->second->_score);", "originalCommit": "52a47ed47e7f267126c8b2f43e8d79d570d121f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwMDA4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r456000083", "bodyText": "this code needs more tracing about the fields being processed and the values of the stats after each field is processed to facilitate debugging in the future.", "author": "andrewcraik", "createdAt": "2020-07-16T18:49:42Z", "path": "runtime/compiler/optimizer/HotFieldMarking.cpp", "diffHunk": "@@ -0,0 +1,173 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"optimizer/HotFieldMarking.hpp\"\n+#include \"env/j9method.h\"\n+#include \"il/Block.hpp\"\n+#include \"il/Node.hpp\"\n+#include \"il/Node_inlines.hpp\"\n+#include \"il/SymbolReference.hpp\"\n+#include \"il/TreeTop.hpp\"\n+#include \"infra/ILWalk.hpp\"\n+#include \"optimizer/Optimizer.hpp\"\n+#include \"optimizer/Optimization.hpp\"\n+#include \"optimizer/Optimization_inlines.hpp\"\n+#include \"optimizer/OptimizationManager.hpp\"\n+\n+#include <map>\n+\n+struct SymStats\n+   {\n+   int32_t _count;\n+   int32_t _score;\n+   int32_t _fieldNameLength;\n+   char* _fieldName;\n+   int32_t _fieldSigLength;\n+   char* _fieldSig;\n+   TR_OpaqueClassBlock *_clazz;\n+   SymStats(int32_t count, int32_t score, int32_t fieldNameLength, char* fieldName, int32_t fieldSigLength, char* fieldSig, TR_OpaqueClassBlock *clazz) :\n+      _count(count), _score(score), _fieldNameLength(fieldNameLength), _fieldName(fieldName), _fieldSigLength(fieldSigLength), _fieldSig(fieldSig), _clazz(clazz) {}\n+   };\n+\n+typedef TR::typed_allocator<std::pair<TR::Symbol *, SymStats *>, TR::Region&> SymAggMapAllocator;\n+typedef std::less<TR::Symbol *> SymAggMapComparator;\n+typedef std::map<TR::Symbol *, SymStats *, SymAggMapComparator, SymAggMapAllocator> SymAggMap;\n+\n+static int32_t getReducedFrequencySum(int32_t currentValue, int32_t newFrequency)\n+   {\n+   return (currentValue + newFrequency);\n+   }\n+\n+static int32_t getReducedFrequencyAverage(int32_t currentValue, int32_t count, int32_t newFrequency)\n+   {\n+   return ((currentValue * count) + newFrequency) / (count + 1);\n+   }\n+\n+int32_t TR_HotFieldMarking::perform()\n+   {\n+   if (!jitConfig->javaVM->memoryManagerFunctions->j9gc_hot_reference_field_required(jitConfig->javaVM))\n+      {\n+      if (trace())\n+         traceMsg(comp(), \"Skipping hot field marking since dynamic breadth first scan ordering is disabled\\n\");\n+      return 0;\n+      }\n+\n+   SymAggMap stats(SymAggMapComparator(), comp()->trMemory()->currentStackRegion());\n+   TR::Block *block = NULL;\n+   for (TR::PostorderNodeIterator it(comp()->getStartTree(), comp()); it != NULL; ++it)\n+      {\n+      TR::Node * const node = it.currentNode();\n+      if (node->getOpCodeValue() == TR::BBStart)\n+         {\n+         block = node->getBlock();\n+         }\n+      else if ((node->getOpCode().isLoadIndirect() || node->getOpCode().isStoreIndirect())\n+               && node->getOpCode().hasSymbolReference()\n+               && !node->getSymbolReference()->isUnresolved()\n+               && node->getSymbolReference()->getSymbol()->isShadow()\n+               && !node->isInternalPointer()\n+               && !node->getOpCode().isArrayLength()\n+               && node->getSymbolReference()->getSymbol()->isCollectedReference()\n+              )\n+         {\n+         TR::SymbolReference *symRef = node->getSymbolReference();\n+         if (symRef->getCPIndex() >= 0 && !symRef->getSymbol()->isArrayShadowSymbol())\n+            {\n+            auto itr = stats.find(symRef->getSymbol());\n+            if (itr != stats.end())\n+               {\n+               if(TR::Options::getReductionAlgorithm(TR_HotFieldReductionAlgorithmSum))\n+                  {\n+                  itr->second->_score = getReducedFrequencySum(itr->second->_score, block->getFrequency());\n+                  } \n+               else\n+                  {\n+                  itr->second->_score = getReducedFrequencyAverage(itr->second->_score, itr->second->_count, block->getFrequency());\n+                  itr->second->_count += 1;\n+                  }\n+               continue;\n+               }\n+\n+            TR::ResolvedMethodSymbol *rms = comp()->getOwningMethodSymbol(symRef->getOwningMethodIndex());\n+            TR_ResolvedMethod *method = rms->getResolvedMethod();\n+\n+            int32_t fieldNameLength = 0;\n+            char *fieldName = method->fieldNameChars(symRef->getCPIndex(), fieldNameLength);\n+            int32_t fieldSigLength = 0;\n+            char *fieldSig = method->fieldSignatureChars(symRef->getCPIndex(), fieldSigLength);\n+            bool isStatic = false;\n+            TR_OpaqueClassBlock *containingClass = static_cast<TR_ResolvedJ9Method*>(method)->definingClassFromCPFieldRef(comp(), symRef->getCPIndex(), isStatic);\n+            if (isStatic)\n+               continue;", "originalCommit": "52a47ed47e7f267126c8b2f43e8d79d570d121f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAxNzQ4Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r456017487", "bodyText": "does this if need to be here? would it make more sense just to have the reductions all having the same signature and being static functions in the file so we could just assign a function pointer to point to one of the methods based on the configured algorithm? might make it easier to add other algorithms in the future or to even have the GC pass the reduction function in if it isn't embedded in the opt code directly...", "author": "andrewcraik", "createdAt": "2020-07-16T19:21:20Z", "path": "runtime/compiler/optimizer/HotFieldMarking.cpp", "diffHunk": "@@ -0,0 +1,173 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"optimizer/HotFieldMarking.hpp\"\n+#include \"env/j9method.h\"\n+#include \"il/Block.hpp\"\n+#include \"il/Node.hpp\"\n+#include \"il/Node_inlines.hpp\"\n+#include \"il/SymbolReference.hpp\"\n+#include \"il/TreeTop.hpp\"\n+#include \"infra/ILWalk.hpp\"\n+#include \"optimizer/Optimizer.hpp\"\n+#include \"optimizer/Optimization.hpp\"\n+#include \"optimizer/Optimization_inlines.hpp\"\n+#include \"optimizer/OptimizationManager.hpp\"\n+\n+#include <map>\n+\n+struct SymStats\n+   {\n+   int32_t _count;\n+   int32_t _score;\n+   int32_t _fieldNameLength;\n+   char* _fieldName;\n+   int32_t _fieldSigLength;\n+   char* _fieldSig;\n+   TR_OpaqueClassBlock *_clazz;\n+   SymStats(int32_t count, int32_t score, int32_t fieldNameLength, char* fieldName, int32_t fieldSigLength, char* fieldSig, TR_OpaqueClassBlock *clazz) :\n+      _count(count), _score(score), _fieldNameLength(fieldNameLength), _fieldName(fieldName), _fieldSigLength(fieldSigLength), _fieldSig(fieldSig), _clazz(clazz) {}\n+   };\n+\n+typedef TR::typed_allocator<std::pair<TR::Symbol *, SymStats *>, TR::Region&> SymAggMapAllocator;\n+typedef std::less<TR::Symbol *> SymAggMapComparator;\n+typedef std::map<TR::Symbol *, SymStats *, SymAggMapComparator, SymAggMapAllocator> SymAggMap;\n+\n+static int32_t getReducedFrequencySum(int32_t currentValue, int32_t newFrequency)\n+   {\n+   return (currentValue + newFrequency);\n+   }\n+\n+static int32_t getReducedFrequencyAverage(int32_t currentValue, int32_t count, int32_t newFrequency)\n+   {\n+   return ((currentValue * count) + newFrequency) / (count + 1);\n+   }\n+\n+int32_t TR_HotFieldMarking::perform()\n+   {\n+   if (!jitConfig->javaVM->memoryManagerFunctions->j9gc_hot_reference_field_required(jitConfig->javaVM))\n+      {\n+      if (trace())\n+         traceMsg(comp(), \"Skipping hot field marking since dynamic breadth first scan ordering is disabled\\n\");\n+      return 0;\n+      }\n+\n+   SymAggMap stats(SymAggMapComparator(), comp()->trMemory()->currentStackRegion());\n+   TR::Block *block = NULL;\n+   for (TR::PostorderNodeIterator it(comp()->getStartTree(), comp()); it != NULL; ++it)\n+      {\n+      TR::Node * const node = it.currentNode();\n+      if (node->getOpCodeValue() == TR::BBStart)\n+         {\n+         block = node->getBlock();\n+         }\n+      else if ((node->getOpCode().isLoadIndirect() || node->getOpCode().isStoreIndirect())\n+               && node->getOpCode().hasSymbolReference()\n+               && !node->getSymbolReference()->isUnresolved()\n+               && node->getSymbolReference()->getSymbol()->isShadow()\n+               && !node->isInternalPointer()\n+               && !node->getOpCode().isArrayLength()\n+               && node->getSymbolReference()->getSymbol()->isCollectedReference()\n+              )\n+         {\n+         TR::SymbolReference *symRef = node->getSymbolReference();\n+         if (symRef->getCPIndex() >= 0 && !symRef->getSymbol()->isArrayShadowSymbol())\n+            {\n+            auto itr = stats.find(symRef->getSymbol());\n+            if (itr != stats.end())\n+               {\n+               if(TR::Options::getReductionAlgorithm(TR_HotFieldReductionAlgorithmSum))", "originalCommit": "52a47ed47e7f267126c8b2f43e8d79d570d121f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxMzQ4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r458813483", "bodyText": "This needs some doxygen", "author": "andrewcraik", "createdAt": "2020-07-22T13:59:09Z", "path": "runtime/compiler/optimizer/HotFieldMarking.hpp", "diffHunk": "@@ -0,0 +1,48 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#ifndef HOTFIELDMARKING_INCL\n+#define HOTFIELDMARKING_INCL\n+\n+#include <stdint.h>                           // for int32_t\n+#include \"optimizer/Optimization.hpp\"         // for Optimization\n+#include \"optimizer/OptimizationManager.hpp\"  // for OptimizationManager\n+\n+namespace TR { class Block; class Node; }\n+\n+class TR_HotFieldMarking : public TR::Optimization\n+   {\n+   public:\n+   TR_HotFieldMarking(TR::OptimizationManager *manager)\n+      : TR::Optimization(manager)\n+      {}\n+   static TR::Optimization *create(TR::OptimizationManager *manager)\n+      {\n+      return new (manager->allocator()) TR_HotFieldMarking(manager);\n+      }\n+\n+   virtual int32_t perform();\n+   virtual const char * optDetailString() const throw();\n+   int32_t getUtilization();", "originalCommit": "52a47ed47e7f267126c8b2f43e8d79d570d121f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxMzc0OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r458813748", "bodyText": "Some doxygen on this would be good", "author": "andrewcraik", "createdAt": "2020-07-22T13:59:31Z", "path": "runtime/compiler/optimizer/HotFieldMarking.cpp", "diffHunk": "@@ -0,0 +1,173 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"optimizer/HotFieldMarking.hpp\"\n+#include \"env/j9method.h\"\n+#include \"il/Block.hpp\"\n+#include \"il/Node.hpp\"\n+#include \"il/Node_inlines.hpp\"\n+#include \"il/SymbolReference.hpp\"\n+#include \"il/TreeTop.hpp\"\n+#include \"infra/ILWalk.hpp\"\n+#include \"optimizer/Optimizer.hpp\"\n+#include \"optimizer/Optimization.hpp\"\n+#include \"optimizer/Optimization_inlines.hpp\"\n+#include \"optimizer/OptimizationManager.hpp\"\n+\n+#include <map>\n+\n+struct SymStats", "originalCommit": "52a47ed47e7f267126c8b2f43e8d79d570d121f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQyNzY5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r459427691", "bodyText": "please make these doxygen comments rather than just inline comments so they can come out in the documentation.", "author": "andrewcraik", "createdAt": "2020-07-23T12:57:08Z", "path": "runtime/compiler/optimizer/HotFieldMarking.cpp", "diffHunk": "@@ -35,24 +35,28 @@\n \n #include <map>\n \n+/**\n+ * A structure to represent the statistics related to each field during a compilation\n+ */\n struct SymStats\n    {\n-   int32_t _count;\n-   int32_t _score;\n+   int32_t _count; /* number of blocks within the compilation that contributes to the frequency score value of the field */", "originalCommit": "9050263b7640de45fa1456f1c1a9db4a5fa0106b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQyODUzMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r459428532", "bodyText": "please format the code with 3 space indent to match the rest of the file since these seem to be tabs.", "author": "andrewcraik", "createdAt": "2020-07-23T12:58:30Z", "path": "runtime/compiler/env/VMJ9.cpp", "diffHunk": "@@ -2347,6 +2350,113 @@ TR_J9VMBase::markHotField(TR::Compilation * comp, TR::SymbolReference * symRef,\n    }\n \n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param reducedCpuUtil normalized cpu utilization of the hot field for the method being compiled\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method being compiled\n+ */\n+void\n+TR_J9VMBase::reportHotField(int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\tJ9JavaVM * javaVM = _jitConfig->javaVM;", "originalCommit": "9050263b7640de45fa1456f1c1a9db4a5fa0106b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzNzUxNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r459437515", "bodyText": "High-level question - shouldn't this logic live in the GC with the logic that declares the data structures and the logic which reads the data structures? We should keep the concerns separated so perhaps moving this function into the GC and just calling the GC from this method would be more appropriate since these are internal details not owned by the JIT and we have traditionally kept the code separate to make sure we respect encapsulation and so the JIT doesn't have to change if you have to change something about the internal data representation in the GC.", "author": "andrewcraik", "createdAt": "2020-07-23T13:12:07Z", "path": "runtime/compiler/env/VMJ9.cpp", "diffHunk": "@@ -2347,6 +2350,113 @@ TR_J9VMBase::markHotField(TR::Compilation * comp, TR::SymbolReference * symRef,\n    }\n \n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param reducedCpuUtil normalized cpu utilization of the hot field for the method being compiled\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method being compiled\n+ */\n+void\n+TR_J9VMBase::reportHotField(int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)", "originalCommit": "9050263b7640de45fa1456f1c1a9db4a5fa0106b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg0Mzc1Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r459843753", "bodyText": "Yes I believe it is correct for this logic to not live in the JIT. As this logic is now purely modifying VM structures I will move it to the VM side.", "author": "jonoommen", "createdAt": "2020-07-24T04:13:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzNzUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzNzc1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r459437756", "bodyText": "This should be queried from the VM/GC somewhere I don't see why it is hardcoded in the JIT.", "author": "andrewcraik", "createdAt": "2020-07-23T13:12:31Z", "path": "runtime/compiler/env/VMJ9.cpp", "diffHunk": "@@ -145,6 +145,9 @@\n #define J9_FINDKNOWNCLASS_FLAG_EXISTING_ONLY 2\n #endif\n \n+/* Max hot field list length allowed for a class if scavenger dynamicBreadthScanOrdering is enabled */\n+#define MAX_HOT_FIELD_LIST_LENGTH 10", "originalCommit": "9050263b7640de45fa1456f1c1a9db4a5fa0106b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzODA0MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r459438040", "bodyText": "Perhaps this would be better done as a query on the objectmodel or something?", "author": "andrewcraik", "createdAt": "2020-07-23T13:13:03Z", "path": "runtime/compiler/env/VMJ9.cpp", "diffHunk": "@@ -2347,6 +2350,113 @@ TR_J9VMBase::markHotField(TR::Compilation * comp, TR::SymbolReference * symRef,\n    }\n \n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param reducedCpuUtil normalized cpu utilization of the hot field for the method being compiled\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method being compiled\n+ */\n+void\n+TR_J9VMBase::reportHotField(int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\tJ9JavaVM * javaVM = _jitConfig->javaVM;\n+\t/* exit if pools are null */\n+\tif (clazz->classLoader->hotFieldPool == NULL || javaVM->hotFieldClassInfoPool == NULL || javaVM->hotFieldClassInfoPoolMutex == NULL) {\n+\t\treturn;\n+\t}\n+\n+\t/* check if hotFieldsInfo exists already */\n+\tif(NULL == clazz->hotFieldsInfo) { \n+\t\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\t\tif(NULL == clazz->hotFieldsInfo) {\n+         /* initialize new hotFieldsInfo pool element as it does not exist already */\n+\t\t\tclazz->hotFieldsInfo = (J9ClassHotFieldsInfo *)pool_newElement(javaVM->hotFieldClassInfoPool);\n+\t\t\tif(NULL == clazz->hotFieldsInfo) {\n+\t\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\t\treturn; \n+\t\t\t}\n+         clazz->hotFieldsInfo->hotFieldListLength = 0;\n+\t\t\tclazz->hotFieldsInfo->consecutiveHotFieldSelections = 0;\n+\t\t\tclazz->hotFieldsInfo->hotFieldOffset1 = U_8_MAX;\n+\t\t\tclazz->hotFieldsInfo->hotFieldOffset2 = U_8_MAX;\n+         \n+         /* create and initialize the new hot field */\n+\t\t\tomrthread_monitor_enter(clazz->classLoader->hotFieldPoolMutex);\t\n+\t\t\tJ9HotField* newHotField = (J9HotField *)pool_newElement(clazz->classLoader->hotFieldPool);\t\n+\t\t\tif(NULL == newHotField) {\n+\t\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\t\treturn; \n+\t\t\t} \n+\t\t\tnewHotField->next = NULL;\n+\t\t\tnewHotField->hotFieldOffset = fieldOffset;\n+\t\t\tnewHotField->hotness = (reducedFrequency * reducedCpuUtil);\n+\t\t\tnewHotField->cpuUtil = reducedCpuUtil;\n+\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+         \n+         /* update hotFieldsInfo for the class now that a new hot field has been added */\n+\t\t\tclazz->hotFieldsInfo->hotFieldListHead = newHotField;\n+\t\t\tclazz->hotFieldsInfo->isClassHotFieldListDirty = true;\n+\t\t\tclazz->hotFieldsInfo->hotFieldListLength++;\n+\t\t\tclazz->hotFieldsInfo->classLoader = clazz->classLoader;\n+\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\treturn;\t\t\n+\t\t} else {\n+\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t}\n+\t} \t\n+\n+\t/* see if hot field exists already in the hot field list */\n+\tJ9HotField* temp = clazz->hotFieldsInfo->hotFieldListHead;\n+\twhile (NULL != temp) {\n+      /* if the hot field exists, update the hot field with the newly reported hot field information */\n+\t\tif(temp->hotFieldOffset == fieldOffset) {\n+\t\t\tomrthread_monitor_enter(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\ttemp->hotness += (reducedFrequency * reducedCpuUtil);\n+\t\t\ttemp->cpuUtil += reducedCpuUtil;\n+\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\tclazz->hotFieldsInfo->isClassHotFieldListDirty = true;\n+\t\t\treturn; \n+\t\t}\n+      /* if the hot field does not exist and the hot field list is not currently at its max size, create and initialize the new hot field  */\n+\t\telse if(NULL == temp->next) {\n+\t\t\tif(clazz->hotFieldsInfo->hotFieldListLength < MAX_HOT_FIELD_LIST_LENGTH)\n+\t\t\t{\n+\t\t\t\tomrthread_monitor_enter(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\t\tJ9HotField* newHotField = (J9HotField *)pool_newElement(clazz->classLoader->hotFieldPool);\n+\t\t\t\tif(NULL == newHotField) {\n+\t\t\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tnewHotField->next = NULL;\n+\t\t\t\tnewHotField->hotFieldOffset = fieldOffset;\n+\t\t\t\tnewHotField->hotness = (reducedFrequency * reducedCpuUtil);\n+\t\t\t\tnewHotField->cpuUtil = reducedCpuUtil;\n+\t\t\t\ttemp->next = newHotField;\n+\t\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\t\t/* update hotFieldsInfo for the class now that a new hot field has been added */\n+            clazz->hotFieldsInfo->hotFieldListLength++;\n+\t\t\t\tclazz->hotFieldsInfo->isClassHotFieldListDirty = true;\n+\t\t\t} \t\t\t\t\n+\t\t\treturn; \t\n+\t\t}\n+\t\ttemp = temp->next;\n+\t}\n+}\n+\n+/**\n+ * Query if hot reference field is reqired for dynamicBreadthFirstScanOrdering\n+ *  @return true if scavenger dynamicBreadthFirstScanOrdering is enabled, 0 otherwise \n+ */\n+bool\n+TR_J9VMBase::isHotReferenceFieldRequired()\n+   {\n+   return _jitConfig->javaVM->memoryManagerFunctions->j9gc_hot_reference_field_required(_jitConfig->javaVM);", "originalCommit": "9050263b7640de45fa1456f1c1a9db4a5fa0106b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNDcwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r459824707", "bodyText": "Yes I believe a query on the object model would be more correct", "author": "jonoommen", "createdAt": "2020-07-24T02:28:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzODA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAxMzY3NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470013675", "bodyText": "cache the result of vm->memoryManagerFunctions->j9gc_hot_reference_field_required(vm) in a BOOLEAN", "author": "tajila", "createdAt": "2020-08-13T14:55:05Z", "path": "runtime/vm/jvminit.c", "diffHunk": "@@ -649,6 +649,16 @@ freeJavaVM(J9JavaVM * vm)\n \t\trunShutdownStage(vm, INTERPRETER_SHUTDOWN, NULL, 0);\n \t}\n \n+\t/* Kill global hot field class info pool and its monitor if dynamicBreadthFirstScanOrdering is enabled */\n+\tif (vm->memoryManagerFunctions->j9gc_hot_reference_field_required(vm) && NULL != vm->hotFieldClassInfoPool) {", "originalCommit": "59a99371ed2d46bffa2d1a6987a1bc6fdcd93a8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAxNDA1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470014050", "bodyText": "do the full (NULL != vm->hotFieldClassInfoPoolMutex) check here", "author": "tajila", "createdAt": "2020-08-13T14:55:28Z", "path": "runtime/vm/jvminit.c", "diffHunk": "@@ -649,6 +649,16 @@ freeJavaVM(J9JavaVM * vm)\n \t\trunShutdownStage(vm, INTERPRETER_SHUTDOWN, NULL, 0);\n \t}\n \n+\t/* Kill global hot field class info pool and its monitor if dynamicBreadthFirstScanOrdering is enabled */\n+\tif (vm->memoryManagerFunctions->j9gc_hot_reference_field_required(vm) && NULL != vm->hotFieldClassInfoPool) {\n+\t\tpool_kill(vm->hotFieldClassInfoPool);\n+\t\tvm->hotFieldClassInfoPool = NULL;\n+\t}\n+\n+\tif (vm->memoryManagerFunctions->j9gc_hot_reference_field_required(vm) && vm->hotFieldClassInfoPoolMutex) {", "originalCommit": "59a99371ed2d46bffa2d1a6987a1bc6fdcd93a8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAyMDE0MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470020140", "bodyText": "put comments on top", "author": "tajila", "createdAt": "2020-08-13T15:03:33Z", "path": "runtime/vm/jvminit.c", "diffHunk": "@@ -6307,6 +6317,13 @@ protectedInitializeJavaVM(J9PortLibrary* portLibrary, void * userData)\n \t\t\t}\n \t\t}\n #endif\n+\t\t/* Create global hot field class info pool and monitor if scavenger dynamicBreadthFirstScanOrdering is enabled */\n+\t\tif (vm->memoryManagerFunctions->j9gc_hot_reference_field_required(vm)) {\n+\t\t\tvm->hotFieldClassInfoPool = pool_new(sizeof(J9ClassHotFieldsInfo),  0, 0, 0, J9_GET_CALLSITE(), J9MEM_CATEGORY_CLASSES, POOL_FOR_PORT(portLibrary));\t/* Create the hot field class pool */", "originalCommit": "59a99371ed2d46bffa2d1a6987a1bc6fdcd93a8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAyMTAxOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470021019", "bodyText": "to the full 0 != check for the monitor init", "author": "tajila", "createdAt": "2020-08-13T15:04:46Z", "path": "runtime/vm/jvminit.c", "diffHunk": "@@ -6307,6 +6317,13 @@ protectedInitializeJavaVM(J9PortLibrary* portLibrary, void * userData)\n \t\t\t}\n \t\t}\n #endif\n+\t\t/* Create global hot field class info pool and monitor if scavenger dynamicBreadthFirstScanOrdering is enabled */\n+\t\tif (vm->memoryManagerFunctions->j9gc_hot_reference_field_required(vm)) {\n+\t\t\tvm->hotFieldClassInfoPool = pool_new(sizeof(J9ClassHotFieldsInfo),  0, 0, 0, J9_GET_CALLSITE(), J9MEM_CATEGORY_CLASSES, POOL_FOR_PORT(portLibrary));\t/* Create the hot field class pool */\n+\t\t\tif (NULL == vm->hotFieldClassInfoPool || omrthread_monitor_init_with_name(&vm->hotFieldClassInfoPoolMutex, 0, \"Hot Field Class Info Pool\")) {", "originalCommit": "59a99371ed2d46bffa2d1a6987a1bc6fdcd93a8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAyMTU2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470021568", "bodyText": "some tabbing issues in this function", "author": "tajila", "createdAt": "2020-08-13T15:05:31Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +581,103 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param vm[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the hot field for the method being compiled\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method being compiled\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/* exit if pools are null */\n+\tif (clazz->classLoader->hotFieldPool == NULL || javaVM->hotFieldClassInfoPool == NULL || javaVM->hotFieldClassInfoPoolMutex == NULL) {\n+\t\treturn;\n+\t}\n+\n+\t/* check if hotFieldsInfo exists already */\n+\tif(NULL == clazz->hotFieldsInfo) { \n+\t\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\t\tif(NULL == clazz->hotFieldsInfo) {\n+         /* initialize new hotFieldsInfo pool element as it does not exist already */", "originalCommit": "59a99371ed2d46bffa2d1a6987a1bc6fdcd93a8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAyMzMyOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470023328", "bodyText": "space between if and (", "author": "tajila", "createdAt": "2020-08-13T15:08:06Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +581,103 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param vm[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the hot field for the method being compiled\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method being compiled\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/* exit if pools are null */\n+\tif (clazz->classLoader->hotFieldPool == NULL || javaVM->hotFieldClassInfoPool == NULL || javaVM->hotFieldClassInfoPoolMutex == NULL) {\n+\t\treturn;\n+\t}\n+\n+\t/* check if hotFieldsInfo exists already */\n+\tif(NULL == clazz->hotFieldsInfo) { ", "originalCommit": "59a99371ed2d46bffa2d1a6987a1bc6fdcd93a8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAyMzQzNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470023436", "bodyText": "same below", "author": "tajila", "createdAt": "2020-08-13T15:08:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAyMzMyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzODgzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470038838", "bodyText": "can this be done lazily? Some apps create a lot of classloaders with a small amounts of classes within them", "author": "tajila", "createdAt": "2020-08-13T15:30:03Z", "path": "runtime/vm/classallocation.c", "diffHunk": "@@ -173,6 +173,18 @@ allocateClassLoader(J9JavaVM *javaVM)\n \t\t/* memset not required as the classLoaderBlocks pool returns zero'd memory */\n \n \t\tclassLoader->classHashTable = hashClassTableNew(javaVM, INITIAL_CLASSHASHTABLE_SIZE);\n+\t\t\n+\t\t/* Create classloader hot field pool and monitor if scavenger dynamicBreadthFirstScanOrdering is enabled */\n+\t\tif(javaVM->memoryManagerFunctions->j9gc_hot_reference_field_required(javaVM)) {", "originalCommit": "59a99371ed2d46bffa2d1a6987a1bc6fdcd93a8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI4MTczMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472281730", "bodyText": "???", "author": "tajila", "createdAt": "2020-08-18T15:24:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzODgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0NDUzNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470044535", "bodyText": "instead of temp calling it hotFieldListHead may be more descriptive", "author": "tajila", "createdAt": "2020-08-13T15:38:45Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +581,103 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param vm[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the hot field for the method being compiled\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method being compiled\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/* exit if pools are null */\n+\tif (clazz->classLoader->hotFieldPool == NULL || javaVM->hotFieldClassInfoPool == NULL || javaVM->hotFieldClassInfoPoolMutex == NULL) {\n+\t\treturn;\n+\t}\n+\n+\t/* check if hotFieldsInfo exists already */\n+\tif(NULL == clazz->hotFieldsInfo) { \n+\t\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\t\tif(NULL == clazz->hotFieldsInfo) {\n+         /* initialize new hotFieldsInfo pool element as it does not exist already */\n+\t\t\tclazz->hotFieldsInfo = (J9ClassHotFieldsInfo *)pool_newElement(javaVM->hotFieldClassInfoPool);\n+\t\t\tif(NULL == clazz->hotFieldsInfo) {\n+\t\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\t\treturn; \n+\t\t\t}\n+         clazz->hotFieldsInfo->hotFieldListLength = 0;\n+\t\t\tclazz->hotFieldsInfo->consecutiveHotFieldSelections = 0;\n+\t\t\tclazz->hotFieldsInfo->hotFieldOffset1 = U_8_MAX;\n+\t\t\tclazz->hotFieldsInfo->hotFieldOffset2 = U_8_MAX;\n+         \n+         /* create and initialize the new hot field */\n+\t\t\tomrthread_monitor_enter(clazz->classLoader->hotFieldPoolMutex);\t\n+\t\t\tJ9HotField* newHotField = (J9HotField *)pool_newElement(clazz->classLoader->hotFieldPool);\t\n+\t\t\tif(NULL == newHotField) {\n+\t\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\t\treturn; \n+\t\t\t} \n+\t\t\tnewHotField->next = NULL;\n+\t\t\tnewHotField->hotFieldOffset = fieldOffset;\n+\t\t\tnewHotField->hotness = (reducedFrequency * reducedCpuUtil);\n+\t\t\tnewHotField->cpuUtil = reducedCpuUtil;\n+\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+         \n+         /* update hotFieldsInfo for the class now that a new hot field has been added */\n+\t\t\tclazz->hotFieldsInfo->hotFieldListHead = newHotField;\n+\t\t\tclazz->hotFieldsInfo->isClassHotFieldListDirty = true;\n+\t\t\tclazz->hotFieldsInfo->hotFieldListLength++;\n+\t\t\tclazz->hotFieldsInfo->classLoader = clazz->classLoader;\n+\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\treturn;\t\t\n+\t\t} else {\n+\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t}\n+\t} \t\n+\n+\t/* see if hot field exists already in the hot field list */\n+\tJ9HotField* temp = clazz->hotFieldsInfo->hotFieldListHead;", "originalCommit": "59a99371ed2d46bffa2d1a6987a1bc6fdcd93a8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0NDg2Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470044862", "bodyText": "dont split else if with comments", "author": "tajila", "createdAt": "2020-08-13T15:39:16Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +581,103 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param vm[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the hot field for the method being compiled\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method being compiled\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/* exit if pools are null */\n+\tif (clazz->classLoader->hotFieldPool == NULL || javaVM->hotFieldClassInfoPool == NULL || javaVM->hotFieldClassInfoPoolMutex == NULL) {\n+\t\treturn;\n+\t}\n+\n+\t/* check if hotFieldsInfo exists already */\n+\tif(NULL == clazz->hotFieldsInfo) { \n+\t\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\t\tif(NULL == clazz->hotFieldsInfo) {\n+         /* initialize new hotFieldsInfo pool element as it does not exist already */\n+\t\t\tclazz->hotFieldsInfo = (J9ClassHotFieldsInfo *)pool_newElement(javaVM->hotFieldClassInfoPool);\n+\t\t\tif(NULL == clazz->hotFieldsInfo) {\n+\t\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\t\treturn; \n+\t\t\t}\n+         clazz->hotFieldsInfo->hotFieldListLength = 0;\n+\t\t\tclazz->hotFieldsInfo->consecutiveHotFieldSelections = 0;\n+\t\t\tclazz->hotFieldsInfo->hotFieldOffset1 = U_8_MAX;\n+\t\t\tclazz->hotFieldsInfo->hotFieldOffset2 = U_8_MAX;\n+         \n+         /* create and initialize the new hot field */\n+\t\t\tomrthread_monitor_enter(clazz->classLoader->hotFieldPoolMutex);\t\n+\t\t\tJ9HotField* newHotField = (J9HotField *)pool_newElement(clazz->classLoader->hotFieldPool);\t\n+\t\t\tif(NULL == newHotField) {\n+\t\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\t\treturn; \n+\t\t\t} \n+\t\t\tnewHotField->next = NULL;\n+\t\t\tnewHotField->hotFieldOffset = fieldOffset;\n+\t\t\tnewHotField->hotness = (reducedFrequency * reducedCpuUtil);\n+\t\t\tnewHotField->cpuUtil = reducedCpuUtil;\n+\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+         \n+         /* update hotFieldsInfo for the class now that a new hot field has been added */\n+\t\t\tclazz->hotFieldsInfo->hotFieldListHead = newHotField;\n+\t\t\tclazz->hotFieldsInfo->isClassHotFieldListDirty = true;\n+\t\t\tclazz->hotFieldsInfo->hotFieldListLength++;\n+\t\t\tclazz->hotFieldsInfo->classLoader = clazz->classLoader;\n+\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\treturn;\t\t\n+\t\t} else {\n+\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t}\n+\t} \t\n+\n+\t/* see if hot field exists already in the hot field list */\n+\tJ9HotField* temp = clazz->hotFieldsInfo->hotFieldListHead;\n+\twhile (NULL != temp) {\n+      /* if the hot field exists, update the hot field with the newly reported hot field information */\n+\t\tif(temp->hotFieldOffset == fieldOffset) {\n+\t\t\tomrthread_monitor_enter(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\ttemp->hotness += (reducedFrequency * reducedCpuUtil);\n+\t\t\ttemp->cpuUtil += reducedCpuUtil;\n+\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\tclazz->hotFieldsInfo->isClassHotFieldListDirty = true;\n+\t\t\treturn; \n+\t\t}\n+      /* if the hot field does not exist and the hot field list is not currently at its max size, create and initialize the new hot field  */", "originalCommit": "59a99371ed2d46bffa2d1a6987a1bc6fdcd93a8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0NzI3NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470047274", "bodyText": "is it possible for this to be NULL", "author": "tajila", "createdAt": "2020-08-13T15:42:46Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +581,103 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param vm[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the hot field for the method being compiled\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method being compiled\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/* exit if pools are null */\n+\tif (clazz->classLoader->hotFieldPool == NULL || javaVM->hotFieldClassInfoPool == NULL || javaVM->hotFieldClassInfoPoolMutex == NULL) {\n+\t\treturn;\n+\t}\n+\n+\t/* check if hotFieldsInfo exists already */\n+\tif(NULL == clazz->hotFieldsInfo) { \n+\t\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\t\tif(NULL == clazz->hotFieldsInfo) {\n+         /* initialize new hotFieldsInfo pool element as it does not exist already */\n+\t\t\tclazz->hotFieldsInfo = (J9ClassHotFieldsInfo *)pool_newElement(javaVM->hotFieldClassInfoPool);\n+\t\t\tif(NULL == clazz->hotFieldsInfo) {\n+\t\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\t\treturn; \n+\t\t\t}\n+         clazz->hotFieldsInfo->hotFieldListLength = 0;\n+\t\t\tclazz->hotFieldsInfo->consecutiveHotFieldSelections = 0;\n+\t\t\tclazz->hotFieldsInfo->hotFieldOffset1 = U_8_MAX;\n+\t\t\tclazz->hotFieldsInfo->hotFieldOffset2 = U_8_MAX;\n+         \n+         /* create and initialize the new hot field */\n+\t\t\tomrthread_monitor_enter(clazz->classLoader->hotFieldPoolMutex);\t\n+\t\t\tJ9HotField* newHotField = (J9HotField *)pool_newElement(clazz->classLoader->hotFieldPool);\t\n+\t\t\tif(NULL == newHotField) {\n+\t\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\t\treturn; \n+\t\t\t} \n+\t\t\tnewHotField->next = NULL;\n+\t\t\tnewHotField->hotFieldOffset = fieldOffset;\n+\t\t\tnewHotField->hotness = (reducedFrequency * reducedCpuUtil);\n+\t\t\tnewHotField->cpuUtil = reducedCpuUtil;\n+\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+         \n+         /* update hotFieldsInfo for the class now that a new hot field has been added */\n+\t\t\tclazz->hotFieldsInfo->hotFieldListHead = newHotField;\n+\t\t\tclazz->hotFieldsInfo->isClassHotFieldListDirty = true;\n+\t\t\tclazz->hotFieldsInfo->hotFieldListLength++;\n+\t\t\tclazz->hotFieldsInfo->classLoader = clazz->classLoader;\n+\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\treturn;\t\t\n+\t\t} else {\n+\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t}\n+\t} \t\n+\n+\t/* see if hot field exists already in the hot field list */\n+\tJ9HotField* temp = clazz->hotFieldsInfo->hotFieldListHead;\n+\twhile (NULL != temp) {", "originalCommit": "59a99371ed2d46bffa2d1a6987a1bc6fdcd93a8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA5Nzg5OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470097898", "bodyText": "Head should not ever be null, but since i'm iterating the linked list temp will eventually be null and is needed for the exit condition.", "author": "jonoommen", "createdAt": "2020-08-13T17:05:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0NzI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1MDE0Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470050146", "bodyText": "to avoid code duplication, and to simply things perhaps do the following:\n\nsearch for hot field\nif hotfield not found create it\nadd/update stats", "author": "tajila", "createdAt": "2020-08-13T15:47:08Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +581,103 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param vm[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the hot field for the method being compiled\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method being compiled\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/* exit if pools are null */\n+\tif (clazz->classLoader->hotFieldPool == NULL || javaVM->hotFieldClassInfoPool == NULL || javaVM->hotFieldClassInfoPoolMutex == NULL) {\n+\t\treturn;\n+\t}\n+\n+\t/* check if hotFieldsInfo exists already */\n+\tif(NULL == clazz->hotFieldsInfo) { \n+\t\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\t\tif(NULL == clazz->hotFieldsInfo) {\n+         /* initialize new hotFieldsInfo pool element as it does not exist already */\n+\t\t\tclazz->hotFieldsInfo = (J9ClassHotFieldsInfo *)pool_newElement(javaVM->hotFieldClassInfoPool);\n+\t\t\tif(NULL == clazz->hotFieldsInfo) {\n+\t\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\t\treturn; \n+\t\t\t}\n+         clazz->hotFieldsInfo->hotFieldListLength = 0;\n+\t\t\tclazz->hotFieldsInfo->consecutiveHotFieldSelections = 0;\n+\t\t\tclazz->hotFieldsInfo->hotFieldOffset1 = U_8_MAX;\n+\t\t\tclazz->hotFieldsInfo->hotFieldOffset2 = U_8_MAX;\n+         \n+         /* create and initialize the new hot field */\n+\t\t\tomrthread_monitor_enter(clazz->classLoader->hotFieldPoolMutex);\t\n+\t\t\tJ9HotField* newHotField = (J9HotField *)pool_newElement(clazz->classLoader->hotFieldPool);\t\n+\t\t\tif(NULL == newHotField) {\n+\t\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\t\treturn; \n+\t\t\t} \n+\t\t\tnewHotField->next = NULL;\n+\t\t\tnewHotField->hotFieldOffset = fieldOffset;\n+\t\t\tnewHotField->hotness = (reducedFrequency * reducedCpuUtil);\n+\t\t\tnewHotField->cpuUtil = reducedCpuUtil;\n+\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+         \n+         /* update hotFieldsInfo for the class now that a new hot field has been added */\n+\t\t\tclazz->hotFieldsInfo->hotFieldListHead = newHotField;\n+\t\t\tclazz->hotFieldsInfo->isClassHotFieldListDirty = true;\n+\t\t\tclazz->hotFieldsInfo->hotFieldListLength++;\n+\t\t\tclazz->hotFieldsInfo->classLoader = clazz->classLoader;\n+\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\treturn;\t\t\n+\t\t} else {\n+\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t}\n+\t} \t\n+\n+\t/* see if hot field exists already in the hot field list */", "originalCommit": "59a99371ed2d46bffa2d1a6987a1bc6fdcd93a8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEwNDM5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470104392", "bodyText": "That is how I originally implemented it, however it was implemented in this manor for efficiency and to reduce monitor contention as this method must be very fast. @tajila", "author": "jonoommen", "createdAt": "2020-08-13T17:12:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1MDE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2MDY5Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470160693", "bodyText": "What I am suggesting doesn't increase lock contention, its more of a code organization comment. The runtime behaviour is the same.\nBasically\ndo {\n    /* find hotfied */\n} while (NULL != head);\n\n// acquire hotFieldPoolMutex\nif (hotfieldnotfound) {\n    //check hotfield maxlen, etc.\n    // create hotfield\n}\n\nupdatehotfield...\n// release hotFieldPoolMutex", "author": "tajila", "createdAt": "2020-08-13T18:28:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1MDE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2MTQwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470161407", "bodyText": "you can split this function into two functions createHotfieldInfo and updateHotfield. You can make them inline functions.", "author": "tajila", "createdAt": "2020-08-13T18:30:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1MDE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2MTkxNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470161915", "bodyText": "also, try limit your functions to a single return, this can be done by adding a label for for exit", "author": "tajila", "createdAt": "2020-08-13T18:30:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1MDE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1MDM4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470050382", "bodyText": "tabbing issue here", "author": "tajila", "createdAt": "2020-08-13T15:47:27Z", "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -605,6 +605,23 @@ typedef struct J9JITRedefinedClass {\n \tstruct J9JITMethodEquivalence* methodList;\n } J9JITRedefinedClass;\n \n+typedef struct J9HotField {\n+    U_8 hotFieldOffset; ", "originalCommit": "59a99371ed2d46bffa2d1a6987a1bc6fdcd93a8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1MTE3MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470051170", "bodyText": "to create a more efficient layout, start with the larger fields (pointer in this case) then the smaller ones. The compiler may add padding bytes if you place a big field after a smaller one", "author": "tajila", "createdAt": "2020-08-13T15:48:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1MDM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1MTU0OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470051548", "bodyText": "same here", "author": "tajila", "createdAt": "2020-08-13T15:49:12Z", "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -605,6 +605,23 @@ typedef struct J9JITRedefinedClass {\n \tstruct J9JITMethodEquivalence* methodList;\n } J9JITRedefinedClass;\n \n+typedef struct J9HotField {\n+    U_8 hotFieldOffset; \n+    U_32 hotness;\n+\tU_16 cpuUtil;\n+   struct J9HotField* next;\n+} J9HotField;\n+\n+typedef struct J9ClassHotFieldsInfo {", "originalCommit": "59a99371ed2d46bffa2d1a6987a1bc6fdcd93a8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2Nzk0Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470167942", "bodyText": "j9class init should be done in createramclass, also the ram class fragments are zero init so the = NULL is not needed.", "author": "tajila", "createdAt": "2020-08-13T18:40:54Z", "path": "runtime/gc_glue_java/ObjectModel.cpp", "diffHunk": "@@ -98,6 +98,7 @@ GC_ObjectModel::internalClassLoadHook(J9HookInterface** hook, UDATA eventNum, vo\n \tGC_ObjectModel *objectModel = (GC_ObjectModel*)userData;\n \tJ9VMThread *vmThread = classLoadEvent->currentThread;\n \tJ9Class *clazz = classLoadEvent->clazz;\n+\tclazz->hotFieldsInfo = NULL;", "originalCommit": "59a99371ed2d46bffa2d1a6987a1bc6fdcd93a8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MTc2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470171764", "bodyText": "Coding style is: (NULL == clazz->classLoader->hotFieldPool). And you need extra oval brackets for each of comparison expressions .", "author": "amicic", "createdAt": "2020-08-13T18:47:33Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +581,103 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param vm[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the hot field for the method being compiled\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method being compiled\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/* exit if pools are null */\n+\tif (clazz->classLoader->hotFieldPool == NULL || javaVM->hotFieldClassInfoPool == NULL || javaVM->hotFieldClassInfoPoolMutex == NULL) {", "originalCommit": "3024ceaa25e0ec0781fff4a333a688fda23bf9c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MjcyOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r470172729", "bodyText": "indentation for this comment and several other lines later below in this method does not now seem right", "author": "amicic", "createdAt": "2020-08-13T18:49:19Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +581,103 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param vm[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the hot field for the method being compiled\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method being compiled\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/* exit if pools are null */\n+\tif (clazz->classLoader->hotFieldPool == NULL || javaVM->hotFieldClassInfoPool == NULL || javaVM->hotFieldClassInfoPoolMutex == NULL) {\n+\t\treturn;\n+\t}\n+\n+\t/* check if hotFieldsInfo exists already */\n+\tif(NULL == clazz->hotFieldsInfo) { \n+\t\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\t\tif(NULL == clazz->hotFieldsInfo) {\n+         /* initialize new hotFieldsInfo pool element as it does not exist already */", "originalCommit": "3024ceaa25e0ec0781fff4a333a688fda23bf9c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU0NDE0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r471544149", "bodyText": "not quite what I meant. Basically, line 606 - 644 (createHotFieldsInfo) is one function. Line 645 - 665 (addOrUpdateHotfield) is another.", "author": "tajila", "createdAt": "2020-08-17T15:07:46Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +583,118 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param vm[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the hot field for the method being compiled\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method being compiled\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/* exit if pools are null */\n+\tif (NULL == clazz->classLoader->hotFieldPool || NULL == javaVM->hotFieldClassInfoPool || NULL == javaVM->hotFieldClassInfoPoolMutex) {\n+\t\tgoto exit;\n+\t}\n+\n+\t/* check if hotFieldsInfo exists already */\n+\tif(NULL == clazz->hotFieldsInfo) { \n+\t\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\t\tif(NULL == clazz->hotFieldsInfo) {\n+        \t/* initialize new hotFieldsInfo pool element as it does not exist already */\n+\t\t\tclazz->hotFieldsInfo = (J9ClassHotFieldsInfo *)pool_newElement(javaVM->hotFieldClassInfoPool);\n+\t\t\tif(NULL == clazz->hotFieldsInfo) {\n+\t\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\t\tgoto exit; \n+\t\t\t}\n+        \tclazz->hotFieldsInfo->hotFieldListLength = 0;\n+\t\t\tclazz->hotFieldsInfo->consecutiveHotFieldSelections = 0;\n+\t\t\tclazz->hotFieldsInfo->hotFieldOffset1 = U_8_MAX;\n+\t\t\tclazz->hotFieldsInfo->hotFieldOffset2 = U_8_MAX;\n+         \n+        \t/* create and initialize the new hot field */\n+\t\t\tomrthread_monitor_enter(clazz->classLoader->hotFieldPoolMutex);\t\n+\t\t\tJ9HotField* newHotField = (J9HotField *)pool_newElement(clazz->classLoader->hotFieldPool);\t\n+\t\t\tif(NULL == newHotField) {\n+\t\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\t\tgoto exit; \n+\t\t\t} \n+\t\t\tnewHotField->next = NULL;\n+\t\t\tnewHotField->hotFieldOffset = fieldOffset;\n+\t\t\tnewHotField->hotness = (reducedFrequency * reducedCpuUtil);\n+\t\t\tnewHotField->cpuUtil = reducedCpuUtil;\n+\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+         \n+        \t/* update hotFieldsInfo for the class now that a new hot field has been added */\n+\t\t\tclazz->hotFieldsInfo->hotFieldListHead = newHotField;\n+\t\t\tclazz->hotFieldsInfo->isClassHotFieldListDirty = true;\n+\t\t\tclazz->hotFieldsInfo->hotFieldListLength++;\n+\t\t\tclazz->hotFieldsInfo->classLoader = clazz->classLoader;\n+\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\tgoto exit;\t\t\n+\t\t} else {\n+\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t}\n+\t} \t\n+", "originalCommit": "0dcf18b0cfc1d4fa149179819664b902fea03a4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU0OTUzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r471549531", "bodyText": "This is what I meant about the duplication, updateHotField is essentially addNewHotField without the allocation of a hotfield. If in the future you need to update the metrics collected, it will have to be updated in two places.\nAnother approach would be to simply find the hotfield in this loop, once it is found then break. If it is not found then current is NULL which is fine. In line 659 check add a NULL check for current along with the existing check (youll need to acquire the monitor before hand). Then in line 660 where you have addNewHotField,  simply allocate a new hotfield. After the if block update the hotfield, the release then monitor. All of this can be done in a single function.", "author": "tajila", "createdAt": "2020-08-17T15:15:46Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +583,118 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param vm[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the hot field for the method being compiled\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method being compiled\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/* exit if pools are null */\n+\tif (NULL == clazz->classLoader->hotFieldPool || NULL == javaVM->hotFieldClassInfoPool || NULL == javaVM->hotFieldClassInfoPoolMutex) {\n+\t\tgoto exit;\n+\t}\n+\n+\t/* check if hotFieldsInfo exists already */\n+\tif(NULL == clazz->hotFieldsInfo) { \n+\t\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\t\tif(NULL == clazz->hotFieldsInfo) {\n+        \t/* initialize new hotFieldsInfo pool element as it does not exist already */\n+\t\t\tclazz->hotFieldsInfo = (J9ClassHotFieldsInfo *)pool_newElement(javaVM->hotFieldClassInfoPool);\n+\t\t\tif(NULL == clazz->hotFieldsInfo) {\n+\t\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\t\tgoto exit; \n+\t\t\t}\n+        \tclazz->hotFieldsInfo->hotFieldListLength = 0;\n+\t\t\tclazz->hotFieldsInfo->consecutiveHotFieldSelections = 0;\n+\t\t\tclazz->hotFieldsInfo->hotFieldOffset1 = U_8_MAX;\n+\t\t\tclazz->hotFieldsInfo->hotFieldOffset2 = U_8_MAX;\n+         \n+        \t/* create and initialize the new hot field */\n+\t\t\tomrthread_monitor_enter(clazz->classLoader->hotFieldPoolMutex);\t\n+\t\t\tJ9HotField* newHotField = (J9HotField *)pool_newElement(clazz->classLoader->hotFieldPool);\t\n+\t\t\tif(NULL == newHotField) {\n+\t\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\t\tgoto exit; \n+\t\t\t} \n+\t\t\tnewHotField->next = NULL;\n+\t\t\tnewHotField->hotFieldOffset = fieldOffset;\n+\t\t\tnewHotField->hotness = (reducedFrequency * reducedCpuUtil);\n+\t\t\tnewHotField->cpuUtil = reducedCpuUtil;\n+\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+         \n+        \t/* update hotFieldsInfo for the class now that a new hot field has been added */\n+\t\t\tclazz->hotFieldsInfo->hotFieldListHead = newHotField;\n+\t\t\tclazz->hotFieldsInfo->isClassHotFieldListDirty = true;\n+\t\t\tclazz->hotFieldsInfo->hotFieldListLength++;\n+\t\t\tclazz->hotFieldsInfo->classLoader = clazz->classLoader;\n+\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t\tgoto exit;\t\t\n+\t\t} else {\n+\t\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t\t}\n+\t} \t\n+\n+\t/* if the hot field exists, update the hot field with the newly reported hot field information */\n+\tJ9HotField* previous;\n+\tJ9HotField* current;\n+\tcurrent = clazz->hotFieldsInfo->hotFieldListHead;\n+\tdo {\n+\t\tif (current->hotFieldOffset == fieldOffset) {\n+\t\t\tupdateHotField(current, clazz, reducedCpuUtil, reducedFrequency);", "originalCommit": "0dcf18b0cfc1d4fa149179819664b902fea03a4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY4NzE0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r471687149", "bodyText": "Ok I will do something just like this \ud83d\udc4d", "author": "jonoommen", "createdAt": "2020-08-17T18:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU0OTUzMQ=="}], "type": "inlineReview"}, {"oid": "75078eb89cc14856086cd02f793d2dd8761cdaf5", "url": "https://github.com/eclipse-openj9/openj9/commit/75078eb89cc14856086cd02f793d2dd8761cdaf5", "message": "modfiy input variable name", "committedDate": "2020-08-17T19:33:45Z", "type": "forcePushed"}, {"oid": "b3913bcde1e052f5f913075f7ee045c10a01aef4", "url": "https://github.com/eclipse-openj9/openj9/commit/b3913bcde1e052f5f913075f7ee045c10a01aef4", "message": "Add option for hot field resetting", "committedDate": "2020-08-18T14:06:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI2OTY0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472269643", "bodyText": "if the hot field already exists and you have exceeded the MAX_HOT_FIELD_LIST_LENGTH then you will not be able to update it. This check needs to be moved into addOrUpdateHotField", "author": "tajila", "createdAt": "2020-08-18T15:07:29Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +583,124 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param clazz pointer to the class where a hot field should be added/updated\n+ * @param fieldOffset value of the field offset that should be added/updated as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/* exit if pools are null */\n+\tif (NULL == clazz->classLoader->hotFieldPool || NULL == javaVM->hotFieldClassInfoPool) {\n+\t\treturn;\n+\t}\n+\n+\t/* If hotFieldsInfo pool element for the class does not exist already, create and initialize the class' hotFieldsInfo pool element\n+\t * otherwise, create/update the given hot field for the class \n+\t */\n+\tif (NULL == clazz->hotFieldsInfo) {\n+\t\tcreateClassHotFieldsInfo(javaVM, clazz, fieldOffset, reducedCpuUtil, reducedFrequency);\n+\t} else if (clazz->hotFieldsInfo->hotFieldListLength < MAX_HOT_FIELD_LIST_LENGTH) {", "originalCommit": "b3913bcde1e052f5f913075f7ee045c10a01aef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxMDA0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472310043", "bodyText": "Yes I see I should not of moved that check.", "author": "jonoommen", "createdAt": "2020-08-18T16:04:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI2OTY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI3MDA2Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472270067", "bodyText": "you can add a label here releaseMutex:", "author": "tajila", "createdAt": "2020-08-18T15:08:07Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +583,124 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param clazz pointer to the class where a hot field should be added/updated\n+ * @param fieldOffset value of the field offset that should be added/updated as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/* exit if pools are null */\n+\tif (NULL == clazz->classLoader->hotFieldPool || NULL == javaVM->hotFieldClassInfoPool) {\n+\t\treturn;\n+\t}\n+\n+\t/* If hotFieldsInfo pool element for the class does not exist already, create and initialize the class' hotFieldsInfo pool element\n+\t * otherwise, create/update the given hot field for the class \n+\t */\n+\tif (NULL == clazz->hotFieldsInfo) {\n+\t\tcreateClassHotFieldsInfo(javaVM, clazz, fieldOffset, reducedCpuUtil, reducedFrequency);\n+\t} else if (clazz->hotFieldsInfo->hotFieldListLength < MAX_HOT_FIELD_LIST_LENGTH) {\n+\t\taddOrUpdateHotField(clazz, fieldOffset, reducedCpuUtil, reducedFrequency);\n+\t}\n+}\n+\n+/**\n+ * Create and initialize a class' hotFieldsInfo pool element.\n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+VMINLINE void\n+createClassHotFieldsInfo(J9JavaVM *javaVM, J9Class* clazz, U_8 fieldOffset, int32_t reducedCpuUtil, U_32 reducedFrequency)\n+{\n+\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\tif (NULL == clazz->hotFieldsInfo) {\n+\t\t/* initialize new hotFieldsInfo pool element as it does not exist already */\n+\t\tclazz->hotFieldsInfo = (J9ClassHotFieldsInfo *)pool_newElement(javaVM->hotFieldClassInfoPool);\n+\t\tif (NULL == clazz->hotFieldsInfo) {\n+\t\t\tgoto exit;\n+\t\t}\n+\t\tclazz->hotFieldsInfo->hotFieldListLength = 0;\n+\t\tclazz->hotFieldsInfo->consecutiveHotFieldSelections = 0;\n+\t\tclazz->hotFieldsInfo->hotFieldOffset1 = U_8_MAX;\n+\t\tclazz->hotFieldsInfo->hotFieldOffset2 = U_8_MAX;\n+\t\t\n+\t\t/* create and initialize the new hot field */\n+\t\tomrthread_monitor_enter(clazz->classLoader->hotFieldPoolMutex);\n+\t\tJ9HotField* newHotField = (J9HotField *)pool_newElement(clazz->classLoader->hotFieldPool);\n+\t\tif(NULL == newHotField) {\n+\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\tgoto exit;\n+\t\t}\n+\t\tnewHotField->next = NULL;\n+\t\tnewHotField->hotFieldOffset = fieldOffset;\n+\t\tnewHotField->hotness = (reducedFrequency * reducedCpuUtil);\n+\t\tnewHotField->cpuUtil = reducedCpuUtil;\n+\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\n+\t\t/* update hotFieldsInfo for the class now that a new hot field has been added */\n+\t\tclazz->hotFieldsInfo->hotFieldListHead = newHotField;\n+\t\tclazz->hotFieldsInfo->isClassHotFieldListDirty = true;\n+\t\tclazz->hotFieldsInfo->hotFieldListLength++;\n+\t\tclazz->hotFieldsInfo->classLoader = clazz->classLoader;\n+\t}\n+\t\n+exit:\n+\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+}\n+\n+/**\n+ * Add or update an existing hot field for a given class.\n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param clazz pointer to the class where a hot field should be added/updated\n+ * @param fieldOffset value of the field offset that should be added/updated as a hot field for the given class\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+VMINLINE void\n+addOrUpdateHotField(J9Class* clazz, U_8 fieldOffset, int32_t reducedCpuUtil, U_32 reducedFrequency)\n+{\n+\t/* Check if the hot field exists already */\n+\tJ9HotField* current;\n+\tcurrent = clazz->hotFieldsInfo->hotFieldListHead;\n+\tdo {\n+\t\tif (current->hotFieldOffset == fieldOffset) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tcurrent = current->next;\n+\t} while (NULL != current);\n+\n+\t/* if the hot field does not exist, create and initialize the new hot field, otherwise, update the hot field with the newly reported hot field information */\n+\tomrthread_monitor_enter(clazz->classLoader->hotFieldPoolMutex);\n+\tif (current == NULL) {\n+\t\tcurrent = (J9HotField *)pool_newElement(clazz->classLoader->hotFieldPool);\n+\t\tif (NULL == current) {\n+\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\treturn;\n+\t\t}\n+\t\tclazz->hotFieldsInfo->hotFieldListLength++;\n+\t\tcurrent->hotFieldOffset = fieldOffset;\n+\t\tcurrent->next = NULL;\n+\t}\n+\n+\tcurrent->hotness += (reducedFrequency * reducedCpuUtil);\n+\tcurrent->cpuUtil += reducedCpuUtil;\n+\tclazz->hotFieldsInfo->isClassHotFieldListDirty = true;\n+\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);", "originalCommit": "b3913bcde1e052f5f913075f7ee045c10a01aef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI3MDI1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472270255", "bodyText": "instead of return you can jump to release", "author": "tajila", "createdAt": "2020-08-18T15:08:23Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +583,124 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param clazz pointer to the class where a hot field should be added/updated\n+ * @param fieldOffset value of the field offset that should be added/updated as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/* exit if pools are null */\n+\tif (NULL == clazz->classLoader->hotFieldPool || NULL == javaVM->hotFieldClassInfoPool) {\n+\t\treturn;\n+\t}\n+\n+\t/* If hotFieldsInfo pool element for the class does not exist already, create and initialize the class' hotFieldsInfo pool element\n+\t * otherwise, create/update the given hot field for the class \n+\t */\n+\tif (NULL == clazz->hotFieldsInfo) {\n+\t\tcreateClassHotFieldsInfo(javaVM, clazz, fieldOffset, reducedCpuUtil, reducedFrequency);\n+\t} else if (clazz->hotFieldsInfo->hotFieldListLength < MAX_HOT_FIELD_LIST_LENGTH) {\n+\t\taddOrUpdateHotField(clazz, fieldOffset, reducedCpuUtil, reducedFrequency);\n+\t}\n+}\n+\n+/**\n+ * Create and initialize a class' hotFieldsInfo pool element.\n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+VMINLINE void\n+createClassHotFieldsInfo(J9JavaVM *javaVM, J9Class* clazz, U_8 fieldOffset, int32_t reducedCpuUtil, U_32 reducedFrequency)\n+{\n+\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\tif (NULL == clazz->hotFieldsInfo) {\n+\t\t/* initialize new hotFieldsInfo pool element as it does not exist already */\n+\t\tclazz->hotFieldsInfo = (J9ClassHotFieldsInfo *)pool_newElement(javaVM->hotFieldClassInfoPool);\n+\t\tif (NULL == clazz->hotFieldsInfo) {\n+\t\t\tgoto exit;\n+\t\t}\n+\t\tclazz->hotFieldsInfo->hotFieldListLength = 0;\n+\t\tclazz->hotFieldsInfo->consecutiveHotFieldSelections = 0;\n+\t\tclazz->hotFieldsInfo->hotFieldOffset1 = U_8_MAX;\n+\t\tclazz->hotFieldsInfo->hotFieldOffset2 = U_8_MAX;\n+\t\t\n+\t\t/* create and initialize the new hot field */\n+\t\tomrthread_monitor_enter(clazz->classLoader->hotFieldPoolMutex);\n+\t\tJ9HotField* newHotField = (J9HotField *)pool_newElement(clazz->classLoader->hotFieldPool);\n+\t\tif(NULL == newHotField) {\n+\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\tgoto exit;\n+\t\t}\n+\t\tnewHotField->next = NULL;\n+\t\tnewHotField->hotFieldOffset = fieldOffset;\n+\t\tnewHotField->hotness = (reducedFrequency * reducedCpuUtil);\n+\t\tnewHotField->cpuUtil = reducedCpuUtil;\n+\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\n+\t\t/* update hotFieldsInfo for the class now that a new hot field has been added */\n+\t\tclazz->hotFieldsInfo->hotFieldListHead = newHotField;\n+\t\tclazz->hotFieldsInfo->isClassHotFieldListDirty = true;\n+\t\tclazz->hotFieldsInfo->hotFieldListLength++;\n+\t\tclazz->hotFieldsInfo->classLoader = clazz->classLoader;\n+\t}\n+\t\n+exit:\n+\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+}\n+\n+/**\n+ * Add or update an existing hot field for a given class.\n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param clazz pointer to the class where a hot field should be added/updated\n+ * @param fieldOffset value of the field offset that should be added/updated as a hot field for the given class\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+VMINLINE void\n+addOrUpdateHotField(J9Class* clazz, U_8 fieldOffset, int32_t reducedCpuUtil, U_32 reducedFrequency)\n+{\n+\t/* Check if the hot field exists already */\n+\tJ9HotField* current;\n+\tcurrent = clazz->hotFieldsInfo->hotFieldListHead;\n+\tdo {\n+\t\tif (current->hotFieldOffset == fieldOffset) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tcurrent = current->next;\n+\t} while (NULL != current);\n+\n+\t/* if the hot field does not exist, create and initialize the new hot field, otherwise, update the hot field with the newly reported hot field information */\n+\tomrthread_monitor_enter(clazz->classLoader->hotFieldPoolMutex);\n+\tif (current == NULL) {\n+\t\tcurrent = (J9HotField *)pool_newElement(clazz->classLoader->hotFieldPool);\n+\t\tif (NULL == current) {\n+\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\treturn;", "originalCommit": "b3913bcde1e052f5f913075f7ee045c10a01aef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI3MjU5NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472272595", "bodyText": "same thing here, I would remove this code. Just make sure addOrUpdateHotField is called after", "author": "tajila", "createdAt": "2020-08-18T15:11:47Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +583,124 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param clazz pointer to the class where a hot field should be added/updated\n+ * @param fieldOffset value of the field offset that should be added/updated as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/* exit if pools are null */\n+\tif (NULL == clazz->classLoader->hotFieldPool || NULL == javaVM->hotFieldClassInfoPool) {\n+\t\treturn;\n+\t}\n+\n+\t/* If hotFieldsInfo pool element for the class does not exist already, create and initialize the class' hotFieldsInfo pool element\n+\t * otherwise, create/update the given hot field for the class \n+\t */\n+\tif (NULL == clazz->hotFieldsInfo) {\n+\t\tcreateClassHotFieldsInfo(javaVM, clazz, fieldOffset, reducedCpuUtil, reducedFrequency);\n+\t} else if (clazz->hotFieldsInfo->hotFieldListLength < MAX_HOT_FIELD_LIST_LENGTH) {\n+\t\taddOrUpdateHotField(clazz, fieldOffset, reducedCpuUtil, reducedFrequency);\n+\t}\n+}\n+\n+/**\n+ * Create and initialize a class' hotFieldsInfo pool element.\n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+VMINLINE void\n+createClassHotFieldsInfo(J9JavaVM *javaVM, J9Class* clazz, U_8 fieldOffset, int32_t reducedCpuUtil, U_32 reducedFrequency)\n+{\n+\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\tif (NULL == clazz->hotFieldsInfo) {\n+\t\t/* initialize new hotFieldsInfo pool element as it does not exist already */\n+\t\tclazz->hotFieldsInfo = (J9ClassHotFieldsInfo *)pool_newElement(javaVM->hotFieldClassInfoPool);\n+\t\tif (NULL == clazz->hotFieldsInfo) {\n+\t\t\tgoto exit;\n+\t\t}\n+\t\tclazz->hotFieldsInfo->hotFieldListLength = 0;\n+\t\tclazz->hotFieldsInfo->consecutiveHotFieldSelections = 0;\n+\t\tclazz->hotFieldsInfo->hotFieldOffset1 = U_8_MAX;\n+\t\tclazz->hotFieldsInfo->hotFieldOffset2 = U_8_MAX;\n+\t\t\n+\t\t/* create and initialize the new hot field */\n+\t\tomrthread_monitor_enter(clazz->classLoader->hotFieldPoolMutex);", "originalCommit": "b3913bcde1e052f5f913075f7ee045c10a01aef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMyNTIxOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472325219", "bodyText": "The issue with doing this would be that the addOrUpdateHotField  method does not handle setting the clazz->hotFieldsInfo->hotFieldListHead. If addOrUpdateHotField was modified to handle the setting of the hotfield list head, then the hotFieldClassInfoPoolMutex would need to be acquired in addOrUpdateHotField method as well to handle this case which would add lock contention. Is this desired over this code duplication?", "author": "jonoommen", "createdAt": "2020-08-18T16:28:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI3MjU5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM1OTAwMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472359001", "bodyText": "Strictly speaking, you only need the hotFieldClassInfoPoolMutex  for allocating the  hotFieldsInfo. As long as hotFieldListHead is only ever updated while hotFieldPoolMutex is held then there is no problem setting hotFieldListHead in addOrUpdateHotField without acquiring hotFieldClassInfoPoolMutex.", "author": "tajila", "createdAt": "2020-08-18T17:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI3MjU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI4MDEwMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472280102", "bodyText": "you  should return a success/failure return code, if this fails do not attempt addOrUpdateHotField", "author": "tajila", "createdAt": "2020-08-18T15:22:18Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +583,124 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param clazz pointer to the class where a hot field should be added/updated\n+ * @param fieldOffset value of the field offset that should be added/updated as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/* exit if pools are null */\n+\tif (NULL == clazz->classLoader->hotFieldPool || NULL == javaVM->hotFieldClassInfoPool) {\n+\t\treturn;\n+\t}\n+\n+\t/* If hotFieldsInfo pool element for the class does not exist already, create and initialize the class' hotFieldsInfo pool element\n+\t * otherwise, create/update the given hot field for the class \n+\t */\n+\tif (NULL == clazz->hotFieldsInfo) {\n+\t\tcreateClassHotFieldsInfo(javaVM, clazz, fieldOffset, reducedCpuUtil, reducedFrequency);\n+\t} else if (clazz->hotFieldsInfo->hotFieldListLength < MAX_HOT_FIELD_LIST_LENGTH) {\n+\t\taddOrUpdateHotField(clazz, fieldOffset, reducedCpuUtil, reducedFrequency);\n+\t}\n+}\n+\n+/**\n+ * Create and initialize a class' hotFieldsInfo pool element.\n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+VMINLINE void", "originalCommit": "b3913bcde1e052f5f913075f7ee045c10a01aef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ5Mjc4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472492781", "bodyText": "Based on our discussion I will mark this as resolved as we decided that we will not set any error/success return code.", "author": "jonoommen", "createdAt": "2020-08-18T21:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI4MDEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI4MDI4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472280282", "bodyText": "should set err return code", "author": "tajila", "createdAt": "2020-08-18T15:22:33Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +583,124 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param clazz pointer to the class where a hot field should be added/updated\n+ * @param fieldOffset value of the field offset that should be added/updated as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/* exit if pools are null */\n+\tif (NULL == clazz->classLoader->hotFieldPool || NULL == javaVM->hotFieldClassInfoPool) {\n+\t\treturn;\n+\t}\n+\n+\t/* If hotFieldsInfo pool element for the class does not exist already, create and initialize the class' hotFieldsInfo pool element\n+\t * otherwise, create/update the given hot field for the class \n+\t */\n+\tif (NULL == clazz->hotFieldsInfo) {\n+\t\tcreateClassHotFieldsInfo(javaVM, clazz, fieldOffset, reducedCpuUtil, reducedFrequency);\n+\t} else if (clazz->hotFieldsInfo->hotFieldListLength < MAX_HOT_FIELD_LIST_LENGTH) {\n+\t\taddOrUpdateHotField(clazz, fieldOffset, reducedCpuUtil, reducedFrequency);\n+\t}\n+}\n+\n+/**\n+ * Create and initialize a class' hotFieldsInfo pool element.\n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+VMINLINE void\n+createClassHotFieldsInfo(J9JavaVM *javaVM, J9Class* clazz, U_8 fieldOffset, int32_t reducedCpuUtil, U_32 reducedFrequency)\n+{\n+\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\tif (NULL == clazz->hotFieldsInfo) {\n+\t\t/* initialize new hotFieldsInfo pool element as it does not exist already */\n+\t\tclazz->hotFieldsInfo = (J9ClassHotFieldsInfo *)pool_newElement(javaVM->hotFieldClassInfoPool);\n+\t\tif (NULL == clazz->hotFieldsInfo) {\n+\t\t\tgoto exit;", "originalCommit": "b3913bcde1e052f5f913075f7ee045c10a01aef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ5MjY2Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472492662", "bodyText": "Based on our discussion I will mark this as resolved as we decided that we will not set any error return code.", "author": "jonoommen", "createdAt": "2020-08-18T21:05:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI4MDI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI4MTI4NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472281285", "bodyText": "might be worth to return a success/err return code here as well. This way you can propogate the err to the JIT thread if you decide to do something with that info (ie. how does JIT deal with alloc failures).\nAll allocation failures should set the err.", "author": "tajila", "createdAt": "2020-08-18T15:23:48Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +583,124 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param clazz pointer to the class where a hot field should be added/updated\n+ * @param fieldOffset value of the field offset that should be added/updated as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/* exit if pools are null */\n+\tif (NULL == clazz->classLoader->hotFieldPool || NULL == javaVM->hotFieldClassInfoPool) {\n+\t\treturn;\n+\t}\n+\n+\t/* If hotFieldsInfo pool element for the class does not exist already, create and initialize the class' hotFieldsInfo pool element\n+\t * otherwise, create/update the given hot field for the class \n+\t */\n+\tif (NULL == clazz->hotFieldsInfo) {\n+\t\tcreateClassHotFieldsInfo(javaVM, clazz, fieldOffset, reducedCpuUtil, reducedFrequency);\n+\t} else if (clazz->hotFieldsInfo->hotFieldListLength < MAX_HOT_FIELD_LIST_LENGTH) {\n+\t\taddOrUpdateHotField(clazz, fieldOffset, reducedCpuUtil, reducedFrequency);\n+\t}\n+}\n+\n+/**\n+ * Create and initialize a class' hotFieldsInfo pool element.\n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+VMINLINE void\n+createClassHotFieldsInfo(J9JavaVM *javaVM, J9Class* clazz, U_8 fieldOffset, int32_t reducedCpuUtil, U_32 reducedFrequency)\n+{\n+\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\tif (NULL == clazz->hotFieldsInfo) {\n+\t\t/* initialize new hotFieldsInfo pool element as it does not exist already */\n+\t\tclazz->hotFieldsInfo = (J9ClassHotFieldsInfo *)pool_newElement(javaVM->hotFieldClassInfoPool);\n+\t\tif (NULL == clazz->hotFieldsInfo) {\n+\t\t\tgoto exit;\n+\t\t}\n+\t\tclazz->hotFieldsInfo->hotFieldListLength = 0;\n+\t\tclazz->hotFieldsInfo->consecutiveHotFieldSelections = 0;\n+\t\tclazz->hotFieldsInfo->hotFieldOffset1 = U_8_MAX;\n+\t\tclazz->hotFieldsInfo->hotFieldOffset2 = U_8_MAX;\n+\t\t\n+\t\t/* create and initialize the new hot field */\n+\t\tomrthread_monitor_enter(clazz->classLoader->hotFieldPoolMutex);\n+\t\tJ9HotField* newHotField = (J9HotField *)pool_newElement(clazz->classLoader->hotFieldPool);\n+\t\tif(NULL == newHotField) {\n+\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\tgoto exit;\n+\t\t}\n+\t\tnewHotField->next = NULL;\n+\t\tnewHotField->hotFieldOffset = fieldOffset;\n+\t\tnewHotField->hotness = (reducedFrequency * reducedCpuUtil);\n+\t\tnewHotField->cpuUtil = reducedCpuUtil;\n+\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\n+\t\t/* update hotFieldsInfo for the class now that a new hot field has been added */\n+\t\tclazz->hotFieldsInfo->hotFieldListHead = newHotField;\n+\t\tclazz->hotFieldsInfo->isClassHotFieldListDirty = true;\n+\t\tclazz->hotFieldsInfo->hotFieldListLength++;\n+\t\tclazz->hotFieldsInfo->classLoader = clazz->classLoader;\n+\t}\n+\t\n+exit:\n+\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+}\n+\n+/**\n+ * Add or update an existing hot field for a given class.\n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param clazz pointer to the class where a hot field should be added/updated\n+ * @param fieldOffset value of the field offset that should be added/updated as a hot field for the given class\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+VMINLINE void", "originalCommit": "b3913bcde1e052f5f913075f7ee045c10a01aef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3NDA5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472374091", "bodyText": "Ok. Shall I will do the basic -1 on failure and 1 on success as I see done in several places in the JIT @andrewcraik?", "author": "jonoommen", "createdAt": "2020-08-18T17:46:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI4MTI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3NzkyOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472377929", "bodyText": "You should use whatever signalling mechanism is most sensible. For the JIT because the data is all optional you can just skip populating the data right? The VM is probably not long for this world with an OOM looming, but there is no reason to abort the compile or bring down the VM - this is a purely optional activity...", "author": "andrewcraik", "createdAt": "2020-08-18T17:53:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI4MTI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQxMTgxMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472411811", "bodyText": "@tajila would you prefer I leave it to return void or from a VM perspective would you like that I return a success/error return code?", "author": "jonoommen", "createdAt": "2020-08-18T18:54:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI4MTI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQyMTI0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472421243", "bodyText": "Based on Andrew's answer you can leave it as void since reporting is optional. You just need to add a null check in addOrUpdateHotField for clazz->hotFieldsInfo.", "author": "tajila", "createdAt": "2020-08-18T19:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI4MTI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM2MDA0NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472360044", "bodyText": "you still need previous because when you are allocating a new one you need to add it to the list", "author": "tajila", "createdAt": "2020-08-18T17:23:11Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +583,124 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param clazz pointer to the class where a hot field should be added/updated\n+ * @param fieldOffset value of the field offset that should be added/updated as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/* exit if pools are null */\n+\tif (NULL == clazz->classLoader->hotFieldPool || NULL == javaVM->hotFieldClassInfoPool) {\n+\t\treturn;\n+\t}\n+\n+\t/* If hotFieldsInfo pool element for the class does not exist already, create and initialize the class' hotFieldsInfo pool element\n+\t * otherwise, create/update the given hot field for the class \n+\t */\n+\tif (NULL == clazz->hotFieldsInfo) {\n+\t\tcreateClassHotFieldsInfo(javaVM, clazz, fieldOffset, reducedCpuUtil, reducedFrequency);\n+\t} else if (clazz->hotFieldsInfo->hotFieldListLength < MAX_HOT_FIELD_LIST_LENGTH) {\n+\t\taddOrUpdateHotField(clazz, fieldOffset, reducedCpuUtil, reducedFrequency);\n+\t}\n+}\n+\n+/**\n+ * Create and initialize a class' hotFieldsInfo pool element.\n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+VMINLINE void\n+createClassHotFieldsInfo(J9JavaVM *javaVM, J9Class* clazz, U_8 fieldOffset, int32_t reducedCpuUtil, U_32 reducedFrequency)\n+{\n+\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\tif (NULL == clazz->hotFieldsInfo) {\n+\t\t/* initialize new hotFieldsInfo pool element as it does not exist already */\n+\t\tclazz->hotFieldsInfo = (J9ClassHotFieldsInfo *)pool_newElement(javaVM->hotFieldClassInfoPool);\n+\t\tif (NULL == clazz->hotFieldsInfo) {\n+\t\t\tgoto exit;\n+\t\t}\n+\t\tclazz->hotFieldsInfo->hotFieldListLength = 0;\n+\t\tclazz->hotFieldsInfo->consecutiveHotFieldSelections = 0;\n+\t\tclazz->hotFieldsInfo->hotFieldOffset1 = U_8_MAX;\n+\t\tclazz->hotFieldsInfo->hotFieldOffset2 = U_8_MAX;\n+\t\t\n+\t\t/* create and initialize the new hot field */\n+\t\tomrthread_monitor_enter(clazz->classLoader->hotFieldPoolMutex);\n+\t\tJ9HotField* newHotField = (J9HotField *)pool_newElement(clazz->classLoader->hotFieldPool);\n+\t\tif(NULL == newHotField) {\n+\t\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\tgoto exit;\n+\t\t}\n+\t\tnewHotField->next = NULL;\n+\t\tnewHotField->hotFieldOffset = fieldOffset;\n+\t\tnewHotField->hotness = (reducedFrequency * reducedCpuUtil);\n+\t\tnewHotField->cpuUtil = reducedCpuUtil;\n+\t\tomrthread_monitor_exit(clazz->classLoader->hotFieldPoolMutex);\n+\t\t\n+\t\t/* update hotFieldsInfo for the class now that a new hot field has been added */\n+\t\tclazz->hotFieldsInfo->hotFieldListHead = newHotField;\n+\t\tclazz->hotFieldsInfo->isClassHotFieldListDirty = true;\n+\t\tclazz->hotFieldsInfo->hotFieldListLength++;\n+\t\tclazz->hotFieldsInfo->classLoader = clazz->classLoader;\n+\t}\n+\t\n+exit:\n+\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+}\n+\n+/**\n+ * Add or update an existing hot field for a given class.\n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param clazz pointer to the class where a hot field should be added/updated\n+ * @param fieldOffset value of the field offset that should be added/updated as a hot field for the given class\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+VMINLINE void\n+addOrUpdateHotField(J9Class* clazz, U_8 fieldOffset, int32_t reducedCpuUtil, U_32 reducedFrequency)\n+{\n+\t/* Check if the hot field exists already */\n+\tJ9HotField* current;\n+\tcurrent = clazz->hotFieldsInfo->hotFieldListHead;", "originalCommit": "b3913bcde1e052f5f913075f7ee045c10a01aef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM2MDcyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472360721", "bodyText": "if previous is NULL, that is a signal that you need to set the hotFieldListHead instead", "author": "tajila", "createdAt": "2020-08-18T17:24:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM2MDA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQyMjY1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r472422656", "bodyText": "Might be worth making this a commandline param so it can be toggled if you feel that varying the number of hotfields may be preferable in certain apps", "author": "tajila", "createdAt": "2020-08-18T19:15:19Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -36,6 +36,9 @@\n /* Extra hidden fields are lockword and finalizeLink. */\n #define NUMBER_OF_EXTRA_HIDDEN_FIELDS 2\n \n+/* Max hot field list length allowed for a class if scavenger dynamicBreadthScanOrdering is enabled */\n+#define MAX_HOT_FIELD_LIST_LENGTH 10", "originalCommit": "b3913bcde1e052f5f913075f7ee045c10a01aef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgwMjE3MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r475802170", "bodyText": "try to avoid multiple returns", "author": "tajila", "createdAt": "2020-08-24T18:10:35Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +582,162 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param clazz pointer to the class where a hot field should be added/updated\n+ * @param fieldOffset value of the field offset that should be added/updated as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/*\n+\t * Exit if the hotFieldClassInfoPool is NULL as it should of been initialized during jvm initialization\n+\t */\n+\tif (NULL == javaVM->hotFieldClassInfoPool) {\n+\t\treturn;", "originalCommit": "0804ef91b79504fc892c8c37d2bf66cb68bc0d79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgwMjczMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r475802731", "bodyText": "you can embed the if statements", "author": "tajila", "createdAt": "2020-08-24T18:11:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgwMjE3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgwMjQ1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r475802456", "bodyText": "do the explicit false == createClassLoaderHotFieldPool", "author": "tajila", "createdAt": "2020-08-24T18:11:09Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +582,162 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param clazz pointer to the class where a hot field should be added/updated\n+ * @param fieldOffset value of the field offset that should be added/updated as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/*\n+\t * Exit if the hotFieldClassInfoPool is NULL as it should of been initialized during jvm initialization\n+\t */\n+\tif (NULL == javaVM->hotFieldClassInfoPool) {\n+\t\treturn;\n+\t}\n+\t/* \n+\t * If the classLoader's hot field pool is null, create and initialize its hotFieldPool and hotFieldPoolMutex as it is required\n+\t * for each classLoader if scavenger dynamicBreadthFirstScanOrdering is enabled\n+\t */\n+\tif(NULL == clazz->classLoader->hotFieldPool && !createClassLoaderHotFieldPool(javaVM, clazz->classLoader)) {", "originalCommit": "0804ef91b79504fc892c8c37d2bf66cb68bc0d79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgwMzAxOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r475803018", "bodyText": "also pay attention to the spacing if (", "author": "tajila", "createdAt": "2020-08-24T18:12:16Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +582,162 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param clazz pointer to the class where a hot field should be added/updated\n+ * @param fieldOffset value of the field offset that should be added/updated as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/*\n+\t * Exit if the hotFieldClassInfoPool is NULL as it should of been initialized during jvm initialization\n+\t */\n+\tif (NULL == javaVM->hotFieldClassInfoPool) {\n+\t\treturn;\n+\t}\n+\t/* \n+\t * If the classLoader's hot field pool is null, create and initialize its hotFieldPool and hotFieldPoolMutex as it is required\n+\t * for each classLoader if scavenger dynamicBreadthFirstScanOrdering is enabled\n+\t */\n+\tif(NULL == clazz->classLoader->hotFieldPool && !createClassLoaderHotFieldPool(javaVM, clazz->classLoader)) {", "originalCommit": "0804ef91b79504fc892c8c37d2bf66cb68bc0d79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgwMzUzNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r475803537", "bodyText": "this should start at the beginning of the line", "author": "tajila", "createdAt": "2020-08-24T18:13:18Z", "path": "runtime/vm/resolvefield.cpp", "diffHunk": "@@ -578,6 +582,162 @@ addHiddenInstanceField(J9JavaVM *vm, const char *className, const char *fieldNam\n \treturn 0;\n }\n \n+/**\n+ * Report a hot field if the JIT has determined that the field has met appropriate thresholds to be determined a hot field. \n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param clazz pointer to the class where a hot field should be added/updated\n+ * @param fieldOffset value of the field offset that should be added/updated as a hot field for the given class\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+void\n+reportHotField(J9JavaVM *javaVM, int32_t reducedCpuUtil, J9Class* clazz, U_8 fieldOffset,  U_32 reducedFrequency)\n+{\n+\t/*\n+\t * Exit if the hotFieldClassInfoPool is NULL as it should of been initialized during jvm initialization\n+\t */\n+\tif (NULL == javaVM->hotFieldClassInfoPool) {\n+\t\treturn;\n+\t}\n+\t/* \n+\t * If the classLoader's hot field pool is null, create and initialize its hotFieldPool and hotFieldPoolMutex as it is required\n+\t * for each classLoader if scavenger dynamicBreadthFirstScanOrdering is enabled\n+\t */\n+\tif(NULL == clazz->classLoader->hotFieldPool && !createClassLoaderHotFieldPool(javaVM, clazz->classLoader)) {\n+\t\treturn;\n+\t}\n+\t/* \n+\t * If the hotFieldsInfo pool element for the class does not exist already, create and initialize the class' hotFieldsInfo pool element\n+\t * otherwise, create/update the given hot field for the class\n+\t */\n+\tif (NULL == clazz->hotFieldsInfo) {\n+\t\tcreateClassHotFieldsInfo(javaVM, clazz, fieldOffset, reducedCpuUtil, reducedFrequency);\n+\t}\n+\taddOrUpdateHotField(javaVM, clazz, fieldOffset, reducedCpuUtil, reducedFrequency);\n+}\n+\n+/**\n+ * Create and initialize a classLoaders hot field pool and hot field pool monitor.\n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param classLoader pointer to the classLoader that requires a hot field pool and hot field monitor to be created for it\n+ */\n+VMINLINE bool\n+createClassLoaderHotFieldPool(J9JavaVM *javaVM, J9ClassLoader* classLoader)\n+{\n+\tbool result = true;\n+\tomrthread_monitor_enter(javaVM->globalHotFieldPoolMutex);\n+\tif (NULL == classLoader->hotFieldPool) {\n+\t\tclassLoader->hotFieldPool = pool_new(sizeof(J9HotField),  0, 0, 0, J9_GET_CALLSITE(), J9MEM_CATEGORY_CLASSES, POOL_FOR_PORT(javaVM->portLibrary));\n+\t\tif (NULL == classLoader->hotFieldPool || (0 != omrthread_monitor_init_with_name(&classLoader->hotFieldPoolMutex, 0, \"Hot Field Pool\"))) {\n+\t\t\tresult = false;\n+\t\t}\n+\t}\n+\tomrthread_monitor_exit(javaVM->globalHotFieldPoolMutex);\n+\treturn result;\n+}\n+\n+/**\n+ * Create and initialize a class' hotFieldsInfo pool element.\n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ * @param clazz pointer to the class where a hot field should be added\n+ * @param fieldOffset value of the field offset that should be added as a hot field for the given class\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+VMINLINE void\n+createClassHotFieldsInfo(J9JavaVM *javaVM, J9Class* clazz, U_8 fieldOffset, int32_t reducedCpuUtil, U_32 reducedFrequency)\n+{\n+\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\t/*\n+\t* Create and initialize new hotFieldsInfo pool element if it does not exist already.\n+\t*/\n+\tif (NULL == clazz->hotFieldsInfo) {\n+\t\tJ9ClassHotFieldsInfo* hotFieldsInfo = (J9ClassHotFieldsInfo *)pool_newElement(javaVM->hotFieldClassInfoPool);\n+\t\tif (NULL != hotFieldsInfo) {\n+\t\t\thotFieldsInfo->hotFieldListLength = 0;\n+\t\t\thotFieldsInfo->consecutiveHotFieldSelections = 0;\n+\t\t\thotFieldsInfo->hotFieldOffset1 = U_8_MAX;\n+\t\t\thotFieldsInfo->hotFieldOffset2 = U_8_MAX;\n+\t\t\thotFieldsInfo->classLoader = clazz->classLoader;\n+\t\t\tclazz->hotFieldsInfo = hotFieldsInfo;\n+\t\t}\n+\t}\n+\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+}\n+\n+/**\n+ * Add or update an existing hot field for a given class.\n+ * Valid if dynamicBreadthFirstScanOrdering is enabled.\n+ *\n+ * @param clazz pointer to the class where a hot field should be added/updated\n+ * @param fieldOffset value of the field offset that should be added/updated as a hot field for the given class\n+ * @param reducedCpuUtil normalized cpu utilization of the method reporting the hot field\n+ * @param reducedFrequency normalized block frequency of the hot field for the method reporting the hot field\n+ */\n+VMINLINE void\n+addOrUpdateHotField(J9JavaVM *javaVM, J9Class* clazz, U_8 fieldOffset, int32_t reducedCpuUtil, U_32 reducedFrequency)\n+{\n+\tif (NULL != clazz->hotFieldsInfo) {\n+\t\tJ9ClassHotFieldsInfo* hotFieldsInfo = clazz->hotFieldsInfo;\n+\t\tJ9ClassLoader* classLoader = clazz->classLoader;\n+\t\tomrthread_monitor_enter(classLoader->hotFieldPoolMutex);\t\t\n+\t\t/* \n+\t\t * Search the hot field list of the class to check if the hot field exists already\n+\t\t */\n+\t\tJ9HotField* previous = NULL;\n+\t\tJ9HotField* current = hotFieldsInfo->hotFieldListHead;\n+\t\twhile (NULL != current) {\n+\t\t\tif (current->hotFieldOffset == fieldOffset) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tprevious = current;\n+\t\t\tcurrent = current->next;\n+\t\t}\n+\t\t/* \n+\t\t * If the hot field does not exist, create and initialize the new hot field.\n+\t\t */\n+\t\tif (current == NULL) {\n+\t\t\tif (hotFieldsInfo->hotFieldListLength >= javaVM->memoryManagerFunctions->j9gc_max_hot_field_list_length(javaVM)) {\n+\t\t\t\tgoto releaseMutex;\n+\t\t\t} else {\n+\t\t\t\tcurrent = (J9HotField *)pool_newElement(classLoader->hotFieldPool);\n+\t\t\t\tif (NULL == current) {\n+\t\t\t\t\tgoto releaseMutex;\n+\t\t\t\t}\n+\t\t\t\thotFieldsInfo->hotFieldListLength++;\n+\t\t\t\tcurrent->hotFieldOffset = fieldOffset;\n+\t\t\t\tcurrent->hotness = 0;\n+\t\t\t\tcurrent->cpuUtil = 0;\n+\t\t\t\tcurrent->next = NULL;\n+\t\t\t}\n+\t\t}\n+\t\t/*\n+\t\t * Update the existing or newly created hot field with the newly reported hot field information.\n+\t\t */\n+\t\tcurrent->hotness += (reducedFrequency * reducedCpuUtil);\n+\t\tcurrent->cpuUtil += reducedCpuUtil;\n+\t\thotFieldsInfo->isClassHotFieldListDirty = true;\t\t\n+\t\t/* \n+\t\t * Initialize hotFieldListHead if the hotFieldList for the class is empty - this is the case if the previous pointer is NULL. \n+\t\t * Otherwise, add the new hot field to the end of the hot field list for the class.\n+\t\t */\n+\t\tif (NULL == previous) {\n+\t\t\thotFieldsInfo->hotFieldListHead = current;\n+\t\t} else {\n+\t\t\tprevious->next = current;\n+\t\t}\n+\n+\treleaseMutex:", "originalCommit": "0804ef91b79504fc892c8c37d2bf66cb68bc0d79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgwNTY5MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r475805690", "bodyText": "unnecessary whitespace", "author": "tajila", "createdAt": "2020-08-24T18:15:18Z", "path": "runtime/vm/classallocation.c", "diffHunk": "@@ -173,6 +173,7 @@ allocateClassLoader(J9JavaVM *javaVM)\n \t\t/* memset not required as the classLoaderBlocks pool returns zero'd memory */\n \n \t\tclassLoader->classHashTable = hashClassTableNew(javaVM, INITIAL_CLASSHASHTABLE_SIZE);\n+\t\t", "originalCommit": "0804ef91b79504fc892c8c37d2bf66cb68bc0d79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgzOTAyNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r475839024", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tif (_javaVM->hotFieldClassInfoPool != NULL && ((_extensions->scavengerStats._gcCount  % _extensions->gcCountBetweenHotFieldSort) == 0)) {\n          \n          \n            \n            \tif ((NULL != _javaVM->hotFieldClassInfoPool) && ((_extensions->scavengerStats._gcCount  % _extensions->gcCountBetweenHotFieldSort) == 0)) {", "author": "amicic", "createdAt": "2020-08-24T19:17:56Z", "path": "runtime/gc_glue_java/ScavengerDelegate.cpp", "diffHunk": "@@ -648,6 +656,104 @@ MM_ScavengerDelegate::private_shouldPercolateGarbageCollect_classUnloading(MM_En\n \treturn shouldGCPercolate;\n }\n \n+void\n+MM_ScavengerDelegate::private_SortAllHotField()\n+{\t\n+\t/* update hottest fields for all elements of the hotFieldClassInfoPool where isClassHotFieldListDirty is true */\n+\tif (_javaVM->hotFieldClassInfoPool != NULL && ((_extensions->scavengerStats._gcCount  % _extensions->gcCountBetweenHotFieldSort) == 0)) {", "originalCommit": "0804ef91b79504fc892c8c37d2bf66cb68bc0d79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgzOTI3OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r475839278", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\twhile (NULL != hotFieldClassInfoTemp && hotFieldClassInfoTemp->consecutiveHotFieldSelections != U_8_MAX) {\n          \n          \n            \n            \t\twhile ((NULL != hotFieldClassInfoTemp) && (U_8_MAX != hotFieldClassInfoTemp->consecutiveHotFieldSelections)) {", "author": "amicic", "createdAt": "2020-08-24T19:18:30Z", "path": "runtime/gc_glue_java/ScavengerDelegate.cpp", "diffHunk": "@@ -648,6 +656,104 @@ MM_ScavengerDelegate::private_shouldPercolateGarbageCollect_classUnloading(MM_En\n \treturn shouldGCPercolate;\n }\n \n+void\n+MM_ScavengerDelegate::private_SortAllHotField()\n+{\t\n+\t/* update hottest fields for all elements of the hotFieldClassInfoPool where isClassHotFieldListDirty is true */\n+\tif (_javaVM->hotFieldClassInfoPool != NULL && ((_extensions->scavengerStats._gcCount  % _extensions->gcCountBetweenHotFieldSort) == 0)) {\n+\t\tpool_state hotFieldClassInfoPoolState;\n+\t\tomrthread_monitor_enter(_javaVM->hotFieldClassInfoPoolMutex);\n+\t\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp = (J9ClassHotFieldsInfo *)pool_startDo(_javaVM->hotFieldClassInfoPool, &hotFieldClassInfoPoolState);\n+\t\t\n+\t\t/* sort hot field list for the class if the hot field list of the class is dirty */\n+\t\twhile (NULL != hotFieldClassInfoTemp && hotFieldClassInfoTemp->consecutiveHotFieldSelections != U_8_MAX) {", "originalCommit": "0804ef91b79504fc892c8c37d2bf66cb68bc0d79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgzOTcwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r475839707", "bodyText": "please add a couple of more extra oval brackets", "author": "amicic", "createdAt": "2020-08-24T19:19:20Z", "path": "runtime/gc_glue_java/ScavengerDelegate.cpp", "diffHunk": "@@ -648,6 +656,104 @@ MM_ScavengerDelegate::private_shouldPercolateGarbageCollect_classUnloading(MM_En\n \treturn shouldGCPercolate;\n }\n \n+void\n+MM_ScavengerDelegate::private_SortAllHotField()\n+{\t\n+\t/* update hottest fields for all elements of the hotFieldClassInfoPool where isClassHotFieldListDirty is true */\n+\tif (_javaVM->hotFieldClassInfoPool != NULL && ((_extensions->scavengerStats._gcCount  % _extensions->gcCountBetweenHotFieldSort) == 0)) {\n+\t\tpool_state hotFieldClassInfoPoolState;\n+\t\tomrthread_monitor_enter(_javaVM->hotFieldClassInfoPoolMutex);\n+\t\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp = (J9ClassHotFieldsInfo *)pool_startDo(_javaVM->hotFieldClassInfoPool, &hotFieldClassInfoPoolState);\n+\t\t\n+\t\t/* sort hot field list for the class if the hot field list of the class is dirty */\n+\t\twhile (NULL != hotFieldClassInfoTemp && hotFieldClassInfoTemp->consecutiveHotFieldSelections != U_8_MAX) {\n+\t\t\tif (hotFieldClassInfoTemp->isClassHotFieldListDirty) {\n+\t\t\t\tprivate_SortClassHotFieldList(hotFieldClassInfoTemp);\n+\t\t\t}\n+\t\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_nextDo(&hotFieldClassInfoPoolState);\n+\t\t}\n+\t\tomrthread_monitor_exit(_javaVM->hotFieldClassInfoPoolMutex);\n+\t}\n+\t/* If adaptiveGcCountBetweenHotFieldSort, update the gc count required between sorting all hot fields as the application runs longer */\n+\tif (_extensions->adaptiveGcCountBetweenHotFieldSort && _extensions->gcCountBetweenHotFieldSort < _extensions->gcCountBetweenHotFieldSortMax && _extensions->scavengerStats._gcCount % INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT == 0) {", "originalCommit": "0804ef91b79504fc892c8c37d2bf66cb68bc0d79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgzOTgwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r475839807", "bodyText": "brackets", "author": "amicic", "createdAt": "2020-08-24T19:19:32Z", "path": "runtime/gc_glue_java/ScavengerDelegate.cpp", "diffHunk": "@@ -648,6 +656,104 @@ MM_ScavengerDelegate::private_shouldPercolateGarbageCollect_classUnloading(MM_En\n \treturn shouldGCPercolate;\n }\n \n+void\n+MM_ScavengerDelegate::private_SortAllHotField()\n+{\t\n+\t/* update hottest fields for all elements of the hotFieldClassInfoPool where isClassHotFieldListDirty is true */\n+\tif (_javaVM->hotFieldClassInfoPool != NULL && ((_extensions->scavengerStats._gcCount  % _extensions->gcCountBetweenHotFieldSort) == 0)) {\n+\t\tpool_state hotFieldClassInfoPoolState;\n+\t\tomrthread_monitor_enter(_javaVM->hotFieldClassInfoPoolMutex);\n+\t\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp = (J9ClassHotFieldsInfo *)pool_startDo(_javaVM->hotFieldClassInfoPool, &hotFieldClassInfoPoolState);\n+\t\t\n+\t\t/* sort hot field list for the class if the hot field list of the class is dirty */\n+\t\twhile (NULL != hotFieldClassInfoTemp && hotFieldClassInfoTemp->consecutiveHotFieldSelections != U_8_MAX) {\n+\t\t\tif (hotFieldClassInfoTemp->isClassHotFieldListDirty) {\n+\t\t\t\tprivate_SortClassHotFieldList(hotFieldClassInfoTemp);\n+\t\t\t}\n+\t\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_nextDo(&hotFieldClassInfoPoolState);\n+\t\t}\n+\t\tomrthread_monitor_exit(_javaVM->hotFieldClassInfoPoolMutex);\n+\t}\n+\t/* If adaptiveGcCountBetweenHotFieldSort, update the gc count required between sorting all hot fields as the application runs longer */\n+\tif (_extensions->adaptiveGcCountBetweenHotFieldSort && _extensions->gcCountBetweenHotFieldSort < _extensions->gcCountBetweenHotFieldSortMax && _extensions->scavengerStats._gcCount % INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT == 0) {\n+\t\t_extensions->gcCountBetweenHotFieldSort++;\n+\t}\n+\t/* If hotFieldResettingEnabled, update the gc count required between resetting all hot fields */\n+\tif (_extensions->hotFieldResettingEnabled && _extensions->scavengerStats._gcCount % _extensions->gcCountBetweenHotFieldReset == 0) {", "originalCommit": "0804ef91b79504fc892c8c37d2bf66cb68bc0d79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg0MDM1NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r475840354", "bodyText": "as per coding standards, we keep the constant first:\nMM_GCExtensions::OMR_GC_SCAVENGER_SCANORDERING_DYNAMIC_BREADTH_FIRST == _extensions->scavengerScanOrdering", "author": "amicic", "createdAt": "2020-08-24T19:20:38Z", "path": "runtime/gc_glue_java/ScavengerDelegate.cpp", "diffHunk": "@@ -180,6 +183,11 @@ MM_ScavengerDelegate::mainSetupForGC(MM_EnvironmentBase * envBase)\n \n \tprivate_setupForOwnableSynchronizerProcessing(MM_EnvironmentStandard::getEnvironment(envBase));\n \n+\t/* Sort all hot fields for all classes if scavenger dynamicBreadthFirstScanOrdering is enabled */\n+\tif (_extensions->scavengerScanOrdering == MM_GCExtensions::OMR_GC_SCAVENGER_SCANORDERING_DYNAMIC_BREADTH_FIRST) {", "originalCommit": "0804ef91b79504fc892c8c37d2bf66cb68bc0d79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg0MDUxMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r475840510", "bodyText": "constant first", "author": "amicic", "createdAt": "2020-08-24T19:20:58Z", "path": "runtime/gc_glue_java/ScavengerDelegate.cpp", "diffHunk": "@@ -648,6 +656,104 @@ MM_ScavengerDelegate::private_shouldPercolateGarbageCollect_classUnloading(MM_En\n \treturn shouldGCPercolate;\n }\n \n+void\n+MM_ScavengerDelegate::private_SortAllHotField()\n+{\t\n+\t/* update hottest fields for all elements of the hotFieldClassInfoPool where isClassHotFieldListDirty is true */\n+\tif (_javaVM->hotFieldClassInfoPool != NULL && ((_extensions->scavengerStats._gcCount  % _extensions->gcCountBetweenHotFieldSort) == 0)) {\n+\t\tpool_state hotFieldClassInfoPoolState;\n+\t\tomrthread_monitor_enter(_javaVM->hotFieldClassInfoPoolMutex);\n+\t\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp = (J9ClassHotFieldsInfo *)pool_startDo(_javaVM->hotFieldClassInfoPool, &hotFieldClassInfoPoolState);\n+\t\t\n+\t\t/* sort hot field list for the class if the hot field list of the class is dirty */\n+\t\twhile (NULL != hotFieldClassInfoTemp && hotFieldClassInfoTemp->consecutiveHotFieldSelections != U_8_MAX) {\n+\t\t\tif (hotFieldClassInfoTemp->isClassHotFieldListDirty) {\n+\t\t\t\tprivate_SortClassHotFieldList(hotFieldClassInfoTemp);\n+\t\t\t}\n+\t\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_nextDo(&hotFieldClassInfoPoolState);\n+\t\t}\n+\t\tomrthread_monitor_exit(_javaVM->hotFieldClassInfoPoolMutex);\n+\t}\n+\t/* If adaptiveGcCountBetweenHotFieldSort, update the gc count required between sorting all hot fields as the application runs longer */\n+\tif (_extensions->adaptiveGcCountBetweenHotFieldSort && _extensions->gcCountBetweenHotFieldSort < _extensions->gcCountBetweenHotFieldSortMax && _extensions->scavengerStats._gcCount % INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT == 0) {\n+\t\t_extensions->gcCountBetweenHotFieldSort++;\n+\t}\n+\t/* If hotFieldResettingEnabled, update the gc count required between resetting all hot fields */\n+\tif (_extensions->hotFieldResettingEnabled && _extensions->scavengerStats._gcCount % _extensions->gcCountBetweenHotFieldReset == 0) {\n+\t\tprivate_ResetAllHotFieldData();\n+\t}\n+}\n+\n+void\n+MM_ScavengerDelegate::private_SortClassHotFieldList(J9ClassHotFieldsInfo* hotFieldClassInfo) {\n+\t/* store initial hot field offsets before hotFieldClassInfo hot field offsets are updated */\n+\tU_8 initialHotFieldOffset1 = hotFieldClassInfo->hotFieldOffset1;\n+\tU_8 initialHotFieldOffset2 = hotFieldClassInfo->hotFieldOffset2;\n+\n+\t/* compute and update the hot fields for each class */\n+\tif (hotFieldClassInfo->hotFieldListLength == 1) {", "originalCommit": "0804ef91b79504fc892c8c37d2bf66cb68bc0d79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg0MTIzNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r475841237", "bodyText": "Is this special case needed for correctness, or this is just a speed optimization? I would not keep just for speed.", "author": "amicic", "createdAt": "2020-08-24T19:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg0MDUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg0MjQ4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r475842481", "bodyText": "extra brackets", "author": "amicic", "createdAt": "2020-08-24T19:24:52Z", "path": "runtime/gc_glue_java/ScavengerDelegate.cpp", "diffHunk": "@@ -648,6 +656,104 @@ MM_ScavengerDelegate::private_shouldPercolateGarbageCollect_classUnloading(MM_En\n \treturn shouldGCPercolate;\n }\n \n+void\n+MM_ScavengerDelegate::private_SortAllHotField()\n+{\t\n+\t/* update hottest fields for all elements of the hotFieldClassInfoPool where isClassHotFieldListDirty is true */\n+\tif (_javaVM->hotFieldClassInfoPool != NULL && ((_extensions->scavengerStats._gcCount  % _extensions->gcCountBetweenHotFieldSort) == 0)) {\n+\t\tpool_state hotFieldClassInfoPoolState;\n+\t\tomrthread_monitor_enter(_javaVM->hotFieldClassInfoPoolMutex);\n+\t\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp = (J9ClassHotFieldsInfo *)pool_startDo(_javaVM->hotFieldClassInfoPool, &hotFieldClassInfoPoolState);\n+\t\t\n+\t\t/* sort hot field list for the class if the hot field list of the class is dirty */\n+\t\twhile (NULL != hotFieldClassInfoTemp && hotFieldClassInfoTemp->consecutiveHotFieldSelections != U_8_MAX) {\n+\t\t\tif (hotFieldClassInfoTemp->isClassHotFieldListDirty) {\n+\t\t\t\tprivate_SortClassHotFieldList(hotFieldClassInfoTemp);\n+\t\t\t}\n+\t\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_nextDo(&hotFieldClassInfoPoolState);\n+\t\t}\n+\t\tomrthread_monitor_exit(_javaVM->hotFieldClassInfoPoolMutex);\n+\t}\n+\t/* If adaptiveGcCountBetweenHotFieldSort, update the gc count required between sorting all hot fields as the application runs longer */\n+\tif (_extensions->adaptiveGcCountBetweenHotFieldSort && _extensions->gcCountBetweenHotFieldSort < _extensions->gcCountBetweenHotFieldSortMax && _extensions->scavengerStats._gcCount % INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT == 0) {\n+\t\t_extensions->gcCountBetweenHotFieldSort++;\n+\t}\n+\t/* If hotFieldResettingEnabled, update the gc count required between resetting all hot fields */\n+\tif (_extensions->hotFieldResettingEnabled && _extensions->scavengerStats._gcCount % _extensions->gcCountBetweenHotFieldReset == 0) {\n+\t\tprivate_ResetAllHotFieldData();\n+\t}\n+}\n+\n+void\n+MM_ScavengerDelegate::private_SortClassHotFieldList(J9ClassHotFieldsInfo* hotFieldClassInfo) {\n+\t/* store initial hot field offsets before hotFieldClassInfo hot field offsets are updated */\n+\tU_8 initialHotFieldOffset1 = hotFieldClassInfo->hotFieldOffset1;\n+\tU_8 initialHotFieldOffset2 = hotFieldClassInfo->hotFieldOffset2;\n+\n+\t/* compute and update the hot fields for each class */\n+\tif (hotFieldClassInfo->hotFieldListLength == 1) {\n+\t\thotFieldClassInfo->hotFieldOffset1 = hotFieldClassInfo->hotFieldListHead->hotFieldOffset;\n+\t} else {\n+\t\tJ9HotField* currentHotField = hotFieldClassInfo->hotFieldListHead;\n+\t\tU_64 hottest = 0;\n+\t\tU_64 secondHottest = 0;\n+\t\tU_64 current = 0;\n+\t\twhile (NULL != currentHotField) {\n+\t\t\tif(currentHotField->cpuUtil > _extensions->minCpuUtil) {\n+\t\t\t\tcurrent = currentHotField->hotness;\n+\t\t\t\t/* compute only the hottest field if depthCopyTwoPaths is not enabled, otherwise, compute the two hottest fields if depthCopyTwoPaths is enabled */\n+\t\t\t\tif (!_extensions->depthCopyTwoPaths) {\n+\t\t\t\t\tif (current > hottest) {\n+\t\t\t\t\t\thottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tif (current > hottest) {\n+\t\t\t\t\t\tsecondHottest = hottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = hotFieldClassInfo->hotFieldOffset1;\n+\t\t\t\t\t\thottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t} else if (current > secondHottest) {\n+\t\t\t\t\t\tsecondHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = currentHotField->hotFieldOffset;\t\t\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcurrentHotField = currentHotField->next;\n+\t\t}\n+\t} \n+\t/* if permanantHotFields are allowed, update consecutiveHotFieldSelections counter if hot field offsets are the same as the previous time the class hot field list was sorted  */\n+\tif (_extensions->allowPermanantHotFields) {\n+\t\tif (initialHotFieldOffset1 == hotFieldClassInfo->hotFieldOffset1 && initialHotFieldOffset2 == hotFieldClassInfo->hotFieldOffset2) {", "originalCommit": "0804ef91b79504fc892c8c37d2bf66cb68bc0d79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8bbae5aa1c8aa6d4bfef63382812c68c9a68e2ba", "url": "https://github.com/eclipse-openj9/openj9/commit/8bbae5aa1c8aa6d4bfef63382812c68c9a68e2ba", "message": "Add 3 path functionality", "committedDate": "2020-09-09T00:39:13Z", "type": "forcePushed"}, {"oid": "ce4cfacb3fc351f9df8f208da5f52423026c9010", "url": "https://github.com/eclipse-openj9/openj9/commit/ce4cfacb3fc351f9df8f208da5f52423026c9010", "message": "Modify Dynamic BF Scan Ordering to use new JIT Hot Field Marking\n\nModify GC Dynamic Breadth First Scan Ordering to use the\nnewly implemented JIT Hot Field Hot Marking Pass.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>", "committedDate": "2020-09-10T20:10:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI4OTk3Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r487289976", "bodyText": "if dynamicBreadthFirstScanOrdering is provided along with say Balanced GC policy, the latter should take precedence, so that dynamicBreadthFirstScanOrdering  is ignored\nessentially set scavengerScanOrdering, but don't touch GC policy", "author": "amicic", "createdAt": "2020-09-11T21:04:33Z", "path": "runtime/gc_modron_startup/mmparseXgc.cpp", "diffHunk": "@@ -1123,6 +1123,15 @@ j9gc_initialize_parse_gc_colon(J9JavaVM *javaVM, char **scan_start)\n \t\tgoto _exit;\n \t}\n \t\t\n+\tif(try_scan(scan_start, \"dynamicBreadthFirstScanOrdering\")) {\n+\t\textensions->scavengerScanOrdering = MM_GCExtensions::OMR_GC_SCAVENGER_SCANORDERING_DYNAMIC_BREADTH_FIRST;\n+\t\t/* Below options are required options for dynamicBreadthFirstScanOrdering */\n+\t\textensions->scavengerAlignHotFields = false;\n+\t\textensions->configurationOptions._gcPolicy = gc_policy_gencon;", "originalCommit": "ce4cfacb3fc351f9df8f208da5f52423026c9010", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI5MTU0Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r487291542", "bodyText": "move the comment(s) above one line and make them C style\nalso expand the comment providing a reason (for example to avoid immediate copying of hot children of reference objects)", "author": "amicic", "createdAt": "2020-09-11T21:08:28Z", "path": "runtime/gc_glue_java/ScavengerRootClearer.cpp", "diffHunk": "@@ -106,6 +106,7 @@ MM_ScavengerRootClearer::scavengeReferenceObjects(MM_EnvironmentStandard *env, u\n {\n \tAssert_MM_true(env->getGCEnvironment()->_referenceObjectBuffer->isEmpty());\n \n+\tenv->disableHotFieldDepthCopy(); //disable dynamicBreadthFirstScanOrdering depth copying before scavenging reference objects", "originalCommit": "ce4cfacb3fc351f9df8f208da5f52423026c9010", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzNjA2OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r488136069", "bodyText": "we should not be forcing Scavenger either", "author": "amicic", "createdAt": "2020-09-14T18:26:23Z", "path": "runtime/gc_modron_startup/mmparseXgc.cpp", "diffHunk": "@@ -1123,6 +1123,14 @@ j9gc_initialize_parse_gc_colon(J9JavaVM *javaVM, char **scan_start)\n \t\tgoto _exit;\n \t}\n \t\t\n+\tif(try_scan(scan_start, \"dynamicBreadthFirstScanOrdering\")) {\n+\t\textensions->scavengerScanOrdering = MM_GCExtensions::OMR_GC_SCAVENGER_SCANORDERING_DYNAMIC_BREADTH_FIRST;\n+\t\t/* Below options are required options for dynamicBreadthFirstScanOrdering */\n+\t\textensions->scavengerAlignHotFields = false;\n+\t\textensions->scavengerEnabled = true;", "originalCommit": "4c57548b5861254e6bb073e358ef7d0a124d3bb9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "844a00b77c83a1c725848bb8a1ff6ee1a45caece", "url": "https://github.com/eclipse-openj9/openj9/commit/844a00b77c83a1c725848bb8a1ff6ee1a45caece", "message": "Modify Dynamic BF Scan Ordering to use new JIT Hot Field Marking\n\nModify GC Dynamic Breadth First Scan Ordering to use the\nnewly implemented JIT Hot Field Hot Marking Pass.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>", "committedDate": "2020-09-15T17:22:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ2NzExOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r489467119", "bodyText": "This file has not been changed after all, so copyrights should not be updated and file should be excluded from change set", "author": "dmitripivkine", "createdAt": "2020-09-16T14:09:01Z", "path": "runtime/gc_glue_java/ObjectModel.cpp", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 1991, 2019 IBM Corp. and others\n+ * Copyright (c) 1991, 2020 IBM Corp. and others", "originalCommit": "844a00b77c83a1c725848bb8a1ff6ee1a45caece", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU2MzMwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r489563306", "bodyText": "please put constant first", "author": "dmitripivkine", "createdAt": "2020-09-16T16:19:37Z", "path": "runtime/gc_modron_startup/mmhelpers.cpp", "diffHunk": "@@ -150,6 +150,30 @@ j9gc_software_read_barrier_enabled(J9JavaVM *javaVM)\n \treturn MM_GCExtensions::getExtensions(javaVM)->isSoftwareRangeCheckReadBarrierEnabled() ? 1 : 0;\n }\n \n+/**\n+ * Query if hot reference field is reqired for scavenger dynamicBreadthFirstScanOrdering\n+ *  @return true if scavenger dynamicBreadthFirstScanOrdering is enabled, 0 otherwise \n+ */\n+UDATA\n+j9gc_hot_reference_field_required(J9JavaVM *javaVM)\n+{\n+#if defined(J9VM_GC_MODRON_SCAVENGER)\n+\treturn MM_GCExtensions::getExtensions(javaVM)->scavengerScanOrdering == MM_GCExtensions::OMR_GC_SCAVENGER_SCANORDERING_DYNAMIC_BREADTH_FIRST;", "originalCommit": "844a00b77c83a1c725848bb8a1ff6ee1a45caece", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU2OTEzMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r489569132", "bodyText": "Cast to (int) is not necessary.  The type of extensions->gcCountBetweenHotFieldSort is uintptr_t", "author": "dmitripivkine", "createdAt": "2020-09-16T16:29:10Z", "path": "runtime/gc_modron_startup/mmparseXXgc.cpp", "diffHunk": "@@ -716,6 +716,143 @@ gcParseXXgcArguments(J9JavaVM *vm, char *optArg)\n \t\t}\n \n #if defined(J9VM_GC_MODRON_SCAVENGER)\n+\t\t/* Start of options relating to dynamicBreadthFirstScanOrdering */\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldSort=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldSort=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 10) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldSort=\", (UDATA)0, (UDATA)10);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldSort = ((int)value);", "originalCommit": "844a00b77c83a1c725848bb8a1ff6ee1a45caece", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU3MDA3OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r489570078", "bodyText": "the same - cast is not necessary", "author": "dmitripivkine", "createdAt": "2020-09-16T16:30:38Z", "path": "runtime/gc_modron_startup/mmparseXXgc.cpp", "diffHunk": "@@ -716,6 +716,143 @@ gcParseXXgcArguments(J9JavaVM *vm, char *optArg)\n \t\t}\n \n #if defined(J9VM_GC_MODRON_SCAVENGER)\n+\t\t/* Start of options relating to dynamicBreadthFirstScanOrdering */\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldSort=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldSort=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 10) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldSort=\", (UDATA)0, (UDATA)10);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldSort = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldSortMax=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldSortMax=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 50) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldSortMax=\", (UDATA)0, (UDATA)50);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldSortMax = ((int)value);", "originalCommit": "844a00b77c83a1c725848bb8a1ff6ee1a45caece", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU3MTkxNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r489571914", "bodyText": "cast is not necessary", "author": "dmitripivkine", "createdAt": "2020-09-16T16:33:38Z", "path": "runtime/gc_modron_startup/mmparseXXgc.cpp", "diffHunk": "@@ -716,6 +716,143 @@ gcParseXXgcArguments(J9JavaVM *vm, char *optArg)\n \t\t}\n \n #if defined(J9VM_GC_MODRON_SCAVENGER)\n+\t\t/* Start of options relating to dynamicBreadthFirstScanOrdering */\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldSort=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldSort=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 10) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldSort=\", (UDATA)0, (UDATA)10);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldSort = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldSortMax=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldSortMax=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 50) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldSortMax=\", (UDATA)0, (UDATA)50);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldSortMax = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfDisableAdaptiveGcCountBetweenHotFieldSort\")) {\n+\t\t\textensions->adaptiveGcCountBetweenHotFieldSort = false;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfDisableDepthCopyTwoPaths\")) {\n+\t\t\textensions->depthCopyTwoPaths = false;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\n+\t\tif(try_scan(&scan_start, \"dbfDepthCopyThreePaths\")) {\n+\t\t\textensions->depthCopyThreePaths = true;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\n+\t\tif(try_scan(&scan_start, \"dbfEnableAlwaysDepthCopyFirstOffset\")) {\n+\t\t\textensions->alwaysDepthCopyFirstOffset = true;\n+\t\t\tcontinue;\n+\t\t} \n+\n+\t\tif(try_scan(&scan_start, \"dbfEnablePermanantHotFields\")) {\n+\t\t\textensions->allowPermanantHotFields = true;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\n+\t\tif(try_scan(&scan_start, \"dbfMaxConsecutiveHotFieldSelections=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfMaxConsecutiveHotFieldSelections=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 50) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfMaxConsecutiveHotFieldSelections=\", (UDATA)0, (UDATA)50);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->maxConsecutiveHotFieldSelections = ((int)value);", "originalCommit": "844a00b77c83a1c725848bb8a1ff6ee1a45caece", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU3MjM1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r489572351", "bodyText": "cast is not necessary", "author": "dmitripivkine", "createdAt": "2020-09-16T16:34:24Z", "path": "runtime/gc_modron_startup/mmparseXXgc.cpp", "diffHunk": "@@ -716,6 +716,143 @@ gcParseXXgcArguments(J9JavaVM *vm, char *optArg)\n \t\t}\n \n #if defined(J9VM_GC_MODRON_SCAVENGER)\n+\t\t/* Start of options relating to dynamicBreadthFirstScanOrdering */\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldSort=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldSort=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 10) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldSort=\", (UDATA)0, (UDATA)10);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldSort = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldSortMax=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldSortMax=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 50) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldSortMax=\", (UDATA)0, (UDATA)50);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldSortMax = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfDisableAdaptiveGcCountBetweenHotFieldSort\")) {\n+\t\t\textensions->adaptiveGcCountBetweenHotFieldSort = false;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfDisableDepthCopyTwoPaths\")) {\n+\t\t\textensions->depthCopyTwoPaths = false;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\n+\t\tif(try_scan(&scan_start, \"dbfDepthCopyThreePaths\")) {\n+\t\t\textensions->depthCopyThreePaths = true;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\n+\t\tif(try_scan(&scan_start, \"dbfEnableAlwaysDepthCopyFirstOffset\")) {\n+\t\t\textensions->alwaysDepthCopyFirstOffset = true;\n+\t\t\tcontinue;\n+\t\t} \n+\n+\t\tif(try_scan(&scan_start, \"dbfEnablePermanantHotFields\")) {\n+\t\t\textensions->allowPermanantHotFields = true;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\n+\t\tif(try_scan(&scan_start, \"dbfMaxConsecutiveHotFieldSelections=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfMaxConsecutiveHotFieldSelections=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 50) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfMaxConsecutiveHotFieldSelections=\", (UDATA)0, (UDATA)50);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->maxConsecutiveHotFieldSelections = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfEnableHotFieldResetting\")) {\n+\t\t\textensions->hotFieldResettingEnabled = true;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldReset=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldReset=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 5000) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldReset=\", (UDATA)0, (UDATA)5000);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldReset = ((int)value);", "originalCommit": "844a00b77c83a1c725848bb8a1ff6ee1a45caece", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU3MjQ0Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r489572447", "bodyText": "cast is not necessary", "author": "dmitripivkine", "createdAt": "2020-09-16T16:34:35Z", "path": "runtime/gc_modron_startup/mmparseXXgc.cpp", "diffHunk": "@@ -716,6 +716,143 @@ gcParseXXgcArguments(J9JavaVM *vm, char *optArg)\n \t\t}\n \n #if defined(J9VM_GC_MODRON_SCAVENGER)\n+\t\t/* Start of options relating to dynamicBreadthFirstScanOrdering */\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldSort=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldSort=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 10) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldSort=\", (UDATA)0, (UDATA)10);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldSort = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldSortMax=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldSortMax=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 50) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldSortMax=\", (UDATA)0, (UDATA)50);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldSortMax = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfDisableAdaptiveGcCountBetweenHotFieldSort\")) {\n+\t\t\textensions->adaptiveGcCountBetweenHotFieldSort = false;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfDisableDepthCopyTwoPaths\")) {\n+\t\t\textensions->depthCopyTwoPaths = false;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\n+\t\tif(try_scan(&scan_start, \"dbfDepthCopyThreePaths\")) {\n+\t\t\textensions->depthCopyThreePaths = true;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\n+\t\tif(try_scan(&scan_start, \"dbfEnableAlwaysDepthCopyFirstOffset\")) {\n+\t\t\textensions->alwaysDepthCopyFirstOffset = true;\n+\t\t\tcontinue;\n+\t\t} \n+\n+\t\tif(try_scan(&scan_start, \"dbfEnablePermanantHotFields\")) {\n+\t\t\textensions->allowPermanantHotFields = true;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\n+\t\tif(try_scan(&scan_start, \"dbfMaxConsecutiveHotFieldSelections=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfMaxConsecutiveHotFieldSelections=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 50) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfMaxConsecutiveHotFieldSelections=\", (UDATA)0, (UDATA)50);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->maxConsecutiveHotFieldSelections = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfEnableHotFieldResetting\")) {\n+\t\t\textensions->hotFieldResettingEnabled = true;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldReset=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldReset=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 5000) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldReset=\", (UDATA)0, (UDATA)5000);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldReset = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfDepthCopyMax=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfDepthCopyMax=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 10) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfDepthCopyMax=\", (UDATA)0, (UDATA)10);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\t\n+\t\t\textensions->depthCopyMax = ((int)value);", "originalCommit": "844a00b77c83a1c725848bb8a1ff6ee1a45caece", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU3Mjk0NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r489572945", "bodyText": "should be cast to (uint32_t)", "author": "dmitripivkine", "createdAt": "2020-09-16T16:35:28Z", "path": "runtime/gc_modron_startup/mmparseXXgc.cpp", "diffHunk": "@@ -716,6 +716,143 @@ gcParseXXgcArguments(J9JavaVM *vm, char *optArg)\n \t\t}\n \n #if defined(J9VM_GC_MODRON_SCAVENGER)\n+\t\t/* Start of options relating to dynamicBreadthFirstScanOrdering */\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldSort=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldSort=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 10) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldSort=\", (UDATA)0, (UDATA)10);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldSort = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldSortMax=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldSortMax=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 50) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldSortMax=\", (UDATA)0, (UDATA)50);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldSortMax = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfDisableAdaptiveGcCountBetweenHotFieldSort\")) {\n+\t\t\textensions->adaptiveGcCountBetweenHotFieldSort = false;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfDisableDepthCopyTwoPaths\")) {\n+\t\t\textensions->depthCopyTwoPaths = false;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\n+\t\tif(try_scan(&scan_start, \"dbfDepthCopyThreePaths\")) {\n+\t\t\textensions->depthCopyThreePaths = true;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\n+\t\tif(try_scan(&scan_start, \"dbfEnableAlwaysDepthCopyFirstOffset\")) {\n+\t\t\textensions->alwaysDepthCopyFirstOffset = true;\n+\t\t\tcontinue;\n+\t\t} \n+\n+\t\tif(try_scan(&scan_start, \"dbfEnablePermanantHotFields\")) {\n+\t\t\textensions->allowPermanantHotFields = true;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\n+\t\tif(try_scan(&scan_start, \"dbfMaxConsecutiveHotFieldSelections=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfMaxConsecutiveHotFieldSelections=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 50) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfMaxConsecutiveHotFieldSelections=\", (UDATA)0, (UDATA)50);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->maxConsecutiveHotFieldSelections = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfEnableHotFieldResetting\")) {\n+\t\t\textensions->hotFieldResettingEnabled = true;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldReset=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldReset=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 5000) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldReset=\", (UDATA)0, (UDATA)5000);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldReset = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfDepthCopyMax=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfDepthCopyMax=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 10) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfDepthCopyMax=\", (UDATA)0, (UDATA)10);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\t\n+\t\t\textensions->depthCopyMax = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfMaxHotFieldListLength=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfMaxHotFieldListLength=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 20) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfMaxHotFieldListLength=\", (UDATA)0, (UDATA)20);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\t\n+\t\t\textensions->maxHotFieldListLength = ((int)value);", "originalCommit": "844a00b77c83a1c725848bb8a1ff6ee1a45caece", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU3MzU4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r489573582", "bodyText": "cast is not necessary", "author": "dmitripivkine", "createdAt": "2020-09-16T16:36:26Z", "path": "runtime/gc_modron_startup/mmparseXXgc.cpp", "diffHunk": "@@ -716,6 +716,143 @@ gcParseXXgcArguments(J9JavaVM *vm, char *optArg)\n \t\t}\n \n #if defined(J9VM_GC_MODRON_SCAVENGER)\n+\t\t/* Start of options relating to dynamicBreadthFirstScanOrdering */\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldSort=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldSort=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 10) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldSort=\", (UDATA)0, (UDATA)10);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldSort = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldSortMax=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldSortMax=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 50) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldSortMax=\", (UDATA)0, (UDATA)50);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldSortMax = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfDisableAdaptiveGcCountBetweenHotFieldSort\")) {\n+\t\t\textensions->adaptiveGcCountBetweenHotFieldSort = false;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfDisableDepthCopyTwoPaths\")) {\n+\t\t\textensions->depthCopyTwoPaths = false;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\n+\t\tif(try_scan(&scan_start, \"dbfDepthCopyThreePaths\")) {\n+\t\t\textensions->depthCopyThreePaths = true;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\n+\t\tif(try_scan(&scan_start, \"dbfEnableAlwaysDepthCopyFirstOffset\")) {\n+\t\t\textensions->alwaysDepthCopyFirstOffset = true;\n+\t\t\tcontinue;\n+\t\t} \n+\n+\t\tif(try_scan(&scan_start, \"dbfEnablePermanantHotFields\")) {\n+\t\t\textensions->allowPermanantHotFields = true;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\n+\t\tif(try_scan(&scan_start, \"dbfMaxConsecutiveHotFieldSelections=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfMaxConsecutiveHotFieldSelections=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 50) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfMaxConsecutiveHotFieldSelections=\", (UDATA)0, (UDATA)50);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->maxConsecutiveHotFieldSelections = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfEnableHotFieldResetting\")) {\n+\t\t\textensions->hotFieldResettingEnabled = true;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldReset=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldReset=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 5000) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldReset=\", (UDATA)0, (UDATA)5000);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldReset = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfDepthCopyMax=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfDepthCopyMax=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 10) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfDepthCopyMax=\", (UDATA)0, (UDATA)10);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\t\n+\t\t\textensions->depthCopyMax = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfMaxHotFieldListLength=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfMaxHotFieldListLength=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 20) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfMaxHotFieldListLength=\", (UDATA)0, (UDATA)20);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\t\n+\t\t\textensions->maxHotFieldListLength = ((int)value);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfMinCpuUtil=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfMinCpuUtil=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 15) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfMinCpuUtil=\", (UDATA)0, (UDATA)15);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\t\n+\t\t\textensions->minCpuUtil = ((int)value);", "originalCommit": "844a00b77c83a1c725848bb8a1ff6ee1a45caece", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8a0a71a286139f42c78139a4fd999e147342a28a", "url": "https://github.com/eclipse-openj9/openj9/commit/8a0a71a286139f42c78139a4fd999e147342a28a", "message": "Add Dynamic Breadth First Scan Ordering to the GC\n\nAdd Dynamic Breadth First Scan Ordering to the GC implemented\nusing JIT hot fields. This enables the copying of a hot field\nmarked by the JIT immediately after the object containing the\nhot field is copied during a Scavenge.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>", "committedDate": "2020-09-16T18:02:52Z", "type": "commit"}, {"oid": "4213c69486ef53e7b30dc2ba1539fefc734c6d4a", "url": "https://github.com/eclipse-openj9/openj9/commit/4213c69486ef53e7b30dc2ba1539fefc734c6d4a", "message": "Add HotFieldMarking pass\n\nCurrently hot field information is passed to the GC by the JIT in ValuePropagation.\nTo make the point where hot field marking is done more deterministic this commit\npulls the marking out into its own pass.\n\nSigned-off-by: Andrew Craik <ajcraik@ca.ibm.com>", "committedDate": "2020-09-16T18:02:52Z", "type": "commit"}, {"oid": "e00089f3cf0ad12e003bcaeb1aa0590895f37909", "url": "https://github.com/eclipse-openj9/openj9/commit/e00089f3cf0ad12e003bcaeb1aa0590895f37909", "message": "Modify Dynamic BF Scan Ordering to use new JIT Hot Field Marking\n\nModify GC Dynamic Breadth First Scan Ordering to use the\nnewly implemented JIT Hot Field Hot Marking Pass.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>", "committedDate": "2020-09-16T18:02:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczOTY5OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10124#discussion_r489739699", "bodyText": "please remove external pair of brackets", "author": "dmitripivkine", "createdAt": "2020-09-16T20:37:31Z", "path": "runtime/gc_modron_startup/mmparseXXgc.cpp", "diffHunk": "@@ -716,6 +716,143 @@ gcParseXXgcArguments(J9JavaVM *vm, char *optArg)\n \t\t}\n \n #if defined(J9VM_GC_MODRON_SCAVENGER)\n+\t\t/* Start of options relating to dynamicBreadthFirstScanOrdering */\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldSort=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldSort=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 10) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldSort=\", (UDATA)0, (UDATA)10);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldSort = value;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldSortMax=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldSortMax=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 50) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldSortMax=\", (UDATA)0, (UDATA)50);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldSortMax = value;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfDisableAdaptiveGcCountBetweenHotFieldSort\")) {\n+\t\t\textensions->adaptiveGcCountBetweenHotFieldSort = false;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfDisableDepthCopyTwoPaths\")) {\n+\t\t\textensions->depthCopyTwoPaths = false;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\n+\t\tif(try_scan(&scan_start, \"dbfDepthCopyThreePaths\")) {\n+\t\t\textensions->depthCopyThreePaths = true;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\n+\t\tif(try_scan(&scan_start, \"dbfEnableAlwaysDepthCopyFirstOffset\")) {\n+\t\t\textensions->alwaysDepthCopyFirstOffset = true;\n+\t\t\tcontinue;\n+\t\t} \n+\n+\t\tif(try_scan(&scan_start, \"dbfEnablePermanantHotFields\")) {\n+\t\t\textensions->allowPermanantHotFields = true;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\n+\t\tif(try_scan(&scan_start, \"dbfMaxConsecutiveHotFieldSelections=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfMaxConsecutiveHotFieldSelections=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 50) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfMaxConsecutiveHotFieldSelections=\", (UDATA)0, (UDATA)50);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->maxConsecutiveHotFieldSelections = value;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfEnableHotFieldResetting\")) {\n+\t\t\textensions->hotFieldResettingEnabled = true;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfGcCountBetweenHotFieldReset=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfGcCountBetweenHotFieldReset=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 5000) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfGcCountBetweenHotFieldReset=\", (UDATA)0, (UDATA)5000);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\textensions->gcCountBetweenHotFieldReset = value;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfDepthCopyMax=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfDepthCopyMax=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 10) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfDepthCopyMax=\", (UDATA)0, (UDATA)10);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\t\n+\t\t\textensions->depthCopyMax = value;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif(try_scan(&scan_start, \"dbfMaxHotFieldListLength=\")) {\n+\t\t\tUDATA value;\n+\t\t\tif(!scan_udata_helper(vm, &scan_start, &value, \"dbfMaxHotFieldListLength=\")) {\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(value > 20) {\n+\t\t\t\tj9nls_printf(PORTLIB, J9NLS_ERROR, J9NLS_GC_OPTIONS_INTEGER_OUT_OF_RANGE, \"dbfMaxHotFieldListLength=\", (UDATA)0, (UDATA)20);\n+\t\t\t\treturnValue = JNI_EINVAL;\n+\t\t\t\tbreak;\n+\t\t\t}\t\n+\t\t\textensions->maxHotFieldListLength = ((uint32_t)value);", "originalCommit": "e00089f3cf0ad12e003bcaeb1aa0590895f37909", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "49d08e622c9ef16cc5d0bfef8afef0b72d7e6659", "url": "https://github.com/eclipse-openj9/openj9/commit/49d08e622c9ef16cc5d0bfef8afef0b72d7e6659", "message": "Modify Dynamic BF Scan Ordering to use new JIT Hot Field Marking\n\nModify GC Dynamic Breadth First Scan Ordering to use the\nnewly implemented JIT Hot Field Hot Marking Pass.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>", "committedDate": "2020-09-18T20:53:14Z", "type": "forcePushed"}, {"oid": "044adf715616a76b9c28c633b8ff1801e1964289", "url": "https://github.com/eclipse-openj9/openj9/commit/044adf715616a76b9c28c633b8ff1801e1964289", "message": "Modify Dynamic BF Scan Ordering to use new JIT Hot Field Marking\n\nModify GC Dynamic Breadth First Scan Ordering to use the\nnewly implemented JIT Hot Field Hot Marking Pass.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>", "committedDate": "2020-09-19T06:39:15Z", "type": "forcePushed"}, {"oid": "7b012e80180a1004711519f31d5616af1b1b3b72", "url": "https://github.com/eclipse-openj9/openj9/commit/7b012e80180a1004711519f31d5616af1b1b3b72", "message": "Modify Dynamic BF Scan Ordering to use new JIT Hot Field Marking\n\nModify GC Dynamic Breadth First Scan Ordering to use the\nnewly implemented JIT Hot Field Hot Marking Pass.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>", "committedDate": "2020-09-22T14:13:06Z", "type": "commit"}, {"oid": "7b012e80180a1004711519f31d5616af1b1b3b72", "url": "https://github.com/eclipse-openj9/openj9/commit/7b012e80180a1004711519f31d5616af1b1b3b72", "message": "Modify Dynamic BF Scan Ordering to use new JIT Hot Field Marking\n\nModify GC Dynamic Breadth First Scan Ordering to use the\nnewly implemented JIT Hot Field Hot Marking Pass.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>", "committedDate": "2020-09-22T14:13:06Z", "type": "forcePushed"}]}