{"pr_number": 10362, "pr_title": "LoadInstance support for sym ref generation for flattened fields", "pr_createdAt": "2020-08-10T18:41:34Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10362", "timeline": [{"oid": "e791b50bd355d9f80a9c1c96c52dfdca5539817d", "url": "https://github.com/eclipse-openj9/openj9/commit/e791b50bd355d9f80a9c1c96c52dfdca5539817d", "message": "Support flattened fields in loadinstance\n\n[skip ci]\nThis change was originally authored by Yi Zhang\nwho is listed as a co-author below.\n\nCo-authored-by: Yi Zhang yizhang@ca.ibm.com\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-08-11T19:55:15Z", "type": "forcePushed"}, {"oid": "0a53071aef116ea842883790c731f0b7220d79c9", "url": "https://github.com/eclipse-openj9/openj9/commit/0a53071aef116ea842883790c731f0b7220d79c9", "message": "Support flattened fields in loadinstance\n\n[skip ci]\nThis change was originally authored by Yi Zhang\nwho is listed as a co-author below.\n\nCo-authored-by: Yi Zhang yizhang@ca.ibm.com\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-08-13T17:08:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MTkzOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r472371939", "bodyText": "I think this does need to be made real to facilitate debugging if test failures occur - the transform is optional. Would it make more sense to always generate the helpers and then have an ilgen opts pass to do the lowering? That way we could use a standard performTransformation guard to guard the transform to allow for easier debugging?\nIf that makes things too complicated then at least some kind of JIT option is necessary.", "author": "andrewcraik", "createdAt": "2020-08-18T17:42:48Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,54 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,\n+                                    &isPrivate, isStore, &isUnresolvedInCP, true /* needsAOTValidation */);\n+   return bResolved;\n+   }\n+\n void\n TR_J9ByteCodeIlGenerator::loadInstance(int32_t cpIndex)\n    {\n    if (_generateReadBarriersForFieldWatch && comp()->compileRelocatableCode())\n       comp()->failCompilation<J9::AOTNoSupportForAOTFailure>(\"NO support for AOT in field watch\");\n-   TR::SymbolReference * symRef = symRefTab()->findOrCreateShadowSymbol(_methodSymbol, cpIndex, false);\n-   loadInstance(symRef);\n+\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       owningMethod->isFieldQType(cpIndex))\n+      {\n+      if (isFieldResovled(comp(), owningMethod, cpIndex, false))\n+         {\n+         if (owningMethod->isFieldFlattened(comp(), cpIndex, _methodSymbol->isStatic()))\n+            {\n+            // TODO choose the runtime helper or not. Maybe based on an option?", "originalCommit": "0a53071aef116ea842883790c731f0b7220d79c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxMjI4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r472512282", "bodyText": "As per discussion with @Leonardo2718 last week, this part of code is likely moved to the runtime helper change that @Leonardo2718 is implementing. That's why I haven't updated it yet. The plan for now is to switch to the runtime flattened field helper by using an environment variable. My understanding is something like below:\n         if (owningMethod->isFieldFlattened(comp(), cpIndex, _methodSymbol->isStatic()))\n            {\n            static char *enableRuntimeFlattenFieldGetfieldHelper = feGetEnv(\"TR_EnableRuntimeFlattenFieldGetfieldHelper\");\n            if (enableRuntimeFlattenFieldGetfieldHelper)\n               {\n               // Runtime helper\n               }\n            else\n               {\n               loadInstanceFlattenedField(cpIndex);\n               }\n            }\n         else\n            {\n            TR::SymbolReference * symRef = symRefTab()->findOrCreateShadowSymbol(_methodSymbol, cpIndex, false);\n            loadInstance(symRef);\n            }\n         }", "author": "a7ehuo", "createdAt": "2020-08-18T21:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MTkzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEzMjQ2Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r473132467", "bodyText": "for debugging a performTransformation would be preferable to an envvar since the use of the fully flattened version is an optimization over the helper version right? eg we should degrade to the simpler one to help debug problems potentially? Thoughts? FYI @Leonardo2718 and @hzongaro", "author": "andrewcraik", "createdAt": "2020-08-19T15:50:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MTkzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMwMTk1OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r473301959", "bodyText": "That is my understanding too: by default we go down the transformation path, if anything wrong happens, we use the environment variable to choose the runtime helpers for debugging. I could be wrong tho. I'll let @Leonardo2718 help confirm.", "author": "a7ehuo", "createdAt": "2020-08-19T20:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MTkzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA4NTU1OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r474085559", "bodyText": "That is my understanding too: by default we go down the transformation path, if anything wrong happens, we use the environment variable to choose the runtime helpers for debugging\n\nI missunderstood the performTransformation macro and please ignore my comments on the above.", "author": "a7ehuo", "createdAt": "2020-08-20T15:45:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MTkzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc5MDU0Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r476790547", "bodyText": "After some discussion with @Leonardo2718 @hzongaro, JIT option is used for now to choose between runtime helper or sym ref generation during the compilation time (eclipse/omr#5493). In the future, performTransformation could be considered. Moving the sym ref generation to Optimization phase is more complicated.", "author": "a7ehuo", "createdAt": "2020-08-25T22:15:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MTkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MjI3NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r472372275", "bodyText": "This sub-tree should have some tracing for when traceILGen is on to outline the choice made and why so we know why we generated the tree we did.", "author": "andrewcraik", "createdAt": "2020-08-18T17:43:23Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,54 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,\n+                                    &isPrivate, isStore, &isUnresolvedInCP, true /* needsAOTValidation */);\n+   return bResolved;\n+   }\n+\n void\n TR_J9ByteCodeIlGenerator::loadInstance(int32_t cpIndex)\n    {\n    if (_generateReadBarriersForFieldWatch && comp()->compileRelocatableCode())\n       comp()->failCompilation<J9::AOTNoSupportForAOTFailure>(\"NO support for AOT in field watch\");\n-   TR::SymbolReference * symRef = symRefTab()->findOrCreateShadowSymbol(_methodSymbol, cpIndex, false);\n-   loadInstance(symRef);\n+\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       owningMethod->isFieldQType(cpIndex))\n+      {\n+      if (isFieldResovled(comp(), owningMethod, cpIndex, false))\n+         {\n+         if (owningMethod->isFieldFlattened(comp(), cpIndex, _methodSymbol->isStatic()))", "originalCommit": "0a53071aef116ea842883790c731f0b7220d79c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYyNTc1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r472625758", "bodyText": "The tracing is added to where each flattened field is being loaded.", "author": "a7ehuo", "createdAt": "2020-08-19T03:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MjI3NQ=="}], "type": "inlineReview"}, {"oid": "99fe516eeaf27e3fea7925558c336e0882b7fac9", "url": "https://github.com/eclipse-openj9/openj9/commit/99fe516eeaf27e3fea7925558c336e0882b7fac9", "message": "Support flattened fields in loadinstance\n\n[skip ci]\nThis change was originally authored by Yi Zhang\nwho is listed as a co-author below.\n\nCo-authored-by: Yi Zhang yizhang@ca.ibm.com\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-08-19T03:00:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4NTMzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r473185338", "bodyText": "Can the isFieldQType really be called before checking if it's resolved?", "author": "Leonardo2718", "createdAt": "2020-08-19T17:00:21Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,57 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,\n+                                    &isPrivate, isStore, &isUnresolvedInCP, true /* needsAOTValidation */);\n+   return bResolved;\n+   }\n+\n void\n TR_J9ByteCodeIlGenerator::loadInstance(int32_t cpIndex)\n    {\n    if (_generateReadBarriersForFieldWatch && comp()->compileRelocatableCode())\n       comp()->failCompilation<J9::AOTNoSupportForAOTFailure>(\"NO support for AOT in field watch\");\n-   TR::SymbolReference * symRef = symRefTab()->findOrCreateShadowSymbol(_methodSymbol, cpIndex, false);\n-   loadInstance(symRef);\n+\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       owningMethod->isFieldQType(cpIndex))", "originalCommit": "99fe516eeaf27e3fea7925558c336e0882b7fac9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzOTU2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r473239568", "bodyText": "isFieldQType() essentially calls VM to check J9ROMNameAndSignature as below and see if it contains Q keyword. My understanding is that it doesn't require the field to be resolved. Or does it need to?\nhttps://github.com/eclipse/openj9/blob/fef3f947a0086af748f59f5aa688b09960a43421/runtime/vm/ValueTypeHelpers.hpp#L248-L261", "author": "a7ehuo", "createdAt": "2020-08-19T18:32:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4NTMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5MjI3MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r473192271", "bodyText": "I think this should actually be\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               return bResolved;\n          \n          \n            \n               return !isUnresolvedInCP;\n          \n      \n    \n    \n  \n\nfieldAttributes() will return true if the CP entry gets resolved at compile-time. Under such cases, the JIT basically gets to peek at what the result will be when the entry is resolved. However, the runtime CP resolution still has to happen, so the JIT needs to treat the field as unresolved (because it is) even though it actually knows what it's supposed to be.", "author": "Leonardo2718", "createdAt": "2020-08-19T17:08:30Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,57 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,\n+                                    &isPrivate, isStore, &isUnresolvedInCP, true /* needsAOTValidation */);\n+   return bResolved;", "originalCommit": "99fe516eeaf27e3fea7925558c336e0882b7fac9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzOTkyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r473239921", "bodyText": "Thanks for the clarification!", "author": "a7ehuo", "createdAt": "2020-08-19T18:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5MjI3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI2Nzc4Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r474267787", "bodyText": "Actually I have a question on this code. For loadInstance, should it check if a field is resolved or if its containing class is resolved. Here on checking if the field is resolved I used how findOrCreateShadowSymbol() does it as blow:\nhttps://github.com/eclipse/openj9/blob/141cd78d2ad744ca44f04b97d0c3927ee854eaf9/runtime/compiler/compile/J9SymbolReferenceTable.cpp#L800\nLooking at genWithField(), it checks if the containing class exists or not to determine resolve or not.\nhttps://github.com/eclipse/openj9/blob/141cd78d2ad744ca44f04b97d0c3927ee854eaf9/runtime/compiler/ilgen/Walker.cpp#L6153-L6157", "author": "a7ehuo", "createdAt": "2020-08-20T20:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5MjI3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc5MTkzMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r476791932", "bodyText": "isFieldResovled() will be removed from this PR and added to runtime helper PR.", "author": "a7ehuo", "createdAt": "2020-08-25T22:17:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5MjI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5OTkzMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r473199930", "bodyText": "What happens if the cpIndex is not field entry in the CP?", "author": "Leonardo2718", "createdAt": "2020-08-19T17:21:22Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,57 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,", "originalCommit": "99fe516eeaf27e3fea7925558c336e0882b7fac9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI2Nzg4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r473267881", "bodyText": "Depending on which one gets to check first (#10362 (comment)): checking isFieldQType() first or checking isFieldResovled() first.\n\nIf  isFieldQType() is called first, it returns false when cpIndex == -1. It goes down the existing path of loadInstance(symRef). It looks to me it still creates a symRef even when cpIndex == -1 regardless of value class or not.\nIf isFieldResovled() is called first, it relies on owningMethod->fieldAttributes to check cpIndex. TR_ResolvedJ9Method::fieldAttributes() only has an TR_ASSERT(cpIndex != -1, ...). It means the release build could crash when cpIndex == -1. However it applies to all cases when fieldAttributes is called regardless of value classes or not.", "author": "a7ehuo", "createdAt": "2020-08-19T19:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5OTkzMA=="}], "type": "inlineReview"}, {"oid": "949f6d8fda4867e014c53bc860afe5056dcb7185", "url": "https://github.com/eclipse-openj9/openj9/commit/949f6d8fda4867e014c53bc860afe5056dcb7185", "message": "Support flattened fields in loadinstance\n\n[skip ci]\nThis change was originally authored by Yi Zhang\nwho is listed as a co-author below.\n\nCo-authored-by: Yi Zhang yizhang@ca.ibm.com\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-08-25T22:11:12Z", "type": "forcePushed"}, {"oid": "e18acfff0479ca605d1869beaa773d05082e39c5", "url": "https://github.com/eclipse-openj9/openj9/commit/e18acfff0479ca605d1869beaa773d05082e39c5", "message": "Support flattened fields in loadinstance\n\n[skip ci]\nThis change was originally authored by Yi Zhang\nwho is listed as a co-author below.\n\nCo-authored-by: Yi Zhang yizhang@ca.ibm.com\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-08-26T20:50:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0Mjc2Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r481442766", "bodyText": "Can we have some documentation in the code of what the trees will look like?", "author": "andrewcraik", "createdAt": "2020-09-01T21:29:10Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5160,6 +5176,81 @@ TR_J9ByteCodeIlGenerator::loadInstance(TR::SymbolReference * symRef)\n    push(dummyLoad);\n    }\n \n+static char * getTopLevelPrefixForFlattenedFields(TR_ResolvedJ9Method *owningMethod, int32_t cpIndex, int32_t &prefixLen, TR::Region &region)\n+   {\n+   int32_t len;\n+   const char * fieldNameChars = owningMethod->fieldNameChars(cpIndex, len);\n+   prefixLen = len + 1; // for '.'\n+\n+   char * newName = new (region) char[len+2];\n+   strncpy(newName, fieldNameChars, len);\n+\n+   newName[len] = '.';\n+   newName[len+1] = '\\0';\n+   return newName;\n+   }\n+\n+void\n+TR_J9ByteCodeIlGenerator::loadFlattenableInstance(int32_t cpIndex)", "originalCommit": "e18acfff0479ca605d1869beaa773d05082e39c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ce2f1a7b4bcb24abf72f1a04a266c1338f95215a", "url": "https://github.com/eclipse-openj9/openj9/commit/ce2f1a7b4bcb24abf72f1a04a266c1338f95215a", "message": "Generate sym ref for flattened fields in loadinstance\n\n[skip ci]\nThis change was originally authored by Yi Zhang\nwho is listed as a co-author below.\n\nCo-authored-by: Yi Zhang yizhang@ca.ibm.com\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-09-01T22:35:49Z", "type": "forcePushed"}, {"oid": "218c43a912b7cbc397bc0d3678c8b3eefc7c6c9a", "url": "https://github.com/eclipse-openj9/openj9/commit/218c43a912b7cbc397bc0d3678c8b3eefc7c6c9a", "message": "Generate sym ref for flattened fields in loadinstance\n\nThis change was originally authored by Yi Zhang\nwho is listed as a co-author below.\n\nCo-authored-by: Yi Zhang yizhang@ca.ibm.com\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-09-16T15:22:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMzNDM4NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r494334384", "bodyText": "why do we need a nullchk here? if the receiver is 'this' it would be guarnateed non-null... or is this some kind of more general transform and in this case we happen to have this and so we leave it to the optimizer to eliminate it later?", "author": "andrewcraik", "createdAt": "2020-09-24T13:48:55Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5216,6 +5217,117 @@ TR_J9ByteCodeIlGenerator::loadFlattenableInstanceWithHelper(int32_t cpIndex)\n    push(helperCallNode);\n    }\n \n+static char * getTopLevelPrefixForFlattenedFields(TR_ResolvedJ9Method *owningMethod, int32_t cpIndex, int32_t &prefixLen, TR::Region &region)\n+   {\n+   int32_t len;\n+   const char * fieldNameChars = owningMethod->fieldNameChars(cpIndex, len);\n+   prefixLen = len + 1; // for '.'\n+\n+   char * newName = new (region) char[len+2];\n+   strncpy(newName, fieldNameChars, len);\n+\n+   newName[len] = '.';\n+   newName[len+1] = '\\0';\n+   return newName;\n+   }\n+\n+void\n+TR_J9ByteCodeIlGenerator::loadFlattenableInstance(int32_t cpIndex)\n+   {\n+   /* An example on what the tree with flattened fields looks like\n+    *\n+    * value NestedA {\n+    *    int x;\n+    *    int y;\n+    *    }\n+    * value NestedB {\n+    *    NestedA a;\n+    *    NestedA b;\n+    *    }\n+    * value ContainerC {\n+    *    NestedB c;\n+    *    NestedB d;\n+    *    }\n+    *\n+    * method=\"ContainerC.getc()QNestedB;\"\n+    *\n+    * /--- trees inserted ------------------------\n+    * n5n      (  0)  NULLCHK on n3n [#32]", "originalCommit": "218c43a912b7cbc397bc0d3678c8b3eefc7c6c9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM5MTE1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r494391150", "bodyText": "I think I should check !isNonNull() before adding the NULLCHK. I'll update it next.", "author": "a7ehuo", "createdAt": "2020-09-24T15:01:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMzNDM4NA=="}], "type": "inlineReview"}, {"oid": "6b4caa64698ea4269a8ae5e15d123bea1b451f79", "url": "https://github.com/eclipse-openj9/openj9/commit/6b4caa64698ea4269a8ae5e15d123bea1b451f79", "message": "Generate sym ref for flattened fields in loadinstance\n\nThis change was originally authored by Yi Zhang\nwho is listed as a co-author below.\n\nCo-authored-by: Yi Zhang yizhang@ca.ibm.com\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-09-24T17:04:41Z", "type": "commit"}, {"oid": "6b4caa64698ea4269a8ae5e15d123bea1b451f79", "url": "https://github.com/eclipse-openj9/openj9/commit/6b4caa64698ea4269a8ae5e15d123bea1b451f79", "message": "Generate sym ref for flattened fields in loadinstance\n\nThis change was originally authored by Yi Zhang\nwho is listed as a co-author below.\n\nCo-authored-by: Yi Zhang yizhang@ca.ibm.com\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-09-24T17:04:41Z", "type": "forcePushed"}]}