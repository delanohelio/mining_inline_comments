{"pr_number": 9866, "pr_title": "Immediate field handling cleanup on Power", "pr_createdAt": "2020-06-12T19:33:16Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9866", "timeline": [{"oid": "f1eae47c09f8f44464d7f6f9ae21d9f7b3a3fb61", "url": "https://github.com/eclipse-openj9/openj9/commit/f1eae47c09f8f44464d7f6f9ae21d9f7b3a3fb61", "message": "Immediate field handling cleanup on Power\n\nbuildDirectDispatch was incorrectly truncating an immediate value before\ngenerating an lis instruction. This was corrected.\n\ngeneratePrologue in PPCRecompilation.cpp also had the same problem and has\nbeen corrected.\n\nAdded in several new asserts to give better information in cases where an out\nof range value is attempted to be used as the immediate value for an\ninstruction.\n\nSigned-off-by: jimmyk <jimmyk@ca.ibm.com>", "committedDate": "2020-06-12T17:14:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwODk1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9866#discussion_r441208955", "bodyText": "I am not sure the ASSERT above guaranties there is nothing in the upper 32-bits of aValue (intptr_t). I would cast to int16_t to be on a safe side and to reproduce the old behaviour precisely. Or make the ASSERT more clear.", "author": "gita-omr", "createdAt": "2020-06-17T00:10:05Z", "path": "runtime/compiler/p/codegen/PPCJNILinkage.cpp", "diffHunk": "@@ -433,8 +433,8 @@ TR::Register *J9::Power::JNILinkage::buildDirectDispatch(TR::Node *callNode)\n \n       // push flags: use lis instead of lis/ori pair since this is a constant. Save one instr\n       aValue = fej9->constJNICallOutFrameFlags();\n-      TR_ASSERT((aValue & ~0x7FFF0000) == 0, \"Length assumption broken.\");\n-      generateTrg1ImmInstruction(cg(), TR::InstOpCode::lis, callNode, gr11Reg, (aValue>>16)&0x0000FFFF);\n+      TR_ASSERT_FATAL((aValue & ~0x7FFF0000) == 0, \"Length assumption broken.\");\n+      generateTrg1ImmInstruction(cg(), TR::InstOpCode::lis, callNode, gr11Reg, aValue>>16);", "originalCommit": "f1eae47c09f8f44464d7f6f9ae21d9f7b3a3fb61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU4NDc4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9866#discussion_r441584788", "bodyText": "This assert does guarantee that the upper bits are unset, but thinking about it, I do agree that the type conversions involved can be a bit unintuitive. This works based on sign-extension to intptr_t after negation, so it only works because the upper bit of that mask is set after negating it. Perhaps using (aValue & ~static_cast<uintptr_t>(0x7FFF0000)) instead would make this more clear?", "author": "aviansie-ben", "createdAt": "2020-06-17T14:23:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwODk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI3NDcyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9866#discussion_r442274726", "bodyText": "Opened #9930", "author": "gita-omr", "createdAt": "2020-06-18T14:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwODk1NQ=="}], "type": "inlineReview"}]}