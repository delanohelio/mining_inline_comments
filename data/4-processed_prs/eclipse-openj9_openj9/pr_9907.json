{"pr_number": 9907, "pr_title": "Acquire Thread.lock while calling jvmti suspendThread", "pr_createdAt": "2020-06-16T18:54:54Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9907", "timeline": [{"oid": "a42ef49f4ed3d52082264d33aa08c43d42017aad", "url": "https://github.com/eclipse-openj9/openj9/commit/a42ef49f4ed3d52082264d33aa08c43d42017aad", "message": "Free Thread.lock while calling jvmti suspendThread\n\nIt is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock has been released before suspending. To make sure of this, acquire the lock while halt is in progress.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-06-22T16:27:39Z", "type": "forcePushed"}, {"oid": "043ed1a4a0523fe97b874c0cef71c364772a8d0b", "url": "https://github.com/eclipse-openj9/openj9/commit/043ed1a4a0523fe97b874c0cef71c364772a8d0b", "message": "Free Thread.lock while calling jvmti suspendThread\n\nIt is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock has been released before suspending. To make sure of this, acquire the lock while halt is in progress.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-07-03T18:28:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3MzM3OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r450473378", "bodyText": "The local can't be re-used as the object may move while the thread is suspended.", "author": "gacholio", "createdAt": "2020-07-06T20:52:01Z", "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -54,7 +62,11 @@ suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tomrthread_monitor_exit(targetThread->publicFlagsMutex);\n+\n \t\t\t\t\tcurrentThread->javaVM->internalVMFunctions->internalEnterVMFromJNI(currentThread);\n+\n+\t\t\t\t\t/* Release java.lang.Thread.lock */\n+\t\t\t\t\tobjectMonitorExit(currentThread, threadLock);", "originalCommit": "043ed1a4a0523fe97b874c0cef71c364772a8d0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYxOTY0MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r451619641", "bodyText": "The lock object needs to be refetched from the vmThread.", "author": "gacholio", "createdAt": "2020-07-08T15:09:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3MzM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA1NzkxMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r451057912", "bodyText": "Is the intention to match the java implementation of the Thread.suspend method by acquiring the lock for other threads before suspending?\nhttps://github.com/eclipse/openj9/blob/ea7b2e9783f21f186eb7ac087af77d74dc5a78ad/jcl/src/java.base/share/classes/java/lang/Thread.java#L1280-L1284\nMaking this match the Java implementation makes sense to me but I don't understand the comment above", "author": "DanHeidinga", "createdAt": "2020-07-07T18:20:53Z", "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -45,7 +45,15 @@ suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA\n \t\t\t\tif (currentThread == targetThread) {\n \t\t\t\t\t*currentThreadSuspended = TRUE;\n \t\t\t\t} else {\n+\t\t\t\t\t/* It is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is \n+\t\t\t\t\t * held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock \n+\t\t\t\t\t * has been released before suspending. To make sure of this, acquire the lock while halt is in progress.\n+\t\t\t\t\t */\n+\t\t\t\t\tj9object_t threadLock = J9VMJAVALANGTHREAD_LOCK(targetThread, targetThread->threadObject);", "originalCommit": "043ed1a4a0523fe97b874c0cef71c364772a8d0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA3NTIyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r451075221", "bodyText": "I suspect the lock here is to prevent the thread from dying while we attempt to suspend it. JVMTI uses a different mechanism (vmThreadListMutex and inspectorCount).", "author": "gacholio", "createdAt": "2020-07-07T18:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA1NzkxMg=="}], "type": "inlineReview"}, {"oid": "7c5874765c7e6c6856e273e92b62b594027d083b", "url": "https://github.com/eclipse-openj9/openj9/commit/7c5874765c7e6c6856e273e92b62b594027d083b", "message": "Free Thread.lock while calling jvmti suspendThread\n\nIt is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock has been released before suspending. To make sure of this, acquire the lock while halt is in progress.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-07-08T18:56:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2NTcyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r451765721", "bodyText": "VM can always be fetched from the current thread - there's no need to add the parameter.", "author": "gacholio", "createdAt": "2020-07-08T19:07:23Z", "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -27,7 +27,7 @@\n extern \"C\" {\n \n jvmtiError\n-suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA *currentThreadSuspended)\n+suspendThread(J9JavaVM *vm, J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA *currentThreadSuspended)", "originalCommit": "7c5874765c7e6c6856e273e92b62b594027d083b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2NzQxOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r451767419", "bodyText": "Please cache the internal function table in a local (and change the other uses in this function to use the local).\nhttps://github.com/eclipse/openj9/blob/566007db997abe3f47f25565506c0f5a0a2f1b00/runtime/j9vm/java11vmi.c#L319", "author": "gacholio", "createdAt": "2020-07-08T19:10:42Z", "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -45,7 +45,14 @@ suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA\n \t\t\t\tif (currentThread == targetThread) {\n \t\t\t\t\t*currentThreadSuspended = TRUE;\n \t\t\t\t} else {\n+\t\t\t\t\t/* It is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is \n+\t\t\t\t\t * held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock \n+\t\t\t\t\t * has been released before suspending. To make sure of this, acquire the lock while halt is in progress.\n+\t\t\t\t\t */\n+\t\t\t\t\tvm->internalVMFunctions->objectMonitorEnter(currentThread, J9VMJAVALANGTHREAD_LOCK(targetThread, targetThread->threadObject));", "originalCommit": "7c5874765c7e6c6856e273e92b62b594027d083b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1ODk5OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r451858999", "bodyText": "updated.", "author": "theresa-m", "createdAt": "2020-07-08T22:26:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2NzQxOQ=="}], "type": "inlineReview"}, {"oid": "4b4f9208eb6e33e18151ff602614d9852d76eb20", "url": "https://github.com/eclipse-openj9/openj9/commit/4b4f9208eb6e33e18151ff602614d9852d76eb20", "message": "Free Thread.lock while calling jvmti suspendThread\n\nIt is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock has been released before suspending. To make sure of this, acquire the lock while halt is in progress.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-07-08T22:24:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3MDMzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r451870331", "bodyText": "One final thing - the object field access macros should take currentThread not targetThread.", "author": "gacholio", "createdAt": "2020-07-08T22:59:00Z", "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -45,7 +45,15 @@ suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA\n \t\t\t\tif (currentThread == targetThread) {\n \t\t\t\t\t*currentThreadSuspended = TRUE;\n \t\t\t\t} else {\n-\t\t\t\t\tcurrentThread->javaVM->internalVMFunctions->internalExitVMToJNI(currentThread);\n+\t\t\t\t\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\t\t\t\t\t/* It is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is \n+\t\t\t\t\t * held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock \n+\t\t\t\t\t * has been released before suspending. To make sure of this, acquire the lock while halt is in progress.\n+\t\t\t\t\t */\n+\t\t\t\t\tvmFuncs->objectMonitorEnter(currentThread, J9VMJAVALANGTHREAD_LOCK(targetThread, targetThread->threadObject));", "originalCommit": "4b4f9208eb6e33e18151ff602614d9852d76eb20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjMyMTMzOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r452321339", "bodyText": "vmFuncs->objectMonitorEnter(currentThread, J9VMJAVALANGTHREAD_LOCK(currentThread, currentThread->threadObject));\n\nWouldn't that make it so currentThread is acquiring the lock that belongs to its own class?\nThe way I'm reading the existing line is currentThread is acquiring targetThread's lock to make sure that no targetThread JCL methods are holding it.", "author": "theresa-m", "createdAt": "2020-07-09T15:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3MDMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjMyNDk5OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r452324998", "bodyText": "Only the first parameter should be changed - it's used in some GC policies and must be the current thread.", "author": "gacholio", "createdAt": "2020-07-09T16:00:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3MDMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc4MjA4OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r453782089", "bodyText": "Still waiting for this to be fixed before test/merge.", "author": "gacholio", "createdAt": "2020-07-13T16:38:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3MDMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzNTcwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r451935706", "bodyText": "Can this comment point to the Thread.suspend java implementation?  And clarify that the other Thread state calls like isAlive, etc will block forever if we suspend while the thread is holding the Thead.lock?", "author": "DanHeidinga", "createdAt": "2020-07-09T02:57:23Z", "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -45,7 +45,15 @@ suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA\n \t\t\t\tif (currentThread == targetThread) {\n \t\t\t\t\t*currentThreadSuspended = TRUE;\n \t\t\t\t} else {\n-\t\t\t\t\tcurrentThread->javaVM->internalVMFunctions->internalExitVMToJNI(currentThread);\n+\t\t\t\t\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\t\t\t\t\t/* It is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is \n+\t\t\t\t\t * held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock \n+\t\t\t\t\t * has been released before suspending. To make sure of this, acquire the lock while halt is in progress.", "originalCommit": "4b4f9208eb6e33e18151ff602614d9852d76eb20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjMwNjkwOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r452306909", "bodyText": "Also, the comment (and PR title) say exactly the opposite of what the code is doing - it's acquiring the lock around the suspension, not releasing it.", "author": "gacholio", "createdAt": "2020-07-09T15:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzNTcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjMyODM0NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r452328344", "bodyText": "I've updated the comments to make it more clear.", "author": "theresa-m", "createdAt": "2020-07-09T16:05:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzNTcwNg=="}], "type": "inlineReview"}, {"oid": "2caf6f20babeb1c9ecc799c3e4807f891b2c4723", "url": "https://github.com/eclipse-openj9/openj9/commit/2caf6f20babeb1c9ecc799c3e4807f891b2c4723", "message": "Acquire Thread.lock while calling jvmti suspendThread\n\nMatch Thread.suspend() synchronization by acquiring the target thread's Thread.lock before suspending. This will prevent deadlocks in the JCL library that could occur if a thread is suspended while holding Thread.lock.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-07-09T15:59:03Z", "type": "forcePushed"}, {"oid": "f1c941733205652c550de205b1a47199ee09a15b", "url": "https://github.com/eclipse-openj9/openj9/commit/f1c941733205652c550de205b1a47199ee09a15b", "message": "Acquire Thread.lock while calling jvmti suspendThread\n\nMatch Thread.suspend() synchronization by acquiring the target thread's Thread.lock before suspending. This will prevent deadlocks in the JCL library that could occur if a thread is suspended while holding Thread.lock.\n\nFor example if thread1 is suspended while in the middle of running Thread.isAlive which is synchronized, thread2 calling thread1.interrupt will hang forever since the lock belonging to thread1 will never be released.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-07-09T16:04:28Z", "type": "forcePushed"}, {"oid": "49a7043f52c3a1f66a3c2f4421bd34ee9778fdd5", "url": "https://github.com/eclipse-openj9/openj9/commit/49a7043f52c3a1f66a3c2f4421bd34ee9778fdd5", "message": "Review", "committedDate": "2020-07-21T17:31:01Z", "type": "forcePushed"}, {"oid": "82841a333f074fdd732c5e03751684371408dad4", "url": "https://github.com/eclipse-openj9/openj9/commit/82841a333f074fdd732c5e03751684371408dad4", "message": "Acquire Thread.lock while calling jvmti suspendThread\n\nMatch Thread.suspend() synchronization by acquiring the target thread's Thread.lock before suspending. This will prevent deadlocks in the JCL library that could occur if a thread is suspended while holding Thread.lock.\n\nFor example if thread1 is suspended while in the middle of running Thread.isAlive which is synchronized, thread2 calling thread1.interrupt will hang forever since the lock belonging to thread1 will never be released.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-07-21T18:00:28Z", "type": "commit"}, {"oid": "82841a333f074fdd732c5e03751684371408dad4", "url": "https://github.com/eclipse-openj9/openj9/commit/82841a333f074fdd732c5e03751684371408dad4", "message": "Acquire Thread.lock while calling jvmti suspendThread\n\nMatch Thread.suspend() synchronization by acquiring the target thread's Thread.lock before suspending. This will prevent deadlocks in the JCL library that could occur if a thread is suspended while holding Thread.lock.\n\nFor example if thread1 is suspended while in the middle of running Thread.isAlive which is synchronized, thread2 calling thread1.interrupt will hang forever since the lock belonging to thread1 will never be released.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-07-21T18:00:28Z", "type": "forcePushed"}]}