{"pr_number": 10926, "pr_title": "ReadOnly Interface Dispatch using PIC Slots", "pr_createdAt": "2020-10-19T18:02:24Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10926", "timeline": [{"oid": "dff73375bef73906c9e3bf362dea449251ef0791", "url": "https://github.com/eclipse-openj9/openj9/commit/dff73375bef73906c9e3bf362dea449251ef0791", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-10-19T18:01:35Z", "type": "forcePushed"}, {"oid": "f9a5c32f145161b808fa24fbd75c34a01a8d41f9", "url": "https://github.com/eclipse-openj9/openj9/commit/f9a5c32f145161b808fa24fbd75c34a01a8d41f9", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-10-19T18:19:11Z", "type": "forcePushed"}, {"oid": "52f2861a3710bacef8c64ca5b59c0130fd68575e", "url": "https://github.com/eclipse-openj9/openj9/commit/52f2861a3710bacef8c64ca5b59c0130fd68575e", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-10-19T19:06:08Z", "type": "forcePushed"}, {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10", "url": "https://github.com/eclipse-openj9/openj9/commit/ab82c5d254e0315b3c65722371fda75cc1d79a10", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-10-19T20:20:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwMDY1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510400650", "bodyText": "Why not just change the type of this variable to be intptr_t and remove the casts below?", "author": "fjeremic", "createdAt": "2020-10-22T19:20:29Z", "path": "runtime/compiler/z/codegen/S390J9CallSnippet.cpp", "diffHunk": "@@ -1653,3 +1653,67 @@ TR::S390VirtualUnresolvedReadOnlySnippet::getLength(int32_t estimatedSnippetStar\n            + sizeof(int32_t); /*RIP offset to post snippet call in mainline*/\n    }\n \n+uint8_t *\n+TR::S390InterfaceCallReadOnlySnippet::emitSnippetBody()\n+   {\n+   uint8_t *cursor = cg()->getBinaryBufferCursor();\n+   getSnippetLabel()->setCodeLocation(cursor);\n+   TR::Node *callNode = getNode();\n+\n+   TR::SymbolReference *interfaceCallReadOnlySymRef = cg()->symRefTab()->findOrCreateRuntimeHelper(TR_S390interfaceCallHelperMultiSlotsReadOnly,\n+                                                                                                               false, false, false);\n+   \n+   TR::GlobalFunctionCallData dataDestination(interfaceCallReadOnlySymRef, callNode, cursor, cg(), self());\n+\n+   cursor = cg()->getObjFmt()->encodeGlobalFunctionCall(dataDestination);\n+\n+   uint8_t *helperCallRA = cursor;", "originalCommit": "ab82c5d254e0315b3c65722371fda75cc1d79a10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NDUwMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510984501", "bodyText": "Fixed in https://github.com/eclipse/openj9/compare/ab82c5d254e0315b3c65722371fda75cc1d79a10..3282a01df297676d33999fca192d2613b5db1b09", "author": "r30shah", "createdAt": "2020-10-23T15:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwMDY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwMTg2MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510401860", "bodyText": "void * vs void* inconsistent. Also need spaces between arithmetic + operators.", "author": "fjeremic", "createdAt": "2020-10-22T19:22:45Z", "path": "runtime/compiler/z/codegen/S390J9CallSnippet.cpp", "diffHunk": "@@ -1653,3 +1653,67 @@ TR::S390VirtualUnresolvedReadOnlySnippet::getLength(int32_t estimatedSnippetStar\n            + sizeof(int32_t); /*RIP offset to post snippet call in mainline*/\n    }\n \n+uint8_t *\n+TR::S390InterfaceCallReadOnlySnippet::emitSnippetBody()\n+   {\n+   uint8_t *cursor = cg()->getBinaryBufferCursor();\n+   getSnippetLabel()->setCodeLocation(cursor);\n+   TR::Node *callNode = getNode();\n+\n+   TR::SymbolReference *interfaceCallReadOnlySymRef = cg()->symRefTab()->findOrCreateRuntimeHelper(TR_S390interfaceCallHelperMultiSlotsReadOnly,\n+                                                                                                               false, false, false);\n+   \n+   TR::GlobalFunctionCallData dataDestination(interfaceCallReadOnlySymRef, callNode, cursor, cg(), self());\n+\n+   cursor = cg()->getObjFmt()->encodeGlobalFunctionCall(dataDestination);\n+\n+   uint8_t *helperCallRA = cursor;\n+   TR_ASSERT_FATAL(cg()->canUseRelativeLongInstructions(interfaceCallPICSlotDataAddress), \"interfaceCallPICData %p is outside relative immediate range\", interfaceCallPICSlotDataAddress);\n+   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(interfaceCallPICSlotDataAddress - (intptr_t)helperCallRA);\n+   cursor += sizeof(int32_t);\n+\n+   intptr_t doneLabelAddress = reinterpret_cast<intptr_t>(doneLabel->getCodeLocation());\n+   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(doneLabelAddress - (intptr_t)helperCallRA);\n+   cursor += sizeof(int32_t);\n+\n+   return cursor;\n+   }\n+\n+void\n+TR_Debug::print(TR::FILE *pOutFile, TR::S390InterfaceCallReadOnlySnippet *snippet)\n+   {\n+   uint8_t *bufferPos = snippet->getSnippetLabel()->getCodeLocation();\n+   TR::SymbolReference *resolveVirtualDispatchReadOnlySymRef = _cg->getSymRef(TR_S390interfaceCallHelperMultiSlotsReadOnly);\n+\n+   TR::SymbolReference *methodSymRef = snippet->getNode()->getSymbolReference();\n+   // TODO: Need the address of the ccGlobalFunctionCallData   \n+   printSnippetLabel(pOutFile, snippet->getSnippetLabel(), bufferPos, \"Interface Call Snippet using Multi Slots\");\n+   printPrefix(pOutFile, NULL, bufferPos, 6);\n+   trfprintf(pOutFile, \"LGRL \\tGPR14, <%p>\\t# Load address of the Helper Method, targetAddress = <%p>\",\n+                    (void *)*(int32_t*)(bufferPos+sizeof(int16_t)),", "originalCommit": "ab82c5d254e0315b3c65722371fda75cc1d79a10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NDU3OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510984578", "bodyText": "Fixed in https://github.com/eclipse/openj9/compare/ab82c5d254e0315b3c65722371fda75cc1d79a10..3282a01df297676d33999fca192d2613b5db1b09", "author": "r30shah", "createdAt": "2020-10-23T15:59:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwMTg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwNTg3OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510405879", "bodyText": "static_cast needed here.", "author": "fjeremic", "createdAt": "2020-10-22T19:30:21Z", "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();", "originalCommit": "ab82c5d254e0315b3c65722371fda75cc1d79a10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NTA4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510995081", "bodyText": "Fixed in https://github.com/eclipse/openj9/compare/ab82c5d254e0315b3c65722371fda75cc1d79a10..3282a01df297676d33999fca192d2613b5db1b09", "author": "r30shah", "createdAt": "2020-10-23T16:17:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwNTg3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwNjc3NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510406775", "bodyText": "Can we use a static const inside of ccInterfaceData to store the constant 3 and use it here instead? This seems quite error prone as the magic constant gets used several times in this function and we can replace it with a properly named and scoped constant that is defined right in the struct.", "author": "fjeremic", "createdAt": "2020-10-22T19:31:59Z", "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();\n+   ccInterfaceDataAddress->interfaceClass = 0;\n+   ccInterfaceDataAddress->iTableIndex = 0;\n+   ccInterfaceDataAddress->j2iThunkAddress = virtualThunk;\n+   ccInterfaceDataAddress->totalSizeOfPicSlots = (3 /*Total Number of PICSlots*/ * sizeof(ccInterfaceDataAddress->slot1Class)) + (3 * sizeof(ccInterfaceDataAddress->slot1Method));", "originalCommit": "ab82c5d254e0315b3c65722371fda75cc1d79a10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4Mzc3MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r512083770", "bodyText": "static const field is allocated once for the entire DLL, not per call site. It is a static variable after all. It will not incur any difference to sizeof(ccInterfaceData).", "author": "fjeremic", "createdAt": "2020-10-26T16:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwNjc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEyNDUxMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r512124513", "bodyText": "Sorry, over sighted the suggestion and forgot we can have static members inside struct in C++. Added the static const inside the ccInterfaceData struct to reflect number of PIC slots, https://github.com/eclipse/openj9/compare/e2eb175cf4e392b9a013648129c1209bc1790bc8..7e34301ef20a2e2b9b78a0d987f8c0e5eb801d0c.", "author": "r30shah", "createdAt": "2020-10-26T17:03:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwNjc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwODg4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510408881", "bodyText": "Why is this needed?", "author": "fjeremic", "createdAt": "2020-10-22T19:36:11Z", "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();\n+   ccInterfaceDataAddress->interfaceClass = 0;\n+   ccInterfaceDataAddress->iTableIndex = 0;\n+   ccInterfaceDataAddress->j2iThunkAddress = virtualThunk;\n+   ccInterfaceDataAddress->totalSizeOfPicSlots = (3 /*Total Number of PICSlots*/ * sizeof(ccInterfaceDataAddress->slot1Class)) + (3 * sizeof(ccInterfaceDataAddress->slot1Method));\n+   ccInterfaceDataAddress->isCacheFull = 0;\n+\n+   // Now we are checking each slot and dispatching methods. \n+   intptr_t interfaceDataAddress = reinterpret_cast<intptr_t>(ccInterfaceDataAddress);\n+\n+   TR::StaticSymbol *interfaceDataSymbol =\n+      TR::StaticSymbol::createWithAddress(trHeapMemory(), TR::Address, reinterpret_cast<void *>(interfaceDataAddress));\n+   interfaceDataSymbol->setNotDataAddress();\n+   TR::SymbolReference *interfaceDataSymRef = new (trHeapMemory()) TR::SymbolReference(cg()->comp()->getSymRefTab(), interfaceDataSymbol, 0);\n+\n+   /**\n+    * LARL  regEP, interfaceDataAddress\n+    * LARL  regRA, returnAddress\n+    * Label StartICF: (Attaching predependency conditions here.\n+    * LPQ   Class,MethodAddress, 0(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,MethodAddress\n+    * LPQ   Class,MethodAddress, 16(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * LPQ   Class,MethodAddress, 32(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * Label SnippetCal: (Cache miss, will be calling the snippet)\n+    * BRCL  interfaceCallSnippet\n+    * Label doneLabel: (Attaching Post Deps Here)\n+    */\n+   int32_t numberOfAdditionalPostDeps = 3; // For load pair instruction, we need 3 virtual registers, even reg, odd reg, even-odd pair\n+   TR::Register *regRA = dependencies->searchPostConditionRegister(getReturnAddressRegister());\n+   if (regRA == NULL)\n+      {\n+      regRA = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+   TR::Register *regEP = dependencies->searchPostConditionRegister(getEntryPointRegister());\n+   if (regEP == NULL)\n+      {\n+      regEP = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::Instruction *cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regEP, interfaceDataSymRef, interfaceDataSymbol->getStaticAddress());\n+   TR::LabelSymbol *doneLabel = generateLabelSymbol(cg());\n+   cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regRA, doneLabel, cursor);\n+\n+   TR::RegisterDependencyConditions *preDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies->getPreConditions(), NULL,\n+                                                                                                         dependencies->getAddCursorForPre(), 0, cg());\n+   \n+   TR::RegisterDependencyConditions *postDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies, 0, numberOfAdditionalPostDeps, cg());\n+   // Removing the pre dependencies from the postDeps\n+   postDeps->setAddCursorForPre(0);\n+   postDeps->setNumPreConditions(0, trMemory());", "originalCommit": "ab82c5d254e0315b3c65722371fda75cc1d79a10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NjAzNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510996034", "bodyText": "It is actually not needed, I wanted to just extract the post deps from the original dependencies and add room for extra deps I need in this function. There is a better way to achieve that and I have made change in https://github.com/eclipse/openj9/compare/3282a01df297676d33999fca192d2613b5db1b09..d1f154c59f4e002f94b5e613001eb016a95a6927", "author": "r30shah", "createdAt": "2020-10-23T16:18:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwODg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMTIxNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510411216", "bodyText": "Why is the NOP needed?", "author": "fjeremic", "createdAt": "2020-10-22T19:40:25Z", "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();\n+   ccInterfaceDataAddress->interfaceClass = 0;\n+   ccInterfaceDataAddress->iTableIndex = 0;\n+   ccInterfaceDataAddress->j2iThunkAddress = virtualThunk;\n+   ccInterfaceDataAddress->totalSizeOfPicSlots = (3 /*Total Number of PICSlots*/ * sizeof(ccInterfaceDataAddress->slot1Class)) + (3 * sizeof(ccInterfaceDataAddress->slot1Method));\n+   ccInterfaceDataAddress->isCacheFull = 0;\n+\n+   // Now we are checking each slot and dispatching methods. \n+   intptr_t interfaceDataAddress = reinterpret_cast<intptr_t>(ccInterfaceDataAddress);\n+\n+   TR::StaticSymbol *interfaceDataSymbol =\n+      TR::StaticSymbol::createWithAddress(trHeapMemory(), TR::Address, reinterpret_cast<void *>(interfaceDataAddress));\n+   interfaceDataSymbol->setNotDataAddress();\n+   TR::SymbolReference *interfaceDataSymRef = new (trHeapMemory()) TR::SymbolReference(cg()->comp()->getSymRefTab(), interfaceDataSymbol, 0);\n+\n+   /**\n+    * LARL  regEP, interfaceDataAddress\n+    * LARL  regRA, returnAddress\n+    * Label StartICF: (Attaching predependency conditions here.\n+    * LPQ   Class,MethodAddress, 0(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,MethodAddress\n+    * LPQ   Class,MethodAddress, 16(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * LPQ   Class,MethodAddress, 32(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * Label SnippetCal: (Cache miss, will be calling the snippet)\n+    * BRCL  interfaceCallSnippet\n+    * Label doneLabel: (Attaching Post Deps Here)\n+    */\n+   int32_t numberOfAdditionalPostDeps = 3; // For load pair instruction, we need 3 virtual registers, even reg, odd reg, even-odd pair\n+   TR::Register *regRA = dependencies->searchPostConditionRegister(getReturnAddressRegister());\n+   if (regRA == NULL)\n+      {\n+      regRA = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+   TR::Register *regEP = dependencies->searchPostConditionRegister(getEntryPointRegister());\n+   if (regEP == NULL)\n+      {\n+      regEP = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::Instruction *cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regEP, interfaceDataSymRef, interfaceDataSymbol->getStaticAddress());\n+   TR::LabelSymbol *doneLabel = generateLabelSymbol(cg());\n+   cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regRA, doneLabel, cursor);\n+\n+   TR::RegisterDependencyConditions *preDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies->getPreConditions(), NULL,\n+                                                                                                         dependencies->getAddCursorForPre(), 0, cg());\n+   \n+   TR::RegisterDependencyConditions *postDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies, 0, numberOfAdditionalPostDeps, cg());\n+   // Removing the pre dependencies from the postDeps\n+   postDeps->setAddCursorForPre(0);\n+   postDeps->setNumPreConditions(0, trMemory());\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg());\n+   cursor = generateS390LabelInstruction(cg(), TR::InstOpCode::LABEL, callNode, cFlowRegionStart, preDeps, cursor);\n+\n+   TR::Register      *slotClassReg = cg()->allocateRegister();\n+   TR::Register      *slotMethodAddressReg = cg()->allocateRegister();\n+   TR::RegisterPair  *slotClassMethodRegPair = cg()->allocateConsecutiveRegisterPair(slotMethodAddressReg, slotClassReg);\n+   postDeps->addPostCondition(slotClassReg, TR::RealRegister::LegalEvenOfPair);\n+   postDeps->addPostCondition(slotMethodAddressReg, TR::RealRegister::LegalOddOfPair);\n+   postDeps->addPostCondition(slotClassMethodRegPair, TR::RealRegister::EvenOddPair);\n+   postDeps->addPostConditionIfNotAlreadyInserted(vftReg, TR::RealRegister::AssignAny);\n+   cursor = generateRXInstruction(cg(), TR::InstOpCode::LPQ, callNode, slotClassMethodRegPair,\n+                                    generateS390MemoryReference(regEP, offsetof(ccInterfaceData, slot1Class), cg()), cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::CGR, callNode, slotClassReg, vftReg, cursor);\n+   cursor =generateS390BranchInstruction(cg(), TR::InstOpCode::BCR, callNode, TR::InstOpCode::COND_BE, slotMethodAddressReg, cursor);\n+\n+   cursor = generateRXInstruction(cg(), TR::InstOpCode::LPQ, callNode, slotClassMethodRegPair,\n+                                    generateS390MemoryReference(regEP, offsetof(ccInterfaceData, slot2Class), cg()), cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::CGR, callNode, slotClassReg, vftReg, cursor);\n+   cursor =generateS390BranchInstruction(cg(), TR::InstOpCode::BCR, callNode, TR::InstOpCode::COND_BE, slotMethodAddressReg, cursor);\n+   \n+   cursor = generateRXInstruction(cg(), TR::InstOpCode::LPQ, callNode, slotClassMethodRegPair,\n+                                    generateS390MemoryReference(regEP, offsetof(ccInterfaceData, slot3Class), cg()), cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::CGR, callNode, slotClassReg, vftReg, cursor);\n+   cursor =generateS390BranchInstruction(cg(), TR::InstOpCode::BCR, callNode, TR::InstOpCode::COND_BE, slotMethodAddressReg, cursor);\n+   \n+   TR::LabelSymbol *interfaceCallHelperSnippetLabel = generateLabelSymbol(cg());\n+   TR::S390InterfaceCallReadOnlySnippet *snippet = new (trHeapMemory()) TR::S390InterfaceCallReadOnlySnippet(\n+      cg(),\n+      callNode,\n+      interfaceCallHelperSnippetLabel,\n+      doneLabel,\n+      interfaceDataAddress);\n+   // Cache miss, going to slow path to lookup the interface method.\n+   cursor = new (trHeapMemory()) TR::S390RILInstruction(TR::InstOpCode::BRCL, callNode, 0xF, snippet, NULL, cg());\n+   cursor = new (trHeapMemory()) TR::S390NOPInstruction(TR::InstOpCode::NOP, 2, callNode, cg()); ", "originalCommit": "ab82c5d254e0315b3c65722371fda75cc1d79a10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5ODY2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510998664", "bodyText": "According to comment in https://github.com/eclipse/openj9/blob/67d8cf0cd31d5215756678a1cd434fc04af98055/runtime/compiler/z/codegen/S390PrivateLinkage.cpp#L2189 It is needed for the patchupVirtualCall, I feel it needs more clear documentation then that. I remember, while testing when I commented out the NOP it was failing the tests, let me find-out the exact call path that that requires this NOP.", "author": "r30shah", "createdAt": "2020-10-23T16:23:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMTIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4NTAyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r512085022", "bodyText": "Ok, we should put the same comment here as exists in the JVM path linked above. I could definitely see someone not knowing anything about this coming down and removing the NOP thinking it shouldn't exist.", "author": "fjeremic", "createdAt": "2020-10-26T16:13:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMTIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjExOTMxNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r512119314", "bodyText": "I have copied the same comment in https://github.com/eclipse/openj9/compare/e2eb175cf4e392b9a013648129c1209bc1790bc8..7e34301ef20a2e2b9b78a0d987f8c0e5eb801d0c\nCurrently checking the path that needs this NOP, will modify if I find something useful.", "author": "r30shah", "createdAt": "2020-10-26T16:55:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMTIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMzI1NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510413254", "bodyText": "We should try to keep the names of these the same as the fields for easier searchability. For example searching for \"totalSizeOfPicSlots\" will not get a hit here.", "author": "fjeremic", "createdAt": "2020-10-22T19:44:19Z", "path": "runtime/compiler/z/runtime/PicBuilder.m4", "diffHunk": "@@ -155,6 +155,24 @@ SETVAL(eq_returnAddressDirectMethod,8)\n SETVAL(eq_resolveVirtualJitEIPForHelperCall,12)\n SETVAL(eq_ResolveVirtualData_RIP,0)\n \n+ZZ Interface Call Helper Read Only Layout\n+SETVAL(eq_InterfaceCallHelperReadOnly_Data,0)\n+SETVAL(eq_InterfaceCallHelperClassPICSlot1,0)\n+SETVAL(eq_InterfaceCallHelperMethodPICSlot1,8)\n+SETVAL(eq_InterfaceCallHelperClassPICSlot2,16)\n+SETVAL(eq_InterfaceCallHelperMethodPICSlot2,24)\n+SETVAL(eq_InterfaceCallHelperClassPICSlot3,32)\n+SETVAL(eq_InterfaceCallHelperMethodPICSlot3,40)\n+SETVAL(eq_InterfaceCallHelper_cpAddress,48)\n+SETVAL(eq_InterfaceCallHelper_cpIndex,56)\n+SETVAL(eq_InterfaceCallHelper_interfaceClass,64)\n+SETVAL(eq_InterfaceCallHelper_methodIndex,72)\n+SETVAL(eq_InterfaceCallHelperTotalPICSlotSize,88)\n+SETVAL(eq_InterfaceCallHelper_isCacheFullFlag,96)", "originalCommit": "ab82c5d254e0315b3c65722371fda75cc1d79a10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NjI5MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510996290", "bodyText": "Fixed in https://github.com/eclipse/openj9/compare/ab82c5d254e0315b3c65722371fda75cc1d79a10..3282a01df297676d33999fca192d2613b5db1b09", "author": "r30shah", "createdAt": "2020-10-23T16:19:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMzI1NA=="}], "type": "inlineReview"}, {"oid": "3282a01df297676d33999fca192d2613b5db1b09", "url": "https://github.com/eclipse-openj9/openj9/commit/3282a01df297676d33999fca192d2613b5db1b09", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-10-23T15:58:42Z", "type": "forcePushed"}, {"oid": "d1f154c59f4e002f94b5e613001eb016a95a6927", "url": "https://github.com/eclipse-openj9/openj9/commit/d1f154c59f4e002f94b5e613001eb016a95a6927", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-10-23T16:15:31Z", "type": "forcePushed"}, {"oid": "e2eb175cf4e392b9a013648129c1209bc1790bc8", "url": "https://github.com/eclipse-openj9/openj9/commit/e2eb175cf4e392b9a013648129c1209bc1790bc8", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-10-26T14:38:49Z", "type": "forcePushed"}, {"oid": "7e34301ef20a2e2b9b78a0d987f8c0e5eb801d0c", "url": "https://github.com/eclipse-openj9/openj9/commit/7e34301ef20a2e2b9b78a0d987f8c0e5eb801d0c", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-10-26T16:53:50Z", "type": "commit"}, {"oid": "7e34301ef20a2e2b9b78a0d987f8c0e5eb801d0c", "url": "https://github.com/eclipse-openj9/openj9/commit/7e34301ef20a2e2b9b78a0d987f8c0e5eb801d0c", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-10-26T16:53:50Z", "type": "forcePushed"}]}