{"pr_number": 11393, "pr_title": "Remove unneeded code in NULLCHKEvaluator", "pr_createdAt": "2020-12-07T22:36:00Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/11393", "timeline": [{"oid": "4870a0dbcafbff3fd8d2bf3451f001352677f096", "url": "https://github.com/eclipse-openj9/openj9/commit/4870a0dbcafbff3fd8d2bf3451f001352677f096", "message": "Remove unneeded code in NULLCHKEvaluator\n\nThere is code which decrements and increments node counts for stores and\nloads which is unnecessary. In the case of stores, the IL trees do not\nproduce a value so decrementing and then incrementing the node does\nnothing at all. The comment seemingly implies that the result may return\nNULL (presumably from the evaluators) however such a value is never\nconsumed so it should not matter.\n\nIn the case of loads we seem to be trying to avoid a evaluating a load\nwith exactly one unevaluated reference underneath a NULLCHK which will\nnever happen because such IL will have been purged from the method\nduring simplification passes at the optimizer level.\n\nWith all this, there is no need to replicate such logic across all the\nplatforms, and we simply delete the code.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>", "committedDate": "2020-12-15T17:16:39Z", "type": "forcePushed"}, {"oid": "602e95240bd6a245c0e2ff0c95dd61918cd11792", "url": "https://github.com/eclipse-openj9/openj9/commit/602e95240bd6a245c0e2ff0c95dd61918cd11792", "message": "Remove unneeded code in NULLCHKEvaluator\n\nThere is code which decrements and increments node counts for stores and\nloads which is unnecessary. In the case of stores, the IL trees do not\nproduce a value so decrementing and then incrementing the node does\nnothing at all. The comment seemingly implies that the result may return\nNULL (presumably from the evaluators) however such a value is never\nconsumed so it should not matter.\n\nIn the case of loads we seem to be trying to avoid a evaluating a load\nwith exactly one unevaluated reference underneath a NULLCHK which will\nnever happen because such IL will have been purged from the method\nduring simplification passes at the optimizer level.\n\nWith all this, there is no need to replicate such logic across all the\nplatforms, and we simply delete the code.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>", "committedDate": "2020-12-15T17:18:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjEyNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11393#discussion_r552966124", "bodyText": "Found the issue. It appears that the code is slightly different on x86 than on Z and Power in this area. The mistake here is the new line we added should be cg->evaluate(node->getFirstChild());. This is because on x86 we modify the value of firstChild where as on Z and Power we do not.\nHere is explicitly where we do this in the code on x86:\nhttps://github.com/eclipse/openj9/blob/137829daa49943b5129f54bdac8aa5754b2e3186/runtime/compiler/x/codegen/J9TreeEvaluator.cpp#L1665-L1688\nAnd for reference here it is on Z for example (where we use a separate variable n to do this):\nhttps://github.com/eclipse/openj9/blob/137829daa49943b5129f54bdac8aa5754b2e3186/runtime/compiler/z/codegen/J9TreeEvaluator.cpp#L5571-L5590\nAnd here it is on Power:\nhttps://github.com/eclipse/openj9/blob/137829daa49943b5129f54bdac8aa5754b2e3186/runtime/compiler/p/codegen/J9TreeEvaluator.cpp#L13111-L13124", "author": "fjeremic", "createdAt": "2021-01-06T21:19:09Z", "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2001,25 +2001,7 @@ TR::Register *J9::X86::TreeEvaluator::evaluateNULLCHKWithPossibleResolve(\n    //\n    if (needLateEvaluation)\n       {\n-      if (comp->useCompressedPointers())\n-         {\n-         // for stores under NULLCHKs, artificially bump\n-         // down the reference count before evaluation (since stores\n-         // return null as registers)\n-         //\n-         bool fixRefCount = false;\n-         if (node->getFirstChild()->getOpCode().isStoreIndirect() &&\n-               node->getFirstChild()->getReferenceCount() > 1)\n-            {\n-            node->getFirstChild()->decReferenceCount();\n-            fixRefCount = true;\n-            }\n-         cg->evaluate(node->getFirstChild());\n-         if (fixRefCount)\n-            node->getFirstChild()->incReferenceCount();\n-         }\n-      else\n-         cg->evaluate(firstChild);\n+      cg->evaluate(firstChild);", "originalCommit": "602e95240bd6a245c0e2ff0c95dd61918cd11792", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk3OTA5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11393#discussion_r552979091", "bodyText": "In fact I believe x86 has a bug here, or at the very least we are missing opportunities. Because we modify the value of firstChild the computation on line 1684:\nhttps://github.com/eclipse/openj9/blob/137829daa49943b5129f54bdac8aa5754b2e3186/runtime/compiler/x/codegen/J9TreeEvaluator.cpp#L1659-L1713\nthis subsequent line:\nhttps://github.com/eclipse/openj9/blob/137829daa49943b5129f54bdac8aa5754b2e3186/runtime/compiler/x/codegen/J9TreeEvaluator.cpp#L1690\nMeans that all the subsequent if and else if checks will fail! This is because opcode is an indirect load IL, and all the checks are checking for something else, for example:\n   if (opCode.isLoadVar() || (comp->target().is64Bit() && opCode.getOpCodeValue()==TR::l2i))\n...\n   else if (opCode.isStore())\n...\n   else if (opCode.isCall()     &&\n            opCode.isIndirect() &&\n            cg->getNumberBytesReadInaccessible() > TR::Compiler->om.offsetOfObjectVftField())\n...\n   else if (opCode.getOpCodeValue() == TR::monent ||\n            opCode.getOpCodeValue() == TR::monexit)\n...\n   else if (!disableBranchlessPassThroughNULLCHK && opCode.getOpCodeValue () == TR::PassThrough\n            && !needResolution && cg->getHasResumableTrapHandler())\n...\n\nAll of these checks will fail. Surely this is a bug right?", "author": "fjeremic", "createdAt": "2021-01-06T21:52:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk3OTg3MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11393#discussion_r552979871", "bodyText": "@0xdaryl I think this may be outside the scope of this PR to fix because the above code has been dead for quite a while. I'm not sure what will happen if we suddenly start running all that code. Let me know what you think on how we should proceed here. The way I see it we have a few options:\n\nLeave the code as is for now and open up an issue\nTry enabling the code and see if any tests fail\nWait until we can common up this evaluator as much of it can be shared across platforms and fix it then\n???\n\nNote to fix the failures observed in this PR is a trivial fix as noted in the first comment in this chain. I'll definitely be making that change. The question here is what to do about reusing firstChild and updating it incorrectly thus making a bunch of subsequent code effectively dead.", "author": "fjeremic", "createdAt": "2021-01-06T21:54:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDMyMTYwMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11393#discussion_r560321600", "bodyText": "Thanks for the thorough scouring of this code.\nI think the output of the loop on L1683-L1684 will either be an indirect load opcode or a readbar opcode.  If it is an indirect load opcode then the condition on L1710 will still succeed because an indirect load will answer true for an isLoadVar() query.  readbars do seem to skip this logic and will generate an explicit NULLCHK (it isn't clear to me if that is the expected behaviour or not).\nCan you push a fix for just the problem found in this PR?  Any further work we need to investigate can be handled in a separate issue.", "author": "0xdaryl", "createdAt": "2021-01-19T16:43:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjEyNA=="}], "type": "inlineReview"}, {"oid": "04ed11240e095e5f6ab2a67d1be2681d08a40137", "url": "https://github.com/eclipse-openj9/openj9/commit/04ed11240e095e5f6ab2a67d1be2681d08a40137", "message": "Remove unneeded code in NULLCHKEvaluator\n\nThere is code which decrements and increments node counts for stores and\nloads which is unnecessary. In the case of stores, the IL trees do not\nproduce a value so decrementing and then incrementing the node does\nnothing at all. The comment seemingly implies that the result may return\nNULL (presumably from the evaluators) however such a value is never\nconsumed so it should not matter.\n\nIn the case of loads we seem to be trying to avoid a evaluating a load\nwith exactly one unevaluated reference underneath a NULLCHK which will\nnever happen because such IL will have been purged from the method\nduring simplification passes at the optimizer level.\n\nWith all this, there is no need to replicate such logic across all the\nplatforms, and we simply delete the code.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>", "committedDate": "2021-01-20T21:05:56Z", "type": "forcePushed"}, {"oid": "6467f5b8abd7b2cee03a847d7d85e2028a97febe", "url": "https://github.com/eclipse-openj9/openj9/commit/6467f5b8abd7b2cee03a847d7d85e2028a97febe", "message": "Remove unneeded code in NULLCHKEvaluator\n\nThere is code which decrements and increments node counts for stores and\nloads which is unnecessary. In the case of stores, the IL trees do not\nproduce a value so decrementing and then incrementing the node does\nnothing at all. The comment seemingly implies that the result may return\nNULL (presumably from the evaluators) however such a value is never\nconsumed so it should not matter.\n\nIn the case of loads we seem to be trying to avoid a evaluating a load\nwith exactly one unevaluated reference underneath a NULLCHK which will\nnever happen because such IL will have been purged from the method\nduring simplification passes at the optimizer level.\n\nWith all this, there is no need to replicate such logic across all the\nplatforms, and we simply delete the code.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>", "committedDate": "2021-01-28T15:09:19Z", "type": "commit"}, {"oid": "6467f5b8abd7b2cee03a847d7d85e2028a97febe", "url": "https://github.com/eclipse-openj9/openj9/commit/6467f5b8abd7b2cee03a847d7d85e2028a97febe", "message": "Remove unneeded code in NULLCHKEvaluator\n\nThere is code which decrements and increments node counts for stores and\nloads which is unnecessary. In the case of stores, the IL trees do not\nproduce a value so decrementing and then incrementing the node does\nnothing at all. The comment seemingly implies that the result may return\nNULL (presumably from the evaluators) however such a value is never\nconsumed so it should not matter.\n\nIn the case of loads we seem to be trying to avoid a evaluating a load\nwith exactly one unevaluated reference underneath a NULLCHK which will\nnever happen because such IL will have been purged from the method\nduring simplification passes at the optimizer level.\n\nWith all this, there is no need to replicate such logic across all the\nplatforms, and we simply delete the code.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>", "committedDate": "2021-01-28T15:09:19Z", "type": "forcePushed"}]}