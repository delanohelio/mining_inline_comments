{"pr_number": 10366, "pr_title": "Recognize Unsafe.copyMemory0 in JDK11", "pr_createdAt": "2020-08-11T13:04:26Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10366", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU2NTM3Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r468565372", "bodyText": "I have a question to both @gita-omr  and @andrewcraik , I see that P and x86 codegen further forces the Unsafe.copyMemory calls to be inlined in case optimizer misses it. I do not see we do it on Z. Is it possible (Apart from running with noOpt) that optimizer would miss this call to transform?", "author": "r30shah", "createdAt": "2020-08-11T13:08:29Z", "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -11993,8 +11993,11 @@ J9::Power::CodeGenerator::inlineDirectCall(TR::Node *node, TR::Register *&result\n             }\n          break;\n          }\n-", "originalCommit": "643d77094f17e6804dca021bf8e12c9a8a638090", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU3ODU5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r468578591", "bodyText": "the inlining in the inliner is always optional - the inliner may run out of budget before considering a call or may choose to spend budget elsewhere. While things like always inline bypass most of the heuristics related to budget - the current inliner is eager and so once it has consumed its budget it will stop considering callsites which can leave 'alwaysInline' methods not inlined.", "author": "andrewcraik", "createdAt": "2020-08-11T13:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU2NTM3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4NDg4Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r471784886", "bodyText": "IMO we should move that reduction out of the codegen evaluators and right into the J9RecognizedCallTransformer so all codegens can transparently take advantage. I'd try to avoid duplicating the already duplicated logic on Z.", "author": "fjeremic", "createdAt": "2020-08-17T21:27:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU2NTM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU3OTI4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r468579283", "bodyText": "I am not a fan of ifdef'd enum entries this makes corefile analysis and other things much harder than it needs to be - keep the numbering consistent. We do not generally use JDK version macros like this.", "author": "andrewcraik", "createdAt": "2020-08-11T13:29:26Z", "path": "runtime/compiler/codegen/J9RecognizedMethodsEnum.hpp", "diffHunk": "@@ -415,6 +415,10 @@\n \n    sun_misc_Unsafe_ensureClassInitialized,\n \n+#if JAVA_SPEC_VERSION >= 11", "originalCommit": "643d77094f17e6804dca021bf8e12c9a8a638090", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4MTAxMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r468581010", "bodyText": "I really don't think the method specific naming convention here makes sense. I think we should have an Unsafe_copyMemory_intrinsic which is what we match the sun/misc/Unsafe.copyMemory to under JDK8 and what we match the copyMemory0 to under JDK11. I think also that if there is a method to be inlined like jdk_internal_misc_Unsafe_copyMmeory0 that recognition can be matched unconditionally - it will only match when we are running JDK11 onward when the method moved. If there is a windows where the method moved but was native we can just check for the method being native before we recognize it and make all that matching code uncondition.\nUsing the Unsafe_copyMemory_intrinsic that is what OMR can reference and avoid Java specific issues to surface at that level of the architecture.", "author": "andrewcraik", "createdAt": "2020-08-11T13:31:54Z", "path": "runtime/compiler/il/J9Node.cpp", "diffHunk": "@@ -299,7 +299,12 @@ J9::Node::processJNICall(TR::TreeTop * callNodeTreeTop, TR::ResolvedMethodSymbol\n #endif\n \n    if (comp->canTransformUnsafeCopyToArrayCopy() &&\n-       (methodSymbol->getRecognizedMethod() == TR::sun_misc_Unsafe_copyMemory))\n+#if JAVA_SPEC_VERSION == 8", "originalCommit": "643d77094f17e6804dca021bf8e12c9a8a638090", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk0MDIyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r468940222", "bodyText": "@andrewcraik  I have made changes that removes the #if macros that was checking the JAVA Version. I agree that we do not have to guard jdk_internal_misc_Unsafe_copyMmeory0 with JAVA SPEC version. Right now in JDK8 and JDK11, we have seen JNI methods sun/misc/Unsafe.copyMemory and jdk/internal/misc/Unsafe.copyMemory0 respectively and I have added an additional check to make sure it does the transformation only when it is JNI method in d1952e6", "author": "r30shah", "createdAt": "2020-08-12T00:38:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4MTAxMA=="}], "type": "inlineReview"}, {"oid": "5bba1b1fbddd33850baf2a68cf9bd80d96689234", "url": "https://github.com/eclipse-openj9/openj9/commit/5bba1b1fbddd33850baf2a68cf9bd80d96689234", "message": "Move transformUnsafeCopyMemoryCall in OpenJ9\n\nTransformation from Unsafe.copyMemory to System.arrayCopy was Java\nspecific transformation. This commit moves the transformation to OpenJ9.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-08-11T20:43:44Z", "type": "forcePushed"}, {"oid": "cdb436ce300395af11b2c1e141c4aa783f6e71b2", "url": "https://github.com/eclipse-openj9/openj9/commit/cdb436ce300395af11b2c1e141c4aa783f6e71b2", "message": "Move transformUnsafeCopyMemoryCall in OpenJ9\n\nTransformation from Unsafe.copyMemory to System.arrayCopy was Java\nspecific transformation. This commit moves the transformation to OpenJ9.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-08-12T00:31:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk0MDc4NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r468940785", "bodyText": "I found that having a query on the call node is the most convenient place as we can have all the information to check whether call node is JNI call and it is one of the recognized copyMemory method.", "author": "r30shah", "createdAt": "2020-08-12T00:40:44Z", "path": "runtime/compiler/il/J9Node.cpp", "diffHunk": "@@ -2212,6 +2212,23 @@ J9::Node::setDontInlinePutOrderedCall()\n    }\n \n bool\n+J9::Node::isUnsafeCopyMemoryIntrinsic()", "originalCommit": "cdb436ce300395af11b2c1e141c4aa783f6e71b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcxOTY5Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r471719693", "bodyText": "These seem to only get used within the if block below. Can we move them there to limit the scope of the variables and make the code easier to reason about?", "author": "fjeremic", "createdAt": "2020-08-17T19:11:08Z", "path": "runtime/compiler/optimizer/J9ValuePropagation.cpp", "diffHunk": "@@ -483,6 +483,88 @@ bool J9::ValuePropagation::transformIndexOfKnownString(\n    return false;\n    }\n \n+bool J9::ValuePropagation::transformUnsafeCopyMemoryCall(TR::Node *arraycopyNode)\n+   {\n+   if (!canRunTransformToArrayCopy())\n+      return false;\n+\n+   TR::TreeTop *tt = _curTree;\n+   TR::Node *ttNode = tt->getNode();", "originalCommit": "cdb436ce300395af11b2c1e141c4aa783f6e71b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc0MDYyNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r471740625", "bodyText": "Fixed in https://github.com/eclipse/openj9/compare/d8f5f521fc955e5cb1fbfeaa0d418cb475503a1a..ff0b1e1650935286a1a1c68ca3f5b8d8402e489a", "author": "r30shah", "createdAt": "2020-08-17T19:55:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcxOTY5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcyMDY2MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r471720661", "bodyText": "We can move these definitions down to where the variables get set, so:\n         int64_t srcOffLow   = srcOffsetConstraint ? srcOffsetConstraint->getLowInt() : TR::getMinSigned<TR::Int32>();\n         int64_t srcOffHigh  = srcOffsetConstraint ? srcOffsetConstraint->getHighInt() : TR::getMaxSigned<TR::Int32>();\n         int64_t dstOffLow   = dstOffsetConstraint ? dstOffsetConstraint->getLowInt() : TR::getMinSigned<TR::Int32>();\n         int64_t dstOffHigh  = dstOffsetConstraint ? dstOffsetConstraint->getHighInt() : TR::getMaxSigned<TR::Int32>();\n         int64_t copyLenLow  = copyLenConstraint   ? copyLenConstraint->getLowInt() : TR::getMinSigned<TR::Int32>();\n         int64_t copyLenHigh = copyLenConstraint   ? copyLenConstraint->getHighInt() : TR::getMaxSigned<TR::Int32>();", "author": "fjeremic", "createdAt": "2020-08-17T19:13:08Z", "path": "runtime/compiler/optimizer/J9ValuePropagation.cpp", "diffHunk": "@@ -483,6 +483,88 @@ bool J9::ValuePropagation::transformIndexOfKnownString(\n    return false;\n    }\n \n+bool J9::ValuePropagation::transformUnsafeCopyMemoryCall(TR::Node *arraycopyNode)\n+   {\n+   if (!canRunTransformToArrayCopy())\n+      return false;\n+\n+   TR::TreeTop *tt = _curTree;\n+   TR::Node *ttNode = tt->getNode();\n+\n+   if (comp()->canTransformUnsafeCopyToArrayCopy()\n+         && arraycopyNode->isUnsafeCopyMemoryIntrinsic())\n+      {\n+\n+      if ((ttNode->getOpCodeValue() == TR::treetop || ttNode->getOpCode().isResolveOrNullCheck())\n+            && performTransformation(comp(), \"%sChanging call Unsafe.copyMemory [%p] to arraycopy\\n\", OPT_DETAILS, arraycopyNode))\n+\n+         {\n+         TR::Node *unsafe     = arraycopyNode->getChild(0);\n+         TR::Node *src        = arraycopyNode->getChild(1);\n+         TR::Node *srcOffset  = arraycopyNode->getChild(2);\n+         TR::Node *dest       = arraycopyNode->getChild(3);\n+         TR::Node *destOffset = arraycopyNode->getChild(4);\n+         TR::Node *len        = arraycopyNode->getChild(5);\n+\n+         int64_t srcOffLow;\n+         int64_t srcOffHigh;\n+         int64_t dstOffLow;\n+         int64_t dstOffHigh;\n+         int64_t copyLenLow;\n+         int64_t copyLenHigh;", "originalCommit": "cdb436ce300395af11b2c1e141c4aa783f6e71b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTczOTg3MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r471739870", "bodyText": "Fixed in https://github.com/eclipse/openj9/compare/cdb436ce300395af11b2c1e141c4aa783f6e71b2..d8f5f521fc955e5cb1fbfeaa0d418cb475503a1a", "author": "r30shah", "createdAt": "2020-08-17T19:53:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcyMDY2MQ=="}], "type": "inlineReview"}, {"oid": "d8f5f521fc955e5cb1fbfeaa0d418cb475503a1a", "url": "https://github.com/eclipse-openj9/openj9/commit/d8f5f521fc955e5cb1fbfeaa0d418cb475503a1a", "message": "Move transformUnsafeCopyMemoryCall in OpenJ9\n\nTransformation from Unsafe.copyMemory to System.arrayCopy was Java\nspecific transformation. This commit moves the transformation to OpenJ9.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-08-17T19:52:30Z", "type": "forcePushed"}, {"oid": "ff0b1e1650935286a1a1c68ca3f5b8d8402e489a", "url": "https://github.com/eclipse-openj9/openj9/commit/ff0b1e1650935286a1a1c68ca3f5b8d8402e489a", "message": "Move transformUnsafeCopyMemoryCall in OpenJ9\n\nTransformation from Unsafe.copyMemory to System.arrayCopy was Java\nspecific transformation. This commit moves the transformation to OpenJ9.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-08-17T19:54:39Z", "type": "forcePushed"}, {"oid": "5b7e35a24c88400aebba54647550e37df536c44c", "url": "https://github.com/eclipse-openj9/openj9/commit/5b7e35a24c88400aebba54647550e37df536c44c", "message": "Move transformUnsafeCopyMemoryCall in OpenJ9\n\nTransformation from Unsafe.copyMemory to System.arrayCopy was Java\nspecific transformation. This commit moves the transformation to OpenJ9.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-08-17T19:58:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4MjM1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r471782351", "bodyText": "So many return points! Now sure if this would be cleaner:\n   if (self()->getOpCode().isCall() && self()->getSymbol()->isMethod())\n      {\n      TR::MethodSymbol *symbol = self()->getSymbol()->getMethodSymbol();\n      if (symbol != NULL && symbol->isNative())\n         {\n         switch (symbol->getRecognizedMethod())\n            {\n            case TR::sun_misc_Unsafe_copyMemory:\n            case TR::jdk_internal_misc_Unsafe_copyMemory0:\n                return true;\n            default:\n                break;\n            }\n         }\n      }\n   \n   return false;", "author": "fjeremic", "createdAt": "2020-08-17T21:22:19Z", "path": "runtime/compiler/il/J9Node.cpp", "diffHunk": "@@ -2212,6 +2212,23 @@ J9::Node::setDontInlinePutOrderedCall()\n    }\n \n bool\n+J9::Node::isUnsafeCopyMemoryIntrinsic()\n+   {\n+   if (!self()->getOpCode().isCall() || !self()->getSymbol()->isMethod())\n+      return false;\n+   TR::MethodSymbol *symbol = self()->getSymbol()->getMethodSymbol();\n+   if (!symbol || !symbol->isNative())\n+      return false;\n+   switch (symbol->getRecognizedMethod())\n+      {\n+      case TR::sun_misc_Unsafe_copyMemory:\n+      case TR::jdk_internal_misc_Unsafe_copyMemory0:\n+         return true;\n+      default:\n+         return false;\n+      }", "originalCommit": "5b7e35a24c88400aebba54647550e37df536c44c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1MzIzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r471853231", "bodyText": "Fixed in https://github.com/eclipse/openj9/compare/5b7e35a24c88400aebba54647550e37df536c44c..91cf3d3105d3cec00915a532186cdcbf5977262d", "author": "r30shah", "createdAt": "2020-08-18T00:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4MjM1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4MjU0Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r471782542", "bodyText": "This needs to be Doxygen documented as to why it exists and what is its purpose.", "author": "fjeremic", "createdAt": "2020-08-17T21:22:45Z", "path": "runtime/compiler/il/J9Node.hpp", "diffHunk": "@@ -284,6 +284,8 @@ class OMR_EXTENSIBLE Node : public OMR::NodeConnector\n    bool chkDontInlineUnsafePutOrderedCall();\n    const char * printIsDontInlineUnsafePutOrderedCall();\n \n+   bool isUnsafeCopyMemoryIntrinsic();", "originalCommit": "5b7e35a24c88400aebba54647550e37df536c44c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1MzE0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r471853149", "bodyText": "Added brief in https://github.com/eclipse/openj9/compare/5b7e35a24c88400aebba54647550e37df536c44c..91cf3d3105d3cec00915a532186cdcbf5977262d", "author": "r30shah", "createdAt": "2020-08-18T00:56:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4MjU0Mg=="}], "type": "inlineReview"}, {"oid": "91cf3d3105d3cec00915a532186cdcbf5977262d", "url": "https://github.com/eclipse-openj9/openj9/commit/91cf3d3105d3cec00915a532186cdcbf5977262d", "message": "Move transformUnsafeCopyMemoryCall in OpenJ9\n\nTransformation from Unsafe.copyMemory to System.arrayCopy was Java\nspecific transformation. This commit moves the transformation to OpenJ9.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-08-18T00:55:09Z", "type": "forcePushed"}, {"oid": "fa538f2b7d215cb17ca22ff9c8893ea698034030", "url": "https://github.com/eclipse-openj9/openj9/commit/fa538f2b7d215cb17ca22ff9c8893ea698034030", "message": "Move transformUnsafeCopyMemoryCall in OpenJ9\n\nTransformation from Unsafe.copyMemory to System.arrayCopy was Java\nspecific transformation. This commit moves the transformation to OpenJ9.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-08-18T01:01:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5MDA0Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r472390046", "bodyText": "This API seems very very specific for it to exist in the Node class. I worry this class will turn into a kitchen sink eventually. Does this really need to exist? It seems it gets used in two locations:\n\nIn processJNICall which we can just replace with:\n\n   if (comp->canTransformUnsafeCopyToArrayCopy() &&\n       (methodSymbol->getRecognizedMethod() == TR::sun_misc_Unsafe_copyMemory ||\n        methodSymbol->getRecognizedMethod() == TR::jdk_internal_misc_Unsafe_copyMemory0))\n\n\nIn transformUnsafeCopyMemoryCall which we can just inline a partial version of this API.\n\nAre we sure introducing this extra complexity into the Node class outweighs the benefits?", "author": "fjeremic", "createdAt": "2020-08-18T18:14:35Z", "path": "runtime/compiler/il/J9Node.hpp", "diffHunk": "@@ -284,6 +284,11 @@ class OMR_EXTENSIBLE Node : public OMR::NodeConnector\n    bool chkDontInlineUnsafePutOrderedCall();\n    const char * printIsDontInlineUnsafePutOrderedCall();\n \n+   /**\n+    * Checks  and return true if the callNode is JNI Call to Unsafe.copyMemory\n+    */\n+   bool isUnsafeCopyMemoryIntrinsic();", "originalCommit": "fa538f2b7d215cb17ca22ff9c8893ea698034030", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA0NTcxOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r473045718", "bodyText": "@fjeremic  Reason I chose to introduce this API in Node class is that it contains all the information that it needed to verify if the JNI call can be transformed. Idea behind using this intrinsic is that if in later version of JDK if there are changes in the call chain, we only need to make changes in one place.\nThere is another potential use of this API in recognized call transformer to identify and transform this call as you suggested in #10366 (comment) , which I think we should pursue and remove the complexity and duplicate code from the codegen.", "author": "r30shah", "createdAt": "2020-08-19T13:52:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5MDA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2OTkxMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r473069910", "bodyText": "That sounds reasonable. Thanks for explaining further uses.", "author": "fjeremic", "createdAt": "2020-08-19T14:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5MDA0Ng=="}], "type": "inlineReview"}, {"oid": "82e89e96d1f5f02429331969faa477cd5ba0cef2", "url": "https://github.com/eclipse-openj9/openj9/commit/82e89e96d1f5f02429331969faa477cd5ba0cef2", "message": "Move transformUnsafeCopyMemoryCall in OpenJ9\n\nTransformation from Unsafe.copyMemory to System.arrayCopy was Java\nspecific transformation. This commit moves the transformation to OpenJ9.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-08-20T14:57:04Z", "type": "forcePushed"}, {"oid": "9939a4f246b56aaa499c1f2050b4f440d8a1b758", "url": "https://github.com/eclipse-openj9/openj9/commit/9939a4f246b56aaa499c1f2050b4f440d8a1b758", "message": "Move transformUnsafeCopyMemoryCall in OpenJ9\n\nTransformation from Unsafe.copyMemory to System.arrayCopy was Java\nspecific transformation. This commit moves the transformation to OpenJ9.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-08-27T14:37:49Z", "type": "forcePushed"}, {"oid": "dc19287ce8f2ea18c87a0d5416ad6e2c416e7603", "url": "https://github.com/eclipse-openj9/openj9/commit/dc19287ce8f2ea18c87a0d5416ad6e2c416e7603", "message": "Move transformUnsafeCopyMemoryCall in OpenJ9\n\nTransformation from Unsafe.copyMemory to System.arrayCopy was Java\nspecific transformation. This commit moves the transformation to OpenJ9.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-09-01T19:23:22Z", "type": "forcePushed"}, {"oid": "46b265ee4633c2c41f02d28b5d8172b3e6b4301d", "url": "https://github.com/eclipse-openj9/openj9/commit/46b265ee4633c2c41f02d28b5d8172b3e6b4301d", "message": "Move transformUnsafeCopyMemoryCall in OpenJ9\n\nTransformation from Unsafe.copyMemory to System.arrayCopy was Java\nspecific transformation. This commit moves the transformation to OpenJ9.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-09-08T15:08:09Z", "type": "forcePushed"}, {"oid": "49d0470e0d073c1ac9d7f5f13ebaf583d301a827", "url": "https://github.com/eclipse-openj9/openj9/commit/49d0470e0d073c1ac9d7f5f13ebaf583d301a827", "message": "Move transformUnsafeCopyMemoryCall in OpenJ9\n\nTransformation from Unsafe.copyMemory to System.arrayCopy was Java\nspecific transformation. This commit moves the transformation to OpenJ9.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-09-14T14:24:35Z", "type": "forcePushed"}, {"oid": "c2307543b065b7dbd940928977b0b6ef9299ae7b", "url": "https://github.com/eclipse-openj9/openj9/commit/c2307543b065b7dbd940928977b0b6ef9299ae7b", "message": "Recognize Unsafe.copyMemory0 in JDK11\n\nOpenJ9 contains the optimization that recognizes the JNI call\nsun/misc/Unsafe.copyMemory and transforms it to System.arrayCopy calls,\nwhich is inlined and optimized on most of the platform. Due to\nimplementation changes in JDK11 we can not apply this optimization to\nsun/misc/Unsafe.copyMemory method which in Java 11 acts as a java\nwrapper that calls the implementation of copyMemory method from\njdk/internal/misc/Unsafe class. This implementation contains additional\nchanges to check range for the source and destination (in case of\nillegal access throws RuntimeException) before calling the\nactual JNI method jdk/internal/misc/Unsafe.copyMemory0 which can be\ntransformed to System.arrayCopy call. Due to this behavioural changes,\nwhen compiling method that calls Unsafe.copyMemory, we need to make sure\nthat optimizer is exposed to JNI call Unsafe.copyMemory0 and that call\nis recognized same way as JNI call sun/misc/Unsafe.copyMemory is\nrecognized in Java 8 to optimize it further.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-09-16T12:38:41Z", "type": "commit"}, {"oid": "c8663fcc199a1c2934fe0f531ce1eb729a6c9797", "url": "https://github.com/eclipse-openj9/openj9/commit/c8663fcc199a1c2934fe0f531ce1eb729a6c9797", "message": "Move transformUnsafeCopyMemoryCall in OpenJ9\n\nTransformation from Unsafe.copyMemory to System.arrayCopy was Java\nspecific transformation. This commit moves the transformation to OpenJ9.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-09-16T12:38:41Z", "type": "commit"}, {"oid": "c8663fcc199a1c2934fe0f531ce1eb729a6c9797", "url": "https://github.com/eclipse-openj9/openj9/commit/c8663fcc199a1c2934fe0f531ce1eb729a6c9797", "message": "Move transformUnsafeCopyMemoryCall in OpenJ9\n\nTransformation from Unsafe.copyMemory to System.arrayCopy was Java\nspecific transformation. This commit moves the transformation to OpenJ9.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-09-16T12:38:41Z", "type": "forcePushed"}]}