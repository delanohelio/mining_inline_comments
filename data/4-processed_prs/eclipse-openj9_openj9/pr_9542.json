{"pr_number": 9542, "pr_title": "AArch64: Implement read barrier evaluators", "pr_createdAt": "2020-05-13T07:07:57Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9542", "timeline": [{"oid": "2e82c6a51f5fb3137c5567c5961cbb50f285c14b", "url": "https://github.com/eclipse-openj9/openj9/commit/2e82c6a51f5fb3137c5567c5961cbb50f285c14b", "message": "AArch64: Implement read barrier evaluators\n\nThis commit implements read barrier evaluators for AArch64.\n\nSigned-off-by: KONNO Kazuhiro <konno@jp.ibm.com>", "committedDate": "2020-05-14T05:32:34Z", "type": "forcePushed"}, {"oid": "476ffeefa7f350a6ce3edc31abd11f1ffaaf1319", "url": "https://github.com/eclipse-openj9/openj9/commit/476ffeefa7f350a6ce3edc31abd11f1ffaaf1319", "message": "AArch64: Implement read barrier evaluators\n\nThis commit implements read barrier evaluators for AArch64.\n\nSigned-off-by: KONNO Kazuhiro <konno@jp.ibm.com>", "committedDate": "2020-05-21T07:53:16Z", "type": "forcePushed"}, {"oid": "04c59540b1c98fbb9c16b444570779ed64effd5d", "url": "https://github.com/eclipse-openj9/openj9/commit/04c59540b1c98fbb9c16b444570779ed64effd5d", "message": "AArch64: Implement read barrier evaluators\n\nThis commit implements read barrier evaluators for AArch64.\n\nSigned-off-by: KONNO Kazuhiro <konno@jp.ibm.com>", "committedDate": "2020-05-26T12:34:39Z", "type": "forcePushed"}, {"oid": "66530baea9c53565a6741132b003b59d4f810130", "url": "https://github.com/eclipse-openj9/openj9/commit/66530baea9c53565a6741132b003b59d4f810130", "message": "AArch64: Implement read barrier evaluators\n\nThis commit implements read barrier evaluators for AArch64.\n\nSigned-off-by: KONNO Kazuhiro <konno@jp.ibm.com>", "committedDate": "2020-05-28T08:55:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAxOTg5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432019894", "bodyText": "What does the offset \"4\" represent?  Perhaps use a more descriptive constant name.", "author": "0xdaryl", "createdAt": "2020-05-28T17:56:54Z", "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);", "originalCommit": "66530baea9c53565a6741132b003b59d4f810130", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwMzE5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432203192", "bodyText": "It is not an offset but a length parameter.\nIt is meaningless, and is addressed by eclipse/omr#4137 .", "author": "knn-k", "createdAt": "2020-05-29T01:02:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAxOTg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4MTk4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432081982", "bodyText": "Use the comp variable that you cached earlier.", "author": "0xdaryl", "createdAt": "2020-05-28T19:50:22Z", "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_LT);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateTopAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_GT);\n+\n+   // TR_softwareReadBarrier helper expects the vmThread in x0.\n+   generateMovInstruction(cg, node, x0Reg, metaReg);\n+\n+   TR::SymbolReference *helperSym = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_softwareReadBarrier, false, false, false);\n+   generateImmSymInstruction(cg, TR::InstOpCode::bl, node, (uintptr_t)helperSym->getMethodAddress(), deps, helperSym, NULL);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, endLabel, deps);\n+\n+   bool needSync = (node->getSymbolReference()->getSymbol()->isSyncVolatile() && cg->comp()->target().isSMP());", "originalCommit": "66530baea9c53565a6741132b003b59d4f810130", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4OTY4MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432089680", "bodyText": "What does it mean to assign metaReg to a NoReg dependence (i.e., any available real register)?  Shouldn't this be the actual real register representing the vmThread?", "author": "0xdaryl", "createdAt": "2020-05-28T20:00:07Z", "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);", "originalCommit": "66530baea9c53565a6741132b003b59d4f810130", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5NzAwMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432197001", "bodyText": "It came from the p version.", "author": "knn-k", "createdAt": "2020-05-29T00:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4OTY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NDU1Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432164553", "bodyText": "Can you call this metaDataReg or more conventionally vmThreadReg ?", "author": "0xdaryl", "createdAt": "2020-05-28T22:45:15Z", "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();", "originalCommit": "66530baea9c53565a6741132b003b59d4f810130", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4MTM4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432281388", "bodyText": "Changed to vmThreadReg.", "author": "knn-k", "createdAt": "2020-05-29T06:31:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NDU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NTIxMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432165212", "bodyText": "Use comp here instead of cg->comp().", "author": "0xdaryl", "createdAt": "2020-05-28T22:47:15Z", "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));", "originalCommit": "66530baea9c53565a6741132b003b59d4f810130", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4MTU4Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432281587", "bodyText": "Changed to comp, here and other locations.", "author": "knn-k", "createdAt": "2020-05-29T06:32:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NTIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NTM4NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432165385", "bodyText": "Use comp here", "author": "0xdaryl", "createdAt": "2020-05-28T22:47:46Z", "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_LT);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateTopAddressOffset(), cg));", "originalCommit": "66530baea9c53565a6741132b003b59d4f810130", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NjkyNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432166924", "bodyText": "Is this necessary?  What are you prefetching here and why?", "author": "0xdaryl", "createdAt": "2020-05-28T22:52:21Z", "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_LT);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateTopAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_GT);\n+\n+   // TR_softwareReadBarrier helper expects the vmThread in x0.\n+   generateMovInstruction(cg, node, x0Reg, metaReg);\n+\n+   TR::SymbolReference *helperSym = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_softwareReadBarrier, false, false, false);\n+   generateImmSymInstruction(cg, TR::InstOpCode::bl, node, (uintptr_t)helperSym->getMethodAddress(), deps, helperSym, NULL);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, endLabel, deps);\n+\n+   bool needSync = (node->getSymbolReference()->getSymbol()->isSyncVolatile() && cg->comp()->target().isSMP());\n+\n+   if (needSync)\n+      {\n+      generateSynchronizationInstruction(cg, TR::InstOpCode::dsb, node, 0xF); // dsb SY\n+      }\n+\n+   cg->insertPrefetchIfNecessary(node, objReg);", "originalCommit": "66530baea9c53565a6741132b003b59d4f810130", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5NjA3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432196077", "bodyText": "It came from the p version.  Removing.", "author": "knn-k", "createdAt": "2020-05-29T00:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NjkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MDQ5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432170494", "bodyText": "The DNA of this method is about 80-90% identical to the iGenerateSoftwareReadBarrier method.  Is there any way you could combine them to save some code space?", "author": "0xdaryl", "createdAt": "2020-05-28T23:02:51Z", "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_LT);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateTopAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_GT);\n+\n+   // TR_softwareReadBarrier helper expects the vmThread in x0.\n+   generateMovInstruction(cg, node, x0Reg, metaReg);\n+\n+   TR::SymbolReference *helperSym = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_softwareReadBarrier, false, false, false);\n+   generateImmSymInstruction(cg, TR::InstOpCode::bl, node, (uintptr_t)helperSym->getMethodAddress(), deps, helperSym, NULL);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, endLabel, deps);\n+\n+   bool needSync = (node->getSymbolReference()->getSymbol()->isSyncVolatile() && cg->comp()->target().isSMP());\n+\n+   if (needSync)\n+      {\n+      generateSynchronizationInstruction(cg, TR::InstOpCode::dsb, node, 0xF); // dsb SY\n+      }\n+\n+   cg->insertPrefetchIfNecessary(node, objReg);\n+\n+   tempMR->decNodeReferenceCounts(cg);\n+\n+   cg->stopUsingRegister(evacuateReg);\n+   cg->stopUsingRegister(locationReg);\n+   cg->stopUsingRegister(x0Reg);\n+\n+   cg->machine()->setLinkRegisterKilled(true);\n+\n+   return objReg;\n+#endif // OMR_GC_CONCURRENT_SCAVENGER\n+   }\n+\n+static TR::Register *\n+aGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)", "originalCommit": "66530baea9c53565a6741132b003b59d4f810130", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MDczMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432170733", "bodyText": "Most of my comments in iGenerateSoftwareReadBarrier apply to this function as well so I'm not going to repeat them.", "author": "0xdaryl", "createdAt": "2020-05-28T23:03:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MDQ5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4MjAwMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432282001", "bodyText": "Merged the two functions into generateSoftwareReadBarrier(), which takes bool isArdbari as its third argument.", "author": "knn-k", "createdAt": "2020-05-29T06:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MDQ5NA=="}], "type": "inlineReview"}, {"oid": "20bf33d0a05ea2ed6dc6dde3981375ee20e9a79a", "url": "https://github.com/eclipse-openj9/openj9/commit/20bf33d0a05ea2ed6dc6dde3981375ee20e9a79a", "message": "AArch64: Implement read barrier evaluators\n\nThis commit implements read barrier evaluators for AArch64.\n\nSigned-off-by: KONNO Kazuhiro <konno@jp.ibm.com>", "committedDate": "2020-05-29T06:18:41Z", "type": "commit"}, {"oid": "20bf33d0a05ea2ed6dc6dde3981375ee20e9a79a", "url": "https://github.com/eclipse-openj9/openj9/commit/20bf33d0a05ea2ed6dc6dde3981375ee20e9a79a", "message": "AArch64: Implement read barrier evaluators\n\nThis commit implements read barrier evaluators for AArch64.\n\nSigned-off-by: KONNO Kazuhiro <konno@jp.ibm.com>", "committedDate": "2020-05-29T06:18:41Z", "type": "forcePushed"}]}