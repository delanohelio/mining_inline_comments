{"pr_number": 9321, "pr_title": "Fix ValueTypeHelpers JDK15 Valhalla compilation failure", "pr_createdAt": "2020-04-22T17:00:45Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9321", "timeline": [{"oid": "ef2598b87d9772dc0bc2e47df6349e7158ee5392", "url": "https://github.com/eclipse-openj9/openj9/commit/ef2598b87d9772dc0bc2e47df6349e7158ee5392", "message": "Fix ValueTypeHelpers JDK15 Valhalla compilation failure\n\nJDK15 Valhalla compilation failure was occurring in\nBuild_JDKnext_x86-64_linux_valhalla_Nightly.\n\nSplit ValueTypeHelpers class name into Full and Compressed\nMove VM_ValueTypeHelpers::isSubstitutable from cpp to hpp\n\nSigned-off-by: Sharon Wang <sharon-wang-cpsc@outlook.com>", "committedDate": "2020-04-22T17:35:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4NjAwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9321#discussion_r413186007", "bodyText": "nitpick: the preprocessor checks should be shifted a tab to the left", "author": "tajila", "createdAt": "2020-04-22T17:42:04Z", "path": "runtime/vm/ValueTypeHelpers.hpp", "diffHunk": "@@ -45,8 +54,139 @@ class VM_ValueTypeHelpers {\n \t * Function members\n \t */\n private:\n+\t/*\n+\t* Determine if the two valueTypes are substitutable when rhs.class equals lhs.class\n+\t* and rhs and lhs are not null\n+\t*\n+\t* @param[in] lhs the lhs object address\n+\t* @param[in] rhs the rhs object address\n+\t* @param[in] startOffset the initial offset for the object\n+\t* @param[in] clazz the value type class\n+\t* return true if they are substitutable and false otherwise\n+\t*/\n \tstatic bool\n-\tisSubstitutable(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI objectAccessBarrier, j9object_t lhs, j9object_t rhs, UDATA startOffset, J9Class *clazz);\n+\tisSubstitutable(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI objectAccessBarrier, j9object_t lhs, j9object_t rhs, UDATA startOffset, J9Class *clazz)\n+\t{\n+\t#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\tJ9JavaVM *vm = currentThread->javaVM;\n+\t\tU_32 walkFlags = J9VM_FIELD_OFFSET_WALK_INCLUDE_INSTANCE;\n+\t\tJ9ROMFieldOffsetWalkState state;\n+\t\tJ9ROMFieldOffsetWalkResult *result = fieldOffsetsStartDo(vm, clazz->romClass, VM_VMHelpers::getSuperclass(clazz), &state, walkFlags, clazz->flattenedClassCache);\n+\t\tbool rc = true;\n+\n+\t\tAssert_VM_notNull(lhs);\n+\t\tAssert_VM_notNull(rhs);\n+\t\tAssert_VM_true(J9OBJECT_CLAZZ(currentThread, lhs) == J9OBJECT_CLAZZ(currentThread, rhs));\n+\n+\t\t/* If J9ClassCanSupportFastSubstitutability is set, we can use the barrier version of memcmp,\n+\t\t* else we recursively check the fields manually. */\n+\t\tif (J9_ARE_ALL_BITS_SET(clazz->classFlags, J9ClassCanSupportFastSubstitutability)) {\n+\t\t\trc = objectAccessBarrier.structuralFlattenedCompareObjects(currentThread, clazz, lhs, rhs, startOffset);\n+\t\t} else {\n+\t\t\twhile (NULL != result->field) {\n+\t\t\t\tJ9UTF8 *signature = J9ROMNAMEANDSIGNATURE_SIGNATURE(&result->field->nameAndSignature);\n+\t\t\t\tU_8 *sigChar = J9UTF8_DATA(signature);\n+\n+\t\t\t\tswitch (*sigChar) {\n+\t\t\t\tcase 'Z': /* boolean */\n+\t\t\t\tcase 'B': /* byte */\n+\t\t\t\tcase 'C': /* char */\n+\t\t\t\tcase 'I': /* int */\n+\t\t\t\tcase 'S': { /* short */\n+\t\t\t\t\tI_32 lhsValue = objectAccessBarrier.inlineMixedObjectReadI32(currentThread, lhs, startOffset + result->offset);\n+\t\t\t\t\tI_32 rhsValue = objectAccessBarrier.inlineMixedObjectReadI32(currentThread, rhs, startOffset + result->offset);\n+\t\t\t\t\tif (lhsValue != rhsValue) {\n+\t\t\t\t\t\trc = false;\n+\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tcase 'J': { /* long */\n+\t\t\t\t\tI_64 lhsValue = objectAccessBarrier.inlineMixedObjectReadI64(currentThread, lhs, startOffset + result->offset);\n+\t\t\t\t\tI_64 rhsValue = objectAccessBarrier.inlineMixedObjectReadI64(currentThread, rhs, startOffset + result->offset);\n+\t\t\t\t\tif (lhsValue != rhsValue) {\n+\t\t\t\t\t\trc = false;\n+\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tcase 'D': { /* double */\n+\t\t\t\t\tU_64 lhsValue = objectAccessBarrier.inlineMixedObjectReadU64(currentThread, lhs, startOffset + result->offset);\n+\t\t\t\t\tU_64 rhsValue = objectAccessBarrier.inlineMixedObjectReadU64(currentThread, rhs, startOffset + result->offset);\n+\n+\t\t\t\t\tif (!checkDoubleEquality(lhsValue, rhsValue)) {\n+\t\t\t\t\t\trc = false;\n+\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tcase 'F': { /* float */\n+\t\t\t\t\tU_32 lhsValue = objectAccessBarrier.inlineMixedObjectReadU32(currentThread, lhs, startOffset + result->offset);\n+\t\t\t\t\tU_32 rhsValue = objectAccessBarrier.inlineMixedObjectReadU32(currentThread, rhs, startOffset + result->offset);\n+\n+\t\t\t\t\tif (!checkFloatEquality(lhsValue, rhsValue)) {\n+\t\t\t\t\t\trc = false;\n+\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tcase '[': { /* Array */\n+\t\t\t\t\tj9object_t lhsObject = objectAccessBarrier.inlineMixedObjectReadObject(currentThread, lhs, startOffset + result->offset);\n+\t\t\t\t\tj9object_t rhsObject = objectAccessBarrier.inlineMixedObjectReadObject(currentThread, rhs, startOffset + result->offset);\n+\t\t\t\t\tif (lhsObject != rhsObject) {\n+\t\t\t\t\t\trc = false;\n+\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tcase 'L': { /* Nullable class type or interface type */\n+\t\t\t\t\tj9object_t lhsObject = objectAccessBarrier.inlineMixedObjectReadObject(currentThread, lhs, startOffset + result->offset);\n+\t\t\t\t\tj9object_t rhsObject = objectAccessBarrier.inlineMixedObjectReadObject(currentThread, rhs, startOffset + result->offset);\n+\n+\t\t\t\t\tif (!VM_ValueTypeHelpers::acmp(currentThread, objectAccessBarrier, lhsObject, rhsObject)) {\n+\t\t\t\t\t\trc = false;\n+\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tcase 'Q': { /* Null-free class type */\n+\t\t\t\t\tJ9Class *fieldClass = findJ9ClassInFlattenedClassCache(clazz->flattenedClassCache, sigChar + 1, J9UTF8_LENGTH(signature) - 2);\n+\t\t\t\t\trc = false;\n+\n+\t\t\t\t\tif (J9_IS_J9CLASS_FLATTENED(fieldClass)) {\n+\t\t\t\t\t\trc = isSubstitutable(currentThread, objectAccessBarrier, lhs, rhs, startOffset + result->offset, fieldClass);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tj9object_t lhsFieldObject = objectAccessBarrier.inlineMixedObjectReadObject(currentThread, lhs, startOffset + result->offset);\n+\t\t\t\t\t\tj9object_t rhsFieldObject = objectAccessBarrier.inlineMixedObjectReadObject(currentThread, rhs, startOffset + result->offset);\n+\n+\t\t\t\t\t\tif (lhsFieldObject == rhsFieldObject) {\n+\t\t\t\t\t\t\trc = true;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t/* When unflattened, we get our object from the specified offset, then increment past the header to the first field. */\n+\t\t\t\t\t\t\trc = isSubstitutable(currentThread, objectAccessBarrier, lhsFieldObject, rhsFieldObject, J9VMTHREAD_OBJECT_HEADER_SIZE(currentThread), fieldClass);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (false == rc) {\n+\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tdefault:\n+\t\t\t\t\tAssert_VM_unreachable();\n+\t\t\t\t} /* switch */\n+\n+\t\t\t\tresult = fieldOffsetsNextDo(&state);\n+\t\t\t}\n+\t\t}\n+\n+\tdone:\n+\t\treturn rc;\n+\t#else /* defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */", "originalCommit": "ef2598b87d9772dc0bc2e47df6349e7158ee5392", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2a909a66bc154639cd4907a9fa7d3245c232e589", "url": "https://github.com/eclipse-openj9/openj9/commit/2a909a66bc154639cd4907a9fa7d3245c232e589", "message": "Fix ValueTypeHelpers JDK15 Valhalla compilation failure\n\nJDK15 Valhalla compilation failure was occurring in\nBuild_JDKnext_x86-64_linux_valhalla_Nightly.\n\nSplit ValueTypeHelpers class name into Full and Compressed\nMove VM_ValueTypeHelpers::isSubstitutable from cpp to hpp\n\nSigned-off-by: Sharon Wang <sharon-wang-cpsc@outlook.com>", "committedDate": "2020-04-22T17:48:41Z", "type": "commit"}, {"oid": "2a909a66bc154639cd4907a9fa7d3245c232e589", "url": "https://github.com/eclipse-openj9/openj9/commit/2a909a66bc154639cd4907a9fa7d3245c232e589", "message": "Fix ValueTypeHelpers JDK15 Valhalla compilation failure\n\nJDK15 Valhalla compilation failure was occurring in\nBuild_JDKnext_x86-64_linux_valhalla_Nightly.\n\nSplit ValueTypeHelpers class name into Full and Compressed\nMove VM_ValueTypeHelpers::isSubstitutable from cpp to hpp\n\nSigned-off-by: Sharon Wang <sharon-wang-cpsc@outlook.com>", "committedDate": "2020-04-22T17:48:41Z", "type": "forcePushed"}]}