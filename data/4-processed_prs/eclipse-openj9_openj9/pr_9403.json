{"pr_number": 9403, "pr_title": "Cache result of class chain validation", "pr_createdAt": "2020-04-29T16:56:16Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9403", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxMTc0MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9403#discussion_r417511741", "bodyText": "I haven't checked, but if these vectors are only initialized during aboutToBootstrap, then the monitor is not needed because aboutToBootstrap is only executed by a single thread before any Java code can run.", "author": "mpirvu", "createdAt": "2020-04-29T18:07:55Z", "path": "runtime/compiler/env/J9SharedCache.cpp", "diffHunk": "@@ -96,6 +103,15 @@ TR_YesNoMaybe TR_J9SharedCache::isSharedCacheDisabledBecauseFull(TR::Compilation\n    return _sharedCacheDisabledBecauseFull;\n    }\n \n+bool\n+TR_J9SharedCache::initClassChainValidationBitVectors()", "originalCommit": "17ce825fd2b8a6314b59b6a452044e89745d64d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxNTU4Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9403#discussion_r419715587", "bodyText": "yeah they're only initialized in aboutToBootstrap; I'll change it so we don't acquire the monitor.", "author": "dsouzai", "createdAt": "2020-05-04T20:42:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxMTc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxNDA4Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9403#discussion_r417514087", "bodyText": "Nitpick: space before index++", "author": "mpirvu", "createdAt": "2020-04-29T18:12:01Z", "path": "runtime/compiler/env/J9SharedCache.cpp", "diffHunk": "@@ -813,76 +829,155 @@ TR_J9SharedCache::findChainForClass(J9Class *clazz, const char *key, uint32_t ke\n    return chainForClass;\n    }\n \n+bool\n+TR_J9SharedCache::validateSuperClassesInClassChain(J9Class *clazz, UDATA * & chainPtr, UDATA *chainEnd)\n+   {\n+   int32_t numSuperclasses = TR::Compiler->cls.classDepthOf(fe()->convertClassPtrToClassOffset(clazz));\n+   for (int32_t index=0; index < numSuperclasses;index++)", "originalCommit": "17ce825fd2b8a6314b59b6a452044e89745d64d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxNDg2MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9403#discussion_r417514861", "bodyText": "Let's cache fe()->convertClassPtrToClassOffset(clazz) and take it out of the loop", "author": "mpirvu", "createdAt": "2020-04-29T18:13:21Z", "path": "runtime/compiler/env/J9SharedCache.cpp", "diffHunk": "@@ -813,76 +829,155 @@ TR_J9SharedCache::findChainForClass(J9Class *clazz, const char *key, uint32_t ke\n    return chainForClass;\n    }\n \n+bool\n+TR_J9SharedCache::validateSuperClassesInClassChain(J9Class *clazz, UDATA * & chainPtr, UDATA *chainEnd)\n+   {\n+   int32_t numSuperclasses = TR::Compiler->cls.classDepthOf(fe()->convertClassPtrToClassOffset(clazz));\n+   for (int32_t index=0; index < numSuperclasses;index++)\n+      {\n+      J9ROMClass *romClass = TR::Compiler->cls.romClassOfSuperClass(fe()->convertClassPtrToClassOffset(clazz), index);", "originalCommit": "17ce825fd2b8a6314b59b6a452044e89745d64d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMjc2OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9403#discussion_r417522769", "bodyText": "I forgot when codert_onload is executed, but it would be nice to create this monitor only if needed, thus maybe we should move this inside initClassChainValidationBitVectors()", "author": "mpirvu", "createdAt": "2020-04-29T18:26:40Z", "path": "runtime/compiler/runtime/codertinit.cpp", "diffHunk": "@@ -216,6 +217,13 @@ J9JITConfig * codert_onload(J9JavaVM * javaVM)\n          goto _abort;\n       }\n \n+   /* initialize classChainValidationMutex */\n+   if (!classChainValidationMutex)\n+      {\n+      if (!(classChainValidationMutex = TR::Monitor::create(\"JIT-ClassChainValidationMutex\")))", "originalCommit": "17ce825fd2b8a6314b59b6a452044e89745d64d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODExMjQyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9403#discussion_r418112421", "bodyText": "Yeah I was thinking about whether I can avoid creating the monitor if I don't need it. I'll look into it.", "author": "dsouzai", "createdAt": "2020-04-30T15:51:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMjc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxNjAzMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9403#discussion_r419716032", "bodyText": "I changed where the monitor is created; essentially the monitor is only needed after we init the map, so I'll change the code to create the monitor when we go to init the map.", "author": "dsouzai", "createdAt": "2020-05-04T20:43:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMjc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNTAxMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9403#discussion_r417525012", "bodyText": "Each class offset is represented by a bit inside the bit-vector. You have 1 million bits (initial size) which means you can cover (more or less) an SCC size of 1MB (ignoring for a moment that classes are stored in the beginning of the SCC).\nIf a class is always aligned on an 8-byte boundary you could do (classOffsetInCache >> 3) to expand your coverage", "author": "mpirvu", "createdAt": "2020-04-29T18:30:31Z", "path": "runtime/compiler/env/J9SharedCache.cpp", "diffHunk": "@@ -813,76 +829,155 @@ TR_J9SharedCache::findChainForClass(J9Class *clazz, const char *key, uint32_t ke\n    return chainForClass;\n    }\n \n+bool\n+TR_J9SharedCache::validateSuperClassesInClassChain(J9Class *clazz, UDATA * & chainPtr, UDATA *chainEnd)\n+   {\n+   int32_t numSuperclasses = TR::Compiler->cls.classDepthOf(fe()->convertClassPtrToClassOffset(clazz));\n+   for (int32_t index=0; index < numSuperclasses;index++)\n+      {\n+      J9ROMClass *romClass = TR::Compiler->cls.romClassOfSuperClass(fe()->convertClassPtrToClassOffset(clazz), index);\n+      if (!romclassMatchesCachedVersion(romClass, chainPtr, chainEnd))\n+         {\n+         LOG(1, \"\\tClass in hierarchy did not match, returning false\\n\");\n+         return false;\n+         }\n+      }\n+   return true;\n+   }\n+\n+bool\n+TR_J9SharedCache::validateInterfacesInClassChain(J9Class *clazz, UDATA * & chainPtr, UDATA *chainEnd)\n+   {\n+   J9ITable *interfaceElement = TR::Compiler->cls.iTableOf(fe()->convertClassPtrToClassOffset(clazz));\n+   while (interfaceElement)\n+      {\n+      J9ROMClass * romClass = TR::Compiler->cls.iTableRomClass(interfaceElement);\n+      if (!romclassMatchesCachedVersion(romClass, chainPtr, chainEnd))\n+         {\n+         LOG(1, \"\\tInterface class did not match, returning false\\n\");\n+         return false;\n+         }\n+      interfaceElement = TR::Compiler->cls.iTableNext(interfaceElement);\n+      }\n+   return true;\n+   }\n+\n+bool\n+TR_J9SharedCache::validateClassChain(J9ROMClass *romClass, J9Class *clazz, UDATA * & chainPtr, UDATA *chainEnd)\n+   {\n+   bool validationSucceeded = false;\n+\n+   if (!romclassMatchesCachedVersion(romClass, chainPtr, chainEnd))\n+      {\n+      LOG(1, \"\\tClass did not match, returning false\\n\");\n+      }\n+   else if (!validateSuperClassesInClassChain(clazz, chainPtr, chainEnd))\n+      {\n+      LOG(1, \"\\tClass in hierarchy did not match, returning false\\n\");\n+      }\n+   else if (!validateInterfacesInClassChain(clazz, chainPtr, chainEnd))\n+      {\n+      LOG(1, \"\\tInterface class did not match, returning false\\n\");\n+      }\n+   else if (chainPtr != chainEnd)\n+      {\n+      LOG(1, \"\\tfinished classes and interfaces, but not at chain end, returning false\\n\");\n+      }\n+   else\n+      {\n+      validationSucceeded = true;\n+      }\n+\n+   return validationSucceeded;\n+   }\n+\n bool\n TR_J9SharedCache::classMatchesCachedVersion(J9Class *clazz, UDATA *chainData)\n    {\n    J9ROMClass *romClass = TR::Compiler->cls.romClassOf(fe()->convertClassPtrToClassOffset(clazz));\n    J9UTF8 * className = J9ROMCLASS_CLASSNAME(romClass);\n-   LOG(5, { log(\"classMatchesCachedVersion class %p %.*s\\n\", clazz, J9UTF8_LENGTH(className), J9UTF8_DATA(className)); });\n+   LOG(1, \"classMatchesCachedVersion class %p %.*s\\n\", clazz, J9UTF8_LENGTH(className), J9UTF8_DATA(className));\n \n    uintptr_t classOffsetInCache;\n+\n+   /* If the pointer isn't the SCC, then return false immmediately\n+    * as the bit vectors hold offsets into the SCC of romclasses\n+    */\n    if (!isPointerInSharedCache(romClass, &classOffsetInCache))\n       {\n-      LOG(5, { log(\"\\tclass not in shared cache, returning false\\n\"); });\n+      LOG(1, \"\\tclass not in shared cache, returning false\\n\");\n       return false;\n       }\n \n+   /* Check if the validation of the class chain was previously\n+    * performed; if so, return the result of that validation\n+    */\n+   if (TR::Options::getAOTCmdLineOptions()->getOption(TR_EnableClassChainValidationCaching))\n+      {\n+      OMR::CriticalSection checkBitVectors(classChainValidationMutex);\n+      if (_classChainValidationFailed->isSet(classOffsetInCache))\n+         {\n+         LOG(1, \"\\tcached result: validation failed\\n\");\n+         return false;\n+         }\n+      if (_classChainValidationSucceeded->isSet(classOffsetInCache))\n+         {\n+         LOG(1, \"\\tcached result: validation succeeded\\n\");\n+         return true;\n+         }\n+      }\n+\n+   /* If the chainData passed in is NULL, try to find it in the SCC\n+    * using the romclass\n+    */\n    if (chainData == NULL)\n       {\n       char key[17]; // longest possible key length is way less than 16 digits\n       uint32_t keyLength;\n       createClassKey(classOffsetInCache, key, keyLength);\n-      LOG(9, { log(\"\\tno chain specific, so looking up for key %.*s\\n\", keyLength, key); });\n+      LOG(3, \"\\tno chain specific, so looking up for key %.*s\\n\", keyLength, key);\n       chainData = findChainForClass(clazz, key, keyLength);\n-      if (chainData == NULL)\n+      }\n+\n+   /* If the chainData is still NULL, add the romclas offset to\n+    * the _classChainValidationFailed bit vector\n+    */\n+   if (chainData == NULL)\n+      {\n+      LOG(1, \"\\tno stored chain, returning false\\n\");\n+      if (TR::Options::getAOTCmdLineOptions()->getOption(TR_EnableClassChainValidationCaching))\n          {\n-         LOG(5, { log(\"\\tno stored chain, returning false\\n\"); });\n-         return false;\n+         OMR::CriticalSection noStoredChain(classChainValidationMutex);\n+         _classChainValidationFailed->set(classOffsetInCache);", "originalCommit": "17ce825fd2b8a6314b59b6a452044e89745d64d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODExNTcxNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9403#discussion_r418115716", "bodyText": "You have 1 million bits (initial size) which means you can cover (more or less) an SCC size of 1MB\n\nI believe it's going to be much more than 1MB. The reason is because the ROMClass offsets refer to the embedded ROMClass in the SCC. The ROMClass contains the ROMConstantPool and the ROMMethods (which contain all the bytecodes). Therefore, the distance between two ROMClasses is going to much more than 1 pointer size.\n\nIf a class is always aligned on an 8-byte boundary you could do (classOffsetInCache >> 3) to expand your coverage\n\nI don't think the ROMClasses are aligned on a 8-byte boundary like RAMClasses, but i'll defer to @DanHeidinga on that. However even if they were aligned, I don't believe you can do the shift because the shift only applies to the class and not the offset.", "author": "dsouzai", "createdAt": "2020-04-30T15:56:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNTAxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEzNDkwOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9403#discussion_r418134909", "bodyText": "The distance between two ROMClasses is indeed going to be larger than 1 pointer size which is why the bitvector solution is inefficient. A sparse bit vector may be better here.\nIf the ROMClasses are aligned on a 8-byte boundary, the offsets are going to be aligned too because I assume that the section of ROMclasses in the SCC is aligned.", "author": "mpirvu", "createdAt": "2020-04-30T16:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNTAxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTczNzkwMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9403#discussion_r419737900", "bodyText": "Resolving thread based on the conversation starting from #9403 (comment)", "author": "dsouzai", "createdAt": "2020-05-04T21:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNTAxMg=="}], "type": "inlineReview"}, {"oid": "c9fb50ab754a421eb0c94f9bca67ccb4f7019014", "url": "https://github.com/eclipse-openj9/openj9/commit/c9fb50ab754a421eb0c94f9bca67ccb4f7019014", "message": "Add comments\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2020-05-04T20:56:03Z", "type": "forcePushed"}, {"oid": "ce42ed59239ccd054c9dc881d890a397d3be63a8", "url": "https://github.com/eclipse-openj9/openj9/commit/ce42ed59239ccd054c9dc881d890a397d3be63a8", "message": "Add comments\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2020-05-04T21:19:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc0MzA4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9403#discussion_r419743082", "bodyText": "Probably should guard this with if (!_ccvMap. Or, I should just remove the if (!_classChainValidationMutex) check above.", "author": "dsouzai", "createdAt": "2020-05-04T21:34:46Z", "path": "runtime/compiler/env/J9SharedCache.cpp", "diffHunk": "@@ -96,6 +100,45 @@ TR_YesNoMaybe TR_J9SharedCache::isSharedCacheDisabledBecauseFull(TR::Compilation\n    return _sharedCacheDisabledBecauseFull;\n    }\n \n+bool\n+TR_J9SharedCache::initCCVCaching()\n+   {\n+   if (!_classChainValidationMutex)\n+      {\n+      if (!(_classChainValidationMutex = TR::Monitor::create(\"JIT-ClassChainValidationMutex\")))\n+         return false;\n+      }\n+\n+   void *storage = jitPersistentAlloc(sizeof(CCVMap));\n+   if (!storage)\n+      return false;\n+\n+   _ccvMap = new (storage) CCVMap(CCVComparator(), TR::Compiler->persistentAllocator());", "originalCommit": "ce42ed59239ccd054c9dc881d890a397d3be63a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDEzNTk4MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9403#discussion_r420135980", "bodyText": "Would something from PersistentCollections.hpp work for you here? (maybe extend it as I see that we only have  unordered_map)", "author": "mpirvu", "createdAt": "2020-05-05T14:05:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc0MzA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE2Mzk5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9403#discussion_r420163992", "bodyText": "I think that the syntax in that file won't compile on all platforms; it needs full C++11 support.", "author": "dsouzai", "createdAt": "2020-05-05T14:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc0MzA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1MzA2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9403#discussion_r420153064", "bodyText": "I don't understand this assert. When TR_EnableClassChainValidationCaching is enabled, we either return true or false or crash. Then the code below that does cacheCCVResult(classOffsetInCache, CCVResult::failure) is unreachable.", "author": "mpirvu", "createdAt": "2020-05-05T14:28:10Z", "path": "runtime/compiler/env/J9SharedCache.cpp", "diffHunk": "@@ -814,75 +857,150 @@ TR_J9SharedCache::findChainForClass(J9Class *clazz, const char *key, uint32_t ke\n    }\n \n bool\n-TR_J9SharedCache::classMatchesCachedVersion(J9Class *clazz, UDATA *chainData)\n+TR_J9SharedCache::validateSuperClassesInClassChain(TR_OpaqueClassBlock *clazz, UDATA * & chainPtr, UDATA *chainEnd)\n    {\n-   J9ROMClass *romClass = TR::Compiler->cls.romClassOf(fe()->convertClassPtrToClassOffset(clazz));\n-   J9UTF8 * className = J9ROMCLASS_CLASSNAME(romClass);\n-   LOG(5, { log(\"classMatchesCachedVersion class %p %.*s\\n\", clazz, J9UTF8_LENGTH(className), J9UTF8_DATA(className)); });\n-\n-   uintptr_t classOffsetInCache;\n-   if (!isPointerInSharedCache(romClass, &classOffsetInCache))\n+   int32_t numSuperclasses = TR::Compiler->cls.classDepthOf(clazz);\n+   for (int32_t index=0; index < numSuperclasses; index++)\n       {\n-      LOG(5, { log(\"\\tclass not in shared cache, returning false\\n\"); });\n-      return false;\n+      J9ROMClass *romClass = TR::Compiler->cls.romClassOfSuperClass(clazz, index);\n+      if (!romclassMatchesCachedVersion(romClass, chainPtr, chainEnd))\n+         {\n+         LOG(1, \"\\tClass in hierarchy did not match, returning false\\n\");\n+         return false;\n+         }\n       }\n+   return true;\n+   }\n \n-   if (chainData == NULL)\n+bool\n+TR_J9SharedCache::validateInterfacesInClassChain(TR_OpaqueClassBlock *clazz, UDATA * & chainPtr, UDATA *chainEnd)\n+   {\n+   J9ITable *interfaceElement = TR::Compiler->cls.iTableOf(clazz);\n+   while (interfaceElement)\n       {\n-      char key[17]; // longest possible key length is way less than 16 digits\n-      uint32_t keyLength;\n-      createClassKey(classOffsetInCache, key, keyLength);\n-      LOG(9, { log(\"\\tno chain specific, so looking up for key %.*s\\n\", keyLength, key); });\n-      chainData = findChainForClass(clazz, key, keyLength);\n-      if (chainData == NULL)\n+      J9ROMClass * romClass = TR::Compiler->cls.iTableRomClass(interfaceElement);\n+      if (!romclassMatchesCachedVersion(romClass, chainPtr, chainEnd))\n          {\n-         LOG(5, { log(\"\\tno stored chain, returning false\\n\"); });\n+         LOG(1, \"\\tInterface class did not match, returning false\\n\");\n          return false;\n          }\n+      interfaceElement = TR::Compiler->cls.iTableNext(interfaceElement);\n       }\n+   return true;\n+   }\n \n-   UDATA *chainPtr = chainData;\n-   UDATA chainLength = *chainPtr++;\n-   UDATA *chainEnd = (UDATA *) (((U_8*)chainData) + chainLength);\n-   LOG(9, { log(\"\\tfound chain: %p with length %d\\n\", chainData, chainLength); });\n+bool\n+TR_J9SharedCache::validateClassChain(J9ROMClass *romClass, TR_OpaqueClassBlock *clazz, UDATA * & chainPtr, UDATA *chainEnd)\n+   {\n+   bool validationSucceeded = false;\n \n    if (!romclassMatchesCachedVersion(romClass, chainPtr, chainEnd))\n       {\n-         LOG(5, { log(\"\\tClass did not match, returning false\\n\"); });\n-         return false;\n+      LOG(1, \"\\tClass did not match, returning false\\n\");\n+      }\n+   else if (!validateSuperClassesInClassChain(clazz, chainPtr, chainEnd))\n+      {\n+      LOG(1, \"\\tClass in hierarchy did not match, returning false\\n\");\n+      }\n+   else if (!validateInterfacesInClassChain(clazz, chainPtr, chainEnd))\n+      {\n+      LOG(1, \"\\tInterface class did not match, returning false\\n\");\n+      }\n+   else if (chainPtr != chainEnd)\n+      {\n+      LOG(1, \"\\tfinished classes and interfaces, but not at chain end, returning false\\n\");\n+      }\n+   else\n+      {\n+      validationSucceeded = true;\n       }\n \n-   int32_t numSuperclasses = TR::Compiler->cls.classDepthOf(fe()->convertClassPtrToClassOffset(clazz));\n-   for (int32_t index=0; index < numSuperclasses;index++)\n+   return validationSucceeded;\n+   }\n+\n+bool\n+TR_J9SharedCache::classMatchesCachedVersion(J9Class *clazz, UDATA *chainData)\n+   {\n+   J9ROMClass *romClass = TR::Compiler->cls.romClassOf(fe()->convertClassPtrToClassOffset(clazz));\n+   J9UTF8 * className = J9ROMCLASS_CLASSNAME(romClass);\n+   LOG(1, \"classMatchesCachedVersion class %p %.*s\\n\", clazz, J9UTF8_LENGTH(className), J9UTF8_DATA(className));\n+\n+   uintptr_t classOffsetInCache;\n+\n+   /* If the pointer isn't the SCC, then return false immmediately\n+    * as the map holds offsets into the SCC of romclasses\n+    */\n+   if (!isPointerInSharedCache(romClass, &classOffsetInCache))\n       {\n-      J9ROMClass *romClass = TR::Compiler->cls.romClassOfSuperClass(fe()->convertClassPtrToClassOffset(clazz), index);\n-      if (!romclassMatchesCachedVersion(romClass, chainPtr, chainEnd))\n-         {\n-         LOG(5, { log(\"\\tClass in hierarchy did not match, returning false\\n\"); });\n-         return false;\n-         }\n+      LOG(1, \"\\tclass not in shared cache, returning false\\n\");\n+      return false;\n       }\n \n-   J9ITable *interfaceElement = TR::Compiler->cls.iTableOf(fe()->convertClassPtrToClassOffset(clazz));\n-   while (interfaceElement)\n+   /* Check if the validation of the class chain was previously\n+    * performed; if so, return the result of that validation\n+    */\n+   if (TR::Options::getAOTCmdLineOptions()->getOption(TR_EnableClassChainValidationCaching))\n       {\n-      J9ROMClass * romClass = TR::Compiler->cls.iTableRomClass(interfaceElement);\n-      if (!romclassMatchesCachedVersion(romClass, chainPtr, chainEnd))\n+      auto result = getCachedCCVResult(classOffsetInCache);\n+      if (result == CCVResult::success)\n+         {\n+         LOG(1, \"\\tcached result: validation succeeded\\n\");\n+         return true;\n+         }\n+      else if (result == CCVResult::failure)\n          {\n-         LOG(5, { log(\"\\tInterface class did not match, returning false\\n\"); });\n+         LOG(1, \"\\tcached result: validation failed\\n\");\n          return false;\n          }\n-      interfaceElement = TR::Compiler->cls.iTableNext(interfaceElement);\n+      else\n+         {\n+         TR_ASSERT_FATAL(result == CCVResult::notYetValidated, \"Unknown result cached %d\\n\", result);", "originalCommit": "ce42ed59239ccd054c9dc881d890a397d3be63a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE2NDU5Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/9403#discussion_r420164596", "bodyText": "getCachedCCVResult can return CCVResult::notYetValidated if we've never cached the result of the validation yet, ie, this is the first time we're validating the class.", "author": "dsouzai", "createdAt": "2020-05-05T14:43:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1MzA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE2NTU4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9403#discussion_r420165588", "bodyText": "The assert is to ensure that if the result returned is not success or failure, it better be notYetValidated (see comment in https://github.com/dsouzai/openj9/blob/classChainOpts/runtime/compiler/env/J9SharedCache.hpp#L257-L261)", "author": "dsouzai", "createdAt": "2020-05-05T14:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1MzA2NA=="}], "type": "inlineReview"}, {"oid": "fb5c26bbdc5365d32c4fefc774b61d5e0c5638d7", "url": "https://github.com/eclipse-openj9/openj9/commit/fb5c26bbdc5365d32c4fefc774b61d5e0c5638d7", "message": "Clean up LOG macro\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2020-05-05T15:07:26Z", "type": "commit"}, {"oid": "1261b78b87fe5f03f942a7910bad65352a25bacc", "url": "https://github.com/eclipse-openj9/openj9/commit/1261b78b87fe5f03f942a7910bad65352a25bacc", "message": "Add classChainValidationMutex\n\nThis mutex will be used to guard concurrent accesses to the map\nthat will keep track of classes whose class chain has already been\nvalidated.\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2020-05-05T15:07:26Z", "type": "commit"}, {"oid": "ea953b3b88519110a5dd48275f9aecd5795a61ea", "url": "https://github.com/eclipse-openj9/openj9/commit/ea953b3b88519110a5dd48275f9aecd5795a61ea", "message": "Add comments\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2020-05-05T15:07:26Z", "type": "forcePushed"}, {"oid": "eeb41d24bcb5078e7617055903ef8cff60897344", "url": "https://github.com/eclipse-openj9/openj9/commit/eeb41d24bcb5078e7617055903ef8cff60897344", "message": "Init Map\n\nThis commit initializes the map that will be used to keep track\nof classes whose class chain has already been validated.\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2020-05-05T19:06:09Z", "type": "commit"}, {"oid": "71aaab83a3af1f56a30cbe318484439b3d6f3241", "url": "https://github.com/eclipse-openj9/openj9/commit/71aaab83a3af1f56a30cbe318484439b3d6f3241", "message": "Cache result of class chain validation\n\nThis commit introduces the ability to cache the result of the validation\nof a class' class chain. The class chain validation validates the shape\nof a loaded class; as such it does so using romclass comparisons.\nTherefore, the shape can't change for the duration of the run.\nTherefore, once a class has been validated (or failed to validate), that\nresult is true for the duration of the run.\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2020-05-05T19:06:10Z", "type": "commit"}, {"oid": "71778530f37660002e532e6e5a70808a5b10736d", "url": "https://github.com/eclipse-openj9/openj9/commit/71778530f37660002e532e6e5a70808a5b10736d", "message": "Add comments\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2020-05-05T19:06:10Z", "type": "commit"}, {"oid": "71778530f37660002e532e6e5a70808a5b10736d", "url": "https://github.com/eclipse-openj9/openj9/commit/71778530f37660002e532e6e5a70808a5b10736d", "message": "Add comments\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2020-05-05T19:06:10Z", "type": "forcePushed"}]}