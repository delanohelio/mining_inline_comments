{"pr_number": 8527, "pr_title": "Support Known Object Table in JITServer", "pr_createdAt": "2020-02-07T17:28:27Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/8527", "timeline": [{"oid": "743a627411d21f76a473880c75c12788b51986eb", "url": "https://github.com/eclipse-openj9/openj9/commit/743a627411d21f76a473880c75c12788b51986eb", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-07T22:07:36Z", "type": "forcePushed"}, {"oid": "788cca78ca8fbf9808f223445e37fa9cf6682299", "url": "https://github.com/eclipse-openj9/openj9/commit/788cca78ca8fbf9808f223445e37fa9cf6682299", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-07T22:39:29Z", "type": "forcePushed"}, {"oid": "259b7a0e74e8e9e889750a42b4c07c6945d7c73d", "url": "https://github.com/eclipse-openj9/openj9/commit/259b7a0e74e8e9e889750a42b4c07c6945d7c73d", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-11T22:24:55Z", "type": "forcePushed"}, {"oid": "8cd30efd89f618b6ede6395407ddecf772e1f9f3", "url": "https://github.com/eclipse-openj9/openj9/commit/8cd30efd89f618b6ede6395407ddecf772e1f9f3", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-12T21:59:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNTE5NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r378915195", "bodyText": "Could you please document why _compiler can be NULL here? This must be related to the client somehow.", "author": "mpirvu", "createdAt": "2020-02-13T15:01:46Z", "path": "runtime/compiler/control/CompilationThread.cpp", "diffHunk": "@@ -7370,7 +7371,7 @@ TR::CompilationInfoPerThreadBase::postCompilationTasks(J9VMThread * vmThread,\n       {\n       metaData = 0;\n       }\n-   else if (TR::CompilationInfo::shouldRetryCompilation(entry, _compiler))\n+   else if (_compiler && TR::CompilationInfo::shouldRetryCompilation(entry, _compiler))", "originalCommit": "8cd30efd89f618b6ede6395407ddecf772e1f9f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NTU4Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379145587", "bodyText": "This is a very rare case I ran into where postCompilationTasks() could be triggered twice. A steam failure exception might be thrown inside postCompilationTasks(), although the compilation is already successful at the server . This exception is caught in CompilationInfoPerThreadBase::compile() and setCompilation(NULL)  is called before postCompilationTasks() is called.\nHowever it only happens when sending free KOT messages. Since I'm going to remove this message, I plan to revert this change because we don't have other known cases that hits this path.\nCompilationInfoPerThreadBase::compile()\ntry \n{ \n\t\u2026\n\tpostCompilationTasks();\n}\ncatch \n{\n\t\u2026\n\tpostCompilationTasks();\n}\nhttps://github.com/eclipse/openj9/blob/ed3d30eedefeef319a1908a98556262ec8fa7c1e/runtime/compiler/control/CompilationThread.cpp#L7752-L7762.", "author": "a7ehuo", "createdAt": "2020-02-13T22:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNTE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkyMzc1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r378923756", "bodyText": "Maybe this could be simplified to:\nif (_compiler->getKnownObjectTable() &&\n    (!_compiler->isOutOfProcessCompilation() || metadata)) // Compilation aborted early at the server\n\nWhy don't we delete those JNI references at the server if the compilation was aborted early?", "author": "mpirvu", "createdAt": "2020-02-13T15:15:11Z", "path": "runtime/compiler/control/CompilationThread.cpp", "diffHunk": "@@ -7550,7 +7546,18 @@ TR::CompilationInfoPerThreadBase::postCompilationTasks(J9VMThread * vmThread,\n #endif /* defined(JITSERVER_SUPPORT) */\n \n    if (_compiler)\n+      {\n+      bool isToFreeKnownObjectTable = true;\n+      // Compilation aborted early at the server\n+      if (_compiler->getPersistentInfo()->getRemoteCompilationMode() == JITServer::SERVER && !metaData)\n+         isToFreeKnownObjectTable = false;\n+\n+      // The KOT needs to survive at least until we're done committing virtual guards\n+      if (_compiler->getKnownObjectTable() && isToFreeKnownObjectTable)\n+         _compiler->freeKnownObjectTable();\n+", "originalCommit": "8cd30efd89f618b6ede6395407ddecf772e1f9f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NjgwMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379146802", "bodyText": "This change will be removed in the next commit because the design has changed to create the KOT at the client and the server by default without exchanging messages.", "author": "a7ehuo", "createdAt": "2020-02-13T22:08:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkyMzc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk4NzgwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r378987808", "bodyText": "Is this a bug fix?", "author": "mpirvu", "createdAt": "2020-02-13T16:52:31Z", "path": "runtime/compiler/control/CompilationThread.cpp", "diffHunk": "@@ -7720,44 +7727,54 @@ TR::CompilationInfoPerThreadBase::compile(J9VMThread * vmThread,\n       {\n       entry->_compErrCode = compilationFailure;\n \n-      if (TR::Options::isAnyVerboseOptionSet(TR_VerboseCompileEnd, TR_VerboseCompFailure, TR_VerbosePerformance))\n+      //if (TR::Options::isAnyVerboseOptionSet(TR_VerboseCompileEnd, TR_VerboseCompFailure, TR_VerbosePerformance))\n          {\n          try\n             {\n             throw;\n             }\n          catch (const J9::JITShutdown)\n             {\n-            TR_VerboseLog::writeLineLocked(TR_Vlog_FAILURE,\"<EARLY TRANSLATION FAILURE: JIT Shutdown signaled>\");\n+            printf(\"%s: <EARLY TRANSLATION FAILURE: JIT Shutdown signaled>\\n\", __PRETTY_FUNCTION__);\n+            //TR_VerboseLog::writeLineLocked(TR_Vlog_FAILURE,\"<EARLY TRANSLATION FAILURE: JIT Shutdown signaled>\");\n             }\n          catch (const std::bad_alloc &e)\n             {\n-            TR_VerboseLog::writeLineLocked(TR_Vlog_FAILURE,\"<EARLY TRANSLATION FAILURE: out of scratch memory>\");\n+            printf(\"%s: <EARLY TRANSLATION FAILURE: out of scratch memory>\\n\", __PRETTY_FUNCTION__);\n+            //TR_VerboseLog::writeLineLocked(TR_Vlog_FAILURE,\"<EARLY TRANSLATION FAILURE: out of scratch memory>\");\n             }\n          catch (const std::exception &e)\n             {\n-            TR_VerboseLog::writeLineLocked(TR_Vlog_FAILURE,\"<EARLY TRANSLATION FAILURE: compilation aborted>\");\n+            printf(\"%s: <EARLY TRANSLATION FAILURE: compilation aborted>: %s @ %s\\n\", __PRETTY_FUNCTION__, getCompilation()->signature(), getCompilation()->getHotnessName());\n+            //TR_VerboseLog::writeLineLocked(TR_Vlog_FAILURE,\"<EARLY TRANSLATION FAILURE: compilation aborted>\");\n+            //\n+            //\n+            //            \"Failed to load previously AOT compiled body for %s @ %s\",\n             }\n          }\n \n       Trc_JIT_outOfMemory(vmThread);\n+\n+#if 0\n #if defined(JITSERVER_SUPPORT)\n       if (getCompilation() && getCompilation()->getPersistentInfo()->getRemoteCompilationMode() == JITServer::SERVER)\n          {\n          getCompilation()->getOptions()->closeLogFileForClientOptions();\n          }\n #endif /* defined(JITSERVER_SUPPORT) */\n+\n       if (getCompilation())\n          {\n+         printf(\"%s: does knownObjectTable need to be freed at the client and the server here? How? What if there  a stream failure?\\n\", __PRETTY_FUNCTION__);\n          getCompilation()->~Compilation();\n          }\n       setCompilation(NULL);\n-\n+#endif\n       // This method has to be called from within the catch block,\n       // since moving it outside would result in it getting invoked\n       // twice on a successful compilation.\n       startPC = postCompilationTasks(vmThread, entry, method,\n-                                     aotCachedMethod, metaData,\n+                                     aotCachedMethod, NULL,", "originalCommit": "8cd30efd89f618b6ede6395407ddecf772e1f9f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NjAzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379146031", "bodyText": "This change is originally added for the same reason as mentioned on the above #8527 (comment). Will revert this change for the same reason.", "author": "a7ehuo", "createdAt": "2020-02-13T22:06:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk4NzgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAxMDUyNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379010525", "bodyText": "I would like a comment explaining why this statement does not need to be done at the server.", "author": "mpirvu", "createdAt": "2020-02-13T17:30:54Z", "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -706,7 +706,11 @@ InterpreterEmulator::visitInvokestatic()\n                _recursionDepth, allconsts);\n          if (mcsIndex != TR::KnownObjectTable::UNKNOWN)\n             {\n+#if defined(JITSERVER_SUPPORT)\n+            if (!comp()->isOutOfProcessCompilation() && comp()->getKnownObjectTable())\n+#else\n             if (comp()->getKnownObjectTable())\n+#endif /* defined(JITSERVER_SUPPORT) */\n                mcs->setMCSReferenceLocation(comp()->getKnownObjectTable()->getPointerLocation(mcsIndex));", "originalCommit": "8cd30efd89f618b6ede6395407ddecf772e1f9f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0OTU5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379149592", "bodyText": "It's not finalized. I need to trace if MCS references will be dereferenced later directly at the server. To iron out all wrinkles regarding to the scope of the change, I just disabled it at the server for now.", "author": "a7ehuo", "createdAt": "2020-02-13T22:14:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAxMDUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyNzE5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379027194", "bodyText": "Why does this method need to be reimplemented? It should call the correct getIndex method, though addArrayWithConstantElements also needs to do the right thing (if the client also maintains a KOT, it may need to add the index to the bitvector represented by _arrayWithConstantElements though I am unsure).", "author": "mpirvu", "createdAt": "2020-02-13T18:02:43Z", "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,167 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndex, objectPointer);\n+      auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t *>();\n+\n+      TR::KnownObjectTable::Index index = std::get<0>(recv);\n+      if (index != nextIndex)\n+         {\n+         return index;\n+         }\n+      else\n+         {\n+         _references.setSize(nextIndex+1);\n+         _references[nextIndex] = std::get<1>(recv);\n+         }\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n+      TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n+\n+      // Search for existing matching entry\n+      //\n+      for (uint32_t i = 1; i < nextIndex; i++)\n+         if (*_references.element(i) == objectPointer)\n+            return i;\n+\n+      // No luck -- allocate a new one\n+      //\n+      J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n+      TR_ASSERT(thread, \"assertion failure\");\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+      }\n+\n    return nextIndex;\n    }\n \n \n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements)", "originalCommit": "8cd30efd89f618b6ede6395407ddecf772e1f9f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyNzk5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379027991", "bodyText": "I see a difference. In the original implementation we assume that we have VM access. However, I think that the server always holds VM access.", "author": "mpirvu", "createdAt": "2020-02-13T18:04:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyNzE5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUyOTAxMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379529013", "bodyText": "Yes, this method is reimplemented because of the assert that checks on the VM access in the OMR implementation.\nAs long as isArrayWithConstantElements() is not called at JITClient, _arrayWithConstantElements doesn\u2019t need to be updated at the JITClient. So addArrayWithConstantElements() doesn't need to be reimplemented.", "author": "a7ehuo", "createdAt": "2020-02-14T16:36:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyNzE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyODc5OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379028798", "bodyText": "This is a new method. Does it need to be virtual?", "author": "mpirvu", "createdAt": "2020-02-13T18:06:00Z", "path": "runtime/compiler/env/J9KnownObjectTable.hpp", "diffHunk": "@@ -59,13 +59,24 @@ class OMR_EXTENSIBLE KnownObjectTable : public OMR::KnownObjectTableConnector\n \n    KnownObjectTable(TR::Compilation *comp);\n \n+   TR::KnownObjectTable *self();\n+\n    virtual Index getEndIndex();\n    virtual Index getIndex(uintptrj_t objectPointer);\n+   Index getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements);\n    virtual uintptrj_t *getPointerLocation(Index index);\n    virtual bool isNull(Index index);\n \n    virtual void dumpTo(TR::FILE *file, TR::Compilation *comp);\n \n+   virtual Index getIndexAt(uintptrj_t *objectReferenceLocation);\n+   virtual Index getIndexAt(uintptrj_t *objectReferenceLocation, bool isArrayWithConstantElements);\n+   virtual Index getExistingIndexAt(uintptrj_t *objectReferenceLocation);\n+\n+   virtual uintptrj_t getPointer(Index index);\n+\n+   virtual uintptrj_t dereferenceObjectPointerReference(uintptrj_t *objectReferenceLocation);", "originalCommit": "8cd30efd89f618b6ede6395407ddecf772e1f9f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAzMzAxNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379033016", "bodyText": "Again, I don't know if addArrayWithConstantEelements() needs to be executed at the client as well.", "author": "mpirvu", "createdAt": "2020-02-13T18:14:29Z", "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,167 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndex, objectPointer);\n+      auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t *>();\n+\n+      TR::KnownObjectTable::Index index = std::get<0>(recv);\n+      if (index != nextIndex)\n+         {\n+         return index;\n+         }\n+      else\n+         {\n+         _references.setSize(nextIndex+1);\n+         _references[nextIndex] = std::get<1>(recv);\n+         }\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n+      TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n+\n+      // Search for existing matching entry\n+      //\n+      for (uint32_t i = 1; i < nextIndex; i++)\n+         if (*_references.element(i) == objectPointer)\n+            return i;\n+\n+      // No luck -- allocate a new one\n+      //\n+      J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n+      TR_ASSERT(thread, \"assertion failure\");\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+      }\n+\n    return nextIndex;\n    }\n \n \n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements)\n+   {\n+   TR::KnownObjectTable::Index index = self()->getIndex(objectPointer);\n+   if (isArrayWithConstantElements)\n+      {\n+      self()->addArrayWithConstantElements(index);\n+      }\n+   return index;\n+   }\n+\n+\n+uintptrj_t\n+J9::KnownObjectTable::dereferenceObjectPointerReference(uintptrj_t *objectReferenceLocation)\n+   {\n+   uintptrj_t objectPointer = 0;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_dereferenceObjectPointerReference, objectReferenceLocation);\n+      objectPointer = std::get<0>(stream->read<uintptrj_t>());\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR::VMAccessCriticalSection dereferenceObjectPointerReferenceCriticalSection(self()->comp());\n+      objectPointer = *objectReferenceLocation;\n+      }\n+   return objectPointer;\n+   }\n+\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndexAt(uintptrj_t *objectReferenceLocation)\n+   {\n+   TR::KnownObjectTable::Index result = UNKNOWN;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      uintptrj_t objectPointer = self()->dereferenceObjectPointerReference(objectReferenceLocation);\n+      result = self()->getIndex(objectPointer);\n+      }\n+#endif /* defined(JITSERVER_SUPPORT) */\n+   else\n+      {\n+      TR::VMAccessCriticalSection getIndexAtCriticalSection(self()->comp());\n+      uintptrj_t objectPointer = *objectReferenceLocation; // Note: object references held as uintptrj_t must never be compressed refs\n+      result = self()->getIndex(objectPointer);\n+      }\n+   return result;\n+   }\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndexAt(uintptrj_t *objectReferenceLocation, bool isArrayWithConstantElements)\n+   {\n+   Index result = self()->getIndexAt(objectReferenceLocation);\n+   if (isArrayWithConstantElements)\n+      self()->addArrayWithConstantElements(result);", "originalCommit": "8cd30efd89f618b6ede6395407ddecf772e1f9f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUyOTM0NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379529345", "bodyText": "Same comment as #8527 (comment).", "author": "a7ehuo", "createdAt": "2020-02-14T16:36:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAzMzAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAzMzkyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379033922", "bodyText": "This implementation will send two messages: one for dereferencing the JNI reference given as parameter and another to do the search through the KOT. Maybe just send a message that will do both.", "author": "mpirvu", "createdAt": "2020-02-13T18:16:18Z", "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,167 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndex, objectPointer);\n+      auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t *>();\n+\n+      TR::KnownObjectTable::Index index = std::get<0>(recv);\n+      if (index != nextIndex)\n+         {\n+         return index;\n+         }\n+      else\n+         {\n+         _references.setSize(nextIndex+1);\n+         _references[nextIndex] = std::get<1>(recv);\n+         }\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n+      TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n+\n+      // Search for existing matching entry\n+      //\n+      for (uint32_t i = 1; i < nextIndex; i++)\n+         if (*_references.element(i) == objectPointer)\n+            return i;\n+\n+      // No luck -- allocate a new one\n+      //\n+      J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n+      TR_ASSERT(thread, \"assertion failure\");\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+      }\n+\n    return nextIndex;\n    }\n \n \n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements)\n+   {\n+   TR::KnownObjectTable::Index index = self()->getIndex(objectPointer);\n+   if (isArrayWithConstantElements)\n+      {\n+      self()->addArrayWithConstantElements(index);\n+      }\n+   return index;\n+   }\n+\n+\n+uintptrj_t\n+J9::KnownObjectTable::dereferenceObjectPointerReference(uintptrj_t *objectReferenceLocation)\n+   {\n+   uintptrj_t objectPointer = 0;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_dereferenceObjectPointerReference, objectReferenceLocation);\n+      objectPointer = std::get<0>(stream->read<uintptrj_t>());\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR::VMAccessCriticalSection dereferenceObjectPointerReferenceCriticalSection(self()->comp());\n+      objectPointer = *objectReferenceLocation;\n+      }\n+   return objectPointer;\n+   }\n+\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndexAt(uintptrj_t *objectReferenceLocation)\n+   {\n+   TR::KnownObjectTable::Index result = UNKNOWN;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      uintptrj_t objectPointer = self()->dereferenceObjectPointerReference(objectReferenceLocation);", "originalCommit": "8cd30efd89f618b6ede6395407ddecf772e1f9f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAzODY4MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379038680", "bodyText": "These existing methods have become virtual. Why? I thought that the extensible class framework was supposed to use static inheritance.", "author": "mpirvu", "createdAt": "2020-02-13T18:25:18Z", "path": "runtime/compiler/env/J9KnownObjectTable.hpp", "diffHunk": "@@ -59,13 +59,24 @@ class OMR_EXTENSIBLE KnownObjectTable : public OMR::KnownObjectTableConnector\n \n    KnownObjectTable(TR::Compilation *comp);\n \n+   TR::KnownObjectTable *self();\n+\n    virtual Index getEndIndex();\n    virtual Index getIndex(uintptrj_t objectPointer);\n+   Index getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements);\n    virtual uintptrj_t *getPointerLocation(Index index);\n    virtual bool isNull(Index index);\n \n    virtual void dumpTo(TR::FILE *file, TR::Compilation *comp);\n \n+   virtual Index getIndexAt(uintptrj_t *objectReferenceLocation);\n+   virtual Index getIndexAt(uintptrj_t *objectReferenceLocation, bool isArrayWithConstantElements);\n+   virtual Index getExistingIndexAt(uintptrj_t *objectReferenceLocation);\n+\n+   virtual uintptrj_t getPointer(Index index);", "originalCommit": "8cd30efd89f618b6ede6395407ddecf772e1f9f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUyOTk3Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379529972", "bodyText": "Will clean up the virtual keywords. I guess originally, self() is not implemented in  OpenJ9 and virtual still mattered.", "author": "a7ehuo", "createdAt": "2020-02-14T16:38:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAzODY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA0MjAzOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379042039", "bodyText": "I guess this remains as a TODO", "author": "mpirvu", "createdAt": "2020-02-13T18:31:27Z", "path": "runtime/compiler/optimizer/J9TransformUtil.cpp", "diffHunk": "@@ -1472,6 +1472,10 @@ J9::TransformUtil::transformIndirectLoadChainAt(TR::Compilation *comp, TR::Node\n bool\n J9::TransformUtil::transformIndirectLoadChain(TR::Compilation *comp, TR::Node *node, TR::Node *baseExpression, TR::KnownObjectTable::Index baseKnownObject, TR::Node **removedNode)\n    {\n+#if defined(JITSERVER_SUPPORT)\n+   if (comp->isOutOfProcessCompilation())", "originalCommit": "8cd30efd89f618b6ede6395407ddecf772e1f9f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA2NjQwOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379066409", "bodyText": "This piece is also problematic. It is executed with VMaccess in hand to prevent GC from moving objects. However, the server will send a few messages to the client and the client does not hold VMaccess throughout this sequence of operations. Somehow we need to create a big function out of this code and execute it atomically (that is under VMaccess) at the client.", "author": "mpirvu", "createdAt": "2020-02-13T19:18:50Z", "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -95,7 +95,7 @@ InterpreterEmulator::maintainStackForGetField()\n             {\n             TR::VMAccessCriticalSection dereferenceKnownObjectField(comp()->fej9());", "originalCommit": "8cd30efd89f618b6ede6395407ddecf772e1f9f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA3NDkwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379074908", "bodyText": "I think it can be done as a message that sends to the client the mirror (for _calleeMethod->getDeclaringClassFromFieldOrStatic()) the baseObjectIndex, the cpIndex, the fieldOffset and receives a KOT index for the fieldAddress. However, if a new entry was added the KOT at the client, the server must do the same.", "author": "mpirvu", "createdAt": "2020-02-13T19:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA2NjQwOQ=="}], "type": "inlineReview"}, {"oid": "049817c3175f0c234c9983c789bd07eb9b8fd297", "url": "https://github.com/eclipse-openj9/openj9/commit/049817c3175f0c234c9983c789bd07eb9b8fd297", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-14T16:40:04Z", "type": "forcePushed"}, {"oid": "dd19c43421254186ba3b321a2a7f7ba8acf1c952", "url": "https://github.com/eclipse-openj9/openj9/commit/dd19c43421254186ba3b321a2a7f7ba8acf1c952", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-14T20:56:34Z", "type": "forcePushed"}, {"oid": "a1be388a70b214617373e45dcbbe6123432754b2", "url": "https://github.com/eclipse-openj9/openj9/commit/a1be388a70b214617373e45dcbbe6123432754b2", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-14T21:32:37Z", "type": "forcePushed"}, {"oid": "5ff8ab957b376d8f439979bb7fd2011b87eec225", "url": "https://github.com/eclipse-openj9/openj9/commit/5ff8ab957b376d8f439979bb7fd2011b87eec225", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-14T21:56:16Z", "type": "forcePushed"}, {"oid": "e83b6e5c3adc40fb285ab49d5122f3fbfd2c0ed9", "url": "https://github.com/eclipse-openj9/openj9/commit/e83b6e5c3adc40fb285ab49d5122f3fbfd2c0ed9", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-18T21:22:44Z", "type": "forcePushed"}, {"oid": "33005e156ec75a57a02df914d2e11da404da7342", "url": "https://github.com/eclipse-openj9/openj9/commit/33005e156ec75a57a02df914d2e11da404da7342", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-18T23:08:12Z", "type": "forcePushed"}, {"oid": "407335283f53c05ee9783055e465fd67eed973ba", "url": "https://github.com/eclipse-openj9/openj9/commit/407335283f53c05ee9783055e465fd67eed973ba", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-19T20:25:08Z", "type": "forcePushed"}, {"oid": "9f460f2b015e6f7af5f3f616a55c9d4570c6b232", "url": "https://github.com/eclipse-openj9/openj9/commit/9f460f2b015e6f7af5f3f616a55c9d4570c6b232", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-19T22:01:22Z", "type": "forcePushed"}, {"oid": "9331481c084fd361e21efd5df9d70fef6ea2e7fc", "url": "https://github.com/eclipse-openj9/openj9/commit/9331481c084fd361e21efd5df9d70fef6ea2e7fc", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-19T22:14:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA3NTI0MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r382075241", "bodyText": "Another pair of curly brackets is not needed.", "author": "mpirvu", "createdAt": "2020-02-20T15:31:33Z", "path": "runtime/compiler/optimizer/J9Inliner.cpp", "diffHunk": "@@ -685,26 +685,51 @@ bool TR_J9MutableCallSite::findCallSiteTarget (TR_CallStack *callStack, TR_Inlin\n          heuristicTrace(inliner->tracer(),\"  Virtual guard NOPing disabled\");\n          return false;\n          }\n+\n       TR_VirtualGuardSelection *vgs = new (comp()->trHeapMemory()) TR_VirtualGuardSelection(TR_MutableCallSiteTargetGuard, TR_DummyTest);\n       vgs->_mutableCallSiteObject = _mcsReferenceLocation;\n       TR::KnownObjectTable *knot = comp()->getOrCreateKnownObjectTable();\n-\n+#if defined(JITSERVER_SUPPORT)\n+      if (comp()->isOutOfProcessCompilation())\n          {\n-         TR::VMAccessCriticalSection mutableCallSiteEpoch(comp()->fej9());\n          vgs->_mutableCallSiteEpoch = TR::KnownObjectTable::UNKNOWN;\n-         uintptrj_t mcsObject = comp()->fej9()->getStaticReferenceFieldAtAddress((uintptrj_t)_mcsReferenceLocation);\n-         if (mcsObject)\n+         auto stream = TR::CompilationInfo::getStream();\n+         stream->write(JITServer::MessageType::KnownObjectTable_mutableCallSiteEpoch, _mcsReferenceLocation);\n+\n+         auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t*>();\n+         TR::KnownObjectTable::Index knotIndex = std::get<0>(recv);\n+         uintptrj_t *objectPointerReference = std::get<1>(recv);\n+\n+         if (knotIndex != TR::KnownObjectTable::UNKNOWN)\n             {\n-            TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp()->fej9());\n-            uintptrj_t currentEpoch = fej9->getVolatileReferenceField(mcsObject, \"epoch\", \"Ljava/lang/invoke/MethodHandle;\");\n-            if (knot && currentEpoch)\n-               vgs->_mutableCallSiteEpoch = knot->getIndex(currentEpoch);\n+            vgs->_mutableCallSiteEpoch = knotIndex;\n+            knot->addIndexAndObjectPointerReferenceAtServer(knotIndex, objectPointerReference);\n             }\n          else\n             {\n             vgs->_mutableCallSiteObject = NULL;\n             }\n          }\n+      else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+         {\n+            {", "originalCommit": "9331481c084fd361e21efd5df9d70fef6ea2e7fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a369de4ae9b29270b7661e496f01d8b974866069", "url": "https://github.com/eclipse-openj9/openj9/commit/a369de4ae9b29270b7661e496f01d8b974866069", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-20T23:14:27Z", "type": "forcePushed"}, {"oid": "c77c4f0dfa41ed04a138c41945f2cce63e4fbd8d", "url": "https://github.com/eclipse-openj9/openj9/commit/c77c4f0dfa41ed04a138c41945f2cce63e4fbd8d", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-20T23:24:04Z", "type": "forcePushed"}, {"oid": "06b1ca76840273dc85c634fe8ba00602d6340f88", "url": "https://github.com/eclipse-openj9/openj9/commit/06b1ca76840273dc85c634fe8ba00602d6340f88", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-21T15:35:39Z", "type": "forcePushed"}, {"oid": "9d7c492d2bebbdad012c99d75cc6ba69f009dd08", "url": "https://github.com/eclipse-openj9/openj9/commit/9d7c492d2bebbdad012c99d75cc6ba69f009dd08", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-21T22:04:31Z", "type": "forcePushed"}, {"oid": "90da570d6f0e9914ca1284ac2b8225c5e50317c8", "url": "https://github.com/eclipse-openj9/openj9/commit/90da570d6f0e9914ca1284ac2b8225c5e50317c8", "message": "Support Known Object Table at the server\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-24T19:51:18Z", "type": "forcePushed"}, {"oid": "a3e560cfdfcfe478b7aad3d56f3c8fe31c492c2f", "url": "https://github.com/eclipse-openj9/openj9/commit/a3e560cfdfcfe478b7aad3d56f3c8fe31c492c2f", "message": "Support Known Object Table at the server\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-24T22:31:31Z", "type": "forcePushed"}, {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "url": "https://github.com/eclipse-openj9/openj9/commit/bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "message": "Support Known Object Table at the server\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-25T16:02:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAyOTIxMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384029212", "bodyText": "Maybe an assert would be better here.", "author": "mpirvu", "createdAt": "2020-02-25T17:44:52Z", "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -556,7 +556,15 @@ TR_CHTable::commitVirtualGuard(TR_VirtualGuard *info, List<TR_VirtualGuardSite>\n    else if (info->getKind() == TR_MutableCallSiteTargetGuard)\n       {\n       static char *dontInvalidateMCSTargetGuards = feGetEnv(\"TR_dontInvalidateMCSTargetGuards\");\n-      if (!dontInvalidateMCSTargetGuards)\n+      if (!dontInvalidateMCSTargetGuards\n+#if defined(JITSERVER_SUPPORT)\n+         // JITServer KOT: At the moment this method is called only by TR_CHTable::commit().\n+         // TR_CHTable::commit() already checks comp->isOutOfProcessCompilation().\n+         // Adding the following check as a precaution in case commitVirtualGuard() is called", "originalCommit": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzMzAxNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384033016", "bodyText": "Change \"it might not cause any issue\" --> \"and therefore it cannot cause any issues\"", "author": "mpirvu", "createdAt": "2020-02-25T18:03:56Z", "path": "runtime/compiler/env/JITServerCHTable.cpp", "diffHunk": "@@ -388,6 +388,12 @@ JITClientCommitVirtualGuard(const VirtualGuardInfoForCHTable *info, std::vector<\n \n             {\n             TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+            // JITServer KOT:\n+            // This method is called by JITClientCHTableCommit() at the client.\n+            // Although accessing VM is not an issue, getIndex() could update the KOT\n+            // at the client directly and the KOT at the server could be out of sync.\n+            // However, JITClientCHTableCommit() is called at the end of compilation,\n+            // it might not cause any issue.", "originalCommit": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3MjY0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384072643", "bodyText": "Does it make sense to have this code if we are going to crash the JVM?", "author": "mpirvu", "createdAt": "2020-02-25T19:20:13Z", "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -86,6 +251,42 @@ J9::KnownObjectTable::getPointerLocation(Index index)\n    }\n \n \n+#if defined(JITSERVER_SUPPORT)\n+void\n+J9::KnownObjectTable::updateKnownObjectTableAtServer(Index index, uintptrj_t *objectReferenceLocation)\n+   {\n+   TR_ASSERT_FATAL(self()->comp()->isOutOfProcessCompilation(), \"updateKnownObjectTableAtServer should only be called at the server\");\n+\n+   if (index == TR::KnownObjectTable::UNKNOWN)\n+      return;\n+\n+   uint32_t nextIndex = self()->getEndIndex();\n+\n+   if (index == nextIndex)\n+      {\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = objectReferenceLocation;\n+      }\n+   else if (index < nextIndex)\n+      {\n+      TR_ASSERT((objectReferenceLocation == _references[index]), \"_references[%d]=%p is not the same as the client KOT[%d]=%p. _references.size()=%u\",\n+                  index, _references[index], index, objectReferenceLocation, nextIndex);\n+      _references[index] = objectReferenceLocation;\n+      }\n+   else\n+      {\n+      _references.setSize(index+1);\n+      _references[index] = objectReferenceLocation;\n+\n+      for (uint32_t i = nextIndex; i < index; ++i)\n+         _references[i] = NULL;\n+", "originalCommit": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3NDYxMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384774611", "bodyText": "I'm debating between two changes:\nEither 1)\nChange TR_ASSERT_FATAL() as TR_ASSERT and keep the above code as it is.\nOR 2)\nIf (index > nextIndex), don't do the above update but only throw TR_ASSERT_FATAL().", "author": "a7ehuo", "createdAt": "2020-02-26T21:23:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3MjY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4Njc0MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384786741", "bodyText": "I would prefer (2)", "author": "mpirvu", "createdAt": "2020-02-26T21:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3MjY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4MjA5Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384082097", "bodyText": "I see that dereferenceObjectPointerReference is only used in the JITServer specific part of getPointer. If that's the case, maybe we should make this JITServer specific.", "author": "mpirvu", "createdAt": "2020-02-25T19:37:35Z", "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,184 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndex, objectPointer);\n+      auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t *>();\n+\n+      TR::KnownObjectTable::Index index = std::get<0>(recv);\n+      uintptrj_t *objectReferenceLocation = std::get<1>(recv);\n+      TR_ASSERT_FATAL(index <= nextIndex, \"The KOT index %d at the client is greater than the KOT index %d at the server\", index, nextIndex);\n+\n+      if (index < nextIndex)\n+         {\n+         return index;\n+         }\n+      else\n+         {\n+         updateKnownObjectTableAtServer(index, objectReferenceLocation);\n+         }\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n+      TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n+\n+      // Search for existing matching entry\n+      //\n+      for (uint32_t i = 1; i < nextIndex; i++)\n+         if (*_references.element(i) == objectPointer)\n+            return i;\n+\n+      // No luck -- allocate a new one\n+      //\n+      J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n+      TR_ASSERT(thread, \"assertion failure\");\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+      }\n+\n    return nextIndex;\n    }\n \n \n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements)\n+   {\n+   TR::KnownObjectTable::Index index = self()->getIndex(objectPointer);\n+   if (isArrayWithConstantElements)\n+      {\n+      self()->addArrayWithConstantElements(index);\n+      }\n+   return index;\n+   }\n+\n+\n+uintptrj_t\n+J9::KnownObjectTable::dereferenceObjectPointerReference(uintptrj_t *objectReferenceLocation)\n+   {\n+   uintptrj_t objectPointer = 0;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_dereferenceObjectPointerReference, objectReferenceLocation);\n+      objectPointer = std::get<0>(stream->read<uintptrj_t>());\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR::VMAccessCriticalSection dereferenceObjectPointerReferenceCriticalSection(self()->comp());", "originalCommit": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5MzcwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384093707", "bodyText": "yes, it should break", "author": "mpirvu", "createdAt": "2020-02-25T19:58:53Z", "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,184 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndex, objectPointer);\n+      auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t *>();\n+\n+      TR::KnownObjectTable::Index index = std::get<0>(recv);\n+      uintptrj_t *objectReferenceLocation = std::get<1>(recv);\n+      TR_ASSERT_FATAL(index <= nextIndex, \"The KOT index %d at the client is greater than the KOT index %d at the server\", index, nextIndex);\n+\n+      if (index < nextIndex)\n+         {\n+         return index;\n+         }\n+      else\n+         {\n+         updateKnownObjectTableAtServer(index, objectReferenceLocation);\n+         }\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n+      TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n+\n+      // Search for existing matching entry\n+      //\n+      for (uint32_t i = 1; i < nextIndex; i++)\n+         if (*_references.element(i) == objectPointer)\n+            return i;\n+\n+      // No luck -- allocate a new one\n+      //\n+      J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n+      TR_ASSERT(thread, \"assertion failure\");\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+      }\n+\n    return nextIndex;\n    }\n \n \n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements)\n+   {\n+   TR::KnownObjectTable::Index index = self()->getIndex(objectPointer);\n+   if (isArrayWithConstantElements)\n+      {\n+      self()->addArrayWithConstantElements(index);\n+      }\n+   return index;\n+   }\n+\n+\n+uintptrj_t\n+J9::KnownObjectTable::dereferenceObjectPointerReference(uintptrj_t *objectReferenceLocation)\n+   {\n+   uintptrj_t objectPointer = 0;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_dereferenceObjectPointerReference, objectReferenceLocation);\n+      objectPointer = std::get<0>(stream->read<uintptrj_t>());\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR::VMAccessCriticalSection dereferenceObjectPointerReferenceCriticalSection(self()->comp());\n+      objectPointer = *objectReferenceLocation;\n+      }\n+   return objectPointer;\n+   }\n+\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndexAt(uintptrj_t *objectReferenceLocation)\n+   {\n+   TR::KnownObjectTable::Index result = UNKNOWN;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndexAt, objectReferenceLocation);\n+      auto recv = stream->read<TR::KnownObjectTable::Index>();\n+      result = std::get<0>(stream->read<TR::KnownObjectTable::Index>());\n+\n+      updateKnownObjectTableAtServer(result, objectReferenceLocation);\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR::VMAccessCriticalSection getIndexAtCriticalSection(self()->comp());\n+      uintptrj_t objectPointer = *objectReferenceLocation; // Note: object references held as uintptrj_t must never be compressed refs\n+      result = self()->getIndex(objectPointer);\n+      }\n+   return result;\n+   }\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndexAt(uintptrj_t *objectReferenceLocation, bool isArrayWithConstantElements)\n+   {\n+   Index result = self()->getIndexAt(objectReferenceLocation);\n+   if (isArrayWithConstantElements)\n+      self()->addArrayWithConstantElements(result);\n+   return result;\n+   }\n+\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getExistingIndexAt(uintptrj_t *objectReferenceLocation)\n+   {\n+   TR::KnownObjectTable::Index result = UNKNOWN;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getExistingIndexAt, objectReferenceLocation);\n+      result = std::get<0>(stream->read<TR::KnownObjectTable::Index>());\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR::VMAccessCriticalSection getExistingIndexAtCriticalSection(self()->comp());\n+\n+      uintptrj_t objectPointer = *objectReferenceLocation;\n+      for (Index i = 0; i < self()->getEndIndex() && (result == UNKNOWN); i++)\n+         {\n+         if (self()->getPointer(i) == objectPointer)\n+            result = i; //TODO: Shouldn't it break here?", "originalCommit": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NTYwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384095608", "bodyText": "why does this need to be reimplemented? The OMR definition is exactly the same.", "author": "mpirvu", "createdAt": "2020-02-25T20:02:42Z", "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,184 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndex, objectPointer);\n+      auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t *>();\n+\n+      TR::KnownObjectTable::Index index = std::get<0>(recv);\n+      uintptrj_t *objectReferenceLocation = std::get<1>(recv);\n+      TR_ASSERT_FATAL(index <= nextIndex, \"The KOT index %d at the client is greater than the KOT index %d at the server\", index, nextIndex);\n+\n+      if (index < nextIndex)\n+         {\n+         return index;\n+         }\n+      else\n+         {\n+         updateKnownObjectTableAtServer(index, objectReferenceLocation);\n+         }\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n+      TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n+\n+      // Search for existing matching entry\n+      //\n+      for (uint32_t i = 1; i < nextIndex; i++)\n+         if (*_references.element(i) == objectPointer)\n+            return i;\n+\n+      // No luck -- allocate a new one\n+      //\n+      J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n+      TR_ASSERT(thread, \"assertion failure\");\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+      }\n+\n    return nextIndex;\n    }\n \n \n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements)\n+   {\n+   TR::KnownObjectTable::Index index = self()->getIndex(objectPointer);\n+   if (isArrayWithConstantElements)\n+      {\n+      self()->addArrayWithConstantElements(index);\n+      }\n+   return index;\n+   }\n+\n+\n+uintptrj_t\n+J9::KnownObjectTable::dereferenceObjectPointerReference(uintptrj_t *objectReferenceLocation)\n+   {\n+   uintptrj_t objectPointer = 0;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_dereferenceObjectPointerReference, objectReferenceLocation);\n+      objectPointer = std::get<0>(stream->read<uintptrj_t>());\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR::VMAccessCriticalSection dereferenceObjectPointerReferenceCriticalSection(self()->comp());\n+      objectPointer = *objectReferenceLocation;\n+      }\n+   return objectPointer;\n+   }\n+\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndexAt(uintptrj_t *objectReferenceLocation)\n+   {\n+   TR::KnownObjectTable::Index result = UNKNOWN;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndexAt, objectReferenceLocation);\n+      auto recv = stream->read<TR::KnownObjectTable::Index>();\n+      result = std::get<0>(stream->read<TR::KnownObjectTable::Index>());\n+\n+      updateKnownObjectTableAtServer(result, objectReferenceLocation);\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR::VMAccessCriticalSection getIndexAtCriticalSection(self()->comp());\n+      uintptrj_t objectPointer = *objectReferenceLocation; // Note: object references held as uintptrj_t must never be compressed refs\n+      result = self()->getIndex(objectPointer);\n+      }\n+   return result;\n+   }\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndexAt(uintptrj_t *objectReferenceLocation, bool isArrayWithConstantElements)\n+   {\n+   Index result = self()->getIndexAt(objectReferenceLocation);\n+   if (isArrayWithConstantElements)\n+      self()->addArrayWithConstantElements(result);\n+   return result;\n+   }\n+\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getExistingIndexAt(uintptrj_t *objectReferenceLocation)\n+   {\n+   TR::KnownObjectTable::Index result = UNKNOWN;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getExistingIndexAt, objectReferenceLocation);\n+      result = std::get<0>(stream->read<TR::KnownObjectTable::Index>());\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR::VMAccessCriticalSection getExistingIndexAtCriticalSection(self()->comp());\n+\n+      uintptrj_t objectPointer = *objectReferenceLocation;\n+      for (Index i = 0; i < self()->getEndIndex() && (result == UNKNOWN); i++)\n+         {\n+         if (self()->getPointer(i) == objectPointer)\n+            result = i; //TODO: Shouldn't it break here?\n+         }\n+      }\n+   return result;\n+   }\n+\n+\n+bool\n+J9::KnownObjectTable::isArrayWithConstantElements(Index index)", "originalCommit": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc1OTcwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384759706", "bodyText": "Will remove the redundant implementation in OpenJ9.", "author": "a7ehuo", "createdAt": "2020-02-26T20:55:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NTYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDExODc0Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384118746", "bodyText": "filterIndexList[i] = knot->getIndex(filtersList[i]);", "author": "mpirvu", "createdAt": "2020-02-25T20:51:31Z", "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -2344,19 +2347,29 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n          break;\n       case MessageType::runFEMacro_invokeFilterArgumentsHandle:\n          {\n-         auto recv = client->getRecvData<uintptrj_t*>();\n+         auto recv = client->getRecvData<uintptrj_t*, bool>();\n          TR::VMAccessCriticalSection invokeFilterArgumentsHandle(fe);\n          uintptrj_t methodHandle = *std::get<0>(recv);\n-         int32_t startPos = (int32_t)fe->getInt32Field(methodHandle, \"startPos\");\n+         bool knotEnabled = std::get<1>(recv);\n \n          uintptrj_t filters = fe->getReferenceField(methodHandle, \"filters\", \"[Ljava/lang/invoke/MethodHandle;\");\n          int32_t numFilters = fe->getArrayLengthInElements(filters);\n          std::vector<uintptrj_t> filtersList(numFilters);\n+         std::vector<TR::KnownObjectTable::Index> filterIndexList(numFilters);\n+         std::vector<uintptrj_t *> filterObjectReferenceLocationList(numFilters);\n+\n          for (int i = 0; i < numFilters; i++)\n             {\n             filtersList[i] = fe->getReferenceElement(filters, i);\n+\n+            if (knotEnabled)\n+               {\n+               filterIndexList[i] = knot->getIndex(fe->getReferenceElement(filters, i));", "originalCommit": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEyMzYwNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384123604", "bodyText": "To avoid the usage of alloca we could create an empty string of methodDescriptorLength+1 chars and use its buffer as an input to fe->getStringUTF8\nstd::string nextSignatureString(methodDescriptorLength+1, 0);\nfe->getStringUTF8(methodDescriptorRef, nextSignatureString.data(), methodDescriptorLength+1);", "author": "mpirvu", "createdAt": "2020-02-25T21:01:37Z", "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -2366,7 +2379,7 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n          char *nextSignature = (char*)alloca(methodDescriptorLength+1);", "originalCommit": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MjQ5Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384772497", "bodyText": "nextSignatureString.data() returns const char* which will not work with getStringUTF8() since it changes the content and a compilation error \"invalid conversion from \u2018const char*\u2019 to \u2018char*\"  will throw too. Looking at other places where getStringUTF8() is called, alloca is called often. Either it could be left as it is or another alternative is to use trMemory->allocateStackMemory as https://github.com/eclipse/openj9/blob/fd96afe5f58b9125d812dcb45ae85f7376e0b7d3/runtime/compiler/control/JITClientCompilationThread.cpp#L892.", "author": "a7ehuo", "createdAt": "2020-02-26T21:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEyMzYwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4NTc3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384785777", "bodyText": "ok, then alloca is fine. I was trying to avoid one round of copying by writing directly into the string buffer. It may work though if using  &mystring[0]", "author": "mpirvu", "createdAt": "2020-02-26T21:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEyMzYwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgwNjIyOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384806228", "bodyText": "& nextSignatureString[0] should work. Maybe it could be done in a separate PR since alloca is used at a few places where getStringUTF8() is called  in JITClientCompilationThread.cpp on constructing the message back to the server.", "author": "a7ehuo", "createdAt": "2020-02-26T22:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEyMzYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEyOTY5Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384129693", "bodyText": "We don't need to send the filtersList. These are object pointers that have no meaning at server.\nHowever, if KOT is disabled we need a way of determining which entries have filters. Sending an array of bool will save space in this case. Thus it's better to send the array called haveFilter", "author": "mpirvu", "createdAt": "2020-02-25T21:14:19Z", "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -2366,7 +2379,7 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n          char *nextSignature = (char*)alloca(methodDescriptorLength+1);\n          fe->getStringUTF8(methodDescriptorRef, nextSignature, methodDescriptorLength+1);\n          std::string nextSignatureString(nextSignature, methodDescriptorLength);\n-         client->write(response, startPos, nextSignatureString, filtersList);\n+         client->write(response, startPos, nextSignatureString, filtersList, filterIndexList, filterObjectReferenceLocationList);", "originalCommit": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEzMDEwOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384130109", "bodyText": "The vector of filters should be replaced by a vector of bools haveFilter", "author": "mpirvu", "createdAt": "2020-02-25T21:15:11Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -8922,15 +8934,18 @@ TR_J9ByteCodeIlGenerator::runFEMacro(TR::SymbolReference *symRef)\n          bool *haveFilter = NULL;\n          bool knotEnabled = !comp()->getOption(TR_DisableKnownObjectTable);\n          char *nextSignature;\n+         TR::KnownObjectTable *knot = knotEnabled ? comp()->getOrCreateKnownObjectTable() : NULL;\n #if defined(JITSERVER_SUPPORT)\n          if (comp()->isOutOfProcessCompilation())\n             {\n             auto stream = TR::CompilationInfo::getStream();\n-            stream->write(JITServer::MessageType::runFEMacro_invokeFilterArgumentsHandle, thunkDetails->getHandleRef());\n-            auto recv = stream->read<int32_t, std::string, std::vector<uintptrj_t>>();\n+            stream->write(JITServer::MessageType::runFEMacro_invokeFilterArgumentsHandle, thunkDetails->getHandleRef(), knotEnabled);\n+            auto recv = stream->read<int32_t, std::string, std::vector<uintptrj_t>, std::vector<TR::KnownObjectTable::Index>, std::vector<uintptrj_t *>>();\n             startPos = std::get<0>(recv);\n             std::string nextSigStr = std::get<1>(recv);\n             std::vector<uintptrj_t> &filters = std::get<2>(recv);", "originalCommit": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEzNTA4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384135081", "bodyText": "Maybe other another test that recvfilterIndexList[i] is not NULL", "author": "mpirvu", "createdAt": "2020-02-25T21:25:18Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -8940,10 +8955,19 @@ TR_J9ByteCodeIlGenerator::runFEMacro(TR::SymbolReference *symRef)\n \n             // copy the filters\n             int32_t numFilters = filters.size();\n+            filterIndexList = knotEnabled ? (TR::KnownObjectTable::Index *) comp()->trMemory()->allocateMemory(sizeof(TR::KnownObjectTable::Index) * numFilters, stackAlloc) : NULL;\n             haveFilter = (bool *) comp()->trMemory()->allocateMemory(sizeof(bool) * numFilters, stackAlloc);\n             for (int i = 0; i <numFilters; i++)\n                {\n                haveFilter[i] = (filters[i] != 0) ? true: false;\n+\n+               if (knotEnabled)\n+                  {\n+                  filterIndexList[i] = recvfilterIndexList[i];\n+\n+                  if (recvfilterIndexList[i] != TR::KnownObjectTable::UNKNOWN)", "originalCommit": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc5OTU1Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384799557", "bodyText": "Do you refer to recvFilterObjectReferenceLocationList[i]? I'm thinking of adding an assert to KnownObjectTable:::updateKnownObjectTableAtServer() to check if the reference is NULL.\nvoid\nJ9::KnownObjectTable::updateKnownObjectTableAtServer(Index index, uintptrj_t *objectReferenceLocation)\n   {\n   TR_ASSERT_FATAL(self()->comp()->isOutOfProcessCompilation(), \"updateKnownObjectTableAtServer should only be called at the server\");\n   TR_ASSERT(objectReferenceLocation, \"objectReferenceLocation should not be NULL\");", "author": "a7ehuo", "createdAt": "2020-02-26T22:13:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEzNTA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY1ODY1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384658650", "bodyText": "If knot is disabled we don't have to compute getVolatileReferenceField, so let's insert this function under if (knotEnabled && knot)", "author": "mpirvu", "createdAt": "2020-02-26T17:47:36Z", "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -2537,6 +2568,199 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n                           std::string((char*) bodyInfo->getMethodInfo(), sizeof(TR_PersistentMethodInfo)));\n          }\n          break;\n+      case MessageType::KnownObjectTable_getIndex:\n+         {\n+         uintptrj_t objectPointer = std::get<0>(client->getRecvData<uintptrj_t>());\n+\n+         TR::VMAccessCriticalSection knownObjectTableGetIndex(fe);\n+         TR::KnownObjectTable::Index index = knot->getIndex(objectPointer);\n+         uintptrj_t *objectPointerReference = knot->getPointerLocation(index);\n+         client->write(response, index, objectPointerReference);\n+         }\n+         break;\n+      case MessageType::KnownObjectTable_getIndexAt:\n+         {\n+         uintptrj_t *objectPointerReference = std::get<0>(client->getRecvData<uintptrj_t*>());\n+         client->write(response, knot->getIndexAt(objectPointerReference));\n+         }\n+         break;\n+      case MessageType::KnownObjectTable_dereferenceObjectPointerReference:\n+         {\n+         uintptrj_t *objectPointerReference = std::get<0>(client->getRecvData<uintptrj_t*>());\n+         client->write(response, knot->dereferenceObjectPointerReference(objectPointerReference));\n+         }\n+         break;\n+      case MessageType::KnownObjectTable_getExistingIndexAt:\n+         {\n+         uintptrj_t *objectPointerReference = std::get<0>(client->getRecvData<uintptrj_t*>());\n+         client->write(response, knot->getExistingIndexAt(objectPointerReference));\n+         }\n+         break;\n+      case MessageType::KnownObjectTable_symbolReferenceTableCreateKnownObject:\n+         {\n+         auto recv = client->getRecvData<void *, TR_ResolvedMethod *, int32_t>();\n+         void *dataAddress = std::get<0>(recv);\n+         TR_ResolvedMethod *owningMethod = std::get<1>(recv);\n+         int32_t cpIndex = std::get<2>(recv);\n+\n+         bool createKnownObject = false;\n+         TR::KnownObjectTable::Index knotIndex = TR::KnownObjectTable::UNKNOWN;\n+         uintptrj_t *objectPointerReference = NULL;\n+\n+         TR::VMAccessCriticalSection getObjectReferenceLocation(fe);\n+         if (*((uintptrj_t*)dataAddress) != 0)\n+            {\n+            TR_OpaqueClassBlock *declaringClass = owningMethod->getDeclaringClassFromFieldOrStatic(comp, cpIndex);\n+            if (declaringClass && fe->isClassInitialized(declaringClass))\n+               {\n+               static const char *foldVarHandle = feGetEnv(\"TR_FoldVarHandleWithoutFear\");\n+               int32_t clazzNameLength = 0;\n+               char *clazzName = fe->getClassNameChars(declaringClass, clazzNameLength);\n+               bool createKnownObject = false;\n+\n+               if (J9::TransformUtil::foldFinalFieldsIn(declaringClass, clazzName, clazzNameLength, true, comp))\n+                  {\n+                  createKnownObject = true;\n+                  }\n+               else if (foldVarHandle\n+                        && (clazzNameLength != 16 || strncmp(clazzName, \"java/lang/System\", 16)))\n+                  {\n+                  TR_OpaqueClassBlock *varHandleClass =  fe->getSystemClassFromClassName(\"java/lang/invoke/VarHandle\", 26);\n+                  TR_OpaqueClassBlock *objectClass = TR::Compiler->cls.objectClass(comp, *((uintptrj_t*)dataAddress));\n+\n+                  if (varHandleClass != NULL\n+                      && objectClass != NULL\n+                      && fe->isInstanceOf(objectClass, varHandleClass, true, true))\n+                     {\n+                     createKnownObject = true;\n+                     }\n+                  }\n+\n+               if (createKnownObject)\n+                  {\n+                  knotIndex = knot->getIndexAt((uintptrj_t*)dataAddress);\n+                  objectPointerReference = knot->getPointerLocation(knotIndex);\n+                  }\n+               }\n+            }\n+         client->write(response, knotIndex, objectPointerReference);\n+         }\n+         break;\n+      case MessageType::KnownObjectTable_mutableCallSiteEpoch:\n+         {\n+         auto recv = client->getRecvData<uintptrj_t*, bool>();\n+         uintptrj_t* mcsReferenceLocation = std::get<0>(recv);\n+         bool knotEnabled = std::get<1>(recv);\n+\n+         uintptrj_t mcsObject = 0;\n+         TR::KnownObjectTable::Index knotIndex = TR::KnownObjectTable::UNKNOWN;\n+         uintptrj_t *objectPointerReference = NULL;\n+\n+         TR::VMAccessCriticalSection mutableCallSiteEpoch(fe);\n+         mcsObject = fe->getStaticReferenceFieldAtAddress((uintptrj_t)mcsReferenceLocation);\n+         if (mcsObject)\n+            {\n+            TR_J9VMBase *fej9 = (TR_J9VMBase *)(fe);\n+            uintptrj_t currentEpoch = fej9->getVolatileReferenceField(mcsObject, \"epoch\", \"Ljava/lang/invoke/MethodHandle;\");", "originalCommit": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4MzEzMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384683130", "bodyText": "If knot==NULL then this function does nothing. I would put the knot test first and only then execute\nTR_OpaqueClassBlock *mutableCallsiteClass = callee->classOfMethod();", "author": "mpirvu", "createdAt": "2020-02-26T18:32:47Z", "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -298,16 +336,36 @@ InterpreterEmulator::getReturnValueForInvokevirtual(TR_ResolvedMethod *callee)\n       TR::KnownObjectTable::Index resultIndex = TR::KnownObjectTable::UNKNOWN;\n       TR_OpaqueClassBlock *mutableCallsiteClass = callee->classOfMethod();\n       debugTrace(tracer(), \"java_lang_invoke_MutableCallSite_target receiver obj%d(*%p) mutableCallsiteClass %p\\n\", receiverIndex, knot->getPointerLocation(receiverIndex), mutableCallsiteClass);\n-      if (mutableCallsiteClass)\n+      if (mutableCallsiteClass && knot)", "originalCommit": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4Mzc0Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384683746", "bodyText": "Also, the critical section for VMAccess on line 334 is not needed.", "author": "mpirvu", "createdAt": "2020-02-26T18:33:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4MzEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY5NTY3Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384695672", "bodyText": "I would prefer the code in the non-jitserver block to be transformed in a similar way to the jitserver block. Otherwise people may have a hard time to understand why one is equivalent to the other.\n                  TR::KnownObjectTable::Index objectIndex = TR::KnownObjectTable::UNKNOWN\n                     {\n                     TR::VMAccessCriticalSection createSymRefWithKnownObject(comp->fej9());\n                     uintptrj_t jlClass = (uintptrj_t)J9VM_J9CLASS_TO_HEAPCLASS((J9Class*)baseObject->getSymbol()->castToStaticSymbol()->getStaticAddress());\n                     TR_ASSERT(jlClass, \"java/lang/Class reference from heap class must be non null\");\n                     objectIndex = knot->getIndexAt(&jlClass);\n                     }\n                  improvedSymRef = comp->getSymRefTab()->findOrCreateSymRefWithKnownObject(node->getSymbolReference(), objectIndex);", "author": "mpirvu", "createdAt": "2020-02-26T18:55:53Z", "path": "runtime/compiler/optimizer/J9TransformUtil.cpp", "diffHunk": "@@ -526,8 +526,30 @@ J9::TransformUtil::transformIndirectLoad(TR::Compilation *comp, TR::Node *node)\n                && baseObject->getOpCodeValue() == TR::loadaddr\n                && !baseObject->getSymbolReference()->isUnresolved())\n                {\n-               TR::SymbolReference *improvedSymRef;\n+               TR::SymbolReference *improvedSymRef = node->getSymbolReference();\n+#if defined(JITSERVER_SUPPORT)\n+               if (comp->isOutOfProcessCompilation())\n+                  {\n+                  TR::KnownObjectTable *knot = comp->getOrCreateKnownObjectTable();\n+                  if (knot)\n+                     {\n+                     auto stream = TR::CompilationInfo::getStream();\n+                     stream->write(JITServer::MessageType::KnownObjectTable_createSymRefWithKnownObject,\n+                           baseObject->getSymbol()->castToStaticSymbol()->getStaticAddress());\n+\n+                     auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t*>();\n+                     TR::KnownObjectTable::Index knotIndex = std::get<0>(recv);\n+                     uintptrj_t *objectPointerReference = std::get<1>(recv);\n \n+                     if (knotIndex != TR::KnownObjectTable::UNKNOWN)\n+                        {\n+                        knot->updateKnownObjectTableAtServer(knotIndex, objectPointerReference);\n+                        }\n+                     improvedSymRef = comp->getSymRefTab()->findOrCreateSymRefWithKnownObject(node->getSymbolReference(), knotIndex);\n+                     }\n+                  }\n+               else\n+#endif /* defined(JITSERVER_SUPPORT) */\n                   {\n                   TR::VMAccessCriticalSection createSymRefWithKnownObject(comp->fej9());\n                   uintptrj_t jlClass = (uintptrj_t)J9VM_J9CLASS_TO_HEAPCLASS((J9Class*)baseObject->getSymbol()->castToStaticSymbol()->getStaticAddress());", "originalCommit": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwMzM1Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384703352", "bodyText": "targetObjectReference is not needed", "author": "mpirvu", "createdAt": "2020-02-26T19:10:05Z", "path": "runtime/compiler/optimizer/J9TransformUtil.cpp", "diffHunk": "@@ -842,9 +864,34 @@ J9::TransformUtil::transformIndirectLoad(TR::Compilation *comp, TR::Node *node)\n                }\n             else if (symrefIsImprovable)\n                {\n-               uintptrj_t targetObjectReference;\n-               TR::SymbolReference *improvedSymRef;\n+               uintptrj_t targetObjectReference = 0;\n+               TR::SymbolReference *improvedSymRef = node->getSymbolReference();\n \n+#if defined(JITSERVER_SUPPORT)\n+               if (comp->isOutOfProcessCompilation())\n+                  {\n+                  TR::KnownObjectTable *knot = comp->getOrCreateKnownObjectTable();\n+                  bool knotEnabled = (knot != NULL);\n+                  auto stream = TR::CompilationInfo::getStream();\n+                  stream->write(JITServer::MessageType::KnownObjectTable_getReferenceField,\n+                        baseObject->getSymbol()->isStatic(), baseObjectRefLocation, fieldOffset, knotEnabled);\n+\n+                  auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t*, uintptrj_t>();\n+                  TR::KnownObjectTable::Index knotIndex = std::get<0>(recv);\n+                  uintptrj_t *objectPointerReference = std::get<1>(recv);\n+                  targetObjectReference = std::get<2>(recv);", "originalCommit": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxMTQwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384811406", "bodyText": "targetObjectReference is used afterwards at https://github.com/eclipse/openj9/blob/fd96afe5f58b9125d812dcb45ae85f7376e0b7d3/runtime/compiler/optimizer/J9TransformUtil.cpp#L862-L872.", "author": "a7ehuo", "createdAt": "2020-02-26T22:39:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwMzM1Mg=="}], "type": "inlineReview"}, {"oid": "ce013bce0da4bf1bcb24a394ae2b5c8c33f0de0e", "url": "https://github.com/eclipse-openj9/openj9/commit/ce013bce0da4bf1bcb24a394ae2b5c8c33f0de0e", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-27T20:21:46Z", "type": "forcePushed"}, {"oid": "5d8add53116fe77ff1a1eb676e026c38eb0ce80f", "url": "https://github.com/eclipse-openj9/openj9/commit/5d8add53116fe77ff1a1eb676e026c38eb0ce80f", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-02-28T19:42:00Z", "type": "forcePushed"}, {"oid": "5bf9611bd5370f1443864cb2099f13e68e687029", "url": "https://github.com/eclipse-openj9/openj9/commit/5bf9611bd5370f1443864cb2099f13e68e687029", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-03-03T15:22:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU4MzY4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r388583683", "bodyText": "I don't think it's safe for the server to ever execute this code because it deals with objects. Any object pointer may have received from the client could become stale because the client cannot hold VMaccess while sending a message to the server.\nIt may be the case that after all the transformations we actually don't call getIndex() from the server, but it's better to put a ASSERT_FATAL here.", "author": "mpirvu", "createdAt": "2020-03-05T21:44:09Z", "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,176 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(J9VM_OPT_JITSERVER)\n+   if (self()->comp()->isOutOfProcessCompilation())", "originalCommit": "5bf9611bd5370f1443864cb2099f13e68e687029", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyNDE2OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r388624169", "bodyText": "I don't think it's safe for the server to ever execute this code because it deals with objects. Any object pointer may have received from the client could become stale because the client cannot hold VMaccess while sending a message to the server.\n\nOn the client side, client->write() is inside the scope of the critical section. Meanwhile, all the following methods would require access to the object pointer.  Would the other methods be a concern as well?\n\ngetIndex()\ngetIndexAt()\ngetExistingIndexAt()\ngetPointer()\n\n\nIt may be the case that after all the transformations we actually don't call getIndex() from the server, but it's better to put a ASSERT_FATAL here.\n\nThe sanity.functional test shows that KnownObjectTable_getIndexAt messages are received often on the client side. So far no KnownObjectTable_getIndex messages exchanged while running sanity.functional.\nAn example from StringPeepholeTest_0\nJITServer Message Type Statistics:\nType# #called TypeName\n...\n...\n#0901     149 IProfiler_searchForMethodSample\n#1201      75 KnownObjectTable_getIndexAt\n#1204     241 KnownObjectTable_symbolReferenceTableCreateKnownObject\n\nStringPeepholeTest_0_PASSED", "author": "a7ehuo", "createdAt": "2020-03-05T23:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU4MzY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY4NDAyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r388684021", "bodyText": "On the client side, client->write() is inside the scope of the critical section.\n\nI missed that. If possible we have to take it out, though I am afraid we may have many transgressions like that. Fortunately, the writes are more forgiving because they block only until the kernel receives the message. In some corner cases the kernel may have a big backlog and therefore the wrote could block.", "author": "mpirvu", "createdAt": "2020-03-06T02:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU4MzY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY4NzU5OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r388687599", "bodyText": "getIndexAt() and getExistingIndexAt() are safe because they don't manipulate objects.\ngetIndex() uses an object, which may have been moved.\ngetPointer() returns an object and it's safe to use, but the usage of the returned object is not safe.", "author": "mpirvu", "createdAt": "2020-03-06T02:47:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU4MzY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY5MTczMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r388691733", "bodyText": "I don't see getIndex called by the server in openj9. I do see some calls in OMR in VPHandlers.cpp which are bypassed. You also don't see any messages for getIndex so we may be good, but we need that ASSERT in getIndex to make sure.", "author": "mpirvu", "createdAt": "2020-03-06T03:05:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU4MzY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk5NjAxNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r388996014", "bodyText": "though I am afraid we may have many transgressions like that\n\nYeah, a quick search in handleServerMessage(), I noticed many message handlings that require access to VM have client->write() inside the scope of TR::VMAccessCriticalSection().\nFor this PR, I will take  client->write() out of the scope of the VM access critical section for the KOT related messages first.", "author": "a7ehuo", "createdAt": "2020-03-06T16:13:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU4MzY4Mw=="}], "type": "inlineReview"}, {"oid": "7e8397712a6f3cb8b1a6e905ab000c6ca2f3b979", "url": "https://github.com/eclipse-openj9/openj9/commit/7e8397712a6f3cb8b1a6e905ab000c6ca2f3b979", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-03-06T22:01:18Z", "type": "forcePushed"}, {"oid": "afb5fdc2fa71976a34cfe04a9c32f169c898c67e", "url": "https://github.com/eclipse-openj9/openj9/commit/afb5fdc2fa71976a34cfe04a9c32f169c898c67e", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-03-08T20:02:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY3MTIyMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r389671223", "bodyText": "This is used in a single place in KnownObjectTable::getPointer(Index index). Thus, is should be marked private.", "author": "mpirvu", "createdAt": "2020-03-09T13:35:23Z", "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,177 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(J9VM_OPT_JITSERVER)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      TR_ASSERT(false, \"It is not safe to call getIndex() at the server. The object pointer could have become stale at the client.\");\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndex, objectPointer);\n+      auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t *>();\n+\n+      TR::KnownObjectTable::Index index = std::get<0>(recv);\n+      uintptrj_t *objectReferenceLocation = std::get<1>(recv);\n+      TR_ASSERT_FATAL(index <= nextIndex, \"The KOT index %d at the client is greater than the KOT index %d at the server\", index, nextIndex);\n+\n+      if (index < nextIndex)\n+         {\n+         return index;\n+         }\n+      else\n+         {\n+         updateKnownObjectTableAtServer(index, objectReferenceLocation);\n+         }\n+      }\n+   else\n+#endif /* defined(J9VM_OPT_JITSERVER) */\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n+      TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n+\n+      // Search for existing matching entry\n+      //\n+      for (uint32_t i = 1; i < nextIndex; i++)\n+         if (*_references.element(i) == objectPointer)\n+            return i;\n+\n+      // No luck -- allocate a new one\n+      //\n+      J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n+      TR_ASSERT(thread, \"assertion failure\");\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+      }\n+\n    return nextIndex;\n    }\n \n \n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements)\n+   {\n+   TR::KnownObjectTable::Index index = self()->getIndex(objectPointer);\n+   if (isArrayWithConstantElements)\n+      {\n+      self()->addArrayWithConstantElements(index);\n+      }\n+   return index;\n+   }\n+\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+uintptrj_t\n+J9::KnownObjectTable::dereferenceObjectPointerReference(uintptrj_t *objectReferenceLocation)", "originalCommit": "afb5fdc2fa71976a34cfe04a9c32f169c898c67e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3MTY1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r389871650", "bodyText": "dereferenceObjectPointerReference()is used in JITClientCompilationThread.cpp. I think I should replace dereferenceObjectPointerReference() with direct messages I getPointer(). JITClientCompilationThread.cpp should be able to call getPointer() directly instead of dereferenceObjectPointerReference().", "author": "a7ehuo", "createdAt": "2020-03-09T18:12:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY3MTIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY3NTM5MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r389675390", "bodyText": "I would like an assert here that this method is not called at the server. We obtain an object pointer from the client, but it's of no use to the server, because by the time we get to use it it may have become stale. Right now the assert holds from my scanning of the code.", "author": "mpirvu", "createdAt": "2020-03-09T13:39:02Z", "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,177 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(J9VM_OPT_JITSERVER)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      TR_ASSERT(false, \"It is not safe to call getIndex() at the server. The object pointer could have become stale at the client.\");\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndex, objectPointer);\n+      auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t *>();\n+\n+      TR::KnownObjectTable::Index index = std::get<0>(recv);\n+      uintptrj_t *objectReferenceLocation = std::get<1>(recv);\n+      TR_ASSERT_FATAL(index <= nextIndex, \"The KOT index %d at the client is greater than the KOT index %d at the server\", index, nextIndex);\n+\n+      if (index < nextIndex)\n+         {\n+         return index;\n+         }\n+      else\n+         {\n+         updateKnownObjectTableAtServer(index, objectReferenceLocation);\n+         }\n+      }\n+   else\n+#endif /* defined(J9VM_OPT_JITSERVER) */\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n+      TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n+\n+      // Search for existing matching entry\n+      //\n+      for (uint32_t i = 1; i < nextIndex; i++)\n+         if (*_references.element(i) == objectPointer)\n+            return i;\n+\n+      // No luck -- allocate a new one\n+      //\n+      J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n+      TR_ASSERT(thread, \"assertion failure\");\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+      }\n+\n    return nextIndex;\n    }\n \n \n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements)\n+   {\n+   TR::KnownObjectTable::Index index = self()->getIndex(objectPointer);\n+   if (isArrayWithConstantElements)\n+      {\n+      self()->addArrayWithConstantElements(index);\n+      }\n+   return index;\n+   }\n+\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+uintptrj_t\n+J9::KnownObjectTable::dereferenceObjectPointerReference(uintptrj_t *objectReferenceLocation)\n+   {\n+   uintptrj_t objectPointer = 0;\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_dereferenceObjectPointerReference, objectReferenceLocation);\n+      objectPointer = std::get<0>(stream->read<uintptrj_t>());\n+      }\n+   else\n+      {\n+      TR::VMAccessCriticalSection dereferenceObjectPointerReferenceCriticalSection(self()->comp());\n+      objectPointer = *objectReferenceLocation;\n+      }\n+   return objectPointer;\n+   }\n+#endif /* defined(J9VM_OPT_JITSERVER) */\n+\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndexAt(uintptrj_t *objectReferenceLocation)\n+   {\n+   TR::KnownObjectTable::Index result = UNKNOWN;\n+#if defined(J9VM_OPT_JITSERVER)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndexAt, objectReferenceLocation);\n+      auto recv = stream->read<TR::KnownObjectTable::Index>();\n+      result = std::get<0>(stream->read<TR::KnownObjectTable::Index>());\n+\n+      updateKnownObjectTableAtServer(result, objectReferenceLocation);\n+      }\n+   else\n+#endif /* defined(J9VM_OPT_JITSERVER) */\n+      {\n+      TR::VMAccessCriticalSection getIndexAtCriticalSection(self()->comp());\n+      uintptrj_t objectPointer = *objectReferenceLocation; // Note: object references held as uintptrj_t must never be compressed refs\n+      result = self()->getIndex(objectPointer);\n+      }\n+   return result;\n+   }\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndexAt(uintptrj_t *objectReferenceLocation, bool isArrayWithConstantElements)\n+   {\n+   Index result = self()->getIndexAt(objectReferenceLocation);\n+   if (isArrayWithConstantElements)\n+      self()->addArrayWithConstantElements(result);\n+   return result;\n+   }\n+\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getExistingIndexAt(uintptrj_t *objectReferenceLocation)\n+   {\n+   TR::KnownObjectTable::Index result = UNKNOWN;\n+#if defined(J9VM_OPT_JITSERVER)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getExistingIndexAt, objectReferenceLocation);\n+      result = std::get<0>(stream->read<TR::KnownObjectTable::Index>());\n+      }\n+   else\n+#endif /* defined(J9VM_OPT_JITSERVER) */\n+      {\n+      TR::VMAccessCriticalSection getExistingIndexAtCriticalSection(self()->comp());\n+\n+      uintptrj_t objectPointer = *objectReferenceLocation;\n+      for (Index i = 0; i < self()->getEndIndex() && (result == UNKNOWN); i++)\n+         {\n+         if (self()->getPointer(i) == objectPointer)\n+            {\n+            result = i;\n+            break;\n+            }\n+         }\n+      }\n+   return result;\n+   }\n+\n+\n+uintptrj_t\n+J9::KnownObjectTable::getPointer(Index index)\n+   {\n+   if (self()->isNull(index))\n+      {\n+      return 0; // Assumes host and target representations of null match each other\n+      }\n+   else\n+      {\n+#if defined(J9VM_OPT_JITSERVER)\n+      if (self()->comp()->isOutOfProcessCompilation())", "originalCommit": "afb5fdc2fa71976a34cfe04a9c32f169c898c67e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "614ef58ead334a10d8ebfed3fc07e47551dbf538", "url": "https://github.com/eclipse-openj9/openj9/commit/614ef58ead334a10d8ebfed3fc07e47551dbf538", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-03-09T19:26:20Z", "type": "forcePushed"}, {"oid": "355e705e05cb13624cb8373ff3510e43065ab99b", "url": "https://github.com/eclipse-openj9/openj9/commit/355e705e05cb13624cb8373ff3510e43065ab99b", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-03-10T14:25:43Z", "type": "commit"}, {"oid": "355e705e05cb13624cb8373ff3510e43065ab99b", "url": "https://github.com/eclipse-openj9/openj9/commit/355e705e05cb13624cb8373ff3510e43065ab99b", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-03-10T14:25:43Z", "type": "forcePushed"}]}