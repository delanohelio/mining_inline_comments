{"pr_number": 11383, "pr_title": "Implement JIT support for flattened value type arrays", "pr_createdAt": "2020-12-07T16:47:17Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/11383", "timeline": [{"oid": "0843bc8479267e034aa4bd707a899cbdc411d328", "url": "https://github.com/eclipse-openj9/openj9/commit/0843bc8479267e034aa4bd707a899cbdc411d328", "message": "Implement JIT support for flattened value type arrays\n\nFor now, the implementation generates VM helpers calls for the\naaload and aastore operations.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>", "committedDate": "2020-12-07T16:45:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDUzMzYyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11383#discussion_r544533622", "bodyText": "How come we don't check if the array element is value type first and then if it's flattened before going down this path to call VM helper to load flattened array element?", "author": "a7ehuo", "createdAt": "2020-12-16T18:39:13Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6079,6 +6079,22 @@ TR_J9ByteCodeIlGenerator::loadFromCallSiteTable(int32_t callSiteIndex)\n void\n TR_J9ByteCodeIlGenerator::loadArrayElement(TR::DataType dataType, TR::ILOpCodes nodeop, bool checks)\n    {\n+   if (TR::Compiler->om.areValueTypesEnabled() && dataType == TR::Address)", "originalCommit": "0843bc8479267e034aa4bd707a899cbdc411d328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA5NTA5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11383#discussion_r545095092", "bodyText": "aaload and aastore don't use the constant pool, so the type of array elements is not known (at least, not without some dataflow analysis). The only thing that's known is that it's an array of some object type.", "author": "Leonardo2718", "createdAt": "2020-12-17T13:37:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDUzMzYyMg=="}], "type": "inlineReview"}]}