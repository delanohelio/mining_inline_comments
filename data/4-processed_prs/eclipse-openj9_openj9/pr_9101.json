{"pr_number": 9101, "pr_title": "ACMP support for value types", "pr_createdAt": "2020-04-02T21:56:00Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9101", "timeline": [{"oid": "2bfeea1926ad463949d312ad05f5ea7ba77c905a", "url": "https://github.com/eclipse-openj9/openj9/commit/2bfeea1926ad463949d312ad05f5ea7ba77c905a", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-02T22:08:19Z", "type": "forcePushed"}, {"oid": "c29c8eb59e188f69df10398a6a5c308ef9053577", "url": "https://github.com/eclipse-openj9/openj9/commit/c29c8eb59e188f69df10398a6a5c308ef9053577", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-02T22:12:24Z", "type": "forcePushed"}, {"oid": "aae350002b16a172b79f34d328fbe2ed506a6c7f", "url": "https://github.com/eclipse-openj9/openj9/commit/aae350002b16a172b79f34d328fbe2ed506a6c7f", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-02T22:14:02Z", "type": "forcePushed"}, {"oid": "8bb080fcdb95177748cc4ef7f5f25cee6b23d445", "url": "https://github.com/eclipse-openj9/openj9/commit/8bb080fcdb95177748cc4ef7f5f25cee6b23d445", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-02T22:30:25Z", "type": "forcePushed"}, {"oid": "59fb9009c79e0a8343675e6ce211653acd6ddd99", "url": "https://github.com/eclipse-openj9/openj9/commit/59fb9009c79e0a8343675e6ce211653acd6ddd99", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-02T22:33:32Z", "type": "forcePushed"}, {"oid": "613d0dafb9b37afeca058dee1153371e00934a84", "url": "https://github.com/eclipse-openj9/openj9/commit/613d0dafb9b37afeca058dee1153371e00934a84", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-02T22:48:27Z", "type": "forcePushed"}, {"oid": "d5f8a189e555df053eefeb8b917ba6165f28ee3b", "url": "https://github.com/eclipse-openj9/openj9/commit/d5f8a189e555df053eefeb8b917ba6165f28ee3b", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-02T23:13:35Z", "type": "forcePushed"}, {"oid": "4e901d5f50334651358ef511060aecf5718a179f", "url": "https://github.com/eclipse-openj9/openj9/commit/4e901d5f50334651358ef511060aecf5718a179f", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-02T23:14:56Z", "type": "forcePushed"}, {"oid": "e862b1f891a1785927447261d6180499f109c235", "url": "https://github.com/eclipse-openj9/openj9/commit/e862b1f891a1785927447261d6180499f109c235", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-02T23:18:35Z", "type": "forcePushed"}, {"oid": "6fdb1bff75bec8a2b011a8c036a63563cf541143", "url": "https://github.com/eclipse-openj9/openj9/commit/6fdb1bff75bec8a2b011a8c036a63563cf541143", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-02T23:19:31Z", "type": "forcePushed"}, {"oid": "0e8e475a2afeb73809fb90a24281594e8219cbcd", "url": "https://github.com/eclipse-openj9/openj9/commit/0e8e475a2afeb73809fb90a24281594e8219cbcd", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-02T23:20:54Z", "type": "forcePushed"}, {"oid": "d60f589493b43fc981ccc36dcf417c87a3c67669", "url": "https://github.com/eclipse-openj9/openj9/commit/d60f589493b43fc981ccc36dcf417c87a3c67669", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-02T23:23:03Z", "type": "forcePushed"}, {"oid": "2fd0f2aa635927654dd044371b9409a96c02eef7", "url": "https://github.com/eclipse-openj9/openj9/commit/2fd0f2aa635927654dd044371b9409a96c02eef7", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-02T23:24:07Z", "type": "forcePushed"}, {"oid": "ebd8989c7a07eafb914530bf971746ad50506973", "url": "https://github.com/eclipse-openj9/openj9/commit/ebd8989c7a07eafb914530bf971746ad50506973", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-02T23:32:07Z", "type": "forcePushed"}, {"oid": "42eaf65032dae42893b674b79ee6089c9d9a1d7e", "url": "https://github.com/eclipse-openj9/openj9/commit/42eaf65032dae42893b674b79ee6089c9d9a1d7e", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-02T23:38:11Z", "type": "forcePushed"}, {"oid": "469447ca915de76c7452972b23e684717ea8c470", "url": "https://github.com/eclipse-openj9/openj9/commit/469447ca915de76c7452972b23e684717ea8c470", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-02T23:39:48Z", "type": "forcePushed"}, {"oid": "404876f2c3ad5c40dda0a1d1c190d48dfa7ec4e6", "url": "https://github.com/eclipse-openj9/openj9/commit/404876f2c3ad5c40dda0a1d1c190d48dfa7ec4e6", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-02T23:46:22Z", "type": "forcePushed"}, {"oid": "51406e7cb0fdf8173f7fd5e33355bb017bbc12f3", "url": "https://github.com/eclipse-openj9/openj9/commit/51406e7cb0fdf8173f7fd5e33355bb017bbc12f3", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-02T23:53:01Z", "type": "forcePushed"}, {"oid": "be1d9222f38594ecf343207b91ecc54e84c4a5a7", "url": "https://github.com/eclipse-openj9/openj9/commit/be1d9222f38594ecf343207b91ecc54e84c4a5a7", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-03T00:01:47Z", "type": "forcePushed"}, {"oid": "f15ae23849affda60b5564777bfc78357081f768", "url": "https://github.com/eclipse-openj9/openj9/commit/f15ae23849affda60b5564777bfc78357081f768", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-03T00:06:30Z", "type": "forcePushed"}, {"oid": "ca7335718dd7f9f0243bf59e59cbd9e6789a9a68", "url": "https://github.com/eclipse-openj9/openj9/commit/ca7335718dd7f9f0243bf59e59cbd9e6789a9a68", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-03T16:16:01Z", "type": "forcePushed"}, {"oid": "8446e0cc070b1a839627bc1584850ea1333e593c", "url": "https://github.com/eclipse-openj9/openj9/commit/8446e0cc070b1a839627bc1584850ea1333e593c", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-03T20:51:55Z", "type": "forcePushed"}, {"oid": "0b60673ac93d4deaecb5d01927ee7e184b08f576", "url": "https://github.com/eclipse-openj9/openj9/commit/0b60673ac93d4deaecb5d01927ee7e184b08f576", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-03T21:47:35Z", "type": "forcePushed"}, {"oid": "e30ef42a7daf60e7f832dc6d6fa9de66822747ee", "url": "https://github.com/eclipse-openj9/openj9/commit/e30ef42a7daf60e7f832dc6d6fa9de66822747ee", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-03T21:51:18Z", "type": "forcePushed"}, {"oid": "dea4269c3836c73011ed3aeeaee0070baf65832e", "url": "https://github.com/eclipse-openj9/openj9/commit/dea4269c3836c73011ed3aeeaee0070baf65832e", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-03T21:55:33Z", "type": "forcePushed"}, {"oid": "ee52a6130a5339f2d69af5870af2df860180cdba", "url": "https://github.com/eclipse-openj9/openj9/commit/ee52a6130a5339f2d69af5870af2df860180cdba", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-03T21:57:30Z", "type": "forcePushed"}, {"oid": "e75de8a4f1b6da1fc5276376cb33cadf469a7ac0", "url": "https://github.com/eclipse-openj9/openj9/commit/e75de8a4f1b6da1fc5276376cb33cadf469a7ac0", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-07T12:55:40Z", "type": "forcePushed"}, {"oid": "c7ad4a22ce44d1f5b5358fe1e2431cef189b2440", "url": "https://github.com/eclipse-openj9/openj9/commit/c7ad4a22ce44d1f5b5358fe1e2431cef189b2440", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-07T12:57:39Z", "type": "forcePushed"}, {"oid": "6c8eceda6577f556ed9dae2b4079f6ed98d193c5", "url": "https://github.com/eclipse-openj9/openj9/commit/6c8eceda6577f556ed9dae2b4079f6ed98d193c5", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-07T13:04:44Z", "type": "forcePushed"}, {"oid": "0796272326cf611025d74ce2c072925f59086977", "url": "https://github.com/eclipse-openj9/openj9/commit/0796272326cf611025d74ce2c072925f59086977", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-07T13:06:19Z", "type": "forcePushed"}, {"oid": "cf4503a00fa4291e986ad5ebf6bc73d045e6815d", "url": "https://github.com/eclipse-openj9/openj9/commit/cf4503a00fa4291e986ad5ebf6bc73d045e6815d", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-07T13:34:50Z", "type": "forcePushed"}, {"oid": "bca72592f7dc8ed481509ae8dfad246c0962a37e", "url": "https://github.com/eclipse-openj9/openj9/commit/bca72592f7dc8ed481509ae8dfad246c0962a37e", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-07T13:46:53Z", "type": "forcePushed"}, {"oid": "3c95055e7c73648db7586bc173716ec100dd3c35", "url": "https://github.com/eclipse-openj9/openj9/commit/3c95055e7c73648db7586bc173716ec100dd3c35", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-07T14:02:06Z", "type": "forcePushed"}, {"oid": "bbeeac72fd4d72a084a8dba48a4b32d7f0402ba2", "url": "https://github.com/eclipse-openj9/openj9/commit/bbeeac72fd4d72a084a8dba48a4b32d7f0402ba2", "message": "ACMP support for value types\n\nThis commit adds the implementation to handle value types when the ACMP\nbytecode is used to compare object fields.\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-07T14:03:56Z", "type": "forcePushed"}, {"oid": "a3032e571a5de5308a3ed409cd167898fef5c834", "url": "https://github.com/eclipse-openj9/openj9/commit/a3032e571a5de5308a3ed409cd167898fef5c834", "message": "ACMP support for value types\n\nThis adds support for substitutability test in the acmp* bytecodes which\nis needed to support value types.\n\nOverview:\n-----------\n\nInstead of doing a reference comparison when the ifacmp* bytecodes are\nexecuted with valueType operands, as is the case with reference type\ntoday, valueTypes will perform a structural comparison instead\n(substitutability test). This overload of the ifacmp* bytecodes is\nrequired because valueTypes subclass java.lang.Object and use a*\nbytecodes. It is possible for the static type of a valueType to be a\nreference type (see example below) but the reflexive properties of the\n`==` must still be maintained.\n\nObject p = (Object) Point.makePoint(1, 2);\nif (p == p) //must be true\n\nThe original acmp (legacy acmp) operation in the ifacmp* bytecodes\nperforms a simple ref comparison, lhs == rhs. This must be updated to\ncheck if both operands are valueTypes, and\u00a0 if they are of the same\ntype. If that is the case a structural comparison must be performed.\nExample below:\n\n```\nacmpSub(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (lhs == rhs) return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs == NULL) || (rhs == NULL)) return false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs.class == rhs.class) && (lhs.isValue)) return\nisSubstitutable(lhs, rhs)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return false\n}\n```\n\nThe structural comparison must iterate through each field and perform an\nequality comparison. If the field is byte, short, char, int the\ncomparison in icmp_eq is performed. If the field is a long the\ncomparison in lcmp is performed. If the field is a float an icmp\ncomparison of Float.floatToIntBits of both values is performed. If the\nfield is a double an lcmp comparison of Double.doubleToLongBits of both\nvalues is performed. Note: this behaviour differs from the float f =\n...; f == f case which performs a fcmp* operation. If the field is a\nreference type that is java.lang.Object or an Interface or any type that\nmay contain a valueType (i.e InlineObject, Object, restricted-abstract\nclasses or interfaces) or if the field is a value type and both values\nare not NULL a recursive acmpSub is performed. For all other types the\nlegacy acmp is performed. Example is below:\n\n```\nisSubstitutable(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each primitive perform primitive comparison (icmp, lcmp,\nFloat.floatToIntBits then icmp, )\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each ref that is j.l.Object, interface, a valueType and\nboth operands are not NULL perform acmSub (recursive)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for all other refs perform legacy acmp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return result\n}\n```\n\nThere are cases where the JVM may optimize the individual field\ncomparisons of the substitutability test and simply perform a memcmp\nover the range of the operands. This optimization is possible in cases\nwhere the substitutability test will not require recursion and there are\nno floating point types.\nThe acmpSub will check to see if the fast comparison flag exists, if so\nit will perform a memcmp with both operands that does something like\nmemcmp(lhs, rhs, lhs.size).\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-07T14:48:16Z", "type": "forcePushed"}, {"oid": "58ec5fd4af99f0c2f419d7afa3d951ec1a8fe35e", "url": "https://github.com/eclipse-openj9/openj9/commit/58ec5fd4af99f0c2f419d7afa3d951ec1a8fe35e", "message": "ACMP support for value types\n\nThis adds support for substitutability test in the acmp* bytecodes which\nis needed to support value types.\n\nOverview:\n-----------\n\nInstead of doing a reference comparison when the ifacmp* bytecodes are\nexecuted with valueType operands, as is the case with reference type\ntoday, valueTypes will perform a structural comparison instead\n(substitutability test). This overload of the ifacmp* bytecodes is\nrequired because valueTypes subclass java.lang.Object and use a*\nbytecodes. It is possible for the static type of a valueType to be a\nreference type (see example below) but the reflexive properties of the\n`==` must still be maintained.\n\nObject p = (Object) Point.makePoint(1, 2);\nif (p == p) //must be true\n\nThe original acmp (legacy acmp) operation in the ifacmp* bytecodes\nperforms a simple ref comparison, lhs == rhs. This must be updated to\ncheck if both operands are valueTypes, and\u00a0 if they are of the same\ntype. If that is the case a structural comparison must be performed.\nExample below:\n\n```\nacmpSub(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (lhs == rhs) return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs == NULL) || (rhs == NULL)) return false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs.class == rhs.class) && (lhs.isValue)) return\nisSubstitutable(lhs, rhs)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return false\n}\n```\n\nThe structural comparison must iterate through each field and perform an\nequality comparison. If the field is byte, short, char, int the\ncomparison in icmp_eq is performed. If the field is a long the\ncomparison in lcmp is performed. If the field is a float an icmp\ncomparison of Float.floatToIntBits of both values is performed. If the\nfield is a double an lcmp comparison of Double.doubleToLongBits of both\nvalues is performed. Note: this behaviour differs from the float f =\n...; f == f case which performs a fcmp* operation. If the field is a\nreference type that is java.lang.Object or an Interface or any type that\nmay contain a valueType (i.e InlineObject, Object, restricted-abstract\nclasses or interfaces) or if the field is a value type and both values\nare not NULL a recursive acmpSub is performed. For all other types the\nlegacy acmp is performed. Example is below:\n\n```\nisSubstitutable(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each primitive perform primitive comparison (icmp, lcmp,\nFloat.floatToIntBits then icmp, )\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each ref that is j.l.Object, interface, a valueType and\nboth operands are not NULL perform acmSub (recursive)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for all other refs perform legacy acmp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return result\n}\n```\n\nThere are cases where the JVM may optimize the individual field\ncomparisons of the substitutability test and simply perform a memcmp\nover the range of the operands. This optimization is possible in cases\nwhere the substitutability test will not require recursion and there are\nno floating point types.\nThe acmpSub will check to see if the fast comparison flag exists, if so\nit will perform a memcmp with both operands that does something like\nmemcmp(lhs, rhs, lhs.size).\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-07T14:50:44Z", "type": "forcePushed"}, {"oid": "84f376789b4606a509ed10071523d226175833a1", "url": "https://github.com/eclipse-openj9/openj9/commit/84f376789b4606a509ed10071523d226175833a1", "message": "ACMP support for value types\n\nThis adds support for substitutability test in the acmp* bytecodes which\nis needed to support value types.\n\nOverview:\n-----------\n\nInstead of doing a reference comparison when the ifacmp* bytecodes are\nexecuted with valueType operands, as is the case with reference type\ntoday, valueTypes will perform a structural comparison instead\n(substitutability test). This overload of the ifacmp* bytecodes is\nrequired because valueTypes subclass java.lang.Object and use a*\nbytecodes. It is possible for the static type of a valueType to be a\nreference type (see example below) but the reflexive properties of the\n`==` must still be maintained.\n\nObject p = (Object) Point.makePoint(1, 2);\nif (p == p) //must be true\n\nThe original acmp (legacy acmp) operation in the ifacmp* bytecodes\nperforms a simple ref comparison, lhs == rhs. This must be updated to\ncheck if both operands are valueTypes, and\u00a0 if they are of the same\ntype. If that is the case a structural comparison must be performed.\nExample below:\n\n```\nacmpSub(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (lhs == rhs) return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs == NULL) || (rhs == NULL)) return false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs.class == rhs.class) && (lhs.isValue)) return\nisSubstitutable(lhs, rhs)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return false\n}\n```\n\nThe structural comparison must iterate through each field and perform an\nequality comparison. If the field is byte, short, char, int the\ncomparison in icmp_eq is performed. If the field is a long the\ncomparison in lcmp is performed. If the field is a float an icmp\ncomparison of Float.floatToIntBits of both values is performed. If the\nfield is a double an lcmp comparison of Double.doubleToLongBits of both\nvalues is performed. Note: this behaviour differs from the float f =\n...; f == f case which performs a fcmp* operation. If the field is a\nreference type that is java.lang.Object or an Interface or any type that\nmay contain a valueType (i.e InlineObject, Object, restricted-abstract\nclasses or interfaces) or if the field is a value type and both values\nare not NULL a recursive acmpSub is performed. For all other types the\nlegacy acmp is performed. Example is below:\n\n```\nisSubstitutable(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each primitive perform primitive comparison (icmp, lcmp,\nFloat.floatToIntBits then icmp, )\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each ref that is j.l.Object, interface, a valueType and\nboth operands are not NULL perform acmSub (recursive)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for all other refs perform legacy acmp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return result\n}\n```\n\nThere are cases where the JVM may optimize the individual field\ncomparisons of the substitutability test and simply perform a memcmp\nover the range of the operands. This optimization is possible in cases\nwhere the substitutability test will not require recursion and there are\nno floating point types.\nThe acmpSub will check to see if the fast comparison flag exists, if so\nit will perform a memcmp with both operands that does something like\nmemcmp(lhs, rhs, lhs.size).\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-07T14:51:46Z", "type": "forcePushed"}, {"oid": "2f24c581e5c775a81a550967f7209e3c40dd500e", "url": "https://github.com/eclipse-openj9/openj9/commit/2f24c581e5c775a81a550967f7209e3c40dd500e", "message": "ACMP support for value types\n\nThis adds support for substitutability test in the acmp* bytecodes which\nis needed to support value types.\n\nOverview:\n-----------\n\nInstead of doing a reference comparison when the ifacmp* bytecodes are\nexecuted with valueType operands, as is the case with reference type\ntoday, valueTypes will perform a structural comparison instead\n(substitutability test). This overload of the ifacmp* bytecodes is\nrequired because valueTypes subclass java.lang.Object and use a*\nbytecodes. It is possible for the static type of a valueType to be a\nreference type (see example below) but the reflexive properties of the\n`==` must still be maintained.\n\nObject p = (Object) Point.makePoint(1, 2);\nif (p == p) //must be true\n\nThe original acmp (legacy acmp) operation in the ifacmp* bytecodes\nperforms a simple ref comparison, lhs == rhs. This must be updated to\ncheck if both operands are valueTypes, and\u00a0 if they are of the same\ntype. If that is the case a structural comparison must be performed.\nExample below:\n\n```\nacmpSub(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (lhs == rhs) return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs == NULL) || (rhs == NULL)) return false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs.class == rhs.class) && (lhs.isValue)) return\nisSubstitutable(lhs, rhs)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return false\n}\n```\n\nThe structural comparison must iterate through each field and perform an\nequality comparison. If the field is byte, short, char, int the\ncomparison in icmp_eq is performed. If the field is a long the\ncomparison in lcmp is performed. If the field is a float an icmp\ncomparison of Float.floatToIntBits of both values is performed. If the\nfield is a double an lcmp comparison of Double.doubleToLongBits of both\nvalues is performed. Note: this behaviour differs from the float f =\n...; f == f case which performs a fcmp* operation. If the field is a\nreference type that is java.lang.Object or an Interface or any type that\nmay contain a valueType (i.e InlineObject, Object, restricted-abstract\nclasses or interfaces) or if the field is a value type and both values\nare not NULL a recursive acmpSub is performed. For all other types the\nlegacy acmp is performed. Example is below:\n\n```\nisSubstitutable(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each primitive perform primitive comparison (icmp, lcmp,\nFloat.floatToIntBits then icmp, )\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each ref that is j.l.Object, interface, a valueType and\nboth operands are not NULL perform acmSub (recursive)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for all other refs perform legacy acmp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return result\n}\n```\n\nThere are cases where the JVM may optimize the individual field\ncomparisons of the substitutability test and simply perform a memcmp\nover the range of the operands. This optimization is possible in cases\nwhere the substitutability test will not require recursion and there are\nno floating point types.\nThe acmpSub will check to see if the fast comparison flag exists, if so\nit will perform a memcmp with both operands that does something like\nmemcmp(lhs, rhs, lhs.size).\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-07T14:54:44Z", "type": "forcePushed"}, {"oid": "c63ce0546023b7f3ba93db9be25f7a24b8f6ecda", "url": "https://github.com/eclipse-openj9/openj9/commit/c63ce0546023b7f3ba93db9be25f7a24b8f6ecda", "message": "ACMP support for value types\n\nThis adds support for substitutability test in the acmp* bytecodes which\nis needed to support value types.\n\nOverview:\n-----------\n\nInstead of doing a reference comparison when the ifacmp* bytecodes are\nexecuted with valueType operands, as is the case with reference type\ntoday, valueTypes will perform a structural comparison instead\n(substitutability test). This overload of the ifacmp* bytecodes is\nrequired because valueTypes subclass java.lang.Object and use a*\nbytecodes. It is possible for the static type of a valueType to be a\nreference type (see example below) but the reflexive properties of the\n`==` must still be maintained.\n\nObject p = (Object) Point.makePoint(1, 2);\nif (p == p) //must be true\n\nThe original acmp (legacy acmp) operation in the ifacmp* bytecodes\nperforms a simple ref comparison, lhs == rhs. This must be updated to\ncheck if both operands are valueTypes, and\u00a0 if they are of the same\ntype. If that is the case a structural comparison must be performed.\nExample below:\n\n```\nacmpSub(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (lhs == rhs) return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs == NULL) || (rhs == NULL)) return false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs.class == rhs.class) && (lhs.isValue)) return\nisSubstitutable(lhs, rhs)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return false\n}\n```\n\nThe structural comparison must iterate through each field and perform an\nequality comparison. If the field is byte, short, char, int the\ncomparison in icmp_eq is performed. If the field is a long the\ncomparison in lcmp is performed. If the field is a float an icmp\ncomparison of Float.floatToIntBits of both values is performed. If the\nfield is a double an lcmp comparison of Double.doubleToLongBits of both\nvalues is performed. Note: this behaviour differs from the float f =\n...; f == f case which performs a fcmp* operation. If the field is a\nreference type that is java.lang.Object or an Interface or any type that\nmay contain a valueType (i.e InlineObject, Object, restricted-abstract\nclasses or interfaces) or if the field is a value type and both values\nare not NULL a recursive acmpSub is performed. For all other types the\nlegacy acmp is performed. Example is below:\n\n```\nisSubstitutable(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each primitive perform primitive comparison (icmp, lcmp,\nFloat.floatToIntBits then icmp, )\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each ref that is j.l.Object, interface, a valueType and\nboth operands are not NULL perform acmSub (recursive)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for all other refs perform legacy acmp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return result\n}\n```\n\nThere are cases where the JVM may optimize the individual field\ncomparisons of the substitutability test and simply perform a memcmp\nover the range of the operands. This optimization is possible in cases\nwhere the substitutability test will not require recursion and there are\nno floating point types.\nThe acmpSub will check to see if the fast comparison flag exists, if so\nit will perform a memcmp with both operands that does something like\nmemcmp(lhs, rhs, lhs.size).\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-07T15:05:13Z", "type": "forcePushed"}, {"oid": "b401f1e99b8c661070eeb2faada2bcb5534239ee", "url": "https://github.com/eclipse-openj9/openj9/commit/b401f1e99b8c661070eeb2faada2bcb5534239ee", "message": "ACMP support for value types\n\nThis adds support for substitutability test in the acmp* bytecodes which\nis needed to support value types.\n\nOverview:\n-----------\n\nInstead of doing a reference comparison when the ifacmp* bytecodes are\nexecuted with valueType operands, as is the case with reference type\ntoday, valueTypes will perform a structural comparison instead\n(substitutability test). This overload of the ifacmp* bytecodes is\nrequired because valueTypes subclass java.lang.Object and use a*\nbytecodes. It is possible for the static type of a valueType to be a\nreference type (see example below) but the reflexive properties of the\n`==` must still be maintained.\n\nObject p = (Object) Point.makePoint(1, 2);\nif (p == p) //must be true\n\nThe original acmp (legacy acmp) operation in the ifacmp* bytecodes\nperforms a simple ref comparison, lhs == rhs. This must be updated to\ncheck if both operands are valueTypes, and\u00a0 if they are of the same\ntype. If that is the case a structural comparison must be performed.\nExample below:\n\n```\nacmpSub(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (lhs == rhs) return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs == NULL) || (rhs == NULL)) return false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs.class == rhs.class) && (lhs.isValue)) return\nisSubstitutable(lhs, rhs)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return false\n}\n```\n\nThe structural comparison must iterate through each field and perform an\nequality comparison. If the field is byte, short, char, int the\ncomparison in icmp_eq is performed. If the field is a long the\ncomparison in lcmp is performed. If the field is a float an icmp\ncomparison of Float.floatToIntBits of both values is performed. If the\nfield is a double an lcmp comparison of Double.doubleToLongBits of both\nvalues is performed. Note: this behaviour differs from the float f =\n...; f == f case which performs a fcmp* operation. If the field is a\nreference type that is java.lang.Object or an Interface or any type that\nmay contain a valueType (i.e InlineObject, Object, restricted-abstract\nclasses or interfaces) or if the field is a value type and both values\nare not NULL a recursive acmpSub is performed. For all other types the\nlegacy acmp is performed. Example is below:\n\n```\nisSubstitutable(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each primitive perform primitive comparison (icmp, lcmp,\nFloat.floatToIntBits then icmp, )\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each ref that is j.l.Object, interface, a valueType and\nboth operands are not NULL perform acmSub (recursive)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for all other refs perform legacy acmp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return result\n}\n```\n\nThere are cases where the JVM may optimize the individual field\ncomparisons of the substitutability test and simply perform a memcmp\nover the range of the operands. This optimization is possible in cases\nwhere the substitutability test will not require recursion and there are\nno floating point types.\nThe acmpSub will check to see if the fast comparison flag exists, if so\nit will perform a memcmp with both operands that does something like\nmemcmp(lhs, rhs, lhs.size).\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-07T15:09:09Z", "type": "forcePushed"}, {"oid": "6fe8415b19e52fea17ede42ff9f5fe23cba39407", "url": "https://github.com/eclipse-openj9/openj9/commit/6fe8415b19e52fea17ede42ff9f5fe23cba39407", "message": "ACMP support for value types\n\nThis adds support for substitutability test in the acmp* bytecodes which\nis needed to support value types.\n\nOverview:\n-----------\n\nInstead of doing a reference comparison when the ifacmp* bytecodes are\nexecuted with valueType operands, as is the case with reference type\ntoday, valueTypes will perform a structural comparison instead\n(substitutability test). This overload of the ifacmp* bytecodes is\nrequired because valueTypes subclass java.lang.Object and use a*\nbytecodes. It is possible for the static type of a valueType to be a\nreference type (see example below) but the reflexive properties of the\n`==` must still be maintained.\n\nObject p = (Object) Point.makePoint(1, 2);\nif (p == p) //must be true\n\nThe original acmp (legacy acmp) operation in the ifacmp* bytecodes\nperforms a simple ref comparison, lhs == rhs. This must be updated to\ncheck if both operands are valueTypes, and\u00a0 if they are of the same\ntype. If that is the case a structural comparison must be performed.\nExample below:\n\n```\nacmpSub(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (lhs == rhs) return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs == NULL) || (rhs == NULL)) return false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs.class == rhs.class) && (lhs.isValue)) return\nisSubstitutable(lhs, rhs)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return false\n}\n```\n\nThe structural comparison must iterate through each field and perform an\nequality comparison. If the field is byte, short, char, int the\ncomparison in icmp_eq is performed. If the field is a long the\ncomparison in lcmp is performed. If the field is a float an icmp\ncomparison of Float.floatToIntBits of both values is performed. If the\nfield is a double an lcmp comparison of Double.doubleToLongBits of both\nvalues is performed. Note: this behaviour differs from the float f =\n...; f == f case which performs a fcmp* operation. If the field is a\nreference type that is java.lang.Object or an Interface or any type that\nmay contain a valueType (i.e InlineObject, Object, restricted-abstract\nclasses or interfaces) or if the field is a value type and both values\nare not NULL a recursive acmpSub is performed. For all other types the\nlegacy acmp is performed. Example is below:\n\n```\nisSubstitutable(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each primitive perform primitive comparison (icmp, lcmp,\nFloat.floatToIntBits then icmp, )\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each ref that is j.l.Object, interface, a valueType and\nboth operands are not NULL perform acmSub (recursive)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for all other refs perform legacy acmp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return result\n}\n```\n\nThere are cases where the JVM may optimize the individual field\ncomparisons of the substitutability test and simply perform a memcmp\nover the range of the operands. This optimization is possible in cases\nwhere the substitutability test will not require recursion and there are\nno floating point types.\nThe acmpSub will check to see if the fast comparison flag exists, if so\nit will perform a memcmp with both operands that does something like\nmemcmp(lhs, rhs, lhs.size).\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-07T15:12:54Z", "type": "forcePushed"}, {"oid": "240f07a9003d8749ca48625c5b7328461e3bcca2", "url": "https://github.com/eclipse-openj9/openj9/commit/240f07a9003d8749ca48625c5b7328461e3bcca2", "message": "ACMP support for value types\n\nThis adds support for substitutability test in the acmp* bytecodes which\nis needed to support value types.\n\nOverview:\n-----------\n\nInstead of doing a reference comparison when the ifacmp* bytecodes are\nexecuted with valueType operands, as is the case with reference type\ntoday, valueTypes will perform a structural comparison instead\n(substitutability test). This overload of the ifacmp* bytecodes is\nrequired because valueTypes subclass java.lang.Object and use a*\nbytecodes. It is possible for the static type of a valueType to be a\nreference type (see example below) but the reflexive properties of the\n`==` must still be maintained.\n\nObject p = (Object) Point.makePoint(1, 2);\nif (p == p) //must be true\n\nThe original acmp (legacy acmp) operation in the ifacmp* bytecodes\nperforms a simple ref comparison, lhs == rhs. This must be updated to\ncheck if both operands are valueTypes, and\u00a0 if they are of the same\ntype. If that is the case a structural comparison must be performed.\nExample below:\n\n```\nacmpSub(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (lhs == rhs) return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs == NULL) || (rhs == NULL)) return false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs.class == rhs.class) && (lhs.isValue)) return\nisSubstitutable(lhs, rhs)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return false\n}\n```\n\nThe structural comparison must iterate through each field and perform an\nequality comparison. If the field is byte, short, char, int the\ncomparison in icmp_eq is performed. If the field is a long the\ncomparison in lcmp is performed. If the field is a float an icmp\ncomparison of Float.floatToIntBits of both values is performed. If the\nfield is a double an lcmp comparison of Double.doubleToLongBits of both\nvalues is performed. Note: this behaviour differs from the float f =\n...; f == f case which performs a fcmp* operation. If the field is a\nreference type that is java.lang.Object or an Interface or any type that\nmay contain a valueType (i.e InlineObject, Object, restricted-abstract\nclasses or interfaces) or if the field is a value type and both values\nare not NULL a recursive acmpSub is performed. For all other types the\nlegacy acmp is performed. Example is below:\n\n```\nisSubstitutable(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each primitive perform primitive comparison (icmp, lcmp,\nFloat.floatToIntBits then icmp, )\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each ref that is j.l.Object, interface, a valueType and\nboth operands are not NULL perform acmSub (recursive)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for all other refs perform legacy acmp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return result\n}\n```\n\nThere are cases where the JVM may optimize the individual field\ncomparisons of the substitutability test and simply perform a memcmp\nover the range of the operands. This optimization is possible in cases\nwhere the substitutability test will not require recursion and there are\nno floating point types.\nThe acmpSub will check to see if the fast comparison flag exists, if so\nit will perform a memcmp with both operands that does something like\nmemcmp(lhs, rhs, lhs.size).\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-07T18:51:07Z", "type": "forcePushed"}, {"oid": "d1ae1107bfb3bcd9de3cb971fefd625e622e341f", "url": "https://github.com/eclipse-openj9/openj9/commit/d1ae1107bfb3bcd9de3cb971fefd625e622e341f", "message": "ACMP support for value types\n\nThis adds support for substitutability test in the acmp* bytecodes which\nis needed to support value types.\n\nOverview:\n-----------\n\nInstead of doing a reference comparison when the ifacmp* bytecodes are\nexecuted with valueType operands, as is the case with reference type\ntoday, valueTypes will perform a structural comparison instead\n(substitutability test). This overload of the ifacmp* bytecodes is\nrequired because valueTypes subclass java.lang.Object and use a*\nbytecodes. It is possible for the static type of a valueType to be a\nreference type (see example below) but the reflexive properties of the\n`==` must still be maintained.\n\nObject p = (Object) Point.makePoint(1, 2);\nif (p == p) //must be true\n\nThe original acmp (legacy acmp) operation in the ifacmp* bytecodes\nperforms a simple ref comparison, lhs == rhs. This must be updated to\ncheck if both operands are valueTypes, and\u00a0 if they are of the same\ntype. If that is the case a structural comparison must be performed.\nExample below:\n\n```\nacmpSub(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (lhs == rhs) return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs == NULL) || (rhs == NULL)) return false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs.class == rhs.class) && (lhs.isValue)) return\nisSubstitutable(lhs, rhs)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return false\n}\n```\n\nThe structural comparison must iterate through each field and perform an\nequality comparison. If the field is byte, short, char, int the\ncomparison in icmp_eq is performed. If the field is a long the\ncomparison in lcmp is performed. If the field is a float an icmp\ncomparison of Float.floatToIntBits of both values is performed. If the\nfield is a double an lcmp comparison of Double.doubleToLongBits of both\nvalues is performed. Note: this behaviour differs from the float f =\n...; f == f case which performs a fcmp* operation. If the field is a\nreference type that is java.lang.Object or an Interface or any type that\nmay contain a valueType (i.e InlineObject, Object, restricted-abstract\nclasses or interfaces) or if the field is a value type and both values\nare not NULL a recursive acmpSub is performed. For all other types the\nlegacy acmp is performed. Example is below:\n\n```\nisSubstitutable(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each primitive perform primitive comparison (icmp, lcmp,\nFloat.floatToIntBits then icmp, )\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each ref that is j.l.Object, interface, a valueType and\nboth operands are not NULL perform acmSub (recursive)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for all other refs perform legacy acmp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return result\n}\n```\n\nThere are cases where the JVM may optimize the individual field\ncomparisons of the substitutability test and simply perform a memcmp\nover the range of the operands. This optimization is possible in cases\nwhere the substitutability test will not require recursion and there are\nno floating point types.\nThe acmpSub will check to see if the fast comparison flag exists, if so\nit will perform a memcmp with both operands that does something like\nmemcmp(lhs, rhs, lhs.size).\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-08T15:35:10Z", "type": "forcePushed"}, {"oid": "d1f0fb26d0c43e7d240f0dad3a6881c9d0a9fc36", "url": "https://github.com/eclipse-openj9/openj9/commit/d1f0fb26d0c43e7d240f0dad3a6881c9d0a9fc36", "message": "ACMP support for value types\n\nThis adds support for substitutability test in the acmp* bytecodes which\nis needed to support value types.\n\nOverview:\n-----------\n\nInstead of doing a reference comparison when the ifacmp* bytecodes are\nexecuted with valueType operands, as is the case with reference type\ntoday, valueTypes will perform a structural comparison instead\n(substitutability test). This overload of the ifacmp* bytecodes is\nrequired because valueTypes subclass java.lang.Object and use a*\nbytecodes. It is possible for the static type of a valueType to be a\nreference type (see example below) but the reflexive properties of the\n`==` must still be maintained.\n\nObject p = (Object) Point.makePoint(1, 2);\nif (p == p) //must be true\n\nThe original acmp (legacy acmp) operation in the ifacmp* bytecodes\nperforms a simple ref comparison, lhs == rhs. This must be updated to\ncheck if both operands are valueTypes, and\u00a0 if they are of the same\ntype. If that is the case a structural comparison must be performed.\nExample below:\n\n```\nacmpSub(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (lhs == rhs) return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs == NULL) || (rhs == NULL)) return false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs.class == rhs.class) && (lhs.isValue)) return\nisSubstitutable(lhs, rhs)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return false\n}\n```\n\nThe structural comparison must iterate through each field and perform an\nequality comparison. If the field is byte, short, char, int the\ncomparison in icmp_eq is performed. If the field is a long the\ncomparison in lcmp is performed. If the field is a float an icmp\ncomparison of Float.floatToIntBits of both values is performed. If the\nfield is a double an lcmp comparison of Double.doubleToLongBits of both\nvalues is performed. Note: this behaviour differs from the float f =\n...; f == f case which performs a fcmp* operation. If the field is a\nreference type that is java.lang.Object or an Interface or any type that\nmay contain a valueType (i.e InlineObject, Object, restricted-abstract\nclasses or interfaces) or if the field is a value type and both values\nare not NULL a recursive acmpSub is performed. For all other types the\nlegacy acmp is performed. Example is below:\n\n```\nisSubstitutable(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each primitive perform primitive comparison (icmp, lcmp,\nFloat.floatToIntBits then icmp, )\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each ref that is j.l.Object, interface, a valueType and\nboth operands are not NULL perform acmSub (recursive)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for all other refs perform legacy acmp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return result\n}\n```\n\nThere are cases where the JVM may optimize the individual field\ncomparisons of the substitutability test and simply perform a memcmp\nover the range of the operands. This optimization is possible in cases\nwhere the substitutability test will not require recursion and there are\nno floating point types.\nThe acmpSub will check to see if the fast comparison flag exists, if so\nit will perform a memcmp with both operands that does something like\nmemcmp(lhs, rhs, lhs.size).\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-08T15:40:36Z", "type": "forcePushed"}, {"oid": "f5f90134a6d9bc6f7ae3cc9150d3cd4e84a176d1", "url": "https://github.com/eclipse-openj9/openj9/commit/f5f90134a6d9bc6f7ae3cc9150d3cd4e84a176d1", "message": "ACMP support for value types\n\nThis adds support for substitutability test in the acmp* bytecodes which\nis needed to support value types.\n\nOverview:\n-----------\n\nInstead of doing a reference comparison when the ifacmp* bytecodes are\nexecuted with valueType operands, as is the case with reference type\ntoday, valueTypes will perform a structural comparison instead\n(substitutability test). This overload of the ifacmp* bytecodes is\nrequired because valueTypes subclass java.lang.Object and use a*\nbytecodes. It is possible for the static type of a valueType to be a\nreference type (see example below) but the reflexive properties of the\n`==` must still be maintained.\n\nObject p = (Object) Point.makePoint(1, 2);\nif (p == p) //must be true\n\nThe original acmp (legacy acmp) operation in the ifacmp* bytecodes\nperforms a simple ref comparison, lhs == rhs. This must be updated to\ncheck if both operands are valueTypes, and\u00a0 if they are of the same\ntype. If that is the case a structural comparison must be performed.\nExample below:\n\n```\nacmpSub(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (lhs == rhs) return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs == NULL) || (rhs == NULL)) return false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs.class == rhs.class) && (lhs.isValue)) return\nisSubstitutable(lhs, rhs)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return false\n}\n```\n\nThe structural comparison must iterate through each field and perform an\nequality comparison. If the field is byte, short, char, int the\ncomparison in icmp_eq is performed. If the field is a long the\ncomparison in lcmp is performed. If the field is a float an icmp\ncomparison of Float.floatToIntBits of both values is performed. If the\nfield is a double an lcmp comparison of Double.doubleToLongBits of both\nvalues is performed. Note: this behaviour differs from the float f =\n...; f == f case which performs a fcmp* operation. If the field is a\nreference type that is java.lang.Object or an Interface or any type that\nmay contain a valueType (i.e InlineObject, Object, restricted-abstract\nclasses or interfaces) or if the field is a value type and both values\nare not NULL a recursive acmpSub is performed. For all other types the\nlegacy acmp is performed. Example is below:\n\n```\nisSubstitutable(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each primitive perform primitive comparison (icmp, lcmp,\nFloat.floatToIntBits then icmp, )\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each ref that is j.l.Object, interface, a valueType and\nboth operands are not NULL perform acmSub (recursive)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for all other refs perform legacy acmp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return result\n}\n```\n\nThere are cases where the JVM may optimize the individual field\ncomparisons of the substitutability test and simply perform a memcmp\nover the range of the operands. This optimization is possible in cases\nwhere the substitutability test will not require recursion and there are\nno floating point types.\nThe acmpSub will check to see if the fast comparison flag exists, if so\nit will perform a memcmp with both operands that does something like\nmemcmp(lhs, rhs, lhs.size).\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-08T15:41:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0MTQ1NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9101#discussion_r405641454", "bodyText": "Might be better to assign acmpResult to (lhs == rhs) initially, then test and modify it inside the ifdef so there's only a single return.", "author": "gacholio", "createdAt": "2020-04-08T16:08:46Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -7323,56 +7324,6 @@ class INTERPRETER_CLASS\n \t\treturn rc;\n \t}\n \n-\t/*\n-\t * Determine if the two objects are substitutable\n-\t *\n-\t * @param[in] lhs the lhs object of acmp bytecodes\n-\t * @param[in] rhs the rhs object of acmp bytecodes\n-\t * return true if they are substitutable and false otherwise\n-\t */\n-\tVMINLINE bool\n-\tacmp(j9object_t lhs, j9object_t rhs)\n-\t{\n-#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)", "originalCommit": "f5f90134a6d9bc6f7ae3cc9150d3cd4e84a176d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0MzExNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9101#discussion_r405643114", "bodyText": "Once again, I can't tell deletion from addition...", "author": "gacholio", "createdAt": "2020-04-08T16:11:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0MTQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0MTcwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9101#discussion_r405641707", "bodyText": "Is there a reason not to captialize here?", "author": "gacholio", "createdAt": "2020-04-08T16:09:06Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -48,6 +48,7 @@\n #include \"MHInterpreter.hpp\"\n #include \"ObjectAccessBarrierAPI.hpp\"\n #include \"ObjectHash.hpp\"\n+#include \"valueTypeHelpers.hpp\"", "originalCommit": "f5f90134a6d9bc6f7ae3cc9150d3cd4e84a176d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0MzY2OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9101#discussion_r405643669", "bodyText": "Assign inital value to (rhs == lhs) and test inside the ifdef, resulting in a single return at the end.", "author": "gacholio", "createdAt": "2020-04-08T16:12:01Z", "path": "runtime/vm/valueTypeHelpers.hpp", "diffHunk": "@@ -37,14 +43,59 @@ class ValueTypeHelpers {\n \t * Function members\n \t */\n private:\n+\tstatic bool\n+\tisSubstitutable(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI objectAccessBarrier, j9object_t lhs, j9object_t rhs, UDATA startOffset, J9Class *clazz);\n \n+\tstatic VMINLINE bool\n+\tcheckDoubleEquality(U_64 a, U_64 b)\n+\t{\n+\t\tbool result = false;\n+\n+\t\tif (a == b) {\n+\t\t\tresult = true;\n+\t\t} else if (IS_NAN_DBL(*(jdouble*)&a) && IS_NAN_DBL(*(jdouble*)&b)) {\n+\t\t\tresult = true;\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic VMINLINE bool\n+\tcheckFloatEquality(U_32 a, U_32 b)\n+\t{\n+\t\tbool result = false;\n+\n+\t\tif (a == b) {\n+\t\t\tresult = true;\n+\t\t} else if (IS_NAN_SNGL(*(jfloat*)&a) && IS_NAN_SNGL(*(jfloat*)&b)) {\n+\t\t\tresult = true;\n+\t\t}\n+\t\treturn result;\n+\t}\n protected:\n \n public:\n-\tstatic bool\n-\tisSubstitutable(J9VMThread *currentThread, j9object_t lhs, j9object_t rhs, UDATA startOffset, J9Class *clazz)\n+\tstatic VMINLINE bool\n+\tacmp(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI objectAccessBarrier, j9object_t lhs, j9object_t rhs)\n \t{\n-\t\treturn false;\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\tbool acmpResult = false;", "originalCommit": "f5f90134a6d9bc6f7ae3cc9150d3cd4e84a176d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0NDE1NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9101#discussion_r405644154", "bodyText": "To be consistent, this should be VM_ValueTypeHelpers.", "author": "gacholio", "createdAt": "2020-04-08T16:12:43Z", "path": "runtime/vm/valueTypeHelpers.hpp", "diffHunk": "@@ -23,6 +23,12 @@\n #if !defined(VALUETYPEHELPERS_HPP_)\n #define VALUETYPEHELPERS_HPP_\n \n+#include \"j9.h\"\n+#include \"fltconst.h\"\n+\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"VMHelpers.hpp\"\n+\n class ValueTypeHelpers {", "originalCommit": "f5f90134a6d9bc6f7ae3cc9150d3cd4e84a176d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d93e731bd3426aa086eab2c0ff1fa3fbf65411c5", "url": "https://github.com/eclipse-openj9/openj9/commit/d93e731bd3426aa086eab2c0ff1fa3fbf65411c5", "message": "ACMP support for value types\n\nThis adds support for substitutability test in the acmp* bytecodes which\nis needed to support value types.\n\nOverview:\n-----------\n\nInstead of doing a reference comparison when the ifacmp* bytecodes are\nexecuted with valueType operands, as is the case with reference type\ntoday, valueTypes will perform a structural comparison instead\n(substitutability test). This overload of the ifacmp* bytecodes is\nrequired because valueTypes subclass java.lang.Object and use a*\nbytecodes. It is possible for the static type of a valueType to be a\nreference type (see example below) but the reflexive properties of the\n`==` must still be maintained.\n\nObject p = (Object) Point.makePoint(1, 2);\nif (p == p) //must be true\n\nThe original acmp (legacy acmp) operation in the ifacmp* bytecodes\nperforms a simple ref comparison, lhs == rhs. This must be updated to\ncheck if both operands are valueTypes, and\u00a0 if they are of the same\ntype. If that is the case a structural comparison must be performed.\nExample below:\n\n```\nacmpSub(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (lhs == rhs) return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs == NULL) || (rhs == NULL)) return false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs.class == rhs.class) && (lhs.isValue)) return\nisSubstitutable(lhs, rhs)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return false\n}\n```\n\nThe structural comparison must iterate through each field and perform an\nequality comparison. If the field is byte, short, char, int the\ncomparison in icmp_eq is performed. If the field is a long the\ncomparison in lcmp is performed. If the field is a float an icmp\ncomparison of Float.floatToIntBits of both values is performed. If the\nfield is a double an lcmp comparison of Double.doubleToLongBits of both\nvalues is performed. Note: this behaviour differs from the float f =\n...; f == f case which performs a fcmp* operation. If the field is a\nreference type that is java.lang.Object or an Interface or any type that\nmay contain a valueType (i.e InlineObject, Object, restricted-abstract\nclasses or interfaces) or if the field is a value type and both values\nare not NULL a recursive acmpSub is performed. For all other types the\nlegacy acmp is performed. Example is below:\n\n```\nisSubstitutable(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each primitive perform primitive comparison (icmp, lcmp,\nFloat.floatToIntBits then icmp, )\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each ref that is j.l.Object, interface, a valueType and\nboth operands are not NULL perform acmSub (recursive)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for all other refs perform legacy acmp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return result\n}\n```\n\nThere are cases where the JVM may optimize the individual field\ncomparisons of the substitutability test and simply perform a memcmp\nover the range of the operands. This optimization is possible in cases\nwhere the substitutability test will not require recursion and there are\nno floating point types.\nThe acmpSub will check to see if the fast comparison flag exists, if so\nit will perform a memcmp with both operands that does something like\nmemcmp(lhs, rhs, lhs.size).\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-08T16:54:23Z", "type": "forcePushed"}, {"oid": "5705b0964a1bc3ba5b5c7c7e94d795afa2a7ab21", "url": "https://github.com/eclipse-openj9/openj9/commit/5705b0964a1bc3ba5b5c7c7e94d795afa2a7ab21", "message": "ACMP support for value types\n\nThis adds support for substitutability test in the acmp* bytecodes which\nis needed to support value types.\n\nOverview:\n-----------\n\nInstead of doing a reference comparison when the ifacmp* bytecodes are\nexecuted with valueType operands, as is the case with reference type\ntoday, valueTypes will perform a structural comparison instead\n(substitutability test). This overload of the ifacmp* bytecodes is\nrequired because valueTypes subclass java.lang.Object and use a*\nbytecodes. It is possible for the static type of a valueType to be a\nreference type (see example below) but the reflexive properties of the\n`==` must still be maintained.\n\nObject p = (Object) Point.makePoint(1, 2);\nif (p == p) //must be true\n\nThe original acmp (legacy acmp) operation in the ifacmp* bytecodes\nperforms a simple ref comparison, lhs == rhs. This must be updated to\ncheck if both operands are valueTypes, and\u00a0 if they are of the same\ntype. If that is the case a structural comparison must be performed.\nExample below:\n\n```\nacmpSub(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (lhs == rhs) return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs == NULL) || (rhs == NULL)) return false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs.class == rhs.class) && (lhs.isValue)) return\nisSubstitutable(lhs, rhs)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return false\n}\n```\n\nThe structural comparison must iterate through each field and perform an\nequality comparison. If the field is byte, short, char, int the\ncomparison in icmp_eq is performed. If the field is a long the\ncomparison in lcmp is performed. If the field is a float an icmp\ncomparison of Float.floatToIntBits of both values is performed. If the\nfield is a double an lcmp comparison of Double.doubleToLongBits of both\nvalues is performed. Note: this behaviour differs from the float f =\n...; f == f case which performs a fcmp* operation. If the field is a\nreference type that is java.lang.Object or an Interface or any type that\nmay contain a valueType (i.e InlineObject, Object, restricted-abstract\nclasses or interfaces) or if the field is a value type and both values\nare not NULL a recursive acmpSub is performed. For all other types the\nlegacy acmp is performed. Example is below:\n\n```\nisSubstitutable(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each primitive perform primitive comparison (icmp, lcmp,\nFloat.floatToIntBits then icmp, )\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each ref that is j.l.Object, interface, a valueType and\nboth operands are not NULL perform acmSub (recursive)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for all other refs perform legacy acmp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return result\n}\n```\n\nThere are cases where the JVM may optimize the individual field\ncomparisons of the substitutability test and simply perform a memcmp\nover the range of the operands. This optimization is possible in cases\nwhere the substitutability test will not require recursion and there are\nno floating point types.\nThe acmpSub will check to see if the fast comparison flag exists, if so\nit will perform a memcmp with both operands that does something like\nmemcmp(lhs, rhs, lhs.size).\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-08T16:56:34Z", "type": "commit"}, {"oid": "5705b0964a1bc3ba5b5c7c7e94d795afa2a7ab21", "url": "https://github.com/eclipse-openj9/openj9/commit/5705b0964a1bc3ba5b5c7c7e94d795afa2a7ab21", "message": "ACMP support for value types\n\nThis adds support for substitutability test in the acmp* bytecodes which\nis needed to support value types.\n\nOverview:\n-----------\n\nInstead of doing a reference comparison when the ifacmp* bytecodes are\nexecuted with valueType operands, as is the case with reference type\ntoday, valueTypes will perform a structural comparison instead\n(substitutability test). This overload of the ifacmp* bytecodes is\nrequired because valueTypes subclass java.lang.Object and use a*\nbytecodes. It is possible for the static type of a valueType to be a\nreference type (see example below) but the reflexive properties of the\n`==` must still be maintained.\n\nObject p = (Object) Point.makePoint(1, 2);\nif (p == p) //must be true\n\nThe original acmp (legacy acmp) operation in the ifacmp* bytecodes\nperforms a simple ref comparison, lhs == rhs. This must be updated to\ncheck if both operands are valueTypes, and\u00a0 if they are of the same\ntype. If that is the case a structural comparison must be performed.\nExample below:\n\n```\nacmpSub(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (lhs == rhs) return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs == NULL) || (rhs == NULL)) return false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if ((lhs.class == rhs.class) && (lhs.isValue)) return\nisSubstitutable(lhs, rhs)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return false\n}\n```\n\nThe structural comparison must iterate through each field and perform an\nequality comparison. If the field is byte, short, char, int the\ncomparison in icmp_eq is performed. If the field is a long the\ncomparison in lcmp is performed. If the field is a float an icmp\ncomparison of Float.floatToIntBits of both values is performed. If the\nfield is a double an lcmp comparison of Double.doubleToLongBits of both\nvalues is performed. Note: this behaviour differs from the float f =\n...; f == f case which performs a fcmp* operation. If the field is a\nreference type that is java.lang.Object or an Interface or any type that\nmay contain a valueType (i.e InlineObject, Object, restricted-abstract\nclasses or interfaces) or if the field is a value type and both values\nare not NULL a recursive acmpSub is performed. For all other types the\nlegacy acmp is performed. Example is below:\n\n```\nisSubstitutable(lhs, rhs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each primitive perform primitive comparison (icmp, lcmp,\nFloat.floatToIntBits then icmp, )\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for each ref that is j.l.Object, interface, a valueType and\nboth operands are not NULL perform acmSub (recursive)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for all other refs perform legacy acmp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return result\n}\n```\n\nThere are cases where the JVM may optimize the individual field\ncomparisons of the substitutability test and simply perform a memcmp\nover the range of the operands. This optimization is possible in cases\nwhere the substitutability test will not require recursion and there are\nno floating point types.\nThe acmpSub will check to see if the fast comparison flag exists, if so\nit will perform a memcmp with both operands that does something like\nmemcmp(lhs, rhs, lhs.size).\n\nThis is based on Adithya's work in\nhttps://github.com/eclipse/openj9/pull/8133\n\nSigned-off-by: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-04-08T16:56:34Z", "type": "forcePushed"}]}