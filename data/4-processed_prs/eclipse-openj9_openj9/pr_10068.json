{"pr_number": 10068, "pr_title": "Add ResolveCHK for value types before NULLCHK", "pr_createdAt": "2020-07-02T03:25:26Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10068", "timeline": [{"oid": "17a945bd68f844020a19f4371adb0c5df4c8df85", "url": "https://github.com/eclipse-openj9/openj9/commit/17a945bd68f844020a19f4371adb0c5df4c8df85", "message": "Add ResolveCHK for value types before NULLCHK\n\nFixes #10056\n\nCo-authored-by: Yi Zhang <yizhang@ca.ibm.com>\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-07-04T00:07:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxNTE5Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10068#discussion_r450915197", "bodyText": "I suggest you add explicitly that the class has to be resolved unconditionally if it's a value type, regardless of whether the value is null, just to make it clear.", "author": "hzongaro", "createdAt": "2020-07-07T14:37:56Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -2357,7 +2357,8 @@ TR_J9ByteCodeIlGenerator::genCheckCast()\n  * Generate IL for a checkcast bytecode instruction.\n  *\n  * If the class specified in the bytecode is unresolved, this leaves out the\n- * ResolveCHK since it has to be conditional on a non-null object.\n+ * ResolveCHK since it has to be conditional on a non-null object when it is\n+ * not a value type.", "originalCommit": "17a945bd68f844020a19f4371adb0c5df4c8df85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5c67553ac4b74a44452e56313dfd253b6c36a85d", "url": "https://github.com/eclipse-openj9/openj9/commit/5c67553ac4b74a44452e56313dfd253b6c36a85d", "message": "Add ResolveCHK for value types before NULLCHK\n\nThe class has to be resolved unconditionally\nif it's a value type, regardless of whether\nthe value is null.\n\nFixes #10056\n\nCo-authored-by: Yi Zhang <yizhang@ca.ibm.com>\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-07-07T15:27:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE2OTU5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10068#discussion_r452169592", "bodyText": "Why can we not use loadClassObject here?", "author": "andrewcraik", "createdAt": "2020-07-09T12:09:01Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -2369,13 +2371,26 @@ TR_J9ByteCodeIlGenerator::genCheckCast(int32_t cpIndex)\n    {\n    if (TR::Compiler->om.areValueTypesEnabled() && TR::Compiler->cls.isClassRefValueType(comp(), method()->classOfMethod(), cpIndex))\n       {\n+      void * classObject = method()->getClassFromConstantPool(comp(), cpIndex);", "originalCommit": "5c67553ac4b74a44452e56313dfd253b6c36a85d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI0MjM0OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10068#discussion_r452242348", "bodyText": "loadClassObject() pushes a node to the stack. The symbolic reference would be pushed on the top of the stack instead of the objectref before the NULLCHK node creation. passThruNode\u2019s child becomes the symbolic reference, instead of objectRef. NULLCHK\u2019s grandchild node ends up being wrong.", "author": "a7ehuo", "createdAt": "2020-07-09T14:04:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE2OTU5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY2MTA2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10068#discussion_r453661068", "bodyText": "@a7ehuo thanks for the explanation - rather than duplicating this logic inline, I think we should refactor loadSymbol into a loadSymbol and loadSymbolNoPush or something like that. loadSymbol can then call loadSymbolNoPush and then push. That way we can keep all that logic together and avoid creating a case to be missed if we have to change anything about how this works...", "author": "andrewcraik", "createdAt": "2020-07-13T13:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE2OTU5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgzMjY1Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10068#discussion_r453832652", "bodyText": "I looked at the code again and I wonder if the followings achieve the same thing without duplicating the logic or refactoring loadSymbol?\n   if (TR::Compiler->om.areValueTypesEnabled() && TR::Compiler->cls.isClassRefValueType(comp(), method()->classOfMethod(), cpIndex))\n      {\n      TR::Node * objNode = _stack->top();\n\n      loadClassObject(cpIndex);\n\n      TR::Node *passThruNode = TR::Node::create(TR::PassThrough, 1, objNode);\n      genTreeTop(genNullCheck(passThruNode));\n      }", "author": "a7ehuo", "createdAt": "2020-07-13T18:03:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE2OTU5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg2MTI4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10068#discussion_r453861288", "bodyText": "so the issue will be that the push in loadClassObject will be onto the real operand stack and that is likely what you want to avoid - you could potentially pop it, but why push to pop... So I think the stack will still be the wrong shape after this if the goal is to load the SymRef without pushing its value onto the simulated operand stack.", "author": "andrewcraik", "createdAt": "2020-07-13T18:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE2OTU5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkzMTI2MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10068#discussion_r453931260", "bodyText": "On second thought you may be right - test the sequence, but your proposal would be preferable if it works.", "author": "andrewcraik", "createdAt": "2020-07-13T21:03:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE2OTU5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQwNTI1Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10068#discussion_r454405257", "bodyText": "The new sequence #10068 (comment) looks good to me. The operation on the stack as below is the same as duplicating loadClassObject logic inline:\nEnter genCheckCast(int32_t cpIndex): stack top aconst\n===>loadClassObject(): stack top aconst\n              - push loadaddr\n===>Enter genCheckCast(): stack top loadaddr\n               Enter genNodeAndPopChildren(): stack top loadaddr\n\t            - pop loadaddr\n\t            - pop aconst\n               Exit genNodeAndPopChildren(): stack empty \n\t       push aconst\n===>Exit genCheckCast(): stack top aconst\nExit genCheckCast(int32_t cpIndex): stack top aconst\n\n  ============================================================\n   1: JBcheckcast\n   /--- trees inserted ------------------------\n      n5n      (  0)  ResolveCHK [#307]                                                                    [0x7f13f1057540] bci=[-1,1,-] rc=0 vc=0 vn=- li=- udi=- nc=1\n      n4n      (  2)    loadaddr  unknown class object[#366  unresolved Static] [flags 0x18307 0x0 ]       [0x7f13f10574f0] bci=[-1,1,-] rc=2 vc=0 vn=- li=- udi=- nc=0\n      n7n      (  0)  NULLCHK on n3n [#32]                                                                 [0x7f13f10575e0] bci=[-1,1,-] rc=0 vc=0 vn=- li=- udi=- nc=1\n      n6n      (  1)    PassThrough                                                                        [0x7f13f1057590] bci=[-1,1,-] rc=1 vc=0 vn=- li=- udi=- nc=1\n      n3n      (  2)      aconst NULL                                                                      [0x7f13f10574a0] bci=[-1,0,-] rc=2 vc=0 vn=- li=- udi=- nc=0\n      n8n      (  0)  checkcast [#86]                                                                      [0x7f13f1057630] bci=[-1,1,-] rc=0 vc=0 vn=- li=- udi=- nc=2\n      n3n      (  2)    ==>aconst NULL\n      n4n      (  2)    ==>loadaddr\n   /--- stack after ------------------------\n   @0 n3n      (  2)  ==>aconst NULL\n  ============================================================", "author": "a7ehuo", "createdAt": "2020-07-14T14:37:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE2OTU5Mg=="}], "type": "inlineReview"}, {"oid": "e74076f16b1369fd144d388b818cea7ac30b16c4", "url": "https://github.com/eclipse-openj9/openj9/commit/e74076f16b1369fd144d388b818cea7ac30b16c4", "message": "Add ResolveCHK for value types before NULLCHK\n\nThe class has to be resolved unconditionally\nif it is a value type, regardless of whether\nthe value is null.\n\nFixes #10056\n\nCo-authored-by: Yi Zhang <yizhang@ca.ibm.com>\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-07-14T15:35:39Z", "type": "commit"}, {"oid": "e74076f16b1369fd144d388b818cea7ac30b16c4", "url": "https://github.com/eclipse-openj9/openj9/commit/e74076f16b1369fd144d388b818cea7ac30b16c4", "message": "Add ResolveCHK for value types before NULLCHK\n\nThe class has to be resolved unconditionally\nif it is a value type, regardless of whether\nthe value is null.\n\nFixes #10056\n\nCo-authored-by: Yi Zhang <yizhang@ca.ibm.com>\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-07-14T15:35:39Z", "type": "forcePushed"}]}