{"pr_number": 8230, "pr_title": "Fix Class.getMethod() and Class.getMethods() missing cases", "pr_createdAt": "2020-01-07T21:54:00Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/8230", "timeline": [{"oid": "4901aa8880abf63122a4de12e76d48ab782cca88", "url": "https://github.com/eclipse-openj9/openj9/commit/4901aa8880abf63122a4de12e76d48ab782cca88", "message": "Search all superinterfaces with base interfaces\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-01-08T16:27:52Z", "type": "forcePushed"}, {"oid": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "url": "https://github.com/eclipse-openj9/openj9/commit/8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "message": "Search all superinterfaces with base interfaces\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-01-09T14:43:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2NzUzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366467531", "bodyText": "Is the check this != Object.class necessary?", "author": "JasonFengJ9", "createdAt": "2020-01-14T17:17:03Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {", "originalCommit": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ4OTk5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r367489992", "bodyText": "I believe this is referring to the javadoc line:\n\nIf C is a class other than Object, then include the result of invoking this algorithm recursively on the superclass of C.\n\nThough in practice I think it may not be needed. @ChengJin01 do you have any insights to this from your testing?", "author": "theresa-m", "createdAt": "2020-01-16T15:40:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2NzUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUwNTI3OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r367505278", "bodyText": "It looks like this check is also done https://github.com/eclipse/openj9/blob/8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625/jcl/src/java.base/share/classes/java/lang/Class.java#L1594 so its not necessary to do it twice.", "author": "theresa-m", "createdAt": "2020-01-16T16:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2NzUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxMDE2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r367510168", "bodyText": "@theresa-m, Object.class should be excluded in the search of superclass in any case. Please modify accordingly if any duplicate and verify the update with all tests.", "author": "ChengJin01", "createdAt": "2020-01-16T16:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2NzUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2ODQzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366468438", "bodyText": "It appears this method is going to repeat getMethodImpl(name, parameterTypes, strSig) regardless of other conditions which is not desirable.", "author": "JasonFengJ9", "createdAt": "2020-01-14T17:19:03Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n+\t\t\tif (!this.isInterface()) {\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, interfaceSet, name, strSig, parameterTypes);", "originalCommit": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ5OTI4Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r367499286", "bodyText": "Yes good catch. I can rearrange that to prevent duplicate calls.", "author": "theresa-m", "createdAt": "2020-01-16T15:55:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2ODQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2OTEyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366469122", "bodyText": "This method might return null while initial result isn't, this doesn't seem right.", "author": "JasonFengJ9", "createdAt": "2020-01-14T17:20:29Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n+\t\t\tif (!this.isInterface()) {\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, interfaceSet, name, strSig, parameterTypes);\n+\t\t\t\tcandidateFromInteface = true;\n+\t\t\t} else if (result.getDeclaringClass() != this) { /* only applies if resulting class is not the base class */\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, interfaceSet, null, name, strSig, parameterTypes);", "originalCommit": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2OTg1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366469858", "bodyText": "Any particular reason to create new HashSet() without actual usage after the following method call?", "author": "JasonFengJ9", "createdAt": "2020-01-14T17:22:06Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n+\t\t\tif (!this.isInterface()) {\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();", "originalCommit": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ5NzU5NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r367497595", "bodyText": "If an interface inherits the same superinterface more than once somewhere in its hierarchy the HashSet will save some native calls.\nexample:\ninterface Y extends X {void m() {}}\ninterface Z extends X, Y {}\n\nX will only be searched once. this example is trivial but if X had many superinterfaces it would show an impact.", "author": "theresa-m", "createdAt": "2020-01-16T15:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2OTg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ3MDExOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366470119", "bodyText": "Similar comment about this interfaceSet as well.", "author": "JasonFengJ9", "createdAt": "2020-01-14T17:22:35Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n+\t\t\tif (!this.isInterface()) {\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, interfaceSet, name, strSig, parameterTypes);\n+\t\t\t\tcandidateFromInteface = true;\n+\t\t\t} else if (result.getDeclaringClass() != this) { /* only applies if resulting class is not the base class */\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();", "originalCommit": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7eedaee3f27228e8837b6490e809b2895035c718", "url": "https://github.com/eclipse-openj9/openj9/commit/7eedaee3f27228e8837b6490e809b2895035c718", "message": "Search all superinterfaces with base interfaces\n\n- Class.getMethods jteg fixes, and make more similar to hotspot output\n- Class.getMethod interface search logic\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-01-29T14:57:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MDkxOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r374170918", "bodyText": "getMethods() is going to be invoked for the superclasses from the top to the bottom, and the later invocations include the results of previous calls which seems an overkill.\ncan we modify getMethodImpl(name, parameterTypes, strSig) to introduce a startingPoint, particularly for the case that the method found is declared by an interface class?", "author": "JasonFengJ9", "createdAt": "2020-02-03T15:34:11Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1530,26 +1551,127 @@ Method getMethodHelper(\n \t * Otherwise, the result method is chosen arbitrarily from specific methods.\n \t */\n \tbestCandidate = result;\n-\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n-\twhile (true) {\n-\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n-\t\tif (result == null) {\n-\t\t\tbreak;\n+\tif (!candidateFromInterface) {\n+\t\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n+\t\twhile (true) {\n+\t\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n+\t\t\tif (result == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n+\t\t\tif ((methodList != null) && publicMethod) {\n+\t\t\t\tmethodList.add(result);\n+\t\t\t}\n+\t\t\tif (forDeclaredMethod || publicMethod) {\n+\t\t\t\t// bestCandidate and result have same declaringClass.\n+\t\t\t\tClass<?> candidateRetType = bestCandidate.getReturnType();\n+\t\t\t\tClass<?> resultRetType = result.getReturnType();\n+\t\t\t\tif ((candidateRetType != resultRetType) && candidateRetType.isAssignableFrom(resultRetType)) {\n+\t\t\t\t\tbestCandidate = result;\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n-\t\tif ((methodList != null) && publicMethod) {\n-\t\t\tmethodList.add(result);\n+\t}\n+\treturn cacheMethod(bestCandidate);\n+}\n+\n+/**\n+ * Helper method searches all interfaces implemented by superclasses from the top to the bottom\n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class to be searched, including the current class and all superclasses\n+ * @param name the specified method's name\n+ * @param strSig the string of the specified method's signature\n+ * @param parameterTypes the types of the arguments of the specified method\n+ * @return the most specific method selected from all interfaces from each superclass of the current class;\n+ *         otherwise, return the method of the first interface from the top superclass\n+ *         if the return types of all specified methods are identical.\n+ */\n+private static Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(Class<?> currentClass, String name, String strSig, Class<?>... parameterTypes) {\n+\tMethod candidateMethod = null;\n+\tif (currentClass != Object.class) {\n+\t\t/* get to the top superclass first. if all return types end up being the same the interfaces from this superclass have priority. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(currentClass.getSuperclass(), name, strSig, parameterTypes);\n+\t\t\n+\t\t/* search all interfaces of current class, comparing against result from previous superclass. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfCurrentClass(currentClass, candidateMethod, name, strSig, parameterTypes);\n+\t}\n+\treturn candidateMethod;\n+}\n+\n+/**\n+ * Helper method searches all interfaces implemented by the current class or interface \n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class or interface to be searched\n+ * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n+ * @param name the specified method's name\n+ * @param strSig the string of the specified method's signature\n+ * @param parameterTypes the types of the arguments of the specified method\n+ * @return the most specific method selected from all interfaces;\n+ *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n+ */\n+private static Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(Class<?> currentClass, Method potentialCandidate, String name, String strSig, Class<?>... parameterTypes) {\n+\tMethod bestMethod = potentialCandidate;\n+\tMethod[] methodCandidates = currentClass.getMethods();", "originalCommit": "7eedaee3f27228e8837b6490e809b2895035c718", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc1ODY1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r374758658", "bodyText": "I agree that it is overkill.\nI think it would still be useful to take advantage of the getMethods helper functions for the sake of not duplicating code, and combining the logic was helpful in that I was able to improve correctness of getMethod and getMethods at the same time. I can limit the superclasses searches for this particular case.", "author": "theresa-m", "createdAt": "2020-02-04T15:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MDkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc3NTgxNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r374775814", "bodyText": "Not against the idea. getMethods() just is a heavyweight api, can getMethodImpl & getDeclaredMethodImpl be used for the superclasses from the top to the bottom instead?\n\nimprove correctness of getMethod and getMethods at the same time\n\ngetMethod() calls getMethodHelper() which is being fixed by this PR.\ndoes getMethods() miss any method?", "author": "JasonFengJ9", "createdAt": "2020-02-04T16:22:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MDkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NzE3NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r374787174", "bodyText": "Not against the idea. getMethods() just is a heavyweight api, can getMethodImpl & getDeclaredMethodImpl be used for the superclasses from the top to the bottom instead?\n\nI think your idea of adding a startingPoint type variable to getMethodImpl would be a good solution as well.\nedit: Although I'm not sure it would be a simple native change since each call to getMethodImpl uses the entire interface list to determine which interface is the most valid match.\n\n\nimprove correctness of getMethod and getMethods at the same time\n\ngetMethod() calls getMethodHelper() which is being fixed by this PR.\ndoes getMethods() miss any method?\n\nThere is one case for getMethods being fixed here as well that was uncovered by one of the tests from #7623. Maybe that will explain more how that line of thinking came about too :) I will make that more obvious in the issue description.", "author": "theresa-m", "createdAt": "2020-02-04T16:40:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MDkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkzNzM4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r374937388", "bodyText": "@JasonFengJ9  I made some updates to this approach to tighten things up. getMostSpecificMethodFromAllInterfacesOfCurrentClass will now call getMethodSet directly, and then only search for interfaces and not classes. Let me know what you think.", "author": "theresa-m", "createdAt": "2020-02-04T21:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MDkxOA=="}], "type": "inlineReview"}, {"oid": "0715f9f8f7a3b2920884c427409dff8877a64373", "url": "https://github.com/eclipse-openj9/openj9/commit/0715f9f8f7a3b2920884c427409dff8877a64373", "message": "Search all superinterfaces with base interfaces\n\n- Class.getMethods jteg fixes, and make more similar to hotspot output\n- Class.getMethod interface search logic\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-02-04T21:29:12Z", "type": "forcePushed"}, {"oid": "bbc2ff27a563388dd938aa3e7391d367fed07c36", "url": "https://github.com/eclipse-openj9/openj9/commit/bbc2ff27a563388dd938aa3e7391d367fed07c36", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-02-12T11:39:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r378336600", "bodyText": "is there a chance that infoCache could be confused by localInterfacesOnly since the key is always this class?\nI didn't go thorough all use cases, but just wondering if such possibility has been considered.", "author": "JasonFengJ9", "createdAt": "2020-02-12T15:46:28Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1530,28 +1552,146 @@ Method getMethodHelper(\n \t * Otherwise, the result method is chosen arbitrarily from specific methods.\n \t */\n \tbestCandidate = result;\n-\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n-\twhile (true) {\n-\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n-\t\tif (result == null) {\n-\t\t\tbreak;\n-\t\t}\n-\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n-\t\tif ((methodList != null) && publicMethod) {\n-\t\t\tmethodList.add(result);\n-\t\t}\n-\t\tif (forDeclaredMethod || publicMethod) {\n-\t\t\t// bestCandidate and result have same declaringClass.\n-\t\t\tClass<?> candidateRetType = bestCandidate.getReturnType();\n-\t\t\tClass<?> resultRetType = result.getReturnType();\n-\t\t\tif ((candidateRetType != resultRetType) && candidateRetType.isAssignableFrom(resultRetType)) {\n-\t\t\t\tbestCandidate = result;\n+\tif (!candidateFromInterface) {\n+\t\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n+\t\twhile (true) {\n+\t\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n+\t\t\tif (result == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n+\t\t\tif ((methodList != null) && publicMethod) {\n+\t\t\t\tmethodList.add(result);\n+\t\t\t}\n+\t\t\tif (forDeclaredMethod || publicMethod) {\n+\t\t\t\t// bestCandidate and result have same declaringClass.\n+\t\t\t\tClass<?> candidateRetType = bestCandidate.getReturnType();\n+\t\t\t\tClass<?> resultRetType = result.getReturnType();\n+\t\t\t\tif ((candidateRetType != resultRetType) && candidateRetType.isAssignableFrom(resultRetType)) {\n+\t\t\t\t\tbestCandidate = result;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \treturn cacheMethod(bestCandidate);\n }\n \n+/**\n+ * Helper method searches all interfaces implemented by superclasses from the top to the bottom\n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class to be searched, including the current class and all superclasses\n+ * @param name the specified method's name\n+ * @param parameterTypes the types of the arguments of the specified method\n+ * @return the most specific method selected from all interfaces from each superclass of the current class;\n+ *         otherwise, return the method of the first interface from the top superclass\n+ *         if the return types of all specified methods are identical.\n+ */\n+private Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(Class<?> currentClass, HashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache, \n+\tString name, Class<?>... parameterTypes) \n+{\n+\tMethod candidateMethod = null;\n+\tif (currentClass != Object.class) {\n+\t\t/* get to the top superclass first. if all return types end up being the same the interfaces from this superclass have priority. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(currentClass.getSuperclass(), infoCache, name, parameterTypes);\n+\t\t\n+\t\t/* search all interfaces of current class, comparing against result from previous superclass. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfCurrentClass(currentClass, infoCache, candidateMethod, name, parameterTypes);\n+\t}\n+\treturn candidateMethod;\n+}\n+\n+/**\n+ * Helper method searches all interfaces implemented by the current class or interface \n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class or interface to be searched\n+ * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n+ * @param name the specified method's name\n+ * @param parameterTypes the types of the arguments of the specified method\n+ * @return the most specific method selected from all interfaces;\n+ *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n+ */\n+private Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(Class<?> currentClass, HashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache,\n+\tMethod potentialCandidate, String name, Class<?>... parameterTypes) \n+{\n+\tMethod bestMethod = potentialCandidate;\n+\t/* if infoCache is passed in, reuse from superclass */\n+\tif (null == infoCache) {\n+\t\tinfoCache = new HashMap<>(16);\n+\t}\n+\tHashMap<MethodInfo, MethodInfo> methodCandidates = getMethodSet(infoCache, false, true);", "originalCommit": "bbc2ff27a563388dd938aa3e7391d367fed07c36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgyMDUzNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r378820535", "bodyText": "I made some modifications so it is more clear which this is being used by getMethodSet.", "author": "theresa-m", "createdAt": "2020-02-13T12:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkwNzQ0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r378907449", "bodyText": "infoCache seems not for late use after current getMethodHelper() call hence won't help much performance.\nIn that case, getInterfaces() is a better choice.", "author": "JasonFengJ9", "createdAt": "2020-02-13T14:49:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ3ODM4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r476478382", "bodyText": "@theresa-m is there a PR update since last comment?", "author": "JasonFengJ9", "createdAt": "2020-08-25T14:09:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4NDY4Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r477284687", "bodyText": "In my opinion getMethodSet is okay. getInterfaces could be used but getMethodSet is already getting interfaces recursively calling getInterfaces. From a maintainability standpoint I think it will be advantageous to maintain one spot for the override logic in update: https://github.com/eclipse/openj9/blob/1ed4919d1a2f9eb58ce7bd4facc99bcb76068bf9/jcl/src/java.base/share/classes/java/lang/Class.java#L3890", "author": "theresa-m", "createdAt": "2020-08-26T13:06:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5Mjk2Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r477292966", "bodyText": "An alternative solution as discussed offline would be to move more of this logic into native code however this would require quite a bit of work.", "author": "theresa-m", "createdAt": "2020-08-26T13:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA=="}], "type": "inlineReview"}, {"oid": "b09b8df1b275eb94e149adf9805c810c72cc95e1", "url": "https://github.com/eclipse-openj9/openj9/commit/b09b8df1b275eb94e149adf9805c810c72cc95e1", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-02-13T12:02:41Z", "type": "forcePushed"}, {"oid": "1ed4919d1a2f9eb58ce7bd4facc99bcb76068bf9", "url": "https://github.com/eclipse-openj9/openj9/commit/1ed4919d1a2f9eb58ce7bd4facc99bcb76068bf9", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-02-13T14:15:07Z", "type": "forcePushed"}, {"oid": "57ec2470aba0d567200e7754f76d4fed5b4110d3", "url": "https://github.com/eclipse-openj9/openj9/commit/57ec2470aba0d567200e7754f76d4fed5b4110d3", "message": "Fix the missing case of Class.getMethod()\n\nThe change is adding code in the helper method\nof getMethod() to address the missing case when\nthe two specific methods are both declared\nby interfaces.\n\nFixes: #7897\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-08-27T12:41:53Z", "type": "commit"}, {"oid": "ce60704e9678db4056d8afe08c13d3a02d554df0", "url": "https://github.com/eclipse-openj9/openj9/commit/ce60704e9678db4056d8afe08c13d3a02d554df0", "message": "Search all superinterfaces with base interfaces\n\n- Class.getMethods jteg fixes, and make more similar to hotspot output\n- Class.getMethod interface search logic\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-08-27T12:41:53Z", "type": "commit"}, {"oid": "2d998299562752395d25a9a94f1f5c3721ff3906", "url": "https://github.com/eclipse-openj9/openj9/commit/2d998299562752395d25a9a94f1f5c3721ff3906", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-08-27T12:41:53Z", "type": "commit"}, {"oid": "2d998299562752395d25a9a94f1f5c3721ff3906", "url": "https://github.com/eclipse-openj9/openj9/commit/2d998299562752395d25a9a94f1f5c3721ff3906", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-08-27T12:41:53Z", "type": "forcePushed"}]}