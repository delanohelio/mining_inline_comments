{"pr_number": 10607, "pr_title": "Update invokedynamic and invokehandle bytecode handlers", "pr_createdAt": "2020-09-16T00:06:46Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10607", "timeline": [{"oid": "f8344b6a20ba4e9bfd06ffb97b30abf27e3c8f1d", "url": "https://github.com/eclipse-openj9/openj9/commit/f8344b6a20ba4e9bfd06ffb97b30abf27e3c8f1d", "message": "Update invokedynamic and invokehandle bytecode handlers\n\nThis changeset updates the handling of invokedynamic and invokehandle\nbytecodes in preparation for migrating to the AdoptOpenJDK MethodHandle\nimplementation. The changes are not enabled by default, and are guarded\nin the macro J9VM_OPT_OPENJDK_METHODHANDLE.\n\nThis implementation can handle both resolved and unresolved\ninvokedynamic and invokehandle bytecodes.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2020-09-16T19:36:05Z", "type": "forcePushed"}, {"oid": "2e35fc27a98f86b2510118e0231bcde9e9f620b1", "url": "https://github.com/eclipse-openj9/openj9/commit/2e35fc27a98f86b2510118e0231bcde9e9f620b1", "message": "Update invokedynamic and invokehandle bytecode handlers\n\nThis changeset updates the handling of invokedynamic and invokehandle\nbytecodes in preparation for migrating to the OpenJDK MethodHandle\nimplementation. The changes are not enabled by default, and are guarded\nin the macro J9VM_OPT_OPENJDK_METHODHANDLE.\n\nThis implementation can handle both resolved and unresolved\ninvokedynamic and invokehandle bytecodes.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2020-09-16T19:41:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgxMjk3NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r493812975", "bodyText": "invokeCache is unlikely to be null based on the way it's calculated. The exception is unnecessary. If it's null, there will be a functional issue and we'll crash trying to access its member variable.", "author": "liqunl", "createdAt": "2020-09-23T18:45:26Z", "path": "runtime/compiler/compile/J9SymbolReferenceTable.cpp", "diffHunk": "@@ -404,18 +408,37 @@ J9::SymbolReferenceTable::findOrCreateHandleMethodSymbol(TR::ResolvedMethodSymbo\n    if (method)\n       owningMethodSymbol->setMayHaveInlineableCall(true);\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   TR::SymbolReference * symRef = findOrCreateMethodSymbol(owningMethodSymbol->getResolvedMethodIndex(), cpIndex, method, TR::MethodSymbol::Static);\n+#else\n    TR::SymbolReference * symRef = findOrCreateMethodSymbol(owningMethodSymbol->getResolvedMethodIndex(), cpIndex, method, TR::MethodSymbol::ComputedVirtual);\n+#endif /* J9VM_OPT_OPENJDK_METHODHANDLE */\n    return symRef;\n    }\n \n \n TR::SymbolReference *\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+J9::SymbolReferenceTable::findOrCreateCallSiteTableEntrySymbol(TR::ResolvedMethodSymbol * owningMethodSymbol, int32_t callSiteIndex, bool isMemberNameObject)\n+#else\n J9::SymbolReferenceTable::findOrCreateCallSiteTableEntrySymbol(TR::ResolvedMethodSymbol * owningMethodSymbol, int32_t callSiteIndex)\n+#endif\n    {\n    TR::SymbolReference *symRef;\n    TR_SymRefIterator i(aliasBuilder.callSiteTableEntrySymRefs(), self());\n    TR_ResolvedMethod *owningMethod = owningMethodSymbol->getResolvedMethod();\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) owningMethod->callSiteTableEntryAddress(callSiteIndex);\n+   if (!invokeCache)", "originalCommit": "2e35fc27a98f86b2510118e0231bcde9e9f620b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgxMzA2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r493813064", "bodyText": "Same here.", "author": "liqunl", "createdAt": "2020-09-23T18:45:33Z", "path": "runtime/compiler/compile/J9SymbolReferenceTable.cpp", "diffHunk": "@@ -453,12 +476,27 @@ J9::SymbolReferenceTable::findOrCreateCallSiteTableEntrySymbol(TR::ResolvedMetho\n \n \n TR::SymbolReference *\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+J9::SymbolReferenceTable::findOrCreateMethodTypeTableEntrySymbol(TR::ResolvedMethodSymbol * owningMethodSymbol, int32_t cpIndex, bool isMemberNameObject)\n+#else\n J9::SymbolReferenceTable::findOrCreateMethodTypeTableEntrySymbol(TR::ResolvedMethodSymbol * owningMethodSymbol, int32_t cpIndex)\n+#endif\n    {\n    TR::SymbolReference *symRef;\n    TR_SymRefIterator i(aliasBuilder.methodTypeTableEntrySymRefs(), self());\n    TR_ResolvedMethod *owningMethod = owningMethodSymbol->getResolvedMethod();\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) owningMethod->methodTypeTableEntryAddress(cpIndex);\n+   if (!invokeCache)", "originalCommit": "2e35fc27a98f86b2510118e0231bcde9e9f620b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgxMzMwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r493813307", "bodyText": "owningMethod should be this. We're looking at invokedynamic bytecode of this resolved method.", "author": "liqunl", "createdAt": "2020-09-23T18:45:49Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -6757,6 +6757,39 @@ TR_ResolvedJ9Method::getResolvedDynamicMethod(TR::Compilation * comp, I_32 callS\n #else\n    TR_ResolvedMethod *result = NULL;\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   TR_ResolvedMethod * owningMethod = comp->getCurrentMethod();", "originalCommit": "2e35fc27a98f86b2510118e0231bcde9e9f620b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgxMzM4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r493813381", "bodyText": "No need to fail compilation here.", "author": "liqunl", "createdAt": "2020-09-23T18:45:55Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -6757,6 +6757,39 @@ TR_ResolvedJ9Method::getResolvedDynamicMethod(TR::Compilation * comp, I_32 callS\n #else\n    TR_ResolvedMethod *result = NULL;\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   TR_ResolvedMethod * owningMethod = comp->getCurrentMethod();\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) owningMethod->callSiteTableEntryAddress(callSiteIndex);\n+   if (!invokeCache)", "originalCommit": "2e35fc27a98f86b2510118e0231bcde9e9f620b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgxMzU3NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r493813574", "bodyText": "Reading constant pool entries does require a VM access. I think the VM access including the original one can be removed.", "author": "liqunl", "createdAt": "2020-09-23T18:46:07Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -6757,6 +6757,39 @@ TR_ResolvedJ9Method::getResolvedDynamicMethod(TR::Compilation * comp, I_32 callS\n #else\n    TR_ResolvedMethod *result = NULL;\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   TR_ResolvedMethod * owningMethod = comp->getCurrentMethod();\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) owningMethod->callSiteTableEntryAddress(callSiteIndex);\n+   if (!invokeCache)\n+      comp->failCompilation<TR::CompilationException>(\"unable to retrieve side table entry for invokeDynamic\");\n+      {\n+      TR::VMAccessCriticalSection getResolvedDynamicMethod(fej9());", "originalCommit": "2e35fc27a98f86b2510118e0231bcde9e9f620b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgxMzY1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r493813655", "bodyText": "We should use isUnresolvedCallSiteTableEntry to see if entry is unresolved.", "author": "liqunl", "createdAt": "2020-09-23T18:46:13Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -6757,6 +6757,39 @@ TR_ResolvedJ9Method::getResolvedDynamicMethod(TR::Compilation * comp, I_32 callS\n #else\n    TR_ResolvedMethod *result = NULL;\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   TR_ResolvedMethod * owningMethod = comp->getCurrentMethod();\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) owningMethod->callSiteTableEntryAddress(callSiteIndex);\n+   if (!invokeCache)\n+      comp->failCompilation<TR::CompilationException>(\"unable to retrieve side table entry for invokeDynamic\");\n+      {\n+      TR::VMAccessCriticalSection getResolvedDynamicMethod(fej9());\n+\n+      J9Class    *ramClass = constantPoolHdr();\n+      J9ROMClass *romClass = romClassPtr();\n+\n+      if (ramClass->callSites[callSiteIndex] == NULL)", "originalCommit": "2e35fc27a98f86b2510118e0231bcde9e9f620b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgxMzg0NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r493813844", "bodyText": "I think the dummy invoke is the only thing different from current implementation, other code can be shared", "author": "liqunl", "createdAt": "2020-09-23T18:46:27Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -6757,6 +6757,39 @@ TR_ResolvedJ9Method::getResolvedDynamicMethod(TR::Compilation * comp, I_32 callS\n #else\n    TR_ResolvedMethod *result = NULL;\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   TR_ResolvedMethod * owningMethod = comp->getCurrentMethod();\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) owningMethod->callSiteTableEntryAddress(callSiteIndex);\n+   if (!invokeCache)\n+      comp->failCompilation<TR::CompilationException>(\"unable to retrieve side table entry for invokeDynamic\");\n+      {\n+      TR::VMAccessCriticalSection getResolvedDynamicMethod(fej9());\n+\n+      J9Class    *ramClass = constantPoolHdr();\n+      J9ROMClass *romClass = romClassPtr();\n+\n+      if (ramClass->callSites[callSiteIndex] == NULL)\n+         {\n+         J9SRP                 *namesAndSigs = (J9SRP*)J9ROMCLASS_CALLSITEDATA(romClass);\n+         J9ROMNameAndSignature *nameAndSig   = NNSRP_GET(namesAndSigs[callSiteIndex], J9ROMNameAndSignature*);\n+         J9UTF8                *signature    = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n+\n+         TR_OpaqueMethodBlock *dummyInvoke = _fe->getMethodFromName(\"java/lang/invoke/MethodHandle\", \"linkToStatic\", \"([Ljava/lang/Object;)Ljava/lang/Object;\");", "originalCommit": "2e35fc27a98f86b2510118e0231bcde9e9f620b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgxNDE4NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r493814185", "bodyText": "VM access is needed to call targetMethodFromMemberName with object reference.", "author": "liqunl", "createdAt": "2020-09-23T18:46:45Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -6757,6 +6757,39 @@ TR_ResolvedJ9Method::getResolvedDynamicMethod(TR::Compilation * comp, I_32 callS\n #else\n    TR_ResolvedMethod *result = NULL;\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   TR_ResolvedMethod * owningMethod = comp->getCurrentMethod();\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) owningMethod->callSiteTableEntryAddress(callSiteIndex);\n+   if (!invokeCache)\n+      comp->failCompilation<TR::CompilationException>(\"unable to retrieve side table entry for invokeDynamic\");\n+      {\n+      TR::VMAccessCriticalSection getResolvedDynamicMethod(fej9());\n+\n+      J9Class    *ramClass = constantPoolHdr();\n+      J9ROMClass *romClass = romClassPtr();\n+\n+      if (ramClass->callSites[callSiteIndex] == NULL)\n+         {\n+         J9SRP                 *namesAndSigs = (J9SRP*)J9ROMCLASS_CALLSITEDATA(romClass);\n+         J9ROMNameAndSignature *nameAndSig   = NNSRP_GET(namesAndSigs[callSiteIndex], J9ROMNameAndSignature*);\n+         J9UTF8                *signature    = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n+\n+         TR_OpaqueMethodBlock *dummyInvoke = _fe->getMethodFromName(\"java/lang/invoke/MethodHandle\", \"linkToStatic\", \"([Ljava/lang/Object;)Ljava/lang/Object;\");\n+         char * linkToStaticSignature = (char *) comp->trMemory()->allocateMemory((J9UTF8_LENGTH(signature)+40)*sizeof(char), heapAlloc);\n+         char * romMethodSignature = (char *) comp->trMemory()->allocateMemory((J9UTF8_LENGTH(signature))*sizeof(char), heapAlloc);\n+         strcpy(romMethodSignature, utf8Data(signature));\n+         char * sigTokenStart = strtok(romMethodSignature, \")\");\n+         char * sigTokenEnd = strtok(NULL, \")\");\n+         sprintf(linkToStaticSignature, \"%sLjava/lang/Object;Ljava/lang/Object;)%s\", sigTokenStart, sigTokenEnd);\n+         result = _fe->createResolvedMethodWithSignature(comp->trMemory(), dummyInvoke, NULL, linkToStaticSignature, strlen(linkToStaticSignature), owningMethod);\n+         }\n+      else\n+         {\n+         TR_OpaqueMethodBlock * targetJ9MethodBlock = fej9()->targetMethodFromMemberName((uintptr_t) invokeCache->target);", "originalCommit": "2e35fc27a98f86b2510118e0231bcde9e9f620b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgxNDMwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r493814308", "bodyText": "Comments for getResolvedDynamicMethod apply here", "author": "liqunl", "createdAt": "2020-09-23T18:46:52Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -6802,6 +6835,39 @@ TR_ResolvedJ9Method::getResolvedHandleMethod(TR::Compilation * comp, I_32 cpInde\n #else\n    TR_ResolvedMethod *result = NULL;\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)", "originalCommit": "2e35fc27a98f86b2510118e0231bcde9e9f620b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0MzAwMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r493843000", "bodyText": "Same here, should use isUnresolvedMethodTypeTableEntry", "author": "liqunl", "createdAt": "2020-09-23T19:28:41Z", "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -627,7 +662,53 @@ InterpreterEmulator::visitInvokedynamic()\n \n       findTargetAndUpdateInfoForCallsite(callsite);\n       }\n+#endif //J9VM_OPT_OPENJDK_METHODHANDLE\n+   }\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+void\n+InterpreterEmulator::visitInvokehandle()\n+   {\n+\n+   bool isInterface = false;\n+   bool isIndirectCall = false;\n+   TR::Method *interfaceMethod = 0;\n+   TR::TreeTop *callNodeTreeTop = 0;\n+   TR::Node *parent = 0;\n+   TR::Node *callNode = 0;\n+   TR::ResolvedMethodSymbol *resolvedSymbol = 0;\n+   Operand *result = NULL;\n+   int32_t cpIndex = next2Bytes();\n+   TR_ResolvedMethod * owningMethod = _methodSymbol->getResolvedMethod();\n+\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) owningMethod->methodTypeTableEntryAddress(cpIndex);\n+   if (!invokeCache) return; // unresolved", "originalCommit": "2e35fc27a98f86b2510118e0231bcde9e9f620b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0MzA0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r493843043", "bodyText": "invokeCache will never be null, it's just a pointer into the side table. We should use isUnresolvedCallSiteTableEntry", "author": "liqunl", "createdAt": "2020-09-23T19:28:46Z", "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -604,6 +607,38 @@ InterpreterEmulator::visitInvokedynamic()\n    TR::ResolvedMethodSymbol *resolvedSymbol = 0;\n    Operand *result = NULL;\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   int32_t callSiteIndex = next2Bytes();\n+   TR_ResolvedMethod * owningMethod = _methodSymbol->getResolvedMethod();\n+\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) owningMethod->callSiteTableEntryAddress(callSiteIndex);\n+   if (!invokeCache) return; // unresolved", "originalCommit": "2e35fc27a98f86b2510118e0231bcde9e9f620b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0MzIzMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r493843233", "bodyText": "Setting null flag on a node means that the node produce null value at runtime, which is wrong.", "author": "liqunl", "createdAt": "2020-09-23T19:29:05Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -3352,6 +3379,48 @@ TR_J9ByteCodeIlGenerator::genInvokeHandle(TR::SymbolReference *invokeExactSymRef\n    return callNode;\n    }\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+void\n+TR_J9ByteCodeIlGenerator::loadFromSideTableForInvokeDynamic(int32_t callSiteIndex)\n+   {\n+   TR::SymbolReference *appendixSymRef = symRefTab()->findOrCreateCallSiteTableEntrySymbol(_methodSymbol, callSiteIndex);\n+   TR::Node * appendixNode = loadSymbol(TR::aload, appendixSymRef);\n+   if (!appendixSymRef->isUnresolved())\n+      appendixNode->setIsNonNull(true);\n+   else\n+      {\n+      // Appendix being unresolved means the target is also unresolved.\n+      // Instead of creating a call to the adapter method, we construct\n+      // a call to linkToStatic and provide appendix and target as\n+      // additional parameters.\n+      TR::SymbolReference *memberNameSymRef = symRefTab()->findOrCreateCallSiteTableEntrySymbol(_methodSymbol, callSiteIndex, true);\n+      TR::Node * memberNameNode = loadSymbol(TR::aload, memberNameSymRef);\n+      appendixNode->setIsNull(true);", "originalCommit": "2e35fc27a98f86b2510118e0231bcde9e9f620b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0MzI2NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r493843265", "bodyText": "Same here.", "author": "liqunl", "createdAt": "2020-09-23T19:29:09Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -3352,6 +3379,48 @@ TR_J9ByteCodeIlGenerator::genInvokeHandle(TR::SymbolReference *invokeExactSymRef\n    return callNode;\n    }\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+void\n+TR_J9ByteCodeIlGenerator::loadFromSideTableForInvokeDynamic(int32_t callSiteIndex)\n+   {\n+   TR::SymbolReference *appendixSymRef = symRefTab()->findOrCreateCallSiteTableEntrySymbol(_methodSymbol, callSiteIndex);\n+   TR::Node * appendixNode = loadSymbol(TR::aload, appendixSymRef);\n+   if (!appendixSymRef->isUnresolved())\n+      appendixNode->setIsNonNull(true);\n+   else\n+      {\n+      // Appendix being unresolved means the target is also unresolved.\n+      // Instead of creating a call to the adapter method, we construct\n+      // a call to linkToStatic and provide appendix and target as\n+      // additional parameters.\n+      TR::SymbolReference *memberNameSymRef = symRefTab()->findOrCreateCallSiteTableEntrySymbol(_methodSymbol, callSiteIndex, true);\n+      TR::Node * memberNameNode = loadSymbol(TR::aload, memberNameSymRef);\n+      appendixNode->setIsNull(true);\n+      memberNameNode->setIsNull(true);\n+      }\n+   }\n+\n+void\n+TR_J9ByteCodeIlGenerator::loadFromSideTableForInvokeHandle(int32_t cpIndex)\n+   {\n+   TR::SymbolReference *appendixSymRef = symRefTab()->findOrCreateMethodTypeTableEntrySymbol(_methodSymbol, cpIndex);\n+   TR::Node * appendixNode = loadSymbol(TR::aload, appendixSymRef);\n+   if (!appendixSymRef->isUnresolved())\n+      appendixNode->setIsNonNull(true);\n+   else\n+      {\n+      // Appendix being unresolved means the target is also unresolved.\n+      // Instead of creating a call to the adapter method, we construct\n+      // a call to linkToStatic and provide appendix and target as\n+      // additional parameters.\n+      TR::SymbolReference *memberNameSymRef = symRefTab()->findOrCreateMethodTypeTableEntrySymbol(_methodSymbol, cpIndex, true);\n+      TR::Node * memberNameNode = loadSymbol(TR::aload, memberNameSymRef);\n+      appendixNode->setIsNull(true);", "originalCommit": "2e35fc27a98f86b2510118e0231bcde9e9f620b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM0MDA1NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r494340054", "bodyText": "The bit vector is used in the openj9 implementation to transform the call later. The new implementation doesn't need it.", "author": "liqunl", "createdAt": "2020-09-24T13:55:52Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -3272,6 +3272,21 @@ TR_J9ByteCodeIlGenerator::genInvokeDynamic(int32_t callSiteIndex)\n \n    if (comp()->getOption(TR_FullSpeedDebug) && !isPeekingMethod())\n       comp()->failCompilation<J9::FSDHasInvokeHandle>(\"FSD_HAS_INVOKEHANDLE 0\");\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\n+   TR::SymbolReference * targetMethodSymRef = symRefTab()->findOrCreateDynamicMethodSymbol(_methodSymbol, callSiteIndex);\n+\n+   loadFromSideTableForInvokeDynamic(callSiteIndex);\n+\n+   if (comp()->getOption(TR_TraceILGen))\n+      printStack(comp(), _stack, \"(Stack after load from callsite table)\");\n+\n+   TR::Node* callNode = genInvokeDirect(targetMethodSymRef);\n+\n+   _invokeDynamicCalls->set(_bcIndex);", "originalCommit": "2e35fc27a98f86b2510118e0231bcde9e9f620b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6f52d520f623856bdb00f403cde48756a1e3f17c", "url": "https://github.com/eclipse-openj9/openj9/commit/6f52d520f623856bdb00f403cde48756a1e3f17c", "message": "Lookup InvokeCacheEntry from CS and MT tables\n\nCS - Call Site Table\nMT - Method Type Table\n\nLooking up InvokeCacheEntry from CS and MT tables\nis necessary for the OpenJDK MethodHandle implementation.\nInvokeCacheEntry consists of 2 entries per call site. CS table\nlookup will be used for invokeDynamic, and MT table lookup will\nbe used for invokeHandle.\n\nAlso-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2020-09-25T17:48:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0MzU1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r496343556", "bodyText": "You don't need to allocate new memory to store the signature. Like the original code, you can do\nTR_OpaqueMethodBlock *dummyInvoke = _fe->getMethodFromName(\"java/lang/invoke/MethodHandle\", \"linkToStatic\", \"([Ljava/lang/Object;)Ljava/lang/Object;\");\nresult = _fe->createResolvedMethodWithSignature(comp->trMemory(), dummyInvoke, NULL, utf8Data(signature), J9UTF8_LENGTH(signature), this);", "author": "liqunl", "createdAt": "2020-09-29T02:35:42Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -6766,30 +6775,52 @@ TR_ResolvedJ9Method::getResolvedDynamicMethod(TR::Compilation * comp, I_32 callS\n    // the CP entry is resolved, even in rtResolve mode.\n \n    // See if the constant pool entry is already resolved or not\n+\n+   J9Class    *ramClass = constantPoolHdr();\n+   J9ROMClass *romClass = romClassPtr();\n+\n+   if (unresolvedInCP)\n       {\n-      TR::VMAccessCriticalSection getResolvedDynamicMethod(fej9());\n+      // \"unresolvedInCP\" is a bit of a misnomer here, but we can describe\n+      // something equivalent by checking the callSites table.\n+      //\n+      *unresolvedInCP = isUnresolvedCallSiteTableEntry(callSiteIndex);\n+      }\n \n-      J9Class    *ramClass = constantPoolHdr();\n-      J9ROMClass *romClass = romClassPtr();\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) callSiteTableEntryAddress(callSiteIndex);\n \n-      if (unresolvedInCP)\n+   if (!isUnresolvedCallSiteTableEntry(callSiteIndex))\n+      {\n+      TR_OpaqueMethodBlock * targetJ9MethodBlock = NULL;\n          {\n-         // \"unresolvedInCP\" is a bit of a misnomer here, but we can describe\n-         // something equivalent by checking the callSites table.\n-         //\n-         *unresolvedInCP = (ramClass->callSites[callSiteIndex] == NULL);\n+         TR::VMAccessCriticalSection getResolvedDynamicMethod(fej9());\n+         targetJ9MethodBlock = fej9()->targetMethodFromMemberName((uintptr_t) invokeCache->target);\n          }\n-\n-      J9SRP                 *namesAndSigs = (J9SRP*)J9ROMCLASS_CALLSITEDATA(romClass);\n-      J9ROMNameAndSignature *nameAndSig   = NNSRP_GET(namesAndSigs[callSiteIndex], J9ROMNameAndSignature*);\n-      J9UTF8                *signature    = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n-\n-      TR_OpaqueMethodBlock *dummyInvokeExact = _fe->getMethodFromName(\"java/lang/invoke/MethodHandle\", \"invokeExact\", JSR292_invokeExactSig);\n-      result = _fe->createResolvedMethodWithSignature(comp->trMemory(), dummyInvokeExact, NULL, utf8Data(signature), J9UTF8_LENGTH(signature), this);\n+      result = fej9()->createResolvedMethod(comp->trMemory(), targetJ9MethodBlock, this);\n+      return result;\n       }\n+#endif\n \n+   J9SRP                 *namesAndSigs = (J9SRP*)J9ROMCLASS_CALLSITEDATA(romClass);\n+   J9ROMNameAndSignature *nameAndSig   = NNSRP_GET(namesAndSigs[callSiteIndex], J9ROMNameAndSignature*);\n+   J9UTF8                *signature    = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   TR_OpaqueMethodBlock *dummyInvoke = _fe->getMethodFromName(\"java/lang/invoke/MethodHandle\", \"linkToStatic\", \"([Ljava/lang/Object;)Ljava/lang/Object;\");\n+   char * linkToStaticSignature = (char *) comp->trMemory()->allocateMemory((J9UTF8_LENGTH(signature)+40)*sizeof(char), heapAlloc);\n+   char * romMethodSignature = (char *) comp->trMemory()->allocateMemory((J9UTF8_LENGTH(signature))*sizeof(char), heapAlloc);\n+   strcpy(romMethodSignature, utf8Data(signature));\n+   char * sigTokenStart = strtok(romMethodSignature, \")\");\n+   char * sigTokenEnd = strtok(NULL, \")\");\n+   sprintf(linkToStaticSignature, \"%sLjava/lang/Object;Ljava/lang/Object;)%s\", sigTokenStart, sigTokenEnd);\n+   result = _fe->createResolvedMethodWithSignature(comp->trMemory(), dummyInvoke, NULL, linkToStaticSignature, strlen(linkToStaticSignature), this);", "originalCommit": "6f52d520f623856bdb00f403cde48756a1e3f17c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUzODUzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r500538531", "bodyText": "When the call is unresolved, we create a dummy invoke to linkToStatic. linkToStatic is signature polymorphic and therefore can have any number of args for the call, and return any type. We also need to provide the appendix and target objects as the last two args. utf8Data(signature) will just get us the call site signature without accounting for the 2 objects we are providing as args. Therefore, we take the ROM method signature, and split it where we need to insert the 2 additional parameters in the signature. strtok modifies the strings, which is why we make a writable copy of it to work on. I will add some comments explaining the rationale behind this and also reduce the duplication with invokeHandle.", "author": "nbhuiyan", "createdAt": "2020-10-06T19:18:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0MzU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0MzU3Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r496343576", "bodyText": "Same problem here", "author": "liqunl", "createdAt": "2020-09-29T02:35:49Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -6811,21 +6841,45 @@ TR_ResolvedJ9Method::getResolvedHandleMethod(TR::Compilation * comp, I_32 cpInde\n    // the CP entry is resolved, even in rtResolve mode.\n \n    // See if the constant pool entry is already resolved or not\n+\n+   if (unresolvedInCP)\n+      *unresolvedInCP = isUnresolvedMethodTypeTableEntry(cpIndex);\n+\n+   J9ROMMethodRef *romMethodRef = (J9ROMMethodRef *)(cp()->romConstantPool + cpIndex);\n+   J9ROMNameAndSignature *nameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   J9UTF8                *signature    = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) methodTypeTableEntryAddress(cpIndex);\n+\n+   if (!isUnresolvedMethodTypeTableEntry(cpIndex))\n       {\n-      TR::VMAccessCriticalSection getResolvedHandleMethod(fej9());\n+      TR_OpaqueMethodBlock * targetJ9MethodBlock = NULL;\n+         {\n+         VMAccessCriticalSection getResolvedHandleMethod(fej9());\n+         targetJ9MethodBlock = fej9()->targetMethodFromMemberName((uintptr_t) invokeCache->target);\n+         }\n+      result = fej9()->createResolvedMethod(comp->trMemory(), targetJ9MethodBlock, this);\n+      return result;\n+      }\n+   TR_OpaqueMethodBlock *dummyInvoke = _fe->getMethodFromName(\"java/lang/invoke/MethodHandle\", \"linkToStatic\", \"([Ljava/lang/Object;)Ljava/lang/Object;\");\n+   char * linkToStaticSignature = (char *) comp->trMemory()->allocateMemory((J9UTF8_LENGTH(signature)+40)*sizeof(char), heapAlloc);\n+   char * romMethodSignature = (char *) comp->trMemory()->allocateMemory((J9UTF8_LENGTH(signature))*sizeof(char), heapAlloc);\n+   strcpy(romMethodSignature, utf8Data(signature));\n+   char * sigTokenStart = strtok(romMethodSignature, \")\");\n+   char * sigTokenEnd = strtok(NULL, \")\");\n+   sprintf(linkToStaticSignature, \"%sLjava/lang/Object;Ljava/lang/Object;)%s\", sigTokenStart, sigTokenEnd);\n+   result = _fe->createResolvedMethodWithSignature(comp->trMemory(), dummyInvoke, NULL, linkToStaticSignature, strlen(linkToStaticSignature), this);", "originalCommit": "6f52d520f623856bdb00f403cde48756a1e3f17c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUzODc4NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r500538785", "bodyText": "See my response to the other comment.", "author": "nbhuiyan", "createdAt": "2020-10-06T19:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0MzU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwNTkzNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r496805935", "bodyText": "There are a lot of duplication of this code. Can we add a few APIs to get address of member name/appendix and hide the implementation detail of the side table? Something like\nmemberNameAddressFromInvokeDynamicSideTable(int32_t callSiteIndex)\nappendixAddressFromInvokeDynamicSideTable(int32_t callSiteIndex)\nmemberNameAddressFromInvokeHandleSideTable(int32_t cpIndex)\nappendixAddressFromInvokeHandleSideTable(int32_t cpIndex)", "author": "liqunl", "createdAt": "2020-09-29T15:20:22Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -6766,30 +6775,52 @@ TR_ResolvedJ9Method::getResolvedDynamicMethod(TR::Compilation * comp, I_32 callS\n    // the CP entry is resolved, even in rtResolve mode.\n \n    // See if the constant pool entry is already resolved or not\n+\n+   J9Class    *ramClass = constantPoolHdr();\n+   J9ROMClass *romClass = romClassPtr();\n+\n+   if (unresolvedInCP)\n       {\n-      TR::VMAccessCriticalSection getResolvedDynamicMethod(fej9());\n+      // \"unresolvedInCP\" is a bit of a misnomer here, but we can describe\n+      // something equivalent by checking the callSites table.\n+      //\n+      *unresolvedInCP = isUnresolvedCallSiteTableEntry(callSiteIndex);\n+      }\n \n-      J9Class    *ramClass = constantPoolHdr();\n-      J9ROMClass *romClass = romClassPtr();\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) callSiteTableEntryAddress(callSiteIndex);", "originalCommit": "6f52d520f623856bdb00f403cde48756a1e3f17c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM0MzE1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r501343155", "bodyText": "Done.", "author": "nbhuiyan", "createdAt": "2020-10-07T22:21:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwNTkzNQ=="}], "type": "inlineReview"}, {"oid": "84085e19cbd7278227d7f7320fceac31e6dcb11e", "url": "https://github.com/eclipse-openj9/openj9/commit/84085e19cbd7278227d7f7320fceac31e6dcb11e", "message": "Lookup InvokeCacheEntry from CS and MT tables\n\nCS - Call Site Table\nMT - Method Type Table\n\nLooking up InvokeCacheEntry from CS and MT tables\nis necessary for the OpenJDK MethodHandle implementation.\nInvokeCacheEntry consists of 2 entries per call site. CS table\nlookup will be used for invokeDynamic, and MT table lookup will\nbe used for invokeHandle.\n\nAlso-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2020-10-07T22:16:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzMTA0NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r502031044", "bodyText": "This function should return address of the object reference in the table. invokeCache->target is the actual object reference, we should return  &invokeCache->target. Like methodTypeTableEntryAddress and callSiteTableEntryAddress, the return type void *", "author": "liqunl", "createdAt": "2020-10-08T21:46:41Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -6902,6 +6943,36 @@ TR_ResolvedJ9Method::fieldsAreSame(I_32 cpIndex1, TR_ResolvedMethod * m2, I_32 c\n    return false;\n    }\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+uintptr_t\n+TR_ResolvedJ9Method::memberNameAddressFromInvokeDynamicSideTable(int32_t callSiteIndex)\n+   {\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) callSiteTableEntryAddress(callSiteIndex);\n+   return (uintptr_t) invokeCache->target;", "originalCommit": "84085e19cbd7278227d7f7320fceac31e6dcb11e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzMTA3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r502031077", "bodyText": "Same here", "author": "liqunl", "createdAt": "2020-10-08T21:46:45Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -6902,6 +6943,36 @@ TR_ResolvedJ9Method::fieldsAreSame(I_32 cpIndex1, TR_ResolvedMethod * m2, I_32 c\n    return false;\n    }\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+uintptr_t\n+TR_ResolvedJ9Method::memberNameAddressFromInvokeDynamicSideTable(int32_t callSiteIndex)\n+   {\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) callSiteTableEntryAddress(callSiteIndex);\n+   return (uintptr_t) invokeCache->target;\n+   }\n+\n+uintptr_t\n+TR_ResolvedJ9Method::appendixAddressFromInvokeDynamicSideTable(int32_t callSiteIndex)\n+   {\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) callSiteTableEntryAddress(callSiteIndex);\n+   return (uintptr_t) invokeCache->appendix;", "originalCommit": "84085e19cbd7278227d7f7320fceac31e6dcb11e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzMTA5Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r502031097", "bodyText": "Same here", "author": "liqunl", "createdAt": "2020-10-08T21:46:48Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -6902,6 +6943,36 @@ TR_ResolvedJ9Method::fieldsAreSame(I_32 cpIndex1, TR_ResolvedMethod * m2, I_32 c\n    return false;\n    }\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+uintptr_t\n+TR_ResolvedJ9Method::memberNameAddressFromInvokeDynamicSideTable(int32_t callSiteIndex)\n+   {\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) callSiteTableEntryAddress(callSiteIndex);\n+   return (uintptr_t) invokeCache->target;\n+   }\n+\n+uintptr_t\n+TR_ResolvedJ9Method::appendixAddressFromInvokeDynamicSideTable(int32_t callSiteIndex)\n+   {\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) callSiteTableEntryAddress(callSiteIndex);\n+   return (uintptr_t) invokeCache->appendix;\n+   }\n+\n+uintptr_t\n+TR_ResolvedJ9Method::memberNameAddressFromInvokeHandleSideTable(int32_t cpIndex)\n+   {\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) methodTypeTableEntryAddress(cpIndex);\n+   return (uintptr_t) invokeCache->target;", "originalCommit": "84085e19cbd7278227d7f7320fceac31e6dcb11e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzMTEzMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r502031130", "bodyText": "Same here", "author": "liqunl", "createdAt": "2020-10-08T21:46:51Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -6902,6 +6943,36 @@ TR_ResolvedJ9Method::fieldsAreSame(I_32 cpIndex1, TR_ResolvedMethod * m2, I_32 c\n    return false;\n    }\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+uintptr_t\n+TR_ResolvedJ9Method::memberNameAddressFromInvokeDynamicSideTable(int32_t callSiteIndex)\n+   {\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) callSiteTableEntryAddress(callSiteIndex);\n+   return (uintptr_t) invokeCache->target;\n+   }\n+\n+uintptr_t\n+TR_ResolvedJ9Method::appendixAddressFromInvokeDynamicSideTable(int32_t callSiteIndex)\n+   {\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) callSiteTableEntryAddress(callSiteIndex);\n+   return (uintptr_t) invokeCache->appendix;\n+   }\n+\n+uintptr_t\n+TR_ResolvedJ9Method::memberNameAddressFromInvokeHandleSideTable(int32_t cpIndex)\n+   {\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) methodTypeTableEntryAddress(cpIndex);\n+   return (uintptr_t) invokeCache->target;\n+   }\n+\n+uintptr_t\n+TR_ResolvedJ9Method::appendixAddressFromInvokeHandleSideTable(int32_t cpIndex)\n+   {\n+   J9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *) methodTypeTableEntryAddress(cpIndex);\n+   return (uintptr_t) invokeCache->appendix;", "originalCommit": "84085e19cbd7278227d7f7320fceac31e6dcb11e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzMTIwOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r502031209", "bodyText": "Should this be ||? Also, I don't think we need knot to inline the adapter method. Adapter method is static and is known if the callsite is resolved.", "author": "liqunl", "createdAt": "2020-10-08T21:47:00Z", "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -603,13 +606,40 @@ InterpreterEmulator::visitInvokedynamic()\n    TR::Node *callNode = 0;\n    TR::ResolvedMethodSymbol *resolvedSymbol = 0;\n    Operand *result = NULL;\n-\n-   TR_ResolvedMethod * owningMethod = _methodSymbol->getResolvedMethod();\n+   int32_t callSiteIndex = next2Bytes();\n    TR::KnownObjectTable *knot = comp()->getOrCreateKnownObjectTable();\n-   if (knot && !owningMethod->isUnresolvedCallSiteTableEntry(cpIndex))\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   if (!knot && owningMethod->isUnresolvedCallSiteTableEntry(callSiteIndex)) return;", "originalCommit": "84085e19cbd7278227d7f7320fceac31e6dcb11e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzMTI0NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r502031244", "bodyText": "If appendixAddressFromInvokeDynamicSideTable returns the address instead of the appendix object reference, we don't need to take the address of it.\nIf knot is null, just push unknown operand.", "author": "liqunl", "createdAt": "2020-10-08T21:47:06Z", "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -603,13 +606,40 @@ InterpreterEmulator::visitInvokedynamic()\n    TR::Node *callNode = 0;\n    TR::ResolvedMethodSymbol *resolvedSymbol = 0;\n    Operand *result = NULL;\n-\n-   TR_ResolvedMethod * owningMethod = _methodSymbol->getResolvedMethod();\n+   int32_t callSiteIndex = next2Bytes();\n    TR::KnownObjectTable *knot = comp()->getOrCreateKnownObjectTable();\n-   if (knot && !owningMethod->isUnresolvedCallSiteTableEntry(cpIndex))\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   if (!knot && owningMethod->isUnresolvedCallSiteTableEntry(callSiteIndex)) return;\n+\n+   // add appendix object to knot and push to stack\n+   uintptr_t appendixAddress = owningMethod->appendixAddressFromInvokeDynamicSideTable(callSiteIndex);\n+   push(new (trStackMemory()) KnownObjOperand(knot->getOrCreateIndexAt(&appendixAddress)));", "originalCommit": "84085e19cbd7278227d7f7320fceac31e6dcb11e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzMTI2Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r502031266", "bodyText": "If memberNameAddressFromInvokeDynamicSideTable returns an address, we need to dereference the address to get the MemberName. Or you can add a function targetMethodFromMemberNameAt to take address of MemberName, and return you the target method. Inside targetMethodFromMemberNameAt, you need to acquire vm access", "author": "liqunl", "createdAt": "2020-10-08T21:47:10Z", "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -603,13 +606,40 @@ InterpreterEmulator::visitInvokedynamic()\n    TR::Node *callNode = 0;\n    TR::ResolvedMethodSymbol *resolvedSymbol = 0;\n    Operand *result = NULL;\n-\n-   TR_ResolvedMethod * owningMethod = _methodSymbol->getResolvedMethod();\n+   int32_t callSiteIndex = next2Bytes();\n    TR::KnownObjectTable *knot = comp()->getOrCreateKnownObjectTable();\n-   if (knot && !owningMethod->isUnresolvedCallSiteTableEntry(cpIndex))\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   if (!knot && owningMethod->isUnresolvedCallSiteTableEntry(callSiteIndex)) return;\n+\n+   // add appendix object to knot and push to stack\n+   uintptr_t appendixAddress = owningMethod->appendixAddressFromInvokeDynamicSideTable(callSiteIndex);\n+   push(new (trStackMemory()) KnownObjOperand(knot->getOrCreateIndexAt(&appendixAddress)));\n+\n+   TR_J9VMBase *fej9 = comp()->fej9();\n+   TR_OpaqueMethodBlock* targetMethodObj = 0;\n+      {\n+      TR::VMAccessCriticalSection vmAccess(fej9);\n+      targetMethodObj = fej9->targetMethodFromMemberName(owningMethod->memberNameAddressFromInvokeDynamicSideTable(callSiteIndex));", "originalCommit": "84085e19cbd7278227d7f7320fceac31e6dcb11e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzMTMxMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r502031310", "bodyText": "Comments for visitInvokedynamic apply to visitInvokehandle", "author": "liqunl", "createdAt": "2020-10-08T21:47:17Z", "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -621,13 +651,59 @@ InterpreterEmulator::visitInvokedynamic()\n \n       TR_CallSite *callsite = new (comp()->trHeapMemory()) TR_J9MethodHandleCallSite(_calltarget->_calleeMethod, callNodeTreeTop,   parent,\n                                                                         callNode, interfaceMethod, resolvedMethod->classOfMethod(),\n-                                                                        -1, cpIndex, resolvedMethod,\n+                                                                        -1, callSiteIndex, resolvedMethod,\n                                                                         resolvedSymbol, isIndirectCall, isInterface, *_newBCInfo, comp(),\n                                                                         _recursionDepth, allconsts);\n \n       findTargetAndUpdateInfoForCallsite(callsite);\n       }\n+#endif //J9VM_OPT_OPENJDK_METHODHANDLE\n+   }\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+void\n+InterpreterEmulator::visitInvokehandle()", "originalCommit": "84085e19cbd7278227d7f7320fceac31e6dcb11e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzMTM0NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r502031344", "bodyText": "If knot is null, we still need to push an operand (unknown operand) to maintain the right stack shape.", "author": "liqunl", "createdAt": "2020-10-08T21:47:21Z", "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -621,13 +651,59 @@ InterpreterEmulator::visitInvokedynamic()\n \n       TR_CallSite *callsite = new (comp()->trHeapMemory()) TR_J9MethodHandleCallSite(_calltarget->_calleeMethod, callNodeTreeTop,   parent,\n                                                                         callNode, interfaceMethod, resolvedMethod->classOfMethod(),\n-                                                                        -1, cpIndex, resolvedMethod,\n+                                                                        -1, callSiteIndex, resolvedMethod,\n                                                                         resolvedSymbol, isIndirectCall, isInterface, *_newBCInfo, comp(),\n                                                                         _recursionDepth, allconsts);\n \n       findTargetAndUpdateInfoForCallsite(callsite);\n       }\n+#endif //J9VM_OPT_OPENJDK_METHODHANDLE\n+   }\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+void\n+InterpreterEmulator::visitInvokehandle()\n+   {\n+\n+   bool isInterface = false;\n+   bool isIndirectCall = false;\n+   TR::Method *interfaceMethod = 0;\n+   TR::TreeTop *callNodeTreeTop = 0;\n+   TR::Node *parent = 0;\n+   TR::Node *callNode = 0;\n+   TR::ResolvedMethodSymbol *resolvedSymbol = 0;\n+   Operand *result = NULL;\n+   int32_t cpIndex = next2Bytes();\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+   if (owningMethod->isUnresolvedMethodTypeTableEntry(cpIndex)) return; // unresolved\n+\n+   // add appendix object to knot and push to stack\n+   TR::KnownObjectTable *knot = comp()->getOrCreateKnownObjectTable();\n+   uintptr_t appendixAddress = owningMethod->appendixAddressFromInvokeHandleSideTable(cpIndex);\n+   if (knot) push(new (trStackMemory()) KnownObjOperand(knot->getOrCreateIndexAt(&appendixAddress)));", "originalCommit": "84085e19cbd7278227d7f7320fceac31e6dcb11e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7fba7d847d6909f5fd0e33ef6e5cc7538f7d5d2b", "url": "https://github.com/eclipse-openj9/openj9/commit/7fba7d847d6909f5fd0e33ef6e5cc7538f7d5d2b", "message": "Lookup InvokeCacheEntry from CS and MT tables\n\nCS - Call Site Table\nMT - Method Type Table\n\nLooking up InvokeCacheEntry from CS and MT tables\nis necessary for the OpenJDK MethodHandle implementation.\nInvokeCacheEntry consists of 2 entries per call site. CS table\nlookup will be used for invokeDynamic, and MT table lookup will\nbe used for invokeHandle.\n\nAlso-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2020-10-09T21:19:20Z", "type": "forcePushed"}, {"oid": "bc0eacc1cc4d5de5e6376d3c5cefdca2453a4e1b", "url": "https://github.com/eclipse-openj9/openj9/commit/bc0eacc1cc4d5de5e6376d3c5cefdca2453a4e1b", "message": "Lookup InvokeCacheEntry from CS and MT tables\n\nCS - Call Site Table\nMT - Method Type Table\n\nLooking up InvokeCacheEntry from CS and MT tables\nis necessary for the OpenJDK MethodHandle implementation.\nInvokeCacheEntry consists of 2 entries per call site. CS table\nlookup will be used for invokeDynamic, and MT table lookup will\nbe used for invokeHandle.\n\nAlso-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2020-10-09T21:28:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE3MDM0Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r504170342", "bodyText": "We should pass -1 as cpIndex since callSiteIndex is not cpIndex", "author": "liqunl", "createdAt": "2020-10-13T18:27:39Z", "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -621,13 +651,59 @@ InterpreterEmulator::visitInvokedynamic()\n \n       TR_CallSite *callsite = new (comp()->trHeapMemory()) TR_J9MethodHandleCallSite(_calltarget->_calleeMethod, callNodeTreeTop,   parent,\n                                                                         callNode, interfaceMethod, resolvedMethod->classOfMethod(),\n-                                                                        -1, cpIndex, resolvedMethod,\n+                                                                        -1, callSiteIndex, resolvedMethod,", "originalCommit": "bc0eacc1cc4d5de5e6376d3c5cefdca2453a4e1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "614d2660c79fff0ffc63a32446aed191c2889233", "url": "https://github.com/eclipse-openj9/openj9/commit/614d2660c79fff0ffc63a32446aed191c2889233", "message": "Lookup InvokeCacheEntry from CS and MT tables\n\nCS - Call Site Table\nMT - Method Type Table\n\nLooking up InvokeCacheEntry from CS and MT tables\nis necessary for the OpenJDK MethodHandle implementation.\nInvokeCacheEntry consists of 2 entries per call site. CS table\nlookup will be used for invokeDynamic, and MT table lookup will\nbe used for invokeHandle.\n\nAlso-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2020-10-13T18:51:28Z", "type": "forcePushed"}, {"oid": "9996995045f8df61a0a7a07daa548862303be1a4", "url": "https://github.com/eclipse-openj9/openj9/commit/9996995045f8df61a0a7a07daa548862303be1a4", "message": "Fix method arg count store for invokeBasic\n\nThe VM uses the value stored in VMThread.tempSlot to determine\nthe location of the receiver object in the stack for the\nsignature-polymorphic calls to invokeBasic, accessing the entry\nat _sp[VMThread.tempSlot].\nHowever, the JIT was storing the number of args in the\ninvokeBasic call into VMThread.tempSlot, which assumes each arg\nfor the invokeBasic call occupies one stack slot. This was not\nthe case for data types that occupied more than one stack slot,\nfor example, dconst.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2020-12-08T22:48:24Z", "type": "forcePushed"}, {"oid": "81212cf5cf56d503cb9945760acfabc9bb26f466", "url": "https://github.com/eclipse-openj9/openj9/commit/81212cf5cf56d503cb9945760acfabc9bb26f466", "message": "Fix method arg count store for invokeBasic\n\nThe VM uses the value stored in VMThread.tempSlot to determine\nthe location of the receiver object in the stack for the\nsignature-polymorphic calls to invokeBasic, accessing the entry\nat _sp[VMThread.tempSlot].\nHowever, the JIT was storing the number of args in the\ninvokeBasic call into VMThread.tempSlot, which assumes each arg\nfor the invokeBasic call occupies one stack slot. This was not\nthe case for data types that occupied more than one stack slot,\nfor example, doubles.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2020-12-08T22:50:12Z", "type": "forcePushed"}, {"oid": "6fa0da1d17dd2771b2cb187e674b4e92a82320c1", "url": "https://github.com/eclipse-openj9/openj9/commit/6fa0da1d17dd2771b2cb187e674b4e92a82320c1", "message": "Fix method arg count store for invokeBasic\n\nThe VM uses the value stored in VMThread.tempSlot to determine\nthe location of the receiver object in the stack for the\nsignature-polymorphic calls to invokeBasic, accessing the entry\nat _sp[VMThread.tempSlot].\nHowever, the JIT was storing the number of args in the\ninvokeBasic call into VMThread.tempSlot, which assumes each arg\nfor the invokeBasic call occupies one stack slot. This was not\nthe case for data types that occupied more than one stack slot,\nfor example, doubles.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2020-12-10T22:21:41Z", "type": "forcePushed"}, {"oid": "35ed501ff32633267c2aa09ae57d22889cb66d47", "url": "https://github.com/eclipse-openj9/openj9/commit/35ed501ff32633267c2aa09ae57d22889cb66d47", "message": "Fix method arg count store for invokeBasic\n\nThe VM uses the value stored in VMThread.tempSlot to determine\nthe location of the receiver object in the stack for the\nsignature-polymorphic calls to invokeBasic, accessing the entry\nat _sp[VMThread.tempSlot].\nHowever, the JIT was storing the number of args in the\ninvokeBasic call into VMThread.tempSlot, which assumes each arg\nfor the invokeBasic call occupies one stack slot. This was not\nthe case for data types that occupied more than one stack slot,\nfor example, doubles.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2020-12-11T01:58:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU1NDk4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r553554988", "bodyText": "We should do nothing for AOT compile for now.", "author": "liqunl", "createdAt": "2021-01-07T19:55:46Z", "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -594,7 +597,7 @@ InterpreterEmulator::prepareToFindAndCreateCallsites(TR::Block **blocks, flags8_\n void\n InterpreterEmulator::visitInvokedynamic()\n    {\n-   int32_t cpIndex = next2Bytes();\n+", "originalCommit": "35ed501ff32633267c2aa09ae57d22889cb66d47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU1NTIwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r553555207", "bodyText": "We should do nothing for AOT compile for now", "author": "liqunl", "createdAt": "2021-01-07T19:56:13Z", "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -621,13 +656,64 @@ InterpreterEmulator::visitInvokedynamic()\n \n       TR_CallSite *callsite = new (comp()->trHeapMemory()) TR_J9MethodHandleCallSite(_calltarget->_calleeMethod, callNodeTreeTop,   parent,\n                                                                         callNode, interfaceMethod, resolvedMethod->classOfMethod(),\n-                                                                        -1, cpIndex, resolvedMethod,\n+                                                                        -1, -1, resolvedMethod,\n                                                                         resolvedSymbol, isIndirectCall, isInterface, *_newBCInfo, comp(),\n                                                                         _recursionDepth, allconsts);\n \n       findTargetAndUpdateInfoForCallsite(callsite);\n       }\n+#endif //J9VM_OPT_OPENJDK_METHODHANDLE\n+   }\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+void\n+InterpreterEmulator::visitInvokehandle()\n+   {", "originalCommit": "35ed501ff32633267c2aa09ae57d22889cb66d47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d8d99c4852625fddbd83631e19320b90eabcfede", "url": "https://github.com/eclipse-openj9/openj9/commit/d8d99c4852625fddbd83631e19320b90eabcfede", "message": "Fix method arg count store for invokeBasic\n\nThe VM uses the value stored in VMThread.tempSlot to determine\nthe location of the receiver object in the stack for the\nsignature-polymorphic calls to invokeBasic, accessing the entry\nat _sp[VMThread.tempSlot].\nHowever, the JIT was storing the number of args in the\ninvokeBasic call into VMThread.tempSlot, which assumes each arg\nfor the invokeBasic call occupies one stack slot. This was not\nthe case for data types that occupied more than one stack slot,\nfor example, doubles.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2021-01-12T23:01:50Z", "type": "forcePushed"}, {"oid": "6f7090a13b8ec61ad3e76dac472995ad79dd65f0", "url": "https://github.com/eclipse-openj9/openj9/commit/6f7090a13b8ec61ad3e76dac472995ad79dd65f0", "message": "Fix method arg count store for invokeBasic\n\nThe VM uses the value stored in VMThread.tempSlot to determine\nthe location of the receiver object in the stack for the\nsignature-polymorphic calls to invokeBasic, accessing the entry\nat _sp[VMThread.tempSlot].\nHowever, the JIT was storing the number of args in the\ninvokeBasic call into VMThread.tempSlot, which assumes each arg\nfor the invokeBasic call occupies one stack slot. This was not\nthe case for data types that occupied more than one stack slot,\nfor example, doubles.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2021-01-12T23:14:15Z", "type": "forcePushed"}, {"oid": "12d2e3a4427dac1cd53f75e9fd64e904e6bddab2", "url": "https://github.com/eclipse-openj9/openj9/commit/12d2e3a4427dac1cd53f75e9fd64e904e6bddab2", "message": "Fix method arg count store for invokeBasic\n\nThe VM uses the value stored in VMThread.tempSlot to determine\nthe location of the receiver object in the stack for the\nsignature-polymorphic calls to invokeBasic, accessing the entry\nat _sp[VMThread.tempSlot].\nHowever, the JIT was storing the number of args in the\ninvokeBasic call into VMThread.tempSlot, which assumes each arg\nfor the invokeBasic call occupies one stack slot. This was not\nthe case for data types that occupied more than one stack slot,\nfor example, doubles.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2021-01-12T23:16:57Z", "type": "forcePushed"}, {"oid": "a911a19ea6f012d966ae8fd5a8a8a7c7d7307da6", "url": "https://github.com/eclipse-openj9/openj9/commit/a911a19ea6f012d966ae8fd5a8a8a7c7d7307da6", "message": "Fix method arg count store for invokeBasic\n\nThe VM uses the value stored in VMThread.tempSlot to determine\nthe location of the receiver object in the stack for the\nsignature-polymorphic calls to invokeBasic, accessing the entry\nat _sp[VMThread.tempSlot].\nHowever, the JIT was storing the number of args in the\ninvokeBasic call into VMThread.tempSlot, which assumes each arg\nfor the invokeBasic call occupies one stack slot. This was not\nthe case for data types that occupied more than one stack slot,\nfor example, doubles.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2021-01-15T21:25:40Z", "type": "forcePushed"}, {"oid": "d64dff45d01d677f98d2bf7de5ed9aa800d0bafc", "url": "https://github.com/eclipse-openj9/openj9/commit/d64dff45d01d677f98d2bf7de5ed9aa800d0bafc", "message": "Update copyright dates\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2021-01-22T18:19:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzc5MjI5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r563792291", "bodyText": "It would be instructive to have a brief comment here describing what this lowering is doing rather than having to grok the code.  Presumably, this is a meta-argument for invokeBasic?", "author": "0xdaryl", "createdAt": "2021-01-25T15:04:23Z", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1075,8 +1075,19 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n        (node->getSymbol()->castToMethodSymbol()->getRecognizedMethod() == TR::java_lang_invoke_MethodHandle_invokeBasic))\n       {\n       TR::SymbolReference *vmThreadTempSlotSymRef = self()->comp()->getSymRefTab()->findOrCreateVMThreadTempSlotFieldSymbolRef();", "originalCommit": "d64dff45d01d677f98d2bf7de5ed9aa800d0bafc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzc5NzcxOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r563797719", "bodyText": "The logic in the invokeHandle and invokeDynamic cases is 95% identical.  Can you think of a way of combining the internals into a shared function without impacting understanding?    I'm just thinking of the code footprint here...", "author": "0xdaryl", "createdAt": "2021-01-25T15:11:21Z", "path": "runtime/compiler/compile/J9SymbolReferenceTable.cpp", "diffHunk": "@@ -533,6 +557,45 @@ J9::SymbolReferenceTable::findOrCreateMethodTypeTableEntrySymbol(TR::ResolvedMet\n    return symRef;\n    }\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+TR::SymbolReference *\n+J9::SymbolReferenceTable::refineInvokeCacheElementSymRefWithKnownObjectIndexForInvokeHandle(TR::ResolvedMethodSymbol * owningMethodSymbol,  TR::SymbolReference * originalSymRef, int32_t cpIndex, bool isMemberNameObject)\n+   {\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(fe());\n+   TR::VMAccessCriticalSection invokeCacheEntry(comp());\n+   TR::KnownObjectTable *knot = comp()->getOrCreateKnownObjectTable();\n+   if (!knot) return originalSymRef;\n+   TR_ResolvedJ9Method *owningMethod = static_cast<TR_ResolvedJ9Method*>(owningMethodSymbol->getResolvedMethod());\n+   TR::KnownObjectTable::Index arrayElementKnotIndex = TR::KnownObjectTable::UNKNOWN;\n+   if (!isMemberNameObject)\n+      arrayElementKnotIndex = knot->getOrCreateIndex((uintptr_t) owningMethod->appendixElementRefFromInvokeHandleSideTable(cpIndex), true);\n+   else\n+      arrayElementKnotIndex = knot->getOrCreateIndex((uintptr_t) owningMethod->memberNameElementRefFromInvokeHandleSideTable(cpIndex), true);\n+   \n+   TR::SymbolReference *newRef = findOrCreateSymRefWithKnownObject(originalSymRef, arrayElementKnotIndex);\n+   return newRef;\n+   }\n+\n+\n+TR::SymbolReference *\n+J9::SymbolReferenceTable::refineInvokeCacheElementSymRefWithKnownObjectIndexForInvokeDynamic(TR::ResolvedMethodSymbol * owningMethodSymbol,  TR::SymbolReference * originalSymRef, int32_t callSiteIndex, bool isMemberNameObject)\n+   {\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(fe());\n+   TR::VMAccessCriticalSection invokeCacheEntry(comp());\n+   TR::KnownObjectTable *knot = comp()->getOrCreateKnownObjectTable();\n+   if (!knot) return originalSymRef;\n+   TR_ResolvedJ9Method *owningMethod = static_cast<TR_ResolvedJ9Method*>(owningMethodSymbol->getResolvedMethod());\n+   TR::KnownObjectTable::Index arrayElementKnotIndex = TR::KnownObjectTable::UNKNOWN;\n+   if (!isMemberNameObject)\n+      arrayElementKnotIndex = knot->getOrCreateIndex((uintptr_t) owningMethod->appendixElementRefFromInvokeDynamicSideTable(callSiteIndex), true);\n+   else\n+      arrayElementKnotIndex = knot->getOrCreateIndex((uintptr_t) owningMethod->memberNameElementRefFromInvokeDynamicSideTable(callSiteIndex), true);\n+\n+   TR::SymbolReference *newRef = findOrCreateSymRefWithKnownObject(originalSymRef, arrayElementKnotIndex);\n+   return newRef;\n+   }", "originalCommit": "d64dff45d01d677f98d2bf7de5ed9aa800d0bafc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzgwMDA3MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r563800071", "bodyText": "Just curious why there is so much whitespace preceding the function name.  It doesn't match the style of the surrounding code.", "author": "0xdaryl", "createdAt": "2021-01-25T15:14:03Z", "path": "runtime/compiler/env/VMJ9.h", "diffHunk": "@@ -794,6 +794,41 @@ class TR_J9VMBase : public TR_FrontEnd\n     *    VM access is not required\n     */\n    TR_OpaqueMethodBlock* targetMethodFromMethodHandle(TR::Compilation* comp, TR::KnownObjectTable::Index objIndex);\n+\n+   /**\n+    * \\brief\n+    *    Get the signature For MethodHandle.linkToStatic call for unresolved invokehandle\n+    *\n+    *    For unresolved invokeHandle, we do not know the adapter method at\n+    *    compile time. The call is expressed as a call to the signature-polymorphic\n+    *    MethodHandle.linkToStatic method. In addition to the arguments of the original call,\n+    *    we need to provide the target and appendix objects as the last two arguments, in addition\n+    *    to the MethodHandle object as the first argument. Therefore, we need to modify the\n+    *    signature of the original call and adapt it to accept three extra arguments.\n+    *\n+    * \\param comp the current compilation\n+    * \\param romMethodSignature the ROM Method signature to be processed\n+    * \\return char * the signature for linkToStatic\n+    */\n+   char *                getSignatureForLinkToStaticForInvokeHandle(TR::Compilation* comp, J9UTF8* romMethodSignature);", "originalCommit": "d64dff45d01d677f98d2bf7de5ed9aa800d0bafc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzgwMDE4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r563800183", "bodyText": "Just curious why there is so much whitespace preceding the function name.  It doesn't match the style of the surrounding code.", "author": "0xdaryl", "createdAt": "2021-01-25T15:14:11Z", "path": "runtime/compiler/env/VMJ9.h", "diffHunk": "@@ -794,6 +794,41 @@ class TR_J9VMBase : public TR_FrontEnd\n     *    VM access is not required\n     */\n    TR_OpaqueMethodBlock* targetMethodFromMethodHandle(TR::Compilation* comp, TR::KnownObjectTable::Index objIndex);\n+\n+   /**\n+    * \\brief\n+    *    Get the signature For MethodHandle.linkToStatic call for unresolved invokehandle\n+    *\n+    *    For unresolved invokeHandle, we do not know the adapter method at\n+    *    compile time. The call is expressed as a call to the signature-polymorphic\n+    *    MethodHandle.linkToStatic method. In addition to the arguments of the original call,\n+    *    we need to provide the target and appendix objects as the last two arguments, in addition\n+    *    to the MethodHandle object as the first argument. Therefore, we need to modify the\n+    *    signature of the original call and adapt it to accept three extra arguments.\n+    *\n+    * \\param comp the current compilation\n+    * \\param romMethodSignature the ROM Method signature to be processed\n+    * \\return char * the signature for linkToStatic\n+    */\n+   char *                getSignatureForLinkToStaticForInvokeHandle(TR::Compilation* comp, J9UTF8* romMethodSignature);\n+\n+\n+   /**\n+    * \\brief\n+    *    Get the signature for MethodHandle.linkToStatic call for unresolved invokedynamic\n+    *\n+    *    For unresolved invokeDynamic, we do not know the adapter method at\n+    *    compile time. The call is expressed as a call to the signature-polymorphic\n+    *    MethodHandle.linkToStatic method. In addition to the arguments of the original call,\n+    *    we need to provide the target and appendix objects as the last two arguments.\n+    *    Therefore, we need to modify the signature of the original call and adapt it to accept\n+    *    the two extra arguments.\n+    *\n+    * \\param comp the current compilation\n+    * \\param romMethodSignature the ROM Method signature to be processed\n+    * \\return char * the signature for linkToStatic\n+    */\n+   char *                getSignatureForLinkToStaticForInvokeDynamic(TR::Compilation* comp, J9UTF8* romMethodSignature);", "originalCommit": "d64dff45d01d677f98d2bf7de5ed9aa800d0bafc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d4476dca55ab8abe795c7a79fc23a43af08cb4ee", "url": "https://github.com/eclipse-openj9/openj9/commit/d4476dca55ab8abe795c7a79fc23a43af08cb4ee", "message": "Update invokedynamic and invokehandle bytecode handlers\n\nThis changeset updates the handling of invokedynamic and invokehandle\nbytecodes in preparation for migrating to the OpenJDK MethodHandle\nimplementation. The changes are not enabled by default, and are guarded\nin the macro J9VM_OPT_OPENJDK_METHODHANDLE.\n\nThis implementation can handle both resolved and unresolved\ninvokedynamic and invokehandle bytecodes.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2021-01-26T21:50:20Z", "type": "commit"}, {"oid": "2da52e1ec3f12900d1b40f323b8a24c2ac04a33c", "url": "https://github.com/eclipse-openj9/openj9/commit/2da52e1ec3f12900d1b40f323b8a24c2ac04a33c", "message": "Lookup InvokeCacheEntry from CS and MT tables\n\nCS - Call Site Table\nMT - Method Type Table\n\nLooking up InvokeCacheEntry from CS and MT tables\nis necessary for the OpenJDK MethodHandle implementation.\nInvokeCacheEntry consists of 2 entries per call site. CS table\nlookup will be used for invokeDynamic, and MT table lookup will\nbe used for invokeHandle.\n\nAlso-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2021-01-26T21:50:20Z", "type": "commit"}, {"oid": "6c3ce97580cbad7f680f69180d37b3dbd38ef9d2", "url": "https://github.com/eclipse-openj9/openj9/commit/6c3ce97580cbad7f680f69180d37b3dbd38ef9d2", "message": "Update invokeCache entry look-up to use single-slot design\n\nFor invokeDynamic and invokeHandle side table entries in\ncallSiteTable and invokeCache tables respectively, the\ninvoke cache entries are now a 2-element array consisting of:\ninvokeCacheArray[0]= member name object\ninvokeCacheArray[1]= appendix object.\n\nIlGen, inliner, symRefTab, etc.  has been updated to use this\ndesign.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2021-01-26T21:50:20Z", "type": "commit"}, {"oid": "ac201a013a0b400f5115090eb981f2b69eae28fc", "url": "https://github.com/eclipse-openj9/openj9/commit/ac201a013a0b400f5115090eb981f2b69eae28fc", "message": "Fix method arg count store for invokeBasic\n\nThe VM uses the value stored in VMThread.tempSlot to determine\nthe location of the receiver object in the stack for the\nsignature-polymorphic calls to invokeBasic, accessing the entry\nat _sp[VMThread.tempSlot].\nHowever, the JIT was storing the number of args in the\ninvokeBasic call into VMThread.tempSlot, which assumes each arg\nfor the invokeBasic call occupies one stack slot. This was not\nthe case for data types that occupied more than one stack slot,\nfor example, doubles.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2021-01-26T21:50:20Z", "type": "commit"}, {"oid": "99a969a26aa6d4f9e6423e6b03779b826d0e5556", "url": "https://github.com/eclipse-openj9/openj9/commit/99a969a26aa6d4f9e6423e6b03779b826d0e5556", "message": "Update copyright dates\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2021-01-26T21:50:20Z", "type": "commit"}, {"oid": "99a969a26aa6d4f9e6423e6b03779b826d0e5556", "url": "https://github.com/eclipse-openj9/openj9/commit/99a969a26aa6d4f9e6423e6b03779b826d0e5556", "message": "Update copyright dates\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2021-01-26T21:50:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTQwNTY4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r565405681", "bodyText": "arrayElementRef is an object reference, so you need VM access to prevent GC.\nappendixElementRefFromInvokeDynamicSideTable and appendixElementRefFromInvokeHandleSideTable are similar, they all read element from an array, and the logic is simple, I don't think they has to be in a function. Can you do something like the following?\nvoid* invokeCacheLocation = owningMethod->methodTypeTableEntryAddress(callSiteIndex);\nTR::VMAccessCriticalSection getReferenceElement(fej9);\nuintptr_t arrayElementRef = fej9->getReferenceElement(*invokeCacheLocation, 1);\n// The rest of the code", "author": "liqunl", "createdAt": "2021-01-27T15:32:54Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -3353,6 +3377,62 @@ TR_J9ByteCodeIlGenerator::genInvokeHandle(TR::SymbolReference *invokeExactSymRef\n    return callNode;\n    }\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+void\n+TR_J9ByteCodeIlGenerator::loadFromSideTableForInvokeDynamic(int32_t callSiteIndex)\n+   {\n+   TR::SymbolReference *callSiteTableEntrySymRef = symRefTab()->findOrCreateCallSiteTableEntrySymbol(_methodSymbol, callSiteIndex);\n+   loadSymbol(TR::aload, callSiteTableEntrySymRef);\n+   loadConstant(TR::iconst, 1); // appendix object\n+   loadArrayElement(TR::Address, comp()->il.opCodeForIndirectLoad(TR::Address), false);\n+   if (callSiteTableEntrySymRef->isUnresolved())\n+      {\n+      // Appendix being unresolved means the target is also unresolved.\n+      // Instead of creating a call to the adapter method, we construct\n+      // a call to linkToStatic and provide appendix and target as\n+      // additional parameters.\n+      loadSymbol(TR::aload, callSiteTableEntrySymRef);\n+      loadConstant(TR::iconst, 0); // membername object\n+      loadArrayElement(TR::Address, comp()->il.opCodeForIndirectLoad(TR::Address), false);\n+      }\n+   else\n+      {\n+      TR_ResolvedJ9Method* owningMethod = static_cast<TR_ResolvedJ9Method *>(_methodSymbol->getResolvedMethod());\n+      uintptr_t arrayElementRef = (uintptr_t) owningMethod->appendixElementRefFromInvokeDynamicSideTable(callSiteIndex);", "originalCommit": "99a969a26aa6d4f9e6423e6b03779b826d0e5556", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTQ2ODIwMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r565468202", "bodyText": "So we're looking up the side table entry twice, one for creating targetMethodSymRef, one from loadFromSideTableForInvokeDynamic, resolution of the entry might change between the two look up. You may get a method symref for linkToStatic but with number of arguments loaded for resolved case.\nIf targetMethodSymRef is linkToStatic, we should check if the method takes one more argument than needed to see if the method symbol is created for unresolved case. Then load arguments accordingly.", "author": "liqunl", "createdAt": "2021-01-27T16:50:17Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -3273,6 +3273,18 @@ TR_J9ByteCodeIlGenerator::genInvokeDynamic(int32_t callSiteIndex)\n \n    if (comp()->getOption(TR_FullSpeedDebug) && !isPeekingMethod())\n       comp()->failCompilation<J9::FSDHasInvokeHandle>(\"FSD_HAS_INVOKEHANDLE 0\");\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\n+   TR::SymbolReference * targetMethodSymRef = symRefTab()->findOrCreateDynamicMethodSymbol(_methodSymbol, callSiteIndex);\n+\n+   loadFromSideTableForInvokeDynamic(callSiteIndex);", "originalCommit": "99a969a26aa6d4f9e6423e6b03779b826d0e5556", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTQ2OTEwOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r565469109", "bodyText": "Can we use macros for array index for appendix object and MemberName instead of harding code them? The macro can be put into env/JSR292Methods.h", "author": "liqunl", "createdAt": "2021-01-27T16:51:27Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -3353,6 +3377,62 @@ TR_J9ByteCodeIlGenerator::genInvokeHandle(TR::SymbolReference *invokeExactSymRef\n    return callNode;\n    }\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+void\n+TR_J9ByteCodeIlGenerator::loadFromSideTableForInvokeDynamic(int32_t callSiteIndex)\n+   {\n+   TR::SymbolReference *callSiteTableEntrySymRef = symRefTab()->findOrCreateCallSiteTableEntrySymbol(_methodSymbol, callSiteIndex);\n+   loadSymbol(TR::aload, callSiteTableEntrySymRef);\n+   loadConstant(TR::iconst, 1); // appendix object", "originalCommit": "99a969a26aa6d4f9e6423e6b03779b826d0e5556", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTQ4MDE1Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r565480157", "bodyText": "Since we're taking an object ref, VM access should have been acquired by the caller. We need an assert here to ensure that", "author": "liqunl", "createdAt": "2021-01-27T17:05:48Z", "path": "runtime/compiler/compile/J9SymbolReferenceTable.cpp", "diffHunk": "@@ -533,6 +557,23 @@ J9::SymbolReferenceTable::findOrCreateMethodTypeTableEntrySymbol(TR::ResolvedMet\n    return symRef;\n    }\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+TR::SymbolReference *\n+J9::SymbolReferenceTable::refineInvokeCacheElementSymRefWithKnownObjectIndex(TR::ResolvedMethodSymbol * owningMethodSymbol,  TR::SymbolReference * originalSymRef, uintptr_t arrayElementRef)\n+   {", "originalCommit": "99a969a26aa6d4f9e6423e6b03779b826d0e5556", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "49b9631e719ef2f5213e545219e1ca1e31b2fc78", "url": "https://github.com/eclipse-openj9/openj9/commit/49b9631e719ef2f5213e545219e1ca1e31b2fc78", "message": "Misc. cleanup work in OpenJDK MH bytecode handler implementation\n\nThis changeset includes the following:\n* Reduced code duplication in invokeDynamic and invokeHandle\n  bytecode handlers in  ILGen and Inliner\n* Use of macros to index into invokeCacheArray\n* Add/assert VM access where required\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2021-01-29T23:46:58Z", "type": "commit"}, {"oid": "bc78f2ef0debbc255e9fcfb5f1698511b2566ad8", "url": "https://github.com/eclipse-openj9/openj9/commit/bc78f2ef0debbc255e9fcfb5f1698511b2566ad8", "message": "Update mechanism for checking invokedynamic/handle is resolved\n\nWhen unresolved, the adapter method symbol constructed is\nlinkToStatic, which requires 2 additional args on top of\nthe original ROM Method parameters for invokedynamic and\n3 additional args in the case of invokehandle. In both\ncases, when resolved, there would be one less invoke cache\narray element load required as opposed to the unresolved\ncase. This way of checking whether we are dealing with\nan unresolved case would ensure that the right number of\nobjects are pushed even if resolution happens in between\ncreating the target method and loading the invoke cache\nelements.\n\nThe new mechanism relies on passing a pointer to a boolean\nvariable from ILGen that gets set before accessing the call\nsite table or constant pool table.\n\nAlso part of this changeset are some comments specifying\nparts of the new bytecode handler implementation that would\nnot work in AOT and/or JITServer.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2021-02-02T21:17:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA5ODA1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r569098056", "bodyText": "Can you be more specific about \"target\"", "author": "liqunl", "createdAt": "2021-02-03T02:59:39Z", "path": "runtime/compiler/env/VMJ9.h", "diffHunk": "@@ -798,6 +798,41 @@ class TR_J9VMBase : public TR_FrontEnd\n     *    VM access is not required\n     */\n    TR_OpaqueMethodBlock* targetMethodFromMethodHandle(TR::Compilation* comp, TR::KnownObjectTable::Index objIndex);\n+\n+   /**\n+    * \\brief\n+    *    Get the signature For MethodHandle.linkToStatic call for unresolved invokehandle\n+    *\n+    *    For unresolved invokeHandle, we do not know the adapter method at\n+    *    compile time. The call is expressed as a call to the signature-polymorphic\n+    *    MethodHandle.linkToStatic method. In addition to the arguments of the original call,\n+    *    we need to provide the target and appendix objects as the last two arguments, in addition\n+    *    to the MethodHandle object as the first argument. Therefore, we need to modify the\n+    *    signature of the original call and adapt it to accept three extra arguments.\n+    *\n+    * \\param comp the current compilation\n+    * \\param romMethodSignature the ROM Method signature to be processed\n+    * \\return char * the signature for linkToStatic\n+    */\n+   char * getSignatureForLinkToStaticForInvokeHandle(TR::Compilation* comp, J9UTF8* romMethodSignature);\n+\n+\n+   /**\n+    * \\brief\n+    *    Get the signature for MethodHandle.linkToStatic call for unresolved invokedynamic\n+    *\n+    *    For unresolved invokeDynamic, we do not know the adapter method at\n+    *    compile time. The call is expressed as a call to the signature-polymorphic\n+    *    MethodHandle.linkToStatic method. In addition to the arguments of the original call,\n+    *    we need to provide the target and appendix objects as the last two arguments.", "originalCommit": "bc78f2ef0debbc255e9fcfb5f1698511b2566ad8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA5ODkxNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r569098916", "bodyText": "Can we move all OJDK code inside one if defined for code cleanness? It's also worth to add a brief comment why the method for unresolved case is different. Same applies to change in getResolvedHandleMethod", "author": "liqunl", "createdAt": "2021-02-03T03:02:34Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -6875,30 +6878,46 @@ TR_ResolvedJ9Method::getResolvedDynamicMethod(TR::Compilation * comp, I_32 callS\n    // the CP entry is resolved, even in rtResolve mode.\n \n    // See if the constant pool entry is already resolved or not\n-      {\n-      TR::VMAccessCriticalSection getResolvedDynamicMethod(fej9());\n \n-      J9Class    *ramClass = constantPoolHdr();\n-      J9ROMClass *romClass = romClassPtr();\n+   J9Class    *ramClass = constantPoolHdr();\n+   J9ROMClass *romClass = romClassPtr();\n+   bool isUnresolvedEntry = isUnresolvedCallSiteTableEntry(callSiteIndex);\n+   if (unresolvedInCP)\n+      {\n+      // \"unresolvedInCP\" is a bit of a misnomer here, but we can describe\n+      // something equivalent by checking the callSites table.\n+      //\n+      *unresolvedInCP = isUnresolvedEntry;\n+      }\n \n-      if (unresolvedInCP)\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   if (!isUnresolvedEntry)\n+      {\n+      TR_OpaqueMethodBlock * targetJ9MethodBlock = NULL;\n+      uintptr_t * invokeCacheArray = (uintptr_t *) callSiteTableEntryAddress(callSiteIndex);\n          {\n-         // \"unresolvedInCP\" is a bit of a misnomer here, but we can describe\n-         // something equivalent by checking the callSites table.\n-         //\n-         *unresolvedInCP = (ramClass->callSites[callSiteIndex] == NULL);\n+         TR::VMAccessCriticalSection getResolvedDynamicMethod(fej9());\n+         targetJ9MethodBlock = fej9()->targetMethodFromMemberName((uintptr_t) fej9()->getReferenceElement(*invokeCacheArray, JSR292_invokeCacheArrayMemberNameIndex)); // this will not work in AOT or JITServer\n          }\n-\n-      J9SRP                 *namesAndSigs = (J9SRP*)J9ROMCLASS_CALLSITEDATA(romClass);\n-      J9ROMNameAndSignature *nameAndSig   = NNSRP_GET(namesAndSigs[callSiteIndex], J9ROMNameAndSignature*);\n-      J9UTF8                *signature    = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n-\n-      TR_OpaqueMethodBlock *dummyInvokeExact = _fe->getMethodFromName(\"java/lang/invoke/MethodHandle\", \"invokeExact\", JSR292_invokeExactSig);\n-      result = _fe->createResolvedMethodWithSignature(comp->trMemory(), dummyInvokeExact, NULL, utf8Data(signature), J9UTF8_LENGTH(signature), this);\n+      result = fej9()->createResolvedMethod(comp->trMemory(), targetJ9MethodBlock, this);\n+      return result;\n       }\n+#endif\n+\n+   J9SRP                 *namesAndSigs = (J9SRP*)J9ROMCLASS_CALLSITEDATA(romClass);\n+   J9ROMNameAndSignature *nameAndSig   = NNSRP_GET(namesAndSigs[callSiteIndex], J9ROMNameAndSignature*);\n+   J9UTF8                *signature    = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)", "originalCommit": "bc78f2ef0debbc255e9fcfb5f1698511b2566ad8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA5OTQyNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r569099425", "bodyText": "Can getSignatureForLinkToStaticForInvokeDynamic return the length of the signature?", "author": "liqunl", "createdAt": "2021-02-03T03:04:23Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -6875,30 +6878,46 @@ TR_ResolvedJ9Method::getResolvedDynamicMethod(TR::Compilation * comp, I_32 callS\n    // the CP entry is resolved, even in rtResolve mode.\n \n    // See if the constant pool entry is already resolved or not\n-      {\n-      TR::VMAccessCriticalSection getResolvedDynamicMethod(fej9());\n \n-      J9Class    *ramClass = constantPoolHdr();\n-      J9ROMClass *romClass = romClassPtr();\n+   J9Class    *ramClass = constantPoolHdr();\n+   J9ROMClass *romClass = romClassPtr();\n+   bool isUnresolvedEntry = isUnresolvedCallSiteTableEntry(callSiteIndex);\n+   if (unresolvedInCP)\n+      {\n+      // \"unresolvedInCP\" is a bit of a misnomer here, but we can describe\n+      // something equivalent by checking the callSites table.\n+      //\n+      *unresolvedInCP = isUnresolvedEntry;\n+      }\n \n-      if (unresolvedInCP)\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   if (!isUnresolvedEntry)\n+      {\n+      TR_OpaqueMethodBlock * targetJ9MethodBlock = NULL;\n+      uintptr_t * invokeCacheArray = (uintptr_t *) callSiteTableEntryAddress(callSiteIndex);\n          {\n-         // \"unresolvedInCP\" is a bit of a misnomer here, but we can describe\n-         // something equivalent by checking the callSites table.\n-         //\n-         *unresolvedInCP = (ramClass->callSites[callSiteIndex] == NULL);\n+         TR::VMAccessCriticalSection getResolvedDynamicMethod(fej9());\n+         targetJ9MethodBlock = fej9()->targetMethodFromMemberName((uintptr_t) fej9()->getReferenceElement(*invokeCacheArray, JSR292_invokeCacheArrayMemberNameIndex)); // this will not work in AOT or JITServer\n          }\n-\n-      J9SRP                 *namesAndSigs = (J9SRP*)J9ROMCLASS_CALLSITEDATA(romClass);\n-      J9ROMNameAndSignature *nameAndSig   = NNSRP_GET(namesAndSigs[callSiteIndex], J9ROMNameAndSignature*);\n-      J9UTF8                *signature    = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n-\n-      TR_OpaqueMethodBlock *dummyInvokeExact = _fe->getMethodFromName(\"java/lang/invoke/MethodHandle\", \"invokeExact\", JSR292_invokeExactSig);\n-      result = _fe->createResolvedMethodWithSignature(comp->trMemory(), dummyInvokeExact, NULL, utf8Data(signature), J9UTF8_LENGTH(signature), this);\n+      result = fej9()->createResolvedMethod(comp->trMemory(), targetJ9MethodBlock, this);\n+      return result;\n       }\n+#endif\n+\n+   J9SRP                 *namesAndSigs = (J9SRP*)J9ROMCLASS_CALLSITEDATA(romClass);\n+   J9ROMNameAndSignature *nameAndSig   = NNSRP_GET(namesAndSigs[callSiteIndex], J9ROMNameAndSignature*);\n+   J9UTF8                *signature    = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   TR_OpaqueMethodBlock *dummyInvoke = _fe->getMethodFromName(\"java/lang/invoke/MethodHandle\", \"linkToStatic\", \"([Ljava/lang/Object;)Ljava/lang/Object;\");\n+   char * linkToStaticSignature = _fe->getSignatureForLinkToStaticForInvokeDynamic(comp, signature);\n+   result = _fe->createResolvedMethodWithSignature(comp->trMemory(), dummyInvoke, NULL, linkToStaticSignature, J9UTF8_LENGTH(signature) + 37, this);", "originalCommit": "bc78f2ef0debbc255e9fcfb5f1698511b2566ad8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEwOTIzMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r569109232", "bodyText": "Can you be more specific in what target object is? And when it is required?", "author": "liqunl", "createdAt": "2021-02-03T03:37:37Z", "path": "runtime/compiler/ilgen/J9ByteCodeIlGenerator.hpp", "diffHunk": "@@ -122,8 +122,21 @@ class TR_J9ByteCodeIlGenerator : public TR_IlGenerator, public TR_J9ByteCodeIter\n    void         genInvokeVirtual(int32_t);\n    void         genInvokeInterface(int32_t);\n    void         genInvokeDynamic(int32_t callSiteIndex);\n-   TR::Node *    genInvokeHandle(int32_t cpIndex);\n-   TR::Node *    genInvokeHandleGeneric(int32_t cpIndex);\n+   TR::Node *   genInvokeHandle(int32_t cpIndex);\n+   TR::Node *   genInvokeHandleGeneric(int32_t cpIndex);\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   /**\n+    * \\brief\n+    *    Generates IL to load elements from invokeCacheArray, resulting in load of\n+    *    appendix and target objects (if required) into the stack to be used as", "originalCommit": "bc78f2ef0debbc255e9fcfb5f1698511b2566ad8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEwOTQ5OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r569109499", "bodyText": "Is this the static address of the array? Or the java object reference?", "author": "liqunl", "createdAt": "2021-02-03T03:38:21Z", "path": "runtime/compiler/ilgen/J9ByteCodeIlGenerator.hpp", "diffHunk": "@@ -122,8 +122,21 @@ class TR_J9ByteCodeIlGenerator : public TR_IlGenerator, public TR_J9ByteCodeIter\n    void         genInvokeVirtual(int32_t);\n    void         genInvokeInterface(int32_t);\n    void         genInvokeDynamic(int32_t callSiteIndex);\n-   TR::Node *    genInvokeHandle(int32_t cpIndex);\n-   TR::Node *    genInvokeHandleGeneric(int32_t cpIndex);\n+   TR::Node *   genInvokeHandle(int32_t cpIndex);\n+   TR::Node *   genInvokeHandleGeneric(int32_t cpIndex);\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   /**\n+    * \\brief\n+    *    Generates IL to load elements from invokeCacheArray, resulting in load of\n+    *    appendix and target objects (if required) into the stack to be used as\n+    *    parameters for adapter method call node.\n+    *\n+    * \\param tableEntrySymRef the symref representing the invokeCacheArray\n+    * \\param invokeCacheArray the invokeCacheArray", "originalCommit": "bc78f2ef0debbc255e9fcfb5f1698511b2566ad8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTc2NjU4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r569766581", "bodyText": "we are passing the entryLocation (which is the static address of the array) here, which we can use to get the Java object ref", "author": "nbhuiyan", "createdAt": "2021-02-03T21:36:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEwOTQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTExMjQyNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r569112427", "bodyText": "Opcode for indirect field load and indirect array load can be different, although for address type it's the same, we should still use il.opCodeForIndirectArrayLoad", "author": "liqunl", "createdAt": "2021-02-03T03:48:24Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -3353,6 +3384,35 @@ TR_J9ByteCodeIlGenerator::genInvokeHandle(TR::SymbolReference *invokeExactSymRef\n    return callNode;\n    }\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+void\n+TR_J9ByteCodeIlGenerator::loadInvokeCacheArrayElements(TR::SymbolReference *tableEntrySymRef, uintptr_t * invokeCacheArray, bool isUnresolved)\n+   {\n+   loadSymbol(TR::aload, tableEntrySymRef);\n+   loadConstant(TR::iconst, JSR292_invokeCacheArrayAppendixIndex);\n+   loadArrayElement(TR::Address, comp()->il.opCodeForIndirectLoad(TR::Address), false);\n+   if (isUnresolved)\n+      {\n+      loadSymbol(TR::aload, tableEntrySymRef);\n+      loadConstant(TR::iconst, JSR292_invokeCacheArrayMemberNameIndex);\n+      loadArrayElement(TR::Address, comp()->il.opCodeForIndirectLoad(TR::Address), false);", "originalCommit": "bc78f2ef0debbc255e9fcfb5f1698511b2566ad8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTExMzY4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r569113682", "bodyText": "Can you add more comments to explain what this code does?", "author": "liqunl", "createdAt": "2021-02-03T03:53:04Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -3353,6 +3384,35 @@ TR_J9ByteCodeIlGenerator::genInvokeHandle(TR::SymbolReference *invokeExactSymRef\n    return callNode;\n    }\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+void\n+TR_J9ByteCodeIlGenerator::loadInvokeCacheArrayElements(TR::SymbolReference *tableEntrySymRef, uintptr_t * invokeCacheArray, bool isUnresolved)\n+   {\n+   loadSymbol(TR::aload, tableEntrySymRef);\n+   loadConstant(TR::iconst, JSR292_invokeCacheArrayAppendixIndex);\n+   loadArrayElement(TR::Address, comp()->il.opCodeForIndirectLoad(TR::Address), false);\n+   if (isUnresolved)\n+      {\n+      loadSymbol(TR::aload, tableEntrySymRef);\n+      loadConstant(TR::iconst, JSR292_invokeCacheArrayMemberNameIndex);\n+      loadArrayElement(TR::Address, comp()->il.opCodeForIndirectLoad(TR::Address), false);\n+      }\n+   else\n+      {\n+      TR_ResolvedJ9Method* owningMethod = static_cast<TR_ResolvedJ9Method *>(_methodSymbol->getResolvedMethod());", "originalCommit": "bc78f2ef0debbc255e9fcfb5f1698511b2566ad8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTExNDQ1Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r569114453", "bodyText": "It's worth to add a comments to show the call generated for resolved and unresolved case", "author": "liqunl", "createdAt": "2021-02-03T03:55:39Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -3273,6 +3273,20 @@ TR_J9ByteCodeIlGenerator::genInvokeDynamic(int32_t callSiteIndex)\n \n    if (comp()->getOption(TR_FullSpeedDebug) && !isPeekingMethod())\n       comp()->failCompilation<J9::FSDHasInvokeHandle>(\"FSD_HAS_INVOKEHANDLE 0\");\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   bool isUnresolved;\n+   TR::SymbolReference * targetMethodSymRef = symRefTab()->findOrCreateDynamicMethodSymbol(_methodSymbol, callSiteIndex, &isUnresolved);", "originalCommit": "bc78f2ef0debbc255e9fcfb5f1698511b2566ad8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTExOTI4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r569119282", "bodyText": "We shouldn't pass true to getOrCreateIndex as appendix element is not an array", "author": "liqunl", "createdAt": "2021-02-03T04:12:57Z", "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -621,14 +629,72 @@ InterpreterEmulator::visitInvokedynamic()\n \n       TR_CallSite *callsite = new (comp()->trHeapMemory()) TR_J9MethodHandleCallSite(_calltarget->_calleeMethod, callNodeTreeTop,   parent,\n                                                                         callNode, interfaceMethod, resolvedMethod->classOfMethod(),\n-                                                                        -1, cpIndex, resolvedMethod,\n+                                                                        -1, -1, resolvedMethod,\n                                                                         resolvedSymbol, isIndirectCall, isInterface, *_newBCInfo, comp(),\n                                                                         _recursionDepth, allconsts);\n \n       findTargetAndUpdateInfoForCallsite(callsite);\n       }\n+#endif //J9VM_OPT_OPENJDK_METHODHANDLE\n+   }\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+void\n+InterpreterEmulator::visitInvokehandle()\n+   {\n+   int32_t cpIndex = next2Bytes();\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+   if (owningMethod->isUnresolvedMethodTypeTableEntry(cpIndex) || comp()->compileRelocatableCode()) return; // do nothing if unresolved or is AOT\n+   uintptr_t * invokeCacheArray = (uintptr_t *) owningMethod->methodTypeTableEntryAddress(cpIndex);\n+   updateKnotAndCreateCallSiteUsingInvokeCacheArray(owningMethod, invokeCacheArray, cpIndex);\n+   }\n+\n+void\n+InterpreterEmulator::updateKnotAndCreateCallSiteUsingInvokeCacheArray(TR_ResolvedJ9Method* owningMethod, uintptr_t * invokeCacheArray, int32_t cpIndex)\n+   {\n+   TR_J9VMBase *fej9 = comp()->fej9();\n+   if (_iteratorWithState)\n+      {\n+      TR::KnownObjectTable *knot = comp()->getOrCreateKnownObjectTable();\n+      if (knot)\n+         {\n+         TR::VMAccessCriticalSection vmAccess(fej9);\n+         uintptr_t appendixElementRef = (uintptr_t) fej9->getReferenceElement(*invokeCacheArray, JSR292_invokeCacheArrayAppendixIndex); // dereferencing invokeCacheArray cannot be done in JITServer\n+         push(new (trStackMemory()) KnownObjOperand(knot->getOrCreateIndex(appendixElementRef, true)));", "originalCommit": "bc78f2ef0debbc255e9fcfb5f1698511b2566ad8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEyMDU2Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r569120562", "bodyText": "We should also return for JITServer. Same for visitInvokehandle", "author": "liqunl", "createdAt": "2021-02-03T04:17:41Z", "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -594,7 +598,13 @@ InterpreterEmulator::prepareToFindAndCreateCallsites(TR::Block **blocks, flags8_\n void\n InterpreterEmulator::visitInvokedynamic()\n    {\n-   int32_t cpIndex = next2Bytes();\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+   int32_t callSiteIndex = next2Bytes();\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   if (owningMethod->isUnresolvedCallSiteTableEntry(callSiteIndex) || comp()->compileRelocatableCode()) return; // do nothing if unresolved or is AOT", "originalCommit": "bc78f2ef0debbc255e9fcfb5f1698511b2566ad8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bb53bf4194b9c4e0115252477376680b85a0ec09", "url": "https://github.com/eclipse-openj9/openj9/commit/bb53bf4194b9c4e0115252477376680b85a0ec09", "message": "Update mechanism for checking invokedynamic/handle is resolved\n\nWhen unresolved, the adapter method symbol constructed is\nlinkToStatic, which requires 2 additional args on top of\nthe original ROM Method parameters for invokedynamic and\n3 additional args in the case of invokehandle. In both\ncases, when resolved, there would be one less invoke cache\narray element load required as opposed to the unresolved\ncase. This way of checking whether we are dealing with\nan unresolved case would ensure that the right number of\nobjects are pushed even if resolution happens in between\ncreating the target method and loading the invoke cache\nelements.\n\nThe new mechanism relies on passing a pointer to a boolean\nvariable from ILGen that gets set before accessing the call\nsite table or constant pool table.\n\nFurthermore, comments have been added in ILGen to\ndemonstrate the different kinds of call nodes created for\nresolved and unresolved invokedynamic and invokehandle\nbytecodes.\n\nIncluded as part of this changeset are some additional\nclarifications in existing comments as well as comments/checks\nwhere needed for parts of the new bytecode handler implementation\nthat would not work in AOT and/or JITServer.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2021-02-03T22:58:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTM0NDc4Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r571344786", "bodyText": "We should mention it is the number of arg slots minus the receiver slot", "author": "liqunl", "createdAt": "2021-02-06T02:45:25Z", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1074,9 +1074,23 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n        !node->getSymbol()->castToMethodSymbol()->isHelper() &&\n        (node->getSymbol()->castToMethodSymbol()->getRecognizedMethod() == TR::java_lang_invoke_MethodHandle_invokeBasic))\n       {\n+      // invokeBasic is signature-polymorphic, so the location of the method handle receiver object on the stack will depend\n+      // on the number of arguments in the invokeBasic call. Therefore, the number of stack slots used by the args of the call", "originalCommit": "bb53bf4194b9c4e0115252477376680b85a0ec09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTQzNjM2Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r571436367", "bodyText": "With the single slot design, the ResolveCHK will be on the load of side table entry, i.e. the trees will look like\nResolveCHK\n  aload <CallSiteTableEntry @<callSiteIndex>>\ntreetop\n  aloadi <appendix object>  // array-shadow from CallSiteTableEntry\n  ...\ntreetop\n  aloadi <memberNameObject>  // array-shadow from CallSiteTableEntry", "author": "liqunl", "createdAt": "2021-02-06T13:36:05Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -3273,6 +3273,45 @@ TR_J9ByteCodeIlGenerator::genInvokeDynamic(int32_t callSiteIndex)\n \n    if (comp()->getOption(TR_FullSpeedDebug) && !isPeekingMethod())\n       comp()->failCompilation<J9::FSDHasInvokeHandle>(\"FSD_HAS_INVOKEHANDLE 0\");\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\n+   // Call generated when call site table entry is resolved:\n+   // -----------------------------------------------------\n+   // call <target method obtained from memberName object>\n+   //    arg0\n+   //    arg1\n+   //    ...\n+   //    aloadi <appendix object>\n+   // ------------------------------------------------------\n+   // Call generated when call site table entry is unresolved:\n+   // ------------------------------------------------------\n+   // ResolveCHK", "originalCommit": "bb53bf4194b9c4e0115252477376680b85a0ec09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTQ1NzkzNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r571457934", "bodyText": "@dmitry-ten Should this query be guarded by J9VM_OPT_JITSERVER macro?", "author": "liqunl", "createdAt": "2021-02-06T16:56:41Z", "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -594,7 +598,15 @@ InterpreterEmulator::prepareToFindAndCreateCallsites(TR::Block **blocks, flags8_\n void\n InterpreterEmulator::visitInvokedynamic()\n    {\n-   int32_t cpIndex = next2Bytes();\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+   int32_t callSiteIndex = next2Bytes();\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   if (owningMethod->isUnresolvedCallSiteTableEntry(callSiteIndex) ||\n+         comp()->compileRelocatableCode() ||\n+         comp()->isOutOfProcessCompilation()) return; // do nothing if unresolved, is AOT or JITServer compilation", "originalCommit": "bb53bf4194b9c4e0115252477376680b85a0ec09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTQ3ODc1Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r571478752", "bodyText": "Right, it should be.", "author": "dmitry-ten", "createdAt": "2021-02-06T19:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTQ1NzkzNA=="}], "type": "inlineReview"}, {"oid": "91a0852ed04f27efe4861fadb37f30b10daf85d0", "url": "https://github.com/eclipse-openj9/openj9/commit/91a0852ed04f27efe4861fadb37f30b10daf85d0", "message": "Update mechanism for checking invokedynamic/handle is resolved\n\nWhen unresolved, the adapter method symbol constructed is\nlinkToStatic, which requires 2 additional args on top of\nthe original ROM Method parameters for invokedynamic and\n3 additional args in the case of invokehandle. In both\ncases, when resolved, there would be one less invoke cache\narray element load required as opposed to the unresolved\ncase. This way of checking whether we are dealing with\nan unresolved case would ensure that the right number of\nobjects are pushed even if resolution happens in between\ncreating the target method and loading the invoke cache\nelements.\n\nThe new mechanism relies on passing a pointer to a boolean\nvariable from ILGen that gets set before accessing the call\nsite table or constant pool table.\n\nFurthermore, comments have been added in ILGen to\ndemonstrate the different kinds of call nodes created for\nresolved and unresolved invokedynamic and invokehandle\nbytecodes.\n\nIncluded as part of this changeset are some additional\nclarifications in existing comments as well as comments/checks\nwhere needed for parts of the new bytecode handler implementation\nthat would not work in AOT and/or JITServer.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2021-02-08T17:46:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzI4NTk4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r573285981", "bodyText": "Should this be MethodTypeTableEntry and cpIndex?", "author": "liqunl", "createdAt": "2021-02-09T22:15:18Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -3311,6 +3354,48 @@ TR_J9ByteCodeIlGenerator::genInvokeHandle(int32_t cpIndex)\n \n    if (comp()->getOption(TR_FullSpeedDebug) && !isPeekingMethod())\n       comp()->failCompilation<J9::FSDHasInvokeHandle>(\"FSD_HAS_INVOKEHANDLE 1\");\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+   // Call generated when methodType table entry is resolved:\n+   // -----------------------------------------------------\n+   // call <target method obtained from memberName object>\n+   //    aload  <Ljava/lang/invoke/MethodHandle;>\n+   //    arg0\n+   //    arg1\n+   //    ...\n+   //    aloadi <appendix object>\n+   // ------------------------------------------------------\n+   // Call generated when methodType table entry is unresolved:\n+   // ------------------------------------------------------\n+   // ResolveCHK\n+   //    aload <CallSiteTableEntry @<callSiteIndex>>", "originalCommit": "91a0852ed04f27efe4861fadb37f30b10daf85d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk3MDg2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r573970864", "bodyText": "good catch!", "author": "nbhuiyan", "createdAt": "2021-02-10T18:27:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzI4NTk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQwODY4Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r573408686", "bodyText": "owningMethod and owningMethodSymbol are not used", "author": "liqunl", "createdAt": "2021-02-10T02:48:47Z", "path": "runtime/compiler/compile/J9SymbolReferenceTable.cpp", "diffHunk": "@@ -533,6 +556,23 @@ J9::SymbolReferenceTable::findOrCreateMethodTypeTableEntrySymbol(TR::ResolvedMet\n    return symRef;\n    }\n \n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+TR::SymbolReference *\n+J9::SymbolReferenceTable::refineInvokeCacheElementSymRefWithKnownObjectIndex(TR::ResolvedMethodSymbol * owningMethodSymbol,  TR::SymbolReference * originalSymRef, uintptr_t arrayElementRef)\n+   {\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(fe());\n+   TR_ASSERT(fej9->haveAccess(), \"Require VM access to be acquired by caller\");\n+   TR::KnownObjectTable *knot = comp()->getOrCreateKnownObjectTable();\n+   if (!knot) return originalSymRef;\n+   TR_ResolvedJ9Method *owningMethod = static_cast<TR_ResolvedJ9Method*>(owningMethodSymbol->getResolvedMethod());", "originalCommit": "91a0852ed04f27efe4861fadb37f30b10daf85d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk3MTIwMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r573971203", "bodyText": "this was left over from a previous revision. fixed.", "author": "nbhuiyan", "createdAt": "2021-02-10T18:28:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQwODY4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQwOTc2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r573409768", "bodyText": "Can we have a comment on what 55 is for?", "author": "liqunl", "createdAt": "2021-02-10T02:52:15Z", "path": "runtime/compiler/env/VMJ9.cpp", "diffHunk": "@@ -4853,6 +4853,48 @@ TR_J9VMBase::targetMethodFromMethodHandle(uintptr_t methodHandle)\n       \"vmentry\",             \"Ljava/lang/invoke/MemberName;\");\n    return targetMethodFromMemberName(vmentry);\n    }\n+\n+char *\n+TR_J9VMBase::getSignatureForLinkToStaticForInvokeHandle(TR::Compilation* comp, J9UTF8* romMethodSignature, int32_t &signatureLength)\n+   {\n+   signatureLength = J9UTF8_LENGTH(romMethodSignature) + 55;", "originalCommit": "91a0852ed04f27efe4861fadb37f30b10daf85d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQwOTg3Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10607#discussion_r573409872", "bodyText": "Same here, a comment to explain 37", "author": "liqunl", "createdAt": "2021-02-10T02:52:38Z", "path": "runtime/compiler/env/VMJ9.cpp", "diffHunk": "@@ -4853,6 +4853,48 @@ TR_J9VMBase::targetMethodFromMethodHandle(uintptr_t methodHandle)\n       \"vmentry\",             \"Ljava/lang/invoke/MemberName;\");\n    return targetMethodFromMemberName(vmentry);\n    }\n+\n+char *\n+TR_J9VMBase::getSignatureForLinkToStaticForInvokeHandle(TR::Compilation* comp, J9UTF8* romMethodSignature, int32_t &signatureLength)\n+   {\n+   signatureLength = J9UTF8_LENGTH(romMethodSignature) + 55;\n+   char * signatureString = (char *) comp->trMemory()->allocateMemory((J9UTF8_LENGTH(romMethodSignature)+1)*sizeof(char), heapAlloc);\n+   char * linkToStaticSignature = (char *) comp->trMemory()->allocateMemory((J9UTF8_LENGTH(romMethodSignature)+55)*sizeof(char), heapAlloc);\n+   strcpy(signatureString, utf8Data(romMethodSignature));\n+   if (strncmp(signatureString, \"()\", 2) == 0)\n+      {\n+      char * returnTypeToken = strtok(signatureString, \"()\");\n+      sprintf(linkToStaticSignature, \"(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)%s\", returnTypeToken);\n+      }\n+   else\n+      {\n+      char * sigTokenStart = strtok(signatureString, \"()\");\n+      char * sigTokenEnd = strtok(NULL, \"()\");\n+      sprintf(linkToStaticSignature, \"(Ljava/lang/Object;%sLjava/lang/Object;Ljava/lang/Object;)%s\", sigTokenStart, sigTokenEnd);\n+      }\n+   return linkToStaticSignature;\n+   }\n+\n+char *\n+TR_J9VMBase::getSignatureForLinkToStaticForInvokeDynamic(TR::Compilation* comp, J9UTF8* romMethodSignature, int32_t &signatureLength)\n+   {\n+   signatureLength = J9UTF8_LENGTH(romMethodSignature) + 37;", "originalCommit": "91a0852ed04f27efe4861fadb37f30b10daf85d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b713a099888116bc96eb089c48bf4ddbd4b7a7bf", "url": "https://github.com/eclipse-openj9/openj9/commit/b713a099888116bc96eb089c48bf4ddbd4b7a7bf", "message": "Update mechanism for checking invokedynamic/handle is resolved\n\nWhen unresolved, the adapter method symbol constructed is\nlinkToStatic, which requires 2 additional args on top of\nthe original ROM Method parameters for invokedynamic and\n3 additional args in the case of invokehandle. In both\ncases, when resolved, there would be one less invoke cache\narray element load required as opposed to the unresolved\ncase. This way of checking whether we are dealing with\nan unresolved case would ensure that the right number of\nobjects are pushed even if resolution happens in between\ncreating the target method and loading the invoke cache\nelements.\n\nThe new mechanism relies on passing a pointer to a boolean\nvariable from ILGen that gets set before accessing the call\nsite table or constant pool table.\n\nFurthermore, comments have been added in ILGen to\ndemonstrate the different kinds of call nodes created for\nresolved and unresolved invokedynamic and invokehandle\nbytecodes.\n\nIncluded as part of this changeset are some additional\nclarifications in existing comments as well as comments/checks\nwhere needed for parts of the new bytecode handler implementation\nthat would not work in AOT and/or JITServer.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2021-02-10T18:26:49Z", "type": "forcePushed"}, {"oid": "a465fc3cac2b176f4807a057449b6d648d9ee9a8", "url": "https://github.com/eclipse-openj9/openj9/commit/a465fc3cac2b176f4807a057449b6d648d9ee9a8", "message": "Update mechanism for checking invokedynamic/handle is resolved\n\nWhen unresolved, the adapter method symbol constructed is\nlinkToStatic, which requires 2 additional args on top of\nthe original ROM Method parameters for invokedynamic and\n3 additional args in the case of invokehandle. In both\ncases, when resolved, there would be one less invoke cache\narray element load required as opposed to the unresolved\ncase. This way of checking whether we are dealing with\nan unresolved case would ensure that the right number of\nobjects are pushed even if resolution happens in between\ncreating the target method and loading the invoke cache\nelements.\n\nThe new mechanism relies on passing a pointer to a boolean\nvariable from ILGen that gets set before accessing the call\nsite table or constant pool table.\n\nFurthermore, comments have been added in ILGen to\ndemonstrate the different kinds of call nodes created for\nresolved and unresolved invokedynamic and invokehandle\nbytecodes.\n\nIncluded as part of this changeset are some additional\nclarifications in existing comments as well as comments/checks\nwhere needed for parts of the new bytecode handler implementation\nthat would not work in AOT and/or JITServer.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2021-02-12T01:19:28Z", "type": "commit"}, {"oid": "a465fc3cac2b176f4807a057449b6d648d9ee9a8", "url": "https://github.com/eclipse-openj9/openj9/commit/a465fc3cac2b176f4807a057449b6d648d9ee9a8", "message": "Update mechanism for checking invokedynamic/handle is resolved\n\nWhen unresolved, the adapter method symbol constructed is\nlinkToStatic, which requires 2 additional args on top of\nthe original ROM Method parameters for invokedynamic and\n3 additional args in the case of invokehandle. In both\ncases, when resolved, there would be one less invoke cache\narray element load required as opposed to the unresolved\ncase. This way of checking whether we are dealing with\nan unresolved case would ensure that the right number of\nobjects are pushed even if resolution happens in between\ncreating the target method and loading the invoke cache\nelements.\n\nThe new mechanism relies on passing a pointer to a boolean\nvariable from ILGen that gets set before accessing the call\nsite table or constant pool table.\n\nFurthermore, comments have been added in ILGen to\ndemonstrate the different kinds of call nodes created for\nresolved and unresolved invokedynamic and invokehandle\nbytecodes.\n\nIncluded as part of this changeset are some additional\nclarifications in existing comments as well as comments/checks\nwhere needed for parts of the new bytecode handler implementation\nthat would not work in AOT and/or JITServer.\n\nSigned-off-by: Nazim Bhuiyan <nubhuiyan@ibm.com>", "committedDate": "2021-02-12T01:19:28Z", "type": "forcePushed"}]}