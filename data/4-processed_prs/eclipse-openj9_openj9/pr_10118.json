{"pr_number": 10118, "pr_title": "Prefetch resolved implementor methods for CHTable", "pr_createdAt": "2020-07-08T16:44:29Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10118", "timeline": [{"oid": "104b3f8c86e82d9336d36ddbb29c33b3492f2e8b", "url": "https://github.com/eclipse-openj9/openj9/commit/104b3f8c86e82d9336d36ddbb29c33b3492f2e8b", "message": "Coalesce messages in interprocedural analyzer\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-08T16:50:48Z", "type": "forcePushed"}, {"oid": "c36959f16d807e52256f825610eef35d2cb4207a", "url": "https://github.com/eclipse-openj9/openj9/commit/c36959f16d807e52256f825610eef35d2cb4207a", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - 'CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-08T17:15:56Z", "type": "forcePushed"}, {"oid": "112f226faf7d190eabbbec3c2a001265339e4c0e", "url": "https://github.com/eclipse-openj9/openj9/commit/112f226faf7d190eabbbec3c2a001265339e4c0e", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - 'CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-08T17:27:28Z", "type": "forcePushed"}, {"oid": "7ef83319a2385ec4104b9250730d95893baa6699", "url": "https://github.com/eclipse-openj9/openj9/commit/7ef83319a2385ec4104b9250730d95893baa6699", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-08T17:29:25Z", "type": "forcePushed"}, {"oid": "8b7d0138eb4e46d77fffcd952ad449e46f6e15c7", "url": "https://github.com/eclipse-openj9/openj9/commit/8b7d0138eb4e46d77fffcd952ad449e46f6e15c7", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-09T16:51:01Z", "type": "forcePushed"}, {"oid": "b6d99e5dc2844531bfc63db8e540375b28cd48d6", "url": "https://github.com/eclipse-openj9/openj9/commit/b6d99e5dc2844531bfc63db8e540375b28cd48d6", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-14T19:33:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcyNjMyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454726326", "bodyText": "We should use a reference for these two fields", "author": "mpirvu", "createdAt": "2020-07-15T00:51:17Z", "path": "runtime/compiler/env/j9methodServer.cpp", "diffHunk": "@@ -1954,6 +1954,40 @@ TR_ResolvedJ9JITServerMethod::cacheFields()\n       }\n    }\n \n+void\n+TR_ResolvedJ9JITServerMethod::cacheImplementorMethods(std::vector<TR_OpaqueClassBlock *> &subClasses, int32_t cpIndexOrOffset, bool isInterface, int32_t ttlForUnresolved)\n+   {\n+   auto compInfoPT = (TR::CompilationInfoPerThreadRemote *) _fe->_compInfoPT;\n+   int32_t numMethods = subClasses.size();\n+\n+   // If there's just one field, it's faster to get it through regular means,\n+   // to avoid overhead of vectors\n+   if (numMethods < 2)\n+      return;\n+\n+   _stream->write(JITServer::MessageType::ResolvedMethod_getResolvedImplementorMethods, (TR_ResolvedJ9Method *) _remoteMirror, subClasses, cpIndexOrOffset, isInterface);\n+   auto recv = _stream->read<std::vector<J9Method *>, std::vector<TR_ResolvedJ9JITServerMethodInfo>>();\n+\n+   // Note: the number of received methods can be smaller\n+   // than the requsted number, because client will abort after\n+   // the first unresolved method.\n+   auto ramMethods = std::get<0>(recv);", "originalCommit": "b6d99e5dc2844531bfc63db8e540375b28cd48d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczMTI3MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454731271", "bodyText": "This can push a NULL ramMethod as the last element. Is that intended?", "author": "mpirvu", "createdAt": "2020-07-15T01:09:43Z", "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -1841,6 +1841,52 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n          client->write(response, objLocation, obj);\n          }\n          break;\n+      case MessageType::ResolvedMethod_getResolvedImplementorMethods:\n+         {\n+         auto recv = client->getRecvData<TR_ResolvedJ9Method *, std::vector<TR_OpaqueClassBlock *>, int32_t, bool>();\n+         auto owningMethod = std::get<0>(recv);\n+         auto &subClasses = std::get<1>(recv);\n+         int32_t cpIndexOrOffset = std::get<2>(recv);\n+         bool isInterface = std::get<3>(recv);\n+\n+         int32_t numMethods = subClasses.size();\n+         std::vector<J9Method *> ramMethods;\n+         std::vector<TR_ResolvedJ9JITServerMethodInfo> methodInfos;\n+         ramMethods.reserve(numMethods);\n+         methodInfos.reserve(numMethods);\n+\n+         for (int32_t i = 0; i < numMethods; ++i)\n+            {\n+            J9Method *ramMethod;\n+            TR_ResolvedJ9JITServerMethodInfo methodInfo;\n+            if (isInterface)\n+               {\n+               ramMethod = (J9Method *) fe->getResolvedInterfaceMethod(owningMethod->getPersistentIdentifier(), subClasses[i], cpIndexOrOffset);\n+               bool resolved = ramMethod && J9_BYTECODE_START_FROM_RAM_METHOD(ramMethod);\n+\n+               if (resolved)\n+                  TR_ResolvedJ9JITServerMethod::createResolvedMethodFromJ9MethodMirror(methodInfo, (TR_OpaqueMethodBlock *) ramMethod, 0, owningMethod, fe, trMemory);\n+               }\n+            else\n+               {\n+               TR_OpaqueMethodBlock *method = fe->getResolvedVirtualMethod(subClasses[i], cpIndexOrOffset);\n+               ramMethod = reinterpret_cast<J9Method *>(method);\n+               TR_ResolvedJ9JITServerMethodInfo methodInfo;\n+               if (ramMethod)\n+                  TR_ResolvedJ9JITServerMethod::createResolvedMethodMirror(methodInfo, method, 0, owningMethod, fe, trMemory);\n+               }\n+            ramMethods.push_back(ramMethod);", "originalCommit": "b6d99e5dc2844531bfc63db8e540375b28cd48d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEzMzMwMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r455133303", "bodyText": "Yes it's intended. This will cache the first unresolved method on the server, so that when the actual tree walk is done, it will know to stop the walk there.", "author": "dmitry-ten", "createdAt": "2020-07-15T15:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczMTI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNTY5NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454735695", "bodyText": "I don't see a constructor for TR_ResolvedJ9JITServerMethodInfo which means that at this point methodInfo is not initialized. Is methodInfo.remoteMirror going to be initialized on all possible paths later?", "author": "mpirvu", "createdAt": "2020-07-15T01:25:39Z", "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -1841,6 +1841,52 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n          client->write(response, objLocation, obj);\n          }\n          break;\n+      case MessageType::ResolvedMethod_getResolvedImplementorMethods:\n+         {\n+         auto recv = client->getRecvData<TR_ResolvedJ9Method *, std::vector<TR_OpaqueClassBlock *>, int32_t, bool>();\n+         auto owningMethod = std::get<0>(recv);\n+         auto &subClasses = std::get<1>(recv);\n+         int32_t cpIndexOrOffset = std::get<2>(recv);\n+         bool isInterface = std::get<3>(recv);\n+\n+         int32_t numMethods = subClasses.size();\n+         std::vector<J9Method *> ramMethods;\n+         std::vector<TR_ResolvedJ9JITServerMethodInfo> methodInfos;\n+         ramMethods.reserve(numMethods);\n+         methodInfos.reserve(numMethods);\n+\n+         for (int32_t i = 0; i < numMethods; ++i)\n+            {\n+            J9Method *ramMethod;\n+            TR_ResolvedJ9JITServerMethodInfo methodInfo;", "originalCommit": "b6d99e5dc2844531bfc63db8e540375b28cd48d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNjQwNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454736405", "bodyText": "I see the initialization in createResolvedMethodFromJ9MethodMirror which calls:\nvoid\nTR_ResolvedJ9JITServerMethod::packMethodInfo(TR_ResolvedJ9JITServerMethodInfo &methodInfo, TR_ResolvedJ9Method *resolvedMethod, TR_FrontEnd *fe)\n   {\n   auto &methodInfoStruct = std::get<0>(methodInfo);\n   if (!resolvedMethod)\n      {\n      // resolved method not created, setting remoteMirror to NULL indicates\n      // that other fields should be ignored.\n      methodInfoStruct.remoteMirror = NULL;\n      return;\n      }\n\nbut that is not called when resolved is false.", "author": "mpirvu", "createdAt": "2020-07-15T01:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNTY5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI4ODY2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r455288668", "bodyText": "That's true. I think I should create a constructor for TR_ResolvedJ9JITServerMethodInfoStruct.", "author": "dmitry-ten", "createdAt": "2020-07-15T19:25:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNTY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0NDU4Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454744586", "bodyText": "Maybe an assert is a better choice here.", "author": "mpirvu", "createdAt": "2020-07-15T01:58:21Z", "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -991,6 +998,115 @@ bool CollectCompiledImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n    return false;\n    }\n \n+#if defined(J9VM_OPT_JITSERVER)\n+class CollectResolvedImplementors: public CollectImplementors\n+   {\n+public:\n+   CollectResolvedImplementors(TR::Compilation * comp,\n+                           TR_OpaqueClassBlock *topClassId,\n+                           int32_t maxCount,\n+                           TR_ResolvedMethod *callerMethod,\n+                           int32_t slotOrIndex,\n+                           TR_YesNoMaybe useGetResolvedInterfaceMethod = TR_maybe) :\n+      CollectImplementors(comp, topClassId, NULL, maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod)\n+      {\n+      _implArray = new (comp->trHeapMemory()) TR_ResolvedMethod *[maxCount];\n+      }\n+\n+   virtual bool visitSubclass(TR_PersistentClassInfo *cl) override;\n+   void cacheResolvedMethods();\n+\n+private:\n+   std::vector<TR_OpaqueClassBlock *> _subClasses;\n+   };\n+\n+bool\n+CollectResolvedImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n+   {\n+   // must only be used on JITServer server-side\n+   if (!comp()->isOutOfProcessCompilation())", "originalCommit": "b6d99e5dc2844531bfc63db8e540375b28cd48d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0NTI2Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454745266", "bodyText": "Let's move type closer to its usage, line 1055.\nSame for compInfoPT", "author": "mpirvu", "createdAt": "2020-07-15T02:00:55Z", "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -991,6 +998,115 @@ bool CollectCompiledImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n    return false;\n    }\n \n+#if defined(J9VM_OPT_JITSERVER)\n+class CollectResolvedImplementors: public CollectImplementors\n+   {\n+public:\n+   CollectResolvedImplementors(TR::Compilation * comp,\n+                           TR_OpaqueClassBlock *topClassId,\n+                           int32_t maxCount,\n+                           TR_ResolvedMethod *callerMethod,\n+                           int32_t slotOrIndex,\n+                           TR_YesNoMaybe useGetResolvedInterfaceMethod = TR_maybe) :\n+      CollectImplementors(comp, topClassId, NULL, maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod)\n+      {\n+      _implArray = new (comp->trHeapMemory()) TR_ResolvedMethod *[maxCount];\n+      }\n+\n+   virtual bool visitSubclass(TR_PersistentClassInfo *cl) override;\n+   void cacheResolvedMethods();\n+\n+private:\n+   std::vector<TR_OpaqueClassBlock *> _subClasses;\n+   };\n+\n+bool\n+CollectResolvedImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n+   {\n+   // must only be used on JITServer server-side\n+   if (!comp()->isOutOfProcessCompilation())\n+      {\n+      stopTheWalk();\n+      return false;\n+      }\n+\n+   auto callerMethod = static_cast<TR_ResolvedJ9JITServerMethod *>(_callerMethod);\n+   TR_ResolvedMethodType type = isInterface() ?", "originalCommit": "b6d99e5dc2844531bfc63db8e540375b28cd48d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0ODMyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454748326", "bodyText": "Is it possible to find something in the cache, but resolvedMethod is NULL? If so, what should we do?", "author": "mpirvu", "createdAt": "2020-07-15T02:12:41Z", "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -991,6 +998,115 @@ bool CollectCompiledImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n    return false;\n    }\n \n+#if defined(J9VM_OPT_JITSERVER)\n+class CollectResolvedImplementors: public CollectImplementors\n+   {\n+public:\n+   CollectResolvedImplementors(TR::Compilation * comp,\n+                           TR_OpaqueClassBlock *topClassId,\n+                           int32_t maxCount,\n+                           TR_ResolvedMethod *callerMethod,\n+                           int32_t slotOrIndex,\n+                           TR_YesNoMaybe useGetResolvedInterfaceMethod = TR_maybe) :\n+      CollectImplementors(comp, topClassId, NULL, maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod)\n+      {\n+      _implArray = new (comp->trHeapMemory()) TR_ResolvedMethod *[maxCount];\n+      }\n+\n+   virtual bool visitSubclass(TR_PersistentClassInfo *cl) override;\n+   void cacheResolvedMethods();\n+\n+private:\n+   std::vector<TR_OpaqueClassBlock *> _subClasses;\n+   };\n+\n+bool\n+CollectResolvedImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n+   {\n+   // must only be used on JITServer server-side\n+   if (!comp()->isOutOfProcessCompilation())\n+      {\n+      stopTheWalk();\n+      return false;\n+      }\n+\n+   auto callerMethod = static_cast<TR_ResolvedJ9JITServerMethod *>(_callerMethod);\n+   TR_ResolvedMethodType type = isInterface() ?\n+      TR_ResolvedMethodType::Interface :\n+      TR_ResolvedMethodType::VirtualFromOffset;\n+   auto compInfoPT = static_cast<TR::CompilationInfoPerThreadRemote *>(static_cast<TR_J9VMBase *>(fe())->_compInfoPT);\n+\n+   // verify that our subclass meets all conditions\n+   TR_OpaqueClassBlock *classId = cl->getClassId();\n+   if (!TR::Compiler->cls.isAbstractClass(comp(), classId)\n+      && !TR::Compiler->cls.isInterfaceClass(comp(), classId))\n+      {\n+      ++_numVisitedSubClasses;\n+      if (_numVisitedSubClasses > _maxNumVisitedSubClasses)\n+         {\n+         // set count greater than maxCount, to indicate failure and force exit\n+         _count = _maxCount + 1;\n+         stopTheWalk();\n+         return false;\n+         }\n+\n+      // if the implementor hasn't been cached yet,\n+      // add the corresponding subclass to the list\n+      TR_ResolvedMethod *resolvedMethod;\n+      TR_ResolvedMethodKey key =\n+         compInfoPT->getResolvedMethodKey(\n+            type,\n+            reinterpret_cast<TR_OpaqueClassBlock *>(callerMethod->constantPoolHdr()),\n+            _slotOrIndex,\n+            classId);\n+      if (!compInfoPT->getCachedResolvedMethod(\n+             key,\n+             callerMethod,\n+             &resolvedMethod))\n+         {\n+         _subClasses.push_back(classId);\n+         }\n+      else if (resolvedMethod)", "originalCommit": "b6d99e5dc2844531bfc63db8e540375b28cd48d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MTc3NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r455291775", "bodyText": "Actually yes, in the case that we have found a cached unresolved method, we should immediately stop the walk and not make further remote calls. Added it.", "author": "dmitry-ten", "createdAt": "2020-07-15T19:30:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0ODMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0OTgyOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454749828", "bodyText": "We should have an assert firing if trying to execute this not at JITServer.", "author": "mpirvu", "createdAt": "2020-07-15T02:17:46Z", "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -991,6 +998,115 @@ bool CollectCompiledImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n    return false;\n    }\n \n+#if defined(J9VM_OPT_JITSERVER)\n+class CollectResolvedImplementors: public CollectImplementors\n+   {\n+public:\n+   CollectResolvedImplementors(TR::Compilation * comp,\n+                           TR_OpaqueClassBlock *topClassId,\n+                           int32_t maxCount,\n+                           TR_ResolvedMethod *callerMethod,\n+                           int32_t slotOrIndex,\n+                           TR_YesNoMaybe useGetResolvedInterfaceMethod = TR_maybe) :\n+      CollectImplementors(comp, topClassId, NULL, maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod)\n+      {\n+      _implArray = new (comp->trHeapMemory()) TR_ResolvedMethod *[maxCount];\n+      }\n+\n+   virtual bool visitSubclass(TR_PersistentClassInfo *cl) override;\n+   void cacheResolvedMethods();\n+\n+private:\n+   std::vector<TR_OpaqueClassBlock *> _subClasses;\n+   };\n+\n+bool\n+CollectResolvedImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n+   {\n+   // must only be used on JITServer server-side\n+   if (!comp()->isOutOfProcessCompilation())\n+      {\n+      stopTheWalk();\n+      return false;\n+      }\n+\n+   auto callerMethod = static_cast<TR_ResolvedJ9JITServerMethod *>(_callerMethod);\n+   TR_ResolvedMethodType type = isInterface() ?\n+      TR_ResolvedMethodType::Interface :\n+      TR_ResolvedMethodType::VirtualFromOffset;\n+   auto compInfoPT = static_cast<TR::CompilationInfoPerThreadRemote *>(static_cast<TR_J9VMBase *>(fe())->_compInfoPT);\n+\n+   // verify that our subclass meets all conditions\n+   TR_OpaqueClassBlock *classId = cl->getClassId();\n+   if (!TR::Compiler->cls.isAbstractClass(comp(), classId)\n+      && !TR::Compiler->cls.isInterfaceClass(comp(), classId))\n+      {\n+      ++_numVisitedSubClasses;\n+      if (_numVisitedSubClasses > _maxNumVisitedSubClasses)\n+         {\n+         // set count greater than maxCount, to indicate failure and force exit\n+         _count = _maxCount + 1;\n+         stopTheWalk();\n+         return false;\n+         }\n+\n+      // if the implementor hasn't been cached yet,\n+      // add the corresponding subclass to the list\n+      TR_ResolvedMethod *resolvedMethod;\n+      TR_ResolvedMethodKey key =\n+         compInfoPT->getResolvedMethodKey(\n+            type,\n+            reinterpret_cast<TR_OpaqueClassBlock *>(callerMethod->constantPoolHdr()),\n+            _slotOrIndex,\n+            classId);\n+      if (!compInfoPT->getCachedResolvedMethod(\n+             key,\n+             callerMethod,\n+             &resolvedMethod))\n+         {\n+         _subClasses.push_back(classId);\n+         }\n+      else if (resolvedMethod)\n+         {\n+         // check to see if there are any duplicates\n+         int32_t i;\n+         for (i = 0; i < _count; i++)\n+            if (resolvedMethod->isSameMethod(_implArray[i]))\n+               break;  // we already listed this method\n+         if (i >= _count) // brand new implementer\n+            {\n+            _implArray[_count++] = resolvedMethod;\n+            if (_count >= _maxCount)\n+               {\n+               stopTheWalk();\n+               }\n+            }\n+         }\n+      }\n+\n+   return true;\n+   }\n+\n+void\n+CollectResolvedImplementors::cacheResolvedMethods()\n+   {\n+   // must only be used on JITServer server-side\n+   // _count >= _maxCount indicates that either all required implementors\n+   // are already cached or that too many subclasses were visited.\n+   // Remote call not needed.\n+   if (!comp()->isOutOfProcessCompilation() || _count >= _maxCount)", "originalCommit": "b6d99e5dc2844531bfc63db8e540375b28cd48d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc1MDA3Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454750076", "bodyText": "Add /* defined(J9VM_OPT_JITSERVER)  */", "author": "mpirvu", "createdAt": "2020-07-15T02:18:48Z", "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -991,6 +998,115 @@ bool CollectCompiledImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n    return false;\n    }\n \n+#if defined(J9VM_OPT_JITSERVER)\n+class CollectResolvedImplementors: public CollectImplementors\n+   {\n+public:\n+   CollectResolvedImplementors(TR::Compilation * comp,\n+                           TR_OpaqueClassBlock *topClassId,\n+                           int32_t maxCount,\n+                           TR_ResolvedMethod *callerMethod,\n+                           int32_t slotOrIndex,\n+                           TR_YesNoMaybe useGetResolvedInterfaceMethod = TR_maybe) :\n+      CollectImplementors(comp, topClassId, NULL, maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod)\n+      {\n+      _implArray = new (comp->trHeapMemory()) TR_ResolvedMethod *[maxCount];\n+      }\n+\n+   virtual bool visitSubclass(TR_PersistentClassInfo *cl) override;\n+   void cacheResolvedMethods();\n+\n+private:\n+   std::vector<TR_OpaqueClassBlock *> _subClasses;\n+   };\n+\n+bool\n+CollectResolvedImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n+   {\n+   // must only be used on JITServer server-side\n+   if (!comp()->isOutOfProcessCompilation())\n+      {\n+      stopTheWalk();\n+      return false;\n+      }\n+\n+   auto callerMethod = static_cast<TR_ResolvedJ9JITServerMethod *>(_callerMethod);\n+   TR_ResolvedMethodType type = isInterface() ?\n+      TR_ResolvedMethodType::Interface :\n+      TR_ResolvedMethodType::VirtualFromOffset;\n+   auto compInfoPT = static_cast<TR::CompilationInfoPerThreadRemote *>(static_cast<TR_J9VMBase *>(fe())->_compInfoPT);\n+\n+   // verify that our subclass meets all conditions\n+   TR_OpaqueClassBlock *classId = cl->getClassId();\n+   if (!TR::Compiler->cls.isAbstractClass(comp(), classId)\n+      && !TR::Compiler->cls.isInterfaceClass(comp(), classId))\n+      {\n+      ++_numVisitedSubClasses;\n+      if (_numVisitedSubClasses > _maxNumVisitedSubClasses)\n+         {\n+         // set count greater than maxCount, to indicate failure and force exit\n+         _count = _maxCount + 1;\n+         stopTheWalk();\n+         return false;\n+         }\n+\n+      // if the implementor hasn't been cached yet,\n+      // add the corresponding subclass to the list\n+      TR_ResolvedMethod *resolvedMethod;\n+      TR_ResolvedMethodKey key =\n+         compInfoPT->getResolvedMethodKey(\n+            type,\n+            reinterpret_cast<TR_OpaqueClassBlock *>(callerMethod->constantPoolHdr()),\n+            _slotOrIndex,\n+            classId);\n+      if (!compInfoPT->getCachedResolvedMethod(\n+             key,\n+             callerMethod,\n+             &resolvedMethod))\n+         {\n+         _subClasses.push_back(classId);\n+         }\n+      else if (resolvedMethod)\n+         {\n+         // check to see if there are any duplicates\n+         int32_t i;\n+         for (i = 0; i < _count; i++)\n+            if (resolvedMethod->isSameMethod(_implArray[i]))\n+               break;  // we already listed this method\n+         if (i >= _count) // brand new implementer\n+            {\n+            _implArray[_count++] = resolvedMethod;\n+            if (_count >= _maxCount)\n+               {\n+               stopTheWalk();\n+               }\n+            }\n+         }\n+      }\n+\n+   return true;\n+   }\n+\n+void\n+CollectResolvedImplementors::cacheResolvedMethods()\n+   {\n+   // must only be used on JITServer server-side\n+   // _count >= _maxCount indicates that either all required implementors\n+   // are already cached or that too many subclasses were visited.\n+   // Remote call not needed.\n+   if (!comp()->isOutOfProcessCompilation() || _count >= _maxCount)\n+      {\n+      return;\n+      }\n+\n+   static_cast<TR_ResolvedJ9JITServerMethod *>(_callerMethod)->cacheImplementorMethods(\n+      _subClasses,\n+      _slotOrIndex,\n+      isInterface(),\n+      2);\n+   }\n+#endif", "originalCommit": "b6d99e5dc2844531bfc63db8e540375b28cd48d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE0NTMwMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r455145303", "bodyText": "I'll also add it in other places in this file that don't have it.", "author": "dmitry-ten", "createdAt": "2020-07-15T15:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc1MDA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc1MDk5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454750992", "bodyText": "Add /* defined(J9VM_OPT_JITSERVER) */", "author": "mpirvu", "createdAt": "2020-07-15T02:21:59Z", "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -1015,6 +1131,16 @@ TR_ClassQueries::collectImplementorsCapped(TR_PersistentClassInfo *clazz,\n    {\n    if (comp->getOption(TR_DisableCHOpts))\n       return maxCount+1; // fail the collection\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+   if (comp->isOutOfProcessCompilation())\n+      {\n+      CollectResolvedImplementors classCollector(comp, clazz->getClassId(), maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod);\n+      classCollector.visit(clazz->getClassId(), locked);\n+      classCollector.cacheResolvedMethods();\n+      }\n+#endif", "originalCommit": "b6d99e5dc2844531bfc63db8e540375b28cd48d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc1MTUzNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454751535", "bodyText": "If we exceeded maxCount at this point, we don't have to execute the second pass through the hierarchy.", "author": "mpirvu", "createdAt": "2020-07-15T02:24:10Z", "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -1015,6 +1131,16 @@ TR_ClassQueries::collectImplementorsCapped(TR_PersistentClassInfo *clazz,\n    {\n    if (comp->getOption(TR_DisableCHOpts))\n       return maxCount+1; // fail the collection\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+   if (comp->isOutOfProcessCompilation())\n+      {\n+      CollectResolvedImplementors classCollector(comp, clazz->getClassId(), maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod);\n+      classCollector.visit(clazz->getClassId(), locked);\n+      classCollector.cacheResolvedMethods();\n+      }\n+#endif\n+", "originalCommit": "b6d99e5dc2844531bfc63db8e540375b28cd48d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc1MjMxNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454752314", "bodyText": "I just saw that parameter called locked. If this is executed in a critical section we may not be able to send a message because of the delay.", "author": "mpirvu", "createdAt": "2020-07-15T02:27:00Z", "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -1015,6 +1131,16 @@ TR_ClassQueries::collectImplementorsCapped(TR_PersistentClassInfo *clazz,\n    {", "originalCommit": "b6d99e5dc2844531bfc63db8e540375b28cd48d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "10b8ae9266671db82a2d829e29bf0b0e801c9f04", "url": "https://github.com/eclipse-openj9/openj9/commit/10b8ae9266671db82a2d829e29bf0b0e801c9f04", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-15T19:11:24Z", "type": "forcePushed"}, {"oid": "3d13588a6b0d88997c1be91af0b6d14b8f882d13", "url": "https://github.com/eclipse-openj9/openj9/commit/3d13588a6b0d88997c1be91af0b6d14b8f882d13", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-15T19:30:57Z", "type": "forcePushed"}, {"oid": "855126328ecea1fb7019b5b10f3e9aec5e700438", "url": "https://github.com/eclipse-openj9/openj9/commit/855126328ecea1fb7019b5b10f3e9aec5e700438", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-16T17:12:06Z", "type": "forcePushed"}, {"oid": "c891c4b21e91f48bdeebacee18ae4cb2d59d4dae", "url": "https://github.com/eclipse-openj9/openj9/commit/c891c4b21e91f48bdeebacee18ae4cb2d59d4dae", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-16T17:13:04Z", "type": "forcePushed"}, {"oid": "4564576c32b20b9e719a74ea795ad137253eb957", "url": "https://github.com/eclipse-openj9/openj9/commit/4564576c32b20b9e719a74ea795ad137253eb957", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-16T19:23:50Z", "type": "forcePushed"}, {"oid": "7fdc460fae1e5ba76fbe7791549d47d666f7d8ad", "url": "https://github.com/eclipse-openj9/openj9/commit/7fdc460fae1e5ba76fbe7791549d47d666f7d8ad", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-16T19:51:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1NDIyOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r456854228", "bodyText": "visitSubclasses is called from visit which acquires the CHTable mutex, thus we keep this mutex while sending a message. I would like to avoid that.", "author": "mpirvu", "createdAt": "2020-07-19T03:38:15Z", "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -991,6 +1007,141 @@ bool CollectCompiledImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n    return false;\n    }\n \n+#if defined(J9VM_OPT_JITSERVER)\n+class CollectResolvedImplementors: public CollectImplementors\n+   {\n+public:\n+   CollectResolvedImplementors(TR::Compilation * comp,\n+                           TR_OpaqueClassBlock *topClassId,\n+                           TR_ResolvedMethod **implArray,\n+                           int32_t maxCount,\n+                           TR_ResolvedMethod *callerMethod,\n+                           int32_t slotOrIndex,\n+                           TR_YesNoMaybe useGetResolvedInterfaceMethod = TR_maybe) :\n+      CollectImplementors(comp, topClassId, implArray, maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod)\n+      {\n+      TR_ASSERT_FATAL(comp->isOutOfProcessCompilation(), \"Must only be called on JITServer server-side\");\n+      }\n+\n+   virtual bool visitSubclass(TR_PersistentClassInfo *cl) override;\n+protected:\n+   virtual void visitSubclasses(TR_PersistentClassInfo *, TR_CHTable::VisitTracker& visited) override;\n+\n+private:\n+   std::vector<TR_OpaqueClassBlock *> _subClasses;\n+   };\n+\n+bool\n+CollectResolvedImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n+   {\n+   TR_ASSERT_FATAL(comp()->isOutOfProcessCompilation(), \"Must only be called on JITServer server-side\");\n+\n+   auto callerMethod = static_cast<TR_ResolvedJ9JITServerMethod *>(_callerMethod);\n+\n+   // verify that our subclass meets all conditions\n+   TR_OpaqueClassBlock *classId = cl->getClassId();\n+   if (!TR::Compiler->cls.isAbstractClass(comp(), classId)\n+      && !TR::Compiler->cls.isInterfaceClass(comp(), classId))\n+      {\n+      ++_numVisitedSubClasses;\n+      if (_numVisitedSubClasses > _maxNumVisitedSubClasses)\n+         {\n+         // too many classes visited.\n+         // set count greater than maxCount, to indicate failure and force exit\n+         _count = _maxCount + 1;\n+         stopTheWalk();\n+         return false;\n+         }\n+\n+      // if the implementor hasn't been cached yet,\n+      // add the corresponding subclass to the list\n+      TR_ResolvedMethod *resolvedMethod;\n+      TR_ResolvedMethodType type = isInterface() ?\n+         TR_ResolvedMethodType::Interface :\n+         TR_ResolvedMethodType::VirtualFromOffset;\n+      auto compInfoPT = static_cast<TR::CompilationInfoPerThreadRemote *>(static_cast<TR_J9VMBase *>(fe())->_compInfoPT);\n+      TR_ResolvedMethodKey key =\n+         compInfoPT->getResolvedMethodKey(\n+            type,\n+            reinterpret_cast<TR_OpaqueClassBlock *>(callerMethod->constantPoolHdr()),\n+            _slotOrIndex,\n+            classId);\n+      if (!compInfoPT->getCachedResolvedMethod(\n+             key,\n+             callerMethod,\n+             &resolvedMethod))\n+         {\n+         _subClasses.push_back(classId);\n+         }\n+      else if (resolvedMethod)\n+         {\n+         bool added = addImplementor(resolvedMethod);\n+         if (added && _count >= _maxCount)\n+            stopTheWalk();\n+         }\n+      else\n+         {\n+         // unresolved cached method found.\n+         // set count greater than maxCount, to indicate failure and force exit\n+         _count = _maxCount + 1;\n+         stopTheWalk();\n+         return false;\n+         }\n+      }\n+\n+   return true;\n+   }\n+\n+void\n+CollectResolvedImplementors::visitSubclasses(TR_PersistentClassInfo * classInfo, TR_CHTable::VisitTracker& visited)\n+   {\n+   TR_SubclassVisitor::visitSubclasses(classInfo, visited);\n+   if (_depth == 0)\n+      {\n+      TR_ASSERT_FATAL(comp()->isOutOfProcessCompilation(), \"Must only be called on JITServer server-side\");\n+      // _count >= _maxCount indicates that either all required implementors\n+      // are already cached or that too many subclasses were visited.\n+      // Remote call not needed.\n+      if (_count >= _maxCount)\n+         {\n+         return;\n+         }\n+\n+      auto callerMethod = static_cast<TR_ResolvedJ9JITServerMethod *>(_callerMethod);\n+      callerMethod->cacheImplementorMethods(", "originalCommit": "7fdc460fae1e5ba76fbe7791549d47d666f7d8ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQyODExMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r457428112", "bodyText": "Ok, I'll move this code back into a separate method then.", "author": "dmitry-ten", "createdAt": "2020-07-20T14:18:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1NDIyOA=="}], "type": "inlineReview"}, {"oid": "8f44f2ef4b79f5cfa033941f3797f454d00ddc15", "url": "https://github.com/eclipse-openj9/openj9/commit/8f44f2ef4b79f5cfa033941f3797f454d00ddc15", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-20T14:53:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI2ODEzNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r460268137", "bodyText": "If the cached method is unresolved (resolvedMethod == NULL) shouldn't we stop the walk and set _count == _maxCount?", "author": "mpirvu", "createdAt": "2020-07-24T20:17:44Z", "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -991,6 +1011,136 @@ bool CollectCompiledImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n    return false;\n    }\n \n+#if defined(J9VM_OPT_JITSERVER)\n+class CollectResolvedImplementors: public CollectImplementors\n+   {\n+public:\n+   CollectResolvedImplementors(TR::Compilation * comp,\n+                           TR_OpaqueClassBlock *topClassId,\n+                           TR_ResolvedMethod **implArray,\n+                           int32_t maxCount,\n+                           TR_ResolvedMethod *callerMethod,\n+                           int32_t slotOrIndex,\n+                           TR_YesNoMaybe useGetResolvedInterfaceMethod = TR_maybe) :\n+      CollectImplementors(comp, topClassId, implArray, maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod)\n+      {\n+      TR_ASSERT_FATAL(comp->isOutOfProcessCompilation(), \"Must only be called on JITServer server-side\");\n+      }\n+\n+   virtual bool visitSubclass(TR_PersistentClassInfo *cl) override;\n+   void cacheResolvedMethods();\n+\n+private:\n+   std::vector<TR_OpaqueClassBlock *> _subClasses;\n+   };\n+\n+bool\n+CollectResolvedImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n+   {\n+   TR_ASSERT_FATAL(comp()->isOutOfProcessCompilation(), \"Must only be called on JITServer server-side\");\n+\n+   auto callerMethod = static_cast<TR_ResolvedJ9JITServerMethod *>(_callerMethod);\n+\n+   // verify that our subclass meets all conditions\n+   TR_OpaqueClassBlock *classId = cl->getClassId();\n+   if (!TR::Compiler->cls.isAbstractClass(comp(), classId)\n+      && !TR::Compiler->cls.isInterfaceClass(comp(), classId))\n+      {\n+      ++_numVisitedSubClasses;\n+      if (_numVisitedSubClasses > _maxNumVisitedSubClasses)\n+         {\n+         // too many classes visited.\n+         // set count greater than maxCount, to indicate failure and force exit\n+         _count = _maxCount + 1;\n+         stopTheWalk();\n+         return false;\n+         }\n+\n+      // if the implementor hasn't been cached yet,\n+      // add the corresponding subclass to the list\n+      TR_ResolvedMethod *resolvedMethod;\n+      TR_ResolvedMethodType type = isInterface() ?\n+         TR_ResolvedMethodType::Interface :\n+         TR_ResolvedMethodType::VirtualFromOffset;\n+      auto compInfoPT = static_cast<TR::CompilationInfoPerThreadRemote *>(static_cast<TR_J9VMBase *>(fe())->_compInfoPT);\n+      TR_ResolvedMethodKey key =\n+         compInfoPT->getResolvedMethodKey(\n+            type,\n+            reinterpret_cast<TR_OpaqueClassBlock *>(callerMethod->constantPoolHdr()),\n+            _slotOrIndex,\n+            classId);\n+      if (!compInfoPT->getCachedResolvedMethod(\n+             key,\n+             callerMethod,\n+             &resolvedMethod))\n+         {\n+         _subClasses.push_back(classId);\n+         }\n+      else if (resolvedMethod)\n+         {\n+         bool added = addImplementor(resolvedMethod);\n+         if (added && _count >= _maxCount)\n+            stopTheWalk();\n+         }\n+      else\n+         {\n+         // unresolved cached method found.\n+         // set count greater than maxCount, to indicate failure and force exit\n+         _count = _maxCount + 1;\n+         stopTheWalk();\n+         return false;\n+         }\n+      }\n+\n+   return true;\n+   }\n+\n+void\n+CollectResolvedImplementors::cacheResolvedMethods()\n+   {\n+   TR_ASSERT_FATAL(comp()->isOutOfProcessCompilation(), \"Must only be called on JITServer server-side\");\n+   // _count >= _maxCount indicates that either all required implementors\n+   // are already cached or that too many subclasses were visited.\n+   // Remote call not needed.\n+   if (_count >= _maxCount)\n+      {\n+      return;\n+      }\n+\n+   auto callerMethod = static_cast<TR_ResolvedJ9JITServerMethod *>(_callerMethod);\n+   callerMethod->cacheImplementorMethods(\n+      _subClasses,\n+      _slotOrIndex,\n+      isInterface(),\n+      2);\n+\n+   // now, add the cached methods to _implArray\n+   TR_ResolvedMethod *resolvedMethod;\n+   TR_ResolvedMethodType type = isInterface() ?\n+      TR_ResolvedMethodType::Interface :\n+      TR_ResolvedMethodType::VirtualFromOffset;\n+   auto compInfoPT = static_cast<TR::CompilationInfoPerThreadRemote *>(static_cast<TR_J9VMBase *>(fe())->_compInfoPT);\n+   for (auto it = _subClasses.begin(); it != _subClasses.end(); ++it)\n+      {\n+      TR_ResolvedMethodKey key =\n+         compInfoPT->getResolvedMethodKey(\n+            type,\n+            reinterpret_cast<TR_OpaqueClassBlock *>(callerMethod->constantPoolHdr()),\n+            _slotOrIndex,\n+            *it);\n+      if (compInfoPT->getCachedResolvedMethod(\n+             key,\n+             callerMethod,\n+             &resolvedMethod))\n+         {\n+         bool added = addImplementor(resolvedMethod);", "originalCommit": "8f44f2ef4b79f5cfa033941f3797f454d00ddc15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3MDUyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r460270526", "bodyText": "Don't we need visitSubclass(clazz) like in the original? This visits the top class.", "author": "mpirvu", "createdAt": "2020-07-24T20:23:07Z", "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -1015,10 +1165,23 @@ TR_ClassQueries::collectImplementorsCapped(TR_PersistentClassInfo *clazz,\n    {\n    if (comp->getOption(TR_DisableCHOpts))\n       return maxCount+1; // fail the collection\n-   CollectImplementors collector(comp, clazz->getClassId(), implArray, maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod);\n-   collector.visitSubclass(clazz);\n-   collector.visit(clazz->getClassId(), locked);\n-   return collector.getCount(); // return the number of implementers in the implArray\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+   if (comp->isOutOfProcessCompilation())\n+      {\n+      CollectResolvedImplementors collector(comp, clazz->getClassId(), implArray, maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod);\n+      collector.visit(clazz->getClassId(), locked);", "originalCommit": "8f44f2ef4b79f5cfa033941f3797f454d00ddc15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk0NDY4MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r460944680", "bodyText": "Oh, true. I didn't realize that we don't visit the top class otherwise.", "author": "dmitry-ten", "createdAt": "2020-07-27T14:45:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3MDUyNg=="}], "type": "inlineReview"}, {"oid": "630d699bc6ae81591912df50264bcc7c9e10baa6", "url": "https://github.com/eclipse-openj9/openj9/commit/630d699bc6ae81591912df50264bcc7c9e10baa6", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-27T14:59:15Z", "type": "forcePushed"}, {"oid": "3ccc3a0786c55820a99670f5ec18421166e14e67", "url": "https://github.com/eclipse-openj9/openj9/commit/3ccc3a0786c55820a99670f5ec18421166e14e67", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-27T15:56:37Z", "type": "commit"}, {"oid": "3ccc3a0786c55820a99670f5ec18421166e14e67", "url": "https://github.com/eclipse-openj9/openj9/commit/3ccc3a0786c55820a99670f5ec18421166e14e67", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-27T15:56:37Z", "type": "forcePushed"}]}