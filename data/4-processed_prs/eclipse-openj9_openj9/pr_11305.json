{"pr_number": 11305, "pr_title": "Update to use the new LoadStoreHandler API on Power", "pr_createdAt": "2020-11-30T19:28:15Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/11305", "timeline": [{"oid": "bc90ee3e0e9c69285138c9b79baf97e16b073f20", "url": "https://github.com/eclipse-openj9/openj9/commit/bc90ee3e0e9c69285138c9b79baf97e16b073f20", "message": "Update simple read monitors to use the new LoadStoreHandler API\n\nPreviously, the code for emitting simple read monitors was using the old\nMemoryReference-based API for performing the load. This API is being\ndeprecated in OMR, so all code dealing with read barriers has been\nupdated to use the new LoadStoreHandler API.\n\nSigned-off-by: Ben Thomas <ben@benthomas.ca>", "committedDate": "2020-12-02T16:26:03Z", "type": "forcePushed"}, {"oid": "24dc2babedf8ad00c543fd122d2f5c686500120f", "url": "https://github.com/eclipse-openj9/openj9/commit/24dc2babedf8ad00c543fd122d2f5c686500120f", "message": "Disable prefetching for aloadi nodes on 64-bit\n\nPreviously, the code in the insertPrefetchIfNecessary method was\nexpecting that it would only see aloadi nodes on 32-bit. Because of\nthis, the code would not operate correctly and would cause segfaults\nduring compilation. This was previously being handled by simply not\ncalling insertPrefetchIfNecessary under these conditions, however\nkeeping this behaviour requires that OMR know about implementation\ndetails of OpenJ9's prefetching.\n\nWhile this code could theoretically be made to work under these\nconditions, the code as written simply cannot handle this case. Instead,\na check has been added to prevent insertPrefetchIfNecessary from\noperating on aloadi nodes on 64-bit to replicate the old behaviour.\n\nSigned-off-by: Ben Thomas <ben@benthomas.ca>", "committedDate": "2020-12-10T19:35:23Z", "type": "forcePushed"}, {"oid": "825ae5151f1c3710237427f8b898eae5bbae9ff6", "url": "https://github.com/eclipse-openj9/openj9/commit/825ae5151f1c3710237427f8b898eae5bbae9ff6", "message": "Update simple read monitors to use the new LoadStoreHandler API\n\nPreviously, the code for emitting simple read monitors was using the old\nMemoryReference-based API for performing the load. This API is being\ndeprecated in OMR, so all code dealing with read barriers has been\nupdated to use the new LoadStoreHandler API.\n\nSigned-off-by: Ben Thomas <ben@benthomas.ca>", "committedDate": "2020-12-17T19:34:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI0ODIwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r546248207", "bodyText": "I think this will cause some register shuffling since before dependencies were shared between the array check store and write barrier helpers.", "author": "gita-omr", "createdAt": "2020-12-19T15:07:24Z", "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -3585,105 +3407,46 @@ TR::Register *J9::Power::TreeEvaluator::ArrayStoreCHKEvaluator(TR::Node *node, T\n       }\n \n    TR::Register *srcReg, *dstReg;\n-   TR::Register *condReg, *temp1Reg, *temp2Reg, *temp3Reg, *temp4Reg, *baseReg, *indexReg;\n-   TR::MemoryReference *tempMR1, *tempMR2;\n-   TR::LabelSymbol *wbLabel, *doneLabel, *startLabel, *storeLabel, *wrtBarEndLabel;\n+   TR::Register *condReg, *temp1Reg, *temp2Reg, *temp3Reg, *temp4Reg;\n+   TR::LabelSymbol *wbLabel, *startLabel;\n    TR::RegisterDependencyConditions *conditions;\n-   J9::Power::PrivateLinkage *linkage = (J9::Power::PrivateLinkage *) cg->getLinkage();\n-   const TR::PPCLinkageProperties &properties = linkage->getProperties();\n-   TR::Instruction *gcPoint;\n-   bool stopUsingSrc = false;\n \n    wbLabel = generateLabelSymbol(cg);\n-   doneLabel = generateLabelSymbol(cg);\n-   storeLabel = (doWrtBar) ? (generateLabelSymbol(cg)) : NULL;\n \n-   tempMR1 = TR::MemoryReference::createWithRootLoadOrStore(cg, firstChild, TR::Compiler->om.sizeofReferenceAddress());\n    dstReg = cg->evaluate(destinationChild);\n-   TR::Register *compressedReg;\n-   if (sourceChild->getReferenceCount() > 1 && (srcReg = sourceChild->getRegister()) != NULL)\n-      {\n-      TR::Register *tempReg = cg->allocateCollectedReferenceRegister();\n-\n-      // Source must be an object.\n-      TR_ASSERT(!srcReg->containsInternalPointer(), \"Stored value is an internal pointer\");\n+   srcReg = cg->evaluate(sourceChild);\n \n-      generateTrg1Src1Instruction(cg, TR::InstOpCode::mr, node, tempReg, srcReg);\n-      srcReg = tempReg;\n-      stopUsingSrc = true;\n-      compressedReg = srcReg;\n-      if (usingCompressedPointers)\n-         compressedReg = cg->evaluate(firstChild->getSecondChild());\n-      }\n-   else\n-      {\n-      srcReg = cg->evaluate(sourceChild);\n-      compressedReg = srcReg;\n-      if (usingCompressedPointers)\n-         compressedReg = cg->evaluate(firstChild->getSecondChild());\n-      }\n-\n-   int32_t numDeps = 11;\n-   if (usingCompressedPointers)\n-      numDeps++;\n-   if ((gcMode == gc_modron_wrtbar_satb) || (comp->getOptions()->realTimeGC()))\n-      numDeps++;\n-   if (!firstChild->skipWrtBar())\n-      numDeps += 2;\n-\n-   conditions = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(numDeps, numDeps, cg->trMemory());\n+   conditions = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(7, 7, cg->trMemory());\n    temp1Reg = cg->allocateRegister();\n    temp2Reg = cg->allocateRegister();\n    temp3Reg = cg->allocateRegister();\n    temp4Reg = cg->allocateRegister();\n    condReg = cg->allocateRegister(TR_CCR);\n \n-   // !!! Adding any dependency before the baseReg, you have to be careful with the excludeGPR0 order\n-   TR::addDependency(conditions, dstReg, TR::RealRegister::gr3, TR_GPR, cg);\n-\n-   if (comp->getOptions()->realTimeGC())\n-      TR::addDependency(conditions, srcReg, TR::RealRegister::gr5, TR_GPR, cg);\n-   else\n-      TR::addDependency(conditions, srcReg, TR::RealRegister::gr4, TR_GPR, cg);\n-\n-   TR::addDependency(conditions, temp1Reg, TR::RealRegister::gr11, TR_GPR, cg);\n+   TR::addDependency(conditions, dstReg, TR::RealRegister::NoReg, TR_GPR, cg);\n+   conditions->getPreConditions()->getRegisterDependency(conditions->getAddCursorForPre() - 1)->setExcludeGPR0();", "originalCommit": "825ae5151f1c3710237427f8b898eae5bbae9ff6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc3Mjc2OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r546772769", "bodyText": "I don't think removing these explicit dependencies should cause any additional register shuffles. The code generated for the write barrier comes after the label with these dependencies, meaning that the more specific dependencies from the write barrier would be encountered by the local register allocator before these ones.", "author": "aviansie-ben", "createdAt": "2020-12-21T15:34:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI0ODIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEzNDE0NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r552134144", "bodyText": "This looks like conditions being misplaced originally.  This current fix certainly is not in line with the intention of prefetch optimization.  Prefetch surely is beneficial performance-wise to 64bit non-compressed.\nThe conditions should read something like:   if  (is-objectReference-load  &&  hotness-testing && CPU-testing)\nApplies to the next change too.", "author": "zl-wang", "createdAt": "2021-01-05T19:06:14Z", "path": "runtime/compiler/p/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -403,7 +403,7 @@ J9::Power::CodeGenerator::insertPrefetchIfNecessary(TR::Node *node, TR::Register\n    static bool disableStringObjPrefetch = (feGetEnv(\"TR_DisableStringObjPrefetch\") != NULL);\n    bool optDisabled = false;\n \n-   if (node->getOpCodeValue() == TR::aloadi ||\n+   if ((node->getOpCodeValue() == TR::aloadi && !comp->target().is64Bit()) ||\n         (comp->target().is64Bit() &&", "originalCommit": "825ae5151f1c3710237427f8b898eae5bbae9ff6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1MzI3OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r552153279", "bodyText": "While I agree that prefetching certainly could be applied in these circumstances, extending the prefetching optimization to handle this case correctly is out-of-scope for this PR. As the commit message clarifies, the previous implementation was not performing prefetching for such nodes either, but the way this was being achieved was slightly different. This change does not make prefetching not occur where it previously would, but simply makes insertPrefetchIfNecessary safe to call on aloadi nodes under 64-bit, as it would otherwise segfault.\nPreviously, we were simply failing to call insertPrefetchIfNecessary at all under the problematic conditions, thus sidestepping the problem. In commoning up code between the load evaluators into LoadStoreHandler, all of these evaluators need to behave uniformly and thus now call insertPrefetchIfNecessary unconditionally, with it being up to that method alone to make the decision as to whether to perform prefetching. This also avoids leaking implementation details of OpenJ9's prefetching into OMR.\nIf you'd like, I can open an issue for extending this support in the future, though.", "author": "aviansie-ben", "createdAt": "2021-01-05T19:42:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEzNDE0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjYzMDE0MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r552630141", "bodyText": "certainly need a follow-up item", "author": "zl-wang", "createdAt": "2021-01-06T13:50:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEzNDE0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU4ODgwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r565588806", "bodyText": "Opened #11803", "author": "aviansie-ben", "createdAt": "2021-01-27T19:48:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEzNDE0NA=="}], "type": "inlineReview"}, {"oid": "688a9f3246c328e8d0e6368f913fa29d01cc69d1", "url": "https://github.com/eclipse-openj9/openj9/commit/688a9f3246c328e8d0e6368f913fa29d01cc69d1", "message": "Update simple read monitors to use the new LoadStoreHandler API\n\nPreviously, the code for emitting simple read monitors was using the old\nMemoryReference-based API for performing the load. This API is being\ndeprecated in OMR, so all code dealing with read barriers has been\nupdated to use the new LoadStoreHandler API.\n\nSigned-off-by: Ben Thomas <ben@benthomas.ca>", "committedDate": "2021-01-05T19:18:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY1ODI2Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r559658267", "bodyText": "@zl-wang is there any chance this assert can get triggered?", "author": "gita-omr", "createdAt": "2021-01-18T15:49:56Z", "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -7439,26 +7274,27 @@ static bool simpleReadMonitor(TR::Node *node, TR::CodeGenerator *cg, TR::Node *o\n       {\n       if (TR::Compiler->om.compressObjectReferences() && nextTopNode->getSymbol()->isClassObject())\n          {\n-         tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 4);\n+         tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 4);\n          loadOpCode = TR::InstOpCode::lwz;\n          }\n       else\n          {\n-         tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 8);\n+         tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 8);\n          loadOpCode = TR::InstOpCode::ld;\n          }\n       }\n    else\n       {\n-      tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 4);\n+      tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 4);\n       loadOpCode = TR::InstOpCode::lwz;\n       }\n+   TR_ASSERT_FATAL_WITH_NODE(nextTopNode, !tempMR.getMemoryReference()->getIndexRegister(), \"Simple read monitors do not currently support indexed loads\");", "originalCommit": "688a9f3246c328e8d0e6368f913fa29d01cc69d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzEyMTY0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r567121649", "bodyText": "since TR::LoadStoreHandler::generateSimpleLoadMemoryReference doesn't guarantee immediate-form addressing, it looks like potentially this assert can trigger.  On the other hand, the existing code didn't handle the indexRegister anyway (if it were present), so that it could be wrong already but not caught with assert. I would suggest removing this assert and staying the previous assumption for the time being, and open a follow-up item to handle the indexRegsiter if it becomes present.  as it is,  it likely works even if indexRegister is present. But this newly added assert will be a flare-up regression in the field (as the ConstantDataSnippet assert was). @aviansie-ben", "author": "zl-wang", "createdAt": "2021-01-29T22:11:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY1ODI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTcxMDE4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r569710181", "bodyText": "since TR::LoadStoreHandler::generateSimpleLoadMemoryReference doesn't guarantee immediate-form addressing, it looks like potentially this assert can trigger\n\nIn practice, this assert should never fire since the code above already checks that nextTopNode->getFirstChild() has been previously evaluated and generateSimpleLoadMemoryReference will never generate an index-form memory reference under these conditions unless one is explicitly requested. This assert is being added to document this assumption and to guard against any future changes that might violate it.\n\nas it is, it likely works even if indexRegister is present\n\nThe consequences of reaching this code with an index-form memory reference could be severe and result in very difficult-to-diagnose issues and possible security vulnerabilities. Firstly, the ICF register dependencies would not include the index register, so we'd potentially get spills in ICF. Secondly and much more worryingly, PPCReadMonitorSnippet (which is used as a fallback if the lock is already held when this code is entered) will always generate an immediate-form load and so would load at an offset of 0 from the base register, which will predictably load the J9Class of the object. If an attacker could cause a race condition to occur, they could reliably force a non-zero result from such a load, which could be a big problem if the value being loaded is a security-critical boolean.", "author": "aviansie-ben", "createdAt": "2021-02-03T20:02:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY1ODI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTc0MDQwMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r569740401", "bodyText": "so, we agree the assert has no much value in catching a problematic case, but more for future-proof which i suggested opening a new PR to be addressed instead. for this merge in particular, it is just better off to get rid of this assert.", "author": "zl-wang", "createdAt": "2021-02-03T20:53:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY1ODI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTc0NjM2NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r569746365", "bodyText": "No, we clearly do not agree. The whole point of an assert is to assert that the stated condition should not happen and to make sure that the compiler fails in a predictable manner if it ever does rather than simply generating garbage code that could wreak havoc on the running application. There is no need to open a new issue or PR here because this is a case that shouldn't happen and thus does not need to be handled.", "author": "aviansie-ben", "createdAt": "2021-02-03T21:03:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY1ODI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTc3MTE4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r569771181", "bodyText": "the problem is:  it is predictably fatal if it triggers.  we are very assert-wary ... high cost of service. as a matter of fact as of today, there are still outstanding assert PMRs for newly added assert to be addressed (iFix delivery) in some branches.\nit is not a regression without this assert (existing bug if indexed form), and it is a new regression with the assert.  better way moving forward: either you make it work for all cases, or we will fix the existing bug in the near future. we just don't want to deal with the potentially new regression.", "author": "zl-wang", "createdAt": "2021-02-03T21:44:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY1ODI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI1NzE4OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r574257189", "bodyText": "Frankly, I find your reasoning here to be misguided. IMO it is much better to crash in a predictable manner than to potentially exhibit wrong behaviour much later on and it being \"not a regression\" to exhibit wrong behaviour is a poor excuse. However, in the interests of moving this PR forward, I have removed the assert in this particular case. Do note that I don't intend on letting excuses of this nature fly in OMR, though, and I will continue to ensure that asserts are added as appropriate there.", "author": "aviansie-ben", "createdAt": "2021-02-11T05:23:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY1ODI2Nw=="}], "type": "inlineReview"}, {"oid": "e7c26c2088c7839f4dd3ae31e1e36b18778660ba", "url": "https://github.com/eclipse-openj9/openj9/commit/e7c26c2088c7839f4dd3ae31e1e36b18778660ba", "message": "Disable prefetching for aloadi nodes on 64-bit\n\nPreviously, the code in the insertPrefetchIfNecessary method was\nexpecting that it would only see aloadi nodes on 32-bit. Because of\nthis, the code would not operate correctly and would cause segfaults\nduring compilation. This was previously being handled by simply not\ncalling insertPrefetchIfNecessary under these conditions, however\nkeeping this behaviour requires that OMR know about implementation\ndetails of OpenJ9's prefetching.\n\nWhile this code could theoretically be made to work under these\nconditions, the code as written simply cannot handle this case. Instead,\na check has been added to prevent insertPrefetchIfNecessary from\noperating on aloadi nodes on 64-bit to replicate the old behaviour.\n\nSigned-off-by: Ben Thomas <ben@benthomas.ca>", "committedDate": "2021-02-11T04:29:01Z", "type": "commit"}, {"oid": "a98159db0defb4a657b07e6c20745dfb2f0dfed4", "url": "https://github.com/eclipse-openj9/openj9/commit/a98159db0defb4a657b07e6c20745dfb2f0dfed4", "message": "Add OMRLoadStoreHandler.cpp to builds\n\nSigned-off-by: Ben Thomas <ben@benthomas.ca>", "committedDate": "2021-02-11T04:29:01Z", "type": "commit"}, {"oid": "7322e410b44a7776d10e4838c070f689a3af2a95", "url": "https://github.com/eclipse-openj9/openj9/commit/7322e410b44a7776d10e4838c070f689a3af2a95", "message": "Update write barriers to use the new LoadStoreHandler API\n\nPreviously, the code for performing write barriers was using the old\nMemoryReference-based API for performing its stores. This API is being\ndeprecated in OMR, so all code dealing with write barriers has been\nupdated to use the new LoadStoreHandler API.\n\nSigned-off-by: Ben Thomas <ben@benthomas.ca>", "committedDate": "2021-02-11T04:29:02Z", "type": "commit"}, {"oid": "46fc477f605ddc1158a12335082609d905f07b53", "url": "https://github.com/eclipse-openj9/openj9/commit/46fc477f605ddc1158a12335082609d905f07b53", "message": "Update read barriers to use the new LoadStoreHandler API\n\nPreviously, the code for performing read barriers was using the old\nMemoryReference-based API for performing its loads. This API is being\ndeprecated in OMR, so all code dealing with read barriers has been\nupdated to use the new LoadStoreHandler API.\n\nUnfortunately, this code cannot be updated in its current form to use\nLoadStoreHandler as intended since it unavoidably performs the load\nduring ICF. Thus, it currently uses generateComputeAddressSequence to\ncompute the address but does not use generateLoadAddressSequence to\nperform the load. This is safe since OpenJ9 is the most derived project\nthat could possibly overload LoadStoreHandler and emitting unnecessary\nsync instructions (while bad for performance) is not incorrect.\n\nThis code should be revisited later to make it more idiomatic, but that\nis beyond the scope of this particular change.\n\nSigned-off-by: Ben Thomas <ben@benthomas.ca>", "committedDate": "2021-02-11T04:29:02Z", "type": "commit"}, {"oid": "bf696f2d44715fd5a8582672ef80c93e7ed92be7", "url": "https://github.com/eclipse-openj9/openj9/commit/bf696f2d44715fd5a8582672ef80c93e7ed92be7", "message": "Update simple read monitors to use the new LoadStoreHandler API\n\nPreviously, the code for emitting simple read monitors was using the old\nMemoryReference-based API for performing the load. This API is being\ndeprecated in OMR, so all code dealing with read barriers has been\nupdated to use the new LoadStoreHandler API.\n\nSigned-off-by: Ben Thomas <ben@benthomas.ca>", "committedDate": "2021-02-11T04:29:02Z", "type": "commit"}, {"oid": "b93e826a2c87fcf670be5f0abe8bb439e9d2ba59", "url": "https://github.com/eclipse-openj9/openj9/commit/b93e826a2c87fcf670be5f0abe8bb439e9d2ba59", "message": "Update copyright dates to 2021\n\nSigned-off-by: Ben Thomas <ben@benthomas.ca>", "committedDate": "2021-02-11T04:29:02Z", "type": "commit"}, {"oid": "f8d77f91e715b71d9940157a813c53ddcbcd97d5", "url": "https://github.com/eclipse-openj9/openj9/commit/f8d77f91e715b71d9940157a813c53ddcbcd97d5", "message": "Remove assert at Julian's request\n\nSigned-off-by: Ben Thomas <ben@benthomas.ca>", "committedDate": "2021-02-11T05:04:24Z", "type": "commit"}, {"oid": "f8d77f91e715b71d9940157a813c53ddcbcd97d5", "url": "https://github.com/eclipse-openj9/openj9/commit/f8d77f91e715b71d9940157a813c53ddcbcd97d5", "message": "Remove assert at Julian's request\n\nSigned-off-by: Ben Thomas <ben@benthomas.ca>", "committedDate": "2021-02-11T05:04:24Z", "type": "forcePushed"}]}