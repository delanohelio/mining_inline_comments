{"pr_number": 8844, "pr_title": "Add mechanism for JITServer termination", "pr_createdAt": "2020-03-12T15:44:01Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/8844", "timeline": [{"oid": "25b5d856e087db5e896c501a3706fc370ed8f867", "url": "https://github.com/eclipse-openj9/openj9/commit/25b5d856e087db5e896c501a3706fc370ed8f867", "message": "Add JITServer_DestroyServer api\n\nAdded new API JITServer_DestroyServer to destroy JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>", "committedDate": "2020-03-12T16:04:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczMzA3OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391733079", "bodyText": "formatting?  Maybe?  Hard to tell when if statements don't always have { & }", "author": "DanHeidinga", "createdAt": "2020-03-12T16:16:31Z", "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error in polling socket: errno=%d\", errno);\n+\t exit(1);", "originalCommit": "25b5d856e087db5e896c501a3706fc370ed8f867", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc5ODc3MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391798771", "bodyText": "For a hard exit like this I would prefer a message to stderr, rather than the vlog (or in addition to the vlog). We used perror below, so we could use here as well.", "author": "mpirvu", "createdAt": "2020-03-12T18:02:03Z", "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error in polling socket: errno=%d\", errno);\n+\t exit(1);", "originalCommit": "25b5d856e087db5e896c501a3706fc370ed8f867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4ODAzNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391888036", "bodyText": "Done.", "author": "ashu-mehra", "createdAt": "2020-03-12T20:53:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc5ODc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxMTM5Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391811396", "bodyText": "Comment needs to be changed to reflect the new implementation.", "author": "mpirvu", "createdAt": "2020-03-12T18:25:35Z", "path": "runtime/compiler/runtime/Listener.hpp", "diffHunk": "@@ -37,12 +38,33 @@\n  \n     The current implementation does not provide code for nicely terminating the listener thread.\n  */\n+\n+#define OPENJ9_LISTENER_POLL_TIMEOUT 10 // in milliseconds\n+\n+class BaseCompileDispatcher;\n+\n class TR_Listener\n    {\n public:\n    TR_Listener();\n    static TR_Listener* allocate();\n    void startListenerThread(J9JavaVM *javaVM);\n+   void stop();\n+   /**\n+      @brief Function called to deal with incoming connection requests\n+\n+      This function opens a socket, binds it and then waits for incoming connection", "originalCommit": "25b5d856e087db5e896c501a3706fc370ed8f867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4ODA3MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391888071", "bodyText": "Done.", "author": "ashu-mehra", "createdAt": "2020-03-12T20:53:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxMTM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxMTc4Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391811786", "bodyText": "Should we increase this to 100 ms?", "author": "mpirvu", "createdAt": "2020-03-12T18:26:22Z", "path": "runtime/compiler/runtime/Listener.hpp", "diffHunk": "@@ -37,12 +38,33 @@\n  \n     The current implementation does not provide code for nicely terminating the listener thread.\n  */\n+\n+#define OPENJ9_LISTENER_POLL_TIMEOUT 10 // in milliseconds", "originalCommit": "25b5d856e087db5e896c501a3706fc370ed8f867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MDUwMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391880500", "bodyText": "10 ms was just a random value. We can set the timeout to 100 ms. The larger it is, the lesser it would wake up to check the flag.", "author": "ashu-mehra", "createdAt": "2020-03-12T20:36:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxMTc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyNjY4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391826681", "bodyText": "Is it possible for poll to fail with EINTR error code and still be able to continue?", "author": "mpirvu", "createdAt": "2020-03-12T18:54:08Z", "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {", "originalCommit": "25b5d856e087db5e896c501a3706fc370ed8f867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MjgzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391882831", "bodyText": "yup, added check for EINTR and continue.", "author": "ashu-mehra", "createdAt": "2020-03-12T20:41:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyNjY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyNjg4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391826882", "bodyText": "If the exit flag is set and we have an incomming connection request we will proceed with the connection request. I believe we still want to exit without handling this request.", "author": "mpirvu", "createdAt": "2020-03-12T18:54:31Z", "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error in polling socket: errno=%d\", errno);\n+\t exit(1);\n+         }\n+      int connfd = accept(sockfd, (struct sockaddr *)&cli_addr, &clilen);", "originalCommit": "25b5d856e087db5e896c501a3706fc370ed8f867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MjgxMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391882811", "bodyText": "right, fixed that.", "author": "ashu-mehra", "createdAt": "2020-03-12T20:41:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyNjg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyODA3Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391828073", "bodyText": "Do we have to check the flags set in revent? We could have POLLIN/POLLERR/POLLHUP/POLLNVAL", "author": "mpirvu", "createdAt": "2020-03-12T18:56:38Z", "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error in polling socket: errno=%d\", errno);\n+\t exit(1);\n+         }", "originalCommit": "25b5d856e087db5e896c501a3706fc370ed8f867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3OTY2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391879668", "bodyText": "We should never get POLLNVAL as it indicates bad fd.\nPOLLHUP can happen for connected sockets/pipes where one ends gets closed and we try to read from the other end. Again this does not apply to our case.\nPOLLERR indicates \"an asynchronous error occurred\" (http://man7.org/linux/man-pages/man7/socket.7.html). Doesn't look like it applies to listening socket.\nOnly flag left is POLLIN which indicates request for new connection.", "author": "ashu-mehra", "createdAt": "2020-03-12T20:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyODA3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ1OTg0Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r392459842", "bodyText": "I see in this example: https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_71/rzab6/poll.htm that a check of\n      if(fds[i].revents != POLLIN)\n      {\n        printf(\"  Error! revents = %d\\n\", fds[i].revents);\n        end_server = TRUE;\n        break;\n      }\n\nis done. Maybe we should do the same to be sure.", "author": "mpirvu", "createdAt": "2020-03-13T20:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyODA3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAzMTk1Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r393031953", "bodyText": "I have added a new commit with this change. I also added a do-while loop for accepting new connections as per the example mentioned in the link in previous comment, so that we can avoid calling poll() if multiple clients are ready.", "author": "ashu-mehra", "createdAt": "2020-03-16T13:44:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyODA3Mw=="}], "type": "inlineReview"}, {"oid": "95d2e77935e71a9b3282fde00c58cb3260397681", "url": "https://github.com/eclipse-openj9/openj9/commit/95d2e77935e71a9b3282fde00c58cb3260397681", "message": "Add JITServer_DestroyServer api\n\nAdded new API JITServer_DestroyServer to destroy JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>", "committedDate": "2020-03-12T20:53:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA2NjczNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r393066734", "bodyText": "Could we please fix the alignment of these two lines", "author": "mpirvu", "createdAt": "2020-03-16T14:28:11Z", "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,305 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      /* check if we are exiting; if yes, there is no need to accept() new connection */\n+      if (getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (errno == EINTR)\n+            {\n+            continue;\n+\t    }\n+         else\n+            {\n+            perror(\"error in polling listening socket\");\n+\t    exit(1);\n+\t    }", "originalCommit": "0a32f9727ea13034a2b6d14b29fd818d1210c45c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA2NzI4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r393067283", "bodyText": "This lines needs two extra spaces", "author": "mpirvu", "createdAt": "2020-03-16T14:28:54Z", "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,305 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      /* check if we are exiting; if yes, there is no need to accept() new connection */\n+      if (getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (errno == EINTR)\n+            {\n+            continue;\n+\t    }\n+         else\n+            {\n+            perror(\"error in polling listening socket\");\n+\t    exit(1);\n+\t    }\n+         }\n+      else if (pfd.revents != POLLIN)\n+         {\n+         fprintf(stderr, \"Unexpected event occurred during poll for new connection: revents=%d\\n\", pfd.revents);\n+\t exit(1);", "originalCommit": "0a32f9727ea13034a2b6d14b29fd818d1210c45c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA2ODkwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r393068906", "bodyText": "On my screen these lines are not properly aligned", "author": "mpirvu", "createdAt": "2020-03-16T14:31:09Z", "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,305 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      /* check if we are exiting; if yes, there is no need to accept() new connection */\n+      if (getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (errno == EINTR)\n+            {\n+            continue;\n+\t    }\n+         else\n+            {\n+            perror(\"error in polling listening socket\");\n+\t    exit(1);\n+\t    }\n+         }\n+      else if (pfd.revents != POLLIN)\n+         {\n+         fprintf(stderr, \"Unexpected event occurred during poll for new connection: revents=%d\\n\", pfd.revents);\n+\t exit(1);\n+         }\n+      do\n+         {\n+         /* at this stage we should have a valid request for new connection */\n+         int connfd = accept(sockfd, (struct sockaddr *)&cli_addr, &clilen);\n+         if (connfd < 0)\n+            {\n+            if ((EAGAIN != errno) && (EWOULDBLOCK != errno))\n+               {\n+\t       if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+                  {\n+                  TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error accepting connection: errno=%d\", errno);\n+\t\t  }\n+\t       }\n+            }\n+         else\n+            {\n+            struct timeval timeoutMsForConnection = {(timeoutMs / 1000), ((timeoutMs % 1000) * 1000)};\n+            if (setsockopt(connfd, SOL_SOCKET, SO_RCVTIMEO, (void *)&timeoutMsForConnection, sizeof(timeoutMsForConnection)) < 0)\n+               {\n+               perror(\"Can't set option SO_RCVTIMEO on connfd socket\");\n+               exit(-1);\n+               }\n+            if (setsockopt(connfd, SOL_SOCKET, SO_SNDTIMEO, (void *)&timeoutMsForConnection, sizeof(timeoutMsForConnection)) < 0)\n+               {\n+               perror(\"Can't set option SO_SNDTIMEO on connfd socket\");\n+               exit(-1);\n+               }\n+\n+            BIO *bio = NULL;\n+            if (sslCtx && !acceptOpenSSLConnection(sslCtx, connfd, bio))\n+               continue;\n+\n+            JITServer::ServerStream *stream = new (PERSISTENT_NEW) JITServer::ServerStream(connfd, bio);\n+            compiler->compile(stream);\n+\t    }\n+         } while ((-1 != connfd) && !getListenerThreadExitFlag());\n+      }\n+", "originalCommit": "0a32f9727ea13034a2b6d14b29fd818d1210c45c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "921bf266683d23fee829a75245281116738f3885", "url": "https://github.com/eclipse-openj9/openj9/commit/921bf266683d23fee829a75245281116738f3885", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>", "committedDate": "2020-03-16T15:01:09Z", "type": "forcePushed"}, {"oid": "066ff297056b631eb4b4b0bb678a120637c069aa", "url": "https://github.com/eclipse-openj9/openj9/commit/066ff297056b631eb4b4b0bb678a120637c069aa", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>", "committedDate": "2020-03-16T18:09:41Z", "type": "forcePushed"}, {"oid": "f2199593d304483960533775336a776faba0775f", "url": "https://github.com/eclipse-openj9/openj9/commit/f2199593d304483960533775336a776faba0775f", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>", "committedDate": "2020-03-19T15:19:34Z", "type": "forcePushed"}, {"oid": "638129acd37bf636acc6f3df0d873c6821e9c633", "url": "https://github.com/eclipse-openj9/openj9/commit/638129acd37bf636acc6f3df0d873c6821e9c633", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>", "committedDate": "2020-03-19T15:43:18Z", "type": "forcePushed"}, {"oid": "68c9014ea8432c2531457a5eef3754e2bc26be96", "url": "https://github.com/eclipse-openj9/openj9/commit/68c9014ea8432c2531457a5eef3754e2bc26be96", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>", "committedDate": "2020-03-19T15:46:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1MDU0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r396450543", "bodyText": "These brackets are not aligned properly", "author": "mpirvu", "createdAt": "2020-03-23T13:30:11Z", "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,309 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{", "originalCommit": "68c9014ea8432c2531457a5eef3754e2bc26be96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1Mjc3NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r396452775", "bodyText": "I would leave if (getListenerThreadExitFlag()) as the first test. Error or not, timeout or not, if it's time to exit, we should exit.", "author": "mpirvu", "createdAt": "2020-03-23T13:33:28Z", "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,309 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+      int connfd = -1;\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if (0 == rc) // poll() timed out and no fd is ready\n+         {\n+         continue;\n+         }\n+      else if (getListenerThreadExitFlag()) // if we are exiting, there is no need to accept() new connection", "originalCommit": "68c9014ea8432c2531457a5eef3754e2bc26be96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "84dba618b545b05f16e21b6366ea45d0a5b11086", "url": "https://github.com/eclipse-openj9/openj9/commit/84dba618b545b05f16e21b6366ea45d0a5b11086", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>", "committedDate": "2020-03-23T14:57:42Z", "type": "forcePushed"}, {"oid": "0493378ca973e22e4243db6c1588ac7fe2378f89", "url": "https://github.com/eclipse-openj9/openj9/commit/0493378ca973e22e4243db6c1588ac7fe2378f89", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>", "committedDate": "2020-03-23T17:34:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzODI4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r396638288", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Stopts the JITServer.\n          \n          \n            \n             * Stops the JITServer.", "author": "DanHeidinga", "createdAt": "2020-03-23T17:44:59Z", "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stopts the JITServer.", "originalCommit": "0493378ca973e22e4243db6c1588ac7fe2378f89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcwOTYwMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r396709603", "bodyText": "Done", "author": "ashu-mehra", "createdAt": "2020-03-23T19:40:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzODI4OA=="}], "type": "inlineReview"}, {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8", "url": "https://github.com/eclipse-openj9/openj9/commit/85f9af8d79769368bec576c717038cbdc2018ba8", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>", "committedDate": "2020-03-23T19:40:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1OTExNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397259115", "bodyText": "If this is freeing the jitServer, it should take a pointer to the pointer and update it to null.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            stopJITServer(JITServer *jitServer)\n          \n          \n            \n            stopJITServer(JITServer **jitServer)", "author": "DanHeidinga", "createdAt": "2020-03-24T15:48:58Z", "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer pointer to the JITServer interface\n+ *\n+ * @returns void\n+ */\n+static void\n+stopJITServer(JITServer *jitServer)", "originalCommit": "85f9af8d79769368bec576c717038cbdc2018ba8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzMTg1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398631850", "bodyText": "Done", "author": "ashu-mehra", "createdAt": "2020-03-26T14:48:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1OTExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1OTQ1Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397259457", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tfree(jitServer);\n          \n          \n            \n            \tfree(*jitServer);\n          \n          \n            \n            \t*jitServer = NULL;", "author": "DanHeidinga", "createdAt": "2020-03-24T15:49:23Z", "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer pointer to the JITServer interface\n+ *\n+ * @returns void\n+ */\n+static void\n+stopJITServer(JITServer *jitServer)\n+{\n+\tJavaVM *vm = jitServer->jvm;\n+\t(*vm)->DestroyJavaVM(vm);\n+\tfree(jitServer);", "originalCommit": "85f9af8d79769368bec576c717038cbdc2018ba8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzMTkxMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398631910", "bodyText": "Done", "author": "ashu-mehra", "createdAt": "2020-03-26T14:48:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1OTQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzU0MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397267541", "bodyText": "Should this return a jint /int32_t?  It would allow propagating the result from DestroyJavaVM", "author": "DanHeidinga", "createdAt": "2020-03-24T15:59:22Z", "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer pointer to the JITServer interface\n+ *\n+ * @returns void\n+ */\n+static void", "originalCommit": "85f9af8d79769368bec576c717038cbdc2018ba8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzMjA4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398632082", "bodyText": "Done", "author": "ashu-mehra", "createdAt": "2020-03-26T14:48:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzkyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397267926", "bodyText": "nitpick to make it consistent with the other 2 functions\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tvoid (*stopJITServer)(struct JITServer *);\n          \n          \n            \n            \tvoid (* stopJITServer)(struct JITServer *);", "author": "DanHeidinga", "createdAt": "2020-03-24T15:59:51Z", "path": "runtime/oti/jitserver_api.h", "diffHunk": "@@ -34,6 +34,7 @@ struct JITServer; /* Forward declaration */\n typedef struct JITServer {\n \tint32_t (* startJITServer)(struct JITServer *);\n \tint32_t (* waitForJITServerTermination)(struct JITServer *);\n+\tvoid (*stopJITServer)(struct JITServer *);", "originalCommit": "85f9af8d79769368bec576c717038cbdc2018ba8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MTg1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397271855", "bodyText": "It would be good to document each of these functions if they are intended to be used by end users akin to Java's Invocation API", "author": "DanHeidinga", "createdAt": "2020-03-24T16:04:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzkyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3MDI5Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398170296", "bodyText": "Do you want me to add comments like this to the function pointers in JITServer structure, or you are referring to documenting these APIs separately in a markdown doc?", "author": "ashu-mehra", "createdAt": "2020-03-25T21:08:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzkyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc5MjQwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398792408", "bodyText": "Those kinds of comments would be a good start.  Eventually we'll want the markdown file that describes the API and how to use it but that can be done in a separate PR", "author": "DanHeidinga", "createdAt": "2020-03-26T18:18:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzkyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2OTg4Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397269886", "bodyText": "Does this actually stop the server?  DestroyJavaVM typically waits until there are no-non daemon threads - are you intentionally depending on that behaviour?  Would be good to add a comment here if that's the intention", "author": "DanHeidinga", "createdAt": "2020-03-24T16:02:19Z", "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer pointer to the JITServer interface\n+ *\n+ * @returns void\n+ */\n+static void\n+stopJITServer(JITServer *jitServer)\n+{\n+\tJavaVM *vm = jitServer->jvm;\n+\t(*vm)->DestroyJavaVM(vm);", "originalCommit": "85f9af8d79769368bec576c717038cbdc2018ba8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2Njk4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398066983", "bodyText": "From JITServer point of view we only want to terminate the Listener thread and we get this chance when DestroyJavaVM is invoked (protectedDestroyJavaVM -> runExitStages -> jitExclusiveVMShutdownPending -> listener->stop).", "author": "ashu-mehra", "createdAt": "2020-03-25T18:10:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2OTg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA3MTUwMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398071503", "bodyText": "Then I'm very unclear on the way to use the APIs here.  When does stopJITServer get called vs waitForJITServerTermination?", "author": "DanHeidinga", "createdAt": "2020-03-25T18:17:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2OTg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA4NDU1OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398084559", "bodyText": "My reply here probably addresses your question to some extent.", "author": "ashu-mehra", "createdAt": "2020-03-25T18:38:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2OTg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MjU5OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397272598", "bodyText": "I don't see a call to this function occurring anywhere.  Should the jitserver launcher be updated to call it after waiting for waitForJITServerTermination() to free resources?\nhttps://github.com/eclipse/openj9/blob/f2034099d7765870ecae55540642096e847fac52/runtime/jitserver_launcher/jitserver.c#L361", "author": "DanHeidinga", "createdAt": "2020-03-24T16:05:46Z", "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1492,6 +1495,7 @@ JITServer_CreateServer(JITServer **jitServer, void *serverArgs)\n \t}\n \tserver->startJITServer = startJITServer;\n \tserver->waitForJITServerTermination = waitForJITServerTermination;\n+\tserver->stopJITServer = stopJITServer;", "originalCommit": "85f9af8d79769368bec576c717038cbdc2018ba8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA3MTA5MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398071090", "bodyText": "Yes, jitserver would need to be updated to call stopJITServer, but we don't yet have any trigger to call this function. waitForJITServerTermination API should ideally be waiting for some 'event' which would tell jitserver to call stopJITServer, but we don't yet have that \"event\" in place.\nAs per the discussion in the parent issue, the mechanism to call stopJITServer needs to be discussed separately.", "author": "ashu-mehra", "createdAt": "2020-03-25T18:17:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MjU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc5ODI3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398798277", "bodyText": "Part of my problem with understanding the API is the rename from JITServer_DestroyServer -> stopJITServer as it confuses the purpose of the function and breaks the parallel with the JITServer_CreateServer call.\nIf this new function was changed back to destoryJITServer or similar name, the difference between it and waitForJITServerTermination would be clearer.  The expected pattern would then be something like:\nJITServer_CreateServer(&jitServer, ...);\n....\njitServer-> waitForJITServerTermination();\n//clean up resources\njitServer->destroyJITServer(&jitServer);\nwhere destroyJITServer would be responsible for freeing the resources allocated by CreateServer", "author": "DanHeidinga", "createdAt": "2020-03-26T18:27:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MjU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgyMzg0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398823843", "bodyText": "ok, I don't mind changing the api from stopJITServer to destroyJITServer.", "author": "ashu-mehra", "createdAt": "2020-03-26T19:07:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MjU5OA=="}], "type": "inlineReview"}, {"oid": "5ad38de11689adf2ff4c6dd172a6a413e6134aeb", "url": "https://github.com/eclipse-openj9/openj9/commit/5ad38de11689adf2ff4c6dd172a6a413e6134aeb", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>", "committedDate": "2020-03-25T18:47:02Z", "type": "forcePushed"}, {"oid": "36cedd509de9259dfcc91a1734dacc0e8a160013", "url": "https://github.com/eclipse-openj9/openj9/commit/36cedd509de9259dfcc91a1734dacc0e8a160013", "message": "Add code for terminating JITServer\n\nAdded new API destroyJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>", "committedDate": "2020-03-26T22:37:05Z", "type": "forcePushed"}, {"oid": "3a197144440bc0248e5ca915ee06838cdf8ee11d", "url": "https://github.com/eclipse-openj9/openj9/commit/3a197144440bc0248e5ca915ee06838cdf8ee11d", "message": "Add code for terminating JITServer\n\nAdded new API destroyJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>", "committedDate": "2020-03-27T17:53:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MTQ4MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r401181480", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Stops the JITServer.\n          \n          \n            \n             * Frees the resources allocated by JITServer_CreateServer.", "author": "DanHeidinga", "createdAt": "2020-03-31T20:06:00Z", "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1572,31 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.", "originalCommit": "3a197144440bc0248e5ca915ee06838cdf8ee11d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MTc2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r401181768", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @param jitServer double pointer to the JITServer interface\n          \n          \n            \n             * @param jitServer double pointer to the JITServer interface.  Must not be null", "author": "DanHeidinga", "createdAt": "2020-03-31T20:06:35Z", "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1572,31 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer double pointer to the JITServer interface", "originalCommit": "3a197144440bc0248e5ca915ee06838cdf8ee11d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MjEwNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r401182104", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Stops the JITServer.\n          \n          \n            \n            \t * Frees the resources allocated by JITServer_CreateServer.", "author": "DanHeidinga", "createdAt": "2020-03-31T20:07:03Z", "path": "runtime/oti/jitserver_api.h", "diffHunk": "@@ -32,8 +32,32 @@ extern \"C\" {\n struct JITServer; /* Forward declaration */\n \n typedef struct JITServer {\n+\t/**\n+\t * Starts an instance of JITServer.\n+\t *\n+\t * @param jitServer pointer to the JITServer interface\n+\t *\n+\t * @returns JITSERVER_OK on success, else negative error code\n+\t */\n \tint32_t (* startJITServer)(struct JITServer *);\n+\t/**\n+\t * Wait for JITServer to terminate.\n+\t *\n+\t * @param jitServer pointer to the JITServer interface\n+\t *\n+\t * @returns JITSERVER_OK on success, else negative error code\n+\t */\n \tint32_t (* waitForJITServerTermination)(struct JITServer *);\n+\t/**\n+\t * Stops the JITServer.", "originalCommit": "3a197144440bc0248e5ca915ee06838cdf8ee11d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MzI3NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r401183275", "bodyText": "This loses the reason for why DestroyJavaVM failed.  Unfortunate given this is returning JITSERVER error codes.  Tracepoints would help here - something to consider for the future - but not for this PR.", "author": "DanHeidinga", "createdAt": "2020-03-31T20:09:05Z", "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1572,31 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer double pointer to the JITServer interface\n+ *\n+ * @returns JITSERVER_OK on success, else negative error code\n+ *\n+ * @note on return *jitServer is set to NULL\n+ */\n+static int32_t\n+destroyJITServer(JITServer **jitServer)\n+{\n+\tJavaVM *vm = (*jitServer)->jvm;\n+\tjint rc = (*vm)->DestroyJavaVM(vm);\n+\tfree(*jitServer);\n+\t*jitServer = NULL;\n+\tif (JNI_OK == rc) {\n+\t\trc = JITSERVER_OK;\n+\t} else {\n+\t\trc = JITSERVER_DESTROY_ERROR;", "originalCommit": "3a197144440bc0248e5ca915ee06838cdf8ee11d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MzgyOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r401183828", "bodyText": "Now that it's clear this frees the resources, I'd like to see it called by the jitserver launcher.  It can be called after 1 waitForJITServerTermination` returns", "author": "DanHeidinga", "createdAt": "2020-03-31T20:10:02Z", "path": "runtime/oti/jitserver_api.h", "diffHunk": "@@ -32,8 +32,32 @@ extern \"C\" {\n struct JITServer; /* Forward declaration */\n \n typedef struct JITServer {\n+\t/**\n+\t * Starts an instance of JITServer.\n+\t *\n+\t * @param jitServer pointer to the JITServer interface\n+\t *\n+\t * @returns JITSERVER_OK on success, else negative error code\n+\t */\n \tint32_t (* startJITServer)(struct JITServer *);\n+\t/**\n+\t * Wait for JITServer to terminate.\n+\t *\n+\t * @param jitServer pointer to the JITServer interface\n+\t *\n+\t * @returns JITSERVER_OK on success, else negative error code\n+\t */\n \tint32_t (* waitForJITServerTermination)(struct JITServer *);\n+\t/**\n+\t * Stops the JITServer.\n+\t *\n+\t * @param jitServer double pointer to the JITServer interface\n+\t *\n+\t * @returns JITSERVER_OK on success, else negative error code\n+\t *\n+\t * @note on return *jitServer is set to NULL\n+\t */\n+\tint32_t (* destroyJITServer)(struct JITServer **);", "originalCommit": "3a197144440bc0248e5ca915ee06838cdf8ee11d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY5ODk0OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r401698948", "bodyText": "Added the call to destroyJITServer in jitserver launcher.", "author": "ashu-mehra", "createdAt": "2020-04-01T15:20:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MzgyOA=="}], "type": "inlineReview"}, {"oid": "1024582276da3ea16765289a11b13c5918c553b6", "url": "https://github.com/eclipse-openj9/openj9/commit/1024582276da3ea16765289a11b13c5918c553b6", "message": "Add code for terminating JITServer\n\nAdded new API destroyJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>", "committedDate": "2020-04-01T14:55:07Z", "type": "commit"}, {"oid": "1024582276da3ea16765289a11b13c5918c553b6", "url": "https://github.com/eclipse-openj9/openj9/commit/1024582276da3ea16765289a11b13c5918c553b6", "message": "Add code for terminating JITServer\n\nAdded new API destroyJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>", "committedDate": "2020-04-01T14:55:07Z", "type": "forcePushed"}]}