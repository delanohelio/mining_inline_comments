{"pr_number": 9938, "pr_title": "Added jitHelpers for store and load", "pr_createdAt": "2020-06-18T18:45:29Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9938", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzODE1Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r442438152", "bodyText": "there is no _sp in this context, value is paramObject", "author": "tajila", "createdAt": "2020-06-18T18:59:06Z", "path": "runtime/vm/ValueTypeHelpers.cpp", "diffHunk": "@@ -69,4 +69,85 @@ isClassRefQtype(J9Class *cpContextClass, U_16 cpIndex)\n {\n \treturn VM_ValueTypeHelpers::isClassRefQtype((J9ConstantPool *) cpContextClass->ramConstantPool, cpIndex);\n }\n+\n+\n+\n+\n+/**\n+ * Performs an aastore operation on an object. Handles flattened and non-flattened cases.\n+ *\n+ * If you can guarantee that receiverObject and paramObj will never be null then it\n+ * doesnt need to throw.\n+ *\n+ * @param[in] currentThread thread token\n+ * @param[in] receiverObject arrayobject\n+ * @param[in] index array index\n+ * @param[in] paramObject obj arg\n+ *\n+ */\n+void\n+jitAastore(J9VMThread currentThread, j9_object_t *arrayObject, U_32 index, j9_object_t *paramObject)\n+{\n+\n+        U_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+        j9object_t value = *(j9object_t*)_sp;", "originalCommit": "dc968f65d2ea995249f4d3c2b1749602e29bc6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzODQxOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r442438418", "bodyText": "this check should be moved out", "author": "tajila", "createdAt": "2020-06-18T18:59:32Z", "path": "runtime/vm/ValueTypeHelpers.cpp", "diffHunk": "@@ -69,4 +69,85 @@ isClassRefQtype(J9Class *cpContextClass, U_16 cpIndex)\n {\n \treturn VM_ValueTypeHelpers::isClassRefQtype((J9ConstantPool *) cpContextClass->ramConstantPool, cpIndex);\n }\n+\n+\n+\n+\n+/**\n+ * Performs an aastore operation on an object. Handles flattened and non-flattened cases.\n+ *\n+ * If you can guarantee that receiverObject and paramObj will never be null then it\n+ * doesnt need to throw.\n+ *\n+ * @param[in] currentThread thread token\n+ * @param[in] receiverObject arrayobject\n+ * @param[in] index array index\n+ * @param[in] paramObject obj arg\n+ *\n+ */\n+void\n+jitAastore(J9VMThread currentThread, j9_object_t *arrayObject, U_32 index, j9_object_t *paramObject)\n+{\n+\n+        U_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+        j9object_t value = *(j9object_t*)_sp;\n+        /* Runtime check class compatibility */\n+        if (false == objectArrayStoreAllowed(arrayObject, value)) {\n+                rc = THROW_ARRAY_STORE;", "originalCommit": "dc968f65d2ea995249f4d3c2b1749602e29bc6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0Mjc1OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r442442759", "bodyText": "add a new bool param called fast, if its fast you can use the fast allocator, otherwise the slow one.", "author": "tajila", "createdAt": "2020-06-18T19:07:55Z", "path": "runtime/vm/ValueTypeHelpers.cpp", "diffHunk": "@@ -69,4 +69,85 @@ isClassRefQtype(J9Class *cpContextClass, U_16 cpIndex)\n {\n \treturn VM_ValueTypeHelpers::isClassRefQtype((J9ConstantPool *) cpContextClass->ramConstantPool, cpIndex);\n }\n+\n+\n+\n+\n+/**\n+ * Performs an aastore operation on an object. Handles flattened and non-flattened cases.\n+ *\n+ * If you can guarantee that receiverObject and paramObj will never be null then it\n+ * doesnt need to throw.\n+ *\n+ * @param[in] currentThread thread token\n+ * @param[in] receiverObject arrayobject\n+ * @param[in] index array index\n+ * @param[in] paramObject obj arg\n+ *\n+ */\n+void\n+jitAastore(J9VMThread currentThread, j9_object_t *arrayObject, U_32 index, j9_object_t *paramObject)\n+{\n+\n+        U_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+        j9object_t value = *(j9object_t*)_sp;\n+        /* Runtime check class compatibility */\n+        if (false == objectArrayStoreAllowed(arrayObject, value)) {\n+                rc = THROW_ARRAY_STORE;\n+        } else {\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+                J9ArrayClass *arrayrefClass = (J9ArrayClass *) J9OBJECT_CLAZZ(_currentThread, arrayObject);\n+                if (J9_IS_J9CLASS_VALUETYPE(arrayrefClass->componentType)) {\n+                        if (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+                                _objectAccessBarrier.copyObjectFieldsToFlattenedArrayElement(_currentThread, arrayrefClass, value, (J9IndexableObject *) arrayObject, index);\n+                        } else {\n+                                _objectAccessBarrier.inlineIndexableObjectStoreObject(_currentThread, arrayObject, index, value);\n+                        }\n+                } else\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+                {\n+                        _objectAccessBarrier.inlineIndexableObjectStoreObject(_currentThread, arrayObject, index, value);\n+        }\n+}\n+\n+/**\n+ * Performs an aaload operation on an object. Handles flattened and non-flattened cases.\n+ *\n+ * If you can guarantee that receiverObject will never be null then it\n+ * doesnt need to throw.\n+ *\n+ * Returns null if newObjectRef retrieval fails.\n+ *\n+ * @param[in] currentThread thread token\n+ * @param[in] receiverObject arrayobject\n+ * @param[in] index array index\n+ *\n+ * @return array element\n+ */\n+j9_object_t\n+jitAaload(J9VMThread currentThread, j9_object_t *arrayObject, U_32 index)", "originalCommit": "dc968f65d2ea995249f4d3c2b1749602e29bc6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0MzEyMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r442443123", "bodyText": "no _sp in this context, need to return a value with JIT_RETURN_UDATA(obj);", "author": "tajila", "createdAt": "2020-06-18T19:08:44Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -748,7 +748,90 @@ old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n void* J9FASTCALL\n old_fast_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(1);\n+\tDECLARE_JIT_PARM(j9_object_t *, arrayObject, 1);\n+\tDECLARE_JIT_INT_PARM(index, 1);\n+\tvoid *slowPath = NULL;\n+\tif (fast_jitLoadFlattenableArrayElementImpl(currentThread, arrayObject, index)) {\n+\t\tslowPath = (void*) old_slow_jitLoadFlattenableArrayElement;\n+\t}\n+\treturn slowPath;\n+}\n+\n+void* J9FASTCALL\n+old_slow_jitLoadFlattenableArrayElementImpl(J9VMThread *currentThread)\n+{\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tJ9Class *arrayref = (J9Class*)currentThread->floatTemp1;\n+\tif (NULL == arrayref) {\n+\t\trc = THROW_NPE;\n+\t} else {\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(currentThread, arrayref);\n+\t\tU_32 index = *(U_32*)_sp;\n+\t\t/* By using U_32 for index, we also catch the negative case, as all negative values are\n+\t\t\t* greater than the maximum array size (31 bits unsigned).\n+\t\t\t*/\n+\t\tif (index >= arrayLength) {\n+\t\t\tcurrentThread->tempSlot = (UDATA)index;\n+\t\t\trc = THROW_AIOB;\n+\t\t} else {\n+\t\t\tj9object_t value = NULL;\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\t\tJ9Class *arrayrefClass = J9OBJECT_CLAZZ(currentThread, arrayref);\n+\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+\t\t\t\tj9object_t newObjectRef = _objectAllocate.inlineAllocateObject(currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, false, false);\n+\n+\t\t\t\tif (NULL == newObjectRef) {\n+\t\t\t\t\tbuildGenericSpecialStackFrame(REGISTER_ARGS, 0);\n+\t\t\t\t\tpushObjectInSpecialFrame(REGISTER_ARGS, arrayref);\n+\t\t\t\t\tupdateVMStruct(REGISTER_ARGS);\n+\t\t\t\t\tnewObjectRef = _vm->memoryManagerFunctions->J9AllocateObject(currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\t\t\tVMStructHasBeenUpdated(REGISTER_ARGS);\n+\t\t\t\t\tarrayref = popObjectInSpecialFrame(REGISTER_ARGS);\n+\t\t\t\t\trestoreGenericSpecialStackFrame(REGISTER_ARGS);\n+\t\t\t\t\tif (J9_UNEXPECTED(NULL == newObjectRef)) {\n+\t\t\t\t\t\trc = THROW_HEAP_OOM;\n+\t\t\t\t\t\treturn rc;\n+\t\t\t\t\t}\n+\t\t\t\t\tarrayrefClass = VM_VMHelpers::currentClass(arrayrefClass);\n+\t\t\t\t}\n+\n+\t\t\t\t_objectAccessBarrier.copyObjectFieldsFromFlattenedArrayElement(currentThread, (J9ArrayClass *) arrayrefClass, newObjectRef, (J9IndexableObject *) arrayref, index);\n+\t\t\t\tvalue = newObjectRef;\n+\t\t\t} else\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+\t\t\t{\n+\t\t\t\tvalue = _objectAccessBarrier.inlineIndexableObjectReadObject(currentThread, arrayref, index);\n+\t\t\t}\n+\t\t\t*(j9object_t*)_sp = value;\n+\t\t}\n+\t}\n+\treturn rc;\n+}\n+\n+static VMINLINE bool\n+fast_jitLoadFlattenableArrayElementImpl(J9VMThread currentThread, j9_object_t *arrayObject, U_32 index)\n+{\n+\tbool slowPathRequired = false;\n+\tif (NULL == arrayObject) {\n+\t\t\tgoto slow;\n+\t}\n+\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\tif (index >= arrayLength) {\n+\t\tgoto slow;\n+\t}\n+\tj9_object_t value = jitAaload(currentThread, arrayObject, index);\n+\tif (J9_UNEXPECTED(NULL == value)) {\n+\t\t\tgoto slow;\n+\t} else {\n+\t\t*(j9object_t*)_sp = value;", "originalCommit": "dc968f65d2ea995249f4d3c2b1749602e29bc6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0MzIwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r442443207", "bodyText": "no _sp in this context, need to return a value with JIT_RETURN_UDATA(obj);", "author": "tajila", "createdAt": "2020-06-18T19:08:56Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -748,7 +748,90 @@ old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n void* J9FASTCALL\n old_fast_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(1);\n+\tDECLARE_JIT_PARM(j9_object_t *, arrayObject, 1);\n+\tDECLARE_JIT_INT_PARM(index, 1);\n+\tvoid *slowPath = NULL;\n+\tif (fast_jitLoadFlattenableArrayElementImpl(currentThread, arrayObject, index)) {\n+\t\tslowPath = (void*) old_slow_jitLoadFlattenableArrayElement;\n+\t}\n+\treturn slowPath;\n+}\n+\n+void* J9FASTCALL\n+old_slow_jitLoadFlattenableArrayElementImpl(J9VMThread *currentThread)\n+{\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tJ9Class *arrayref = (J9Class*)currentThread->floatTemp1;\n+\tif (NULL == arrayref) {\n+\t\trc = THROW_NPE;\n+\t} else {\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(currentThread, arrayref);\n+\t\tU_32 index = *(U_32*)_sp;\n+\t\t/* By using U_32 for index, we also catch the negative case, as all negative values are\n+\t\t\t* greater than the maximum array size (31 bits unsigned).\n+\t\t\t*/\n+\t\tif (index >= arrayLength) {\n+\t\t\tcurrentThread->tempSlot = (UDATA)index;\n+\t\t\trc = THROW_AIOB;\n+\t\t} else {\n+\t\t\tj9object_t value = NULL;\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\t\tJ9Class *arrayrefClass = J9OBJECT_CLAZZ(currentThread, arrayref);\n+\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+\t\t\t\tj9object_t newObjectRef = _objectAllocate.inlineAllocateObject(currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, false, false);\n+\n+\t\t\t\tif (NULL == newObjectRef) {\n+\t\t\t\t\tbuildGenericSpecialStackFrame(REGISTER_ARGS, 0);\n+\t\t\t\t\tpushObjectInSpecialFrame(REGISTER_ARGS, arrayref);\n+\t\t\t\t\tupdateVMStruct(REGISTER_ARGS);\n+\t\t\t\t\tnewObjectRef = _vm->memoryManagerFunctions->J9AllocateObject(currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\t\t\tVMStructHasBeenUpdated(REGISTER_ARGS);\n+\t\t\t\t\tarrayref = popObjectInSpecialFrame(REGISTER_ARGS);\n+\t\t\t\t\trestoreGenericSpecialStackFrame(REGISTER_ARGS);\n+\t\t\t\t\tif (J9_UNEXPECTED(NULL == newObjectRef)) {\n+\t\t\t\t\t\trc = THROW_HEAP_OOM;\n+\t\t\t\t\t\treturn rc;\n+\t\t\t\t\t}\n+\t\t\t\t\tarrayrefClass = VM_VMHelpers::currentClass(arrayrefClass);\n+\t\t\t\t}\n+\n+\t\t\t\t_objectAccessBarrier.copyObjectFieldsFromFlattenedArrayElement(currentThread, (J9ArrayClass *) arrayrefClass, newObjectRef, (J9IndexableObject *) arrayref, index);\n+\t\t\t\tvalue = newObjectRef;\n+\t\t\t} else\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+\t\t\t{\n+\t\t\t\tvalue = _objectAccessBarrier.inlineIndexableObjectReadObject(currentThread, arrayref, index);\n+\t\t\t}\n+\t\t\t*(j9object_t*)_sp = value;", "originalCommit": "dc968f65d2ea995249f4d3c2b1749602e29bc6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0NDQ5OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r442444498", "bodyText": "dont think this helper is needed, you have just put the code in here", "author": "tajila", "createdAt": "2020-06-18T19:11:30Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -748,7 +748,90 @@ old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n void* J9FASTCALL\n old_fast_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(1);\n+\tDECLARE_JIT_PARM(j9_object_t *, arrayObject, 1);\n+\tDECLARE_JIT_INT_PARM(index, 1);\n+\tvoid *slowPath = NULL;\n+\tif (fast_jitLoadFlattenableArrayElementImpl(currentThread, arrayObject, index)) {", "originalCommit": "dc968f65d2ea995249f4d3c2b1749602e29bc6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0NTA5OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r442445099", "bodyText": "this will have to be added to a function table, same as the other one. you can rename them to [load/store]FlattenableArrayElement", "author": "tajila", "createdAt": "2020-06-18T19:12:43Z", "path": "runtime/vm/ValueTypeHelpers.cpp", "diffHunk": "@@ -69,4 +69,85 @@ isClassRefQtype(J9Class *cpContextClass, U_16 cpIndex)\n {\n \treturn VM_ValueTypeHelpers::isClassRefQtype((J9ConstantPool *) cpContextClass->ramConstantPool, cpIndex);\n }\n+\n+\n+\n+\n+/**\n+ * Performs an aastore operation on an object. Handles flattened and non-flattened cases.\n+ *\n+ * If you can guarantee that receiverObject and paramObj will never be null then it\n+ * doesnt need to throw.\n+ *\n+ * @param[in] currentThread thread token\n+ * @param[in] receiverObject arrayobject\n+ * @param[in] index array index\n+ * @param[in] paramObject obj arg\n+ *\n+ */\n+void\n+jitAastore(J9VMThread currentThread, j9_object_t *arrayObject, U_32 index, j9_object_t *paramObject)", "originalCommit": "dc968f65d2ea995249f4d3c2b1749602e29bc6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0NjE5OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r442446198", "bodyText": "you need the index as well", "author": "tajila", "createdAt": "2020-06-18T19:14:58Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -748,7 +748,90 @@ old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n void* J9FASTCALL\n old_fast_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(1);\n+\tDECLARE_JIT_PARM(j9_object_t *, arrayObject, 1);\n+\tDECLARE_JIT_INT_PARM(index, 1);\n+\tvoid *slowPath = NULL;\n+\tif (fast_jitLoadFlattenableArrayElementImpl(currentThread, arrayObject, index)) {\n+\t\tslowPath = (void*) old_slow_jitLoadFlattenableArrayElement;\n+\t}\n+\treturn slowPath;\n+}\n+\n+void* J9FASTCALL\n+old_slow_jitLoadFlattenableArrayElementImpl(J9VMThread *currentThread)\n+{\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tJ9Class *arrayref = (J9Class*)currentThread->floatTemp1;", "originalCommit": "dc968f65d2ea995249f4d3c2b1749602e29bc6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0ODUzNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r442448537", "bodyText": "should  be using the VT helper here as well, with fast = FALSE", "author": "tajila", "createdAt": "2020-06-18T19:19:50Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -748,7 +748,90 @@ old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n void* J9FASTCALL\n old_fast_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(1);\n+\tDECLARE_JIT_PARM(j9_object_t *, arrayObject, 1);\n+\tDECLARE_JIT_INT_PARM(index, 1);\n+\tvoid *slowPath = NULL;\n+\tif (fast_jitLoadFlattenableArrayElementImpl(currentThread, arrayObject, index)) {\n+\t\tslowPath = (void*) old_slow_jitLoadFlattenableArrayElement;\n+\t}\n+\treturn slowPath;\n+}\n+\n+void* J9FASTCALL\n+old_slow_jitLoadFlattenableArrayElementImpl(J9VMThread *currentThread)\n+{\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tJ9Class *arrayref = (J9Class*)currentThread->floatTemp1;\n+\tif (NULL == arrayref) {\n+\t\trc = THROW_NPE;\n+\t} else {\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(currentThread, arrayref);\n+\t\tU_32 index = *(U_32*)_sp;\n+\t\t/* By using U_32 for index, we also catch the negative case, as all negative values are\n+\t\t\t* greater than the maximum array size (31 bits unsigned).\n+\t\t\t*/\n+\t\tif (index >= arrayLength) {\n+\t\t\tcurrentThread->tempSlot = (UDATA)index;\n+\t\t\trc = THROW_AIOB;\n+\t\t} else {\n+\t\t\tj9object_t value = NULL;", "originalCommit": "dc968f65d2ea995249f4d3c2b1749602e29bc6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ1MDAwMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r442450002", "bodyText": "when throwing exceptions you need to set it to the correct exception routine. Examples are:\naddr = setHeapOutOfMemoryErrorFromJIT(currentThread);\naddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGINSTANTIATIONERROR | J9_EX_CTOR_CLASS, J9VM_J9CLASS_TO_HEAPCLASS(objectClass));", "author": "tajila", "createdAt": "2020-06-18T19:22:46Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -748,7 +748,90 @@ old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n void* J9FASTCALL\n old_fast_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(1);\n+\tDECLARE_JIT_PARM(j9_object_t *, arrayObject, 1);\n+\tDECLARE_JIT_INT_PARM(index, 1);\n+\tvoid *slowPath = NULL;\n+\tif (fast_jitLoadFlattenableArrayElementImpl(currentThread, arrayObject, index)) {\n+\t\tslowPath = (void*) old_slow_jitLoadFlattenableArrayElement;\n+\t}\n+\treturn slowPath;\n+}\n+\n+void* J9FASTCALL\n+old_slow_jitLoadFlattenableArrayElementImpl(J9VMThread *currentThread)\n+{\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tJ9Class *arrayref = (J9Class*)currentThread->floatTemp1;\n+\tif (NULL == arrayref) {\n+\t\trc = THROW_NPE;", "originalCommit": "dc968f65d2ea995249f4d3c2b1749602e29bc6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dc968f65d2ea995249f4d3c2b1749602e29bc6dd", "url": "https://github.com/eclipse-openj9/openj9/commit/dc968f65d2ea995249f4d3c2b1749602e29bc6dd", "message": "Added jitHelpers for store and load\n\nAdded jitHelper for load and store of flatenable array elements\n- Created fast and slow variants\n\nAdded ValueTypeHelpers aaload and aastore. Both handle flattened\nand unflattened cases.\n-aaload: Fast loading of flattenable array element\n-aastore: Fast storing of flattenable array element\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-06-18T18:42:58Z", "type": "forcePushed"}, {"oid": "eee32df3914ce2518d4b1ad454a40ee90dd0282a", "url": "https://github.com/eclipse-openj9/openj9/commit/eee32df3914ce2518d4b1ad454a40ee90dd0282a", "message": "Added jitHelpers for store and load\n\nAdded jitHelper for load and store of flatenable array elements\n- Created fast and slow variants\n\nAdded ValueTypeHelpers aaload and aastore. Both handle flattened\nand unflattened cases.\n-aaload: Fast loading of flattenable array element\n-aastore: Fast storing of flattenable array element\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-06-19T15:35:35Z", "type": "forcePushed"}, {"oid": "33de2de91fd593a96cf622a1bb18545e0707f099", "url": "https://github.com/eclipse-openj9/openj9/commit/33de2de91fd593a96cf622a1bb18545e0707f099", "message": "TEMP AND UNTESTED, WILL BE SQUASHED ONCE FIXED:\nAdded functions old_fast_jitLoadFlattenableArrayElement and old_slow_jitLoadFlattenableArrayElement\nAdded cpp and c versions of jitAaload.", "committedDate": "2020-06-24T18:50:35Z", "type": "forcePushed"}, {"oid": "32f839adf5ef8b8951eade1b29411f15f2ecb768", "url": "https://github.com/eclipse-openj9/openj9/commit/32f839adf5ef8b8951eade1b29411f15f2ecb768", "message": "Added jitHelpers for store and load\n\nAdded jitHelper for load and store of flatenable array elements\n- Created fast and slow variants\n\nAdded ValueTypeHelpers aaload and aastore. Both handle flattened\nand unflattened cases.\n-aaload: Fast loading of flattenable array element\n-aastore: Fast storing of flattenable array element\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>\n\nTEMP AND UNTESTED, WILL BE SQUASHED ONCE FIXED:\nAdded functions old_fast_jitLoadFlattenableArrayElement and old_slow_jitLoadFlattenableArrayElement\nAdded cpp and c versions of jitAaload.", "committedDate": "2020-06-24T19:01:10Z", "type": "forcePushed"}, {"oid": "3e1cbd0acaf551a0dfea0ec94bed44566d353a34", "url": "https://github.com/eclipse-openj9/openj9/commit/3e1cbd0acaf551a0dfea0ec94bed44566d353a34", "message": "Added jitHelpers for store and load\n\nAdded jitHelper for load and store of flatenable array elements\n- Created fast and slow variants\n\nAdded ValueTypeHelpers aaload and aastore. Both handle flattened\nand unflattened cases.\n-aaload: Fast loading of flattenable array element\n-aastore: Fast storing of flattenable array element\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>\n\nTEMP AND UNTESTED, WILL BE SQUASHED ONCE FIXED:\nAdded functions old_fast_jitLoadFlattenableArrayElement and old_slow_jitLoadFlattenableArrayElement\nAdded cpp and c versions of jitAaload.", "committedDate": "2020-06-24T19:37:01Z", "type": "forcePushed"}, {"oid": "f2990057784f7f70139181ee3561d32204a47cc1", "url": "https://github.com/eclipse-openj9/openj9/commit/f2990057784f7f70139181ee3561d32204a47cc1", "message": "Added jitHelpers for store and load\n\nAdded jitHelper for load and store of flatenable array elements\n- Created fast and slow variants\n\nAdded ValueTypeHelpers aaload and aastore. Both handle flattened\nand unflattened cases.\n-aaload: Fast loading of flattenable array element\n-aastore: Fast storing of flattenable array element\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-06-24T20:19:16Z", "type": "forcePushed"}, {"oid": "f813c7025fd486ae924ae0ad5eecf22e6ddfd2c7", "url": "https://github.com/eclipse-openj9/openj9/commit/f813c7025fd486ae924ae0ad5eecf22e6ddfd2c7", "message": "Added jitHelpers for store and load\n\nAdded jitHelper for load and store of flatenable array elements\n- Created fast and slow variants\n\nAdded ValueTypeHelpers aaload and aastore. Both handle flattened\nand unflattened cases.\n-aaload: Fast loading of flattenable array element\n-aastore: Fast storing of flattenable array element\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-06-24T20:23:30Z", "type": "forcePushed"}, {"oid": "8dd45d67d8e07460793ec76d5961442f5e57b9aa", "url": "https://github.com/eclipse-openj9/openj9/commit/8dd45d67d8e07460793ec76d5961442f5e57b9aa", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers aaload and aastore. Both handle flattened\nand unflattened cases. Both contain an option for either a fast\nor a slow variant.\n-jitAaload: Loads flattenable array element\n-jitAastore: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls aaLoad\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls aaStore\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-06-25T14:44:57Z", "type": "forcePushed"}, {"oid": "18e87736f2e0719dea43b913c1d2803f62a91b57", "url": "https://github.com/eclipse-openj9/openj9/commit/18e87736f2e0719dea43b913c1d2803f62a91b57", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers aaload and aastore. Both handle flattened\nand unflattened cases. Both contain an option for either a fast\nor a slow variant.\n-jitAaload: Loads flattenable array element\n-jitAastore: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls aaLoad\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls aaStore\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-06-25T16:11:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcwNjc5MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r447706790", "bodyText": "this can be moved above the done: label so you dont need the !slowPathUsed", "author": "tajila", "createdAt": "2020-06-30T14:01:37Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -742,13 +742,68 @@ old_fast_jitPutFlattenableStaticField(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayObject = (j9object_t)currentThread->floatTemp1;\n+\tU_32 index = *((U_32 *)currentThread->floatTemp2);\n+\tvoid *addr = NULL;\n+\tif (NULL == arrayObject) {\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t value = NULL;\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\t\tif (index >= arrayLength) {\n+\t\t\tcurrentThread->tempSlot = (UDATA)index;\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);\n+\t\t} else {\n+\t\t\t\tvalue = currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, false);\n+\t\t\t\tif (NULL == value) {\n+\t\t\t\t\taddr = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\t\t}\n+\t\tJIT_RETURN_UDATA(value);\n+\t}\n+done:\n+\treturn addr;\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\n }\n \n void* J9FASTCALL\n old_fast_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(2);\n+\tDECLARE_JIT_PARM(j9object_t, arrayObject, 1);\n+\tDECLARE_JIT_INT_PARM(index, 2);\n+\n+\tvoid* slowPath = NULL;\n+\tbool slowPathUsed = false;\n+\tj9object_t value = NULL;\n+\tU_32 arrayLength = 0; /* initialized here to not cross the goto statement and so it isn't initalized with a NULL arrayObject; */\n+\n+\tif (NULL == arrayObject) {\n+\t\t\tgoto slow;\n+\t}\n+\tarrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\tif (index >= arrayLength) {\n+\t\tgoto slow;\n+\t}\n+\tvalue = (j9object_t) currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, true);\n+\tif (J9_UNEXPECTED(NULL == value)) {\n+\t\t\tgoto slow;\n+\t}\n+\n+done:\n+\tif (!slowPathUsed) {", "originalCommit": "18e87736f2e0719dea43b913c1d2803f62a91b57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcwODU4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r447708582", "bodyText": "why is this moved?", "author": "tajila", "createdAt": "2020-06-30T14:04:03Z", "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -3496,6 +3496,8 @@ typedef struct J9ClassCastParms {\n \n typedef struct J9JITConfig {\n \tIDATA  ( *entryPoint)(struct J9JITConfig *jitConfig, struct J9VMThread *vmStruct, J9Method *method, void *oldStartPC) ;\n+\tvoid *old_fast_jitLoadFlattenableArrayElement;", "originalCommit": "18e87736f2e0719dea43b913c1d2803f62a91b57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcwODczOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r447708739", "bodyText": "i dont think you need the slow version", "author": "tajila", "createdAt": "2020-06-30T14:04:16Z", "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -3496,6 +3496,8 @@ typedef struct J9ClassCastParms {\n \n typedef struct J9JITConfig {\n \tIDATA  ( *entryPoint)(struct J9JITConfig *jitConfig, struct J9VMThread *vmStruct, J9Method *method, void *oldStartPC) ;\n+\tvoid *old_fast_jitLoadFlattenableArrayElement;\n+\tvoid *old_slow_jitLoadFlattenableArrayElement;", "originalCommit": "18e87736f2e0719dea43b913c1d2803f62a91b57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcwOTA5Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r447709097", "bodyText": "indenting needs to be fixed, make sure you are using tabs not spaces", "author": "tajila", "createdAt": "2020-06-30T14:04:45Z", "path": "runtime/vm/ValueTypeHelpers.cpp", "diffHunk": "@@ -168,5 +168,20 @@ arrayElementSize(J9ArrayClass* arrayClass)\n         Assert_VM_notNull(arrayClass);\n         return arrayClass->flattenedElementSize;\n }\n+void\n+storeFlattenableArrayElement(J9VMThread *currentThread, j9object_t arrayObject, U_32 index, j9object_t *paramObject, BOOLEAN fast)\n+{\n+        MM_ObjectAccessBarrierAPI objectAccessBarrier(currentThread);\n+        VM_ValueTypeHelpers::jitAastore(currentThread, objectAccessBarrier, arrayObject, index, paramObject, fast);\n+\n+}\n+\n+j9object_t\n+loadFlattenableArrayElement(J9VMThread *currentThread, j9object_t arrayObject, U_32 index, BOOLEAN fast)\n+{\n+        MM_ObjectAccessBarrierAPI objectAccessBarrier(currentThread);", "originalCommit": "18e87736f2e0719dea43b913c1d2803f62a91b57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcwOTMwMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r447709300", "bodyText": "same thing here with the indenting", "author": "tajila", "createdAt": "2020-06-30T14:05:00Z", "path": "runtime/vm/ValueTypeHelpers.hpp", "diffHunk": "@@ -255,6 +255,75 @@ class VM_ValueTypeHelpers {\n \t\treturn rc;\n \t}\n \n+\tstatic VMINLINE void\n+\tjitAastore(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI _objectAccessBarrier, j9object_t arrayObject, U_32 index, j9object_t *paramObject, bool fast)\n+\t{\n+\t#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)", "originalCommit": "18e87736f2e0719dea43b913c1d2803f62a91b57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcxMDE3Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r447710172", "bodyText": "if you are doing an out-of-line allocation youll need to build a special frame in case of a GC", "author": "tajila", "createdAt": "2020-06-30T14:06:08Z", "path": "runtime/vm/ValueTypeHelpers.hpp", "diffHunk": "@@ -255,6 +255,75 @@ class VM_ValueTypeHelpers {\n \t\treturn rc;\n \t}\n \n+\tstatic VMINLINE void\n+\tjitAastore(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI _objectAccessBarrier, j9object_t arrayObject, U_32 index, j9object_t *paramObject, bool fast)\n+\t{\n+\t#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\t\tJ9ArrayClass *arrayrefClass = (J9ArrayClass *) J9OBJECT_CLAZZ(currentThread, arrayObject);\n+\t\t\tif (J9_IS_J9CLASS_VALUETYPE(arrayrefClass->componentType)) {\n+\t\t\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+\t\t\t\t\t\t\t_objectAccessBarrier.copyObjectFieldsToFlattenedArrayElement(currentThread, arrayrefClass, *paramObject, (J9IndexableObject *) arrayObject, index);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t_objectAccessBarrier.inlineIndexableObjectStoreObject(currentThread, arrayObject, index, *paramObject);\n+\t\t\t\t\t}\n+\t\t\t} else\n+\t#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+\t\t\t{\n+\t\t\t\t\t_objectAccessBarrier.inlineIndexableObjectStoreObject(currentThread, arrayObject, index, *paramObject);\n+\t\t\t}\n+\t}\n+\n+\tstatic VMINLINE j9object_t\n+\tjitAaload(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI _objectAccessBarrier, MM_ObjectAllocationAPI _objectAllocate, j9object_t arrayObject, U_32 index, bool fast)\n+\t{\n+        j9object_t value = NULL;\n+\n+        if (fast) {\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+                J9Class *arrayrefClass = J9OBJECT_CLAZZ(currentThread, arrayObject);\n+                if (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+                        j9object_t newObjectRef = _objectAllocate.inlineAllocateObject(currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, false, false);\n+                        if (NULL == newObjectRef) {\n+\t\t\t\t\t\t\tvalue = newObjectRef;\n+\t\t\t\t\t\t\tgoto done;\n+                        }\n+                        _objectAccessBarrier.copyObjectFieldsFromFlattenedArrayElement(currentThread, (J9ArrayClass *) arrayrefClass, newObjectRef, (J9IndexableObject *)arrayObject, index);\n+                        value = newObjectRef;\n+                } else\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+                {\n+                        value = _objectAccessBarrier.inlineIndexableObjectReadObject(currentThread, arrayObject, index);\n+                }\n+        } else if (NULL != arrayObject) {\n+\t\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(currentThread, arrayObject);\n+\t\t\tif (index >= arrayLength) {\n+\t\t\t\tcurrentThread->tempSlot = (UDATA)index;\n+\t\t\t\tgoto done;\n+\t\t\t} else {\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\t\t\tJ9Class *arrayrefClass = J9OBJECT_CLAZZ(currentThread, arrayObject);\n+\t\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+\t\t\t\t\tj9object_t newObjectRef = _objectAllocate.inlineAllocateObject(currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, false, false);\n+\t\t\t\t\tif (NULL == newObjectRef) {\n+\t\t\t\t\t\tnewObjectRef = currentThread->javaVM->memoryManagerFunctions->J9AllocateObject(currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);", "originalCommit": "18e87736f2e0719dea43b913c1d2803f62a91b57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyMDQ4NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r449220485", "bodyText": "Could you take a look at what I've got down now to make sure it's correct?", "author": "OussamaSaoudi", "createdAt": "2020-07-02T19:17:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcxMDE3Mg=="}], "type": "inlineReview"}, {"oid": "1c5bfbf316d37a80e3cd7d7e63cf71ca3108e194", "url": "https://github.com/eclipse-openj9/openj9/commit/1c5bfbf316d37a80e3cd7d7e63cf71ca3108e194", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers aaload and aastore. Both handle flattened\nand unflattened cases. Both contain an option for either a fast\nor a slow variant.\n-jitAaload: Loads flattenable array element\n-jitAastore: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls aaLoad\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls aaStore\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-07-02T15:14:07Z", "type": "forcePushed"}, {"oid": "56dd50f3943c47dda01ba4b812b8f9cc3849a1f5", "url": "https://github.com/eclipse-openj9/openj9/commit/56dd50f3943c47dda01ba4b812b8f9cc3849a1f5", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers aaload and aastore. Both handle flattened\nand unflattened cases. Both contain an option for either a fast\nor a slow variant.\n-jitAaload: Loads flattenable array element\n-jitAastore: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls aaLoad\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls aaStore\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-07-02T15:57:46Z", "type": "forcePushed"}, {"oid": "8d9d57107b1325006a7bb51855e6a78fbe7f5d94", "url": "https://github.com/eclipse-openj9/openj9/commit/8d9d57107b1325006a7bb51855e6a78fbe7f5d94", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers aaload and aastore. Both handle flattened\nand unflattened cases. Both contain an option for either a fast\nor a slow variant.\n-jitAaload: Loads flattenable array element\n-jitAastore: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls aaLoad\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls aaStore\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-07-02T16:36:33Z", "type": "forcePushed"}, {"oid": "6d47f23e45e9729456080367cd07815679059349", "url": "https://github.com/eclipse-openj9/openj9/commit/6d47f23e45e9729456080367cd07815679059349", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers aaload and aastore. Both handle flattened\nand unflattened cases. Both contain an option for either a fast\nor a slow variant.\n-jitAaload: Loads flattenable array element\n-jitAastore: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls aaLoad\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls aaStore\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-07-02T16:42:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0MDk1NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r468740954", "bodyText": "need frame build before setting the exception", "author": "tajila", "createdAt": "2020-08-11T17:19:44Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -742,13 +742,64 @@ old_fast_jitPutFlattenableStaticField(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayObject = (j9object_t)currentThread->floatTemp1;\n+\tU_32 index = *((U_32 *)currentThread->floatTemp2);\n+\tvoid *addr = NULL;\n+\tif (NULL == arrayObject) {", "originalCommit": "6d47f23e45e9729456080367cd07815679059349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0MTIzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r468741238", "bodyText": "same here, and below", "author": "tajila", "createdAt": "2020-08-11T17:20:13Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -742,13 +742,64 @@ old_fast_jitPutFlattenableStaticField(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayObject = (j9object_t)currentThread->floatTemp1;\n+\tU_32 index = *((U_32 *)currentThread->floatTemp2);\n+\tvoid *addr = NULL;\n+\tif (NULL == arrayObject) {\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t value = NULL;\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\t\tif (index >= arrayLength) {\n+\t\t\tcurrentThread->tempSlot = (UDATA)index;\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);", "originalCommit": "6d47f23e45e9729456080367cd07815679059349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0MjIyMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r468742223", "bodyText": "extra line here", "author": "tajila", "createdAt": "2020-08-11T17:21:52Z", "path": "runtime/vm/ValueTypeHelpers.cpp", "diffHunk": "@@ -168,5 +168,20 @@ arrayElementSize(J9ArrayClass* arrayClass)\n         Assert_VM_notNull(arrayClass);\n         return arrayClass->flattenedElementSize;\n }\n+void\n+storeFlattenableArrayElement(J9VMThread *currentThread, j9object_t arrayObject, U_32 index, j9object_t *paramObject, BOOLEAN fast)\n+{\n+        MM_ObjectAccessBarrierAPI objectAccessBarrier(currentThread);\n+        VM_ValueTypeHelpers::jitAastore(currentThread, objectAccessBarrier, arrayObject, index, paramObject, fast);\n+", "originalCommit": "6d47f23e45e9729456080367cd07815679059349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0MzIwMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r468743203", "bodyText": "that boolean fast wont compile on windows, use fast != false instead", "author": "tajila", "createdAt": "2020-08-11T17:23:33Z", "path": "runtime/vm/ValueTypeHelpers.cpp", "diffHunk": "@@ -168,5 +168,20 @@ arrayElementSize(J9ArrayClass* arrayClass)\n         Assert_VM_notNull(arrayClass);\n         return arrayClass->flattenedElementSize;\n }\n+void\n+storeFlattenableArrayElement(J9VMThread *currentThread, j9object_t arrayObject, U_32 index, j9object_t *paramObject, BOOLEAN fast)\n+{\n+        MM_ObjectAccessBarrierAPI objectAccessBarrier(currentThread);\n+        VM_ValueTypeHelpers::jitAastore(currentThread, objectAccessBarrier, arrayObject, index, paramObject, fast);\n+\n+}\n+\n+j9object_t\n+loadFlattenableArrayElement(J9VMThread *currentThread, j9object_t arrayObject, U_32 index, BOOLEAN fast)\n+{\n+        MM_ObjectAccessBarrierAPI objectAccessBarrier(currentThread);\n+        MM_ObjectAllocationAPI objectAllocate(currentThread);\n+        return VM_ValueTypeHelpers::jitAaload(currentThread, objectAccessBarrier, objectAllocate, arrayObject, index, fast);", "originalCommit": "6d47f23e45e9729456080367cd07815679059349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0MzcyNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r468743725", "bodyText": "instead of pushing frame here, just make sure caller pushes frame if fast is set to false. You can add something in the comments", "author": "tajila", "createdAt": "2020-08-11T17:24:28Z", "path": "runtime/vm/ValueTypeHelpers.hpp", "diffHunk": "@@ -255,6 +255,82 @@ class VM_ValueTypeHelpers {\n \t\treturn rc;\n \t}\n \n+\tstatic VMINLINE void\n+\tjitAastore(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI _objectAccessBarrier, j9object_t arrayObject, U_32 index, j9object_t *paramObject, bool fast)\n+\t{\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\tJ9ArrayClass *arrayrefClass = (J9ArrayClass *) J9OBJECT_CLAZZ(currentThread, arrayObject);\n+\t\tif (J9_IS_J9CLASS_VALUETYPE(arrayrefClass->componentType)) {\n+\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+\t\t\t\t_objectAccessBarrier.copyObjectFieldsToFlattenedArrayElement(currentThread, arrayrefClass, *paramObject, (J9IndexableObject *) arrayObject, index);\n+\t\t\t} else {\n+\t\t\t\t_objectAccessBarrier.inlineIndexableObjectStoreObject(currentThread, arrayObject, index, *paramObject);\n+\t\t\t}\n+\t\t} else\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+\t\t{\n+\t\t\t_objectAccessBarrier.inlineIndexableObjectStoreObject(currentThread, arrayObject, index, *paramObject);\n+\t\t}\n+\t}\n+\n+\tstatic VMINLINE j9object_t\n+\tjitAaload(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI _objectAccessBarrier, MM_ObjectAllocationAPI _objectAllocate, j9object_t arrayObject, U_32 index, bool fast)\n+\t{\n+\t\tj9object_t value = NULL;\n+\n+\t\tif (fast) {\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\t\tJ9Class *arrayrefClass = J9OBJECT_CLAZZ(currentThread, arrayObject);\n+\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+\t\t\t\tj9object_t newObjectRef = _objectAllocate.inlineAllocateObject(currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, false, false);\n+\t\t\t\tif (NULL == newObjectRef) {\n+\t\t\t\t\tvalue = newObjectRef;\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\t\t\t\t_objectAccessBarrier.copyObjectFieldsFromFlattenedArrayElement(currentThread, (J9ArrayClass *) arrayrefClass, newObjectRef, (J9IndexableObject *)arrayObject, index);\n+\t\t\t\tvalue = newObjectRef;\n+\t\t\t} else\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+\t\t\t{\n+\t\t\t\tvalue = _objectAccessBarrier.inlineIndexableObjectReadObject(currentThread, arrayObject, index);\n+\t\t\t}\n+\t\t} else if (NULL != arrayObject) {\n+\t\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(currentThread, arrayObject);\n+\t\t\tif (index >= arrayLength) {\n+\t\t\t\tcurrentThread->tempSlot = (UDATA)index;\n+\t\t\t\tgoto done;\n+\t\t\t} else {\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\t\t\tJ9Class *arrayrefClass = J9OBJECT_CLAZZ(currentThread, arrayObject);\n+\t\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+\t\t\t\t\tj9object_t newObjectRef = _objectAllocate.inlineAllocateObject(currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, false, false);\n+\t\t\t\t\tif (NULL == newObjectRef) {\n+\t\t\t\t\t\tUDATA *bp = VM_OutOfLineINL_Helpers::buildSpecialStackFrame(currentThread, J9SF_FRAME_TYPE_GENERIC_SPECIAL, 0, false);\n+\t\t\t\t\t\tVM_VMHelpers::pushObjectInSpecialFrame(currentThread, arrayObject);", "originalCommit": "6d47f23e45e9729456080367cd07815679059349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0NDUwOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r468744509", "bodyText": "this else branch is not needed, all the checks are done before calling this function", "author": "tajila", "createdAt": "2020-08-11T17:25:54Z", "path": "runtime/vm/ValueTypeHelpers.hpp", "diffHunk": "@@ -255,6 +255,82 @@ class VM_ValueTypeHelpers {\n \t\treturn rc;\n \t}\n \n+\tstatic VMINLINE void\n+\tjitAastore(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI _objectAccessBarrier, j9object_t arrayObject, U_32 index, j9object_t *paramObject, bool fast)\n+\t{\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\tJ9ArrayClass *arrayrefClass = (J9ArrayClass *) J9OBJECT_CLAZZ(currentThread, arrayObject);\n+\t\tif (J9_IS_J9CLASS_VALUETYPE(arrayrefClass->componentType)) {\n+\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+\t\t\t\t_objectAccessBarrier.copyObjectFieldsToFlattenedArrayElement(currentThread, arrayrefClass, *paramObject, (J9IndexableObject *) arrayObject, index);\n+\t\t\t} else {\n+\t\t\t\t_objectAccessBarrier.inlineIndexableObjectStoreObject(currentThread, arrayObject, index, *paramObject);\n+\t\t\t}\n+\t\t} else\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+\t\t{\n+\t\t\t_objectAccessBarrier.inlineIndexableObjectStoreObject(currentThread, arrayObject, index, *paramObject);\n+\t\t}\n+\t}\n+\n+\tstatic VMINLINE j9object_t\n+\tjitAaload(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI _objectAccessBarrier, MM_ObjectAllocationAPI _objectAllocate, j9object_t arrayObject, U_32 index, bool fast)\n+\t{\n+\t\tj9object_t value = NULL;\n+\n+\t\tif (fast) {\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\t\tJ9Class *arrayrefClass = J9OBJECT_CLAZZ(currentThread, arrayObject);\n+\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+\t\t\t\tj9object_t newObjectRef = _objectAllocate.inlineAllocateObject(currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, false, false);\n+\t\t\t\tif (NULL == newObjectRef) {\n+\t\t\t\t\tvalue = newObjectRef;\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\t\t\t\t_objectAccessBarrier.copyObjectFieldsFromFlattenedArrayElement(currentThread, (J9ArrayClass *) arrayrefClass, newObjectRef, (J9IndexableObject *)arrayObject, index);\n+\t\t\t\tvalue = newObjectRef;\n+\t\t\t} else\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+\t\t\t{\n+\t\t\t\tvalue = _objectAccessBarrier.inlineIndexableObjectReadObject(currentThread, arrayObject, index);\n+\t\t\t}\n+\t\t} else if (NULL != arrayObject) {", "originalCommit": "6d47f23e45e9729456080367cd07815679059349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0NDk5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r468744992", "bodyText": "fast should be checked here, if fast use _objectAllocate.inlineAllocateObject else use currentThread->javaVM->memoryManagerFunctions->J9AllocateObject", "author": "tajila", "createdAt": "2020-08-11T17:26:44Z", "path": "runtime/vm/ValueTypeHelpers.hpp", "diffHunk": "@@ -255,6 +255,82 @@ class VM_ValueTypeHelpers {\n \t\treturn rc;\n \t}\n \n+\tstatic VMINLINE void\n+\tjitAastore(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI _objectAccessBarrier, j9object_t arrayObject, U_32 index, j9object_t *paramObject, bool fast)\n+\t{\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\tJ9ArrayClass *arrayrefClass = (J9ArrayClass *) J9OBJECT_CLAZZ(currentThread, arrayObject);\n+\t\tif (J9_IS_J9CLASS_VALUETYPE(arrayrefClass->componentType)) {\n+\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+\t\t\t\t_objectAccessBarrier.copyObjectFieldsToFlattenedArrayElement(currentThread, arrayrefClass, *paramObject, (J9IndexableObject *) arrayObject, index);\n+\t\t\t} else {\n+\t\t\t\t_objectAccessBarrier.inlineIndexableObjectStoreObject(currentThread, arrayObject, index, *paramObject);\n+\t\t\t}\n+\t\t} else\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+\t\t{\n+\t\t\t_objectAccessBarrier.inlineIndexableObjectStoreObject(currentThread, arrayObject, index, *paramObject);\n+\t\t}\n+\t}\n+\n+\tstatic VMINLINE j9object_t\n+\tjitAaload(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI _objectAccessBarrier, MM_ObjectAllocationAPI _objectAllocate, j9object_t arrayObject, U_32 index, bool fast)\n+\t{\n+\t\tj9object_t value = NULL;\n+\n+\t\tif (fast) {\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\t\tJ9Class *arrayrefClass = J9OBJECT_CLAZZ(currentThread, arrayObject);\n+\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+\t\t\t\tj9object_t newObjectRef = _objectAllocate.inlineAllocateObject(currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, false, false);", "originalCommit": "6d47f23e45e9729456080367cd07815679059349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0NTI1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r468745250", "bodyText": "add javadocs here as well", "author": "tajila", "createdAt": "2020-08-11T17:27:10Z", "path": "runtime/vm/ValueTypeHelpers.hpp", "diffHunk": "@@ -255,6 +255,82 @@ class VM_ValueTypeHelpers {\n \t\treturn rc;\n \t}\n \n+\tstatic VMINLINE void", "originalCommit": "6d47f23e45e9729456080367cd07815679059349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0NTc0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r468745743", "bodyText": "rename to store/loadFlattenableArrayElement", "author": "tajila", "createdAt": "2020-08-11T17:27:58Z", "path": "runtime/vm/ValueTypeHelpers.hpp", "diffHunk": "@@ -255,6 +255,82 @@ class VM_ValueTypeHelpers {\n \t\treturn rc;\n \t}\n \n+\tstatic VMINLINE void\n+\tjitAastore(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI _objectAccessBarrier, j9object_t arrayObject, U_32 index, j9object_t *paramObject, bool fast)", "originalCommit": "6d47f23e45e9729456080367cd07815679059349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0NjAzMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r468746032", "bodyText": "these functions should be used in the bytecodeinterpreter so we dont duplicate logic", "author": "tajila", "createdAt": "2020-08-11T17:28:28Z", "path": "runtime/vm/ValueTypeHelpers.hpp", "diffHunk": "@@ -255,6 +255,82 @@ class VM_ValueTypeHelpers {\n \t\treturn rc;\n \t}\n \n+\tstatic VMINLINE void\n+\tjitAastore(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI _objectAccessBarrier, j9object_t arrayObject, U_32 index, j9object_t *paramObject, bool fast)\n+\t{\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\tJ9ArrayClass *arrayrefClass = (J9ArrayClass *) J9OBJECT_CLAZZ(currentThread, arrayObject);\n+\t\tif (J9_IS_J9CLASS_VALUETYPE(arrayrefClass->componentType)) {\n+\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+\t\t\t\t_objectAccessBarrier.copyObjectFieldsToFlattenedArrayElement(currentThread, arrayrefClass, *paramObject, (J9IndexableObject *) arrayObject, index);\n+\t\t\t} else {\n+\t\t\t\t_objectAccessBarrier.inlineIndexableObjectStoreObject(currentThread, arrayObject, index, *paramObject);\n+\t\t\t}\n+\t\t} else\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+\t\t{\n+\t\t\t_objectAccessBarrier.inlineIndexableObjectStoreObject(currentThread, arrayObject, index, *paramObject);\n+\t\t}\n+\t}\n+\n+\tstatic VMINLINE j9object_t\n+\tjitAaload(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI _objectAccessBarrier, MM_ObjectAllocationAPI _objectAllocate, j9object_t arrayObject, U_32 index, bool fast)\n+\t{\n+\t\tj9object_t value = NULL;\n+\n+\t\tif (fast) {\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\t\tJ9Class *arrayrefClass = J9OBJECT_CLAZZ(currentThread, arrayObject);\n+\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+\t\t\t\tj9object_t newObjectRef = _objectAllocate.inlineAllocateObject(currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, false, false);\n+\t\t\t\tif (NULL == newObjectRef) {\n+\t\t\t\t\tvalue = newObjectRef;\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\t\t\t\t_objectAccessBarrier.copyObjectFieldsFromFlattenedArrayElement(currentThread, (J9ArrayClass *) arrayrefClass, newObjectRef, (J9IndexableObject *)arrayObject, index);\n+\t\t\t\tvalue = newObjectRef;\n+\t\t\t} else\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+\t\t\t{\n+\t\t\t\tvalue = _objectAccessBarrier.inlineIndexableObjectReadObject(currentThread, arrayObject, index);\n+\t\t\t}\n+\t\t} else if (NULL != arrayObject) {\n+\t\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(currentThread, arrayObject);\n+\t\t\tif (index >= arrayLength) {\n+\t\t\t\tcurrentThread->tempSlot = (UDATA)index;\n+\t\t\t\tgoto done;\n+\t\t\t} else {\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\t\t\tJ9Class *arrayrefClass = J9OBJECT_CLAZZ(currentThread, arrayObject);\n+\t\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+\t\t\t\t\tj9object_t newObjectRef = _objectAllocate.inlineAllocateObject(currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, false, false);\n+\t\t\t\t\tif (NULL == newObjectRef) {\n+\t\t\t\t\t\tUDATA *bp = VM_OutOfLineINL_Helpers::buildSpecialStackFrame(currentThread, J9SF_FRAME_TYPE_GENERIC_SPECIAL, 0, false);\n+\t\t\t\t\t\tVM_VMHelpers::pushObjectInSpecialFrame(currentThread, arrayObject);\n+\t\t\t\t\t\tnewObjectRef = currentThread->javaVM->memoryManagerFunctions->J9AllocateObject(currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\t\t\t\tarrayObject = VM_VMHelpers::popObjectInSpecialFrame(currentThread);\n+\t\t\t\t\t\tVM_OutOfLineINL_Helpers::restoreSpecialStackFrameLeavingArgs(currentThread, bp);\n+\t\t\t\t\t\tif (J9_UNEXPECTED(NULL == returnObjectRef)) {\n+\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (J9_UNEXPECTED(NULL == newObjectRef)) {\n+\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tarrayrefClass = VM_VMHelpers::currentClass(arrayrefClass);\n+\t\t\t\t\t}\n+\t\t\t\t\t_objectAccessBarrier.copyObjectFieldsFromFlattenedArrayElement(currentThread, (J9ArrayClass *) arrayrefClass, newObjectRef, (J9IndexableObject *) arrayObject, index);\n+\t\t\t\t\tvalue = newObjectRef;\n+\t\t\t\t} else\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+\t\t\t\t{\n+\t\t\t\t\tvalue = _objectAccessBarrier.inlineIndexableObjectReadObject(currentThread, arrayObject, index);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+done:\n+\t\treturn value;\n+\t}\n+", "originalCommit": "6d47f23e45e9729456080367cd07815679059349", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyODI2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r469528268", "bodyText": "To confirm, I should replace the code currently in ByteCodeInterpreter with these functions?", "author": "OussamaSaoudi", "createdAt": "2020-08-12T20:36:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0NjAzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3NDQwMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r470174402", "bodyText": "yes", "author": "tajila", "createdAt": "2020-08-13T18:52:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0NjAzMg=="}], "type": "inlineReview"}, {"oid": "b7a8a448d8c068b762688576aa102eca1e5c81c2", "url": "https://github.com/eclipse-openj9/openj9/commit/b7a8a448d8c068b762688576aa102eca1e5c81c2", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers aaload and aastore. Both handle flattened\nand unflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls aaLoad\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls aaStore\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-08-12T19:39:47Z", "type": "forcePushed"}, {"oid": "8400ae656fe5f01bb3dce0835600b9f4984429f4", "url": "https://github.com/eclipse-openj9/openj9/commit/8400ae656fe5f01bb3dce0835600b9f4984429f4", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers aaload and aastore. Both handle flattened\nand unflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls aaLoad\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls aaStore\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-08-12T20:22:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUxODc1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r469518755", "bodyText": "Should I add that it assumes the index is less than the array size and that it does not throw exceptions?", "author": "OussamaSaoudi", "createdAt": "2020-08-12T20:24:55Z", "path": "runtime/vm/ValueTypeHelpers.hpp", "diffHunk": "@@ -417,6 +417,81 @@ class VM_ValueTypeHelpers {\n \t\t}\n \t}\n \n+\t/**\n+\t * Performs an aastore operation on an object. Handles flattened and non-flattened cases.\n+\t *\n+\t * Assumes recieverObject and paramObject are not null.", "originalCommit": "8400ae656fe5f01bb3dce0835600b9f4984429f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3NDUyOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r470174528", "bodyText": "yes", "author": "tajila", "createdAt": "2020-08-13T18:52:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUxODc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3NDc1OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r470174759", "bodyText": "you can add that all AIOB exceptions must be thrown before hand", "author": "tajila", "createdAt": "2020-08-13T18:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUxODc1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMDIzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r469520238", "bodyText": "This line will then go to JIT_RETURN_UDATA(value), returning NULL. I want to confirm that this is fine?", "author": "OussamaSaoudi", "createdAt": "2020-08-12T20:27:47Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -885,13 +885,69 @@ old_fast_jitPutFlattenableStaticField(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayObject = (j9object_t)currentThread->floatTemp1;\n+\tU_32 index = *((U_32 *)currentThread->floatTemp2);\n+\tvoid *addr = NULL;\n+\tif (NULL == arrayObject) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t value = NULL;\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\t\tif (index >= arrayLength) {\n+\t\t\tcurrentThread->tempSlot = (UDATA)index;\n+\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);", "originalCommit": "8400ae656fe5f01bb3dce0835600b9f4984429f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUzOTA0NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r471539045", "bodyText": "if you are throwing an exception you dont need to set the return val, you can just jum straight to done", "author": "tajila", "createdAt": "2020-08-17T15:00:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMDIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU0MDUxNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r471540515", "bodyText": "or conversely, just move up the JIT_RETURN_UDATA(value); to after the NULL check for the return value", "author": "tajila", "createdAt": "2020-08-17T15:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMDIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMjI2NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r469522265", "bodyText": "fast == false, so I need to build a special frame. Is this the correct way to do it in this context, or should I use OutOfLineNL?", "author": "OussamaSaoudi", "createdAt": "2020-08-12T20:31:33Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -885,13 +885,69 @@ old_fast_jitPutFlattenableStaticField(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayObject = (j9object_t)currentThread->floatTemp1;\n+\tU_32 index = *((U_32 *)currentThread->floatTemp2);\n+\tvoid *addr = NULL;\n+\tif (NULL == arrayObject) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t value = NULL;\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\t\tif (index >= arrayLength) {\n+\t\t\tcurrentThread->tempSlot = (UDATA)index;\n+\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);\n+\t\t} else {\n+\t\t\tbuildJITResolveFrame(currentThread, J9_SSF_JIT_RESOLVE, parmCount);\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, arrayObject);\n+\t\t\tvalue = currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, false);", "originalCommit": "8400ae656fe5f01bb3dce0835600b9f4984429f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3NTEwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r470175108", "bodyText": "the frame should be built before call the function", "author": "tajila", "createdAt": "2020-08-13T18:53:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMjI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUzNDI1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r471534250", "bodyText": "So I build it regardless of the path being fast or slow?", "author": "OussamaSaoudi", "createdAt": "2020-08-17T14:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMjI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUzNzUwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r471537507", "bodyText": "it should only be built on a slow path", "author": "tajila", "createdAt": "2020-08-17T14:57:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMjI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUzNzY2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r471537664", "bodyText": "look at old_slow_jitGetFlattenableField for an example", "author": "tajila", "createdAt": "2020-08-17T14:58:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMjI2NQ=="}], "type": "inlineReview"}, {"oid": "545da994cb0d038313570ab644fc20742cbe808f", "url": "https://github.com/eclipse-openj9/openj9/commit/545da994cb0d038313570ab644fc20742cbe808f", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers aaload and aastore. Both handle flattened\nand unflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls aaLoad\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls aaStore\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-08-12T20:38:58Z", "type": "forcePushed"}, {"oid": "8a440442d6a699511f9a71b87d665427daeac04b", "url": "https://github.com/eclipse-openj9/openj9/commit/8a440442d6a699511f9a71b87d665427daeac04b", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers aaload and aastore. Both handle flattened\nand unflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls aaLoad\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls aaStore\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-08-17T17:27:02Z", "type": "forcePushed"}, {"oid": "1a7d20fe6643a099aa4daeb94fbad3f1251dd28f", "url": "https://github.com/eclipse-openj9/openj9/commit/1a7d20fe6643a099aa4daeb94fbad3f1251dd28f", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers aaload and aastore. Both handle flattened\nand unflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls aaLoad\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls aaStore\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-08-18T14:22:12Z", "type": "forcePushed"}, {"oid": "d2b8e2c6ccd701e571808d75105a570873799839", "url": "https://github.com/eclipse-openj9/openj9/commit/d2b8e2c6ccd701e571808d75105a570873799839", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers loadFlattenableArrayElement and\nstoreFlattenableArrayElement which perform aaload and\naastore functions respectively. Both handle flattened and\nunflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls loadFlattenableArrayElement\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls storeFlattenableArrayElement\n\nReplaced existing code in aaload and aastore functions in\nByteCodeInterpreter.hpp with calls to loadFlattenableArrayElement\nand storeFlattenableArrayElement. Functionality remains the same.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-08-18T15:37:01Z", "type": "forcePushed"}, {"oid": "6dd8aea6829a6280289436dc248e42c41804bc32", "url": "https://github.com/eclipse-openj9/openj9/commit/6dd8aea6829a6280289436dc248e42c41804bc32", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers loadFlattenableArrayElement and\nstoreFlattenableArrayElement which perform aaload and\naastore functions respectively. Both handle flattened and\nunflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls loadFlattenableArrayElement\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls storeFlattenableArrayElement\n\nReplaced existing code in aaload and aastore functions in\nByteCodeInterpreter.hpp with calls to loadFlattenableArrayElement\nand storeFlattenableArrayElement. Functionality remains the same.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-08-19T16:48:18Z", "type": "forcePushed"}, {"oid": "dc1389b79457f1a3fbc1ff4d2f1ee552397797f4", "url": "https://github.com/eclipse-openj9/openj9/commit/dc1389b79457f1a3fbc1ff4d2f1ee552397797f4", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers loadFlattenableArrayElement and\nstoreFlattenableArrayElement which perform aaload and\naastore functions respectively. Both handle flattened and\nunflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls loadFlattenableArrayElement\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls storeFlattenableArrayElement\n\nReplaced existing code in aaload and aastore functions in\nByteCodeInterpreter.hpp with calls to loadFlattenableArrayElement\nand storeFlattenableArrayElement. Functionality remains the same.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-08-19T17:01:49Z", "type": "forcePushed"}, {"oid": "a022daf131148c2c2f6cd105cf8bdc3f5bab2682", "url": "https://github.com/eclipse-openj9/openj9/commit/a022daf131148c2c2f6cd105cf8bdc3f5bab2682", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers loadFlattenableArrayElement and\nstoreFlattenableArrayElement which perform aaload and\naastore functions respectively. Both handle flattened and\nunflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls loadFlattenableArrayElement\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls storeFlattenableArrayElement\n\nReplaced existing code in aaload and aastore functions in\nByteCodeInterpreter.hpp with calls to loadFlattenableArrayElement\nand storeFlattenableArrayElement. Functionality remains the same.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-08-25T19:18:19Z", "type": "forcePushed"}, {"oid": "48fd1a593e4bbe7bbe1ba7725689018242108c90", "url": "https://github.com/eclipse-openj9/openj9/commit/48fd1a593e4bbe7bbe1ba7725689018242108c90", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers loadFlattenableArrayElement and\nstoreFlattenableArrayElement which perform aaload and\naastore functions respectively. Both handle flattened and\nunflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls loadFlattenableArrayElement\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls storeFlattenableArrayElement\n\nReplaced existing code in aaload and aastore functions in\nByteCodeInterpreter.hpp with calls to loadFlattenableArrayElement\nand storeFlattenableArrayElement. Functionality remains the same.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-08-25T20:20:11Z", "type": "forcePushed"}, {"oid": "d045b807b37522516b47bfbb6134fadd9e77b5af", "url": "https://github.com/eclipse-openj9/openj9/commit/d045b807b37522516b47bfbb6134fadd9e77b5af", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers loadFlattenableArrayElement and\nstoreFlattenableArrayElement which perform aaload and\naastore functions respectively. Both handle flattened and\nunflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls loadFlattenableArrayElement\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls storeFlattenableArrayElement\n\nReplaced existing code in aaload and aastore functions in\nByteCodeInterpreter.hpp with calls to loadFlattenableArrayElement\nand storeFlattenableArrayElement. Functionality remains the same.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-08-26T16:41:04Z", "type": "forcePushed"}, {"oid": "b64525c09e65cf94fbd8b54c0a6812ee30fd77c1", "url": "https://github.com/eclipse-openj9/openj9/commit/b64525c09e65cf94fbd8b54c0a6812ee30fd77c1", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers loadFlattenableArrayElement and\nstoreFlattenableArrayElement which perform aaload and\naastore functions respectively. Both handle flattened and\nunflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls loadFlattenableArrayElement\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls storeFlattenableArrayElement\n\nReplaced existing code in aaload and aastore functions in\nByteCodeInterpreter.hpp with calls to loadFlattenableArrayElement\nand storeFlattenableArrayElement. Functionality remains the same.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-08-27T01:02:27Z", "type": "forcePushed"}, {"oid": "6265619d329018f5b0fe632334743df6d48f1a1e", "url": "https://github.com/eclipse-openj9/openj9/commit/6265619d329018f5b0fe632334743df6d48f1a1e", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading flattenable array element with a\nslow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n\nAdded ValueTypeHelpers loadFlattenableArrayElement and\nstoreFlattenableArrayElement which perform aaload and\naastore functions respectively. Both handle flattened and\nunflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls loadFlattenableArrayElement\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls storeFlattenableArrayElement\n\nReplaced existing code in aaload and aastore functions in\nByteCodeInterpreter.hpp with calls to loadFlattenableArrayElement\nand storeFlattenableArrayElement. Functionality remains the same.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-08-27T03:13:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE0NTQwNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r481145404", "bodyText": "you dont need that comment", "author": "tajila", "createdAt": "2020-09-01T13:40:21Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -885,13 +885,73 @@ old_fast_jitPutFlattenableStaticField(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayObject = (j9object_t)currentThread->floatTemp1;\n+\tU_32 index = *((U_32 *)currentThread->floatTemp2);\n+\tvoid *addr = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\tif (NULL == arrayObject) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t value = NULL;\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\t\tif (index >= arrayLength) {\n+\t\t\tcurrentThread->tempSlot = (UDATA)index;\n+\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);\n+\t\t} else {\n+\t\t\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, arrayObject);\n+\t\t\tvalue = currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, false);\n+\t\t\tarrayObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\taddr = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\t\t\tif (NULL != addr) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tif (NULL == value) {\n+\t\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\t\taddr = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJIT_RETURN_UDATA(value);\n+\t\t}\n+\t}\n+done:\n+\treturn addr;\n+\tSLOW_JIT_HELPER_EPILOGUE();\n }\n \n void* J9FASTCALL\n old_fast_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(2);\n+\tDECLARE_JIT_PARM(j9object_t, arrayObject, 1);\n+\tDECLARE_JIT_INT_PARM(index, 2);\n+\tvoid* slowPath = NULL;\n+\tbool slowPathUsed = false;\n+\tj9object_t value = NULL;\n+\tU_32 arrayLength = 0; /* initialized here to not cross the goto statement. Requires non null arrayObject to assign value */", "originalCommit": "6265619d329018f5b0fe632334743df6d48f1a1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE0NzYxOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r481147618", "bodyText": "you dont need to pass the address, you just need to do a re-interpret cast.\nie. currentThread->floatTemp2 = *(void **)&index", "author": "tajila", "createdAt": "2020-09-01T13:43:29Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -885,13 +885,73 @@ old_fast_jitPutFlattenableStaticField(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayObject = (j9object_t)currentThread->floatTemp1;\n+\tU_32 index = *((U_32 *)currentThread->floatTemp2);\n+\tvoid *addr = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\tif (NULL == arrayObject) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t value = NULL;\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\t\tif (index >= arrayLength) {\n+\t\t\tcurrentThread->tempSlot = (UDATA)index;\n+\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);\n+\t\t} else {\n+\t\t\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, arrayObject);\n+\t\t\tvalue = currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, false);\n+\t\t\tarrayObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\taddr = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\t\t\tif (NULL != addr) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tif (NULL == value) {\n+\t\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\t\taddr = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJIT_RETURN_UDATA(value);\n+\t\t}\n+\t}\n+done:\n+\treturn addr;\n+\tSLOW_JIT_HELPER_EPILOGUE();\n }\n \n void* J9FASTCALL\n old_fast_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(2);\n+\tDECLARE_JIT_PARM(j9object_t, arrayObject, 1);\n+\tDECLARE_JIT_INT_PARM(index, 2);\n+\tvoid* slowPath = NULL;\n+\tbool slowPathUsed = false;\n+\tj9object_t value = NULL;\n+\tU_32 arrayLength = 0; /* initialized here to not cross the goto statement. Requires non null arrayObject to assign value */\n+\tif (NULL == arrayObject) {\n+\t\tgoto slow;\n+\t}\n+\tarrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\tif (index >= arrayLength) {\n+\t\tgoto slow;\n+\t}\n+\tvalue = (j9object_t) currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, true);\n+\tif (J9_UNEXPECTED(NULL == value)) {\n+\t\tgoto slow;\n+\t}\n+\tJIT_RETURN_UDATA(value);\n+done:\n+\treturn slowPath;\n+slow:\n+\tslowPathUsed = true;\n+\tcurrentThread->floatTemp1 = (void *)arrayObject;\n+\tcurrentThread->floatTemp2 = (void *)&index;", "originalCommit": "6265619d329018f5b0fe632334743df6d48f1a1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE0ODIxNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r481148216", "bodyText": "same here with the re-intepret cast", "author": "tajila", "createdAt": "2020-09-01T13:44:20Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -885,13 +885,73 @@ old_fast_jitPutFlattenableStaticField(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayObject = (j9object_t)currentThread->floatTemp1;\n+\tU_32 index = *((U_32 *)currentThread->floatTemp2);", "originalCommit": "6265619d329018f5b0fe632334743df6d48f1a1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE1NDU1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r481154555", "bodyText": "you dont need to push/pop arrayObject in a special frame", "author": "tajila", "createdAt": "2020-09-01T13:53:34Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -885,13 +885,73 @@ old_fast_jitPutFlattenableStaticField(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayObject = (j9object_t)currentThread->floatTemp1;\n+\tU_32 index = *((U_32 *)currentThread->floatTemp2);\n+\tvoid *addr = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\tif (NULL == arrayObject) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t value = NULL;\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\t\tif (index >= arrayLength) {\n+\t\t\tcurrentThread->tempSlot = (UDATA)index;\n+\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);\n+\t\t} else {\n+\t\t\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, arrayObject);", "originalCommit": "6265619d329018f5b0fe632334743df6d48f1a1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE1NTI5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r481155294", "bodyText": "why is this being done?", "author": "tajila", "createdAt": "2020-09-01T13:54:38Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -885,13 +885,73 @@ old_fast_jitPutFlattenableStaticField(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayObject = (j9object_t)currentThread->floatTemp1;\n+\tU_32 index = *((U_32 *)currentThread->floatTemp2);\n+\tvoid *addr = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\tif (NULL == arrayObject) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t value = NULL;\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\t\tif (index >= arrayLength) {\n+\t\t\tcurrentThread->tempSlot = (UDATA)index;", "originalCommit": "6265619d329018f5b0fe632334743df6d48f1a1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQyMzI4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r481423281", "bodyText": "This is what is done on the ByteCodeInterpreter version of aaload  if the index is greater than the array length. Let me know if you think it is not needed.", "author": "OussamaSaoudi", "createdAt": "2020-09-01T20:50:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE1NTI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQyNjI2Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r481426262", "bodyText": "In the interpreter we have a special routine that will look at the tempSlot so that it can print a more helpful exception message. We dont have that here.", "author": "tajila", "createdAt": "2020-09-01T20:56:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE1NTI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE1NjI0Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r481156246", "bodyText": "you need to add currentThread->floatTemp1 = (void*)valuet; // in case of decompile before restore the jit frame", "author": "tajila", "createdAt": "2020-09-01T13:55:55Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -885,13 +885,73 @@ old_fast_jitPutFlattenableStaticField(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayObject = (j9object_t)currentThread->floatTemp1;\n+\tU_32 index = *((U_32 *)currentThread->floatTemp2);\n+\tvoid *addr = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\tif (NULL == arrayObject) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t value = NULL;\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\t\tif (index >= arrayLength) {\n+\t\t\tcurrentThread->tempSlot = (UDATA)index;\n+\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);\n+\t\t} else {\n+\t\t\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, arrayObject);\n+\t\t\tvalue = currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, false);\n+\t\t\tarrayObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);", "originalCommit": "6265619d329018f5b0fe632334743df6d48f1a1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE1NzMyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r481157326", "bodyText": "also do the value null check before restore the jit frame so you dont need to build another frame to set the exception", "author": "tajila", "createdAt": "2020-09-01T13:57:20Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -885,13 +885,73 @@ old_fast_jitPutFlattenableStaticField(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayObject = (j9object_t)currentThread->floatTemp1;\n+\tU_32 index = *((U_32 *)currentThread->floatTemp2);\n+\tvoid *addr = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\tif (NULL == arrayObject) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t value = NULL;\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\t\tif (index >= arrayLength) {\n+\t\t\tcurrentThread->tempSlot = (UDATA)index;\n+\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);\n+\t\t} else {\n+\t\t\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, arrayObject);\n+\t\t\tvalue = currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, false);\n+\t\t\tarrayObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\taddr = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\t\t\tif (NULL != addr) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tif (NULL == value) {", "originalCommit": "6265619d329018f5b0fe632334743df6d48f1a1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE1NzY5MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r481157690", "bodyText": "where is the jitStoreFlattenableArrayElement helper?", "author": "tajila", "createdAt": "2020-09-01T13:57:53Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -885,13 +885,73 @@ old_fast_jitPutFlattenableStaticField(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayObject = (j9object_t)currentThread->floatTemp1;\n+\tU_32 index = *((U_32 *)currentThread->floatTemp2);\n+\tvoid *addr = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\tif (NULL == arrayObject) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t value = NULL;\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\t\tif (index >= arrayLength) {\n+\t\t\tcurrentThread->tempSlot = (UDATA)index;\n+\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);\n+\t\t} else {\n+\t\t\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, arrayObject);\n+\t\t\tvalue = currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, false);\n+\t\t\tarrayObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\taddr = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\t\t\tif (NULL != addr) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tif (NULL == value) {\n+\t\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\t\taddr = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJIT_RETURN_UDATA(value);\n+\t\t}\n+\t}\n+done:\n+\treturn addr;\n+\tSLOW_JIT_HELPER_EPILOGUE();\n }\n \n void* J9FASTCALL\n old_fast_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(2);\n+\tDECLARE_JIT_PARM(j9object_t, arrayObject, 1);\n+\tDECLARE_JIT_INT_PARM(index, 2);\n+\tvoid* slowPath = NULL;\n+\tbool slowPathUsed = false;\n+\tj9object_t value = NULL;\n+\tU_32 arrayLength = 0; /* initialized here to not cross the goto statement. Requires non null arrayObject to assign value */\n+\tif (NULL == arrayObject) {\n+\t\tgoto slow;\n+\t}\n+\tarrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\tif (index >= arrayLength) {\n+\t\tgoto slow;\n+\t}\n+\tvalue = (j9object_t) currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, true);\n+\tif (J9_UNEXPECTED(NULL == value)) {\n+\t\tgoto slow;\n+\t}\n+\tJIT_RETURN_UDATA(value);\n+done:\n+\treturn slowPath;\n+slow:\n+\tslowPathUsed = true;\n+\tcurrentThread->floatTemp1 = (void *)arrayObject;\n+\tcurrentThread->floatTemp2 = (void *)&index;\n+\tslowPath = (void*)old_slow_jitLoadFlattenableArrayElement;\n+\tgoto done;\n }", "originalCommit": "6265619d329018f5b0fe632334743df6d48f1a1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE1ODUzMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r481158530", "bodyText": "you dont need the J9_IS_J9CLASS_FLATTENED check here", "author": "tajila", "createdAt": "2020-09-01T13:59:06Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -5872,34 +5872,25 @@ class INTERPRETER_CLASS\n \t\t\t\t_currentThread->tempSlot = (UDATA)index;\n \t\t\t\trc = THROW_AIOB;\n \t\t\t} else {\n-\t\t\t\tj9object_t value = NULL;\n+\t\t\t\tj9object_t value = VM_ValueTypeHelpers::loadFlattenableArrayElement(_currentThread, _objectAccessBarrier, _objectAllocate, arrayref, index, true);\n #if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n \t\t\t\tJ9Class *arrayrefClass = J9OBJECT_CLAZZ(_currentThread, arrayref);\n-\t\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n-\t\t\t\t\tj9object_t newObjectRef = _objectAllocate.inlineAllocateObject(_currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, false, false);\n-\n-\t\t\t\t\tif (NULL == newObjectRef) {\n-\t\t\t\t\t\tbuildGenericSpecialStackFrame(REGISTER_ARGS, 0);\n-\t\t\t\t\t\tpushObjectInSpecialFrame(REGISTER_ARGS, arrayref);\n-\t\t\t\t\t\tupdateVMStruct(REGISTER_ARGS);\n-\t\t\t\t\t\tnewObjectRef = _vm->memoryManagerFunctions->J9AllocateObject(_currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n-\t\t\t\t\t\tVMStructHasBeenUpdated(REGISTER_ARGS);\n-\t\t\t\t\t\tarrayref = popObjectInSpecialFrame(REGISTER_ARGS);\n-\t\t\t\t\t\trestoreGenericSpecialStackFrame(REGISTER_ARGS);\n-\t\t\t\t\t\tif (J9_UNEXPECTED(NULL == newObjectRef)) {\n-\t\t\t\t\t\t\trc = THROW_HEAP_OOM;\n-\t\t\t\t\t\t\treturn rc;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tarrayrefClass = VM_VMHelpers::currentClass(arrayrefClass);\n+\t\t\t\tif (NULL == value && J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {", "originalCommit": "6265619d329018f5b0fe632334743df6d48f1a1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM5NjczMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r481396730", "bodyText": "Removing the J9_IS_J9CLASS_FLATTENED will cause a system dump. I believe the reason is value = _objectAccessBarrier.inlineIndexableObjectReadObject(currentThread, receiverObject, index); is being run in all cases in which the value is not flattened. In the case that it does return null it will always hit the HEAP_OOM error (which should occur only if the slow path is used and returns null, not the non flattened path returns null) This was the simplest way I could come up with to prevent that.", "author": "OussamaSaoudi", "createdAt": "2020-09-01T19:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE1ODUzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNjU2Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r481406563", "bodyText": "The problem is that you have one path for value types and non-valuetypes. Basically you need a\n#ifdef valuetype\nif (J9_IS_ValueType(arrayrefClass)) {\n//your code here\n} else\n#endif /* valuetype */\n{\n\n}", "author": "tajila", "createdAt": "2020-09-01T20:18:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE1ODUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE1ODg1Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r481158853", "bodyText": "yo can just reuse value", "author": "tajila", "createdAt": "2020-09-01T13:59:33Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -5872,34 +5872,25 @@ class INTERPRETER_CLASS\n \t\t\t\t_currentThread->tempSlot = (UDATA)index;\n \t\t\t\trc = THROW_AIOB;\n \t\t\t} else {\n-\t\t\t\tj9object_t value = NULL;\n+\t\t\t\tj9object_t value = VM_ValueTypeHelpers::loadFlattenableArrayElement(_currentThread, _objectAccessBarrier, _objectAllocate, arrayref, index, true);\n #if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n \t\t\t\tJ9Class *arrayrefClass = J9OBJECT_CLAZZ(_currentThread, arrayref);\n-\t\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n-\t\t\t\t\tj9object_t newObjectRef = _objectAllocate.inlineAllocateObject(_currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, false, false);\n-\n-\t\t\t\t\tif (NULL == newObjectRef) {\n-\t\t\t\t\t\tbuildGenericSpecialStackFrame(REGISTER_ARGS, 0);\n-\t\t\t\t\t\tpushObjectInSpecialFrame(REGISTER_ARGS, arrayref);\n-\t\t\t\t\t\tupdateVMStruct(REGISTER_ARGS);\n-\t\t\t\t\t\tnewObjectRef = _vm->memoryManagerFunctions->J9AllocateObject(_currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n-\t\t\t\t\t\tVMStructHasBeenUpdated(REGISTER_ARGS);\n-\t\t\t\t\t\tarrayref = popObjectInSpecialFrame(REGISTER_ARGS);\n-\t\t\t\t\t\trestoreGenericSpecialStackFrame(REGISTER_ARGS);\n-\t\t\t\t\t\tif (J9_UNEXPECTED(NULL == newObjectRef)) {\n-\t\t\t\t\t\t\trc = THROW_HEAP_OOM;\n-\t\t\t\t\t\t\treturn rc;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tarrayrefClass = VM_VMHelpers::currentClass(arrayrefClass);\n+\t\t\t\tif (NULL == value && J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+\t\t\t\t\tj9object_t newObjectRef = NULL;", "originalCommit": "6265619d329018f5b0fe632334743df6d48f1a1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE2MDYzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r481160638", "bodyText": "add brackets (NULL == value)", "author": "tajila", "createdAt": "2020-09-01T14:02:00Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -5933,21 +5924,12 @@ class INTERPRETER_CLASS\n \t\t\t\t} else {\n #if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n \t\t\t\t\tJ9ArrayClass *arrayrefClass = (J9ArrayClass *) J9OBJECT_CLAZZ(_currentThread, arrayref);\n-\t\t\t\t\tif (J9_IS_J9CLASS_VALUETYPE(arrayrefClass->componentType)) {\n-\t\t\t\t\t\tif (NULL == value) {\n-\t\t\t\t\t\t\trc = THROW_NPE;\n-\t\t\t\t\t\t\tgoto done;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n-\t\t\t\t\t\t\t_objectAccessBarrier.copyObjectFieldsToFlattenedArrayElement(_currentThread, arrayrefClass, value, (J9IndexableObject *) arrayref, index);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t_objectAccessBarrier.inlineIndexableObjectStoreObject(_currentThread, arrayref, index, value);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else\n-#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n-\t\t\t\t\t{\n-\t\t\t\t\t\t_objectAccessBarrier.inlineIndexableObjectStoreObject(_currentThread, arrayref, index, value);\n+\t\t\t\t\tif (J9_IS_J9CLASS_VALUETYPE(arrayrefClass->componentType) && NULL == value) {", "originalCommit": "6265619d329018f5b0fe632334743df6d48f1a1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwOTUyOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r481409529", "bodyText": "you dont need the vt check here", "author": "tajila", "createdAt": "2020-09-01T20:24:08Z", "path": "runtime/vm/ValueTypeHelpers.hpp", "diffHunk": "@@ -417,6 +417,87 @@ class VM_ValueTypeHelpers {\n \t\t}\n \t}\n \n+\t/**\n+\t * Performs an aastore operation on an object. Handles flattened and non-flattened cases.\n+\t *\n+\t * Assumes recieverObject and paramObject are not null.\n+\t * All AIOB exceptions must be thrown before calling.\n+\t *\n+\t * @param[in] currentThread thread token\n+\t * @param[in] _objectAccessBarrier access barrier\n+\t * @param[in] receiverObject arrayObject\n+\t * @param[in] index array index\n+\t * @param[in] paramObject obj arg\n+\t */\n+\tstatic VMINLINE void\n+\tstoreFlattenableArrayElement(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI _objectAccessBarrier, j9object_t arrayRef, U_32 index, j9object_t value)\n+\t{\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\tJ9ArrayClass *arrayrefClass = (J9ArrayClass *) J9OBJECT_CLAZZ(currentThread, arrayRef);\n+\t\tif (J9_IS_J9CLASS_VALUETYPE(arrayrefClass->componentType)) {", "originalCommit": "6265619d329018f5b0fe632334743df6d48f1a1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwOTY3Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r481409676", "bodyText": "the flattened check is sufficient", "author": "tajila", "createdAt": "2020-09-01T20:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwOTUyOQ=="}], "type": "inlineReview"}, {"oid": "3fe478bd72b791b301e81b2dd2d1947561978c2f", "url": "https://github.com/eclipse-openj9/openj9/commit/3fe478bd72b791b301e81b2dd2d1947561978c2f", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading and storing flattenable array\nelement with a slow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n-old_fast_jitStoreFlattenableArrayElement: Attempts to use fast\npath to store value into array. If it fails, calls the slow\\\nvariant.\n-old_slow_jitStoreFlattenableArrayElement: Proceeds through\nsllow path for storing, throws appropriate exceptions when\nneeded.\n\nAdded runtime helper to check if storing object in an array\nis allowed.\n-jitObjectArrayStoreAllowed\n\nAdded ValueTypeHelpers loadFlattenableArrayElement and\nstoreFlattenableArrayElement which perform aaload and\naastore functions respectively. Both handle flattened and\nunflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls loadFlattenableArrayElement\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls storeFlattenableArrayElement\n\nReplaced existing code in aaload and aastore functions in\nByteCodeInterpreter.hpp with calls to loadFlattenableArrayElement\nand storeFlattenableArrayElement. Functionality remains the same.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-09-03T15:13:03Z", "type": "forcePushed"}, {"oid": "38923cdafef8c2c6d3b904fe8b7ac086076b03de", "url": "https://github.com/eclipse-openj9/openj9/commit/38923cdafef8c2c6d3b904fe8b7ac086076b03de", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading and storing flattenable array\nelement with a slow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n-old_fast_jitStoreFlattenableArrayElement: Attempts to use fast\npath to store value into array. If it fails, calls the slow\\\nvariant.\n-old_slow_jitStoreFlattenableArrayElement: Proceeds through\nsllow path for storing, throws appropriate exceptions when\nneeded.\n\nAdded runtime helper to check if storing object in an array\nis allowed.\n-jitObjectArrayStoreAllowed\n\nAdded ValueTypeHelpers loadFlattenableArrayElement and\nstoreFlattenableArrayElement which perform aaload and\naastore functions respectively. Both handle flattened and\nunflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls loadFlattenableArrayElement\n-storeFlattenableArrayElement: c function that initializes\nrequried objects and calls storeFlattenableArrayElement\n\nReplaced existing code in aaload and aastore functions in\nByteCodeInterpreter.hpp with calls to loadFlattenableArrayElement\nand storeFlattenableArrayElement. Functionality remains the same.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-09-03T15:39:45Z", "type": "forcePushed"}, {"oid": "e826ecba138b0cbf511ae7cb43d5b85d8299603a", "url": "https://github.com/eclipse-openj9/openj9/commit/e826ecba138b0cbf511ae7cb43d5b85d8299603a", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading and storing flattenable array\nelement with a slow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n-old_fast_jitStoreFlattenableArrayElement: Attempts to use fast\npath to store value into array. If it fails, calls the slow\\\nvariant.\n-old_slow_jitStoreFlattenableArrayElement: Proceeds through\nsllow path for storing, throws appropriate exceptions when\nneeded.\n\nAdded runtime helper to check if storing object in an array\nis allowed.\n-jitObjectArrayStoreAllowed\n\nAdded ValueTypeHelpers loadFlattenableArrayElement and\nstoreFlattenableArrayElement which perform aaload and\naastore functions respectively. Both handle flattened and\nunflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls loadFlattenableArrayElement\n-storeFlattenableArrayElement: c function that initializes\nrequired objects and calls storeFlattenableArrayElement\n\nReplaced existing code in aaload and aastore functions in\nByteCodeInterpreter.hpp with calls to loadFlattenableArrayElement\nand storeFlattenableArrayElement. Functionality remains the same.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-09-03T16:15:42Z", "type": "forcePushed"}, {"oid": "045079fda850fd4ca0444cacbfd2da59e25de3ef", "url": "https://github.com/eclipse-openj9/openj9/commit/045079fda850fd4ca0444cacbfd2da59e25de3ef", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading and storing flattenable array\nelement with a slow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n-old_fast_jitStoreFlattenableArrayElement: Attempts to use fast\npath to store value into array. If it fails, calls the slow\\\nvariant.\n-old_slow_jitStoreFlattenableArrayElement: Proceeds through\nsllow path for storing, throws appropriate exceptions when\nneeded.\n\nAdded runtime helper to check if storing object in an array\nis allowed.\n-jitObjectArrayStoreAllowed\n\nAdded ValueTypeHelpers loadFlattenableArrayElement and\nstoreFlattenableArrayElement which perform aaload and\naastore functions respectively. Both handle flattened and\nunflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls loadFlattenableArrayElement\n-storeFlattenableArrayElement: c function that initializes\nrequired objects and calls storeFlattenableArrayElement\n\nReplaced existing code in aaload and aastore functions in\nByteCodeInterpreter.hpp with calls to loadFlattenableArrayElement\nand storeFlattenableArrayElement. Functionality remains the same.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-09-03T17:02:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg4NjAyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r484886026", "bodyText": "no need for ifdefs in the jitruntime helpers since they are only called when VTs are enabled", "author": "tajila", "createdAt": "2020-09-08T12:44:31Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -885,25 +903,150 @@ old_fast_jitPutFlattenableStaticField(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayObject = (j9object_t)currentThread->floatTemp1;\n+\tU_32 index = *(U_32 *)&currentThread->floatTemp2;\n+\tvoid *addr = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\tif (NULL == arrayObject) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t value = NULL;\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\t\tif (index >= arrayLength) {\n+\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);\n+\t\t} else {\n+\t\t\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\t\t\tvalue = currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, false);\n+\t\t\tif (NULL == value) {\n+\t\t\t\taddr = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tcurrentThread->floatTemp1 = (void*)value; // in case of decompile\n+\t\t\taddr = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\t\t\tif (NULL != addr) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJIT_RETURN_UDATA(value);\n+\t\t}\n+\t}\n+done:\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn addr;\n }\n \n void* J9FASTCALL\n old_fast_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(2);\n+\tDECLARE_JIT_PARM(j9object_t, arrayObject, 1);\n+\tDECLARE_JIT_INT_PARM(index, 2);\n+\tbool slowPathUsed = false;\n+\tvoid *slowPath = NULL;\n+\tj9object_t value = NULL;\n+\tU_32 arrayLength = 0;\n+\tif (NULL == arrayObject) {\n+\t\tgoto slow;\n+\t}\n+\tarrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\tif (index >= arrayLength) {\n+\t\tgoto slow;\n+\t}\n+\tvalue = (j9object_t) currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, true);\n+\tif (J9_UNEXPECTED(NULL == value)) {\n+\t\tgoto slow;\n+\t}\n+\tJIT_RETURN_UDATA(value);\n+done:\n+\treturn slowPath;\n+slow:\n+\tslowPathUsed = true;\n+\tcurrentThread->floatTemp1 = (void *)arrayObject;\n+\tcurrentThread->floatTemp2 = *(void **)&index;\n+\tslowPath = (void*)old_slow_jitLoadFlattenableArrayElement;\n+\tgoto done;\n }\n \n void* J9FASTCALL\n old_slow_jitStoreFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayref = (j9object_t)currentThread->floatTemp1;\n+\tj9object_t value = (j9object_t)currentThread->floatTemp2;\n+\tU_32 index = *(U_32 *)&currentThread->floatTemp3;\n+\tU_32 arrayLength = 0;\n+\tvoid *addr = NULL;\n+\tif (NULL == arrayref) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tarrayLength = J9INDEXABLEOBJECT_SIZE(currentThread, arrayref);\n+\t\tif (index >= arrayLength) {\n+\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);\n+\t\t} else {\n+\t\t\tif (false == jitObjectArrayStoreAllowed(arrayref, value)) {\n+\t\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYSTOREEXCEPTION, NULL);\n+\t\t\t} else {\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\t\t\tJ9ArrayClass *arrayrefClass = (J9ArrayClass *) J9OBJECT_CLAZZ(currentThread, arrayref);\n+\t\t\t\tif (J9_IS_J9CLASS_VALUETYPE(arrayrefClass->componentType) && (NULL == value)) {\n+\t\t\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);;\n+\t\t\t\t} else\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+\t\t\t\t{\n+\t\t\t\t\tcurrentThread->javaVM->internalVMFunctions->storeFlattenableArrayElement(currentThread, arrayref, index, value);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn addr;\n }\n \n void* J9FASTCALL\n old_fast_jitStoreFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(3);\n+\tDECLARE_JIT_PARM(j9object_t, arrayref, 1);\n+\tDECLARE_JIT_PARM(j9object_t, value, 2);\n+\tDECLARE_JIT_INT_PARM(index, 3);\n+\tbool slowPathUsed = false;\n+\tvoid *slowPath = NULL;\n+\tU_32 arrayLength = 0;\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)", "originalCommit": "d70f830818e02a1644e94f95570063ebf3fc0595", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg4NjQzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r484886431", "bodyText": "same here", "author": "tajila", "createdAt": "2020-09-08T12:45:10Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -885,25 +903,150 @@ old_fast_jitPutFlattenableStaticField(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayObject = (j9object_t)currentThread->floatTemp1;\n+\tU_32 index = *(U_32 *)&currentThread->floatTemp2;\n+\tvoid *addr = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\tif (NULL == arrayObject) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t value = NULL;\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\t\tif (index >= arrayLength) {\n+\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);\n+\t\t} else {\n+\t\t\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\t\t\tvalue = currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, false);\n+\t\t\tif (NULL == value) {\n+\t\t\t\taddr = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tcurrentThread->floatTemp1 = (void*)value; // in case of decompile\n+\t\t\taddr = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\t\t\tif (NULL != addr) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJIT_RETURN_UDATA(value);\n+\t\t}\n+\t}\n+done:\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn addr;\n }\n \n void* J9FASTCALL\n old_fast_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(2);\n+\tDECLARE_JIT_PARM(j9object_t, arrayObject, 1);\n+\tDECLARE_JIT_INT_PARM(index, 2);\n+\tbool slowPathUsed = false;\n+\tvoid *slowPath = NULL;\n+\tj9object_t value = NULL;\n+\tU_32 arrayLength = 0;\n+\tif (NULL == arrayObject) {\n+\t\tgoto slow;\n+\t}\n+\tarrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\tif (index >= arrayLength) {\n+\t\tgoto slow;\n+\t}\n+\tvalue = (j9object_t) currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, true);\n+\tif (J9_UNEXPECTED(NULL == value)) {\n+\t\tgoto slow;\n+\t}\n+\tJIT_RETURN_UDATA(value);\n+done:\n+\treturn slowPath;\n+slow:\n+\tslowPathUsed = true;\n+\tcurrentThread->floatTemp1 = (void *)arrayObject;\n+\tcurrentThread->floatTemp2 = *(void **)&index;\n+\tslowPath = (void*)old_slow_jitLoadFlattenableArrayElement;\n+\tgoto done;\n }\n \n void* J9FASTCALL\n old_slow_jitStoreFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayref = (j9object_t)currentThread->floatTemp1;\n+\tj9object_t value = (j9object_t)currentThread->floatTemp2;\n+\tU_32 index = *(U_32 *)&currentThread->floatTemp3;\n+\tU_32 arrayLength = 0;\n+\tvoid *addr = NULL;\n+\tif (NULL == arrayref) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tarrayLength = J9INDEXABLEOBJECT_SIZE(currentThread, arrayref);\n+\t\tif (index >= arrayLength) {\n+\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);\n+\t\t} else {\n+\t\t\tif (false == jitObjectArrayStoreAllowed(arrayref, value)) {\n+\t\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYSTOREEXCEPTION, NULL);\n+\t\t\t} else {\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\t\t\tJ9ArrayClass *arrayrefClass = (J9ArrayClass *) J9OBJECT_CLAZZ(currentThread, arrayref);\n+\t\t\t\tif (J9_IS_J9CLASS_VALUETYPE(arrayrefClass->componentType) && (NULL == value)) {\n+\t\t\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);;\n+\t\t\t\t} else\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+\t\t\t\t{\n+\t\t\t\t\tcurrentThread->javaVM->internalVMFunctions->storeFlattenableArrayElement(currentThread, arrayref, index, value);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn addr;\n }\n \n void* J9FASTCALL\n old_fast_jitStoreFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(3);\n+\tDECLARE_JIT_PARM(j9object_t, arrayref, 1);\n+\tDECLARE_JIT_PARM(j9object_t, value, 2);\n+\tDECLARE_JIT_INT_PARM(index, 3);\n+\tbool slowPathUsed = false;\n+\tvoid *slowPath = NULL;\n+\tU_32 arrayLength = 0;\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\tJ9ArrayClass *arrayrefClass = NULL;\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+\tif (NULL == arrayref) {\n+\t\tgoto slow;\n+\t}\n+\tarrayLength = J9INDEXABLEOBJECT_SIZE(currentThread, arrayref);\n+\tif (index >= arrayLength) {\n+\t\tgoto slow;\n+\t}\n+\tif (false == jitObjectArrayStoreAllowed(arrayref, value)) {\n+\t\tgoto slow;\n+\t}\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)", "originalCommit": "d70f830818e02a1644e94f95570063ebf3fc0595", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg4Nzc3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r484887777", "bodyText": "this test is not needed, the helper will only be called if the array is a valuetype", "author": "tajila", "createdAt": "2020-09-08T12:47:27Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -885,25 +903,150 @@ old_fast_jitPutFlattenableStaticField(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayObject = (j9object_t)currentThread->floatTemp1;\n+\tU_32 index = *(U_32 *)&currentThread->floatTemp2;\n+\tvoid *addr = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\tif (NULL == arrayObject) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t value = NULL;\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\t\tif (index >= arrayLength) {\n+\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);\n+\t\t} else {\n+\t\t\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\t\t\tvalue = currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, false);\n+\t\t\tif (NULL == value) {\n+\t\t\t\taddr = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tcurrentThread->floatTemp1 = (void*)value; // in case of decompile\n+\t\t\taddr = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\t\t\tif (NULL != addr) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJIT_RETURN_UDATA(value);\n+\t\t}\n+\t}\n+done:\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn addr;\n }\n \n void* J9FASTCALL\n old_fast_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(2);\n+\tDECLARE_JIT_PARM(j9object_t, arrayObject, 1);\n+\tDECLARE_JIT_INT_PARM(index, 2);\n+\tbool slowPathUsed = false;\n+\tvoid *slowPath = NULL;\n+\tj9object_t value = NULL;\n+\tU_32 arrayLength = 0;\n+\tif (NULL == arrayObject) {\n+\t\tgoto slow;\n+\t}\n+\tarrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\tif (index >= arrayLength) {\n+\t\tgoto slow;\n+\t}\n+\tvalue = (j9object_t) currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, true);\n+\tif (J9_UNEXPECTED(NULL == value)) {\n+\t\tgoto slow;\n+\t}\n+\tJIT_RETURN_UDATA(value);\n+done:\n+\treturn slowPath;\n+slow:\n+\tslowPathUsed = true;\n+\tcurrentThread->floatTemp1 = (void *)arrayObject;\n+\tcurrentThread->floatTemp2 = *(void **)&index;\n+\tslowPath = (void*)old_slow_jitLoadFlattenableArrayElement;\n+\tgoto done;\n }\n \n void* J9FASTCALL\n old_slow_jitStoreFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayref = (j9object_t)currentThread->floatTemp1;\n+\tj9object_t value = (j9object_t)currentThread->floatTemp2;\n+\tU_32 index = *(U_32 *)&currentThread->floatTemp3;\n+\tU_32 arrayLength = 0;\n+\tvoid *addr = NULL;\n+\tif (NULL == arrayref) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tarrayLength = J9INDEXABLEOBJECT_SIZE(currentThread, arrayref);\n+\t\tif (index >= arrayLength) {\n+\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);\n+\t\t} else {\n+\t\t\tif (false == jitObjectArrayStoreAllowed(arrayref, value)) {\n+\t\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYSTOREEXCEPTION, NULL);\n+\t\t\t} else {\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\t\t\tJ9ArrayClass *arrayrefClass = (J9ArrayClass *) J9OBJECT_CLAZZ(currentThread, arrayref);\n+\t\t\t\tif (J9_IS_J9CLASS_VALUETYPE(arrayrefClass->componentType) && (NULL == value)) {\n+\t\t\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);;\n+\t\t\t\t} else\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+\t\t\t\t{\n+\t\t\t\t\tcurrentThread->javaVM->internalVMFunctions->storeFlattenableArrayElement(currentThread, arrayref, index, value);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn addr;\n }\n \n void* J9FASTCALL\n old_fast_jitStoreFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(3);\n+\tDECLARE_JIT_PARM(j9object_t, arrayref, 1);\n+\tDECLARE_JIT_PARM(j9object_t, value, 2);\n+\tDECLARE_JIT_INT_PARM(index, 3);\n+\tbool slowPathUsed = false;\n+\tvoid *slowPath = NULL;\n+\tU_32 arrayLength = 0;\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\tJ9ArrayClass *arrayrefClass = NULL;\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+\tif (NULL == arrayref) {\n+\t\tgoto slow;\n+\t}\n+\tarrayLength = J9INDEXABLEOBJECT_SIZE(currentThread, arrayref);\n+\tif (index >= arrayLength) {\n+\t\tgoto slow;\n+\t}\n+\tif (false == jitObjectArrayStoreAllowed(arrayref, value)) {\n+\t\tgoto slow;\n+\t}\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\tarrayrefClass = (J9ArrayClass *) J9OBJECT_CLAZZ(currentThread, arrayref);\n+\tif (J9_IS_J9CLASS_VALUETYPE(arrayrefClass->componentType) && (NULL == value)) {", "originalCommit": "d70f830818e02a1644e94f95570063ebf3fc0595", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg5NzMzNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r484897337", "bodyText": "you dont need to copy this function, I didnt realize this is what you were talking about. Yes, your original suggestion of moving this into VMHelpers.hpp is correct. This way it can be shared by the interpreter and the runtime helpres", "author": "tajila", "createdAt": "2020-09-08T13:02:32Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -213,6 +213,24 @@ restoreBranchJITResolveFrame(J9VMThread *currentThread)\n \trestoreJITResolveFrame(currentThread, NULL, false, false);\n }\n \n+VMINLINE bool", "originalCommit": "d70f830818e02a1644e94f95570063ebf3fc0595", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkxMDM4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r484910382", "bodyText": "its not actually possible to get here, you can only be in the slow path if you are throwing an exception, since the storing the element cant fail", "author": "tajila", "createdAt": "2020-09-08T13:21:12Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -885,25 +903,150 @@ old_fast_jitPutFlattenableStaticField(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayObject = (j9object_t)currentThread->floatTemp1;\n+\tU_32 index = *(U_32 *)&currentThread->floatTemp2;\n+\tvoid *addr = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\tif (NULL == arrayObject) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t value = NULL;\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\t\tif (index >= arrayLength) {\n+\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);\n+\t\t} else {\n+\t\t\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\t\t\tvalue = currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, false);\n+\t\t\tif (NULL == value) {\n+\t\t\t\taddr = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tcurrentThread->floatTemp1 = (void*)value; // in case of decompile\n+\t\t\taddr = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\t\t\tif (NULL != addr) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJIT_RETURN_UDATA(value);\n+\t\t}\n+\t}\n+done:\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn addr;\n }\n \n void* J9FASTCALL\n old_fast_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(2);\n+\tDECLARE_JIT_PARM(j9object_t, arrayObject, 1);\n+\tDECLARE_JIT_INT_PARM(index, 2);\n+\tbool slowPathUsed = false;\n+\tvoid *slowPath = NULL;\n+\tj9object_t value = NULL;\n+\tU_32 arrayLength = 0;\n+\tif (NULL == arrayObject) {\n+\t\tgoto slow;\n+\t}\n+\tarrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\tif (index >= arrayLength) {\n+\t\tgoto slow;\n+\t}\n+\tvalue = (j9object_t) currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, true);\n+\tif (J9_UNEXPECTED(NULL == value)) {\n+\t\tgoto slow;\n+\t}\n+\tJIT_RETURN_UDATA(value);\n+done:\n+\treturn slowPath;\n+slow:\n+\tslowPathUsed = true;\n+\tcurrentThread->floatTemp1 = (void *)arrayObject;\n+\tcurrentThread->floatTemp2 = *(void **)&index;\n+\tslowPath = (void*)old_slow_jitLoadFlattenableArrayElement;\n+\tgoto done;\n }\n \n void* J9FASTCALL\n old_slow_jitStoreFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayref = (j9object_t)currentThread->floatTemp1;\n+\tj9object_t value = (j9object_t)currentThread->floatTemp2;\n+\tU_32 index = *(U_32 *)&currentThread->floatTemp3;\n+\tU_32 arrayLength = 0;\n+\tvoid *addr = NULL;\n+\tif (NULL == arrayref) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tarrayLength = J9INDEXABLEOBJECT_SIZE(currentThread, arrayref);\n+\t\tif (index >= arrayLength) {\n+\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);\n+\t\t} else {\n+\t\t\tif (false == jitObjectArrayStoreAllowed(arrayref, value)) {\n+\t\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYSTOREEXCEPTION, NULL);\n+\t\t\t} else {\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\t\t\tJ9ArrayClass *arrayrefClass = (J9ArrayClass *) J9OBJECT_CLAZZ(currentThread, arrayref);\n+\t\t\t\tif (J9_IS_J9CLASS_VALUETYPE(arrayrefClass->componentType) && (NULL == value)) {\n+\t\t\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);;\n+\t\t\t\t} else\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+\t\t\t\t{\n+\t\t\t\t\tcurrentThread->javaVM->internalVMFunctions->storeFlattenableArrayElement(currentThread, arrayref, index, value);", "originalCommit": "d70f830818e02a1644e94f95570063ebf3fc0595", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkxODI0Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r484918247", "bodyText": "add a comment saying \"We only get here due to an allocation failure\"", "author": "tajila", "createdAt": "2020-09-08T13:27:55Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -5875,34 +5875,23 @@ class INTERPRETER_CLASS\n \t\t\t\t_currentThread->tempSlot = (UDATA)index;\n \t\t\t\trc = THROW_AIOB;\n \t\t\t} else {\n-\t\t\t\tj9object_t value = NULL;\n+\t\t\t\tj9object_t value = VM_ValueTypeHelpers::loadFlattenableArrayElement(_currentThread, _objectAccessBarrier, _objectAllocate, arrayref, index, true);\n #if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n \t\t\t\tJ9Class *arrayrefClass = J9OBJECT_CLAZZ(_currentThread, arrayref);\n-\t\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n-\t\t\t\t\tj9object_t newObjectRef = _objectAllocate.inlineAllocateObject(_currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, false, false);\n-\n-\t\t\t\t\tif (NULL == newObjectRef) {\n-\t\t\t\t\t\tbuildGenericSpecialStackFrame(REGISTER_ARGS, 0);\n-\t\t\t\t\t\tpushObjectInSpecialFrame(REGISTER_ARGS, arrayref);\n-\t\t\t\t\t\tupdateVMStruct(REGISTER_ARGS);\n-\t\t\t\t\t\tnewObjectRef = _vm->memoryManagerFunctions->J9AllocateObject(_currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n-\t\t\t\t\t\tVMStructHasBeenUpdated(REGISTER_ARGS);\n-\t\t\t\t\t\tarrayref = popObjectInSpecialFrame(REGISTER_ARGS);\n-\t\t\t\t\t\trestoreGenericSpecialStackFrame(REGISTER_ARGS);\n-\t\t\t\t\t\tif (J9_UNEXPECTED(NULL == newObjectRef)) {\n-\t\t\t\t\t\t\trc = THROW_HEAP_OOM;\n-\t\t\t\t\t\t\treturn rc;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tarrayrefClass = VM_VMHelpers::currentClass(arrayrefClass);\n+\t\t\t\tif ((NULL == value) && J9_IS_J9CLASS_VALUETYPE(arrayrefClass)) {", "originalCommit": "d70f830818e02a1644e94f95570063ebf3fc0595", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "41a72e1948b514b787007eda63af258b2b9eedd0", "url": "https://github.com/eclipse-openj9/openj9/commit/41a72e1948b514b787007eda63af258b2b9eedd0", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading and storing flattenable array\nelement with a slow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n-old_fast_jitStoreFlattenableArrayElement: Attempts to use fast\npath to store value into array. If it fails, calls the slow\\\nvariant.\n-old_slow_jitStoreFlattenableArrayElement: Proceeds through\nsllow path for storing, throws appropriate exceptions when\nneeded.\n\nMoved ByteCodeInterpreter helper to  VMHelpers to check if\nstoring object in an array is allowed. Replaced occurence\nin ByteCodeInterpreter to new version.\n-objectArrayStoreAllowed\n\nAdded ValueTypeHelpers loadFlattenableArrayElement and\nstoreFlattenableArrayElement which perform aaload and\naastore functions respectively. Both handle flattened and\nunflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls loadFlattenableArrayElement\n-storeFlattenableArrayElement: c function that initializes\nrequired objects and calls storeFlattenableArrayElement\n\nReplaced existing code in aaload and aastore functions in\nByteCodeInterpreter.hpp with calls to loadFlattenableArrayElement\nand storeFlattenableArrayElement. Functionality remains the same.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-09-08T17:24:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQzMzI0OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r486433248", "bodyText": "need to push/pop receiverObject in special frame as J9AllocateObject might cause GC", "author": "tajila", "createdAt": "2020-09-10T15:26:01Z", "path": "runtime/vm/ValueTypeHelpers.hpp", "diffHunk": "@@ -417,6 +417,83 @@ class VM_ValueTypeHelpers {\n \t\t}\n \t}\n \n+\t/**\n+\t * Performs an aastore operation on an object. Handles flattened and non-flattened cases.\n+\t *\n+\t * Assumes recieverObject and paramObject are not null.\n+\t * All AIOB exceptions must be thrown before calling.\n+\t *\n+\t * @param[in] currentThread thread token\n+\t * @param[in] _objectAccessBarrier access barrier\n+\t * @param[in] receiverObject arrayObject\n+\t * @param[in] index array index\n+\t * @param[in] paramObject obj arg\n+\t */\n+\tstatic VMINLINE void\n+\tstoreFlattenableArrayElement(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI _objectAccessBarrier, j9object_t receiverObject, U_32 index, j9object_t paramObject)\n+\t{\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\tJ9ArrayClass *arrayrefClass = (J9ArrayClass *) J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+\t\t\t_objectAccessBarrier.copyObjectFieldsToFlattenedArrayElement(currentThread, arrayrefClass, paramObject, (J9IndexableObject *) receiverObject, index);\n+\t\t} else\n+#endif /* if defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n+\t\t{\n+\t\t\t_objectAccessBarrier.inlineIndexableObjectStoreObject(currentThread, receiverObject, index, paramObject);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Performs an aaload operation on an object. Handles flattened and non-flattened cases.\n+\t *\n+\t * Assumes recieverObject is not null.\n+\t * All AIOB exceptions must be thrown before calling.\n+\t *\n+\t * Returns null if newObjectRef retrieval fails.\n+\t *\n+\t * If fast == false, special stack frame must be built and receiverObject must be pushed onto it.\n+\t *\n+\t * @param[in] currentThread thread token\n+\t * @param[in] _objectAccessBarrier access barrier\n+\t * @param[in] _objectAllocate allocator\n+\t * @param[in] receiverObject arrayobject\n+\t * @param[in] index array index\n+\t *\n+\t * @return array element\n+\t */\n+\tstatic VMINLINE j9object_t\n+\tloadFlattenableArrayElement(J9VMThread *currentThread, MM_ObjectAccessBarrierAPI _objectAccessBarrier, MM_ObjectAllocationAPI _objectAllocate, j9object_t receiverObject, U_32 index, bool fast)\n+\t{\n+\t\tj9object_t value = NULL;\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\t\tj9object_t newObjectRef = NULL;\n+\t\tJ9Class *arrayrefClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n+\t\t\tif (fast) {\n+\t\t\t\tnewObjectRef = _objectAllocate.inlineAllocateObject(currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, false, false);\n+\t\t\t\tif(J9_UNEXPECTED(NULL == newObjectRef)) {\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tnewObjectRef = currentThread->javaVM->memoryManagerFunctions->J9AllocateObject(currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);", "originalCommit": "41a72e1948b514b787007eda63af258b2b9eedd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU3MDY5Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r486570693", "bodyText": "It's stated in the function's comment\n\n\"If fast == false, special stack frame must be built and receiverObject must be pushed onto it.\"\nLet me know if you'd still like me to change it.", "author": "OussamaSaoudi", "createdAt": "2020-09-10T19:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQzMzI0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU3NzI3Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r486577276", "bodyText": "ah forgot about that. ignore that comment", "author": "tajila", "createdAt": "2020-09-10T19:15:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQzMzI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQzNTAwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r486435007", "bodyText": "can you delete the existing one in the bytecode interpreter", "author": "tajila", "createdAt": "2020-09-10T15:28:20Z", "path": "runtime/oti/VMHelpers.hpp", "diffHunk": "@@ -1704,6 +1704,24 @@ class VM_VMHelpers\n \t\t}\n \t\treturn method;\n \t}\n+\tstatic VMINLINE bool\n+\tobjectArrayStoreAllowed(j9object_t array, j9object_t storeValue)", "originalCommit": "41a72e1948b514b787007eda63af258b2b9eedd0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MjIyNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r486482225", "bodyText": "since this code has to throw, you can just build once the frame upfront", "author": "tajila", "createdAt": "2020-09-10T16:36:30Z", "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -885,25 +885,139 @@ old_fast_jitPutFlattenableStaticField(J9VMThread *currentThread)\n void* J9FASTCALL\n old_slow_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayObject = (j9object_t)currentThread->floatTemp1;\n+\tU_32 index = *(U_32 *)&currentThread->floatTemp2;\n+\tvoid *addr = NULL;\n+\tvoid *oldPC = currentThread->jitReturnAddress;\n+\tif (NULL == arrayObject) {\n+\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t value = NULL;\n+\t\tU_32 arrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\t\tif (index >= arrayLength) {\n+\t\t\tbuildJITResolveFrameForRuntimeHelper(currentThread, parmCount);\n+\t\t\taddr = setCurrentExceptionFromJIT(currentThread, J9VMCONSTANTPOOL_JAVALANGARRAYINDEXOUTOFBOUNDSEXCEPTION, NULL);\n+\t\t} else {\n+\t\t\tbuildJITResolveFrameWithPC(currentThread, J9_STACK_FLAGS_JIT_ALLOCATION_RESOLVE | J9_SSF_JIT_RESOLVE, parmCount, true, 0, oldPC);\n+\t\t\tvalue = currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, false);\n+\t\t\tif (NULL == value) {\n+\t\t\t\taddr = setHeapOutOfMemoryErrorFromJIT(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tcurrentThread->floatTemp1 = (void*)value; // in case of decompile\n+\t\t\taddr = restoreJITResolveFrame(currentThread, oldPC, false, false);\n+\t\t\tif (NULL != addr) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJIT_RETURN_UDATA(value);\n+\t\t}\n+\t}\n+done:\n+\tSLOW_JIT_HELPER_EPILOGUE();\n+\treturn addr;\n }\n \n void* J9FASTCALL\n old_fast_jitLoadFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tOLD_JIT_HELPER_PROLOGUE(2);\n+\tDECLARE_JIT_PARM(j9object_t, arrayObject, 1);\n+\tDECLARE_JIT_INT_PARM(index, 2);\n+\tbool slowPathUsed = false;\n+\tvoid *slowPath = NULL;\n+\tj9object_t value = NULL;\n+\tU_32 arrayLength = 0;\n+\tif (NULL == arrayObject) {\n+\t\tgoto slow;\n+\t}\n+\tarrayLength = J9INDEXABLEOBJECT_SIZE(_currentThread, arrayObject);\n+\tif (index >= arrayLength) {\n+\t\tgoto slow;\n+\t}\n+\tvalue = (j9object_t) currentThread->javaVM->internalVMFunctions->loadFlattenableArrayElement(currentThread, arrayObject, index, true);\n+\tif (J9_UNEXPECTED(NULL == value)) {\n+\t\tgoto slow;\n+\t}\n+\tJIT_RETURN_UDATA(value);\n+done:\n+\treturn slowPath;\n+slow:\n+\tslowPathUsed = true;\n+\tcurrentThread->floatTemp1 = (void *)arrayObject;\n+\tcurrentThread->floatTemp2 = *(void **)&index;\n+\tslowPath = (void*)old_slow_jitLoadFlattenableArrayElement;\n+\tgoto done;\n }\n \n void* J9FASTCALL\n old_slow_jitStoreFlattenableArrayElement(J9VMThread *currentThread)\n {\n-\treturn NULL;\n+\tSLOW_JIT_HELPER_PROLOGUE();\n+\tj9object_t arrayref = (j9object_t)currentThread->floatTemp1;\n+\tj9object_t value = (j9object_t)currentThread->floatTemp2;\n+\tU_32 index = *(U_32 *)&currentThread->floatTemp3;\n+\tU_32 arrayLength = 0;\n+\tvoid *addr = NULL;\n+\tif (NULL == arrayref) {", "originalCommit": "41a72e1948b514b787007eda63af258b2b9eedd0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "082936914da67b4dde1d7a24d1223de999022d65", "url": "https://github.com/eclipse-openj9/openj9/commit/082936914da67b4dde1d7a24d1223de999022d65", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading and storing flattenable array\nelement with a slow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n-old_fast_jitStoreFlattenableArrayElement: Attempts to use fast\npath to store value into array. If it fails, calls the slow\\\nvariant.\n-old_slow_jitStoreFlattenableArrayElement: Proceeds through\nsllow path for storing, throws appropriate exceptions when\nneeded.\n\nMoved ByteCodeInterpreter helper to  VMHelpers to check if\nstoring object in an array is allowed. Replaced occurence\nin ByteCodeInterpreter to new version.\n-objectArrayStoreAllowed\n\nAdded ValueTypeHelpers loadFlattenableArrayElement and\nstoreFlattenableArrayElement which perform aaload and\naastore functions respectively. Both handle flattened and\nunflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls loadFlattenableArrayElement\n-storeFlattenableArrayElement: c function that initializes\nrequired objects and calls storeFlattenableArrayElement\n\nReplaced existing code in aaload and aastore functions in\nByteCodeInterpreter.hpp with calls to loadFlattenableArrayElement\nand storeFlattenableArrayElement. Functionality remains the same.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-09-10T19:32:24Z", "type": "forcePushed"}, {"oid": "2ae150cf55d928410e9416e672b8a1898a572a00", "url": "https://github.com/eclipse-openj9/openj9/commit/2ae150cf55d928410e9416e672b8a1898a572a00", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading and storing flattenable array\nelement with a slow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n-old_fast_jitStoreFlattenableArrayElement: Attempts to use fast\npath to store value into array. If it fails, calls the slow\\\nvariant.\n-old_slow_jitStoreFlattenableArrayElement: Proceeds through\nsllow path for storing, throws appropriate exceptions when\nneeded.\n\nMoved ByteCodeInterpreter helper to  VMHelpers to check if\nstoring object in an array is allowed. Replaced occurence\nin ByteCodeInterpreter to new version.\n-objectArrayStoreAllowed\n\nAdded ValueTypeHelpers loadFlattenableArrayElement and\nstoreFlattenableArrayElement which perform aaload and\naastore functions respectively. Both handle flattened and\nunflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls loadFlattenableArrayElement\n-storeFlattenableArrayElement: c function that initializes\nrequired objects and calls storeFlattenableArrayElement\n\nReplaced existing code in aaload and aastore functions in\nByteCodeInterpreter.hpp with calls to loadFlattenableArrayElement\nand storeFlattenableArrayElement. Functionality remains the same.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-09-11T14:33:29Z", "type": "forcePushed"}, {"oid": "a47940a1ff84a5ca91e9d7a8541736c484a2e46e", "url": "https://github.com/eclipse-openj9/openj9/commit/a47940a1ff84a5ca91e9d7a8541736c484a2e46e", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading and storing flattenable array\nelement with a slow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n-old_fast_jitStoreFlattenableArrayElement: Attempts to use fast\npath to store value into array. If it fails, calls the slow\\\nvariant.\n-old_slow_jitStoreFlattenableArrayElement: Proceeds through\nsllow path for storing, throws appropriate exceptions when\nneeded.\n\nMoved ByteCodeInterpreter helper to  VMHelpers to check if\nstoring object in an array is allowed. Replaced occurence\nin ByteCodeInterpreter to new version.\n-objectArrayStoreAllowed\n\nAdded ValueTypeHelpers loadFlattenableArrayElement and\nstoreFlattenableArrayElement which perform aaload and\naastore functions respectively. Both handle flattened and\nunflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls loadFlattenableArrayElement\n-storeFlattenableArrayElement: c function that initializes\nrequired objects and calls storeFlattenableArrayElement\n\nReplaced existing code in aaload and aastore functions in\nByteCodeInterpreter.hpp with calls to loadFlattenableArrayElement\nand storeFlattenableArrayElement. Functionality remains the same.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-09-14T14:47:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE1MDY1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9938#discussion_r488150651", "bodyText": "This is the problem, J9_IS_J9CLASS_VALUETYPE(arrayrefClass), arrayclasses are never marked as VT's only the element types. This should remain as the J9_IS_J9CLASS_FLATTENED test", "author": "tajila", "createdAt": "2020-09-14T18:53:02Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -5875,34 +5857,24 @@ class INTERPRETER_CLASS\n \t\t\t\t_currentThread->tempSlot = (UDATA)index;\n \t\t\t\trc = THROW_AIOB;\n \t\t\t} else {\n-\t\t\t\tj9object_t value = NULL;\n+\t\t\t\tj9object_t value = VM_ValueTypeHelpers::loadFlattenableArrayElement(_currentThread, _objectAccessBarrier, _objectAllocate, arrayref, index, true);\n #if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n \t\t\t\tJ9Class *arrayrefClass = J9OBJECT_CLAZZ(_currentThread, arrayref);\n-\t\t\t\tif (J9_IS_J9CLASS_FLATTENED(arrayrefClass)) {\n-\t\t\t\t\tj9object_t newObjectRef = _objectAllocate.inlineAllocateObject(_currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, false, false);\n-\n-\t\t\t\t\tif (NULL == newObjectRef) {\n-\t\t\t\t\t\tbuildGenericSpecialStackFrame(REGISTER_ARGS, 0);\n-\t\t\t\t\t\tpushObjectInSpecialFrame(REGISTER_ARGS, arrayref);\n-\t\t\t\t\t\tupdateVMStruct(REGISTER_ARGS);\n-\t\t\t\t\t\tnewObjectRef = _vm->memoryManagerFunctions->J9AllocateObject(_currentThread, ((J9ArrayClass*)arrayrefClass)->leafComponentType, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n-\t\t\t\t\t\tVMStructHasBeenUpdated(REGISTER_ARGS);\n-\t\t\t\t\t\tarrayref = popObjectInSpecialFrame(REGISTER_ARGS);\n-\t\t\t\t\t\trestoreGenericSpecialStackFrame(REGISTER_ARGS);\n-\t\t\t\t\t\tif (J9_UNEXPECTED(NULL == newObjectRef)) {\n-\t\t\t\t\t\t\trc = THROW_HEAP_OOM;\n-\t\t\t\t\t\t\treturn rc;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tarrayrefClass = VM_VMHelpers::currentClass(arrayrefClass);\n+\t\t\t\tif ((NULL == value) && J9_IS_J9CLASS_VALUETYPE(arrayrefClass)) {", "originalCommit": "a47940a1ff84a5ca91e9d7a8541736c484a2e46e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eada15c6c142e06fd62a60b5a7c70b28d6afba2e", "url": "https://github.com/eclipse-openj9/openj9/commit/eada15c6c142e06fd62a60b5a7c70b28d6afba2e", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading and storing flattenable array\nelement with a slow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n-old_fast_jitStoreFlattenableArrayElement: Attempts to use fast\npath to store value into array. If it fails, calls the slow\\\nvariant.\n-old_slow_jitStoreFlattenableArrayElement: Proceeds through\nsllow path for storing, throws appropriate exceptions when\nneeded.\n\nMoved ByteCodeInterpreter helper to  VMHelpers to check if\nstoring object in an array is allowed. Replaced occurence\nin ByteCodeInterpreter to new version.\n-objectArrayStoreAllowed\n\nAdded ValueTypeHelpers loadFlattenableArrayElement and\nstoreFlattenableArrayElement which perform aaload and\naastore functions respectively. Both handle flattened and\nunflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls loadFlattenableArrayElement\n-storeFlattenableArrayElement: c function that initializes\nrequired objects and calls storeFlattenableArrayElement\n\nReplaced existing code in aaload and aastore functions in\nByteCodeInterpreter.hpp with calls to loadFlattenableArrayElement\nand storeFlattenableArrayElement. Functionality remains the same.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-09-14T19:06:22Z", "type": "commit"}, {"oid": "eada15c6c142e06fd62a60b5a7c70b28d6afba2e", "url": "https://github.com/eclipse-openj9/openj9/commit/eada15c6c142e06fd62a60b5a7c70b28d6afba2e", "message": "Added jitHelpers for store and load\n\nAdded jitHelpers for loading and storing flattenable array\nelement with a slow and fast variant.\n-old_fast-jitLoadFlattenableArrayElement: Attempts to use fast\npath to load array element. If it fails calls the slow variant.\n-old_slow_jitLoadFlattenableArrayElement: Proceeds thorugh slow\npath for loading, throwing appropriate exceptions when needed.\n-old_fast_jitStoreFlattenableArrayElement: Attempts to use fast\npath to store value into array. If it fails, calls the slow\\\nvariant.\n-old_slow_jitStoreFlattenableArrayElement: Proceeds through\nsllow path for storing, throws appropriate exceptions when\nneeded.\n\nMoved ByteCodeInterpreter helper to  VMHelpers to check if\nstoring object in an array is allowed. Replaced occurence\nin ByteCodeInterpreter to new version.\n-objectArrayStoreAllowed\n\nAdded ValueTypeHelpers loadFlattenableArrayElement and\nstoreFlattenableArrayElement which perform aaload and\naastore functions respectively. Both handle flattened and\nunflattened cases. Both contain an option for either a fast\nor a slow variant.\n-loadFlattenableArrayElement: Loads flattenable array element\n-storeFlattenableArrayElement: Stores flattenable array element\n-loadFlattenableArrayElement: c function that initializes\nrequired objects and calls loadFlattenableArrayElement\n-storeFlattenableArrayElement: c function that initializes\nrequired objects and calls storeFlattenableArrayElement\n\nReplaced existing code in aaload and aastore functions in\nByteCodeInterpreter.hpp with calls to loadFlattenableArrayElement\nand storeFlattenableArrayElement. Functionality remains the same.\n\nRelated to: https://github.com/eclipse/openj9/issues/9627\n\nSigned-off-by: Oussama Saoudi <oussama.saoudi@ibm.com>", "committedDate": "2020-09-14T19:06:22Z", "type": "forcePushed"}]}