{"pr_number": 9326, "pr_title": "Supporting Changes for mon(ent/exit) for value Types", "pr_createdAt": "2020-04-22T20:30:39Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9326", "timeline": [{"oid": "c99f445c36fe76ead49f8c155b36812bf8df525b", "url": "https://github.com/eclipse-openj9/openj9/commit/c99f445c36fe76ead49f8c155b36812bf8df525b", "message": "Supporting Changes for mon(ent/exit) for value Types\n\nAdd support for monitor enter/exit for value Types on IBM Z.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-04-22T20:55:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzNDcwNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r413334704", "bodyText": "@fjeremic  I have a big-fat TODO here, as whenever we are making substantial changes in monent/monexit or work towards enabling lock reservation, we do need to refactor both the evaluators.\nRight now We have multiple OOL sections generated.\n\nMonitorCacheLookup : We implement this in OOL and as last resource there we call the JIT Helper.\nLock Reservation : Also we perform some checks in OOL for lock reservation before calling the JIT helper.\nInlineRecursive:  Generating a manual nested monitor handling in OOL, which also has a helper call.\n\nRight now 2 is disabled and we generate either 1(In case we do not have lockword offset) or 3 and if we generate 1 , second OOL only contains a call to JIT Helper, otherwise, we have some good work done in OOL section for 3 before it call helper.", "author": "r30shah", "createdAt": "2020-04-22T21:09:19Z", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6937,16 +6937,57 @@ J9::Z::TreeEvaluator::VMifInstanceOfEvaluator(TR::Node * node, TR::CodeGenerator\n    return NULL;\n    }\n \n+TR::Register *\n+J9::Z::TreeEvaluator::generateCheckForValueTypeMonitorEnterOrExit(TR::Node *node, TR::Register *objReg, TR::LabelSymbol* mergeLabel, TR::LabelSymbol *helperCallLabel, TR::CodeGenerator *cg)\n+   {\n+   TR::Register *objectClassReg = cg->allocateRegister();\n+   TR::TreeEvaluator::genLoadForObjectHeadersMasked(cg, node, objectClassReg, generateS390MemoryReference(objReg, TR::Compiler->om.offsetOfObjectVftField(), cg), NULL);\n+   TR::Register *classFlagsRegister = cg->allocateRegister();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(cg->comp()->fe());\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, classFlagsRegister, generateS390MemoryReference(objectClassReg, static_cast<uint32_t>(fej9->getOffsetOfClassFlags()), cg));\n+   bool generateOOLSection = helperCallLabel == NULL;\n+   if (generateOOLSection)\n+      helperCallLabel = generateLabelSymbol(cg);\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, classFlagsRegister, static_cast<int32_t>(J9ClassIsValueType), TR::InstOpCode::COND_BE, helperCallLabel);\n+\n+   // TODO: As we have quite amount of work happening in OOL in other cases (Monitor Cache Lookup / Lock Reservation / Regular Code Recursive CAS code for monitor),", "originalCommit": "c99f445c36fe76ead49f8c155b36812bf8df525b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwNzUwNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416007504", "bodyText": "What you have here is fine. Personally I'd avoid complicating things with if (generateOOLSection) as it relies on external code doing something, so if any changes are made there would be bugs. Personally I'd unconditionally generate the OOL and call the helper just for our own sanity. However what you have is ok. I agree the evaluator is starting to become quite complicated now and needs some love.", "author": "fjeremic", "createdAt": "2020-04-27T17:29:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzNDcwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAyOTI4MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416029280", "bodyText": "What I intended to do here, is if, user has provided the helperCallLabel I am going to use that to generate a call to helper. If we have not generated a helper call (When we are either doing inline Recursive lock routine or monitor cache lookup) , this API will generate OOL.", "author": "r30shah", "createdAt": "2020-04-27T17:58:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzNDcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4MzYwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r415983607", "bodyText": "Is there a need to expose this API externally? The only two uses should be in the monitor evaluators, so I would think it could just remain as a static function in the compilation unit.", "author": "fjeremic", "createdAt": "2020-04-27T16:55:51Z", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.hpp", "diffHunk": "@@ -150,7 +150,17 @@ class OMR_EXTENSIBLE TreeEvaluator: public J9::TreeEvaluator\n                                                             TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *mergeLabel);\n \n \n-\n+   /**\n+    * Generates a quick runtime test for valueType node and in case if node is of valueType, generates a branch to helper call\n+    * \n+    * @param node monent or monexit node\n+    * @param objReg TR::Register containing the object\n+    * @param mergeLabel TR::LabelSymbol* to pointing to mergePoint in mainline\n+    * @param callLabel TR::LabelSymbol* pointing to the helper Call Label\n+    * @param cg CodeGenerator Object Ptr\n+    * @return TR::Register* If Given node required a runtime test to check for valueType, it will return the register containing J9Class of given object\n+    */\n+   static TR::Register *generateCheckForValueTypeMonitorEnterOrExit(TR::Node *node, TR::Register *objReg, TR::LabelSymbol *mergeLabel, TR::LabelSymbol *helperCallLabel, TR::CodeGenerator *cg);", "originalCommit": "c99f445c36fe76ead49f8c155b36812bf8df525b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAzMDUwNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416030504", "bodyText": "Certainly, this can be static. No need to expose this. Unless, we need to use same test for ReduceSynchronizedFieldLoad .", "author": "r30shah", "createdAt": "2020-04-27T18:00:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4MzYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA0NDg1Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416044853", "bodyText": "Synchronized field load optimization can't run for value types so it is fine to move this to live only in the .cpp file.", "author": "fjeremic", "createdAt": "2020-04-27T18:21:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4MzYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MDcwMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416160701", "bodyText": "Fixed this in https://github.com/eclipse/openj9/compare/097726868780ab77a37f3f823e2ba1d82900e0db..46e59d80a6c270bd3654d431e7c3372ec3d240b8", "author": "r30shah", "createdAt": "2020-04-27T21:26:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4MzYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5ODU1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r415998555", "bodyText": "This should be a static_cast if possible.", "author": "fjeremic", "createdAt": "2020-04-27T17:16:37Z", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6937,16 +6937,57 @@ J9::Z::TreeEvaluator::VMifInstanceOfEvaluator(TR::Node * node, TR::CodeGenerator\n    return NULL;\n    }\n \n+TR::Register *\n+J9::Z::TreeEvaluator::generateCheckForValueTypeMonitorEnterOrExit(TR::Node *node, TR::Register *objReg, TR::LabelSymbol* mergeLabel, TR::LabelSymbol *helperCallLabel, TR::CodeGenerator *cg)\n+   {\n+   TR::Register *objectClassReg = cg->allocateRegister();\n+   TR::TreeEvaluator::genLoadForObjectHeadersMasked(cg, node, objectClassReg, generateS390MemoryReference(objReg, TR::Compiler->om.offsetOfObjectVftField(), cg), NULL);\n+   TR::Register *classFlagsRegister = cg->allocateRegister();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(cg->comp()->fe());", "originalCommit": "c99f445c36fe76ead49f8c155b36812bf8df525b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MDc5Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416160793", "bodyText": "Fixed in https://github.com/eclipse/openj9/compare/097726868780ab77a37f3f823e2ba1d82900e0db..46e59d80a6c270bd3654d431e7c3372ec3d240b8", "author": "r30shah", "createdAt": "2020-04-27T21:27:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5ODU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5ODg2MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r415998861", "bodyText": "This register leaks. We never seem to call cg->stopUsingRegister on it.", "author": "fjeremic", "createdAt": "2020-04-27T17:17:04Z", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6937,16 +6937,57 @@ J9::Z::TreeEvaluator::VMifInstanceOfEvaluator(TR::Node * node, TR::CodeGenerator\n    return NULL;\n    }\n \n+TR::Register *\n+J9::Z::TreeEvaluator::generateCheckForValueTypeMonitorEnterOrExit(TR::Node *node, TR::Register *objReg, TR::LabelSymbol* mergeLabel, TR::LabelSymbol *helperCallLabel, TR::CodeGenerator *cg)\n+   {\n+   TR::Register *objectClassReg = cg->allocateRegister();\n+   TR::TreeEvaluator::genLoadForObjectHeadersMasked(cg, node, objectClassReg, generateS390MemoryReference(objReg, TR::Compiler->om.offsetOfObjectVftField(), cg), NULL);\n+   TR::Register *classFlagsRegister = cg->allocateRegister();", "originalCommit": "c99f445c36fe76ead49f8c155b36812bf8df525b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxOTY3OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416019678", "bodyText": "Yeah, I forgot to push latest changes, I found that while testing. https://github.com/eclipse/openj9/compare/c99f445c36fe76ead49f8c155b36812bf8df525b..097726868780ab77a37f3f823e2ba1d82900e0db contains the change.", "author": "r30shah", "createdAt": "2020-04-27T17:45:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5ODg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwNTk4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416005982", "bodyText": "I don't think we need to load the flags into a register. Can we get away with using TM to just test in memory and generate a BRC to act on it?", "author": "fjeremic", "createdAt": "2020-04-27T17:27:03Z", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6937,16 +6937,57 @@ J9::Z::TreeEvaluator::VMifInstanceOfEvaluator(TR::Node * node, TR::CodeGenerator\n    return NULL;\n    }\n \n+TR::Register *\n+J9::Z::TreeEvaluator::generateCheckForValueTypeMonitorEnterOrExit(TR::Node *node, TR::Register *objReg, TR::LabelSymbol* mergeLabel, TR::LabelSymbol *helperCallLabel, TR::CodeGenerator *cg)\n+   {\n+   TR::Register *objectClassReg = cg->allocateRegister();\n+   TR::TreeEvaluator::genLoadForObjectHeadersMasked(cg, node, objectClassReg, generateS390MemoryReference(objReg, TR::Compiler->om.offsetOfObjectVftField(), cg), NULL);\n+   TR::Register *classFlagsRegister = cg->allocateRegister();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(cg->comp()->fe());\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, classFlagsRegister, generateS390MemoryReference(objectClassReg, static_cast<uint32_t>(fej9->getOffsetOfClassFlags()), cg));\n+   bool generateOOLSection = helperCallLabel == NULL;\n+   if (generateOOLSection)\n+      helperCallLabel = generateLabelSymbol(cg);\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, classFlagsRegister, static_cast<int32_t>(J9ClassIsValueType), TR::InstOpCode::COND_BE, helperCallLabel);", "originalCommit": "c99f445c36fe76ead49f8c155b36812bf8df525b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjcyNjI5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416726294", "bodyText": "Actually I interpreted x86 implementation wrong. A version of TM should be used here not logical compare. @fjeremic  marking this as WIP while I fix it.", "author": "r30shah", "createdAt": "2020-04-28T15:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwNTk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc0MDc4MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416740780", "bodyText": "Correct sequence will look like following.\nL classFlagsRegister,@(J9class+classFlags)\nTMLL classFlagsRegister,0x400 // Ands 48-63 bits of classFlagsRegister with 0x400\nBRC NotZero, helperCallLabel\n\nChanges should be ok, though marking this WIP till I test it out again.", "author": "r30shah", "createdAt": "2020-04-28T16:10:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwNTk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc0NDU3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416744577", "bodyText": "Yeah that sequence looks good.", "author": "fjeremic", "createdAt": "2020-04-28T16:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwNTk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwODkxNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416008917", "bodyText": "We should try to stick to a similar implementation to x86 to avoid complexity and deviation. You only need to send in the node and from that you can extract the object register.", "author": "fjeremic", "createdAt": "2020-04-27T17:31:00Z", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6937,16 +6937,57 @@ J9::Z::TreeEvaluator::VMifInstanceOfEvaluator(TR::Node * node, TR::CodeGenerator\n    return NULL;\n    }\n \n+TR::Register *\n+J9::Z::TreeEvaluator::generateCheckForValueTypeMonitorEnterOrExit(TR::Node *node, TR::Register *objReg, TR::LabelSymbol* mergeLabel, TR::LabelSymbol *helperCallLabel, TR::CodeGenerator *cg)", "originalCommit": "c99f445c36fe76ead49f8c155b36812bf8df525b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAyNTY4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416025682", "bodyText": "The reason why I have to pass some extra argument to this function is because in the main evaluator, callLabel is either used for inline Recursive implementation of lock routine in OOL or a regular helper call. These label helps me minimizing the OOL section we are generating for monitor node. We certainly do not want to generate 3 OOL for single node, each have their own helper dispatch sequence to call same JIT helper function.", "author": "r30shah", "createdAt": "2020-04-27T17:53:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwODkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA0NDE1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416044150", "bodyText": "Right, I was talking about the need to pass in both node and objReg, when only node will suffice.", "author": "fjeremic", "createdAt": "2020-04-27T18:20:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwODkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MDk4OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416160989", "bodyText": "Fixed in https://github.com/eclipse/openj9/compare/097726868780ab77a37f3f823e2ba1d82900e0db..46e59d80a6c270bd3654d431e7c3372ec3d240b8", "author": "r30shah", "createdAt": "2020-04-27T21:27:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwODkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxMDQyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416010422", "bodyText": "Let's try to stick with similar code as on x86 and move this TR_maybe check into the API. Alternatively modify the x86 implementation to look like yours. Whichever you think is best as long as we are consistent.", "author": "fjeremic", "createdAt": "2020-04-27T17:32:53Z", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -7006,13 +7047,24 @@ J9::Z::TreeEvaluator::VMmonentEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    if (disableOOL)\n       inlineRecursive = false;\n \n+   if (TR::Compiler->om.areValueTypesEnabled() && isMonitorValueType == TR_maybe)", "originalCommit": "c99f445c36fe76ead49f8c155b36812bf8df525b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "097726868780ab77a37f3f823e2ba1d82900e0db", "url": "https://github.com/eclipse-openj9/openj9/commit/097726868780ab77a37f3f823e2ba1d82900e0db", "message": "Supporting Changes for mon(ent/exit) for value Types\n\nAdd support for monitor enter/exit for value Types on IBM Z.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-04-23T15:22:01Z", "type": "forcePushed"}, {"oid": "46e59d80a6c270bd3654d431e7c3372ec3d240b8", "url": "https://github.com/eclipse-openj9/openj9/commit/46e59d80a6c270bd3654d431e7c3372ec3d240b8", "message": "Supporting Changes for mon(ent/exit) for value Types\n\nAdd support for monitor enter/exit for value Types on IBM Z.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-04-27T21:07:11Z", "type": "forcePushed"}, {"oid": "a9677bf7a14415c84c7dcde1d0bf8fc7969e950b", "url": "https://github.com/eclipse-openj9/openj9/commit/a9677bf7a14415c84c7dcde1d0bf8fc7969e950b", "message": "Supporting Changes for mon(ent/exit) for value Types\n\nAdd support for monitor enter/exit for value Types on IBM Z.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-04-27T21:09:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MTkzMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416161933", "bodyText": "@fjeremic  We will not carry out further test in the loop if we find valueType is enabled and node can be of value type.", "author": "r30shah", "createdAt": "2020-04-27T21:29:01Z", "path": "runtime/compiler/z/codegen/ReduceSynchronizedFieldLoad.cpp", "diffHunk": "@@ -284,7 +284,9 @@ ReduceSynchronizedFieldLoad::performOnTreeTops(TR::TreeTop* startTreeTop, TR::Tr\n          TR::Node* monentNode = iter.currentNode()->getOpCodeValue() == TR::monent ?\n             iter.currentNode() :\n             iter.currentNode()->getFirstChild();\n-\n+         // If value types are enabled and the monitor is confirmed non value type, than only do this optimization.", "originalCommit": "a9677bf7a14415c84c7dcde1d0bf8fc7969e950b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc0NDEyNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416744127", "bodyText": "The comment is not very useful as the if statement pretty much says the same thing. Also the ! should be propagated inside the parenthesis. How about:\n// Locking on value types is prohibited by the spec., so this optimization can only be performed if we are certain (at compile time) the locking object is not a value type\nif (TR::Compiler->om.areValueTypesEnabled() && cg->isMonitorValueType(node) != TR_no)\n   continue;", "author": "fjeremic", "createdAt": "2020-04-28T16:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MTkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgwNDExNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416804117", "bodyText": "Fixed in https://github.com/eclipse/openj9/compare/247123bcd0bf7c87262e954972690bf87f08e56a..194c9838319153c006f53f64cfd8db44d2a78ad5", "author": "r30shah", "createdAt": "2020-04-28T17:43:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MTkzMw=="}], "type": "inlineReview"}, {"oid": "2a2c5fa991bf7b3579cbe91338977bcb1f0e2884", "url": "https://github.com/eclipse-openj9/openj9/commit/2a2c5fa991bf7b3579cbe91338977bcb1f0e2884", "message": "Supporting Changes for mon(ent/exit) for value Types\n\nAdd support for monitor enter/exit for value Types on IBM Z.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-04-28T16:06:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc0NzgwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416747807", "bodyText": "This is dangerous. We are assuming the value of J9ClassIsValueType is in a specific bit range. If that were ever to change we would have a silent bug here. Can we add a fatal assert that 0 < J9ClassIsValueType <= 0xFFFF?", "author": "fjeremic", "createdAt": "2020-04-28T16:19:58Z", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6937,16 +6937,69 @@ J9::Z::TreeEvaluator::VMifInstanceOfEvaluator(TR::Node * node, TR::CodeGenerator\n    return NULL;\n    }\n \n+/**\n+    * Generates a quick runtime test for valueType node and in case if node is of valueType, generates a branch to helper call\n+    * \n+    * @param node monent or monexit node\n+    * @param mergeLabel TR::LabelSymbol* to pointing to mergePoint in mainline\n+    * @param callLabel TR::LabelSymbol* pointing to the helper Call Label\n+    * @param cg CodeGenerator Object Ptr\n+    * @return TR::Register* If Given node required a runtime test to check for valueType, it will return the register containing J9Class of given object\n+    */\n+static TR::Register*\n+generateCheckForValueTypeMonitorEnterOrExit(TR::Node *node, TR::LabelSymbol* mergeLabel, TR::LabelSymbol *helperCallLabel, TR::CodeGenerator *cg)\n+   {\n+   TR::Register *objReg = cg->evaluate(node->getFirstChild());\n+   TR::Register *objectClassReg = cg->allocateRegister();\n+   TR::TreeEvaluator::genLoadForObjectHeadersMasked(cg, node, objectClassReg, generateS390MemoryReference(objReg, TR::Compiler->om.offsetOfObjectVftField(), cg), NULL);\n+   TR::Register *classFlagsRegister = cg->allocateRegister();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(cg->comp()->fe());\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, classFlagsRegister, generateS390MemoryReference(objectClassReg, static_cast<uint32_t>(fej9->getOffsetOfClassFlags()), cg));\n+   bool generateOOLSection = helperCallLabel == NULL;\n+   if (generateOOLSection)\n+      helperCallLabel = generateLabelSymbol(cg);\n+   \n+   generateRIInstruction(cg, TR::InstOpCode::TMLL, node, classFlagsRegister, J9ClassIsValueType);", "originalCommit": "2a2c5fa991bf7b3579cbe91338977bcb1f0e2884", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc1Njg0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416756843", "bodyText": "I have put the static assert same as x86 here (https://github.com/eclipse/openj9/compare/2a2c5fa991bf7b3579cbe91338977bcb1f0e2884..247123bcd0bf7c87262e954972690bf87f08e56a)", "author": "r30shah", "createdAt": "2020-04-28T16:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc0NzgwNw=="}], "type": "inlineReview"}, {"oid": "247123bcd0bf7c87262e954972690bf87f08e56a", "url": "https://github.com/eclipse-openj9/openj9/commit/247123bcd0bf7c87262e954972690bf87f08e56a", "message": "Supporting Changes for mon(ent/exit) for value Types\n\nAdd support for monitor enter/exit for value Types on IBM Z.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-04-28T16:27:12Z", "type": "forcePushed"}, {"oid": "194c9838319153c006f53f64cfd8db44d2a78ad5", "url": "https://github.com/eclipse-openj9/openj9/commit/194c9838319153c006f53f64cfd8db44d2a78ad5", "message": "Supporting Changes for mon(ent/exit) for value Types\n\nAdd support for monitor enter/exit for value Types on IBM Z.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-04-28T17:21:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg3NjA2Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r416876067", "bodyText": "This is still not what we want. I would have hoped the use of classFlagsRegister would have been completely eliminated. Can we get rid of this load and just turn the TMLL into TM (immediate-memory test under mask)?", "author": "fjeremic", "createdAt": "2020-04-28T19:43:46Z", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6937,16 +6937,71 @@ J9::Z::TreeEvaluator::VMifInstanceOfEvaluator(TR::Node * node, TR::CodeGenerator\n    return NULL;\n    }\n \n+/**\n+    * Generates a quick runtime test for valueType node and in case if node is of valueType, generates a branch to helper call\n+    * \n+    * @param node monent or monexit node\n+    * @param mergeLabel TR::LabelSymbol* to pointing to mergePoint in mainline\n+    * @param callLabel TR::LabelSymbol* pointing to the helper Call Label\n+    * @param cg CodeGenerator Object Ptr\n+    * @return TR::Register* If Given node required a runtime test to check for valueType, it will return the register containing J9Class of given object\n+    */\n+static TR::Register*\n+generateCheckForValueTypeMonitorEnterOrExit(TR::Node *node, TR::LabelSymbol* mergeLabel, TR::LabelSymbol *helperCallLabel, TR::CodeGenerator *cg)\n+   {\n+   TR::Register *objReg = cg->evaluate(node->getFirstChild());\n+   TR::Register *objectClassReg = cg->allocateRegister();\n+   TR::TreeEvaluator::genLoadForObjectHeadersMasked(cg, node, objectClassReg, generateS390MemoryReference(objReg, TR::Compiler->om.offsetOfObjectVftField(), cg), NULL);\n+   TR::Register *classFlagsRegister = cg->allocateRegister();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(cg->comp()->fe());\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, classFlagsRegister, generateS390MemoryReference(objectClassReg, static_cast<uint32_t>(fej9->getOffsetOfClassFlags()), cg));", "originalCommit": "194c9838319153c006f53f64cfd8db44d2a78ad5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwOTc4Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r417409786", "bodyText": "Fixed implementation to use Memory-Immediate test instruction instead of using an additional register to hold the class flags. Also updated the static_assert so that if we ever change J9ClassIsValueType to use other bit except withing second byte of classFlags, it will throw an assert.\nInstruction looks like following.\nTM @(objectClassReg+(offsetOf(classFlags)+2)), 0x4\nBRC COND_BRNZ, helperCall\n\nDelta: https://github.com/eclipse/openj9/compare/194c9838319153c006f53f64cfd8db44d2a78ad5..c64a354e89084e22019e97161f517bd09eace94a", "author": "r30shah", "createdAt": "2020-04-29T15:33:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg3NjA2Nw=="}], "type": "inlineReview"}, {"oid": "c64a354e89084e22019e97161f517bd09eace94a", "url": "https://github.com/eclipse-openj9/openj9/commit/c64a354e89084e22019e97161f517bd09eace94a", "message": "Supporting Changes for mon(ent/exit) for value Types\n\nAdd support for monitor enter/exit for value Types on IBM Z.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-04-28T23:35:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQxNTM3NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r417415374", "bodyText": "Formatting is a bit off here. I don't think we need to specify the types of the parameters as Doxygen automatically picks that up. There shouldn't be an \"If\" in the return value message because this register is always returned.", "author": "fjeremic", "createdAt": "2020-04-29T15:40:45Z", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6937,16 +6937,69 @@ J9::Z::TreeEvaluator::VMifInstanceOfEvaluator(TR::Node * node, TR::CodeGenerator\n    return NULL;\n    }\n \n+/**\n+    * Generates a quick runtime test for valueType node and in case if node is of valueType, generates a branch to helper call\n+    * \n+    * @param node monent or monexit node\n+    * @param mergeLabel TR::LabelSymbol* to pointing to mergePoint in mainline\n+    * @param callLabel TR::LabelSymbol* pointing to the helper Call Label\n+    * @param cg CodeGenerator Object Ptr\n+    * @return TR::Register* If Given node required a runtime test to check for valueType, it will return the register containing J9Class of given object\n+    */", "originalCommit": "c64a354e89084e22019e97161f517bd09eace94a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzNTc2OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r417435769", "bodyText": "This may be more on the personal preference but I'd consider adding some line breaks in between logical blocks of code. This entire function looks like one giant block of continuous code which may be hard to read. Just something to consider. I've gone ahead and improved the grammar in the comments and added line breaks to show what this function could look like:\nstatic TR::Register*\ngenerateCheckForValueTypeMonitorEnterOrExit(TR::Node *node, TR::LabelSymbol* mergeLabel, TR::LabelSymbol *helperCallLabel, TR::CodeGenerator *cg)\n   {\n   auto objReg = cg->evaluate(node->getFirstChild());\n   auto objectClassReg = cg->allocateRegister();\n\n   TR::TreeEvaluator::genLoadForObjectHeadersMasked(cg, node, objectClassReg, generateS390MemoryReference(objReg, TR::Compiler->om.offsetOfObjectVftField(), cg), NULL);\n\n   // Currently the value of J9ClassIsValueType flag maps to the second (low order) byte of the class flags field. To\n   // be able to use the TM instruction we need to ensure we safe guard against changes of this value since we have to\n   // hardcode the offset from the class flags field to reach the byte corresponding to the bit we want to test.\n   static_assert(static_cast<uint32_t>(J9ClassIsValueType & 0xFF00) == static_cast<uint32_t>(J9ClassIsValueType), \n      \"Expecting J9ClassIsValueType to be within second byte of classFlags\");\n   auto classFlagsMemRef = generateS390MemoryReference(objectClassReg, static_cast<uint32_t>(static_cast<TR_J9VMBase *>(cg->comp()->fe())->getOffsetOfClassFlags()) + 2, cg);\n   generateSIInstruction(cg, TR::InstOpCode::TM, node, classFlagsMemRef, J9ClassIsValueType >> 8);\n\n   const bool generateOOLSection = (helperCallLabel == NULL);\n   if (generateOOLSection)\n      {\n      helperCallLabel = generateLabelSymbol(cg);\n      }\n\n   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRNZ, node, helperCallLabel);\n\n   // TODO: There is now the possibility of three distinct OOL sections with helper calls to be generated when\n   // evaluating the TR::monent or TR::monexit nodes:\n   //\n   // 1. Monitor cache lookup OOL\n   // 2. Lock reservation OOL\n   // 3. Value types object OOL\n   //\n   // These distinct OOL sections may perform non-trivial logic but what they all have in common is they all have a\n   // call to the same JIT helper which acts as a fall back. This complexity exists because of the way the evaluators\n   // are currently architected and due to the restriction that we cannot have nested OOL code sections. Whenever\n   // making future changes to these evaluators we should consider refactoring them to reduce the complexity and\n   // attempt to consolidate the calls to the JIT helper so as to not have multiple copies.\n   if (generateOOLSection)\n      {\n      TR_S390OutOfLineCodeSection *helperCallOOLSection = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(helperCallLabel, mergeLabel, cg);\n      cg->getS390OutOfLineCodeSectionList().push_front(helperCallOOLSection);\n      helperCallOOLSection->swapInstructionListsWithCompilation();\n\n      auto cursor = generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, helperCallLabel);\n\n      TR_Debug *debugObj = cg->getDebug();\n      if (debugObj)\n         debugObj->addInstructionComment(cursor, \"Denotes Start of OOL for ValueType Node\");\n\n      cg->getLinkage(TR_CHelper)->buildDirectDispatch(node);\n      cursor = generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, mergeLabel);\n\n      if (debugObj)\n         debugObj->addInstructionComment(cursor, \"Denotes End of OOL for ValueType Node\");\n\n      helperCallOOLSection->swapInstructionListsWithCompilation();\n      }\n\n   return objectClassReg;\n   }\n\nDo you think it reads easier and the comments are improved?", "author": "fjeremic", "createdAt": "2020-04-29T16:09:14Z", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6937,16 +6937,69 @@ J9::Z::TreeEvaluator::VMifInstanceOfEvaluator(TR::Node * node, TR::CodeGenerator\n    return NULL;\n    }\n \n+/**\n+    * Generates a quick runtime test for valueType node and in case if node is of valueType, generates a branch to helper call\n+    * \n+    * @param node monent or monexit node\n+    * @param mergeLabel TR::LabelSymbol* to pointing to mergePoint in mainline\n+    * @param callLabel TR::LabelSymbol* pointing to the helper Call Label\n+    * @param cg CodeGenerator Object Ptr\n+    * @return TR::Register* If Given node required a runtime test to check for valueType, it will return the register containing J9Class of given object\n+    */\n+static TR::Register*\n+generateCheckForValueTypeMonitorEnterOrExit(TR::Node *node, TR::LabelSymbol* mergeLabel, TR::LabelSymbol *helperCallLabel, TR::CodeGenerator *cg)\n+   {\n+   TR::Register *objReg = cg->evaluate(node->getFirstChild());\n+   TR::Register *objectClassReg = cg->allocateRegister();\n+   TR::TreeEvaluator::genLoadForObjectHeadersMasked(cg, node, objectClassReg, generateS390MemoryReference(objReg, TR::Compiler->om.offsetOfObjectVftField(), cg), NULL);\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(cg->comp()->fe());\n+   bool generateOOLSection = helperCallLabel == NULL;\n+   if (generateOOLSection)\n+      helperCallLabel = generateLabelSymbol(cg);\n+   // Currently we have used a bit from the second byte in the 32-bit ClassFlags field for J9ClassIsValueType flag.\n+   // To use the memory to immediate test instruction, we are generating a memory reference which accesses the second byte in the ClassFlags field.\n+   static_assert(static_cast<uint32_t>(J9ClassIsValueType & 0xFF00) == static_cast<uint32_t>(J9ClassIsValueType), \"Expecting J9ClassIsValueType to be within second byte of classFlags\");\n+   TR::MemoryReference *classFlagsMemRef = generateS390MemoryReference(objectClassReg, static_cast<uint32_t>(fej9->getOffsetOfClassFlags()) + 2, cg);\n+   generateSIInstruction(cg, TR::InstOpCode::TM, node, classFlagsMemRef, J9ClassIsValueType >> 8);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRNZ, node, helperCallLabel);", "originalCommit": "c64a354e89084e22019e97161f517bd09eace94a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3OTAxNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r417479016", "bodyText": "Thanks @fjeremic  for the suggestion. Added more spaces and also used most of suggested changes in https://github.com/eclipse/openj9/compare/c64a354e89084e22019e97161f517bd09eace94a..95e8afe940942c7102d63af15e07e73d02cb8789", "author": "r30shah", "createdAt": "2020-04-29T17:15:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzNTc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ4NDU1Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r417484553", "bodyText": "The @return can be simplified as well.", "author": "fjeremic", "createdAt": "2020-04-29T17:24:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzNTc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUwNzEzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9326#discussion_r417507138", "bodyText": "Sorry, missed that, fixed it", "author": "r30shah", "createdAt": "2020-04-29T17:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzNTc2OQ=="}], "type": "inlineReview"}, {"oid": "95e8afe940942c7102d63af15e07e73d02cb8789", "url": "https://github.com/eclipse-openj9/openj9/commit/95e8afe940942c7102d63af15e07e73d02cb8789", "message": "Supporting Changes for mon(ent/exit) for value Types\n\nAdd support for monitor enter/exit for value Types on IBM Z.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-04-29T17:11:18Z", "type": "forcePushed"}, {"oid": "43de64cef4a422b07e3d23dd5da27ee8a1456fe5", "url": "https://github.com/eclipse-openj9/openj9/commit/43de64cef4a422b07e3d23dd5da27ee8a1456fe5", "message": "Supporting Changes for mon(ent/exit) for value Types\n\nAdd support for monitor enter/exit for value Types on IBM Z.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-04-29T17:57:41Z", "type": "forcePushed"}, {"oid": "c89e41e6063a07fe9f1366692c0f054769be7b4a", "url": "https://github.com/eclipse-openj9/openj9/commit/c89e41e6063a07fe9f1366692c0f054769be7b4a", "message": "Supporting Changes for mon(ent/exit) for value Types\n\nAdd support for monitor enter/exit for value Types on IBM Z.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-04-29T17:59:09Z", "type": "commit"}, {"oid": "c89e41e6063a07fe9f1366692c0f054769be7b4a", "url": "https://github.com/eclipse-openj9/openj9/commit/c89e41e6063a07fe9f1366692c0f054769be7b4a", "message": "Supporting Changes for mon(ent/exit) for value Types\n\nAdd support for monitor enter/exit for value Types on IBM Z.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-04-29T17:59:09Z", "type": "forcePushed"}]}