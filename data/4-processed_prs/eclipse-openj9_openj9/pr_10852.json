{"pr_number": 10852, "pr_title": "Ensure AOT Compilation in JIT Dump", "pr_createdAt": "2020-10-08T21:51:27Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10852", "timeline": [{"oid": "91041235eb35b6b7f6942730c2897fc5a9d25181", "url": "https://github.com/eclipse-openj9/openj9/commit/91041235eb35b6b7f6942730c2897fc5a9d25181", "message": "JITDump AOT Compile\n\nEnsure that if there is a crash during an AOT compilation, the JIT Dump\nperforms an AOT compilation as well.\n\nSigned-off-by: Irwin D'Souza <dsouzai.gh@gmail.com>", "committedDate": "2020-10-08T21:46:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzNzc5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10852#discussion_r502037794", "bodyText": "I should note, I don't think this will actually result in an AOT compilation; this is because the method is already in the SCC, so the control code will probably just try to do an AOT load. However, if the AOT compilation was also done in the current JVM, it would be nice to be able to log that compilation as well, though this would require keeping track of the methods that were AOT compiled by the current JVM.", "author": "dsouzai", "createdAt": "2020-10-08T22:02:58Z", "path": "runtime/compiler/control/JitDump.cpp", "diffHunk": "@@ -586,15 +586,29 @@ runJitdump(char *label, J9RASdumpContext *context, J9RASdumpAgent *agent)\n                if (!(jittedMethodsOnStack[i]._method))\n                   continue;\n \n+               bool isAOTBody = false;\n+               J9JITExceptionTable *metadata = NULL;\n+               void *startPC = jittedMethodsOnStack[i]._oldStartPC;\n+               if (startPC)\n+                  {\n+                  metadata = jitConfig->jitGetExceptionTableFromPC(crashedThread, (UDATA)startPC);\n+                  if (metadata)\n+                     {\n+                     TR_PersistentJittedBodyInfo *bodyInfo = (TR_PersistentJittedBodyInfo *)metadata->bodyInfo;\n+                     if (bodyInfo)\n+                        isAOTBody = bodyInfo->getIsAotedBody();\n+                     }\n+                  }\n+\n                TR_CompilationErrorCode compErrCode;\n                compErrCode = recompileMethodForLog(\n                   crashedThread,\n                   jittedMethodsOnStack[i]._method,\n                   compInfo,\n-                  frontendOfThread,\n                   jittedMethodsOnStack[i]._optLevel,\n                   false,\n-                  jittedMethodsOnStack[i]._oldStartPC,\n+                  isAOTBody,", "originalCommit": "91041235eb35b6b7f6942730c2897fc5a9d25181", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkzNDU5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10852#discussion_r504934592", "bodyText": "Will you add more code to bypass those AOT loads? Otherwise the current change does not achieve its intended effect.", "author": "mpirvu", "createdAt": "2020-10-14T19:54:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzNzc5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MDM3OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10852#discussion_r508770379", "bodyText": "I figured I would leave that for a future PR, since trying to do that in this PR might result in quite a big PR.", "author": "dsouzai", "createdAt": "2020-10-20T19:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzNzc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NDgzMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10852#discussion_r509374832", "bodyText": "How does this work for ordinary methods? Given an TR::IlGeneratorMethodDetails* instance how does one determine if an ordinary method is an AOT method compilation?", "author": "fjeremic", "createdAt": "2020-10-21T15:14:23Z", "path": "runtime/compiler/ilgen/J9IlGeneratorMethodDetails.hpp", "diffHunk": "@@ -105,6 +105,7 @@ class OMR_EXTENSIBLE IlGeneratorMethodDetails : public OMR::IlGeneratorMethodDet\n \n    virtual bool isOrdinaryMethod()     const { return true; }\n    virtual bool isJitDumpMethod()      const { return false; }\n+   virtual bool isJitDumpAOTMethod()   const { return false; }", "originalCommit": "91041235eb35b6b7f6942730c2897fc5a9d25181", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3ODIyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10852#discussion_r509378221", "bodyText": "For ordinary methods, the decision to AOT or not happens in preCompilationTasks; the type of frontend that's created is used to determine whether the method is AOT'd or not. The reason I needed to do this is because of all the control logic; if a method is already in the SCC or it hasn't been downgraded, we won't do any AOT compile. So this is just to bypass all of that and force the compilation to be an AOT compile.", "author": "dsouzai", "createdAt": "2020-10-21T15:18:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NDgzMg=="}], "type": "inlineReview"}]}