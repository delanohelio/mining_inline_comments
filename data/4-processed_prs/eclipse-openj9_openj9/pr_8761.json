{"pr_number": 8761, "pr_title": "Correct numberOfAnnotations in Runtime*Annotations", "pr_createdAt": "2020-03-05T21:02:47Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/8761", "timeline": [{"oid": "576be579059a29dd3bac890e25af6eb523444f13", "url": "https://github.com/eclipse-openj9/openj9/commit/576be579059a29dd3bac890e25af6eb523444f13", "message": "Runtime*Annotations malformat edge cases\n\nCurrently it is assumed that the length of a RuntimeVisibleAnnotation or RuntimeVisibleTypeAnnotation will be at least 2. This may not be the case for a malformatted annotation. Deal with the cases where the length is 0 or 1 and ensure that the error is properly handled.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-03-06T20:41:20Z", "type": "forcePushed"}, {"oid": "4a2b816ff465573ca986d94376219911fff67402", "url": "https://github.com/eclipse-openj9/openj9/commit/4a2b816ff465573ca986d94376219911fff67402", "message": "Runtime*Annotations malformed edge cases\n\nCurrently it is assumed that the length of a RuntimeVisibleAnnotation or RuntimeVisibleTypeAnnotation will be at least 2. This may not be the case for a malformed annotation. Deal with the cases where the length is 0 or 1 and ensure that the error is properly handled.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-03-06T20:42:50Z", "type": "forcePushed"}, {"oid": "40f6444ea75e2f276093071688a75db5cc76c559", "url": "https://github.com/eclipse-openj9/openj9/commit/40f6444ea75e2f276093071688a75db5cc76c559", "message": "Runtime*Annotations malformed edge cases\n\nCurrently it is assumed that the length of a RuntimeVisibleAnnotation or RuntimeVisibleTypeAnnotation will be at least 2. This may not be the case for a malformed annotation. Deal with the cases where the length is 0 or 1 and ensure that the error is properly handled.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-03-06T21:09:26Z", "type": "forcePushed"}, {"oid": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a", "url": "https://github.com/eclipse-openj9/openj9/commit/36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a", "message": "Runtime*Annotations malformed edge cases\n\nCurrently it is assumed that the length of a RuntimeVisibleAnnotation or RuntimeVisibleTypeAnnotation will be at least 2. This may not be the case for a malformed annotation. Deal with the cases where the length is 0 or 1 and ensure that the error is properly handled.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-03-09T19:19:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkzODM4OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r390938389", "bodyText": "What about the case where length == 1?  The code checks for > 1 here and handles 0 == length below - what happens to length == 1?", "author": "DanHeidinga", "createdAt": "2020-03-11T12:33:59Z", "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -418,33 +418,51 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t}\n \n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->annotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n \n-\t\t\tif (!ALLOC_ARRAY(annotations->annotations, annotations->numberOfAnnotations, J9CfrAnnotation))\n-\t\t\t{\n-\t\t\t\treturn BCT_ERR_OUT_OF_ROM;\n-\t\t\t}\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * Don't read a bogus numberOfAnnotations.\n+\t\t\t */\n+\t\t\tif (length > 1) {", "originalCommit": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEzMzA1Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r391133053", "bodyText": "Since a length of 1 is not long enough to have a valid numberOfAnnotations I wanted to skip the sections where numberOfAnnotations is set. Since this 1 byte is not being read the annotation will enter the error handling code since (index != end).\nI will add some additional comments to make this clear.", "author": "theresa-m", "createdAt": "2020-03-11T17:17:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkzODM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkzODYwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r390938608", "bodyText": "nitpick\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tif (!ALLOC_ARRAY(annotations->annotations, annotations->numberOfAnnotations, J9CfrAnnotation))\n          \n          \n            \n            \t\t\t\t{\n          \n          \n            \n            \t\t\t\tif (!ALLOC_ARRAY(annotations->annotations, annotations->numberOfAnnotations, J9CfrAnnotation)) {", "author": "DanHeidinga", "createdAt": "2020-03-11T12:34:26Z", "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -418,33 +418,51 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t}\n \n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->annotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n \n-\t\t\tif (!ALLOC_ARRAY(annotations->annotations, annotations->numberOfAnnotations, J9CfrAnnotation))\n-\t\t\t{\n-\t\t\t\treturn BCT_ERR_OUT_OF_ROM;\n-\t\t\t}\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * Don't read a bogus numberOfAnnotations.\n+\t\t\t */\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n \n-\t\t\tresult = readAnnotations(classfile, annotations->annotations, annotations->numberOfAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->annotations, annotations->numberOfAnnotations, J9CfrAnnotation))\n+\t\t\t\t{", "originalCommit": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0NzA3Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r390947073", "bodyText": "the lengths of 4 & 3 here aren't immediately obvious to me.  Is it the size of a the visible annotation + 1?", "author": "DanHeidinga", "createdAt": "2020-03-11T12:50:36Z", "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -655,24 +681,55 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* calculate the length needed to insert the illegal type_annotation.\n+\t\t\t\t * The minimum number of bytes needed is three for\n+\t\t\t\t * num_annotations and target_type\n+\t\t\t\t */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\t/* Treat one byte as part of the type_annotation to reach the correct index. */\n+\t\t\t\t\tannotations->rawDataLength = 4;\n+\t\t\t\t} else if (length < 3) {\n+\t\t\t\t\tannotations->rawDataLength = 3;", "originalCommit": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE0NTE3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r391145177", "bodyText": "num_annotations (2 bytes)\ntarget_type (1 byte)\nfollowed by any additional raw data.\n\nThe 4 length is the size of the illegal annotation + 1. The minimum required to create the annotation is 3.", "author": "theresa-m", "createdAt": "2020-03-11T17:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0NzA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk1MjI2Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r390952266", "bodyText": "It might be clearer to have a minimum number of byes required and take the max(min_required_bytes, length + 1)", "author": "DanHeidinga", "createdAt": "2020-03-11T13:00:24Z", "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -655,24 +681,55 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* calculate the length needed to insert the illegal type_annotation.\n+\t\t\t\t * The minimum number of bytes needed is three for\n+\t\t\t\t * num_annotations and target_type\n+\t\t\t\t */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\t/* Treat one byte as part of the type_annotation to reach the correct index. */\n+\t\t\t\t\tannotations->rawDataLength = 4;\n+\t\t\t\t} else if (length < 3) {\n+\t\t\t\t\tannotations->rawDataLength = 3;\n+\t\t\t\t} else {\n+\t\t\t\t\t/* Extra slot for illegal target_type */\n+\t\t\t\t\tannotations->rawDataLength = length + 1;", "originalCommit": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk1MjYyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r390952622", "bodyText": "Why = 1 here?", "author": "DanHeidinga", "createdAt": "2020-03-11T13:01:02Z", "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -655,24 +681,55 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* calculate the length needed to insert the illegal type_annotation.\n+\t\t\t\t * The minimum number of bytes needed is three for\n+\t\t\t\t * num_annotations and target_type\n+\t\t\t\t */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\t/* Treat one byte as part of the type_annotation to reach the correct index. */\n+\t\t\t\t\tannotations->rawDataLength = 4;\n+\t\t\t\t} else if (length < 3) {\n+\t\t\t\t\tannotations->rawDataLength = 3;\n+\t\t\t\t} else {\n+\t\t\t\t\t/* Extra slot for illegal target_type */\n+\t\t\t\t\tannotations->rawDataLength = length + 1;\n+\t\t\t\t}\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, annotations->rawDataLength, U_8)) {\n \t\t\t\t\treturn -2;\n \t\t\t\t}\n \t\t\t\tindex = attributeStart; /* rewind to the start of the attribute */\n-\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index); /* put in the num_annotations */\n-\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n-\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n-\t\t\t\t\t/* insert an error marker */\n-\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n-\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n-\t\t\t\t\tannotations->rawDataLength = length + 1;\n-\t\t\t\t} else { /* the attribute is already marked bad */\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n-\t\t\t\t\tannotations->rawDataLength = length;\n+\n+\t\t\t\t/* read num_annotations or set dummy if these bytes do not exist. */\n+\t\t\t\tif (length >= 2) {\n+\t\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index);\n+\t\t\t\t} else {\n+\t\t\t\t\tannotations->rawAttributeData[0] = 0;\n+\t\t\t\t\tannotations->rawAttributeData[1] = 1;", "originalCommit": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE1ODMxNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r391158316", "bodyText": "The 1 is there to show that there is 1 type_annotation here for the illegal annotation being created.", "author": "theresa-m", "createdAt": "2020-03-11T17:54:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk1MjYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE2OTk4NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r391169985", "bodyText": "I will add some additional comments to all of this.", "author": "theresa-m", "createdAt": "2020-03-11T18:14:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk1MjYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MDc1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r392280750", "bodyText": "Is this special case needed?  rawDataLength will be max(3, length+1).\nIf length is 1, then rawDataLength would be 3.  Does the minimumRawDataBytes need to be 4 to cover the +1 here?", "author": "DanHeidinga", "createdAt": "2020-03-13T14:58:50Z", "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -623,56 +642,102 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\treturn -2;\n \t\t\t}\n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleTypeAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->typeAnnotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n-\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation))\n-\t\t\t{\n-\t\t\t\treturn -2;\n-\t\t\t}\n-\t\t\ttypeAnnotations = annotations->typeAnnotations;\n-\t\t\t/*\n-\t\t\t * we are now at the start of the first type_annotation\n-\t\t\t * Silently ignore errors.\n+\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * There must be at least two bytes to have a valid numberOfAnnotations.\n+\t\t\t * Length of 0 will be treated as an error below. Length of 1 will be an error as well since the index\n+\t\t\t * will not match the end value.\n \t\t\t */\n-\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n-\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n-\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n-\t\t\t\t\tbreak;\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation)) {\n+\t\t\t\t\treturn -2;\n+\t\t\t\t}\n+\t\t\t\ttypeAnnotations = annotations->typeAnnotations;\n+\t\t\t\t/*\n+\t\t\t\t* we are now at the start of the first type_annotation\n+\t\t\t\t* Silently ignore errors.\n+\t\t\t\t*/\n+\t\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n+\t\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (BCT_ERR_OUT_OF_ROM == result) {\n \t\t\t\t/* Return out of memory error code to allocate larger buffer for classfile */\n \t\t\t\treturn result;\n-\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (index != end)) {\n-\t\t\t\tU_32 cursor = 0;\n+\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (0 == length) || (index != end)) {\n \t\t\t\t/*\n \t\t\t\t * give up parsing.\n \t\t\t\t * Copy the raw data, insert a bogus type_annotation,\n \t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field,\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n+\t\t\t\tU_32 cursor = 0;\n+\n+\t\t\t\t/* The minimum number of raw data bytes needed to create a bogus type_annotation is:\n+\t\t\t\t * num_annotations (2 bytes)\n+\t\t\t\t * target_type (1 byte)\n+\t\t\t\t */\n+\t\t\t\tconst U_32 minimumRawDataBytes = 3;\n+\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* use at least the minimum number of bytes, or add an extra slot for the illegal target_type */\n+\t\t\t\tannotations->rawDataLength = OMR_MAX(minimumRawDataBytes, length + 1);\n+\n+\t\t\t\t/* special case for length = 1. To ensure index is incremented correctly, \n+\t\t\t\t * add this extra byte to the end of the raw data array. */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\tannotations->rawDataLength++;", "originalCommit": "f6d3c25f5bc44314c577ebba23e70389f07c7c4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MjQwMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r392282400", "bodyText": "Reading the code below that writes to annotations->rawAttributeData[3] = 0;, min length here needs to be 4, not 3", "author": "DanHeidinga", "createdAt": "2020-03-13T15:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MDc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MzMzNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r392283337", "bodyText": "This is the case I'm most unsure of.  Maybe an example would help here? Or an assert that rawDataLength > 4, assuming that's the right condition", "author": "DanHeidinga", "createdAt": "2020-03-13T15:03:00Z", "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -623,56 +642,102 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\treturn -2;\n \t\t\t}\n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleTypeAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->typeAnnotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n-\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation))\n-\t\t\t{\n-\t\t\t\treturn -2;\n-\t\t\t}\n-\t\t\ttypeAnnotations = annotations->typeAnnotations;\n-\t\t\t/*\n-\t\t\t * we are now at the start of the first type_annotation\n-\t\t\t * Silently ignore errors.\n+\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * There must be at least two bytes to have a valid numberOfAnnotations.\n+\t\t\t * Length of 0 will be treated as an error below. Length of 1 will be an error as well since the index\n+\t\t\t * will not match the end value.\n \t\t\t */\n-\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n-\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n-\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n-\t\t\t\t\tbreak;\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation)) {\n+\t\t\t\t\treturn -2;\n+\t\t\t\t}\n+\t\t\t\ttypeAnnotations = annotations->typeAnnotations;\n+\t\t\t\t/*\n+\t\t\t\t* we are now at the start of the first type_annotation\n+\t\t\t\t* Silently ignore errors.\n+\t\t\t\t*/\n+\t\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n+\t\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (BCT_ERR_OUT_OF_ROM == result) {\n \t\t\t\t/* Return out of memory error code to allocate larger buffer for classfile */\n \t\t\t\treturn result;\n-\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (index != end)) {\n-\t\t\t\tU_32 cursor = 0;\n+\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (0 == length) || (index != end)) {\n \t\t\t\t/*\n \t\t\t\t * give up parsing.\n \t\t\t\t * Copy the raw data, insert a bogus type_annotation,\n \t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field,\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n+\t\t\t\tU_32 cursor = 0;\n+\n+\t\t\t\t/* The minimum number of raw data bytes needed to create a bogus type_annotation is:\n+\t\t\t\t * num_annotations (2 bytes)\n+\t\t\t\t * target_type (1 byte)\n+\t\t\t\t */\n+\t\t\t\tconst U_32 minimumRawDataBytes = 3;\n+\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* use at least the minimum number of bytes, or add an extra slot for the illegal target_type */\n+\t\t\t\tannotations->rawDataLength = OMR_MAX(minimumRawDataBytes, length + 1);\n+\n+\t\t\t\t/* special case for length = 1. To ensure index is incremented correctly, \n+\t\t\t\t * add this extra byte to the end of the raw data array. */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\tannotations->rawDataLength++;\n+\t\t\t\t}\n+\n+\t\t\t\t/* create raw data array. */\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, annotations->rawDataLength, U_8)) {\n \t\t\t\t\treturn -2;\n \t\t\t\t}\n \t\t\t\tindex = attributeStart; /* rewind to the start of the attribute */\n-\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index); /* put in the num_annotations */\n-\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n-\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n-\t\t\t\t\t/* insert an error marker */\n-\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n-\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n-\t\t\t\t\tannotations->rawDataLength = length + 1;\n-\t\t\t\t} else { /* the attribute is already marked bad */\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n-\t\t\t\t\tannotations->rawDataLength = length;\n+\n+\t\t\t\t/* read num_annotations or set dummy if these bytes do not exist. */\n+\t\t\t\tif (length >= 2) {\n+\t\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index);\n+\t\t\t\t} else {\n+\t\t\t\t\t/* there should be at least one type_annotation here for the illegal \n+\t\t\t\t\t * entry that is being created. */\n+\t\t\t\t\tannotations->rawAttributeData[0] = 0;\n+\t\t\t\t\tannotations->rawAttributeData[1] = 1;\n \t\t\t\t}\n-\t\t\t\tfor (cursor = 4; cursor < annotations->rawDataLength; ++cursor) {\n-\t\t\t\t\tCHECK_EOF(1);\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[cursor], index);\n+\n+\t\t\t\t/* set illegal target_type followed by raw data */\n+\t\t\t\tif (minimumRawDataBytes == annotations->rawDataLength) { /* final slot is reserved for illegal target_type */\n+\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\t\t\t\t} else {\n+\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n+\n+\t\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n+\t\t\t\t\t\t/* insert an error marker */\n+\t\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n+\t\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\t\t\t\t\t} else { /* the attribute is already marked bad */\n+\t\t\t\t\t\tannotations->rawAttributeData[3] = 0;\n+\t\t\t\t\t\tif (index != end) {\n+\t\t\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tannotations->rawDataLength = length - 1; /* won't be using the extra slot */", "originalCommit": "f6d3c25f5bc44314c577ebba23e70389f07c7c4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0f972102e1b6b8328662691d099d9b85bf4adf3e", "url": "https://github.com/eclipse-openj9/openj9/commit/0f972102e1b6b8328662691d099d9b85bf4adf3e", "message": "Additional comments and clean up\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-03-13T21:21:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk4NjQyNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r392986425", "bodyText": "We've tried to use -- and ++ less in the code base outside of for /  while loops\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\tannotations->rawDataLength--;\n          \n          \n            \n            \t\t\t\t\tannotations->rawDataLength -= 1;", "author": "DanHeidinga", "createdAt": "2020-03-16T12:33:06Z", "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -623,56 +642,106 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\treturn -2;\n \t\t\t}\n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleTypeAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->typeAnnotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n-\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation))\n-\t\t\t{\n-\t\t\t\treturn -2;\n-\t\t\t}\n-\t\t\ttypeAnnotations = annotations->typeAnnotations;\n-\t\t\t/*\n-\t\t\t * we are now at the start of the first type_annotation\n-\t\t\t * Silently ignore errors.\n+\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * There must be at least two bytes to have a valid numberOfAnnotations.\n+\t\t\t * Length of 0 will be treated as an error below. Length of 1 will be an error as well since the index\n+\t\t\t * will not match the end value.\n \t\t\t */\n-\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n-\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n-\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n-\t\t\t\t\tbreak;\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation)) {\n+\t\t\t\t\treturn -2;\n+\t\t\t\t}\n+\t\t\t\ttypeAnnotations = annotations->typeAnnotations;\n+\t\t\t\t/*\n+\t\t\t\t* we are now at the start of the first type_annotation\n+\t\t\t\t* Silently ignore errors.\n+\t\t\t\t*/\n+\t\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n+\t\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (BCT_ERR_OUT_OF_ROM == result) {\n \t\t\t\t/* Return out of memory error code to allocate larger buffer for classfile */\n \t\t\t\treturn result;\n-\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (index != end)) {\n-\t\t\t\tU_32 cursor = 0;\n+\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (0 == length) || (index != end)) {\n \t\t\t\t/*\n-\t\t\t\t * give up parsing.\n+\t\t\t\t * Give up parsing.\n+\t\t\t\t * \n \t\t\t\t * Copy the raw data, insert a bogus type_annotation,\n-\t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field,\n-\t\t\t\t * to indicate that the attribute is malformed.\n+\t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field\n+\t\t\t\t * to indicate that the attribute is malformed. The remaining raw data should follow\n+\t\t\t\t * the illegal target_type.\n+\t\t\t\t * \n+\t\t\t\t * The minimum number of raw data bytes needed to create a bogus type_annotation is:\n+\t\t\t\t * num_annotations (2 bytes)\n+\t\t\t\t * target_type (1 byte)\n+\t\t\t\t * extra raw data (at least 1 byte)\n+\t\t\t\t * \n+\t\t\t\t * Length will be adjusted during rawAttributeData assignment if it is determined that \n+\t\t\t\t * an extra slot is not needed.\n \t\t\t\t */\n+\t\t\t\tconst U_32 minimumRawDataBytes = 4;\n+\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\tannotations->rawDataLength = OMR_MAX(minimumRawDataBytes, length + 1);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, annotations->rawDataLength, U_8)) {\n \t\t\t\t\treturn -2;\n \t\t\t\t}\n \t\t\t\tindex = attributeStart; /* rewind to the start of the attribute */\n-\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index); /* put in the num_annotations */\n-\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n-\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n-\t\t\t\t\t/* insert an error marker */\n-\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n-\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n-\t\t\t\t\tannotations->rawDataLength = length + 1;\n-\t\t\t\t} else { /* the attribute is already marked bad */\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n-\t\t\t\t\tannotations->rawDataLength = length;\n+\n+\t\t\t\t/* read num_annotations or set dummy if these bytes do not exist. */\n+\t\t\t\tif (length >= 2) {\n+\t\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index);\n+\t\t\t\t} else {\n+\t\t\t\t\t/* there should be at least one type_annotation here for the illegal \n+\t\t\t\t\t * entry that is being created. */\n+\t\t\t\t\tannotations->rawAttributeData[0] = 0;\n+\t\t\t\t\tannotations->rawAttributeData[1] = 1;\n \t\t\t\t}\n-\t\t\t\tfor (cursor = 4; cursor < annotations->rawDataLength; ++cursor) {\n-\t\t\t\t\tCHECK_EOF(1);\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[cursor], index);\n+\n+\t\t\t\t/* Insert illegal target_type followed by remaining raw data. */\n+\t\t\t\tif (index == end) {\n+\t\t\t\t\t/* There is no remaining raw data. */\n+\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\n+\t\t\t\t\t/* Adjust rawDataLength since there was no need to insert an extra byte. */\n+\t\t\t\t\tannotations->rawDataLength--;", "originalCommit": "0f972102e1b6b8328662691d099d9b85bf4adf3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk4NzcyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r392987721", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t} else { /* the attribute is already marked bad */\n          \n          \n            \n            \t\t\t\t\t\t/* Adjust rawDataLength since there was no need to insert an extra byte. */\n          \n          \n            \n            \t\t\t\t\t} else { \n          \n          \n            \n            \t\t\t\t\t\t/* The attribute is already marked bad.\n          \n          \n            \n            \t\t\t\t\t\t * Adjust rawDataLength since there was no need to insert an extra byte.\n          \n          \n            \n            \t\t\t\t\t\t */", "author": "DanHeidinga", "createdAt": "2020-03-16T12:34:38Z", "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -623,56 +642,106 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\treturn -2;\n \t\t\t}\n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleTypeAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->typeAnnotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n-\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation))\n-\t\t\t{\n-\t\t\t\treturn -2;\n-\t\t\t}\n-\t\t\ttypeAnnotations = annotations->typeAnnotations;\n-\t\t\t/*\n-\t\t\t * we are now at the start of the first type_annotation\n-\t\t\t * Silently ignore errors.\n+\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * There must be at least two bytes to have a valid numberOfAnnotations.\n+\t\t\t * Length of 0 will be treated as an error below. Length of 1 will be an error as well since the index\n+\t\t\t * will not match the end value.\n \t\t\t */\n-\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n-\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n-\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n-\t\t\t\t\tbreak;\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation)) {\n+\t\t\t\t\treturn -2;\n+\t\t\t\t}\n+\t\t\t\ttypeAnnotations = annotations->typeAnnotations;\n+\t\t\t\t/*\n+\t\t\t\t* we are now at the start of the first type_annotation\n+\t\t\t\t* Silently ignore errors.\n+\t\t\t\t*/\n+\t\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n+\t\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (BCT_ERR_OUT_OF_ROM == result) {\n \t\t\t\t/* Return out of memory error code to allocate larger buffer for classfile */\n \t\t\t\treturn result;\n-\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (index != end)) {\n-\t\t\t\tU_32 cursor = 0;\n+\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (0 == length) || (index != end)) {\n \t\t\t\t/*\n-\t\t\t\t * give up parsing.\n+\t\t\t\t * Give up parsing.\n+\t\t\t\t * \n \t\t\t\t * Copy the raw data, insert a bogus type_annotation,\n-\t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field,\n-\t\t\t\t * to indicate that the attribute is malformed.\n+\t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field\n+\t\t\t\t * to indicate that the attribute is malformed. The remaining raw data should follow\n+\t\t\t\t * the illegal target_type.\n+\t\t\t\t * \n+\t\t\t\t * The minimum number of raw data bytes needed to create a bogus type_annotation is:\n+\t\t\t\t * num_annotations (2 bytes)\n+\t\t\t\t * target_type (1 byte)\n+\t\t\t\t * extra raw data (at least 1 byte)\n+\t\t\t\t * \n+\t\t\t\t * Length will be adjusted during rawAttributeData assignment if it is determined that \n+\t\t\t\t * an extra slot is not needed.\n \t\t\t\t */\n+\t\t\t\tconst U_32 minimumRawDataBytes = 4;\n+\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\tannotations->rawDataLength = OMR_MAX(minimumRawDataBytes, length + 1);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, annotations->rawDataLength, U_8)) {\n \t\t\t\t\treturn -2;\n \t\t\t\t}\n \t\t\t\tindex = attributeStart; /* rewind to the start of the attribute */\n-\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index); /* put in the num_annotations */\n-\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n-\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n-\t\t\t\t\t/* insert an error marker */\n-\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n-\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n-\t\t\t\t\tannotations->rawDataLength = length + 1;\n-\t\t\t\t} else { /* the attribute is already marked bad */\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n-\t\t\t\t\tannotations->rawDataLength = length;\n+\n+\t\t\t\t/* read num_annotations or set dummy if these bytes do not exist. */\n+\t\t\t\tif (length >= 2) {\n+\t\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index);\n+\t\t\t\t} else {\n+\t\t\t\t\t/* there should be at least one type_annotation here for the illegal \n+\t\t\t\t\t * entry that is being created. */\n+\t\t\t\t\tannotations->rawAttributeData[0] = 0;\n+\t\t\t\t\tannotations->rawAttributeData[1] = 1;\n \t\t\t\t}\n-\t\t\t\tfor (cursor = 4; cursor < annotations->rawDataLength; ++cursor) {\n-\t\t\t\t\tCHECK_EOF(1);\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[cursor], index);\n+\n+\t\t\t\t/* Insert illegal target_type followed by remaining raw data. */\n+\t\t\t\tif (index == end) {\n+\t\t\t\t\t/* There is no remaining raw data. */\n+\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\n+\t\t\t\t\t/* Adjust rawDataLength since there was no need to insert an extra byte. */\n+\t\t\t\t\tannotations->rawDataLength--;\n+\t\t\t\t} else {\n+\t\t\t\t\t/* cursor is the starting point in raw data array to write remaining raw data. */\n+\t\t\t\t\tU_32 cursor = 0;\n+\n+\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n+\n+\t\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n+\t\t\t\t\t\t/* insert an error marker */\n+\t\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n+\t\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\t\t\t\t\t\tcursor = 4;\n+\t\t\t\t\t} else { /* the attribute is already marked bad */\n+\t\t\t\t\t\t/* Adjust rawDataLength since there was no need to insert an extra byte. */", "originalCommit": "0f972102e1b6b8328662691d099d9b85bf4adf3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk4Nzk1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r392987950", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\tannotations->rawDataLength--;\n          \n          \n            \n            \t\t\t\t\t\tannotations->rawDataLength -= 1;", "author": "DanHeidinga", "createdAt": "2020-03-16T12:34:54Z", "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -623,56 +642,106 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\treturn -2;\n \t\t\t}\n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleTypeAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->typeAnnotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n-\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation))\n-\t\t\t{\n-\t\t\t\treturn -2;\n-\t\t\t}\n-\t\t\ttypeAnnotations = annotations->typeAnnotations;\n-\t\t\t/*\n-\t\t\t * we are now at the start of the first type_annotation\n-\t\t\t * Silently ignore errors.\n+\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * There must be at least two bytes to have a valid numberOfAnnotations.\n+\t\t\t * Length of 0 will be treated as an error below. Length of 1 will be an error as well since the index\n+\t\t\t * will not match the end value.\n \t\t\t */\n-\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n-\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n-\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n-\t\t\t\t\tbreak;\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation)) {\n+\t\t\t\t\treturn -2;\n+\t\t\t\t}\n+\t\t\t\ttypeAnnotations = annotations->typeAnnotations;\n+\t\t\t\t/*\n+\t\t\t\t* we are now at the start of the first type_annotation\n+\t\t\t\t* Silently ignore errors.\n+\t\t\t\t*/\n+\t\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n+\t\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (BCT_ERR_OUT_OF_ROM == result) {\n \t\t\t\t/* Return out of memory error code to allocate larger buffer for classfile */\n \t\t\t\treturn result;\n-\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (index != end)) {\n-\t\t\t\tU_32 cursor = 0;\n+\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (0 == length) || (index != end)) {\n \t\t\t\t/*\n-\t\t\t\t * give up parsing.\n+\t\t\t\t * Give up parsing.\n+\t\t\t\t * \n \t\t\t\t * Copy the raw data, insert a bogus type_annotation,\n-\t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field,\n-\t\t\t\t * to indicate that the attribute is malformed.\n+\t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field\n+\t\t\t\t * to indicate that the attribute is malformed. The remaining raw data should follow\n+\t\t\t\t * the illegal target_type.\n+\t\t\t\t * \n+\t\t\t\t * The minimum number of raw data bytes needed to create a bogus type_annotation is:\n+\t\t\t\t * num_annotations (2 bytes)\n+\t\t\t\t * target_type (1 byte)\n+\t\t\t\t * extra raw data (at least 1 byte)\n+\t\t\t\t * \n+\t\t\t\t * Length will be adjusted during rawAttributeData assignment if it is determined that \n+\t\t\t\t * an extra slot is not needed.\n \t\t\t\t */\n+\t\t\t\tconst U_32 minimumRawDataBytes = 4;\n+\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\tannotations->rawDataLength = OMR_MAX(minimumRawDataBytes, length + 1);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, annotations->rawDataLength, U_8)) {\n \t\t\t\t\treturn -2;\n \t\t\t\t}\n \t\t\t\tindex = attributeStart; /* rewind to the start of the attribute */\n-\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index); /* put in the num_annotations */\n-\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n-\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n-\t\t\t\t\t/* insert an error marker */\n-\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n-\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n-\t\t\t\t\tannotations->rawDataLength = length + 1;\n-\t\t\t\t} else { /* the attribute is already marked bad */\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n-\t\t\t\t\tannotations->rawDataLength = length;\n+\n+\t\t\t\t/* read num_annotations or set dummy if these bytes do not exist. */\n+\t\t\t\tif (length >= 2) {\n+\t\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index);\n+\t\t\t\t} else {\n+\t\t\t\t\t/* there should be at least one type_annotation here for the illegal \n+\t\t\t\t\t * entry that is being created. */\n+\t\t\t\t\tannotations->rawAttributeData[0] = 0;\n+\t\t\t\t\tannotations->rawAttributeData[1] = 1;\n \t\t\t\t}\n-\t\t\t\tfor (cursor = 4; cursor < annotations->rawDataLength; ++cursor) {\n-\t\t\t\t\tCHECK_EOF(1);\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[cursor], index);\n+\n+\t\t\t\t/* Insert illegal target_type followed by remaining raw data. */\n+\t\t\t\tif (index == end) {\n+\t\t\t\t\t/* There is no remaining raw data. */\n+\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\n+\t\t\t\t\t/* Adjust rawDataLength since there was no need to insert an extra byte. */\n+\t\t\t\t\tannotations->rawDataLength--;\n+\t\t\t\t} else {\n+\t\t\t\t\t/* cursor is the starting point in raw data array to write remaining raw data. */\n+\t\t\t\t\tU_32 cursor = 0;\n+\n+\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n+\n+\t\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n+\t\t\t\t\t\t/* insert an error marker */\n+\t\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n+\t\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\t\t\t\t\t\tcursor = 4;\n+\t\t\t\t\t} else { /* the attribute is already marked bad */\n+\t\t\t\t\t\t/* Adjust rawDataLength since there was no need to insert an extra byte. */\n+\t\t\t\t\t\tannotations->rawDataLength--;", "originalCommit": "0f972102e1b6b8328662691d099d9b85bf4adf3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8fa94fc7c0d95fc813f032fd4528773cac80817e", "url": "https://github.com/eclipse-openj9/openj9/commit/8fa94fc7c0d95fc813f032fd4528773cac80817e", "message": "Runtime*Annotations malformed edge cases\n\nCurrently it is assumed that the length of a RuntimeVisibleAnnotation or RuntimeVisibleTypeAnnotation will be at least 2. This may not be the case for a malformed annotation. Deal with the cases where the length is 0 or 1 and ensure that the error is properly handled.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-03-16T14:07:39Z", "type": "commit"}, {"oid": "8fa94fc7c0d95fc813f032fd4528773cac80817e", "url": "https://github.com/eclipse-openj9/openj9/commit/8fa94fc7c0d95fc813f032fd4528773cac80817e", "message": "Runtime*Annotations malformed edge cases\n\nCurrently it is assumed that the length of a RuntimeVisibleAnnotation or RuntimeVisibleTypeAnnotation will be at least 2. This may not be the case for a malformed annotation. Deal with the cases where the length is 0 or 1 and ensure that the error is properly handled.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-03-16T14:07:39Z", "type": "forcePushed"}]}