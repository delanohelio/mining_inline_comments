{"pr_number": 11507, "pr_title": "Add extra U_64 data field to Indexable Object Headers", "pr_createdAt": "2020-12-17T17:58:10Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/11507", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5MTU1Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r545291553", "bodyText": "@dchopra001  This is the update you suggested me, please let me know if this change will be part of #11320 so I can remove it from here", "author": "bragaigor", "createdAt": "2020-12-17T18:00:48Z", "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -1374,8 +1374,7 @@ TR::Register *J9::X86::TreeEvaluator::multianewArrayEvaluator(TR::Node *node, TR\n       }\n \n    // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n-   generateRegRegInstruction(MOVRegReg(),  node, temp2Reg, firstDimLenReg, cg);\n-   generateRegImmInstruction(SHLRegImm1(), node, temp2Reg, 4, cg);\n+   generateRegRegImmInstruction(IMulRegRegImms(4), node, temp2Reg, firstDimLenReg, zeroArraySize, cg);", "originalCommit": "88db5cbaa77b9ce36907fc7d8ddf0a7734ec4d9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg3NTI0OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r545875248", "bodyText": "The change will be part of the above mentioned PR (and I've ported an equivalent fix to Z as well). So you can remove it from here. Thanks!", "author": "dchopra001", "createdAt": "2020-12-18T14:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5MTU1Mw=="}], "type": "inlineReview"}, {"oid": "919fd3044121cdbaa4de02bc341d9da3a0859131", "url": "https://github.com/eclipse-openj9/openj9/commit/919fd3044121cdbaa4de02bc341d9da3a0859131", "message": "Add extra U_64 data field to Indexable Object Headers\n\nPreliminary work to incorporate extra 64 bit field to\nIndexable object headers. In case of contiguous arraylets\nthe extra field will hold the address of where the data\nstarts, which is right after the header. In case of\ndiscontiguous arraylets the extra field will hold the\naddress of:\n\n- The contiguous double mapped region (assuming double map\n  is enabled).\n- The contiguous sparse-heap region outside the heap (assuming\n  sparse heap is enabled).\n- If double mapping an sparse heap are both disabled, dataAddr\n  will point to the address right adter the header, in this\n  case to the first arrayoid.\n\nThis is the first phase concerning a series of deliverables.\nHere, we introduce the extra U_64 data field along with helper\nfunctions such as getters and setters that will be needed in\nthe future. Now dataAddr is only introduced and never used.\nOnce it\u2019s stable we\u2019ll deliver the second phase of changes\nthat makes use of dataAddr.\n\nPlease refer to https://github.com/eclipse/openj9/issues/11438\nfor more info. This set of changes concern part of the first\naction item of such issue.\n\nSigned-off-by: Igor Braga <higorb1@gmail.com>", "committedDate": "2020-12-19T17:00:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcyNjQ1Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r546726457", "bodyText": "minor difference, but you can just pass dataAddr value, instead of passing headerSize and header", "author": "amicic", "createdAt": "2020-12-21T14:11:08Z", "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -58,6 +58,67 @@ class MM_ObjectAllocationAPI\n \tconst J9VMGCSizeClasses *_sizeClasses;\n #endif /* J9VM_GC_SEGREGATED_HEAP */\n \n+\tVMINLINE void\n+\tinitializeIndexableSlots(bool initializeSlots, UDATA dataSize, UDATA headerSize, J9IndexableObject *header)", "originalCommit": "919fd3044121cdbaa4de02bc341d9da3a0859131", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcyODIyOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r546728228", "bodyText": "i'd call it  J9_GC_INDEXABLE_DATA_FIELD_SIZE and define it as sizeof(U_64)", "author": "amicic", "createdAt": "2020-12-21T14:14:28Z", "path": "runtime/oti/j9consts.h", "diffHunk": "@@ -458,6 +458,8 @@ extern \"C\" {\n \n #define J9_GC_MINIMUM_OBJECT_SIZE 0x10\n #if defined(J9VM_ENV_DATA64)\n+#define J9_GC_EXTRA_DATA_FIELD_SIZE 0x08", "originalCommit": "919fd3044121cdbaa4de02bc341d9da3a0859131", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjczMDg5Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r546730893", "bodyText": "You could share the code for setter and getter.... have dataAddrSlotForContiguous() (and one for Discontiguous) that will give you address of the dataAddr Slot, and then setter and getter just de-references the address.", "author": "amicic", "createdAt": "2020-12-21T14:19:12Z", "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,143 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\t/**\n+\t * Sets data pointer of a contiguous indexable object.\n+\t * Sets the data pointer of a contiguous indexable object; in this case\n+\t * dataAddr will point directly into the data right after dataAddr field\n+\t * (data resides in heap).\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 address = (U_64)((UDATA)arrayPtr + contiguousHeaderSize());\n+\n+\t\tif (compressed) {\n+\t\t\t((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr = address;\n+\t\t} else {\n+\t\t\t((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr = address;\n+\t\t}", "originalCommit": "919fd3044121cdbaa4de02bc341d9da3a0859131", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5NDUzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r546794538", "bodyText": "True, were you thinking something along these lines?", "author": "bragaigor", "createdAt": "2020-12-21T16:12:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjczMDg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM4NDI3OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551384279", "bodyText": "Remove extra space", "author": "bragaigor", "createdAt": "2021-01-04T15:26:42Z", "path": "runtime/oti/j9consts.h", "diffHunk": "@@ -458,6 +458,8 @@ extern \"C\" {\n \n #define J9_GC_MINIMUM_OBJECT_SIZE 0x10\n #if defined(J9VM_ENV_DATA64)\n+#define  J9_GC_INDEXABLE_DATA_FIELD_SIZE sizeof(U_64)", "originalCommit": "686aacd36aaa6f47396d5ff1a2dd5eecc58df281", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2MTI4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551561288", "bodyText": "Is the cast needed here?", "author": "fjeremic", "createdAt": "2021-01-04T20:50:40Z", "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -7040,10 +7040,20 @@ static bool genZeroInitObject2(\n    auto headerSize = isArrayNew ? TR::Compiler->om.contiguousArrayHeaderSizeInBytes() : TR::Compiler->om.objectHeaderSizeInBytes();\n    // If we are using full refs both contiguous and discontiguous array header have the same size, in which case we must adjust header size\n    // slightly so that rep stosb can initialize the size field of zero sized arrays appropriately\n-   if (!cg->comp()->target().is32Bit() && !TR::Compiler->om.compressObjectReferences() && isArrayNew)\n+   //   #bits per section (compressed refs): | 32 bits |  32 bits   | 32 bits | 32 bits |   32 bits   |   32 bits    |\n+   //   zero sized arrays:                   |  class  | mustBeZero |   size  | padding |          dataAddr          |\n+   //   smallest contiguous array:           |  class  |    size    |      dataAddr     | 1 byte + padding |  other  |\n+   //   In order for us to successfully initialize the size field of a zero sized array in compressed refs\n+   //   we must subtract 8 bytes (sizeof(dataAddr)) from header size. And in case of full refs we must\n+   //   subtract 16 bytes from the header in order to properly initialize the zero sized field. We can\n+   //   accomplish that by simply subtracting the offset of dataAddr field, which is 8 for compressed refs\n+   //   and 16 for full refs.\n+#if defined(TR_TARGET_64BIT)\n+   if (!cg->comp()->target().is32Bit() && isArrayNew)\n       {\n-      headerSize -= 8;\n+      headerSize -= ((TR_J9VMBase *)(cg->fe()))->getOffsetOfContiguousDataAddrField();", "originalCommit": "686aacd36aaa6f47396d5ff1a2dd5eecc58df281", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2OTgxNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551569817", "bodyText": "Yes, we get a \"no member named \u2018getOffsetOfContiguousDataAddrField\u2019 in class TR_FrontEnd\" error if we don't cast it to TR_J9VMBase *", "author": "bragaigor", "createdAt": "2021-01-04T21:08:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2MTI4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4MjIyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551582226", "bodyText": "Oh I see, I saw the parenthesis in the wrong place. I thought we were casting whatever getOffsetOfContiguousDataAddrField returned to TR_J9VMBase *. A change I would like to see made is to make use of static_cast here instead of a C style cast as the C++ variant is type safe.", "author": "fjeremic", "createdAt": "2021-01-04T21:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2MTI4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4Mzg0Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551583847", "bodyText": "Sounds good!", "author": "bragaigor", "createdAt": "2021-01-04T21:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2MTI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY5MzYyMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551693623", "bodyText": "Brackets please.", "author": "gacholio", "createdAt": "2021-01-05T03:14:00Z", "path": "runtime/oti/j9consts.h", "diffHunk": "@@ -458,6 +458,8 @@ extern \"C\" {\n \n #define J9_GC_MINIMUM_OBJECT_SIZE 0x10\n #if defined(J9VM_ENV_DATA64)\n+#define J9_GC_INDEXABLE_DATA_FIELD_SIZE sizeof(U_64)\n+#define J9_GC_MINIMUM_INDEXABLE_OBJECT_SIZE J9_GC_MINIMUM_OBJECT_SIZE +  J9_GC_INDEXABLE_DATA_FIELD_SIZE", "originalCommit": "bf05e0c03e97f6d93ac00e6811977596546d22ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAwMTk1Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552001952", "bodyText": "nit: please also lose the extra space after +", "author": "keithc-ca", "createdAt": "2021-01-05T15:25:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY5MzYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4MzA4MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551983080", "bodyText": "The header file says these functions return uintptr_t. Please be consistent.", "author": "keithc-ca", "createdAt": "2021-01-05T14:56:35Z", "path": "runtime/compiler/env/VMJ9.cpp", "diffHunk": "@@ -1024,6 +1024,10 @@ UDATA TR_J9VMBase::getOffsetOfBackfillOffsetField()                 {return offs\n \n UDATA TR_J9VMBase::getOffsetOfContiguousArraySizeField()            {return TR::Compiler->om.offsetOfContiguousArraySizeField();}\n UDATA TR_J9VMBase::getOffsetOfDiscontiguousArraySizeField()         {return TR::Compiler->om.offsetOfDiscontiguousArraySizeField();}\n+#if defined(TR_TARGET_64BIT)\n+UDATA TR_J9VMBase::getOffsetOfContiguousDataAddrField()             {return TR::Compiler->om.offsetOfContiguousDataAddrField();}\n+UDATA TR_J9VMBase::getOffsetOfDiscontiguousDataAddrField()          {return TR::Compiler->om.offsetOfDiscontiguousDataAddrField();}", "originalCommit": "bf05e0c03e97f6d93ac00e6811977596546d22ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxNDgyNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552014824", "bodyText": "You're right, I tried to be consistent with the other method usages as they have uintptr_t in the header file and UDATA here. Should I update this to use uintptr_t instead?", "author": "bragaigor", "createdAt": "2021-01-05T15:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4MzA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyNDExNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552024114", "bodyText": "In GC code, the preference seems to be in favour of standard types (e.g. uintptr_t).", "author": "keithc-ca", "createdAt": "2021-01-05T15:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4MzA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4NjYzNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551986637", "bodyText": "This this use AssertDiscontiguousArrayletLayout?", "author": "keithc-ca", "createdAt": "2021-01-05T15:02:14Z", "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,161 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\n+\t/**\n+\t * Gets data pointer of a contiguous indexable object.\n+\t * Helper to get dataAddr field of contiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 *address = NULL;\n+\t\tif (compressed) {\n+\t\t\taddress = &((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\taddress = &((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn address;\n+\t}\n+\n+\t/**\n+\t * Gets data pointer of a discontiguous indexable object.\n+\t * Helper to get dataAddr field of discontiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to discontiguous indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForDiscontiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.", "originalCommit": "bf05e0c03e97f6d93ac00e6811977596546d22ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyMDcwMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552020700", "bodyText": "For now we only use AssertDiscontiguousArrayletLayout in getDataAddrForDiscontiguous, because setDataAddrForDiscontiguous will also be setting dataAddr field for hybrid arraylets and AssertDiscontiguousArrayletLayout only asserts if they're strictly Discontiguous. The reason for that is that we made the assumption that getDataAddrForDiscontiguous(J9IndexableObject *arrayPtr) would only be used in case of pure disncotiguous arraylets (double mapping case or future off-heap technology)", "author": "bragaigor", "createdAt": "2021-01-05T15:53:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4NjYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyNTgyNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552025824", "bodyText": "It just struck me as inconsistent to assert in dataAddrSlotForContiguous, but not dataAddrSlotForDiscontiguous.", "author": "keithc-ca", "createdAt": "2021-01-05T16:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4NjYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4NzAzNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551987034", "bodyText": "I think the first cast is redundant.", "author": "keithc-ca", "createdAt": "2021-01-05T15:02:51Z", "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,161 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\n+\t/**\n+\t * Gets data pointer of a contiguous indexable object.\n+\t * Helper to get dataAddr field of contiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 *address = NULL;\n+\t\tif (compressed) {\n+\t\t\taddress = &((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\taddress = &((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn address;\n+\t}\n+\n+\t/**\n+\t * Gets data pointer of a discontiguous indexable object.\n+\t * Helper to get dataAddr field of discontiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to discontiguous indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForDiscontiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 *address = NULL;\n+\t\tif (compressed) {\n+\t\t\taddress = &((J9IndexableObjectDiscontiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\taddress = &((J9IndexableObjectDiscontiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn address;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a contiguous indexable object.\n+\t * Sets the data pointer of a contiguous indexable object; in this case\n+\t * dataAddr will point directly into the data right after dataAddr field\n+\t * (data resides in heap).\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tU_64 *dataAddr = dataAddrSlotForContiguous(arrayPtr);\n+\t\tU_64 address = (U_64)((U_64)arrayPtr + contiguousHeaderSize());", "originalCommit": "bf05e0c03e97f6d93ac00e6811977596546d22ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4NzIwMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551987201", "bodyText": "Redundant cast.", "author": "keithc-ca", "createdAt": "2021-01-05T15:03:09Z", "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,161 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\n+\t/**\n+\t * Gets data pointer of a contiguous indexable object.\n+\t * Helper to get dataAddr field of contiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 *address = NULL;\n+\t\tif (compressed) {\n+\t\t\taddress = &((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\taddress = &((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn address;\n+\t}\n+\n+\t/**\n+\t * Gets data pointer of a discontiguous indexable object.\n+\t * Helper to get dataAddr field of discontiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to discontiguous indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForDiscontiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 *address = NULL;\n+\t\tif (compressed) {\n+\t\t\taddress = &((J9IndexableObjectDiscontiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\taddress = &((J9IndexableObjectDiscontiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn address;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a contiguous indexable object.\n+\t * Sets the data pointer of a contiguous indexable object; in this case\n+\t * dataAddr will point directly into the data right after dataAddr field\n+\t * (data resides in heap).\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tU_64 *dataAddr = dataAddrSlotForContiguous(arrayPtr);\n+\t\tU_64 address = (U_64)((U_64)arrayPtr + contiguousHeaderSize());\n+\t\t*dataAddr = address;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a discontiguous indexable object.\n+\t * Sets the data pointer of a discontiguous indexable object; in this case\n+\t * dataAddr will point to the contiguous representation of the data\n+\t * which resides outside the heap (assuming double map/sparse-heap is enabled).\n+\t * In case double map is disabled, the dataAddr will point to the first arrayoid\n+\t * of the discontiguous indexable object, which also resides right after dataAddr\n+\t * field.\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t * @param dataAddr      Pointer which points to indexable object data\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForDiscontiguous(J9IndexableObject *arrayPtr, U_64 address)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tU_64 calculatedDataAddr = address;\n+\t\tU_64 *dataAddr = dataAddrSlotForDiscontiguous(arrayPtr);\n+\n+\t\t/* If calculatedDataAddr is NULL then we make dataAddr point to the first arrayoid */\n+\t\t/* Later on, when sparse-heap is enabled by default, we must assert dataAddr is not NULL */\n+\t\tif (0 == calculatedDataAddr) {\n+\t\t\tcalculatedDataAddr = (U_64)((U_64)arrayPtr + discontiguousHeaderSize());", "originalCommit": "bf05e0c03e97f6d93ac00e6811977596546d22ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk5NDk3NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551994975", "bodyText": "This can be:\nuint8_t *afterAlloc = heapAlloc + allocateSize;\n\nwhich eliminates the cast here and the need for one on line 168.", "author": "keithc-ca", "createdAt": "2021-01-05T15:15:16Z", "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -80,25 +142,30 @@ class MM_ObjectAllocationAPI\n #endif /* J9VM_ENV_DATA64 */\n \t\t\t{\n \t\t\t\t/* Calculate the size of the object */\n-\t\t\t\tUDATA const headerSize = J9VMTHREAD_CONTIGUOUS_HEADER_SIZE(currentThread);\n-\t\t\t\tUDATA const dataSize = ((UDATA)size) * J9ARRAYCLASS_GET_STRIDE(arrayClass);\n-\t\t\t\tUDATA allocateSize = (dataSize + headerSize + _objectAlignmentInBytes - 1) & ~(UDATA)(_objectAlignmentInBytes - 1);\n+\t\t\t\tuintptr_t const headerSize = J9VMTHREAD_CONTIGUOUS_HEADER_SIZE(currentThread);\n+\t\t\t\tuintptr_t const dataSize = ((uintptr_t)size) * J9ARRAYCLASS_GET_STRIDE(arrayClass);\n+\t\t\t\tuintptr_t allocateSize = (dataSize + headerSize + _objectAlignmentInBytes - 1) & ~(uintptr_t)(_objectAlignmentInBytes - 1);\n+#if defined(J9VM_ENV_DATA64)\n+\t\t\t\tif (allocateSize < J9_GC_MINIMUM_INDEXABLE_OBJECT_SIZE) {\n+\t\t\t\t\tallocateSize = J9_GC_MINIMUM_INDEXABLE_OBJECT_SIZE;\n+\t\t\t\t}\n+#else /* !J9VM_ENV_DATA64 */\n \t\t\t\tif (allocateSize < J9_GC_MINIMUM_OBJECT_SIZE) {\n \t\t\t\t\tallocateSize = J9_GC_MINIMUM_OBJECT_SIZE;\n \t\t\t\t}\n-\n+#endif /* J9VM_ENV_DATA64 */\n \t\t\t\t/* Allocate the memory */\n \t\t\t\tj9object_t objectHeader = NULL;\n \n \t\t\t\tswitch(_gcAllocationType) {\n \n #if defined(J9VM_GC_THREAD_LOCAL_HEAP)\n \t\t\t\tcase OMR_GC_ALLOCATION_TYPE_TLH:\n-\t\t\t\t\tif (allocateSize <= ((UDATA) currentThread->heapTop - (UDATA) currentThread->heapAlloc)) {\n-\t\t\t\t\t\tU_8 *heapAlloc = currentThread->heapAlloc;\n-\t\t\t\t\t\tUDATA afterAlloc = (UDATA)heapAlloc + allocateSize;\n+\t\t\t\t\tif (allocateSize <= ((uintptr_t) currentThread->heapTop - (uintptr_t) currentThread->heapAlloc)) {\n+\t\t\t\t\t\tuint8_t *heapAlloc = currentThread->heapAlloc;\n+\t\t\t\t\t\tuintptr_t afterAlloc = (uintptr_t)heapAlloc + allocateSize;", "originalCommit": "bf05e0c03e97f6d93ac00e6811977596546d22ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk5NTg0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551995843", "bodyText": "nit: end of multi-line comment (*/) should be on a line by itself.", "author": "keithc-ca", "createdAt": "2021-01-05T15:16:36Z", "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -150,29 +217,24 @@ class MM_ObjectAllocationAPI\n \t\t\t\t}\n \n \t\t\t\t/* Initialize the object */\n-\t\t\t\tif (J9VMTHREAD_COMPRESS_OBJECT_REFERENCES(currentThread)) {\n-\t\t\t\t\tJ9IndexableObjectContiguousCompressed *header = (J9IndexableObjectContiguousCompressed*)objectHeader;\n-\t\t\t\t\theader->clazz = (U_32)(UDATA)arrayClass;\n-\t\t\t\t\theader->size = size;\n-\t\t\t\t\tif (initializeSlots) {\n-\t\t\t\t\t\tmemset(header + 1, 0, dataSize);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\tJ9IndexableObjectContiguousFull *header = (J9IndexableObjectContiguousFull*)objectHeader;\n-\t\t\t\t\theader->clazz = (UDATA)arrayClass;\n-\t\t\t\t\theader->size = size;\n-\t\t\t\t\tif (initializeSlots) {\n-\t\t\t\t\t\tmemset(header + 1, 0, dataSize);\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\tinitializeContiguousIndexableObject(currentThread, initializeSlots, arrayClass, size, dataSize, &objectHeader);\n+\n \t\t\t\tif (memoryBarrier) {\n \t\t\t\t\tVM_AtomicSupport::writeBarrier();\n \t\t\t\t}\n \t\t\t\tinstance = objectHeader;\n \t\t\t}\n \t\t} else {\n+#if defined(J9VM_ENV_DATA64)\n+\t\t\t/* Calculate size of indexable object */\n+\t\t\tuintptr_t const headerSize = J9VMTHREAD_DISCONTIGUOUS_HEADER_SIZE(currentThread);\n+\t\t\tuintptr_t allocateSize = (headerSize + _objectAlignmentInBytes - 1) & ~(uintptr_t)(_objectAlignmentInBytes - 1);\n+\t\t\t/* Discontiguous header size is always equal or greater than J9_GC_MINIMUM_INDEXABLE_OBJECT_SIZE; therefore,\n+\t\t\t * there's no need to check if allocateSize is less than J9_GC_MINIMUM_INDEXABLE_OBJECT_SIZE */", "originalCommit": "bf05e0c03e97f6d93ac00e6811977596546d22ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk5NjQzOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551996439", "bodyText": "Needless casts as above.", "author": "keithc-ca", "createdAt": "2021-01-05T15:17:28Z", "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -181,11 +243,11 @@ class MM_ObjectAllocationAPI\n #if defined(J9VM_GC_THREAD_LOCAL_HEAP)\n \t\t\tcase OMR_GC_ALLOCATION_TYPE_TLH:\n \n-\t\t\t\tif (allocateSize <= ((UDATA) currentThread->heapTop - (UDATA) currentThread->heapAlloc)) {\n-\t\t\t\t\tU_8 *heapAlloc = currentThread->heapAlloc;\n-\t\t\t\t\tUDATA afterAlloc = (UDATA)heapAlloc + allocateSize;\n+\t\t\t\tif (allocateSize <= ((uintptr_t) currentThread->heapTop - (uintptr_t) currentThread->heapAlloc)) {\n+\t\t\t\t\tuint8_t *heapAlloc = currentThread->heapAlloc;\n+\t\t\t\t\tuintptr_t afterAlloc = (uintptr_t)heapAlloc + allocateSize;\n \t\t\t\t\tobjectHeader = (j9object_t) heapAlloc;\n-\t\t\t\t\tcurrentThread->heapAlloc = (U_8 *)afterAlloc;\n+\t\t\t\t\tcurrentThread->heapAlloc = (uint8_t *)afterAlloc;", "originalCommit": "bf05e0c03e97f6d93ac00e6811977596546d22ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAwMTI0Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552001246", "bodyText": "I think this round-up pattern deserves to be refactored into a helper function (perhaps a macro already exists).", "author": "keithc-ca", "createdAt": "2021-01-05T15:24:48Z", "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -274,9 +327,9 @@ class MM_ObjectAllocationAPI\n \t\tj9object_t instance = NULL;\n #if defined(J9VM_GC_THREAD_LOCAL_HEAP) || defined(J9VM_GC_SEGREGATED_HEAP)\n \t\t/* Calculate the size of the object */\n-\t\tUDATA const headerSize = J9VMTHREAD_OBJECT_HEADER_SIZE(currentThread);\n-\t\tUDATA dataSize = clazz->totalInstanceSize;\n-\t\tUDATA allocateSize = (dataSize + headerSize + _objectAlignmentInBytes - 1) & ~(UDATA)(_objectAlignmentInBytes - 1);\n+\t\tuintptr_t const headerSize = J9VMTHREAD_OBJECT_HEADER_SIZE(currentThread);\n+\t\tuintptr_t dataSize = clazz->totalInstanceSize;\n+\t\tuintptr_t allocateSize = (dataSize + headerSize + _objectAlignmentInBytes - 1) & ~(uintptr_t)(_objectAlignmentInBytes - 1);", "originalCommit": "bf05e0c03e97f6d93ac00e6811977596546d22ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552088916", "bodyText": "These structures are no longer used (they exist only to keep DDR happy), so if you avoid changing them, then there may not be a need for any DDR work.", "author": "gacholio", "createdAt": "2021-01-05T17:42:19Z", "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -2967,18 +2967,25 @@ typedef struct J9IndexableObjectContiguous {\n #if defined(J9VM_ENV_DATA64) && defined(OMR_GC_FULL_POINTERS)\n \tU_32 padding;\n #endif /* J9VM_ENV_DATA64 && !OMR_GC_COMPRESSED_POINTERS */\n+#if defined(J9VM_ENV_DATA64)", "originalCommit": "bf05e0c03e97f6d93ac00e6811977596546d22ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMDUzMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552100532", "bodyText": "Sounds good. I used them because I was getting errors on PPC 32 bit machines and the usage of those macros fixed that issue. Which macro should I use to specify if the platform is 32 or 64 bits instead?", "author": "bragaigor", "createdAt": "2021-01-05T18:02:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNzA5OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552107099", "bodyText": "J9VM_ENV_DATA64 is the right macro to use.\nThey must be updated or DDR will break: see my comment below.", "author": "keithc-ca", "createdAt": "2021-01-05T18:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjExMjM5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552112391", "bodyText": "Ah I see what you mean. Only the structures J9IndexableObject.*Compressed and J9IndexableObject.*Full are used while J9IndexableObjectContiguous is not, correct? Can I say the same for J9IndexableObjectDiscontiguous struct?", "author": "bragaigor", "createdAt": "2021-01-05T18:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEyMTc0Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552121746", "bodyText": "Perhaps the answer is what I thought we had already done - add a flag to indicate the presence of the compressed/full structures and use that instead of the mixed mode flag. Then we could leave the outdated structures as-is.", "author": "gacholio", "createdAt": "2021-01-05T18:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1NzIyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552157226", "bodyText": "The DDR code must continue to use J9IndexableObjectContiguous and J9IndexableObjectDiscontiguous to support core files from VMs before the introduction of the *Compressed and *Full variants. The old types should have sizes that reflect the new reality so the offset to the elements can be correctly computed.\nI'm not sure it's worth the effort to avoid using J9IndexableObjectContiguous or J9IndexableObjectDiscontiguous except for old core files.\nThe dataAddr field should be added to all six types (in 64-bit builds).", "author": "keithc-ca", "createdAt": "2021-01-05T19:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE2MTA3Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552161072", "bodyText": "The DDR code must continue to use J9IndexableObjectContiguous and J9IndexableObjectDiscontiguous to support core files from VMs before the introduction of the *Compressed and *Full variants.\n\nCurious why we have this restriction? Shouldn't we always use the DDR/jdmpview version that came with the VM which generated the core file being investigated?", "author": "fjeremic", "createdAt": "2021-01-05T19:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE3NDU0Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552174547", "bodyText": "Yes, I suppose there is no benefit to doing as I suggested. The sizes are derived from the core file, so there's no reason not to update the obsolete structures.", "author": "gacholio", "createdAt": "2021-01-05T20:25:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE3NTM0Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552175342", "bodyText": "The intent has always been that DDR is backward-compatible; that is, a new version of jdmpview should be able to read a core file produced by an older VM. This greatly simplifies the support story: you don't need to have every version in use by any customer to support them all. If a problem is identified in DDR in the version used by some client, you have the option to use a newer version (perhaps a new, custom version) to examine core files.\nRather than a restriction, this permits greater freedom in your choice of which version of jdmpview to use.", "author": "keithc-ca", "createdAt": "2021-01-05T20:26:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4OTE2Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552089162", "bodyText": "Same comment as above - don't change the unused structures.", "author": "gacholio", "createdAt": "2021-01-05T17:42:47Z", "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -2989,13 +2996,19 @@ typedef struct J9IndexableObjectDiscontiguous {\n #if defined(OMR_GC_COMPRESSED_POINTERS) || !defined(J9VM_ENV_DATA64)\n \tU_32 padding;\n #endif /* OMR_GC_COMPRESSED_POINTERS || !J9VM_ENV_DATA64 */\n+#if defined(J9VM_ENV_DATA64)", "originalCommit": "bf05e0c03e97f6d93ac00e6811977596546d22ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA5NTYzMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552095630", "bodyText": "Those types are used in DDR code, e.g. J9IndexableObjectHelper.", "author": "keithc-ca", "createdAt": "2021-01-05T17:54:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4OTE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjc1ODEzNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552758135", "bodyText": "nit: please remove this blank line", "author": "keithc-ca", "createdAt": "2021-01-06T16:13:01Z", "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,161 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\n+\t/**\n+\t * Gets data pointer of a contiguous indexable object.\n+\t * Helper to get dataAddr field of contiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to indexable object data\n+\t */\n+\tMMINLINE void **\n+\tdataAddrSlotForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tvoid **dataAddrPtr = NULL;\n+\t\tif (compressed) {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn dataAddrPtr;\n+\t}\n+\n+\t/**\n+\t * Gets data pointer of a discontiguous indexable object.\n+\t * Helper to get dataAddr field of discontiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to discontiguous indexable object data\n+\t */\n+\tMMINLINE void **\n+\tdataAddrSlotForDiscontiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tvoid **dataAddrPtr = NULL;\n+\t\tif (compressed) {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectDiscontiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectDiscontiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn dataAddrPtr;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a contiguous indexable object.\n+\t * Sets the data pointer of a contiguous indexable object; in this case\n+\t * dataAddr will point directly into the data right after dataAddr field\n+\t * (data resides in heap).\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tvoid **dataAddrPtr = dataAddrSlotForContiguous(arrayPtr);\n+\t\tvoid *dataAddr = (void *)((U_64)arrayPtr + contiguousHeaderSize());\n+\t\t*dataAddrPtr = dataAddr;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a discontiguous indexable object.\n+\t * Sets the data pointer of a discontiguous indexable object; in this case\n+\t * dataAddr will point to the contiguous representation of the data\n+\t * which resides outside the heap (assuming double map/sparse-heap is enabled).\n+\t * In case double map is disabled, the dataAddr will point to the first arrayoid\n+\t * of the discontiguous indexable object, which also resides right after dataAddr\n+\t * field.\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t * @param dataAddr      Pointer which points to indexable object data\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForDiscontiguous(J9IndexableObject *arrayPtr, void *address)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tvoid *calculatedDataAddr = address;\n+\t\tvoid **dataAddrPtr = dataAddrSlotForDiscontiguous(arrayPtr);\n+\n+\t\t/* If calculatedDataAddr is NULL then we make dataAddr point to the first arrayoid */\n+\t\t/* Later on, when sparse-heap is enabled by default, we must assert dataAddr is not NULL */\n+\t\tif (NULL == calculatedDataAddr) {\n+\t\t\tcalculatedDataAddr = (void *)((U_64)arrayPtr + discontiguousHeaderSize());\n+\t\t}\n+\n+\t\t*dataAddrPtr = calculatedDataAddr;\n+\t}\n+\n+\t/**\n+\t * Returns data pointer associated with a contiguous Indexable object.\n+\t * Data pointer will always be pointing at the arraylet data. In this\n+\t * case the data pointer will be pointing to address immediately after\n+\t * the header.\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t * @return data address associated with the Indexable object\n+\t */\n+\tMMINLINE void *\n+\tgetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tvoid *dataAddr = *dataAddrSlotForContiguous(arrayPtr);\n+\t\treturn dataAddr;\n+\t}\n+\n+\t/**\n+\t * Returns data pointer associated with a discontiguous Indexable object.\n+\t * Data pointer will always be pointing at the arraylet data. In this\n+\t * case the data pointer will be pointing to address immediately after\n+\t * the header (the arrayoid), except when double mapping or sparse-heap\n+\t * is enabled. In these cases, the data pointer will point to the\n+\t * contiguous representation of the data; hence returning that pointer.\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t * @return data address associated with the Indexable object\n+\t */\n+", "originalCommit": "23a6fbc2f8e8f6efe1722772b18f011d37222f4d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eea13016da2093cef1c255ef51e09833bf83404a", "url": "https://github.com/eclipse-openj9/openj9/commit/eea13016da2093cef1c255ef51e09833bf83404a", "message": "Add extra U_64 data field to Indexable Object Headers\n\nPreliminary work to incorporate extra 64 bit field to\nIndexable object headers. In case of contiguous arraylets\nthe extra field will hold the address of where the data\nstarts, which is right after the header. In case of\ndiscontiguous arraylets the extra field will hold the\naddress of:\n\n- The contiguous double mapped region (assuming double map\n  is enabled).\n- The contiguous sparse-heap region outside the heap (assuming\n  sparse heap is enabled).\n- If double mapping an sparse heap are both disabled, dataAddr\n  will point to the address right adter the header, in this\n  case to the first arrayoid.\n\nThis is the first phase concerning a series of deliverables.\nHere, we introduce the extra U_64 data field along with helper\nfunctions such as getters and setters that will be needed in\nthe future. Now dataAddr is only introduced and never used.\nOnce it\u2019s stable we\u2019ll deliver the second phase of changes\nthat makes use of dataAddr.\n\nPlease refer to https://github.com/eclipse/openj9/issues/11438\nfor more info. This set of changes concern part of the first\naction item of such issue.\n\nSigned-off-by: Igor Braga <higorb1@gmail.com>", "committedDate": "2021-01-06T18:07:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxMTMzNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552911337", "bodyText": "U64 is not correct in the name - the logic is correct (and used) even on 32bit, too.\nRename it to either ROUND_TO, or perhaps ROUND_UP_TO\nBTW, the same logic exists in GC_ObjectModelBase::adjustSizeInBytes() in OMR. Ideally, the macro should be on OMR side and both sides use it (but I guess this ok for now),", "author": "amicic", "createdAt": "2021-01-06T19:12:59Z", "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -33,6 +33,9 @@\n #endif /* OMR_OVERRIDE_COMPRESS_OBJECT_REFERENCES */\n #endif /* OMR_OVERRIDE_COMPRESS_OBJECT_REFERENCES */\n \n+/* Generic rounding macro - result is a uintptr_t */\n+#define ROUND_U64_TO(granularity, number) (((uintptr_t)(number) + (granularity) - 1) & ~((uintptr_t)(granularity) - 1))", "originalCommit": "eea13016da2093cef1c255ef51e09833bf83404a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxMjExOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552912118", "bodyText": "and I'd swap the positions of the arguments", "author": "amicic", "createdAt": "2021-01-06T19:14:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxMTMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxNDY5Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552914696", "bodyText": "we actually have a macro already: ROUND_UP_TO_POWEROF2 (object heap alignment is 8, what indeed is a power of 2)", "author": "amicic", "createdAt": "2021-01-06T19:19:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxMTMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxNjg5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552916894", "bodyText": "I thought I remembered OMR having such a macro. Thanks, @amicic for pointing it out.\nThis should definitely use ROUND_UP_TO_POWEROF2.", "author": "keithc-ca", "createdAt": "2021-01-06T19:24:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxMTMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxOTkyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552919922", "bodyText": "Yes I was going with ROUND_TO but ran into some issues with redefinition and namespaces. Cool I didn't know about ROUND_UP_TO_POWEROF2, I'll update it to make use of this macro, thanks!", "author": "bragaigor", "createdAt": "2021-01-06T19:30:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxMTMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyNTI3MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552925271", "bodyText": "it's more generic/optimal (in potential case this gets used on 32 bit) to cast to UDATA (what also discontiguousHeaderSize() returns).\nsame for contiguous", "author": "amicic", "createdAt": "2021-01-06T19:41:49Z", "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,160 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\n+\t/**\n+\t * Gets data pointer of a contiguous indexable object.\n+\t * Helper to get dataAddr field of contiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to indexable object data\n+\t */\n+\tMMINLINE void **\n+\tdataAddrSlotForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tvoid **dataAddrPtr = NULL;\n+\t\tif (compressed) {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn dataAddrPtr;\n+\t}\n+\n+\t/**\n+\t * Gets data pointer of a discontiguous indexable object.\n+\t * Helper to get dataAddr field of discontiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to discontiguous indexable object data\n+\t */\n+\tMMINLINE void **\n+\tdataAddrSlotForDiscontiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tvoid **dataAddrPtr = NULL;\n+\t\tif (compressed) {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectDiscontiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectDiscontiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn dataAddrPtr;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a contiguous indexable object.\n+\t * Sets the data pointer of a contiguous indexable object; in this case\n+\t * dataAddr will point directly into the data right after dataAddr field\n+\t * (data resides in heap).\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tvoid **dataAddrPtr = dataAddrSlotForContiguous(arrayPtr);\n+\t\tvoid *dataAddr = (void *)((U_64)arrayPtr + contiguousHeaderSize());\n+\t\t*dataAddrPtr = dataAddr;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a discontiguous indexable object.\n+\t * Sets the data pointer of a discontiguous indexable object; in this case\n+\t * dataAddr will point to the contiguous representation of the data\n+\t * which resides outside the heap (assuming double map/sparse-heap is enabled).\n+\t * In case double map is disabled, the dataAddr will point to the first arrayoid\n+\t * of the discontiguous indexable object, which also resides right after dataAddr\n+\t * field.\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t * @param dataAddr      Pointer which points to indexable object data\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForDiscontiguous(J9IndexableObject *arrayPtr, void *address)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tvoid *calculatedDataAddr = address;\n+\t\tvoid **dataAddrPtr = dataAddrSlotForDiscontiguous(arrayPtr);\n+\n+\t\t/* If calculatedDataAddr is NULL then we make dataAddr point to the first arrayoid */\n+\t\t/* Later on, when sparse-heap is enabled by default, we must assert dataAddr is not NULL */\n+\t\tif (NULL == calculatedDataAddr) {\n+\t\t\tcalculatedDataAddr = (void *)((U_64)arrayPtr + discontiguousHeaderSize());", "originalCommit": "eea13016da2093cef1c255ef51e09833bf83404a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyODk3Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552928973", "bodyText": "missed to use the macro", "author": "amicic", "createdAt": "2021-01-06T19:50:04Z", "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -150,29 +220,25 @@ class MM_ObjectAllocationAPI\n \t\t\t\t}\n \n \t\t\t\t/* Initialize the object */\n-\t\t\t\tif (J9VMTHREAD_COMPRESS_OBJECT_REFERENCES(currentThread)) {\n-\t\t\t\t\tJ9IndexableObjectContiguousCompressed *header = (J9IndexableObjectContiguousCompressed*)objectHeader;\n-\t\t\t\t\theader->clazz = (U_32)(UDATA)arrayClass;\n-\t\t\t\t\theader->size = size;\n-\t\t\t\t\tif (initializeSlots) {\n-\t\t\t\t\t\tmemset(header + 1, 0, dataSize);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\tJ9IndexableObjectContiguousFull *header = (J9IndexableObjectContiguousFull*)objectHeader;\n-\t\t\t\t\theader->clazz = (UDATA)arrayClass;\n-\t\t\t\t\theader->size = size;\n-\t\t\t\t\tif (initializeSlots) {\n-\t\t\t\t\t\tmemset(header + 1, 0, dataSize);\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\tinitializeContiguousIndexableObject(currentThread, initializeSlots, arrayClass, size, dataSize, &objectHeader);\n+\n \t\t\t\tif (memoryBarrier) {\n \t\t\t\t\tVM_AtomicSupport::writeBarrier();\n \t\t\t\t}\n \t\t\t\tinstance = objectHeader;\n \t\t\t}\n \t\t} else {\n+#if defined(J9VM_ENV_DATA64)\n+\t\t\t/* Calculate size of indexable object */\n+\t\t\tuintptr_t const headerSize = J9VMTHREAD_DISCONTIGUOUS_HEADER_SIZE(currentThread);\n+\t\t\tuintptr_t allocateSize = (headerSize + _objectAlignmentInBytes - 1) & ~(uintptr_t)(_objectAlignmentInBytes - 1);", "originalCommit": "eea13016da2093cef1c255ef51e09833bf83404a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNTY1Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552935657", "bodyText": "(NULL != dataAddr) is just temporary till all parties do initialize/update dataAddr? Even in 0-sized arrays, this will be initialized (to the end of header)?", "author": "amicic", "createdAt": "2021-01-06T20:03:14Z", "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -48,16 +51,78 @@ class MM_ObjectAllocationAPI\n \t * Data members\n \t */\n private:\n-\tconst UDATA _gcAllocationType;\n+\tconst uintptr_t _gcAllocationType;\n #if defined(J9VM_GC_BATCH_CLEAR_TLH)\n-\tconst UDATA _initializeSlotsOnTLHAllocate;\n+\tconst uintptr_t _initializeSlotsOnTLHAllocate;\n #endif /* J9VM_GC_BATCH_CLEAR_TLH */\n-\tconst UDATA _objectAlignmentInBytes;\n+\tconst uintptr_t _objectAlignmentInBytes;\n \n #if defined (J9VM_GC_SEGREGATED_HEAP)\n \tconst J9VMGCSizeClasses *_sizeClasses;\n #endif /* J9VM_GC_SEGREGATED_HEAP */\n \n+\tVMINLINE void\n+\tinitializeIndexableSlots(bool initializeSlots, uintptr_t dataSize, void *dataAddr)\n+\t{\n+\t\tif ((NULL != dataAddr) && initializeSlots) {", "originalCommit": "eea13016da2093cef1c255ef51e09833bf83404a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzODY1Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552938657", "bodyText": "Yes, dataAddr will always be initialized to:\nvoid *dataAddr = (void *)((uintptr_t)header + headerSize);\n\n(NULL != dataAddr) is there for safety even though it's not necessary since the default is to init dataAddr to point to data right after header.", "author": "bragaigor", "createdAt": "2021-01-06T20:10:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNTY1Nw=="}], "type": "inlineReview"}, {"oid": "f16da64b5bcb87ca7466bf4c76c70a8c244b06e1", "url": "https://github.com/eclipse-openj9/openj9/commit/f16da64b5bcb87ca7466bf4c76c70a8c244b06e1", "message": "Add extra U_64 data field to Indexable Object Headers\n\nPreliminary work to incorporate extra 64 bit field to\nIndexable object headers. In case of contiguous arraylets\nthe extra field will hold the address of where the data\nstarts, which is right after the header. In case of\ndiscontiguous arraylets the extra field will hold the\naddress of:\n\n- The contiguous double mapped region (assuming double map\n  is enabled).\n- The contiguous sparse-heap region outside the heap (assuming\n  sparse heap is enabled).\n- If double mapping an sparse heap are both disabled, dataAddr\n  will point to the address right adter the header, in this\n  case to the first arrayoid.\n\nThis is the first phase concerning a series of deliverables.\nHere, we introduce the extra U_64 data field along with helper\nfunctions such as getters and setters that will be needed in\nthe future. Now dataAddr is only introduced and never used.\nOnce it\u2019s stable we\u2019ll deliver the second phase of changes\nthat makes use of dataAddr.\n\nPlease refer to https://github.com/eclipse/openj9/issues/11438\nfor more info. This set of changes concern part of the first\naction item of such issue.\n\nSigned-off-by: Igor Braga <higorb1@gmail.com>", "committedDate": "2021-01-07T02:08:47Z", "type": "commit"}, {"oid": "f16da64b5bcb87ca7466bf4c76c70a8c244b06e1", "url": "https://github.com/eclipse-openj9/openj9/commit/f16da64b5bcb87ca7466bf4c76c70a8c244b06e1", "message": "Add extra U_64 data field to Indexable Object Headers\n\nPreliminary work to incorporate extra 64 bit field to\nIndexable object headers. In case of contiguous arraylets\nthe extra field will hold the address of where the data\nstarts, which is right after the header. In case of\ndiscontiguous arraylets the extra field will hold the\naddress of:\n\n- The contiguous double mapped region (assuming double map\n  is enabled).\n- The contiguous sparse-heap region outside the heap (assuming\n  sparse heap is enabled).\n- If double mapping an sparse heap are both disabled, dataAddr\n  will point to the address right adter the header, in this\n  case to the first arrayoid.\n\nThis is the first phase concerning a series of deliverables.\nHere, we introduce the extra U_64 data field along with helper\nfunctions such as getters and setters that will be needed in\nthe future. Now dataAddr is only introduced and never used.\nOnce it\u2019s stable we\u2019ll deliver the second phase of changes\nthat makes use of dataAddr.\n\nPlease refer to https://github.com/eclipse/openj9/issues/11438\nfor more info. This set of changes concern part of the first\naction item of such issue.\n\nSigned-off-by: Igor Braga <higorb1@gmail.com>", "committedDate": "2021-01-07T02:08:47Z", "type": "forcePushed"}]}