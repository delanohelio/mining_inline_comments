{"pr_number": 8496, "pr_title": "Improve performance on a full shared cache.", "pr_createdAt": "2020-02-04T16:35:44Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/8496", "timeline": [{"oid": "44bd2f3d0c3da263be5254ee3de4922dd1a5861c", "url": "https://github.com/eclipse-openj9/openj9/commit/44bd2f3d0c3da263be5254ee3de4922dd1a5861c", "message": "Improve performance on a full shared cache.\n\nWe see a significant slow down of startup speed when there are\nmany JVMs queuing for the write mutex of a full cache. It is not\nnecessary to acquire the write mutex in this case.\n\nReturn from j9shr_classStoreTransaction_start() after acquiring the\nsegment mutex but before acquiring the cache write mutex if the cache is\nfull.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-02-04T16:38:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgxMzc0MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8496#discussion_r374813741", "bodyText": "I added this check because when reaching this point, we do not have write mutex if the cache is full/soft full. Without this check,  j9shr_classStoreTransaction_createSharedClass() does not guarantee returning on checking J9SHR_RUNTIMEFLAG_AVAILABLE_SPACE_FULL from localRuntimeFlags (Another thread that has write mutex may unset this flag), leading to unexpected behavior.", "author": "hangshao0", "createdAt": "2020-02-04T17:26:37Z", "path": "runtime/bcutil/ROMClassBuilder.cpp", "diffHunk": "@@ -608,32 +608,37 @@ ROMClassBuilder::prepareAndLaydown( BufferManager *bufferManager, ClassFileParse\n \t\t\tsizeRequirements.lineNumberTableSize = U_32(sizeInformation.lineNumberSize);\n \t\t\tsizeRequirements.localVariableTableSize = U_32(sizeInformation.variableInfoSize);\n \n-\t\t\tif ( sharedStoreClassTransaction.allocateSharedClass(&sizeRequirements) ){\n-\t\t\t\tU_8 *romClassBuffer = (U_8*)sharedStoreClassTransaction.getRomClass();\n-\t\t\t\t/*\n-\t\t\t\t * Make note that the laydown is occurring in SharedClasses\n-\t\t\t\t */\n-\t\t\t\tromSize = finishPrepareAndLaydown(\n-\t\t\t\t\t\t(U_8*)sharedStoreClassTransaction.getRomClass(),\n-\t\t\t\t\t\t(U_8*)sharedStoreClassTransaction.getLineNumberTable(),\n-\t\t\t\t\t\t(U_8*)sharedStoreClassTransaction.getLocalVariableTable(),\n-\t\t\t\t\t\t&sizeInformation, modifiers, extraModifiers, optionalFlags,\n-\t\t\t\t\t\ttrue, sharedStoreClassTransaction.hasSharedStringTableLock(),\n-\t\t\t\t\t\t&classFileOracle, &srpOffsetTable, &srpKeyProducer, &romClassWriter,\n-\t\t\t\t\t\tcontext, &constantPoolMap\n-\t\t\t\t\t\t);\n-\n-\t\t\t\tfixReturnBytecodes(_portLibrary, (J9ROMClass *)romClassBuffer);\n+\t\t\tif (!sharedStoreClassTransaction.isCacheFull()) {", "originalCommit": "44bd2f3d0c3da263be5254ee3de4922dd1a5861c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MDYyNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8496#discussion_r374850625", "bodyText": "Why the check for TSTATE_ENTER_SEGMENTMUTEX?", "author": "pshipton", "createdAt": "2020-02-04T18:39:02Z", "path": "runtime/shared_common/SCImplementedAPI.cpp", "diffHunk": "@@ -770,7 +792,9 @@ j9shr_classStoreTransaction_nextSharedClassForCompare(void * tobj)\n \n \tTrc_SHR_API_j9shr_nextSharedClassForCompare_Entry(currentThread);\n \n-\tif (obj->transactionState != TSTATE_ENTER_WRITEMUTEX) {\n+\tif ((obj->transactionState != TSTATE_ENTER_WRITEMUTEX)\n+\t\t&& ((0 == obj->cacheFullFlags) || (obj->transactionState != TSTATE_ENTER_SEGMENTMUTEX))", "originalCommit": "44bd2f3d0c3da263be5254ee3de4922dd1a5861c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg3NDc5Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8496#discussion_r374874796", "bodyText": "With this change, we now return from j9shr_classStoreTransaction_start() after acquiring the segment mutex but before acquiring the cache write mutex if the cache is\nfull.\nfindNextROMClass() asserts the segmentMutex is being held. We should continue to findNextROMClass() in j9shr_classStoreTransaction_nextSharedClassForCompare() either:\n\nCache is not full, write mutex is entered, or\nCache is full, segmentMutex is entered.", "author": "hangshao0", "createdAt": "2020-02-04T19:25:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MDYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxMjY0MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8496#discussion_r374912641", "bodyText": "What I was thinking is that it seems redundant to check both cacheFullFlags and TSTATE_ENTER_SEGMENTMUTEX. If cacheFullFlags != 0 then transactionState == TSTATE_ENTER_SEGMENTMUTEX", "author": "pshipton", "createdAt": "2020-02-04T20:45:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MDYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0NzE5Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8496#discussion_r374947197", "bodyText": "Yes, the check for TSTATE_ENTER_SEGMENTMUTEX can be removed and it is removed.", "author": "hangshao0", "createdAt": "2020-02-04T21:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MDYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MDY3NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8496#discussion_r374850675", "bodyText": "Do these need to be level 1? They could be occurring quite often when the cache is full.", "author": "pshipton", "createdAt": "2020-02-04T18:39:07Z", "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -2984,3 +2984,6 @@ TraceEvent=Trc_SHR_CM_storeCacheUniqueID_generateCacheUniqueID_after Overhead=1\n \n TraceEvent=Trc_SHR_CC_startup_getCacheUniqueID_before Overhead=1 Level=7 Template=\"CC::startup(): getCacheUniqueID() - (createTime: %llx, metadataBytes: %zx, classesBytes: %zx, lineNumTabBytes: %zx, varTabBytes: %zx) \"\n TraceEvent=Trc_SHR_CC_startup_getCacheUniqueID_after Overhead=1 Level=7 Template=\"CC::startup(): getCacheUniqueID() - the cache unique ID is %s\"\n+\n+TraceEvent=Trc_SHR_API_j9shr_classStoreTransaction_start_cacheFull_Event Overhead=1 Level=1 Template=\"API j9shr_classStoreTransaction_start : J9SHR_RUNTIMEFLAG_BLOCK_SPACE_FULL is set. The shared cache is full\"", "originalCommit": "44bd2f3d0c3da263be5254ee3de4922dd1a5861c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg3NzU4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8496#discussion_r374877581", "bodyText": "I see the existing Trc_SHR_API_j9shr_createSharedClass_Full_Event is level 2 and cache could be full during the startup phase, so I made this trace point level 1. But I am fine with setting it level 3.", "author": "hangshao0", "createdAt": "2020-02-04T19:31:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MDY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxMDc2Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8496#discussion_r374910762", "bodyText": "Ideally there should be a single tracepoint when the cache becomes full, not a tracepoint every time a class is loaded when the cache is full.", "author": "pshipton", "createdAt": "2020-02-04T20:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MDY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0NzMxNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8496#discussion_r374947315", "bodyText": "Changed to level 3.", "author": "hangshao0", "createdAt": "2020-02-04T22:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MDY3NQ=="}], "type": "inlineReview"}, {"oid": "3cb5e7a342fa56525a5d7c94f6ef1150b43c7a21", "url": "https://github.com/eclipse-openj9/openj9/commit/3cb5e7a342fa56525a5d7c94f6ef1150b43c7a21", "message": "Improve performance on a full shared cache.\n\nWe see a significant slow down of startup speed when there are\nmany JVMs queuing for the write mutex of a full cache. It is not\nnecessary to acquire the write mutex in this case.\n\nReturn from j9shr_classStoreTransaction_start() after acquiring the\nsegment mutex but before acquiring the cache write mutex if the cache is\nfull.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-02-04T21:58:42Z", "type": "forcePushed"}, {"oid": "0581f2c19032c50b6258be2363e0477b105f4c2e", "url": "https://github.com/eclipse-openj9/openj9/commit/0581f2c19032c50b6258be2363e0477b105f4c2e", "message": "Improve performance on a full shared cache.\n\nWe see a significant slow down of startup speed when there are\nmany JVMs queuing for the write mutex of a full cache. It is not\nnecessary to acquire the write mutex in this case.\n\nReturn from j9shr_classStoreTransaction_start() after acquiring the\nsegment mutex but before acquiring the cache write mutex if the cache is\nfull.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-02-05T18:32:20Z", "type": "forcePushed"}, {"oid": "ba0e095a667dad751c6df65a4601ce0ea3763110", "url": "https://github.com/eclipse-openj9/openj9/commit/ba0e095a667dad751c6df65a4601ce0ea3763110", "message": "Improve performance on a full shared cache.\n\nWe see a significant slow down of startup speed when there are\nmany JVMs queuing for the write mutex of a full cache. It is not\nnecessary to acquire the write mutex in this case.\n\nReturn from j9shr_classStoreTransaction_start() after acquiring the\nsegment mutex but before acquiring the cache write mutex if the cache is\nfull.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-02-06T17:41:49Z", "type": "forcePushed"}, {"oid": "4c14e1416a83ed785d2714806d3f76d488c047e7", "url": "https://github.com/eclipse-openj9/openj9/commit/4c14e1416a83ed785d2714806d3f76d488c047e7", "message": "Improve performance on a full shared cache.\n\nWe see a significant slow down of startup speed when there are\nmany JVMs queuing for the write mutex of a full cache. It is not\nnecessary to acquire the write mutex in this case.\n\nReturn from j9shr_classStoreTransaction_start() after acquiring the\nsegment mutex but before acquiring the cache write mutex if the cache is\nfull.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-02-06T19:21:31Z", "type": "commit"}, {"oid": "4c14e1416a83ed785d2714806d3f76d488c047e7", "url": "https://github.com/eclipse-openj9/openj9/commit/4c14e1416a83ed785d2714806d3f76d488c047e7", "message": "Improve performance on a full shared cache.\n\nWe see a significant slow down of startup speed when there are\nmany JVMs queuing for the write mutex of a full cache. It is not\nnecessary to acquire the write mutex in this case.\n\nReturn from j9shr_classStoreTransaction_start() after acquiring the\nsegment mutex but before acquiring the cache write mutex if the cache is\nfull.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-02-06T19:21:31Z", "type": "forcePushed"}]}