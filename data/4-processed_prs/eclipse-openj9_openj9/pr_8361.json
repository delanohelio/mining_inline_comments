{"pr_number": 8361, "pr_title": "Skip zero init of Matcher internal arrays", "pr_createdAt": "2020-01-21T19:44:04Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/8361", "timeline": [{"oid": "107bac52ba6268d99aebf84f8dc85ec716c7eb8a", "url": "https://github.com/eclipse-openj9/openj9/commit/107bac52ba6268d99aebf84f8dc85ec716c7eb8a", "message": "Skip zero init of Matcher internal arrays\n\nThe implementation of java/util/regex/Matcher uses two int arrays internally\nto track matched regions. These arrays are created and then all elements are\nset to -1. This changes skips the zero init of the int arrays at allocation-\ntime as the arrays will be immediately overwritten with -1s.\n\nSigned-off-by: Andrew Craik <ajcraik@ca.ibm.com>", "committedDate": "2020-01-21T19:43:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg2MTY5Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8361#discussion_r374861697", "bodyText": "Will this change work for JDK11 which has a third array which is of type IntHashSet[]? In the reset() method we call the clear() API if the array index is non-null [2]. This means if we are not zero initializing the array, then it could have garbage data in there and we would try to call the clear() method on a garbage object.\n[1] https://github.com/ibmruntimes/openj9-openjdk-jdk11/blob/c9bd6c8ae0bee2fb301c6af09cb7a23099f4cd16/src/java.base/share/classes/java/util/regex/Matcher.java#L250\n[2] https://github.com/ibmruntimes/openj9-openjdk-jdk11/blob/c9bd6c8ae0bee2fb301c6af09cb7a23099f4cd16/src/java.base/share/classes/java/util/regex/Matcher.java#L410-L413", "author": "fjeremic", "createdAt": "2020-02-04T18:59:55Z", "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -4166,6 +4166,13 @@ void TR_ResolvedJ9Method::construct()\n       {  TR::unknownMethod},\n       };\n \n+   static X JavaUtilRegexMatcherMethods [] =\n+      {\n+      {x(TR::java_util_regex_Matcher_init, \"<init>\", \"(Ljava/util/regex/Pattern;Ljava/lang/CharSequence;)V\")},", "originalCommit": "107bac52ba6268d99aebf84f8dc85ec716c7eb8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg2NjEzNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8361#discussion_r374866134", "bodyText": "More generally, how do ensure that future changes to JCL methods will not break us? What happens when for example in JDK22 a new array gets introduced in this type and the author expects it to be zero initialized?\nThis seems like something that the JIT should be deducing, at least for non-OpenJ9 JCL methods, otherwise we are just waiting for silent bugs to be introduced.", "author": "fjeremic", "createdAt": "2020-02-04T19:08:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg2MTY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxNDgxOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8361#discussion_r376414818", "bodyText": "It isn't possible to deduce this programattically when values are in fields and potentially accessed on multiple threads using a local anlaysis - whitelisting is the only option. There is a risk form future JCL change, but this method is not unlike many other core JCL methods that need special handling.\nThanks for pointing out the extra array in JDK11 - given that it is a reference array - those do not support zero init skipping -the option only affects primitives which is why the testing works and the optimization works in general. I believe there are also other methods relying on this behavior.", "author": "andrewcraik", "createdAt": "2020-02-07T14:22:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg2MTY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUxMDI1Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8361#discussion_r376510252", "bodyText": "Thanks for pointing out the extra array in JDK11 - given that it is a reference array - those do not support zero init skipping -the option only affects primitives which is why the testing works and the optimization works in general.\n\nJust to clarify explicitly, we only allow skip zero initialization on primitive arrays? Could you point to the code where this check happens for future reference? I did not know we had this restriction, but happy that we do.", "author": "fjeremic", "createdAt": "2020-02-07T17:21:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg2MTY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc4NzA1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8361#discussion_r377787058", "bodyText": "Dug it up:\nhttps://github.com/eclipse/openj9/blob/c0ec632cad6b4408118467b2542e762efd7fa5e0/runtime/compiler/ilgen/Walker.cpp#L5980-L5981\nThis is where we check if the method symbol has been marked for the JIT to allow skipping zero initialization. It is used when new (primitive) arrays are created during ILGen. The above concern is no longer valid.", "author": "fjeremic", "createdAt": "2020-02-11T17:31:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg2MTY5Nw=="}], "type": "inlineReview"}]}