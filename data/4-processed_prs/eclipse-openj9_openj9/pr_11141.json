{"pr_number": 11141, "pr_title": "Support Static and Special Direct calls on Z for Snapshot", "pr_createdAt": "2020-11-10T14:09:03Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/11141", "timeline": [{"oid": "3e8a13d47b78cf5db056d240e5539707d7cc96a7", "url": "https://github.com/eclipse-openj9/openj9/commit/3e8a13d47b78cf5db056d240e5539707d7cc96a7", "message": "Support Static and Special Direct calls on Z for Snapshot\n\nImplement patchless dispatch sequence for Direct Static or Special calls\non Z for Snahoshot configuration.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-11-10T16:06:00Z", "type": "forcePushed"}, {"oid": "e8887726f2511f10c68bdf11d17f6f485b1775b6", "url": "https://github.com/eclipse-openj9/openj9/commit/e8887726f2511f10c68bdf11d17f6f485b1775b6", "message": "Support Static and Special Direct calls on Z for Snapshot\n\nImplement patchless dispatch sequence for Direct Static or Special calls\non Z for Snahoshot configuration.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-11-16T22:05:33Z", "type": "forcePushed"}, {"oid": "1fcc8e3db54652281d81f8934ade48d03e9818ec", "url": "https://github.com/eclipse-openj9/openj9/commit/1fcc8e3db54652281d81f8934ade48d03e9818ec", "message": "Support Static and Special Direct calls on Z for Snapshot\n\nImplement patchless dispatch sequence for Direct Static or Special calls\non Z for Snahoshot configuration.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-11-17T13:47:12Z", "type": "forcePushed"}, {"oid": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "url": "https://github.com/eclipse-openj9/openj9/commit/9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "message": "Support Static and Special Direct calls on Z for Snapshot\n\nImplement patchless dispatch sequence for Direct Static or Special calls\non Z for Snahoshot configuration.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-11-17T13:55:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMwOTAzNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525309034", "bodyText": "I think we need to place the RI on/off sequence for both RX and RWX dispatches. We need to move this outside the if / else.", "author": "fjeremic", "createdAt": "2020-11-17T16:38:53Z", "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -2631,29 +2740,36 @@ J9::Z::PrivateLinkage::buildDirectCall(TR::Node * callNode, TR::SymbolReference\n       }\n    else\n       {\n-      if (cg()->getSupportsRuntimeInstrumentation())\n-         TR::TreeEvaluator::generateRuntimeInstrumentationOnOffSequence(cg(), TR::InstOpCode::RIOFF, callNode);\n-\n-      // call through snippet if the method is not resolved or not jitted yet\n-      TR::LabelSymbol * label = generateLabelSymbol(cg());\n-      TR::Snippet * snippet;\n-\n-      if (callSymRef->isUnresolved() || (comp()->compileRelocatableCode() && !comp()->getOption(TR_UseSymbolValidationManager)))\n+      if (comp()->getGenerateReadOnlyCode())\n          {\n-         snippet = new (trHeapMemory()) TR::S390UnresolvedCallSnippet(cg(), callNode, label, argSize);\n+         gcPoint = buildNoPatchingStaticOrSpecialCall(callNode, callSymRef, dependencies, argSize);\n          }\n       else\n-         {\n-         snippet = new (trHeapMemory()) TR::S390J9CallSnippet(cg(), callNode, label, callSymRef, argSize);\n-         }\n+         { \n+         if (cg()->getSupportsRuntimeInstrumentation())\n+            TR::TreeEvaluator::generateRuntimeInstrumentationOnOffSequence(cg(), TR::InstOpCode::RIOFF, callNode);\n \n-      cg()->addSnippet(snippet);\n+         // call through snippet if the method is not resolved or not jitted yet\n+         TR::LabelSymbol * label = generateLabelSymbol(cg());\n+         TR::Snippet * snippet;\n+\n+         if (callSymRef->isUnresolved() || (comp()->compileRelocatableCode() && !comp()->getOption(TR_UseSymbolValidationManager)))\n+            {\n+            snippet = new (trHeapMemory()) TR::S390UnresolvedCallSnippet(cg(), callNode, label, argSize);\n+            }\n+         else\n+            {\n+            snippet = new (trHeapMemory()) TR::S390J9CallSnippet(cg(), callNode, label, callSymRef, argSize);\n+            }\n \n+         cg()->addSnippet(snippet);\n \n-      gcPoint = generateSnippetCall(cg(), callNode, snippet, dependencies, callSymRef);\n \n-      if (cg()->getSupportsRuntimeInstrumentation())\n-         TR::TreeEvaluator::generateRuntimeInstrumentationOnOffSequence(cg(), TR::InstOpCode::RION, callNode);\n+         gcPoint = generateSnippetCall(cg(), callNode, snippet, dependencies, callSymRef);\n+\n+         if (cg()->getSupportsRuntimeInstrumentation())\n+            TR::TreeEvaluator::generateRuntimeInstrumentationOnOffSequence(cg(), TR::InstOpCode::RION, callNode);", "originalCommit": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI0NDQ5OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r526244498", "bodyText": "Moved the RION generation outside of the if/else , reason I kept that limited to RWX because, I am not sure how RI is going to work out for RX code.", "author": "r30shah", "createdAt": "2020-11-18T16:51:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMwOTAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMxMjIyNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525312225", "bodyText": "We should keep the name of this the same as the field for searchability.", "author": "fjeremic", "createdAt": "2020-11-17T16:42:16Z", "path": "runtime/compiler/z/runtime/PicBuilder.m4", "diffHunk": "@@ -167,6 +167,16 @@ SETVAL(eq_InterfaceCallHelperReadOnly_RA,4)\n SETVAL(eq_offsetOfMethodAddrInPICSlot,8)\n SETVAL(eq_sizeOfPICSlotForInterfaceCall,16)\n \n+ZZ Unresolved/Resolved Static and Special Calls Glue\n+SETVAL(eq_ccUnresolvedStaticSpecialCall_methodAddress,0)", "originalCommit": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMxMzEwMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525313100", "bodyText": "These seem to have different names. The struct is named ccStaticSpecialData. Should we use the same name here?", "author": "fjeremic", "createdAt": "2020-11-17T16:43:24Z", "path": "runtime/compiler/z/runtime/PicBuilder.m4", "diffHunk": "@@ -167,6 +167,16 @@ SETVAL(eq_InterfaceCallHelperReadOnly_RA,4)\n SETVAL(eq_offsetOfMethodAddrInPICSlot,8)\n SETVAL(eq_sizeOfPICSlotForInterfaceCall,16)\n \n+ZZ Unresolved/Resolved Static and Special Calls Glue\n+SETVAL(eq_ccUnresolvedStaticSpecialCall_methodAddress,0)\n+SETVAL(eq_ccUnresolvedStaticSpecialCall_ramMethod,8)\n+SETVAL(eq_ccUnresolvedStaticSpecialCall_cpAddress,16)\n+SETVAL(eq_ccUnresolvedStaticSpecialCall_cpIndex,24)\n+SETVAL(eq_ccStaticOrSpecialCalls_methodAddress,0)\n+SETVAL(eq_ccResolvedStaticSpecialCall_ramMethod,8)", "originalCommit": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI0MzYzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r526243631", "bodyText": "Some of the offset for both unresolved and resolved are same (for example ramMethod, snippetOrCompiledMethod) and in the PIC Builder I have tried put the common block of code together (For example for unresoved static or special call, it calls different JIT helper but updating the CCData with ramMethod and dispatching for the j2itransition shared same code even with resolved ones) so for such fields I have used StaticOrSpecialCalls and removed resolved or unresolved from it.\nThere were some un-needed offset I forgot to cleanup , Removed them in https://github.com/eclipse/openj9/compare/9a9d9b37daeb983c8d4e295fcc785afeecde5d78..de725983cd06ff96468a76b30321d3f8bb48caea", "author": "r30shah", "createdAt": "2020-11-18T16:50:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMxMzEwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMxNDk4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525314988", "bodyText": "Is OSR currently allowed with read only code? Wondering if this should be a fatal assert under read-only mode.", "author": "fjeremic", "createdAt": "2020-11-17T16:45:51Z", "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -2592,7 +2699,9 @@ J9::Z::PrivateLinkage::buildDirectCall(TR::Node * callNode, TR::SymbolReference\n \n    if (comp()->getOption(TR_TraceCG))\n       traceMsg(comp(), \"Build Direct Call\\n\");\n-\n+   // TODO: For read only code cache, we will need to change the jitInduceOSR\n+   // call below to use the sequence that is works for RXi, Probably a new\n+   // buildDirectCall makes sense here to handle all the cases more cleanly\n    // generate call", "originalCommit": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI0MDY2Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r526240662", "bodyText": "I have added a FATAL assert with Node in case generateReadOnlyCode is enabled and we encounter jitInduceOSR call. I do not think so we have OSR support currently for RX code\nhttps://github.com/eclipse/openj9/compare/9a9d9b37daeb983c8d4e295fcc785afeecde5d78..de725983cd06ff96468a76b30321d3f8bb48caea", "author": "r30shah", "createdAt": "2020-11-18T16:46:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMxNDk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyMTMwMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525321301", "bodyText": "This comment is not very useful. It does not say anything more than the code already does.", "author": "fjeremic", "createdAt": "2020-11-17T16:54:27Z", "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -2562,6 +2564,111 @@ J9::Z::PrivateLinkage::buildVirtualDispatch(TR::Node * callNode, TR::RegisterDep\n    gcPoint->setNeedsGCMap(getPreservedRegisterMapForGC());\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingStaticOrSpecialCall(TR::Node *callNode, TR::SymbolReference *callSymRef,\n+   TR::RegisterDependencyConditions *dependencies, int32_t argSize)\n+   {\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+   intptr_t callSnippetCCDataAddress = NULL;\n+   int32_t  offsetOfSnippetOrCompiledMethod = 0;\n+   if (callSymRef->isUnresolved() || (comp()->compileRelocatableCode() && !comp()->getOption(TR_UseSymbolValidationManager)))\n+      {\n+      // Call Is unresolved. Allocate a CCData.", "originalCommit": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI0MDA5Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r526240096", "bodyText": "Removed comment in https://github.com/eclipse/openj9/compare/9a9d9b37daeb983c8d4e295fcc785afeecde5d78..de725983cd06ff96468a76b30321d3f8bb48caea", "author": "r30shah", "createdAt": "2020-11-18T16:46:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyMTMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyMjUzNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525322534", "bodyText": "We should initialize this.", "author": "fjeremic", "createdAt": "2020-11-17T16:55:55Z", "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -2562,6 +2564,111 @@ J9::Z::PrivateLinkage::buildVirtualDispatch(TR::Node * callNode, TR::RegisterDep\n    gcPoint->setNeedsGCMap(getPreservedRegisterMapForGC());\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingStaticOrSpecialCall(TR::Node *callNode, TR::SymbolReference *callSymRef,\n+   TR::RegisterDependencyConditions *dependencies, int32_t argSize)\n+   {\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;", "originalCommit": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI0MDAxNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r526240016", "bodyText": "Changed in https://github.com/eclipse/openj9/compare/9a9d9b37daeb983c8d4e295fcc785afeecde5d78..de725983cd06ff96468a76b30321d3f8bb48caea", "author": "r30shah", "createdAt": "2020-11-18T16:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyMjUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyMzc5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525323794", "bodyText": "Shouldn't this be an offsetof(ccStaticSpecialData, ...)? Perhaps a copy/paste error.", "author": "fjeremic", "createdAt": "2020-11-17T16:57:40Z", "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -2562,6 +2564,111 @@ J9::Z::PrivateLinkage::buildVirtualDispatch(TR::Node * callNode, TR::RegisterDep\n    gcPoint->setNeedsGCMap(getPreservedRegisterMapForGC());\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingStaticOrSpecialCall(TR::Node *callNode, TR::SymbolReference *callSymRef,\n+   TR::RegisterDependencyConditions *dependencies, int32_t argSize)\n+   {\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+   intptr_t callSnippetCCDataAddress = NULL;\n+   int32_t  offsetOfSnippetOrCompiledMethod = 0;\n+   if (callSymRef->isUnresolved() || (comp()->compileRelocatableCode() && !comp()->getOption(TR_UseSymbolValidationManager)))\n+      {\n+      // Call Is unresolved. Allocate a CCData.\n+      if (!(codeCacheData->put(NULL, sizeof(ccUnresolvedStaticSpecialData), alignof(ccUnresolvedStaticSpecialData), NULL, index)))\n+         {\n+         cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate metadata for static or special call\");\n+         }\n+\n+      ccUnresolvedStaticSpecialData *ccUnresolvedStaticSpecialDataAddress = codeCacheData->get<ccUnresolvedStaticSpecialData>(index);\n+\n+      // Shape of the ccData\n+      // snippetOrCompiledMethod -> to be updated in binary encoding while emitting snippet body\n+      // ramMethod -> Should be NULL for Unresolved\n+      // cpAddress -> Filled here\n+      // cpIndex   -> Filled here\n+\n+      ccUnresolvedStaticSpecialDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+      ccUnresolvedStaticSpecialDataAddress->ramMethod = 0;\n+      ccUnresolvedStaticSpecialDataAddress->cpIndex   = static_cast<intptr_t>(callNode->getSymbolReference()->getCPIndexForVM());\n+      callSnippetCCDataAddress = reinterpret_cast<intptr_t>(ccUnresolvedStaticSpecialDataAddress);\n+      offsetOfSnippetOrCompiledMethod = static_cast<int32_t>(offsetof(ccUnresolvedStaticSpecialData, snippetOrCompiledMethod));\n+      }\n+   else\n+      {\n+      if (!(codeCacheData->put(NULL, sizeof(ccStaticSpecialData), alignof(ccStaticSpecialData), NULL, index)))\n+         {\n+         cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate metadata for static or special call\");\n+         }\n+\n+      ccStaticSpecialData *ccStaticSpecialDataAddress = codeCacheData->get<ccStaticSpecialData>(index);\n+\n+      // Shape of the ccData\n+      // snippetOrCompiledMethod -> to be updated in binary encoding while emitting snippet body\n+      // ramMethod -> Filled Here\n+      TR::MethodSymbol *methodSymbol = callSymRef->getSymbol()->castToMethodSymbol();\n+      intptr_t ramMethod;\n+#if defined(J9VM_OPT_JITSERVER)\n+      ramMethod = comp()->isOutOfProcessCompilation() && methodSymbol->isInterpreted() ?\n+                     static_cast<intptr_t>(callSymRef->getSymbol()->castToResolvedMethodSymbol()->getResolvedMethod()->getPersistentIdentifier()) :\n+                     static_cast<intptr_t>(methodSymbol->getMethodAddress());\n+#else\n+      ramMethod = reinterpret_cast<intptr_t>(methodSymbol->getMethodAddress());\n+#endif\n+      ccStaticSpecialDataAddress->ramMethod = ramMethod;\n+      callSnippetCCDataAddress = reinterpret_cast<intptr_t>(ccStaticSpecialDataAddress);\n+      offsetOfSnippetOrCompiledMethod = static_cast<int32_t>(offsetof(ccUnresolvedStaticSpecialData, snippetOrCompiledMethod));", "originalCommit": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIzOTg3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r526239877", "bodyText": "Yeah, it was copy/paste error, both CCData has same offset for snippetOrCompiledMethod so did not cause functional issue but fixed it in https://github.com/eclipse/openj9/compare/9a9d9b37daeb983c8d4e295fcc785afeecde5d78..de725983cd06ff96468a76b30321d3f8bb48caea", "author": "r30shah", "createdAt": "2020-11-18T16:45:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyMzc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzMDI3NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525330275", "bodyText": "Spaces around operators.", "author": "fjeremic", "createdAt": "2020-11-17T17:04:53Z", "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -2562,6 +2564,111 @@ J9::Z::PrivateLinkage::buildVirtualDispatch(TR::Node * callNode, TR::RegisterDep\n    gcPoint->setNeedsGCMap(getPreservedRegisterMapForGC());\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingStaticOrSpecialCall(TR::Node *callNode, TR::SymbolReference *callSymRef,\n+   TR::RegisterDependencyConditions *dependencies, int32_t argSize)\n+   {\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+   intptr_t callSnippetCCDataAddress = NULL;\n+   int32_t  offsetOfSnippetOrCompiledMethod = 0;\n+   if (callSymRef->isUnresolved() || (comp()->compileRelocatableCode() && !comp()->getOption(TR_UseSymbolValidationManager)))\n+      {\n+      // Call Is unresolved. Allocate a CCData.\n+      if (!(codeCacheData->put(NULL, sizeof(ccUnresolvedStaticSpecialData), alignof(ccUnresolvedStaticSpecialData), NULL, index)))\n+         {\n+         cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate metadata for static or special call\");\n+         }\n+\n+      ccUnresolvedStaticSpecialData *ccUnresolvedStaticSpecialDataAddress = codeCacheData->get<ccUnresolvedStaticSpecialData>(index);\n+\n+      // Shape of the ccData\n+      // snippetOrCompiledMethod -> to be updated in binary encoding while emitting snippet body\n+      // ramMethod -> Should be NULL for Unresolved\n+      // cpAddress -> Filled here\n+      // cpIndex   -> Filled here\n+\n+      ccUnresolvedStaticSpecialDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+      ccUnresolvedStaticSpecialDataAddress->ramMethod = 0;\n+      ccUnresolvedStaticSpecialDataAddress->cpIndex   = static_cast<intptr_t>(callNode->getSymbolReference()->getCPIndexForVM());\n+      callSnippetCCDataAddress = reinterpret_cast<intptr_t>(ccUnresolvedStaticSpecialDataAddress);\n+      offsetOfSnippetOrCompiledMethod = static_cast<int32_t>(offsetof(ccUnresolvedStaticSpecialData, snippetOrCompiledMethod));\n+      }\n+   else\n+      {\n+      if (!(codeCacheData->put(NULL, sizeof(ccStaticSpecialData), alignof(ccStaticSpecialData), NULL, index)))\n+         {\n+         cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate metadata for static or special call\");\n+         }\n+\n+      ccStaticSpecialData *ccStaticSpecialDataAddress = codeCacheData->get<ccStaticSpecialData>(index);\n+\n+      // Shape of the ccData\n+      // snippetOrCompiledMethod -> to be updated in binary encoding while emitting snippet body\n+      // ramMethod -> Filled Here\n+      TR::MethodSymbol *methodSymbol = callSymRef->getSymbol()->castToMethodSymbol();\n+      intptr_t ramMethod;\n+#if defined(J9VM_OPT_JITSERVER)\n+      ramMethod = comp()->isOutOfProcessCompilation() && methodSymbol->isInterpreted() ?\n+                     static_cast<intptr_t>(callSymRef->getSymbol()->castToResolvedMethodSymbol()->getResolvedMethod()->getPersistentIdentifier()) :\n+                     static_cast<intptr_t>(methodSymbol->getMethodAddress());\n+#else\n+      ramMethod = reinterpret_cast<intptr_t>(methodSymbol->getMethodAddress());\n+#endif\n+      ccStaticSpecialDataAddress->ramMethod = ramMethod;\n+      callSnippetCCDataAddress = reinterpret_cast<intptr_t>(ccStaticSpecialDataAddress);\n+      offsetOfSnippetOrCompiledMethod = static_cast<int32_t>(offsetof(ccUnresolvedStaticSpecialData, snippetOrCompiledMethod));\n+      }\n+\n+   TR::LabelSymbol *snippetLabel = generateLabelSymbol(cg());\n+   TR::LabelSymbol *doneLabel = generateLabelSymbol(cg());\n+   TR::Snippet *callSnippet = new (trHeapMemory()) TR::S390J9CallSnippetRX(cg(),\n+                                                                           callNode,\n+                                                                           snippetLabel,\n+                                                                           doneLabel,\n+                                                                           callSymRef,\n+                                                                           argSize,\n+                                                                           callSnippetCCDataAddress);\n+   void *targetAddress = reinterpret_cast<void *>(callSnippetCCDataAddress + static_cast<intptr_t>(offsetOfSnippetOrCompiledMethod));\n+   TR::StaticSymbol *snippetOrCompiledSlotSymbol = TR::StaticSymbol::createWithAddress(comp()->trHeapMemory(), TR::Address, targetAddress);\n+   TR::SymbolReference *snippetOrCompiledSlotSymRef = new (comp()->trHeapMemory()) TR::SymbolReference(comp()->getSymRefTab(), snippetOrCompiledSlotSymbol, 0);\n+   snippetOrCompiledSlotSymbol->setNotDataAddress();\n+\n+   TR::RegisterDependencyConditions *preDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies->getPreConditions(), NULL,\n+                                                                                                      dependencies->getAddCursorForPre(), 0, cg());\n+\n+   int32_t numOfAdditionalPostDeps = 0;\n+   TR::Register *regRA = dependencies->searchPostConditionRegister(getReturnAddressRegister());\n+   if (regRA == NULL)\n+      {\n+      regRA = cg()->allocateRegister();\n+      numOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::Register *regEP = dependencies->searchPostConditionRegister(getEntryPointRegister());\n+   if (regEP == NULL)\n+      {\n+      regEP = cg()->allocateRegister();\n+      numOfAdditionalPostDeps+=1;", "originalCommit": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIzOTAxNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r526239016", "bodyText": "Changed in https://github.com/eclipse/openj9/compare/9a9d9b37daeb983c8d4e295fcc785afeecde5d78..de725983cd06ff96468a76b30321d3f8bb48caea", "author": "r30shah", "createdAt": "2020-11-18T16:44:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzMDI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzMTA4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525331088", "bodyText": "Why do we need to do this if we already specified 0 preconditions when we allocated the register dependency?", "author": "fjeremic", "createdAt": "2020-11-17T17:05:30Z", "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -2562,6 +2564,111 @@ J9::Z::PrivateLinkage::buildVirtualDispatch(TR::Node * callNode, TR::RegisterDep\n    gcPoint->setNeedsGCMap(getPreservedRegisterMapForGC());\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingStaticOrSpecialCall(TR::Node *callNode, TR::SymbolReference *callSymRef,\n+   TR::RegisterDependencyConditions *dependencies, int32_t argSize)\n+   {\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+   intptr_t callSnippetCCDataAddress = NULL;\n+   int32_t  offsetOfSnippetOrCompiledMethod = 0;\n+   if (callSymRef->isUnresolved() || (comp()->compileRelocatableCode() && !comp()->getOption(TR_UseSymbolValidationManager)))\n+      {\n+      // Call Is unresolved. Allocate a CCData.\n+      if (!(codeCacheData->put(NULL, sizeof(ccUnresolvedStaticSpecialData), alignof(ccUnresolvedStaticSpecialData), NULL, index)))\n+         {\n+         cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate metadata for static or special call\");\n+         }\n+\n+      ccUnresolvedStaticSpecialData *ccUnresolvedStaticSpecialDataAddress = codeCacheData->get<ccUnresolvedStaticSpecialData>(index);\n+\n+      // Shape of the ccData\n+      // snippetOrCompiledMethod -> to be updated in binary encoding while emitting snippet body\n+      // ramMethod -> Should be NULL for Unresolved\n+      // cpAddress -> Filled here\n+      // cpIndex   -> Filled here\n+\n+      ccUnresolvedStaticSpecialDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+      ccUnresolvedStaticSpecialDataAddress->ramMethod = 0;\n+      ccUnresolvedStaticSpecialDataAddress->cpIndex   = static_cast<intptr_t>(callNode->getSymbolReference()->getCPIndexForVM());\n+      callSnippetCCDataAddress = reinterpret_cast<intptr_t>(ccUnresolvedStaticSpecialDataAddress);\n+      offsetOfSnippetOrCompiledMethod = static_cast<int32_t>(offsetof(ccUnresolvedStaticSpecialData, snippetOrCompiledMethod));\n+      }\n+   else\n+      {\n+      if (!(codeCacheData->put(NULL, sizeof(ccStaticSpecialData), alignof(ccStaticSpecialData), NULL, index)))\n+         {\n+         cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate metadata for static or special call\");\n+         }\n+\n+      ccStaticSpecialData *ccStaticSpecialDataAddress = codeCacheData->get<ccStaticSpecialData>(index);\n+\n+      // Shape of the ccData\n+      // snippetOrCompiledMethod -> to be updated in binary encoding while emitting snippet body\n+      // ramMethod -> Filled Here\n+      TR::MethodSymbol *methodSymbol = callSymRef->getSymbol()->castToMethodSymbol();\n+      intptr_t ramMethod;\n+#if defined(J9VM_OPT_JITSERVER)\n+      ramMethod = comp()->isOutOfProcessCompilation() && methodSymbol->isInterpreted() ?\n+                     static_cast<intptr_t>(callSymRef->getSymbol()->castToResolvedMethodSymbol()->getResolvedMethod()->getPersistentIdentifier()) :\n+                     static_cast<intptr_t>(methodSymbol->getMethodAddress());\n+#else\n+      ramMethod = reinterpret_cast<intptr_t>(methodSymbol->getMethodAddress());\n+#endif\n+      ccStaticSpecialDataAddress->ramMethod = ramMethod;\n+      callSnippetCCDataAddress = reinterpret_cast<intptr_t>(ccStaticSpecialDataAddress);\n+      offsetOfSnippetOrCompiledMethod = static_cast<int32_t>(offsetof(ccUnresolvedStaticSpecialData, snippetOrCompiledMethod));\n+      }\n+\n+   TR::LabelSymbol *snippetLabel = generateLabelSymbol(cg());\n+   TR::LabelSymbol *doneLabel = generateLabelSymbol(cg());\n+   TR::Snippet *callSnippet = new (trHeapMemory()) TR::S390J9CallSnippetRX(cg(),\n+                                                                           callNode,\n+                                                                           snippetLabel,\n+                                                                           doneLabel,\n+                                                                           callSymRef,\n+                                                                           argSize,\n+                                                                           callSnippetCCDataAddress);\n+   void *targetAddress = reinterpret_cast<void *>(callSnippetCCDataAddress + static_cast<intptr_t>(offsetOfSnippetOrCompiledMethod));\n+   TR::StaticSymbol *snippetOrCompiledSlotSymbol = TR::StaticSymbol::createWithAddress(comp()->trHeapMemory(), TR::Address, targetAddress);\n+   TR::SymbolReference *snippetOrCompiledSlotSymRef = new (comp()->trHeapMemory()) TR::SymbolReference(comp()->getSymRefTab(), snippetOrCompiledSlotSymbol, 0);\n+   snippetOrCompiledSlotSymbol->setNotDataAddress();\n+\n+   TR::RegisterDependencyConditions *preDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies->getPreConditions(), NULL,\n+                                                                                                      dependencies->getAddCursorForPre(), 0, cg());\n+\n+   int32_t numOfAdditionalPostDeps = 0;\n+   TR::Register *regRA = dependencies->searchPostConditionRegister(getReturnAddressRegister());\n+   if (regRA == NULL)\n+      {\n+      regRA = cg()->allocateRegister();\n+      numOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::Register *regEP = dependencies->searchPostConditionRegister(getEntryPointRegister());\n+   if (regEP == NULL)\n+      {\n+      regEP = cg()->allocateRegister();\n+      numOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::RegisterDependencyConditions *postDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies, 0, numOfAdditionalPostDeps, cg());\n+   postDeps->setAddCursorForPre(0);\n+   postDeps->setNumPreConditions(0, trMemory());", "originalCommit": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIzODg4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r526238883", "bodyText": "The overload of the constructor does not set the pre conditions to 0 but just adds that count to existing pre conditions. I have changed the way I am extracting the post deps from dependencies in https://github.com/eclipse/openj9/compare/9a9d9b37daeb983c8d4e295fcc785afeecde5d78..de725983cd06ff96468a76b30321d3f8bb48caea", "author": "r30shah", "createdAt": "2020-11-18T16:44:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzMTA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzMzk3Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525333976", "bodyText": "Why not change the type of callSnippet to be TR::S390J9CallSnippetRX* at the declaration point so we can avoid this cast here?", "author": "fjeremic", "createdAt": "2020-11-17T17:07:45Z", "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -2562,6 +2564,111 @@ J9::Z::PrivateLinkage::buildVirtualDispatch(TR::Node * callNode, TR::RegisterDep\n    gcPoint->setNeedsGCMap(getPreservedRegisterMapForGC());\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingStaticOrSpecialCall(TR::Node *callNode, TR::SymbolReference *callSymRef,\n+   TR::RegisterDependencyConditions *dependencies, int32_t argSize)\n+   {\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+   intptr_t callSnippetCCDataAddress = NULL;\n+   int32_t  offsetOfSnippetOrCompiledMethod = 0;\n+   if (callSymRef->isUnresolved() || (comp()->compileRelocatableCode() && !comp()->getOption(TR_UseSymbolValidationManager)))\n+      {\n+      // Call Is unresolved. Allocate a CCData.\n+      if (!(codeCacheData->put(NULL, sizeof(ccUnresolvedStaticSpecialData), alignof(ccUnresolvedStaticSpecialData), NULL, index)))\n+         {\n+         cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate metadata for static or special call\");\n+         }\n+\n+      ccUnresolvedStaticSpecialData *ccUnresolvedStaticSpecialDataAddress = codeCacheData->get<ccUnresolvedStaticSpecialData>(index);\n+\n+      // Shape of the ccData\n+      // snippetOrCompiledMethod -> to be updated in binary encoding while emitting snippet body\n+      // ramMethod -> Should be NULL for Unresolved\n+      // cpAddress -> Filled here\n+      // cpIndex   -> Filled here\n+\n+      ccUnresolvedStaticSpecialDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+      ccUnresolvedStaticSpecialDataAddress->ramMethod = 0;\n+      ccUnresolvedStaticSpecialDataAddress->cpIndex   = static_cast<intptr_t>(callNode->getSymbolReference()->getCPIndexForVM());\n+      callSnippetCCDataAddress = reinterpret_cast<intptr_t>(ccUnresolvedStaticSpecialDataAddress);\n+      offsetOfSnippetOrCompiledMethod = static_cast<int32_t>(offsetof(ccUnresolvedStaticSpecialData, snippetOrCompiledMethod));\n+      }\n+   else\n+      {\n+      if (!(codeCacheData->put(NULL, sizeof(ccStaticSpecialData), alignof(ccStaticSpecialData), NULL, index)))\n+         {\n+         cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate metadata for static or special call\");\n+         }\n+\n+      ccStaticSpecialData *ccStaticSpecialDataAddress = codeCacheData->get<ccStaticSpecialData>(index);\n+\n+      // Shape of the ccData\n+      // snippetOrCompiledMethod -> to be updated in binary encoding while emitting snippet body\n+      // ramMethod -> Filled Here\n+      TR::MethodSymbol *methodSymbol = callSymRef->getSymbol()->castToMethodSymbol();\n+      intptr_t ramMethod;\n+#if defined(J9VM_OPT_JITSERVER)\n+      ramMethod = comp()->isOutOfProcessCompilation() && methodSymbol->isInterpreted() ?\n+                     static_cast<intptr_t>(callSymRef->getSymbol()->castToResolvedMethodSymbol()->getResolvedMethod()->getPersistentIdentifier()) :\n+                     static_cast<intptr_t>(methodSymbol->getMethodAddress());\n+#else\n+      ramMethod = reinterpret_cast<intptr_t>(methodSymbol->getMethodAddress());\n+#endif\n+      ccStaticSpecialDataAddress->ramMethod = ramMethod;\n+      callSnippetCCDataAddress = reinterpret_cast<intptr_t>(ccStaticSpecialDataAddress);\n+      offsetOfSnippetOrCompiledMethod = static_cast<int32_t>(offsetof(ccUnresolvedStaticSpecialData, snippetOrCompiledMethod));\n+      }\n+\n+   TR::LabelSymbol *snippetLabel = generateLabelSymbol(cg());\n+   TR::LabelSymbol *doneLabel = generateLabelSymbol(cg());\n+   TR::Snippet *callSnippet = new (trHeapMemory()) TR::S390J9CallSnippetRX(cg(),\n+                                                                           callNode,\n+                                                                           snippetLabel,\n+                                                                           doneLabel,\n+                                                                           callSymRef,\n+                                                                           argSize,\n+                                                                           callSnippetCCDataAddress);\n+   void *targetAddress = reinterpret_cast<void *>(callSnippetCCDataAddress + static_cast<intptr_t>(offsetOfSnippetOrCompiledMethod));\n+   TR::StaticSymbol *snippetOrCompiledSlotSymbol = TR::StaticSymbol::createWithAddress(comp()->trHeapMemory(), TR::Address, targetAddress);\n+   TR::SymbolReference *snippetOrCompiledSlotSymRef = new (comp()->trHeapMemory()) TR::SymbolReference(comp()->getSymRefTab(), snippetOrCompiledSlotSymbol, 0);\n+   snippetOrCompiledSlotSymbol->setNotDataAddress();\n+\n+   TR::RegisterDependencyConditions *preDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies->getPreConditions(), NULL,\n+                                                                                                      dependencies->getAddCursorForPre(), 0, cg());\n+\n+   int32_t numOfAdditionalPostDeps = 0;\n+   TR::Register *regRA = dependencies->searchPostConditionRegister(getReturnAddressRegister());\n+   if (regRA == NULL)\n+      {\n+      regRA = cg()->allocateRegister();\n+      numOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::Register *regEP = dependencies->searchPostConditionRegister(getEntryPointRegister());\n+   if (regEP == NULL)\n+      {\n+      regEP = cg()->allocateRegister();\n+      numOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::RegisterDependencyConditions *postDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies, 0, numOfAdditionalPostDeps, cg());\n+   postDeps->setAddCursorForPre(0);\n+   postDeps->setNumPreConditions(0, trMemory());\n+   postDeps->addPostConditionIfNotAlreadyInserted(regRA, getReturnAddressRegister());\n+   postDeps->addPostConditionIfNotAlreadyInserted(regEP, getEntryPointRegister());\n+\n+   TR::Instruction *cursor = generateS390LabelInstruction(cg(), TR::InstOpCode::LABEL, callNode, generateLabelSymbol(cg()), preDeps);\n+   cursor = generateRILInstruction(cg(), TR::InstOpCode::LGRL, callNode, regRA, snippetOrCompiledSlotSymRef, targetAddress, cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::BASR, callNode, regRA, regRA, postDeps, cursor);\n+   ((TR::S390J9CallSnippetRX *)callSnippet)->setBranchInstruction(cursor);", "originalCommit": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIzNzM3OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r526237378", "bodyText": "set branch instruction was added later so forgot to change the type. Fixed this in https://github.com/eclipse/openj9/compare/9a9d9b37daeb983c8d4e295fcc785afeecde5d78..de725983cd06ff96468a76b30321d3f8bb48caea", "author": "r30shah", "createdAt": "2020-11-18T16:42:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzMzk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNTM0Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525335342", "bodyText": "This comment is not very useful. It does not say anything more than the code already does.", "author": "fjeremic", "createdAt": "2020-11-17T17:09:47Z", "path": "runtime/compiler/z/codegen/S390J9CallSnippet.cpp", "diffHunk": "@@ -1718,3 +1720,183 @@ TR::S390InterfaceCallReadOnlySnippet::getLength(int32_t estimatedSnippetStart)\n            + sizeof(int32_t)  /*RIP offset to PICSlot data address*/\n            + sizeof(int32_t);  /*RIP offset to instruction in mainline*/\n    }\n+ \n+uint8_t *\n+TR::S390J9CallSnippetRX::emitSnippetBody()\n+   {\n+   uint8_t *cursor = cg()->getBinaryBufferCursor();\n+   TR::SymbolReference *callSymRef = getRealMethodSymbolReference();\n+   TR::Node *callNode = getNode();\n+   getSnippetLabel()->setCodeLocation(cursor);\n+   cursor = S390flushArgumentsToStack(cursor, getNode(), getSizeOfArguments(), cg());\n+\n+   //Check if the call is unresolved", "originalCommit": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIzNjU2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r526236564", "bodyText": "Removed in https://github.com/eclipse/openj9/compare/9a9d9b37daeb983c8d4e295fcc785afeecde5d78..de725983cd06ff96468a76b30321d3f8bb48caea", "author": "r30shah", "createdAt": "2020-11-18T16:41:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNTM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNjg1NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525336854", "bodyText": "Adding a new line right before a comment can go a long way to improve readability and emphasize a logical block of code. Otherwise it just looks like one giant blob of code.", "author": "fjeremic", "createdAt": "2020-11-17T17:11:49Z", "path": "runtime/compiler/z/codegen/S390J9CallSnippet.cpp", "diffHunk": "@@ -1718,3 +1720,183 @@ TR::S390InterfaceCallReadOnlySnippet::getLength(int32_t estimatedSnippetStart)\n            + sizeof(int32_t)  /*RIP offset to PICSlot data address*/\n            + sizeof(int32_t);  /*RIP offset to instruction in mainline*/\n    }\n+ \n+uint8_t *\n+TR::S390J9CallSnippetRX::emitSnippetBody()\n+   {\n+   uint8_t *cursor = cg()->getBinaryBufferCursor();\n+   TR::SymbolReference *callSymRef = getRealMethodSymbolReference();\n+   TR::Node *callNode = getNode();\n+   getSnippetLabel()->setCodeLocation(cursor);\n+   cursor = S390flushArgumentsToStack(cursor, getNode(), getSizeOfArguments(), cg());\n+\n+   //Check if the call is unresolved\n+   if (callSymRef->isUnresolved() || (cg()->comp()->compileRelocatableCode() && !cg()->comp()->getOption(TR_UseSymbolValidationManager)))\n+      {\n+      typedef J9::Z::PrivateLinkage::ccUnresolvedStaticSpecialData ccUnresolvedStaticSpecialData;\n+      ccUnresolvedStaticSpecialData *ccDataAddress = reinterpret_cast<ccUnresolvedStaticSpecialData *>(callSnippetCCDataAddress);\n+      ccDataAddress->snippetOrCompiledMethod = reinterpret_cast<intptr_t>(getSnippetLabel()->getCodeLocation());\n+      // LGRL  rEP, @(CCUnresolvedStaticOrSpecialData + ramMethod)\n+      intptr_t instrAddr = reinterpret_cast<intptr_t>(cursor);\n+      *cursor = static_cast<uint8_t>(0xC4);", "originalCommit": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIzNjQ3Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r526236472", "bodyText": "That makes sense, sorry for the mess. Tried to add more new lines to make call more readable in https://github.com/eclipse/openj9/compare/9a9d9b37daeb983c8d4e295fcc785afeecde5d78..de725983cd06ff96468a76b30321d3f8bb48caea", "author": "r30shah", "createdAt": "2020-11-18T16:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNjg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNzM4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525337381", "bodyText": "This comment looks incomplete.", "author": "fjeremic", "createdAt": "2020-11-17T17:12:38Z", "path": "runtime/compiler/z/codegen/S390J9CallSnippet.cpp", "diffHunk": "@@ -1718,3 +1720,183 @@ TR::S390InterfaceCallReadOnlySnippet::getLength(int32_t estimatedSnippetStart)\n            + sizeof(int32_t)  /*RIP offset to PICSlot data address*/\n            + sizeof(int32_t);  /*RIP offset to instruction in mainline*/\n    }\n+ \n+uint8_t *\n+TR::S390J9CallSnippetRX::emitSnippetBody()\n+   {\n+   uint8_t *cursor = cg()->getBinaryBufferCursor();\n+   TR::SymbolReference *callSymRef = getRealMethodSymbolReference();\n+   TR::Node *callNode = getNode();\n+   getSnippetLabel()->setCodeLocation(cursor);\n+   cursor = S390flushArgumentsToStack(cursor, getNode(), getSizeOfArguments(), cg());\n+\n+   //Check if the call is unresolved\n+   if (callSymRef->isUnresolved() || (cg()->comp()->compileRelocatableCode() && !cg()->comp()->getOption(TR_UseSymbolValidationManager)))\n+      {\n+      typedef J9::Z::PrivateLinkage::ccUnresolvedStaticSpecialData ccUnresolvedStaticSpecialData;\n+      ccUnresolvedStaticSpecialData *ccDataAddress = reinterpret_cast<ccUnresolvedStaticSpecialData *>(callSnippetCCDataAddress);\n+      ccDataAddress->snippetOrCompiledMethod = reinterpret_cast<intptr_t>(getSnippetLabel()->getCodeLocation());\n+      // LGRL  rEP, @(CCUnresolvedStaticOrSpecialData + ramMethod)\n+      intptr_t instrAddr = reinterpret_cast<intptr_t>(cursor);\n+      *cursor = static_cast<uint8_t>(0xC4);\n+      cursor += sizeof(uint8_t);\n+      *reinterpret_cast<int8_t *>(cursor) = static_cast<int8_t>(((cg()->getEntryPointRegister() - 1) << 4 ) + 0x8 );\n+      cursor += sizeof(int8_t);\n+      *reinterpret_cast<int32_t *>(cursor) = static_cast<int32_t>((callSnippetCCDataAddress + offsetof(ccUnresolvedStaticSpecialData, ramMethod) - instrAddr) / 2 );\n+      cursor += sizeof(int32_t);\n+\n+      // CGIJ rEP,0,Label\n+      instrAddr = reinterpret_cast<intptr_t>(cursor);\n+      *reinterpret_cast<int8_t *>(cursor) = static_cast<int8_t>(0xEC);\n+      cursor += sizeof(int8_t);\n+      *reinterpret_cast<int8_t *>(cursor) = static_cast<int16_t>(((cg()->getEntryPointRegister() - 1) << 4 ) + 0x6 );\n+      cursor += sizeof(int8_t);\n+\n+      // Now we need to calculate the instruction address for the resolved case, for now Just Skipping the 4 bytes\n+      cursor += sizeof(int32_t);\n+\n+      TR::SymbolReference *helperGlueSymRef = cg()->symRefTab()->findOrCreateRuntimeHelper(callSymRef->getSymbol()->castToMethodSymbol()->isStatic() ? TR_S390interpretedUnresolvedStaticCallGlueRX : TR_S390interpretedUnresolvedSpecialCallGlueRX,\n+                                                                                             false, false, false);\n+      TR::GlobalFunctionCallData dataDestination(helperGlueSymRef, callNode, cursor, cg(), self());\n+\n+      cursor = cg()->getObjFmt()->encodeGlobalFunctionCall(dataDestination);\n+      // Calling the Encode Global FunctionCall and now update the \n+      ", "originalCommit": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIzNjE3MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r526236170", "bodyText": "Comment was not needed, removed it in https://github.com/eclipse/openj9/compare/9a9d9b37daeb983c8d4e295fcc785afeecde5d78..de725983cd06ff96468a76b30321d3f8bb48caea", "author": "r30shah", "createdAt": "2020-11-18T16:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNzM4MQ=="}], "type": "inlineReview"}, {"oid": "de725983cd06ff96468a76b30321d3f8bb48caea", "url": "https://github.com/eclipse-openj9/openj9/commit/de725983cd06ff96468a76b30321d3f8bb48caea", "message": "Support Static and Special Direct calls on Z for Snapshot\n\nImplement patchless dispatch sequence for Direct Static or Special calls\non Z for Snahoshot configuration.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-11-18T16:40:31Z", "type": "commit"}, {"oid": "de725983cd06ff96468a76b30321d3f8bb48caea", "url": "https://github.com/eclipse-openj9/openj9/commit/de725983cd06ff96468a76b30321d3f8bb48caea", "message": "Support Static and Special Direct calls on Z for Snapshot\n\nImplement patchless dispatch sequence for Direct Static or Special calls\non Z for Snahoshot configuration.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>", "committedDate": "2020-11-18T16:40:31Z", "type": "forcePushed"}]}