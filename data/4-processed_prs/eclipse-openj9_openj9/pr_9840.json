{"pr_number": 9840, "pr_title": "Don't acquire exclusive vm access with waiting xdump", "pr_createdAt": "2020-06-10T00:53:46Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9840", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwMTc1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r438301758", "bodyText": "nit: comment closer should be on a line by itself.", "author": "keithc-ca", "createdAt": "2020-06-10T17:44:30Z", "path": "runtime/rasdump/trigger.c", "diffHunk": "@@ -555,6 +555,46 @@ prepareForDump(struct J9JavaVM *vm, struct J9RASdumpAgent *agent, struct J9RASdu\n \t\tnewState |= J9RAS_DUMP_TRACE_DISABLED;\n \t}\n \n+\t/* Release vm access until this thread has the dumpKey and is ready to run. This will allow \n+\t * other threads to obtain exclusiveVMAccess in the meantime. */", "originalCommit": "c7b4ec673c57999d4bc1a72c07980365685a904f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwMjQ0Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r438302447", "bodyText": "It isn't clear to me what is meant by 'out-time' here: please elaborate.", "author": "keithc-ca", "createdAt": "2020-06-10T17:45:37Z", "path": "runtime/rasdump/trigger.c", "diffHunk": "@@ -555,6 +555,46 @@ prepareForDump(struct J9JavaVM *vm, struct J9RASdumpAgent *agent, struct J9RASdu\n \t\tnewState |= J9RAS_DUMP_TRACE_DISABLED;\n \t}\n \n+\t/* Release vm access until this thread has the dumpKey and is ready to run. This will allow \n+\t * other threads to obtain exclusiveVMAccess in the meantime. */\n+\tvm->internalVMFunctions->internalReleaseVMAccess(vmThread);\n+\n+\t/*\n+\t * The following actions are considered safe to call during a crash situation...\n+\t */\n+\n+\t/* For fatal events, the first failing thread sets the global rasDumpFirstThread. It then gets higher priority on the\n+\t * serial dump lock, see below. This allows the first failing thread to complete its dumps and exit the VM, reducing\n+\t * the number of dumps written and out-time if multiple threads crash.", "originalCommit": "c7b4ec673c57999d4bc1a72c07980365685a904f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NTU4NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r438455584", "bodyText": "I am unclear about this phrase as well, this comment was not authored by me.\nI think it is talking about reducing the time it takes a thread to crash but I'm not sure why that would apply to 'multiple threads' specifically.", "author": "theresa-m", "createdAt": "2020-06-10T23:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwMjQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwMzcyMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r438303723", "bodyText": "This should use J9_ARE_ANY_BITS_SET().", "author": "keithc-ca", "createdAt": "2020-06-10T17:47:47Z", "path": "runtime/rasdump/trigger.c", "diffHunk": "@@ -555,6 +555,46 @@ prepareForDump(struct J9JavaVM *vm, struct J9RASdumpAgent *agent, struct J9RASdu\n \t\tnewState |= J9RAS_DUMP_TRACE_DISABLED;\n \t}\n \n+\t/* Release vm access until this thread has the dumpKey and is ready to run. This will allow \n+\t * other threads to obtain exclusiveVMAccess in the meantime. */\n+\tvm->internalVMFunctions->internalReleaseVMAccess(vmThread);\n+\n+\t/*\n+\t * The following actions are considered safe to call during a crash situation...\n+\t */\n+\n+\t/* For fatal events, the first failing thread sets the global rasDumpFirstThread. It then gets higher priority on the\n+\t * serial dump lock, see below. This allows the first failing thread to complete its dumps and exit the VM, reducing\n+\t * the number of dumps written and out-time if multiple threads crash.\n+\t */\n+\tif (0 != (context->eventFlags & (J9RAS_DUMP_ON_GP_FAULT | J9RAS_DUMP_ON_ABORT_SIGNAL | J9RAS_DUMP_ON_TRACE_ASSERT))) {", "originalCommit": "c7b4ec673c57999d4bc1a72c07980365685a904f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwNDA5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r438304091", "bodyText": "This should use J9_ARE_ANY_BITS_SET().", "author": "keithc-ca", "createdAt": "2020-06-10T17:48:24Z", "path": "runtime/rasdump/trigger.c", "diffHunk": "@@ -555,6 +555,46 @@ prepareForDump(struct J9JavaVM *vm, struct J9RASdumpAgent *agent, struct J9RASdu\n \t\tnewState |= J9RAS_DUMP_TRACE_DISABLED;\n \t}\n \n+\t/* Release vm access until this thread has the dumpKey and is ready to run. This will allow \n+\t * other threads to obtain exclusiveVMAccess in the meantime. */\n+\tvm->internalVMFunctions->internalReleaseVMAccess(vmThread);\n+\n+\t/*\n+\t * The following actions are considered safe to call during a crash situation...\n+\t */\n+\n+\t/* For fatal events, the first failing thread sets the global rasDumpFirstThread. It then gets higher priority on the\n+\t * serial dump lock, see below. This allows the first failing thread to complete its dumps and exit the VM, reducing\n+\t * the number of dumps written and out-time if multiple threads crash.\n+\t */\n+\tif (0 != (context->eventFlags & (J9RAS_DUMP_ON_GP_FAULT | J9RAS_DUMP_ON_ABORT_SIGNAL | J9RAS_DUMP_ON_TRACE_ASSERT))) {\n+\t\tcompareAndSwapUDATA(&rasDumpFirstThread, 0, dumpKey);\n+\t}\n+\n+\tif (rasDumpSuspendKey == dumpKey) {\n+\t\t/* We already have the lock */\n+\t} else {\n+\t\tUDATA newKey = 0;\n+\n+\t\t/* Grab the dump lock? */\n+\t\tif (agent->requestMask & J9RAS_DUMP_DO_SUSPEND_OTHER_DUMPS) {", "originalCommit": "c7b4ec673c57999d4bc1a72c07980365685a904f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwNDU5NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r438304595", "bodyText": "This should use J9_ARE_NO_BITS_SET().", "author": "keithc-ca", "createdAt": "2020-06-10T17:49:17Z", "path": "runtime/rasdump/trigger.c", "diffHunk": "@@ -555,6 +555,46 @@ prepareForDump(struct J9JavaVM *vm, struct J9RASdumpAgent *agent, struct J9RASdu\n \t\tnewState |= J9RAS_DUMP_TRACE_DISABLED;\n \t}\n \n+\t/* Release vm access until this thread has the dumpKey and is ready to run. This will allow \n+\t * other threads to obtain exclusiveVMAccess in the meantime. */\n+\tvm->internalVMFunctions->internalReleaseVMAccess(vmThread);\n+\n+\t/*\n+\t * The following actions are considered safe to call during a crash situation...\n+\t */\n+\n+\t/* For fatal events, the first failing thread sets the global rasDumpFirstThread. It then gets higher priority on the\n+\t * serial dump lock, see below. This allows the first failing thread to complete its dumps and exit the VM, reducing\n+\t * the number of dumps written and out-time if multiple threads crash.\n+\t */\n+\tif (0 != (context->eventFlags & (J9RAS_DUMP_ON_GP_FAULT | J9RAS_DUMP_ON_ABORT_SIGNAL | J9RAS_DUMP_ON_TRACE_ASSERT))) {\n+\t\tcompareAndSwapUDATA(&rasDumpFirstThread, 0, dumpKey);\n+\t}\n+\n+\tif (rasDumpSuspendKey == dumpKey) {\n+\t\t/* We already have the lock */\n+\t} else {\n+\t\tUDATA newKey = 0;\n+\n+\t\t/* Grab the dump lock? */\n+\t\tif (agent->requestMask & J9RAS_DUMP_DO_SUSPEND_OTHER_DUMPS) {\n+\t\t\tnewState |= J9RAS_DUMP_GOT_LOCK;\n+\t\t\tnewKey = dumpKey;\n+\t\t}\n+\n+\t\t/* Always wait for the lock, but only grab it when requested */\n+\t\twhile (compareAndSwapUDATA(&rasDumpSuspendKey, 0, newKey) != 0) {\n+\t\t\tif (rasDumpFirstThread == dumpKey) {\n+\t\t\t\t/* First failing thread gets a simple priority boost over other threads waiting for lock */\n+\t\t\t\tomrthread_sleep(20);\n+\t\t\t} else {\n+\t\t\t\tomrthread_sleep(200);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tvm->internalVMFunctions->internalAcquireVMAccess(vmThread);\n+\n \tif ((context->eventFlags & (J9RAS_DUMP_ON_GP_FAULT | J9RAS_DUMP_ON_ABORT_SIGNAL | J9RAS_DUMP_ON_TRACE_ASSERT)) == 0) {", "originalCommit": "c7b4ec673c57999d4bc1a72c07980365685a904f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM1ODA4NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r438358084", "bodyText": "We can't release vmaccess here as we don't know what state we're in.  The code below is setup to handle:\n\nunattached threads needing to attach (won't have vmaccess at this point)\nthreads that are \"inNative\"\nthreads that don't already have access\n\nThat code needs to run first to get to a stable state before we can modify the current thread's access", "author": "DanHeidinga", "createdAt": "2020-06-10T19:27:17Z", "path": "runtime/rasdump/trigger.c", "diffHunk": "@@ -555,6 +555,46 @@ prepareForDump(struct J9JavaVM *vm, struct J9RASdumpAgent *agent, struct J9RASdu\n \t\tnewState |= J9RAS_DUMP_TRACE_DISABLED;\n \t}\n \n+\t/* Release vm access until this thread has the dumpKey and is ready to run. This will allow \n+\t * other threads to obtain exclusiveVMAccess in the meantime. */\n+\tvm->internalVMFunctions->internalReleaseVMAccess(vmThread);", "originalCommit": "c7b4ec673c57999d4bc1a72c07980365685a904f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0MjE4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r438442188", "bodyText": "I see the problem with that.\nFrom what I can tell though the vm access state is only being stabilized for the J9RAS_DUMP_DO_EXCLUSIVE_VM_ACCESS case here\nI think instead those cases can be checked before calling internalReleaseVMAccess here.", "author": "theresa-m", "createdAt": "2020-06-10T22:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM1ODA4NA=="}], "type": "inlineReview"}, {"oid": "7ea280e00050e08ceaed599bf44e55e8b700f2f6", "url": "https://github.com/eclipse-openj9/openj9/commit/7ea280e00050e08ceaed599bf44e55e8b700f2f6", "message": "Can't acquire exclusive vm access with waiting xdump\n\nPending xdump threads are waiting in such a way that blocks other threads from acquiring exclusive vm access. The threads wait to acquire a key until the running xdump thread finishes and hold shared vm access while spinning.\n\nSolution:\n- release vm access while waiting for dumpKey so other threads can acquire exclusive vm access\n- moved dumpKey acquire first in prepareForDump so no differentiation between J9RAS_DUMP_DO_SUSPEND_OTHER_DUMPS and J9RAS_DUMP_DO_EXCLUSIVE_VM_ACCESS is needed\n- re-order events in unwindAfterDump to match the reverse order of prepareForDump\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-06-10T23:29:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5NTg5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r438495891", "bodyText": "This is closer but we still need to take isNative into account as I believe we have vmaccess but be in native.  @gacholio", "author": "DanHeidinga", "createdAt": "2020-06-11T01:39:01Z", "path": "runtime/rasdump/trigger.c", "diffHunk": "@@ -555,7 +556,53 @@ prepareForDump(struct J9JavaVM *vm, struct J9RASdumpAgent *agent, struct J9RASdu\n \t\tnewState |= J9RAS_DUMP_TRACE_DISABLED;\n \t}\n \n-\tif ((context->eventFlags & (J9RAS_DUMP_ON_GP_FAULT | J9RAS_DUMP_ON_ABORT_SIGNAL | J9RAS_DUMP_ON_TRACE_ASSERT)) == 0) {\n+\t/* Release vm access until this thread has the dumpKey and is ready to run. This will allow other threads to obtain exclusiveVMAccess in the meantime. */\n+\tif (vmThread) {\n+\t\tif (vmThread->publicFlags & J9_PUBLIC_FLAGS_VM_ACCESS) {", "originalCommit": "7ea280e00050e08ceaed599bf44e55e8b700f2f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2NjE5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r438866194", "bodyText": "I'll take a detailed look before the end of the week.", "author": "gacholio", "createdAt": "2020-06-11T15:22:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5NTg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4ODg5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r438988894", "bodyText": "There's code in here that's already assuming we're in the JNI context when this function is running (calls AttachCurrentThreadAsDaemon) - what is the actual context when this is called? There are 3 possibilities:\n\ninNative (i.e. JNI)\nnot inNative, have VM access\nnot inNative, don't have VM access", "author": "gacholio", "createdAt": "2020-06-11T18:29:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5NTg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MTkzMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r439081930", "bodyText": "ah. I see now the difference with inNative is with atomic_free_jni. I will update that case.", "author": "theresa-m", "createdAt": "2020-06-11T21:32:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5NTg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA5NTc2MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r439095761", "bodyText": "updated.", "author": "theresa-m", "createdAt": "2020-06-11T22:00:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5NTg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4OTQ3MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r439189470", "bodyText": "I'm wrong about the attach case - that's for a signal on a thread not attached to the VM at all (so not the typical \"JNI context\"). The code has to handle atomic-free in the same way as below - detect and save the state so it can be restored later.", "author": "gacholio", "createdAt": "2020-06-12T03:37:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5NTg5MQ=="}], "type": "inlineReview"}, {"oid": "83a5c0476055905276ab3279be17c0117f960bf4", "url": "https://github.com/eclipse-openj9/openj9/commit/83a5c0476055905276ab3279be17c0117f960bf4", "message": "Can't acquire exclusive vm access with waiting xdump\n\nPending xdump threads are waiting in such a way that blocks other threads from acquiring exclusive vm access. The threads wait to acquire a key until the running xdump thread finishes and hold shared vm access while spinning.\n\nSolution:\n- release vm access while waiting for dumpKey so other threads can acquire exclusive vm access\n- moved dumpKey acquire first in prepareForDump so no differentiation between J9RAS_DUMP_DO_SUSPEND_OTHER_DUMPS and J9RAS_DUMP_DO_EXCLUSIVE_VM_ACCESS is needed\n- re-order events in unwindAfterDump to match the reverse order of prepareForDump\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-06-11T21:59:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2NjExMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r439366112", "bodyText": "This is still not correct - please follow the pattern below.", "author": "gacholio", "createdAt": "2020-06-12T11:33:40Z", "path": "runtime/rasdump/trigger.c", "diffHunk": "@@ -555,7 +556,61 @@ prepareForDump(struct J9JavaVM *vm, struct J9RASdumpAgent *agent, struct J9RASdu\n \t\tnewState |= J9RAS_DUMP_TRACE_DISABLED;\n \t}\n \n-\tif ((context->eventFlags & (J9RAS_DUMP_ON_GP_FAULT | J9RAS_DUMP_ON_ABORT_SIGNAL | J9RAS_DUMP_ON_TRACE_ASSERT)) == 0) {\n+\t/* Release vm access until this thread has the dumpKey and is ready to run. This will allow other threads to obtain exclusiveVMAccess in the meantime. */\n+\tif (vmThread) {\n+\t\tif (J9_ARE_ANY_BITS_SET(vmThread->publicFlags, J9_PUBLIC_FLAGS_VM_ACCESS)) {", "originalCommit": "83a5c0476055905276ab3279be17c0117f960bf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQyNzg2OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r439427869", "bodyText": "Strictly speaking, you don't need to do anything if inNative is true - the thread will not block exclusive. That should simplify the code.\nif (!inNative) {\n   if (vm access) {\n      release and set your variable\n   }\n}", "author": "gacholio", "createdAt": "2020-06-12T13:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2NjExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2MTMzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r439461338", "bodyText": "And when reacquiring access, you need only check the local variable and call acquire - no need for any enter/exit VM in this change.\nIt's safe to check !inNative without an ifdef, as the field always exists and will always be 0 in VMs which have not been updated for atomic-free JNI.", "author": "gacholio", "createdAt": "2020-06-12T14:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2NjExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzNDA1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r439534055", "bodyText": "Thanks for the review @gacholio I've updated the change with the pattern you suggested.", "author": "theresa-m", "createdAt": "2020-06-12T16:52:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2NjExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ1OTg0MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r439459841", "bodyText": "Should be 0 !=", "author": "gacholio", "createdAt": "2020-06-12T14:39:30Z", "path": "runtime/rasdump/trigger.c", "diffHunk": "@@ -555,7 +556,61 @@ prepareForDump(struct J9JavaVM *vm, struct J9RASdumpAgent *agent, struct J9RASdu\n \t\tnewState |= J9RAS_DUMP_TRACE_DISABLED;\n \t}\n \n-\tif ((context->eventFlags & (J9RAS_DUMP_ON_GP_FAULT | J9RAS_DUMP_ON_ABORT_SIGNAL | J9RAS_DUMP_ON_TRACE_ASSERT)) == 0) {\n+\t/* Release vm access until this thread has the dumpKey and is ready to run. This will allow other threads to obtain exclusiveVMAccess in the meantime. */\n+\tif (vmThread) {\n+\t\tif (J9_ARE_ANY_BITS_SET(vmThread->publicFlags, J9_PUBLIC_FLAGS_VM_ACCESS)) {\n+\t\t\tif (vmThread->inNative) {\n+\t\t\t\tvm->internalVMFunctions->internalExitVMToJNI(vmThread);\n+\t\t\t} else {\n+\t\t\t\tvm->internalVMFunctions->internalReleaseVMAccess(vmThread);\n+\t\t\t}\n+\t\t\tacquireVMAccessAfterWait = TRUE;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * The following actions are considered safe to call during a crash situation...\n+\t */\n+\n+\t/* For fatal events, the first failing thread sets the global rasDumpFirstThread. It then gets higher priority on the\n+\t * serial dump lock, see below. This allows the first failing thread to complete its dumps and exit the VM, reducing\n+\t * the number of dumps written and out-time if multiple threads crash.\n+\t */\n+\tif (J9_ARE_ANY_BITS_SET(context->eventFlags, J9RAS_DUMP_ON_GP_FAULT | J9RAS_DUMP_ON_ABORT_SIGNAL | J9RAS_DUMP_ON_TRACE_ASSERT)) {\n+\t\tcompareAndSwapUDATA(&rasDumpFirstThread, 0, dumpKey);\n+\t}\n+\n+\tif (rasDumpSuspendKey == dumpKey) {\n+\t\t/* We already have the lock */\n+\t} else {\n+\t\tUDATA newKey = 0;\n+\n+\t\t/* Grab the dump lock? */\n+\t\tif (J9_ARE_ANY_BITS_SET(agent->requestMask, J9RAS_DUMP_DO_SUSPEND_OTHER_DUMPS)) {\n+\t\t\tnewState |= J9RAS_DUMP_GOT_LOCK;\n+\t\t\tnewKey = dumpKey;\n+\t\t}\n+\n+\t\t/* Always wait for the lock, but only grab it when requested */\n+\t\twhile (compareAndSwapUDATA(&rasDumpSuspendKey, 0, newKey) != 0) {", "originalCommit": "83a5c0476055905276ab3279be17c0117f960bf4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3164fc98a7e32cbcac6849c53c991d51e8a0661d", "url": "https://github.com/eclipse-openj9/openj9/commit/3164fc98a7e32cbcac6849c53c991d51e8a0661d", "message": "Can't acquire exclusive vm access with waiting xdump\n\nPending xdump threads are waiting in such a way that blocks other threads from acquiring exclusive vm access. The threads wait to acquire a key until the running xdump thread finishes and hold shared vm access while spinning.\n\nSolution:\n- release vm access while waiting for dumpKey so other threads can acquire exclusive vm access\n- moved dumpKey acquire first in prepareForDump so no differentiation between J9RAS_DUMP_DO_SUSPEND_OTHER_DUMPS and J9RAS_DUMP_DO_EXCLUSIVE_VM_ACCESS is needed\n- re-order events in unwindAfterDump to match the reverse order of prepareForDump\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-06-12T16:49:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0MTMyMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r439541323", "bodyText": "I would prefer NULL != vmThread here, but the old-style is used throughout the file, so I won't insist.", "author": "gacholio", "createdAt": "2020-06-12T17:06:51Z", "path": "runtime/rasdump/trigger.c", "diffHunk": "@@ -555,7 +556,53 @@ prepareForDump(struct J9JavaVM *vm, struct J9RASdumpAgent *agent, struct J9RASdu\n \t\tnewState |= J9RAS_DUMP_TRACE_DISABLED;\n \t}\n \n-\tif ((context->eventFlags & (J9RAS_DUMP_ON_GP_FAULT | J9RAS_DUMP_ON_ABORT_SIGNAL | J9RAS_DUMP_ON_TRACE_ASSERT)) == 0) {\n+\t/* Release vm access until this thread has the dumpKey and is ready to run. This will allow other threads to obtain exclusiveVMAccess in the meantime. */\n+\tif (vmThread && !vmThread->inNative) {", "originalCommit": "3164fc98a7e32cbcac6849c53c991d51e8a0661d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0ODA1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9840#discussion_r439548051", "bodyText": "updated with that change", "author": "theresa-m", "createdAt": "2020-06-12T17:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0MTMyMw=="}], "type": "inlineReview"}, {"oid": "79aa969364a019c82ed375b71bffbf945746bb94", "url": "https://github.com/eclipse-openj9/openj9/commit/79aa969364a019c82ed375b71bffbf945746bb94", "message": "Can't acquire exclusive vm access with waiting xdump\n\nPending xdump threads are waiting in such a way that blocks other threads from acquiring exclusive vm access. The threads wait to acquire a key until the running xdump thread finishes and hold shared vm access while spinning.\n\nSolution:\n- release vm access while waiting for dumpKey so other threads can acquire exclusive vm access\n- moved dumpKey acquire first in prepareForDump so no differentiation between J9RAS_DUMP_DO_SUSPEND_OTHER_DUMPS and J9RAS_DUMP_DO_EXCLUSIVE_VM_ACCESS is needed\n- re-order events in unwindAfterDump to match the reverse order of prepareForDump\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-06-12T17:20:57Z", "type": "commit"}, {"oid": "79aa969364a019c82ed375b71bffbf945746bb94", "url": "https://github.com/eclipse-openj9/openj9/commit/79aa969364a019c82ed375b71bffbf945746bb94", "message": "Can't acquire exclusive vm access with waiting xdump\n\nPending xdump threads are waiting in such a way that blocks other threads from acquiring exclusive vm access. The threads wait to acquire a key until the running xdump thread finishes and hold shared vm access while spinning.\n\nSolution:\n- release vm access while waiting for dumpKey so other threads can acquire exclusive vm access\n- moved dumpKey acquire first in prepareForDump so no differentiation between J9RAS_DUMP_DO_SUSPEND_OTHER_DUMPS and J9RAS_DUMP_DO_EXCLUSIVE_VM_ACCESS is needed\n- re-order events in unwindAfterDump to match the reverse order of prepareForDump\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-06-12T17:20:57Z", "type": "forcePushed"}]}