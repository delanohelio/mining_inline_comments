{"pr_number": 9076, "pr_title": "Handle race condition in outOfLineINL", "pr_createdAt": "2020-04-01T20:37:42Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9076", "timeline": [{"oid": "d3f9ce6be5c884dcf2c764dadda66201e905deb0", "url": "https://github.com/eclipse-openj9/openj9/commit/d3f9ce6be5c884dcf2c764dadda66201e905deb0", "message": "Handle race condition in outOfLineINL\n\nIn the below example, compareAndExchangeRelease translates to an\nOutOfLine INL method named\nOutOfLineINL_jdk_internal_misc_Unsafe_compareAndExchangeIntVolatile.\n\nExample:\nInstFieldVH <- InstanceFieldVarHandle provides access to an int field in\nan object.\n1000 threads concurrently execute {\n\tint old, new;\n\tdo {\n\t\told = (int)InstFieldVH.getVolatile(object);\n\t\tnew = old + 2;\n\t} while (old != InstFieldVH.compareAndExchangeRelease(object, old,\nnew));\n}\n\nThere is a race condition between 1) invoking the target method in\nBytecodeInterpreter.hpp::outOfLineINL; and 2) resolving the native\naddress (J9Method->extra) of the target method in\nBytecodeInterpreter.hpp::bindNative.\n\nDue to the race condition, the native address of the target method may\nnot be resolved when certain threads invoke outOfLineINL. In such cases,\noutOfLineINL should resolve the native address before proceeding. \n\nbindnatv.cpp::resolveNativeAddress - The code to resolve the native\naddress is protected by the J9JavaVM->bindNativeMutex. So, it can be\nsafely invoked by multiple threads. If the native address is already\nresolved, then it returns without repeating the resolution process.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-04-03T15:00:18Z", "type": "commit"}, {"oid": "d3f9ce6be5c884dcf2c764dadda66201e905deb0", "url": "https://github.com/eclipse-openj9/openj9/commit/d3f9ce6be5c884dcf2c764dadda66201e905deb0", "message": "Handle race condition in outOfLineINL\n\nIn the below example, compareAndExchangeRelease translates to an\nOutOfLine INL method named\nOutOfLineINL_jdk_internal_misc_Unsafe_compareAndExchangeIntVolatile.\n\nExample:\nInstFieldVH <- InstanceFieldVarHandle provides access to an int field in\nan object.\n1000 threads concurrently execute {\n\tint old, new;\n\tdo {\n\t\told = (int)InstFieldVH.getVolatile(object);\n\t\tnew = old + 2;\n\t} while (old != InstFieldVH.compareAndExchangeRelease(object, old,\nnew));\n}\n\nThere is a race condition between 1) invoking the target method in\nBytecodeInterpreter.hpp::outOfLineINL; and 2) resolving the native\naddress (J9Method->extra) of the target method in\nBytecodeInterpreter.hpp::bindNative.\n\nDue to the race condition, the native address of the target method may\nnot be resolved when certain threads invoke outOfLineINL. In such cases,\noutOfLineINL should resolve the native address before proceeding. \n\nbindnatv.cpp::resolveNativeAddress - The code to resolve the native\naddress is protected by the J9JavaVM->bindNativeMutex. So, it can be\nsafely invoked by multiple threads. If the native address is already\nresolved, then it returns without repeating the resolution process.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-04-03T15:00:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1MjM0NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9076#discussion_r403252345", "bodyText": "Do you need this here? It seems the callers are all doing it. While it's harmless to do more than once in a row, it's definitely unnecessary.", "author": "gacholio", "createdAt": "2020-04-03T19:06:05Z", "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -2019,40 +2019,50 @@ obj:;\n \t}\n \n \tVMINLINE VM_BytecodeAction\n-\tbindNative(REGISTER_ARGS_LIST)\n+\tresolveNativeAddressWithErrorHandling()\n \t{\n-\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n-\t\tbuildMethodFrame(REGISTER_ARGS, _sendMethod, jitStackFrameFlags(REGISTER_ARGS, 0));\n-\t\tupdateVMStruct(REGISTER_ARGS);\n \t\tUDATA bindRC = resolveNativeAddress(_currentThread, _sendMethod, TRUE);\n \t\tif (J9_NATIVE_METHOD_BIND_OUT_OF_MEMORY == bindRC) {\n \t\t\t_vm->memoryManagerFunctions->j9gc_modron_global_collect_with_overrides(_currentThread, J9MMCONSTANT_EXPLICIT_GC_NATIVE_OUT_OF_MEMORY);\n \t\t\tbindRC = resolveNativeAddress(_currentThread, _sendMethod, TRUE);\n \t\t}\n-\t\tswitch(bindRC) {\n-\t\tcase J9_NATIVE_METHOD_BIND_SUCCESS: {\n-\t\t\tVMStructHasBeenUpdated(REGISTER_ARGS);\n-\t\t\tJ9SFMethodFrame *methodFrame = (J9SFMethodFrame*)_sp;\n-\t\t\t_currentThread->jitStackFrameFlags = methodFrame->specialFrameFlags & J9_SSF_JIT_NATIVE_TRANSITION_FRAME;\n-\t\t\trestoreSpecialStackFrameLeavingArgs(REGISTER_ARGS, ((UDATA*)(methodFrame + 1)) - 1);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase J9_NATIVE_METHOD_BIND_OUT_OF_MEMORY:\n-\t\t\tsetNativeBindOutOfMemoryError(_currentThread, _sendMethod);\n-\t\t\tVMStructHasBeenUpdated(REGISTER_ARGS);", "originalCommit": "d3f9ce6be5c884dcf2c764dadda66201e905deb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1MjUzMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9076#discussion_r403252533", "bodyText": "Oops, looking at the remove code...", "author": "gacholio", "createdAt": "2020-04-03T19:06:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1MjM0NQ=="}], "type": "inlineReview"}]}