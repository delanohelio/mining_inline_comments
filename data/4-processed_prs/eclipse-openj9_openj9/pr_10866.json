{"pr_number": 10866, "pr_title": "Remove J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro", "pr_createdAt": "2020-10-09T22:42:10Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10866", "timeline": [{"oid": "70d1589d85637102f3aca4af44101883738236a8", "url": "https://github.com/eclipse-openj9/openj9/commit/70d1589d85637102f3aca4af44101883738236a8", "message": "Align Copyright header\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>", "committedDate": "2020-10-09T22:54:58Z", "type": "forcePushed"}, {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "url": "https://github.com/eclipse-openj9/openj9/commit/8f5d420218bc4ccec6f2887401666a572f1a5de6", "message": "Fix CompositeCacheSizesTests\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>", "committedDate": "2020-10-10T21:11:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkzNDYxMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r503934612", "bodyText": "This change is unnecessary.", "author": "pshipton", "createdAt": "2020-10-13T13:07:10Z", "path": "runtime/shared_common/CompiledMethodManagerImpl.cpp", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2001, 2019 IBM Corp. and others\n+ * Copyright (c) 2001, 2020 IBM Corp. and others", "originalCommit": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk5MTQzNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r503991436", "bodyText": "Copyright Check would fail instead, right?", "author": "alexey-anufriev", "createdAt": "2020-10-13T14:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkzNDYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAwNzQwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504007407", "bodyText": "It's the only change in this file, so the copyright doesn't need to be updated.", "author": "pshipton", "createdAt": "2020-10-13T14:39:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkzNDYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAwOTE5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504009192", "bodyText": "Probably I touched it somehow, but then reverted the change. In any case I can revert it.", "author": "alexey-anufriev", "createdAt": "2020-10-13T14:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkzNDYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwNjYzMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504806630", "bodyText": "Reverted.", "author": "alexey-anufriev", "createdAt": "2020-10-14T16:17:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkzNDYxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkzNjk5Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r503936996", "bodyText": "It's policy to keep existing tracepoint numbers the same, meaning that older tracepoint can't be deleted. They can be updated with the Obsolete keyword.", "author": "pshipton", "createdAt": "2020-10-13T13:10:42Z", "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1804,37 +1804,6 @@ TraceException=Trc_SHR_RMI_compareROMClasses_NoCachelet Overhead=1 Level=1 Templ\n TraceEntry=Trc_SHR_INIT_hookSerializeSharedCache_entry Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Entering hookSerializeSharedCache\"\n TraceExit=Trc_SHR_INIT_hookSerializeSharedCache_exit Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Exiting hookSerializeSharedCache\"\n \n-TraceEntry=Trc_SHR_OSC_Vmem_startup_Entry NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Entering cache name = %s, control dir = %s, cache size = %zu, numSems = %zd, create flags = 0x%zx, verbose flags = 0x%zx, openFlags = 0x%x\"", "originalCommit": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwNjk0NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504806945", "bodyText": "Didn't know that. Reverted.", "author": "alexey-anufriev", "createdAt": "2020-10-14T16:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkzNjk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkzOTg4NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r503939884", "bodyText": "This change is unnecessary.", "author": "pshipton", "createdAt": "2020-10-13T13:14:44Z", "path": "runtime/tests/shared/SCStoreTransactionTests.hpp", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2001, 2014 IBM Corp. and others\n+ * Copyright (c) 2001, 2020 IBM Corp. and others", "originalCommit": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk5MTc1Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r503991752", "bodyText": "Copyright Check would fail instead, right?", "author": "alexey-anufriev", "createdAt": "2020-10-13T14:19:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkzOTg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAwNzcyMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504007723", "bodyText": "It's the only change in this file, so the copyright doesn't need to be updated.", "author": "pshipton", "createdAt": "2020-10-13T14:39:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkzOTg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAwOTA1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504009056", "bodyText": "Probably I touched it somehow, but then reverted the change. In any case I can revert it.", "author": "alexey-anufriev", "createdAt": "2020-10-13T14:41:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkzOTg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwNzIwMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504807203", "bodyText": "Reverted.", "author": "alexey-anufriev", "createdAt": "2020-10-14T16:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkzOTg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk0MjA4Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r503942086", "bodyText": "The deletion is backwards here.", "author": "pshipton", "createdAt": "2020-10-13T13:17:06Z", "path": "runtime/tests/shared/CorruptCacheTest.cpp", "diffHunk": "@@ -1044,61 +1009,48 @@ testCorruptCache(J9JavaVM* vm)\n \t\tswitch (i) {\n \t\tcase 0:\n #if !defined(J9ZOS390)\n-#if !defined(J9SHR_CACHELET_SUPPORT)\n \t\t\tcacheType = J9PORT_SHR_CACHE_TYPE_PERSISTENT;\n \t\t\tcacheTypeString = \"J9PORT_SHR_CACHE_TYPE_PERSISTENT\";\n-#else\n-\t\t\tcacheType = J9PORT_SHR_CACHE_TYPE_VMEM;\n-\t\t\tcacheTypeString = \"J9PORT_SHR_CACHE_TYPE_VMEM\";\n-#endif\n \t\t\treadOnly = false;\n \t\t\textraRuntimeFlags |= J9SHR_RUNTIMEFLAG_DISABLE_CORRUPT_CACHE_DUMPS;\n #endif\n \t\t\tbreak;\n \t\tcase 1:\n-#if !defined(J9SHR_CACHELET_SUPPORT)\n \t\t\tcacheType = J9PORT_SHR_CACHE_TYPE_NONPERSISTENT;\n \t\t\tcacheTypeString = \"J9PORT_SHR_CACHE_TYPE_NONPERSISTENT\";\n \t\t\treadOnly = false;\n \t\t\textraRuntimeFlags |= J9SHR_RUNTIMEFLAG_DISABLE_CORRUPT_CACHE_DUMPS;\n-#endif\n+\n \t\t\tbreak;\n \t\tcase 2:\n #if !(defined(J9ZOS390))\n-#if !defined(J9SHR_CACHELET_SUPPORT)\n-\t\t\tcacheType = J9PORT_SHR_CACHE_TYPE_PERSISTENT;\n-\t\t\tcacheTypeString = \"J9PORT_SHR_CACHE_TYPE_PERSISTENT\";\n-#else\n \t\t\tcacheType = J9PORT_SHR_CACHE_TYPE_VMEM;", "originalCommit": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMDExNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504810115", "bodyText": "Fixed.", "author": "alexey-anufriev", "createdAt": "2020-10-14T16:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk0MjA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA0ODI1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504048250", "bodyText": "I believe _cacheletCntr, _cacheletTail, _cacheletHead, _runningNested, _growEnabled, _isSerialized a few lines above can be removed.", "author": "hangshao0", "createdAt": "2020-10-13T15:29:25Z", "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -295,13 +295,7 @@ SH_CacheMap::initialize(J9JavaVM* vm, J9SharedClassConfig* sharedClassConfig, Bl\n \t_isSerialized = false;\n \t_isAssertEnabled = true;\n \t_metadataReleased = false;\n-\t", "originalCommit": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg4MDc3Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504880776", "bodyText": "Removed.", "author": "alexey-anufriev", "createdAt": "2020-10-14T18:20:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA0ODI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1MDIxOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504050218", "bodyText": "The trace point Trc_SHR_CM_readCache_initCacheletFailed can be marked as Obsolete at j9shr.tdf.", "author": "hangshao0", "createdAt": "2020-10-13T15:31:31Z", "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -1276,47 +1207,6 @@ SH_CacheMap::readCache(J9VMThread* currentThread, SH_CompositeCacheImpl* cache,\n \t\t\t\t\tTrc_SHR_Assert_ShouldNeverHappen();\n \t\t\t\t\tresult = CM_READ_CACHE_FAILED;\n \t\t\t\t}\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\t\t\t\t/* Initialize cachelets, but don't start them up */\n-\t\t\t\tif ((cache == _cc) && (itemType == TYPE_CACHELET)) {\n-\t\t\t\t\tCacheletWrapper* wrapper = (CacheletWrapper*)ITEMDATA(it);\n-\t\t\t\t\tBlockPtr cacheletMemory = (BlockPtr)CLETDATA(wrapper);\n-\t\t\t\t\tSH_CompositeCacheImpl* cachelet = _cacheletHead; /* this list currently spans all supercaches */\n-\t\t\t\t\twhile (cachelet) {\n-\t\t\t\t\t\tif (cachelet->getNestedMemory() == cacheletMemory) {\n-\t\t\t\t\t\t\t/* cachelet is already initialized */\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcachelet = cachelet->getNext();\n-\t\t\t\t\t}\n-\t\t\t\t\t\n-\t\t\t\t\tif (cachelet == NULL) {\n-\t\t\t\t\t\tif (!(cachelet = initCachelet(currentThread, (BlockPtr)cacheletMemory, false))) {\n-\t\t\t\t\t\t\tTrc_SHR_CM_readCache_initCacheletFailed(currentThread, cacheletMemory);", "originalCommit": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyMTA5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504821091", "bodyText": "Marked.", "author": "alexey-anufriev", "createdAt": "2020-10-14T16:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1MDIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1MDk0MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504050940", "bodyText": "This trace point can also be mark as Obsolete in j9shr.tdf.", "author": "hangshao0", "createdAt": "2020-10-13T15:32:19Z", "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -1276,47 +1207,6 @@ SH_CacheMap::readCache(J9VMThread* currentThread, SH_CompositeCacheImpl* cache,\n \t\t\t\t\tTrc_SHR_Assert_ShouldNeverHappen();\n \t\t\t\t\tresult = CM_READ_CACHE_FAILED;\n \t\t\t\t}\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\t\t\t\t/* Initialize cachelets, but don't start them up */\n-\t\t\t\tif ((cache == _cc) && (itemType == TYPE_CACHELET)) {\n-\t\t\t\t\tCacheletWrapper* wrapper = (CacheletWrapper*)ITEMDATA(it);\n-\t\t\t\t\tBlockPtr cacheletMemory = (BlockPtr)CLETDATA(wrapper);\n-\t\t\t\t\tSH_CompositeCacheImpl* cachelet = _cacheletHead; /* this list currently spans all supercaches */\n-\t\t\t\t\twhile (cachelet) {\n-\t\t\t\t\t\tif (cachelet->getNestedMemory() == cacheletMemory) {\n-\t\t\t\t\t\t\t/* cachelet is already initialized */\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcachelet = cachelet->getNext();\n-\t\t\t\t\t}\n-\t\t\t\t\t\n-\t\t\t\t\tif (cachelet == NULL) {\n-\t\t\t\t\t\tif (!(cachelet = initCachelet(currentThread, (BlockPtr)cacheletMemory, false))) {\n-\t\t\t\t\t\t\tTrc_SHR_CM_readCache_initCacheletFailed(currentThread, cacheletMemory);\n-\t\t\t\t\t\t\tresult = CM_READ_CACHE_FAILED;\n-\t\t\t\t\t\t\tgoto readCache_stop;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tTrc_SHR_CM_readCache_initCachelet(currentThread, cachelet, cacheletMemory);", "originalCommit": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyMTkxMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504821912", "bodyText": "Marked.", "author": "alexey-anufriev", "createdAt": "2020-10-14T16:41:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1MDk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1MzY3NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504053675", "bodyText": "This trace point can be mark as Obsolete.", "author": "hangshao0", "createdAt": "2020-10-13T15:35:42Z", "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -5836,993 +5644,6 @@ SH_CacheMap::getAttachedDataManager(J9VMThread* currentThread)\n \treturn NULL;\n }\n \n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-UDATA\n-SH_CacheMap::startAllManagers(J9VMThread* currentThread)\n-{\n-\tif (getScopeManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getClasspathManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getROMClassManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getByteDataManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getCompiledMethodManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\treturn 1;\n-}\n-\n-#endif /* J9SHR_CACHELET_SUPPORT */\n-\n-\t/************************************** STUFF EXCLUSIVE TO CACHELETS *********************************/\n-\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-SH_CompositeCacheImpl*\n-SH_CacheMap::initCachelet(J9VMThread* currentThread, BlockPtr existingCacheletMemory, bool creatingCachelet) \n-{\n-\tvoid* ccMem = pool_newElement(_ccPool);\n-\tSH_CompositeCacheImpl* newCachelet;\n-\t\n-\tif (ccMem == NULL) {\n-\t\t/* TODO: Tracepoint */\n-\t\treturn NULL;\n-\t}\n-\tif ((_cacheletHead == NULL) && (startAllManagers(currentThread) == 0)) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tnewCachelet = SH_CompositeCacheImpl::newInstanceNested(currentThread->javaVM, _cc, (SH_CompositeCacheImpl*)ccMem, J9SHR_DEFAULT_CACHELET_SIZE, existingCacheletMemory, creatingCachelet);\n-\tif (!newCachelet) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tif (_cacheletHead != NULL) {\n-\t\t_cacheletTail->setNext((SH_CompositeCacheImpl*)newCachelet);\n-\t} else {\n-\t\t_cacheletHead = _ccCacheletHead = (SH_CompositeCacheImpl*)newCachelet;\n-\t}\n-\t_cacheletTail = (SH_CompositeCacheImpl*)newCachelet;\n-\treturn newCachelet;\n-}\n-\n-/* TODO: Check that we are checking for CC_STARTUP_CORRUPT */\n-/* THREADING: Does not require the cache write mutex */\n-IDATA\n-SH_CacheMap::startupCachelet(J9VMThread* currentThread, SH_CompositeCache* cachelet)\n-{\n-\tIDATA rc;\n-\t\n-\t/* Because starting up a cachelet might require the write mutex,\n-\t * we can't have the refresh mutex here.\n-\t */\n-\trc = ((SH_CompositeCacheImpl*)cachelet)->startupNested(currentThread);\n-\tif (rc == CC_STARTUP_OK) {\n-\t\tif (sanityWalkROMClassSegment(currentThread, (SH_CompositeCacheImpl*)cachelet) == 0) {\n-\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t}\n-\t\tif (rc == CC_STARTUP_OK) {\n-\t\t\tbool hasClassSegmentMutex = \n-\t\t\t\t(omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);\n-\t\t\t/* This is harmless if segments were already initialized. */\n-\t\t\tif (-1 ==  refreshHashtables(currentThread, hasClassSegmentMutex)) {\n-\t\t\t\tif ( _ccHead->isCacheCorrupt()) {\n-\t\t\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t\t\t} else {\n-\t\t\t\t\trc = CC_STARTUP_FAILED;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif (CC_STARTUP_CORRUPT == rc) {\n-\t\treportCorruptCache(currentThread, _ccHead);\n-\t}\n-\n-\treturn rc;\n-}\n-\n-/* THREADING: Must have cache write mutex */\n-SH_CompositeCacheImpl*\n-SH_CacheMap::createNewCachelet(J9VMThread* currentThread) \n-{\n-\tJ9SharedDataDescriptor descriptor;\n-\tSH_Manager* localBDM;\n-\tBlockPtr cacheletMemory;\n-\tSH_CompositeCacheImpl* returnVal = NULL;\n-\tJ9JavaVM* vm = currentThread->javaVM;\n-\tbool createdNewChainedCache = false;\n-\tIDATA i;\n-\t\n-\tTrc_SHR_CM_createNewCachelet_Entry(currentThread);\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\n-\t/* Assume that the manager is started */\n-\tlocalBDM = managers()->getManagerForDataType(TYPE_BYTE_DATA);\n-\tdescriptor.address = 0;\n-\tdescriptor.type = J9SHR_DATA_TYPE_CACHELET;\n-\tdescriptor.length = J9SHR_DEFAULT_CACHELET_SIZE;\n-\tdescriptor.flags = (J9SHRDATA_ALLOCATE_ZEROD_MEMORY | J9SHRDATA_NOT_INDEXED);\n-\n-\tfor (i=0; i<2; i++) {\n-\t\tcacheletMemory = (BlockPtr)addByteDataToCache(currentThread, localBDM, NULL, &descriptor, NULL, true);\n-\n-\t\tif (cacheletMemory != NULL) {\n-\t\t\treturnVal = initCachelet(currentThread, cacheletMemory, true);\n-\t\t\tif (returnVal) {\n-\t\t\t\tif (startupCachelet(currentThread, returnVal) == CC_STARTUP_OK) {\n-\t\t\t\t\tif (createdNewChainedCache) {\n-\t\t\t\t\t\tJ9SharedInvariantInternTable *stringTable = vm->sharedInvariantInternTable;\n-\t\t\t\t\t\t_ccCacheletHead = returnVal;\n-\t\t\t\t\t\tif (!initializeROMSegmentList(currentThread)) {\n-\t\t\t\t\t\t\t/* TODO: handle this correctly */\n-\t\t\t\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);", "originalCommit": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyMjIxMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504822212", "bodyText": "Marked.", "author": "alexey-anufriev", "createdAt": "2020-10-14T16:41:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1MzY3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1MzY5OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504053698", "bodyText": "This trace point can be mark as Obsolete.", "author": "hangshao0", "createdAt": "2020-10-13T15:35:44Z", "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -5836,993 +5644,6 @@ SH_CacheMap::getAttachedDataManager(J9VMThread* currentThread)\n \treturn NULL;\n }\n \n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-UDATA\n-SH_CacheMap::startAllManagers(J9VMThread* currentThread)\n-{\n-\tif (getScopeManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getClasspathManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getROMClassManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getByteDataManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getCompiledMethodManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\treturn 1;\n-}\n-\n-#endif /* J9SHR_CACHELET_SUPPORT */\n-\n-\t/************************************** STUFF EXCLUSIVE TO CACHELETS *********************************/\n-\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-SH_CompositeCacheImpl*\n-SH_CacheMap::initCachelet(J9VMThread* currentThread, BlockPtr existingCacheletMemory, bool creatingCachelet) \n-{\n-\tvoid* ccMem = pool_newElement(_ccPool);\n-\tSH_CompositeCacheImpl* newCachelet;\n-\t\n-\tif (ccMem == NULL) {\n-\t\t/* TODO: Tracepoint */\n-\t\treturn NULL;\n-\t}\n-\tif ((_cacheletHead == NULL) && (startAllManagers(currentThread) == 0)) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tnewCachelet = SH_CompositeCacheImpl::newInstanceNested(currentThread->javaVM, _cc, (SH_CompositeCacheImpl*)ccMem, J9SHR_DEFAULT_CACHELET_SIZE, existingCacheletMemory, creatingCachelet);\n-\tif (!newCachelet) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tif (_cacheletHead != NULL) {\n-\t\t_cacheletTail->setNext((SH_CompositeCacheImpl*)newCachelet);\n-\t} else {\n-\t\t_cacheletHead = _ccCacheletHead = (SH_CompositeCacheImpl*)newCachelet;\n-\t}\n-\t_cacheletTail = (SH_CompositeCacheImpl*)newCachelet;\n-\treturn newCachelet;\n-}\n-\n-/* TODO: Check that we are checking for CC_STARTUP_CORRUPT */\n-/* THREADING: Does not require the cache write mutex */\n-IDATA\n-SH_CacheMap::startupCachelet(J9VMThread* currentThread, SH_CompositeCache* cachelet)\n-{\n-\tIDATA rc;\n-\t\n-\t/* Because starting up a cachelet might require the write mutex,\n-\t * we can't have the refresh mutex here.\n-\t */\n-\trc = ((SH_CompositeCacheImpl*)cachelet)->startupNested(currentThread);\n-\tif (rc == CC_STARTUP_OK) {\n-\t\tif (sanityWalkROMClassSegment(currentThread, (SH_CompositeCacheImpl*)cachelet) == 0) {\n-\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t}\n-\t\tif (rc == CC_STARTUP_OK) {\n-\t\t\tbool hasClassSegmentMutex = \n-\t\t\t\t(omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);\n-\t\t\t/* This is harmless if segments were already initialized. */\n-\t\t\tif (-1 ==  refreshHashtables(currentThread, hasClassSegmentMutex)) {\n-\t\t\t\tif ( _ccHead->isCacheCorrupt()) {\n-\t\t\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t\t\t} else {\n-\t\t\t\t\trc = CC_STARTUP_FAILED;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif (CC_STARTUP_CORRUPT == rc) {\n-\t\treportCorruptCache(currentThread, _ccHead);\n-\t}\n-\n-\treturn rc;\n-}\n-\n-/* THREADING: Must have cache write mutex */\n-SH_CompositeCacheImpl*\n-SH_CacheMap::createNewCachelet(J9VMThread* currentThread) \n-{\n-\tJ9SharedDataDescriptor descriptor;\n-\tSH_Manager* localBDM;\n-\tBlockPtr cacheletMemory;\n-\tSH_CompositeCacheImpl* returnVal = NULL;\n-\tJ9JavaVM* vm = currentThread->javaVM;\n-\tbool createdNewChainedCache = false;\n-\tIDATA i;\n-\t\n-\tTrc_SHR_CM_createNewCachelet_Entry(currentThread);", "originalCommit": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyMjQ0Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504822446", "bodyText": "Marked.", "author": "alexey-anufriev", "createdAt": "2020-10-14T16:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1MzY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1NDI1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504054251", "bodyText": "This trace point can be mark as Obsolete.", "author": "hangshao0", "createdAt": "2020-10-13T15:36:26Z", "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -5836,993 +5644,6 @@ SH_CacheMap::getAttachedDataManager(J9VMThread* currentThread)\n \treturn NULL;\n }\n \n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-UDATA\n-SH_CacheMap::startAllManagers(J9VMThread* currentThread)\n-{\n-\tif (getScopeManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getClasspathManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getROMClassManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getByteDataManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getCompiledMethodManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\treturn 1;\n-}\n-\n-#endif /* J9SHR_CACHELET_SUPPORT */\n-\n-\t/************************************** STUFF EXCLUSIVE TO CACHELETS *********************************/\n-\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-SH_CompositeCacheImpl*\n-SH_CacheMap::initCachelet(J9VMThread* currentThread, BlockPtr existingCacheletMemory, bool creatingCachelet) \n-{\n-\tvoid* ccMem = pool_newElement(_ccPool);\n-\tSH_CompositeCacheImpl* newCachelet;\n-\t\n-\tif (ccMem == NULL) {\n-\t\t/* TODO: Tracepoint */\n-\t\treturn NULL;\n-\t}\n-\tif ((_cacheletHead == NULL) && (startAllManagers(currentThread) == 0)) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tnewCachelet = SH_CompositeCacheImpl::newInstanceNested(currentThread->javaVM, _cc, (SH_CompositeCacheImpl*)ccMem, J9SHR_DEFAULT_CACHELET_SIZE, existingCacheletMemory, creatingCachelet);\n-\tif (!newCachelet) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tif (_cacheletHead != NULL) {\n-\t\t_cacheletTail->setNext((SH_CompositeCacheImpl*)newCachelet);\n-\t} else {\n-\t\t_cacheletHead = _ccCacheletHead = (SH_CompositeCacheImpl*)newCachelet;\n-\t}\n-\t_cacheletTail = (SH_CompositeCacheImpl*)newCachelet;\n-\treturn newCachelet;\n-}\n-\n-/* TODO: Check that we are checking for CC_STARTUP_CORRUPT */\n-/* THREADING: Does not require the cache write mutex */\n-IDATA\n-SH_CacheMap::startupCachelet(J9VMThread* currentThread, SH_CompositeCache* cachelet)\n-{\n-\tIDATA rc;\n-\t\n-\t/* Because starting up a cachelet might require the write mutex,\n-\t * we can't have the refresh mutex here.\n-\t */\n-\trc = ((SH_CompositeCacheImpl*)cachelet)->startupNested(currentThread);\n-\tif (rc == CC_STARTUP_OK) {\n-\t\tif (sanityWalkROMClassSegment(currentThread, (SH_CompositeCacheImpl*)cachelet) == 0) {\n-\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t}\n-\t\tif (rc == CC_STARTUP_OK) {\n-\t\t\tbool hasClassSegmentMutex = \n-\t\t\t\t(omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);\n-\t\t\t/* This is harmless if segments were already initialized. */\n-\t\t\tif (-1 ==  refreshHashtables(currentThread, hasClassSegmentMutex)) {\n-\t\t\t\tif ( _ccHead->isCacheCorrupt()) {\n-\t\t\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t\t\t} else {\n-\t\t\t\t\trc = CC_STARTUP_FAILED;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif (CC_STARTUP_CORRUPT == rc) {\n-\t\treportCorruptCache(currentThread, _ccHead);\n-\t}\n-\n-\treturn rc;\n-}\n-\n-/* THREADING: Must have cache write mutex */\n-SH_CompositeCacheImpl*\n-SH_CacheMap::createNewCachelet(J9VMThread* currentThread) \n-{\n-\tJ9SharedDataDescriptor descriptor;\n-\tSH_Manager* localBDM;\n-\tBlockPtr cacheletMemory;\n-\tSH_CompositeCacheImpl* returnVal = NULL;\n-\tJ9JavaVM* vm = currentThread->javaVM;\n-\tbool createdNewChainedCache = false;\n-\tIDATA i;\n-\t\n-\tTrc_SHR_CM_createNewCachelet_Entry(currentThread);\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\n-\t/* Assume that the manager is started */\n-\tlocalBDM = managers()->getManagerForDataType(TYPE_BYTE_DATA);\n-\tdescriptor.address = 0;\n-\tdescriptor.type = J9SHR_DATA_TYPE_CACHELET;\n-\tdescriptor.length = J9SHR_DEFAULT_CACHELET_SIZE;\n-\tdescriptor.flags = (J9SHRDATA_ALLOCATE_ZEROD_MEMORY | J9SHRDATA_NOT_INDEXED);\n-\n-\tfor (i=0; i<2; i++) {\n-\t\tcacheletMemory = (BlockPtr)addByteDataToCache(currentThread, localBDM, NULL, &descriptor, NULL, true);\n-\n-\t\tif (cacheletMemory != NULL) {\n-\t\t\treturnVal = initCachelet(currentThread, cacheletMemory, true);\n-\t\t\tif (returnVal) {\n-\t\t\t\tif (startupCachelet(currentThread, returnVal) == CC_STARTUP_OK) {\n-\t\t\t\t\tif (createdNewChainedCache) {\n-\t\t\t\t\t\tJ9SharedInvariantInternTable *stringTable = vm->sharedInvariantInternTable;\n-\t\t\t\t\t\t_ccCacheletHead = returnVal;\n-\t\t\t\t\t\tif (!initializeROMSegmentList(currentThread)) {\n-\t\t\t\t\t\t\t/* TODO: handle this correctly */\n-\t\t\t\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);\n-\t\t\t\t\t\t\treturn NULL;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (stringTable) {\n-\t\t\t\t\t\t\tUDATA ignore;\n-\n-\t\t\t\t\t\t\tupdateAllManagersWithNewCacheArea(currentThread, returnVal);\n-\t\t\t\t\t\t\t/* TODO: VERY IMPORTANT!! Entering the readWrite area mutex while we have the writeMutex breaks our threading model for cross-process\n-\t\t\t\t\t\t\t * synchronization. If this were ever used for multi-JVM, it could/would deadlock. However, we have to get the readWrite mutex here\n-\t\t\t\t\t\t\t * so that we can reset the string table. Currently, this will cause assertion failures in CompositeCache for that reason. */\n-\t\t\t\t\t\t\t_cc->enterReadWriteAreaMutex(currentThread, FALSE, &ignore, &ignore);\n-\t\t\t\t\t\t\t_cc->setInternCacheHeaderFields(\n-\t\t\t\t\t\t    \t&(stringTable->sharedTailNodePtr),\n-\t\t\t\t\t\t    \t&(stringTable->sharedHeadNodePtr),\n-\t\t\t\t\t\t\t    &(stringTable->totalSharedNodesPtr),\n-\t\t\t\t\t\t    \t&(stringTable->totalSharedWeightPtr));\n-\n-\t\t\t\t\t\t\tj9shr_resetSharedStringTable(currentThread->javaVM);\n-\n-\t\t\t\t\t\t\t_cc->exitReadWriteAreaMutex(currentThread, J9SHR_STRING_POOL_OK);\n-\t\t\t\t\t\t\tresetAllManagers(currentThread);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t} else {\n-\t\t\t\t\t/* TODO: Need to do some backpedalling and cleanup here */\n-\t\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);\n-\t\t\t\t\treturn NULL;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!createdNewChainedCache && _growEnabled && createNewChainedCache(currentThread, 0)) {\n-\t\t\t\tcreatedNewChainedCache = true;\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);\n-\t\t\t\treturn NULL;\n-\t\t\t}\n-\t\t}\n-\t}\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, returnVal);\n-\treturn returnVal;\n-}\n-\n-/* THREADING: Must have cache write mutex */\n-SH_CompositeCacheImpl*\n-SH_CacheMap::createNewChainedCache(J9VMThread* currentThread, UDATA requiredSize)\n-{\n-\tvoid* ccMem;\n-\tSH_CompositeCacheImpl* newCache;\n-\tJ9SharedClassCacheDescriptor *cacheDesc;\n-\tPORT_ACCESS_FROM_VMC(currentThread);\n-\n-\tTrc_SHR_CM_createNewChainedCache_Entry(currentThread, requiredSize, requiredSize);", "originalCommit": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyMjY2Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504822662", "bodyText": "Marked.", "author": "alexey-anufriev", "createdAt": "2020-10-14T16:42:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1NDI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1NDM0MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504054340", "bodyText": "This trace point can be mark as Obsolete.", "author": "hangshao0", "createdAt": "2020-10-13T15:36:34Z", "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -5836,993 +5644,6 @@ SH_CacheMap::getAttachedDataManager(J9VMThread* currentThread)\n \treturn NULL;\n }\n \n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-UDATA\n-SH_CacheMap::startAllManagers(J9VMThread* currentThread)\n-{\n-\tif (getScopeManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getClasspathManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getROMClassManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getByteDataManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getCompiledMethodManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\treturn 1;\n-}\n-\n-#endif /* J9SHR_CACHELET_SUPPORT */\n-\n-\t/************************************** STUFF EXCLUSIVE TO CACHELETS *********************************/\n-\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-SH_CompositeCacheImpl*\n-SH_CacheMap::initCachelet(J9VMThread* currentThread, BlockPtr existingCacheletMemory, bool creatingCachelet) \n-{\n-\tvoid* ccMem = pool_newElement(_ccPool);\n-\tSH_CompositeCacheImpl* newCachelet;\n-\t\n-\tif (ccMem == NULL) {\n-\t\t/* TODO: Tracepoint */\n-\t\treturn NULL;\n-\t}\n-\tif ((_cacheletHead == NULL) && (startAllManagers(currentThread) == 0)) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tnewCachelet = SH_CompositeCacheImpl::newInstanceNested(currentThread->javaVM, _cc, (SH_CompositeCacheImpl*)ccMem, J9SHR_DEFAULT_CACHELET_SIZE, existingCacheletMemory, creatingCachelet);\n-\tif (!newCachelet) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tif (_cacheletHead != NULL) {\n-\t\t_cacheletTail->setNext((SH_CompositeCacheImpl*)newCachelet);\n-\t} else {\n-\t\t_cacheletHead = _ccCacheletHead = (SH_CompositeCacheImpl*)newCachelet;\n-\t}\n-\t_cacheletTail = (SH_CompositeCacheImpl*)newCachelet;\n-\treturn newCachelet;\n-}\n-\n-/* TODO: Check that we are checking for CC_STARTUP_CORRUPT */\n-/* THREADING: Does not require the cache write mutex */\n-IDATA\n-SH_CacheMap::startupCachelet(J9VMThread* currentThread, SH_CompositeCache* cachelet)\n-{\n-\tIDATA rc;\n-\t\n-\t/* Because starting up a cachelet might require the write mutex,\n-\t * we can't have the refresh mutex here.\n-\t */\n-\trc = ((SH_CompositeCacheImpl*)cachelet)->startupNested(currentThread);\n-\tif (rc == CC_STARTUP_OK) {\n-\t\tif (sanityWalkROMClassSegment(currentThread, (SH_CompositeCacheImpl*)cachelet) == 0) {\n-\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t}\n-\t\tif (rc == CC_STARTUP_OK) {\n-\t\t\tbool hasClassSegmentMutex = \n-\t\t\t\t(omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);\n-\t\t\t/* This is harmless if segments were already initialized. */\n-\t\t\tif (-1 ==  refreshHashtables(currentThread, hasClassSegmentMutex)) {\n-\t\t\t\tif ( _ccHead->isCacheCorrupt()) {\n-\t\t\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t\t\t} else {\n-\t\t\t\t\trc = CC_STARTUP_FAILED;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif (CC_STARTUP_CORRUPT == rc) {\n-\t\treportCorruptCache(currentThread, _ccHead);\n-\t}\n-\n-\treturn rc;\n-}\n-\n-/* THREADING: Must have cache write mutex */\n-SH_CompositeCacheImpl*\n-SH_CacheMap::createNewCachelet(J9VMThread* currentThread) \n-{\n-\tJ9SharedDataDescriptor descriptor;\n-\tSH_Manager* localBDM;\n-\tBlockPtr cacheletMemory;\n-\tSH_CompositeCacheImpl* returnVal = NULL;\n-\tJ9JavaVM* vm = currentThread->javaVM;\n-\tbool createdNewChainedCache = false;\n-\tIDATA i;\n-\t\n-\tTrc_SHR_CM_createNewCachelet_Entry(currentThread);\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\n-\t/* Assume that the manager is started */\n-\tlocalBDM = managers()->getManagerForDataType(TYPE_BYTE_DATA);\n-\tdescriptor.address = 0;\n-\tdescriptor.type = J9SHR_DATA_TYPE_CACHELET;\n-\tdescriptor.length = J9SHR_DEFAULT_CACHELET_SIZE;\n-\tdescriptor.flags = (J9SHRDATA_ALLOCATE_ZEROD_MEMORY | J9SHRDATA_NOT_INDEXED);\n-\n-\tfor (i=0; i<2; i++) {\n-\t\tcacheletMemory = (BlockPtr)addByteDataToCache(currentThread, localBDM, NULL, &descriptor, NULL, true);\n-\n-\t\tif (cacheletMemory != NULL) {\n-\t\t\treturnVal = initCachelet(currentThread, cacheletMemory, true);\n-\t\t\tif (returnVal) {\n-\t\t\t\tif (startupCachelet(currentThread, returnVal) == CC_STARTUP_OK) {\n-\t\t\t\t\tif (createdNewChainedCache) {\n-\t\t\t\t\t\tJ9SharedInvariantInternTable *stringTable = vm->sharedInvariantInternTable;\n-\t\t\t\t\t\t_ccCacheletHead = returnVal;\n-\t\t\t\t\t\tif (!initializeROMSegmentList(currentThread)) {\n-\t\t\t\t\t\t\t/* TODO: handle this correctly */\n-\t\t\t\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);\n-\t\t\t\t\t\t\treturn NULL;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (stringTable) {\n-\t\t\t\t\t\t\tUDATA ignore;\n-\n-\t\t\t\t\t\t\tupdateAllManagersWithNewCacheArea(currentThread, returnVal);\n-\t\t\t\t\t\t\t/* TODO: VERY IMPORTANT!! Entering the readWrite area mutex while we have the writeMutex breaks our threading model for cross-process\n-\t\t\t\t\t\t\t * synchronization. If this were ever used for multi-JVM, it could/would deadlock. However, we have to get the readWrite mutex here\n-\t\t\t\t\t\t\t * so that we can reset the string table. Currently, this will cause assertion failures in CompositeCache for that reason. */\n-\t\t\t\t\t\t\t_cc->enterReadWriteAreaMutex(currentThread, FALSE, &ignore, &ignore);\n-\t\t\t\t\t\t\t_cc->setInternCacheHeaderFields(\n-\t\t\t\t\t\t    \t&(stringTable->sharedTailNodePtr),\n-\t\t\t\t\t\t    \t&(stringTable->sharedHeadNodePtr),\n-\t\t\t\t\t\t\t    &(stringTable->totalSharedNodesPtr),\n-\t\t\t\t\t\t    \t&(stringTable->totalSharedWeightPtr));\n-\n-\t\t\t\t\t\t\tj9shr_resetSharedStringTable(currentThread->javaVM);\n-\n-\t\t\t\t\t\t\t_cc->exitReadWriteAreaMutex(currentThread, J9SHR_STRING_POOL_OK);\n-\t\t\t\t\t\t\tresetAllManagers(currentThread);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t} else {\n-\t\t\t\t\t/* TODO: Need to do some backpedalling and cleanup here */\n-\t\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);\n-\t\t\t\t\treturn NULL;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!createdNewChainedCache && _growEnabled && createNewChainedCache(currentThread, 0)) {\n-\t\t\t\tcreatedNewChainedCache = true;\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);\n-\t\t\t\treturn NULL;\n-\t\t\t}\n-\t\t}\n-\t}\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, returnVal);\n-\treturn returnVal;\n-}\n-\n-/* THREADING: Must have cache write mutex */\n-SH_CompositeCacheImpl*\n-SH_CacheMap::createNewChainedCache(J9VMThread* currentThread, UDATA requiredSize)\n-{\n-\tvoid* ccMem;\n-\tSH_CompositeCacheImpl* newCache;\n-\tJ9SharedClassCacheDescriptor *cacheDesc;\n-\tPORT_ACCESS_FROM_VMC(currentThread);\n-\n-\tTrc_SHR_CM_createNewChainedCache_Entry(currentThread, requiredSize, requiredSize);\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\tTrc_SHR_Assert_True(_sharedClassConfig != NULL);\n-\n-\tccMem = j9mem_allocate_memory(SH_CompositeCacheImpl::getRequiredConstrBytes(false, false), J9MEM_CATEGORY_CLASSES);\n-\n-\tif (ccMem == NULL) {\n-\t\tTrc_SHR_CM_createNewChainedCache_Exit(currentThread, NULL);", "originalCommit": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyMjgxNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504822817", "bodyText": "Marked.", "author": "alexey-anufriev", "createdAt": "2020-10-14T16:42:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1NDM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1ODk0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504058949", "bodyText": "There is another #if defined(J9SHR_CACHELETS_SAVE_READWRITE_AREA) at line 3954 (or line 3796 with your change) which can be removed.", "author": "hangshao0", "createdAt": "2020-10-13T15:42:50Z", "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -5836,993 +5644,6 @@ SH_CacheMap::getAttachedDataManager(J9VMThread* currentThread)\n \treturn NULL;\n }\n \n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-UDATA\n-SH_CacheMap::startAllManagers(J9VMThread* currentThread)\n-{\n-\tif (getScopeManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getClasspathManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getROMClassManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getByteDataManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getCompiledMethodManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\treturn 1;\n-}\n-\n-#endif /* J9SHR_CACHELET_SUPPORT */\n-\n-\t/************************************** STUFF EXCLUSIVE TO CACHELETS *********************************/\n-\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-SH_CompositeCacheImpl*\n-SH_CacheMap::initCachelet(J9VMThread* currentThread, BlockPtr existingCacheletMemory, bool creatingCachelet) \n-{\n-\tvoid* ccMem = pool_newElement(_ccPool);\n-\tSH_CompositeCacheImpl* newCachelet;\n-\t\n-\tif (ccMem == NULL) {\n-\t\t/* TODO: Tracepoint */\n-\t\treturn NULL;\n-\t}\n-\tif ((_cacheletHead == NULL) && (startAllManagers(currentThread) == 0)) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tnewCachelet = SH_CompositeCacheImpl::newInstanceNested(currentThread->javaVM, _cc, (SH_CompositeCacheImpl*)ccMem, J9SHR_DEFAULT_CACHELET_SIZE, existingCacheletMemory, creatingCachelet);\n-\tif (!newCachelet) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tif (_cacheletHead != NULL) {\n-\t\t_cacheletTail->setNext((SH_CompositeCacheImpl*)newCachelet);\n-\t} else {\n-\t\t_cacheletHead = _ccCacheletHead = (SH_CompositeCacheImpl*)newCachelet;\n-\t}\n-\t_cacheletTail = (SH_CompositeCacheImpl*)newCachelet;\n-\treturn newCachelet;\n-}\n-\n-/* TODO: Check that we are checking for CC_STARTUP_CORRUPT */\n-/* THREADING: Does not require the cache write mutex */\n-IDATA\n-SH_CacheMap::startupCachelet(J9VMThread* currentThread, SH_CompositeCache* cachelet)\n-{\n-\tIDATA rc;\n-\t\n-\t/* Because starting up a cachelet might require the write mutex,\n-\t * we can't have the refresh mutex here.\n-\t */\n-\trc = ((SH_CompositeCacheImpl*)cachelet)->startupNested(currentThread);\n-\tif (rc == CC_STARTUP_OK) {\n-\t\tif (sanityWalkROMClassSegment(currentThread, (SH_CompositeCacheImpl*)cachelet) == 0) {\n-\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t}\n-\t\tif (rc == CC_STARTUP_OK) {\n-\t\t\tbool hasClassSegmentMutex = \n-\t\t\t\t(omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);\n-\t\t\t/* This is harmless if segments were already initialized. */\n-\t\t\tif (-1 ==  refreshHashtables(currentThread, hasClassSegmentMutex)) {\n-\t\t\t\tif ( _ccHead->isCacheCorrupt()) {\n-\t\t\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t\t\t} else {\n-\t\t\t\t\trc = CC_STARTUP_FAILED;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif (CC_STARTUP_CORRUPT == rc) {\n-\t\treportCorruptCache(currentThread, _ccHead);\n-\t}\n-\n-\treturn rc;\n-}\n-\n-/* THREADING: Must have cache write mutex */\n-SH_CompositeCacheImpl*\n-SH_CacheMap::createNewCachelet(J9VMThread* currentThread) \n-{\n-\tJ9SharedDataDescriptor descriptor;\n-\tSH_Manager* localBDM;\n-\tBlockPtr cacheletMemory;\n-\tSH_CompositeCacheImpl* returnVal = NULL;\n-\tJ9JavaVM* vm = currentThread->javaVM;\n-\tbool createdNewChainedCache = false;\n-\tIDATA i;\n-\t\n-\tTrc_SHR_CM_createNewCachelet_Entry(currentThread);\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\n-\t/* Assume that the manager is started */\n-\tlocalBDM = managers()->getManagerForDataType(TYPE_BYTE_DATA);\n-\tdescriptor.address = 0;\n-\tdescriptor.type = J9SHR_DATA_TYPE_CACHELET;\n-\tdescriptor.length = J9SHR_DEFAULT_CACHELET_SIZE;\n-\tdescriptor.flags = (J9SHRDATA_ALLOCATE_ZEROD_MEMORY | J9SHRDATA_NOT_INDEXED);\n-\n-\tfor (i=0; i<2; i++) {\n-\t\tcacheletMemory = (BlockPtr)addByteDataToCache(currentThread, localBDM, NULL, &descriptor, NULL, true);\n-\n-\t\tif (cacheletMemory != NULL) {\n-\t\t\treturnVal = initCachelet(currentThread, cacheletMemory, true);\n-\t\t\tif (returnVal) {\n-\t\t\t\tif (startupCachelet(currentThread, returnVal) == CC_STARTUP_OK) {\n-\t\t\t\t\tif (createdNewChainedCache) {\n-\t\t\t\t\t\tJ9SharedInvariantInternTable *stringTable = vm->sharedInvariantInternTable;\n-\t\t\t\t\t\t_ccCacheletHead = returnVal;\n-\t\t\t\t\t\tif (!initializeROMSegmentList(currentThread)) {\n-\t\t\t\t\t\t\t/* TODO: handle this correctly */\n-\t\t\t\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);\n-\t\t\t\t\t\t\treturn NULL;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (stringTable) {\n-\t\t\t\t\t\t\tUDATA ignore;\n-\n-\t\t\t\t\t\t\tupdateAllManagersWithNewCacheArea(currentThread, returnVal);\n-\t\t\t\t\t\t\t/* TODO: VERY IMPORTANT!! Entering the readWrite area mutex while we have the writeMutex breaks our threading model for cross-process\n-\t\t\t\t\t\t\t * synchronization. If this were ever used for multi-JVM, it could/would deadlock. However, we have to get the readWrite mutex here\n-\t\t\t\t\t\t\t * so that we can reset the string table. Currently, this will cause assertion failures in CompositeCache for that reason. */\n-\t\t\t\t\t\t\t_cc->enterReadWriteAreaMutex(currentThread, FALSE, &ignore, &ignore);\n-\t\t\t\t\t\t\t_cc->setInternCacheHeaderFields(\n-\t\t\t\t\t\t    \t&(stringTable->sharedTailNodePtr),\n-\t\t\t\t\t\t    \t&(stringTable->sharedHeadNodePtr),\n-\t\t\t\t\t\t\t    &(stringTable->totalSharedNodesPtr),\n-\t\t\t\t\t\t    \t&(stringTable->totalSharedWeightPtr));\n-\n-\t\t\t\t\t\t\tj9shr_resetSharedStringTable(currentThread->javaVM);\n-\n-\t\t\t\t\t\t\t_cc->exitReadWriteAreaMutex(currentThread, J9SHR_STRING_POOL_OK);\n-\t\t\t\t\t\t\tresetAllManagers(currentThread);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t} else {\n-\t\t\t\t\t/* TODO: Need to do some backpedalling and cleanup here */\n-\t\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);\n-\t\t\t\t\treturn NULL;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!createdNewChainedCache && _growEnabled && createNewChainedCache(currentThread, 0)) {\n-\t\t\t\tcreatedNewChainedCache = true;\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);\n-\t\t\t\treturn NULL;\n-\t\t\t}\n-\t\t}\n-\t}\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, returnVal);\n-\treturn returnVal;\n-}\n-\n-/* THREADING: Must have cache write mutex */\n-SH_CompositeCacheImpl*\n-SH_CacheMap::createNewChainedCache(J9VMThread* currentThread, UDATA requiredSize)\n-{\n-\tvoid* ccMem;\n-\tSH_CompositeCacheImpl* newCache;\n-\tJ9SharedClassCacheDescriptor *cacheDesc;\n-\tPORT_ACCESS_FROM_VMC(currentThread);\n-\n-\tTrc_SHR_CM_createNewChainedCache_Entry(currentThread, requiredSize, requiredSize);\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\tTrc_SHR_Assert_True(_sharedClassConfig != NULL);\n-\n-\tccMem = j9mem_allocate_memory(SH_CompositeCacheImpl::getRequiredConstrBytes(false, false), J9MEM_CATEGORY_CLASSES);\n-\n-\tif (ccMem == NULL) {\n-\t\tTrc_SHR_CM_createNewChainedCache_Exit(currentThread, NULL);\n-\t\treturn NULL;\n-\t}\n-\n-\tcacheDesc = this->appendCacheDescriptorList(currentThread, _sharedClassConfig);\n-\tif (!cacheDesc) {\n-\t\tTrc_SHR_CM_createNewChainedCache_Exit(currentThread, NULL);\n-\t\treturn NULL;\n-\t}\n-\n-\t/* For now, chained caches can only be VMEM */\n-\tnewCache = SH_CompositeCacheImpl::newInstanceChained(currentThread->javaVM, (SH_CompositeCacheImpl*)ccMem, _sharedClassConfig, J9PORT_SHR_CACHE_TYPE_VMEM);\n-\tif (newCache) {\n-\t\tJ9JavaVM* vm = currentThread->javaVM;\n-\t\tU_32 ignored;\n-\t\tIDATA rc;\n-\t\tJ9SharedClassPreinitConfig tempConfig;\n-\t\t\n-\t\tmemcpy(&tempConfig, vm->sharedClassPreinitConfig, sizeof(J9SharedClassPreinitConfig));\n-\t\tif (requiredSize > 0) {\n-\t\t\ttempConfig.sharedClassCacheSize = requiredSize;\n-\t\t\ttempConfig.sharedClassReadWriteBytes = 0;\n-\t\t}\n-\t\t\n-\t\trc = newCache->startupChained(currentThread, _ccHead, &tempConfig, &ignored, &_localCrashCntr);\n-\t\tif (rc == CC_STARTUP_OK) {\n-\t\t\tSH_CompositeCacheImpl* walk = _cacheletHead;\n-\t\t\tSH_CompositeCacheImpl* last = NULL;\n-\t\t\t\n-\t\t\t_cc->setNext(newCache);\n-\t\t\t_cc->setCacheHeaderFullFlags(currentThread, J9SHR_ALL_CACHE_FULL_BITS, false);\n-\t\t\t/* Mark existing cachelets full */\n-\t\t\twhile (walk) {\n-\t\t\t\tif (false == walk->isCacheMarkedFull(currentThread)) {\n-\t\t\t\t\twalk->setCacheHeaderFullFlags(currentThread, J9SHR_ALL_CACHE_FULL_BITS, false);\n-\t\t\t\t}\n-\t\t\t\tlast = walk;\n-\t\t\t\twalk = walk->getNext();\n-\t\t\t}\n-\t\t\t_cc = newCache;\n-\t\t\t_prevCClastCachelet = last;\n-\t\t} else {\n-\t\t\tgoto _error;\n-\t\t}\n-\t} else {\n-\t\tgoto _error;\n-\t}\n-\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\tTrc_SHR_CM_createNewChainedCache_Exit(currentThread, newCache);\n-\treturn newCache;\n-\n-_error:\n-\tpool_removeElement(_ccPool, ccMem);\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\tTrc_SHR_CM_createNewChainedCache_Exit(currentThread, NULL);\n-\treturn NULL;\n-}\n-\n-/**\n- * @retval -1 failed\n- * @retval 0 succeeded\n- */\n-IDATA\n-SH_CacheMap::buildCacheletMetadata(J9VMThread* currentThread, SH_Manager::CacheletMetadataArray** metadataArray)\n-{\n-\tUDATA metadataArraySize;\n-\tUDATA numberOfManagers = 0;\n-\tUDATA numberOfCachelets = 0;\n-\tSH_CompositeCacheImpl* walk;\n-\tSH_Manager::CacheletMetadataArray* array;\n-\tUDATA counter = 0;\n-\tUDATA cacheletMetadataSize;\n-\tSH_Manager::CacheletMetadata* currentMeta;\n-\tconst char* fnName = \"buildCacheletMetadata\";\n-\tSH_Manager* walkManager;\n-\tSH_Managers::ManagerWalkState state;\n-\tCacheletHints* firstHint;\n-\tUDATA totalSizeNeeded = sizeof(J9SharedCacheHeader);\n-\t\n-\tPORT_ACCESS_FROM_VMC(currentThread);\n-\t\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\n-\twalk = _cacheletHead;\n-\twhile (walk) {\n-\t\tif (walk->isStarted()) {\n-\t\t\t++numberOfCachelets;\n-\t\t}\n-\t\twalk = walk->getNext();\n-\t}\n-\n-\twalkManager = managers()->startDo(currentThread, MANAGER_STATE_STARTED, &state);\n-\twhile (walkManager) {\n-\t\tnumberOfManagers++;\n-\t\twalkManager = managers()->nextDo(&state);\n-\t}\n-\n-\t/*\n-\t * Hint collection data structure:\n-\t * one CacheletMetadata per cachelet\n-\t *   one CacheletHints per manager per cachelet - includes data type\n-\t *     one data record per hash item in the manager - data record size can vary by manager\n-\t *\n-\t * Serialized cachelet metadata format:\n-\t * layout CacheletWrapper + (CacheletHints + hint data) x (#cachelets x #managers) + segment list \n-\t *\n-\t * The hint is a key that indicates to the manager which cachelet to load.\n-\t */\n-\tcacheletMetadataSize = sizeof(SH_Manager::CacheletMetadata) + (numberOfManagers * sizeof(CacheletHints));\n-\tmetadataArraySize = sizeof(SH_Manager::CacheletMetadataArray) + (numberOfCachelets * cacheletMetadataSize);\n-\n-\t/* \n-\t * The temp metadata is allocated here in a contiguous block with this format:\n-\t * CacheletMetadataArray | #cachelets x CacheletMetadata | #cachelets x #managers x CacheletHints\n-\t */\n-\tarray = (SH_Manager::CacheletMetadataArray*)j9mem_allocate_memory(metadataArraySize, J9MEM_CATEGORY_CLASSES);\n-\tif (array == NULL) {\n-\t\t_ccHead->exitWriteMutex(currentThread, fnName);\n-\t\treturn -1;\n-\t}\n-\tmemset(array, 0, metadataArraySize);\n-\t\n-\t/* set up the array pointers */\n-\tarray->numMetas = numberOfCachelets;\n-\tarray->metadataArray = (SH_Manager::CacheletMetadata*)&array[1];\n-\tfirstHint = (CacheletHints*)&array->metadataArray[numberOfCachelets]; \n-\t\n-\twalk = _cacheletHead;\n-\tcurrentMeta = &array->metadataArray[0];\n-\twhile (walk) {\n-\t\tif (walk->isStarted()) {\n-\t\t\tcurrentMeta->cachelet = walk;\n-\t\t\tcurrentMeta->numHints = numberOfManagers;\n-\t\t\tcurrentMeta->hintsArray\t= firstHint;\n-\t\t\t++currentMeta;\n-\t\t\tfirstHint += numberOfManagers;\n-\t\t}\n-\t\twalk = walk->getNext();\n-\t}\n-\n-\t/* generate hints */\n-\twalkManager = managers()->startDo(currentThread, MANAGER_STATE_STARTED, &state);\n-\twhile (walkManager) {\n-\t\twalkManager->generateHints(currentThread, array);\n-\t\twalkManager = managers()->nextDo(&state);\n-\t}\n-\n-\tfor (counter=0; counter<array->numMetas; counter++) {\n-\t\tUDATA c2;\n-\t\tSH_Manager::CacheletMetadata* cacheletMetadata = &array->metadataArray[counter];\n-\t\tShcItem item;\n-\t\tShcItem* itemPtr = &item;\n-\t\tU_32 total = sizeof(CacheletWrapper);\n-\t\tfor (c2=0; c2<cacheletMetadata->numHints; c2++) {\n-\t\t\tif (cacheletMetadata->hintsArray[c2].dataType != TYPE_UNINITIALIZED) {\n-\t\t\t\ttotal += (U_32)(sizeof(CacheletHints) + cacheletMetadata->hintsArray[c2].length);\n-\t\t\t}\n-\t\t}\n-\t\ttotal += (U_32)(sizeof(UDATA) * \n-\t\t\t((SH_CompositeCacheImpl*)cacheletMetadata->cachelet)->countROMSegments(currentThread));\n-\t\t_ccHead->initBlockData(&itemPtr, total, TYPE_CACHELET);\n-\t\ttotalSizeNeeded += _ccHead->getBytesRequiredForItemWithAlign(itemPtr, SHC_WORDALIGN, 0);\n-\t}\n-\t/* discard any old metadata by creating a new supercache for the hints */\n-\t/* TODO: could optimize and use the current cache if there is enough room and no existing metadata */\n-\tif (createNewChainedCache(currentThread, totalSizeNeeded + (_ccHead->getOSPageSize() * 2)) == NULL) {  \n-\t\tCACHEMAP_PRINT1(J9NLS_ERROR, J9NLS_SHRC_CM_NO_CACHE_FOR_HINTS, _cacheName);\n-\t\treturn -1;\n-\t}\n-\n-\t/* write hints into the current supercache */\n-\tfor (counter=0; counter<array->numMetas; counter++) {\n-\t\tif (writeCacheletMetadata(currentThread, &array->metadataArray[counter]) != 0) {\n-\t\t\treturn -1;\n-\t\t}\n-\t}\n-\n-\t*metadataArray = array;\n-\n-\treturn 0;\n-}\n-\n-void\n-SH_CacheMap::freeCacheletMetadata(J9VMThread* currentThread, SH_Manager::CacheletMetadataArray* metaArray)\n-{\n-\tPORT_ACCESS_FROM_VMC(currentThread);\n-\tSH_Manager* walkManager;\n-\tSH_Managers::ManagerWalkState state;\n-\n-\twalkManager = managers()->startDo(currentThread, MANAGER_STATE_STARTED, &state);\n-\twhile (walkManager) {\n-\t\twalkManager->freeHintData(currentThread, metaArray);\n-\t\twalkManager = managers()->nextDo(&state);\n-\t}\n-\tj9mem_free_memory(metaArray);\n-}\n-\n-IDATA\n-SH_CacheMap::readCacheletHints(J9VMThread* currentThread, SH_CompositeCacheImpl* cachelet, CacheletWrapper* cacheletWrapper)\n-{\n-\tUDATA counter = 0;\n-\tCacheletHints* currentHints = (CacheletHints*)CLETHINTS(cacheletWrapper);\n-\n-\tfor (counter=0; counter<cacheletWrapper->numHints; counter++) {\n-\t\tSH_Manager* managerForType;\n-\t\t\n-\t\t/* With Cachelets, all managers should already be started */\n-\t\tmanagerForType = managers()->getManagerForDataType(currentHints->dataType);\n-\t\tif (NULL == managerForType) {\n-\t\t\tTrc_SHR_CM_readCacheletHints_noManager(currentThread, currentHints->dataType);\n-\t\t\tif (0 == currentHints->length) {\n-\t\t\t\t/* Doesn't matter if the manager can't be found when there are no hints */\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tTrc_SHR_Assert_ShouldNeverHappen();\n-\t\t\tcontinue;\n-\t\t}\n-\t\t/* currentHints->data is NULL; don't use it. The hint data was copied directly after the CacheletHint structure. */\n-\t\tmanagerForType->primeFromHints(currentThread, cachelet, (U_8*)&currentHints[1], currentHints->length);\n-\t\tcurrentHints = (CacheletHints*)((UDATA)currentHints + (currentHints->length + sizeof(CacheletHints)));\n-\t}\n-\treturn 0;\n-}\n-\n-/**\n- * Create the class memory segments for a cachelet.\n- * Do this when the cachelet is initialized, rather than when startup() is called,\n- * because we may not be able to get the class segment mutex when startup() is called.\n- * @param[in] currentThread The current thread.\n- * @param[in] cachelet The cachelet.\n- * @param[in] cacheletWrapper The cachelet metadata.\n- * @retval true success\n- * @retval false failure\n- * @pre Owns the VM class segment mutex\n- * @post Owns the VM class segment mutex\n- */\n-bool\n-SH_CacheMap::readCacheletSegments(J9VMThread* currentThread, SH_CompositeCacheImpl* cachelet, CacheletWrapper* cacheletWrapper)\n-{\n-\tU_8* cursor = CLETHINTS(cacheletWrapper);\n-\tUDATA* segmentLengths = NULL;\n-\tU_8* firstBaseAddress = NULL;\n-\tU_8* baseAddress = NULL;\n-\tJ9MemorySegment* segment = NULL;\n-\tUDATA i;\n-\t\n-\tTrc_SHR_Assert_True(omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex));\n-\t\n-\tif (cacheletWrapper->numSegments == 0) {\n-\t\tTrc_SHR_CM_readCacheletSegments_noSegments(currentThread, cachelet, cacheletWrapper);\n-\t\treturn true;\n-\t}\n-\t\n-\t/* scan past the hints */\n-\tfor (i = 0; i < cacheletWrapper->numHints; ++i) {\n-\t\tCacheletHints* hint = (CacheletHints*)cursor;\n-\t\tcursor += hint->length + sizeof(CacheletHints); \n-\t}\n-\t\n-\t/* Scan the segment lengths. Note that _theca isn't initialized. */\n-\tfirstBaseAddress = baseAddress = (U_8*)(cachelet->getNestedMemory()) + cacheletWrapper->segmentStartOffset;\n-\tsegmentLengths = (UDATA*)cursor;\n-\tfor (i = 0; i < cacheletWrapper->numSegments; ++i) {\n-\t\tsegment = addNewROMImageSegment(currentThread, baseAddress, baseAddress + *segmentLengths);\n-\t\tif (!segment) {\n-\t\t\tTrc_SHR_CM_readCacheletSegments_addSegmentFailed(currentThread,\n-\t\t\t\t\tcachelet, cacheletWrapper, i, baseAddress, baseAddress + *segmentLengths);\n-\t\t\treturn false;\n-\t\t}\n-\t\tsegment->heapAlloc = segment->heapTop;\n-\n-\t\tbaseAddress += *segmentLengths;\n-\t\t++segmentLengths;\n-\t}\n-\t/* the last segment may not be fully allocated */\n-\tsegment->heapAlloc = segment->heapBase + cacheletWrapper->lastSegmentAlloc;\n-\tcachelet->setCurrentROMSegment(segment);\n-\t\n-\tTrc_SHR_CM_readCacheletSegments_addedSegments(currentThread,\n-\t\t\tcachelet, cacheletWrapper,\n-\t\t\tcacheletWrapper->numSegments,\n-\t\t\tfirstBaseAddress,\n-\t\t\tsegment->heapTop,\n-\t\t\tsegment->heapAlloc,\n-\t\t\tcachelet->getCurrentROMSegment());\n-\treturn true;\n-}\n-\n-IDATA\n-SH_CacheMap::writeCacheletMetadata(J9VMThread* currentThread, SH_Manager::CacheletMetadata* cacheletMetadata)\n-{\n-\tSH_CompositeCacheImpl* cachelet = (SH_CompositeCacheImpl*)cacheletMetadata->cachelet;\n-\tShcItem item;\n-\tShcItem* itemPtr = &item;\n-\tShcItem* itemInCache = NULL;\n-\tCacheletWrapper cw;\n-\tCacheletWrapper* cwInCache = NULL;\n-\tU_32 totalSizeNeeded = sizeof(CacheletWrapper);\n-\tUDATA counter = 0;\n-\tBlockPtr cursor;\n-\tUDATA hintsUsed = 0;\n-\tUDATA numSegments = 0;\n-\tPORT_ACCESS_FROM_VMC(currentThread);\n-\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\n-\t/* TODO If you don't write hints for a manager, then when the cache is started, the manager\n-\t * won't consider itself _isRunningNested. So we have to write something even if there\n-\t * are no hints.\n-\t */\n-\tfor (counter=0; counter<cacheletMetadata->numHints; counter++) {\n-\t\tCacheletHints* currentHints = &cacheletMetadata->hintsArray[counter];\n-\t\tif ((currentHints->dataType != TYPE_UNINITIALIZED) && (currentHints->length > 0)) {\n-\t\t\ttotalSizeNeeded += (U_32)(sizeof(CacheletHints) + currentHints->length);\n-\t\t\t++hintsUsed;\n-\t\t}\n-\t}\n-\n-\tnumSegments = cachelet->countROMSegments(currentThread);\n-\ttotalSizeNeeded += (U_32)(sizeof(UDATA) * numSegments);\n-\n-\t/* TODO the granularity of a block is 1M. Most of it may be wasted. */\n-\t_ccHead->initBlockData(&itemPtr, totalSizeNeeded, TYPE_CACHELET);\n-\titemInCache = (ShcItem*)_cc->allocateBlock(currentThread, itemPtr, SHC_WORDALIGN, 0);\n-\t\n-\tif (itemInCache == NULL) {\n-\t\t/* There are 3 failure conditions when allocate() can return NULL */\n-\t\tif (true == _cc->isCacheMarkedFull(currentThread)) {\n-\t\t\tCACHEMAP_PRINT2(J9NLS_ERROR, J9NLS_SHRC_CM_CACHE_FULL, _cacheName, totalSizeNeeded);\n-\t\t} else if (_cc->isCacheCorrupt()) {\n-\t\t\tCACHEMAP_PRINT(J9NLS_ERROR, J9NLS_SHRC_CM_CACHE_CORRUPT);\n-\t\t} else {\n-\t\t\tI_32 freeBlockBytes = _cc->getFreeBlockBytes();\n-\t\t\tJ9SharedClassJavacoreDataDescriptor descriptor;\n-\t\t\tCACHEMAP_PRINT3(J9NLS_ERROR, J9NLS_SHRC_CM_INSUFFICIENT_FREE_BLOCK, _cacheName, freeBlockBytes, totalSizeNeeded);\n-\t\t\tj9tty_printf(PORTLIB, \"Free bytes: %d\\t\", _cc->getFreeBytes());\n-\t\t\tj9tty_printf(PORTLIB, \"AOT bytes: %d\\t\", _cc->getAOTBytes());\n-\t\t\tj9tty_printf(PORTLIB, \"JIT bytes: %d\\n\", _cc->getJITBytes());\n-\t\t\tif (1 == getJavacoreData(currentThread->javaVM, &descriptor)) {\n-\t\t\t\tj9tty_printf(PORTLIB, \"minAOT: %d\\t\", descriptor.minAOT);\n-\t\t\t\tj9tty_printf(PORTLIB, \"minJIT: %d\\n\", descriptor.minJIT);\n-\t\t\t}\n-\t\t}\n-\t\tCACHEMAP_PRINT1(J9NLS_ERROR, J9NLS_SHRC_CM_NO_BLOCK_FOR_HINTS, _cacheName);\n-\t\treturn -1;\n-\t}\n-\n-\t/* construct CacheletWrapper */\n-\tcwInCache = (CacheletWrapper*)ITEMDATA(itemInCache);\n-\tcw.dataStart = (J9SRP)((UDATA)cachelet->getCacheHeaderAddress() - (UDATA)cwInCache);\n-\tcw.dataLength = cachelet->getCacheMemorySize();\n-\tcw.numHints = hintsUsed;\n-\tcw.numSegments = numSegments;\n-\tcw.segmentStartOffset = (UDATA)cachelet->getBaseAddress() - (UDATA)cachelet->getCacheHeaderAddress();\n-\tmemcpy(cwInCache, &cw, sizeof(CacheletWrapper));\n-\tcacheletMetadata->wrapperAddress = cwInCache;\n-\t\n-\t/* construct hints */\n-\tcursor = (BlockPtr)cwInCache + sizeof(CacheletWrapper);\n-\tfor (counter=0; counter<cacheletMetadata->numHints; counter++) {\n-\t\tCacheletHints* currentHints = &cacheletMetadata->hintsArray[counter];\n-\t\t\n-\t\t/* skip uninitialized and zero length hints */\n-\t\tif ((currentHints->dataType != TYPE_UNINITIALIZED) && (currentHints->length > 0)) {\n-\t\t\tmemcpy(cursor, currentHints, sizeof(CacheletHints));\n-\t\t\t/* cursor->data should be an address in the target cache.\n-\t\t\t * It can't be set to an absolute value.\n-\t\t\t */\n-\t\t\t((CacheletHints*)cursor)->data = NULL;\n-\t\t\tcursor += sizeof(CacheletHints);\n-\n-\t\t\tmemcpy(cursor, currentHints->data, currentHints->length);\n-\t\t\tcursor += currentHints->length;\n-\t\t}\n-\t}\n-\n-\t/* construct segments */\n-\tcachelet->writeROMSegmentMetadata(currentThread, numSegments, cursor, &cwInCache->lastSegmentAlloc);\n-\n-\t_cc->commitUpdate(currentThread, false);\n-\n-\treturn 0;\n-}\n-\n-#if 0\n-/** \n- * Grow cache in place.\n- */\n-IDATA\n-SH_CacheMap::growCacheInPlace(J9VMThread* currentThread, UDATA rwGrowth, UDATA freeGrowth)\n-{\n-\tBlockPtr srcSegmentStart, srcSegmentEnd;\n-\tUDATA srcSegmentLen;\n-\n-\t/* relocate the cachelets, and then move them */\n-\tBlockPtr newBase = (BlockPtr)_cc->getBaseAddress() + rwGrowth;\n-\tthis->setDeployedROMClassStarts(currentThread, newBase);\n-\tif (this->fixupCompiledMethodsForSerialization(currentThread,newBase)!= 0) {\n-\t\t/*TODO ... possibly return -1*/\n-\t}\n-\tsrcSegmentStart = (BlockPtr)_cc->getBaseAddress();\n-\tsrcSegmentEnd = (BlockPtr)_cc->getCacheEndAddress();\n-\tsrcSegmentLen = srcSegmentEnd - srcSegmentStart;\n-\tmemmove(newBase, srcSegmentStart, srcSegmentLen);\n-\tmemset(srcSegmentStart, 0, rwGrowth);\n-\t_cc->growCacheInPlace(rwGrowth, freeGrowth);\n-\tif (resetAllManagers(currentThread) != 0) {\n-\t\treturn -1;\n-\t}\n-\treturn readCache(currentThread, _cc, -1, false);\n-}\n-#endif\n-\n-\n-/**\n- * Serialize a chained growable cache to one big deployment cache.\n- * \n- * @retval true succeeded\n- * @retval false failed\n- */\n-bool\n-SH_CacheMap::serializeSharedCache(J9VMThread* currentThread)\n-{\n-\tbool ok = true;\n-\tconst char* fnName = \"serializeSharedCache\";\n-\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\tif (_runningNested) {\n-\t\tif (!currentThread) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tif (_ccHead->enterWriteMutex(currentThread, true, fnName) != 0) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!_isSerialized) {\n-\t\t\tok = serializeOfflineCache(currentThread);\n-\t\t\t_isSerialized = true;\n-\t\t}\n-\t\t_ccHead->exitWriteMutex(currentThread, fnName);\n-\t}\n-#endif\n-\treturn ok;\n-}\n-\n-/**\n- * Serialize this chained cache to one big deployment cache.\n- * The chained cache contents are no longer usable after this.\n- * @param[in] this chain of supercaches\n- * @param[in] currentThread\n- * @retval true succeeded\n- * @retval false failed. We may have deleted the serialized cache because it was corrupt.\n- * \n- */\n-bool\n-SH_CacheMap::serializeOfflineCache(J9VMThread* currentThread)\n-{\n-\tSH_CompositeCacheImpl* serializedCache = NULL;\n-\tSH_CompositeCacheImpl* supercache;\n-\tSH_CompositeCacheImpl* cachelet;\n-\tJ9SharedClassConfig config;\n-\tJ9SharedClassPreinitConfig piconfig;\n-\tJ9SharedClassCacheDescriptor newCacheDesc;\n-\tU_32 actualSize;\n-\tUDATA localCrashCntr;\n-\tbool cacheHasIntegrity;\n-\tJ9JavaVM* vm = currentThread->javaVM;\n-\tvoid* objectMemory;\n-\tUDATA totalMetadataSize = 0;\n-\tUDATA totalCacheletSize = 0;\n-#if defined(J9SHR_CACHELETS_SAVE_READWRITE_AREA)", "originalCommit": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyMDE4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504820188", "bodyText": "Removed.", "author": "alexey-anufriev", "createdAt": "2020-10-14T16:38:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1ODk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA2MTUxMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504061512", "bodyText": "Trc_SHR_CMI_primeHashtables_addingHint and Trc_SHR_CMI_primeHashtables_failedToPrimeHint can be marked as Obsolete", "author": "hangshao0", "createdAt": "2020-10-13T15:46:08Z", "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1453,147 +1437,3 @@ SH_ClasspathManagerImpl2::getNumItemsByType(UDATA* numClasspaths, UDATA* numURLs\n \t*numURLs = _urlCount;\n \t*numTokens = _tokenCount;\n }\n-\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-/**\n- * Walk the managed items hashtable in this cachelet. Allocate and populate an array\n- * of hints, one for each hash entry.\n- *\n- * @param[in] self a data type manager\n- * @param[in] vmthread the current VMThread\n- * @param[out] hints a CacheletHints structure. This function fills in its\n- * contents.\n- *\n- * @retval 0 success\n- * @retval -1 failure\n- */\n-IDATA\n-SH_ClasspathManagerImpl2::createHintsForCachelet(J9VMThread* vmthread, SH_CompositeCache* cachelet, CacheletHints* hints)\n-{\n-\tTrc_SHR_Assert_True(hints != NULL);\n-\n-\t/* hints->dataType should have been set by the caller */\n-\tTrc_SHR_Assert_True(hints->dataType == _dataTypesRepresented[0]);\n-\t\n-\treturn cpeCollectHashes(vmthread, cachelet, hints);\n-}\n-\n-/**\n- * add a (_hashValue, cachelet) entry to the hash table\n- * only called with hints of the right data type \n- *\n- * each hint is a UDATA-length hash of a string\n- * \n- * This method is not threadsafe.\n- */\n-IDATA\n-SH_ClasspathManagerImpl2::primeHashtables(J9VMThread* vmthread, SH_CompositeCache* cachelet, U_8* hintsData, UDATA dataLength)\n-{\n-\tUDATA* hashSlot = (UDATA*)hintsData;\n-\tUDATA hintCount = 0;\n-\n-\tif ((dataLength == 0) || (hintsData == NULL)) {\n-\t\treturn 0;\n-\t}\n-\n-\thintCount = dataLength / sizeof(UDATA);\n-\twhile (hintCount-- > 0) {\n-\t\tTrc_SHR_CMI_primeHashtables_addingHint(vmthread, cachelet, *hashSlot);", "originalCommit": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyMzU1NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504823554", "bodyText": "Marked.", "author": "alexey-anufriev", "createdAt": "2020-10-14T16:44:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA2MTUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA2Mzk4NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504063985", "bodyText": "The above #if defined(J9SHR_CACHELETS_SAVE_READWRITE_AREA) and code inside it can also be removed.", "author": "hangshao0", "createdAt": "2020-10-13T15:49:36Z", "path": "runtime/shared_common/CompositeCache.cpp", "diffHunk": "@@ -2835,11 +2712,6 @@ SH_CompositeCacheImpl::allocate(J9VMThread* currentThread, U_8 type, ShcItem* it\n \t\t\tif (readWriteBuffer) {\n #if defined(J9SHR_CACHELETS_SAVE_READWRITE_AREA)\n \t\t\t\t*readWriteBuffer = parent->allocateReadWrite(separateBufferSize);\n-#if defined(J9SHR_CACHELET_SUPPORT)", "originalCommit": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxODkzMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504818933", "bodyText": "Removed.", "author": "alexey-anufriev", "createdAt": "2020-10-14T16:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA2Mzk4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkzNDg2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504934868", "bodyText": "There is one more #if defined(J9SHR_CACHELETS_SAVE_READWRITE_AREA) above in the function at line 2799 (or line 2676 with your change)", "author": "hangshao0", "createdAt": "2020-10-14T19:54:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA2Mzk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3Mzc4Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504073787", "bodyText": "You can remove the flag J9SHR_RUNTIMEFLAG_ENABLE_NESTED in shcflags.h and make a comment there say bit 0x10000 is free to use. All the code checking this flag can also be removed.", "author": "hangshao0", "createdAt": "2020-10-13T16:02:51Z", "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -352,9 +342,6 @@ J9SharedClassesOptions J9SHAREDCLASSESOPTIONS[] = {\n \t{ OPTION_RESTORE_FROM_SNAPSHOT, PARSE_TYPE_EXACT, RESULT_DO_RESTORE_FROM_SNAPSHOT, J9SHR_RUNTIMEFLAG_RESTORE},\n \t{ OPTION_PRINT_SNAPSHOTNAME, PARSE_TYPE_EXACT, RESULT_DO_PRINT_SNAPSHOTNAME, 0},\n #endif /* !defined(WIN32) */\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\t{ OPTION_NESTED, PARSE_TYPE_EXACT, RESULT_DO_ADD_RUNTIMEFLAG, J9SHR_RUNTIMEFLAG_ENABLE_NESTED},", "originalCommit": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3NTUwMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504075503", "bodyText": "OPTION_NESTED can also be removed.", "author": "hangshao0", "createdAt": "2020-10-13T16:05:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3Mzc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgzMDEwNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504830105", "bodyText": "Removed.", "author": "alexey-anufriev", "createdAt": "2020-10-14T16:54:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3Mzc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3NzQ1Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504077453", "bodyText": "Nothing is changed in this file. So no need to update the copyright date.", "author": "hangshao0", "createdAt": "2020-10-13T16:08:18Z", "path": "runtime/tests/shared/CompositeCacheSizesTests.hpp", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2001, 2017 IBM Corp. and others\n+ * Copyright (c) 2001, 2020 IBM Corp. and others", "originalCommit": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxNjM4MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504816380", "bodyText": "Reverted.", "author": "alexey-anufriev", "createdAt": "2020-10-14T16:32:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3NzQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg3NzUzMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504877532", "bodyText": "This change is still in this PR. Seems that you didn't push your local change to your personal fork ?", "author": "hangshao0", "createdAt": "2020-10-14T18:14:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3NzQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkxNTI1NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504915254", "bodyText": "Wanted to push one more commit right away, but then decided to rework it.\nI was reorganizing commits to make the history prettier. But replies were already posted.\nSorry for the confusion.", "author": "alexey-anufriev", "createdAt": "2020-10-14T19:19:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3NzQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3OTIzNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504079236", "bodyText": "No need to update the copyright date.", "author": "hangshao0", "createdAt": "2020-10-13T16:10:58Z", "path": "runtime/tests/shared/SCStringTransactionTests.hpp", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2001, 2014 IBM Corp. and others\n+ * Copyright (c) 2001, 2020 IBM Corp. and others", "originalCommit": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxNjE2Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504816167", "bodyText": "Reverted.", "author": "alexey-anufriev", "createdAt": "2020-10-14T16:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3OTIzNg=="}], "type": "inlineReview"}, {"oid": "e4d9018d65bdc5a2454c41f8ce6c55accc93a035", "url": "https://github.com/eclipse-openj9/openj9/commit/e4d9018d65bdc5a2454c41f8ce6c55accc93a035", "message": "Remove J9SHR_CACHELET_SUPPORT macro\n\nThis patch removes J9SHR_CACHELET_SUPPORT macro and related code\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>", "committedDate": "2020-10-14T19:17:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyMjQzNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504922437", "bodyText": "_ccCacheletHead and _prevCClastCachelet can also be removed.", "author": "hangshao0", "createdAt": "2020-10-14T19:32:15Z", "path": "runtime/shared_common/CacheMap.hpp", "diffHunk": "@@ -299,9 +289,7 @@ class SH_CacheMap : public SH_SharedCache, public SH_CacheMapStats\n \tJ9SharedClassConfig* _sharedClassConfig;\n \t\n \tSH_CompositeCacheImpl* _ccHead;\t\t\t\t/* head of supercache list */\n-\tSH_CompositeCacheImpl* _cacheletHead;\t\t/* head of all known cachelets */\n \tSH_CompositeCacheImpl* _ccCacheletHead;\t\t/* head of cachelet list for current cache */", "originalCommit": "e4d9018d65bdc5a2454c41f8ce6c55accc93a035", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk3OTMzNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504979335", "bodyText": "Removed", "author": "alexey-anufriev", "createdAt": "2020-10-14T21:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyMjQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkzNzE1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504937156", "bodyText": "The indentation in this block looks incorrect to me. I guess you are using spaces instead of tabs ?", "author": "hangshao0", "createdAt": "2020-10-14T19:58:52Z", "path": "runtime/shared_common/CompositeCache.cpp", "diffHunk": "@@ -2872,30 +2741,22 @@ SH_CompositeCacheImpl::allocate(J9VMThread* currentThread, U_8 type, ShcItem* it\n \t\tSH_CompositeCacheImpl *ccToUse = ((_ccHead == NULL) ? ((_parent == NULL) ? this : _parent->_ccHead) : _ccHead);\n \n \t\tif (ALLOCATE_TYPE_AOT == type) {\n-\t\t\tTrc_SHR_Assert_True((0 == (*_runtimeFlags & J9SHR_RUNTIMEFLAG_ENABLE_NESTED)));\n \t\t\tflags |= J9SHR_AOT_SPACE_FULL;\n \t\t} else if (ALLOCATE_TYPE_JIT == type) {\n-\t\t\tTrc_SHR_Assert_True((0 == (*_runtimeFlags & J9SHR_RUNTIMEFLAG_ENABLE_NESTED)));\n \t\t\tflags |= J9SHR_JIT_SPACE_FULL;\n \t\t} else {\n-\t\t\tif (0 != (*_runtimeFlags & J9SHR_RUNTIMEFLAG_ENABLE_NESTED)) {\n-\t\t\t\t/* For realtime cache, allocation failure can happen only when trying to allocate new cachelet. */\n-\t\t\t\tTrc_SHR_Assert_Equals(itemToWrite->dataType, TYPE_CACHELET);\n-\t\t\t\tflags |= J9SHR_BLOCK_SPACE_FULL;\n-\t\t\t} else {\n-\t\t\t\tI_32 freeBlockBytes = getFreeBlockBytes();\n-\t\t\t\t/* Allocation request for BLOCK data can fail if\n-\t\t\t\t * \t\trequested amount > freeBlockBytes >= CC_MIN_SPACE_BEFORE_CACHE_FULL, or\n-\t\t\t\t * \t\trequested amount > freeBlockBytes < (J9SHR_MIN_GAP_BEFORE_METADATA + J9SHR_MIN_DUMMY_DATA_SIZE).\n-\t\t\t\t * In first case we don't want to set J9SHR_RUNTIMEFLAG_BLOCK_SPACE_FULL as free block bytes is above threshold.\n-\t\t\t\t * In second case we don't need to set J9SHR_RUNTIMEFLAG_BLOCK_SPACE_FULL as it would have been done in previous commit.\n-\t\t\t\t */\n-\t\t\t\tif (freeBlockBytes < (I_32) (J9SHR_MIN_GAP_BEFORE_METADATA + J9SHR_MIN_DUMMY_DATA_SIZE)) {\n-\t\t\t\t\tTrc_SHR_Assert_True(J9SHR_BLOCK_SPACE_FULL == (J9SHR_BLOCK_SPACE_FULL & _theca->cacheFullFlags));\n-\t\t\t\t} else {\n-\t\t\t\t\tTrc_SHR_Assert_True(freeBlockBytes >= (I_32) CC_MIN_SPACE_BEFORE_CACHE_FULL);\n-\t\t\t\t}\n-\t\t\t}\n+            I_32 freeBlockBytes = getFreeBlockBytes();", "originalCommit": "e4d9018d65bdc5a2454c41f8ce6c55accc93a035", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk3OTIwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504979208", "bodyText": "Fixed", "author": "alexey-anufriev", "createdAt": "2020-10-14T21:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkzNzE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk3MzA0MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504973041", "bodyText": "Nothing is changed in this file, so no need to change the copyright date.", "author": "hangshao0", "createdAt": "2020-10-14T21:08:19Z", "path": "runtime/shared_common/Managers.cpp", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2001, 2014 IBM Corp. and others\n+ * Copyright (c) 2001, 2020 IBM Corp. and others", "originalCommit": "e4d9018d65bdc5a2454c41f8ce6c55accc93a035", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk3OTExMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504979113", "bodyText": "Fixed", "author": "alexey-anufriev", "createdAt": "2020-10-14T21:21:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk3MzA0MQ=="}], "type": "inlineReview"}, {"oid": "82c7505435c7dfbaf27471eddd8ec9858a3c4857", "url": "https://github.com/eclipse-openj9/openj9/commit/82c7505435c7dfbaf27471eddd8ec9858a3c4857", "message": "Remove J9SHR_CACHELET_SUPPORT macro\n\nThis patch removes J9SHR_CACHELET_SUPPORT macro and related code\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>", "committedDate": "2020-10-14T21:19:59Z", "type": "forcePushed"}, {"oid": "bf3d5c6395d7545086d0abf175193af19ed0e3f7", "url": "https://github.com/eclipse-openj9/openj9/commit/bf3d5c6395d7545086d0abf175193af19ed0e3f7", "message": "Remove J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro\n\nThis patch removes J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro along with related code\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>", "committedDate": "2020-10-14T21:35:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA0NTI3OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505045278", "bodyText": "Pls fix the indenting here and the next line, to use tabs.", "author": "pshipton", "createdAt": "2020-10-14T22:58:58Z", "path": "runtime/shared_common/CompositeCache.cpp", "diffHunk": "@@ -6053,13 +5414,8 @@ SH_CompositeCacheImpl::setRuntimeCacheFullFlags(J9VMThread* currentThread)\n \t\t\t\tCC_TRACE1(J9SHR_VERBOSEFLAG_ENABLE_VERBOSE, J9NLS_INFO, J9NLS_SHRC_CM_WARN_FULL_CACHE, _cacheName);\n \t\t\t} else {\n \t\t\t\tif (0 != (cacheFullFlags & J9SHR_RUNTIMEFLAG_BLOCK_SPACE_FULL)) {\n-\t\t\t\t\tif (0 != (cacheFullFlags & J9SHR_RUNTIMEFLAG_ENABLE_NESTED)) {\n-\t\t\t\t\t\t/* If we requested a growable cache, this is an error. */\n-\t\t\t\t\t\tCC_TRACE1(J9SHR_VERBOSEFLAG_ENABLE_VERBOSE_DEFAULT, J9NLS_INFO, J9NLS_SHRC_CM_WARN_FULL_CACHE, _cacheName);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\t/* Only report Block data space full to std-err with verbose enabled */\n-\t\t\t\t\t\tCC_TRACE1(J9SHR_VERBOSEFLAG_ENABLE_VERBOSE, J9NLS_INFO, J9NLS_SHRC_CM_WARN_BLOCK_SPACE_FULL, _cacheName);\n-\t\t\t\t\t}\n+                    /* Only report Block data space full to std-err with verbose enabled */", "originalCommit": "bf3d5c6395d7545086d0abf175193af19ed0e3f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg0NDgzNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505844834", "bodyText": "Fixed", "author": "alexey-anufriev", "createdAt": "2020-10-15T20:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA0NTI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1MTA0MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505051041", "bodyText": "Pls remove the isNested parameter of getFirstROMClassAddress().", "author": "pshipton", "createdAt": "2020-10-14T23:07:30Z", "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -1049,7 +971,7 @@ SH_CacheMap::initializeROMSegmentList(J9VMThread* currentThread)\n \tTrc_SHR_CM_initializeROMSegmentList_Entry(currentThread);\n \n \tcacheBase = (U_8*)_ccHead->getBaseAddress();\n-\tfirstROMClassAddress = _ccHead->getFirstROMClassAddress(_runningNested);\n+\tfirstROMClassAddress = _ccHead->getFirstROMClassAddress(false);", "originalCommit": "bf3d5c6395d7545086d0abf175193af19ed0e3f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg0NDc3Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505844776", "bodyText": "Fixed", "author": "alexey-anufriev", "createdAt": "2020-10-15T20:59:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1MTA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NDE3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505054177", "bodyText": "All these primeHashtables tracepoints are Obsolete.", "author": "pshipton", "createdAt": "2020-10-14T23:12:09Z", "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1774,8 +1774,8 @@ TraceExit=Trc_SHR_OSC_recreateSemaphore_Exit4Obsolete NoEnv Obsolete Overhead=1\n TraceEvent=Trc_SHR_BDMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"BDMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n TraceException=Trc_SHR_BDMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"BDMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n-TraceEvent=Trc_SHR_CMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"CMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n-TraceException=Trc_SHR_CMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"CMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n+TraceEvent=Trc_SHR_CMI_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"CMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n+TraceException=Trc_SHR_CMI_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"CMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n TraceEvent=Trc_SHR_RMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"RMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"", "originalCommit": "bf3d5c6395d7545086d0abf175193af19ed0e3f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg0NDY3NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505844674", "bodyText": "Marked", "author": "alexey-anufriev", "createdAt": "2020-10-15T20:59:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NDE3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NDY1Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505054653", "bodyText": "Obsolete", "author": "pshipton", "createdAt": "2020-10-14T23:12:51Z", "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1788,11 +1788,11 @@ TraceException=Trc_SHR_SMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1\n \n TraceExit=Trc_SHR_CC_startup_Exit8 Overhead=1 Level=1 Template=\"CC startup: Exiting due to running nested on existing cache not containing cachelets\"\n \n-TraceEntry=Trc_SHR_CM_createNewCachelet_Entry Overhead=1 Level=1 Template=\"CM createNewCachelet: Entering\"\n-TraceExit=Trc_SHR_CM_createNewCachelet_Exit Overhead=1 Level=1 Template=\"CM createNewCachelet: Exiting with returnVal=0x%p\"\n+TraceEntry=Trc_SHR_CM_createNewCachelet_Entry Obsolete Overhead=1 Level=1 Template=\"CM createNewCachelet: Entering\"\n+TraceExit=Trc_SHR_CM_createNewCachelet_Exit Obsolete Overhead=1 Level=1 Template=\"CM createNewCachelet: Exiting with returnVal=0x%p\"\n \n-TraceEntry=Trc_SHR_CM_createNewChainedCache_Entry Overhead=1 Level=1 Template=\"CM createNewChainedCache: Entering with requiredSize=%d (0x%x)\"\n-TraceExit=Trc_SHR_CM_createNewChainedCache_Exit Overhead=1 Level=1 Template=\"CM createNewChainedCache: Exiting with newCache=0x%p\"\n+TraceEntry=Trc_SHR_CM_createNewChainedCache_Entry Obsolete Overhead=1 Level=1 Template=\"CM createNewChainedCache: Entering with requiredSize=%d (0x%x)\"\n+TraceExit=Trc_SHR_CM_createNewChainedCache_Exit Obsolete Overhead=1 Level=1 Template=\"CM createNewChainedCache: Exiting with newCache=0x%p\"\n \n TraceEvent=Trc_SHR_CM_writeROMClassToCache_classpathNotInNewSupercache Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Classpath not in current supercache. Re-storing.\"", "originalCommit": "bf3d5c6395d7545086d0abf175193af19ed0e3f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg0NDYyNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505844627", "bodyText": "Marked", "author": "alexey-anufriev", "createdAt": "2020-10-15T20:58:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NDY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NDgyNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505054824", "bodyText": "Obsolete", "author": "pshipton", "createdAt": "2020-10-14T23:13:07Z", "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1788,11 +1788,11 @@ TraceException=Trc_SHR_SMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1\n \n TraceExit=Trc_SHR_CC_startup_Exit8 Overhead=1 Level=1 Template=\"CC startup: Exiting due to running nested on existing cache not containing cachelets\"\n \n-TraceEntry=Trc_SHR_CM_createNewCachelet_Entry Overhead=1 Level=1 Template=\"CM createNewCachelet: Entering\"\n-TraceExit=Trc_SHR_CM_createNewCachelet_Exit Overhead=1 Level=1 Template=\"CM createNewCachelet: Exiting with returnVal=0x%p\"\n+TraceEntry=Trc_SHR_CM_createNewCachelet_Entry Obsolete Overhead=1 Level=1 Template=\"CM createNewCachelet: Entering\"\n+TraceExit=Trc_SHR_CM_createNewCachelet_Exit Obsolete Overhead=1 Level=1 Template=\"CM createNewCachelet: Exiting with returnVal=0x%p\"\n \n-TraceEntry=Trc_SHR_CM_createNewChainedCache_Entry Overhead=1 Level=1 Template=\"CM createNewChainedCache: Entering with requiredSize=%d (0x%x)\"\n-TraceExit=Trc_SHR_CM_createNewChainedCache_Exit Overhead=1 Level=1 Template=\"CM createNewChainedCache: Exiting with newCache=0x%p\"\n+TraceEntry=Trc_SHR_CM_createNewChainedCache_Entry Obsolete Overhead=1 Level=1 Template=\"CM createNewChainedCache: Entering with requiredSize=%d (0x%x)\"\n+TraceExit=Trc_SHR_CM_createNewChainedCache_Exit Obsolete Overhead=1 Level=1 Template=\"CM createNewChainedCache: Exiting with newCache=0x%p\"\n \n TraceEvent=Trc_SHR_CM_writeROMClassToCache_classpathNotInNewSupercache Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Classpath not in current supercache. Re-storing.\"\n TraceException=Trc_SHR_CM_writeROMClassToCache_failedToReStoreClasspath Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Failed to re-store classpath in new supercache. Classpath item=0x%p, size=%u. Supercache free=%u, total=%u. Cachelet free=%u, total=%u.\"", "originalCommit": "bf3d5c6395d7545086d0abf175193af19ed0e3f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg0NDU4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505844583", "bodyText": "Marked", "author": "alexey-anufriev", "createdAt": "2020-10-15T20:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NDgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NDk3MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505054970", "bodyText": "These 2 are Obsolete.", "author": "pshipton", "createdAt": "2020-10-14T23:13:19Z", "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1804,36 +1804,36 @@ TraceException=Trc_SHR_RMI_compareROMClasses_NoCachelet Overhead=1 Level=1 Templ\n TraceEntry=Trc_SHR_INIT_hookSerializeSharedCache_entry Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Entering hookSerializeSharedCache\"", "originalCommit": "bf3d5c6395d7545086d0abf175193af19ed0e3f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg0NDUzMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505844532", "bodyText": "Marked", "author": "alexey-anufriev", "createdAt": "2020-10-15T20:58:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NDk3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NTIwNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505055204", "bodyText": "Obsolete.", "author": "pshipton", "createdAt": "2020-10-14T23:13:37Z", "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1804,36 +1804,36 @@ TraceException=Trc_SHR_RMI_compareROMClasses_NoCachelet Overhead=1 Level=1 Templ\n TraceEntry=Trc_SHR_INIT_hookSerializeSharedCache_entry Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Entering hookSerializeSharedCache\"\n TraceExit=Trc_SHR_INIT_hookSerializeSharedCache_exit Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Exiting hookSerializeSharedCache\"", "originalCommit": "bf3d5c6395d7545086d0abf175193af19ed0e3f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg0NDM1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505844351", "bodyText": "Marked", "author": "alexey-anufriev", "createdAt": "2020-10-15T20:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NTIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NTM0NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505055345", "bodyText": "These 2 are Obsolete.", "author": "pshipton", "createdAt": "2020-10-14T23:13:50Z", "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1804,36 +1804,36 @@ TraceException=Trc_SHR_RMI_compareROMClasses_NoCachelet Overhead=1 Level=1 Templ\n TraceEntry=Trc_SHR_INIT_hookSerializeSharedCache_entry Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Entering hookSerializeSharedCache\"\n TraceExit=Trc_SHR_INIT_hookSerializeSharedCache_exit Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Exiting hookSerializeSharedCache\"\n \n-TraceEntry=Trc_SHR_OSC_Vmem_startup_Entry NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Entering cache name = %s, control dir = %s, cache size = %zu, numSems = %zd, create flags = 0x%zx, verbose flags = 0x%zx, openFlags = 0x%x\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_commonStartupFailure NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup failed\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_commonStartupSuccess NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup succeeded\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_detectedNetworkCache NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: detected network cache - aborting\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badfileopen NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open failed for cache path name = %s\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodfileopen NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open successful for cache path name = %s, file handle %d\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_failed_mutex_init NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to initialize mutex %zu\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized_mutexes NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Succeeded initializing mutexes\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badAcquireHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Acquire header write lock failed\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodAcquireHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully acquired header write lock\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_cacheNotInUse NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock acquired, cache is not in use\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_cacheInUse NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock not acquired, cache is in use\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_fileOpened NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: File length > 0, file opened\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_cacheTooSmall Noenv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Cache is too small even for OSCache header\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseAttachReadLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release attach read lock\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseAttachReadLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released attach read lock\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release header write lock\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released header write lock\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_closefilefailed NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Exiting - closeCacheFile failed\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_cacheNotInitialized NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attempting to open read-only but cache is not initialized\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_allocation_failed NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Memory allocation of %d bytes failed\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_callinginit NoEnv  Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Calling init with _mapDataAddr=%p, _mapDataLength=%zu, sharedClassMinAOTSize=%zd, sharedClassMaxAOTSize=%zd, sharedClassReadWriteBytes=%zd\"\n+TraceEntry=Trc_SHR_OSC_Vmem_startup_Entry NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Entering cache name = %s, control dir = %s, cache size = %zu, numSems = %zd, create flags = 0x%zx, verbose flags = 0x%zx, openFlags = 0x%x\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_commonStartupFailure NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup failed\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_commonStartupSuccess NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup succeeded\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_detectedNetworkCache NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: detected network cache - aborting\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badfileopen NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open failed for cache path name = %s\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodfileopen NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open successful for cache path name = %s, file handle %d\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_failed_mutex_init NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to initialize mutex %zu\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized_mutexes NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Succeeded initializing mutexes\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badAcquireHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Acquire header write lock failed\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodAcquireHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully acquired header write lock\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_cacheNotInUse NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock acquired, cache is not in use\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_cacheInUse NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock not acquired, cache is in use\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_fileOpened NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: File length > 0, file opened\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_cacheTooSmall Noenv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Cache is too small even for OSCache header\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseAttachReadLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release attach read lock\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseAttachReadLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released attach read lock\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release header write lock\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released header write lock\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_closefilefailed NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Exiting - closeCacheFile failed\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_cacheNotInitialized NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attempting to open read-only but cache is not initialized\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_allocation_failed NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Memory allocation of %d bytes failed\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_callinginit NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Calling init with _mapDataAddr=%p, _mapDataLength=%zu, sharedClassMinAOTSize=%zd, sharedClassMaxAOTSize=%zd, sharedClassReadWriteBytes=%zd\"\n TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Returned from init method\"", "originalCommit": "bf3d5c6395d7545086d0abf175193af19ed0e3f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg0NDMwMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505844301", "bodyText": "Marked", "author": "alexey-anufriev", "createdAt": "2020-10-15T20:58:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NTM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NTc0Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505055742", "bodyText": "These 4 are Obsolete.", "author": "pshipton", "createdAt": "2020-10-14T23:14:24Z", "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1804,36 +1804,36 @@ TraceException=Trc_SHR_RMI_compareROMClasses_NoCachelet Overhead=1 Level=1 Templ\n TraceEntry=Trc_SHR_INIT_hookSerializeSharedCache_entry Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Entering hookSerializeSharedCache\"\n TraceExit=Trc_SHR_INIT_hookSerializeSharedCache_exit Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Exiting hookSerializeSharedCache\"\n \n-TraceEntry=Trc_SHR_OSC_Vmem_startup_Entry NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Entering cache name = %s, control dir = %s, cache size = %zu, numSems = %zd, create flags = 0x%zx, verbose flags = 0x%zx, openFlags = 0x%x\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_commonStartupFailure NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup failed\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_commonStartupSuccess NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup succeeded\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_detectedNetworkCache NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: detected network cache - aborting\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badfileopen NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open failed for cache path name = %s\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodfileopen NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open successful for cache path name = %s, file handle %d\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_failed_mutex_init NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to initialize mutex %zu\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized_mutexes NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Succeeded initializing mutexes\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badAcquireHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Acquire header write lock failed\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodAcquireHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully acquired header write lock\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_cacheNotInUse NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock acquired, cache is not in use\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_cacheInUse NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock not acquired, cache is in use\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_fileOpened NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: File length > 0, file opened\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_cacheTooSmall Noenv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Cache is too small even for OSCache header\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseAttachReadLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release attach read lock\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseAttachReadLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released attach read lock\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release header write lock\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released header write lock\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_closefilefailed NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Exiting - closeCacheFile failed\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_cacheNotInitialized NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attempting to open read-only but cache is not initialized\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_allocation_failed NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Memory allocation of %d bytes failed\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_callinginit NoEnv  Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Calling init with _mapDataAddr=%p, _mapDataLength=%zu, sharedClassMinAOTSize=%zd, sharedClassMaxAOTSize=%zd, sharedClassReadWriteBytes=%zd\"\n+TraceEntry=Trc_SHR_OSC_Vmem_startup_Entry NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Entering cache name = %s, control dir = %s, cache size = %zu, numSems = %zd, create flags = 0x%zx, verbose flags = 0x%zx, openFlags = 0x%x\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_commonStartupFailure NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup failed\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_commonStartupSuccess NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup succeeded\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_detectedNetworkCache NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: detected network cache - aborting\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badfileopen NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open failed for cache path name = %s\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodfileopen NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open successful for cache path name = %s, file handle %d\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_failed_mutex_init NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to initialize mutex %zu\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized_mutexes NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Succeeded initializing mutexes\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badAcquireHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Acquire header write lock failed\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodAcquireHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully acquired header write lock\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_cacheNotInUse NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock acquired, cache is not in use\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_cacheInUse NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock not acquired, cache is in use\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_fileOpened NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: File length > 0, file opened\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_cacheTooSmall Noenv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Cache is too small even for OSCache header\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseAttachReadLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release attach read lock\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseAttachReadLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released attach read lock\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release header write lock\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released header write lock\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_closefilefailed NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Exiting - closeCacheFile failed\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_cacheNotInitialized NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attempting to open read-only but cache is not initialized\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_allocation_failed NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Memory allocation of %d bytes failed\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_callinginit NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Calling init with _mapDataAddr=%p, _mapDataLength=%zu, sharedClassMinAOTSize=%zd, sharedClassMaxAOTSize=%zd, sharedClassReadWriteBytes=%zd\"\n TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Returned from init method\"\n TraceExit=Trc_SHR_OSC_Vmem_startup_Exit NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successful exit\"\n \n-TraceEntry=Trc_SHR_OSC_Vmem_attach_Entry Obsolete NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Entered\"\n-TraceExit=Trc_SHR_OSC_Vmem_attach_corruptCacheHeader NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is corrupt\"\n-TraceExit=Trc_SHR_OSC_Vmem_attach_differentBuildID NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: cache has an unrecognised buildID\"\n-TraceExit=Trc_SHR_OSC_Vmem_attach_invalidCacheHeader NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is invalid\"\n-TraceExit=Trc_SHR_OSC_Vmem_attach_validCacheHeader NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is valid\"\n+TraceEntry=Trc_SHR_OSC_Vmem_attach_Entry NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Entered\"\n+TraceExit=Trc_SHR_OSC_Vmem_attach_corruptCacheHeader NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is corrupt\"\n+TraceExit=Trc_SHR_OSC_Vmem_attach_differentBuildID NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: cache has an unrecognised buildID\"\n+TraceExit=Trc_SHR_OSC_Vmem_attach_invalidCacheHeader NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is invalid\"\n+TraceExit=Trc_SHR_OSC_Vmem_attach_validCacheHeader NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is valid\"\n \n TraceEntry=Trc_SHR_M_startupHintCachelets_Entry Overhead=1 Level=1 Template=\"M startupHintCachelets: hint=%u\"", "originalCommit": "bf3d5c6395d7545086d0abf175193af19ed0e3f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg0NDIzNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505844236", "bodyText": "Marked", "author": "alexey-anufriev", "createdAt": "2020-10-15T20:58:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NTc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NTk4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505055988", "bodyText": "These 3 are Obsolete.", "author": "pshipton", "createdAt": "2020-10-14T23:14:43Z", "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1844,8 +1844,8 @@ TraceException=Trc_SHR_M_startupHintCachelets_lockStartupMonitorFailed Overhead=\n TraceException=Trc_SHR_RRM_rrmTableLookup_lockStartupMonitorFailed Overhead=1 Level=1 Template=\"RRM rrmTableLookup: Can't lock startup monitor, rc=%d, cachelet=0x%p, for hint=0x%p\"\n TraceException=Trc_SHR_CC_newInstanceNested_allocStartupMonitorFailed NoEnv Overhead=1 Level=1 Template=\"CC newInstanceNested: Failed to allocate _startupMonitor for cachelet %p\"\n \n-TraceEvent=Trc_SHR_CM_readCache_initCachelet Overhead=1 Level=1 Template=\"CM readCache: init new cachelet, cachelet=0x%p cacheletMemory=0x%p\"\n-TraceException=Trc_SHR_CM_readCache_initCacheletFailed Overhead=1 Level=1 Template=\"CM readCache: init new cachelet failed, cacheletMemory=0x%p\"\n+TraceEvent=Trc_SHR_CM_readCache_initCachelet Obsolete Overhead=1 Level=1 Template=\"CM readCache: init new cachelet, cachelet=0x%p cacheletMemory=0x%p\"\n+TraceException=Trc_SHR_CM_readCache_initCacheletFailed Obsolete Overhead=1 Level=1 Template=\"CM readCache: init new cachelet failed, cacheletMemory=0x%p\"\n TraceEvent=Trc_SHR_CM_readCacheletSegments_noSegments Overhead=1 Level=1 Template=\"CM readCacheletSegments: No class segments for cachelet 0x%p, wrapper=0x%p\"", "originalCommit": "bf3d5c6395d7545086d0abf175193af19ed0e3f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg0NDIxNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505844217", "bodyText": "Marked", "author": "alexey-anufriev", "createdAt": "2020-10-15T20:58:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NTk4OA=="}], "type": "inlineReview"}, {"oid": "1253518c01a6c38abe109969af22e325cf78855b", "url": "https://github.com/eclipse-openj9/openj9/commit/1253518c01a6c38abe109969af22e325cf78855b", "message": "Remove J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro\n\nThis patch removes J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro along with related code\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>", "committedDate": "2020-10-15T20:58:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwODE0NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505908144", "bodyText": "These two are Obsolete.", "author": "pshipton", "createdAt": "2020-10-15T22:51:59Z", "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1771,84 +1771,84 @@ TraceAssert=Trc_SHR_Assert_True_KNOWNPROBLEM NoEnv Obsolete Overhead=1 Level=3 A\n \n TraceExit=Trc_SHR_OSC_recreateSemaphore_Exit4Obsolete NoEnv Obsolete Overhead=1 Level=1 Group=OSCache Template=\"OSCache recreateSemaphore Exit, failure = semaphore id is different, semid in cache header=%d, current %d\"\n \n-TraceEvent=Trc_SHR_BDMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"BDMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n-TraceException=Trc_SHR_BDMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"BDMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n+TraceEvent=Trc_SHR_BDMI_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"BDMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n+TraceException=Trc_SHR_BDMI_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"BDMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n-TraceEvent=Trc_SHR_CMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"CMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n-TraceException=Trc_SHR_CMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"CMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n+TraceEvent=Trc_SHR_CMI_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"CMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n+TraceException=Trc_SHR_CMI_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"CMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n-TraceEvent=Trc_SHR_RMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"RMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n-TraceException=Trc_SHR_RMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"RMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n+TraceEvent=Trc_SHR_RMI_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"RMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n+TraceException=Trc_SHR_RMI_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"RMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n-TraceEvent=Trc_SHR_RRM_primeHashtables_addingHint Overhead=9 Level=9 Template=\"RRM primeHashtables: Adding hint, cachelet=0x%p hashValue=0x%p\"\n-TraceException=Trc_SHR_RRM_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"RRM primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=0x%p\"\n+TraceEvent=Trc_SHR_RRM_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"RRM primeHashtables: Adding hint, cachelet=0x%p hashValue=0x%p\"\n+TraceException=Trc_SHR_RRM_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"RRM primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=0x%p\"\n \n-TraceEvent=Trc_SHR_SMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"SMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n-TraceException=Trc_SHR_SMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"SMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n+TraceEvent=Trc_SHR_SMI_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"SMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n+TraceException=Trc_SHR_SMI_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"SMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n TraceExit=Trc_SHR_CC_startup_Exit8 Overhead=1 Level=1 Template=\"CC startup: Exiting due to running nested on existing cache not containing cachelets\"\n \n-TraceEntry=Trc_SHR_CM_createNewCachelet_Entry Overhead=1 Level=1 Template=\"CM createNewCachelet: Entering\"\n-TraceExit=Trc_SHR_CM_createNewCachelet_Exit Overhead=1 Level=1 Template=\"CM createNewCachelet: Exiting with returnVal=0x%p\"\n+TraceEntry=Trc_SHR_CM_createNewCachelet_Entry Obsolete Overhead=1 Level=1 Template=\"CM createNewCachelet: Entering\"\n+TraceExit=Trc_SHR_CM_createNewCachelet_Exit Obsolete Overhead=1 Level=1 Template=\"CM createNewCachelet: Exiting with returnVal=0x%p\"\n \n-TraceEntry=Trc_SHR_CM_createNewChainedCache_Entry Overhead=1 Level=1 Template=\"CM createNewChainedCache: Entering with requiredSize=%d (0x%x)\"\n-TraceExit=Trc_SHR_CM_createNewChainedCache_Exit Overhead=1 Level=1 Template=\"CM createNewChainedCache: Exiting with newCache=0x%p\"\n+TraceEntry=Trc_SHR_CM_createNewChainedCache_Entry Obsolete Overhead=1 Level=1 Template=\"CM createNewChainedCache: Entering with requiredSize=%d (0x%x)\"\n+TraceExit=Trc_SHR_CM_createNewChainedCache_Exit Obsolete Overhead=1 Level=1 Template=\"CM createNewChainedCache: Exiting with newCache=0x%p\"\n \n-TraceEvent=Trc_SHR_CM_writeROMClassToCache_classpathNotInNewSupercache Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Classpath not in current supercache. Re-storing.\"\n-TraceException=Trc_SHR_CM_writeROMClassToCache_failedToReStoreClasspath Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Failed to re-store classpath in new supercache. Classpath item=0x%p, size=%u. Supercache free=%u, total=%u. Cachelet free=%u, total=%u.\"\n+TraceEvent=Trc_SHR_CM_writeROMClassToCache_classpathNotInNewSupercache Obsolete Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Classpath not in current supercache. Re-storing.\"\n+TraceException=Trc_SHR_CM_writeROMClassToCache_failedToReStoreClasspath Obsolete Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Failed to re-store classpath in new supercache. Classpath item=0x%p, size=%u. Supercache free=%u, total=%u. Cachelet free=%u, total=%u.\"\n \n TraceExit=Trc_SHR_CM_addROMClassToCache_ExitFull Overhead=1 Level=1 Template=\"CM addROMClassToCache: Exiting due to full cache\"", "originalCommit": "1253518c01a6c38abe109969af22e325cf78855b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEyNzM2MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r506127360", "bodyText": "Marked.", "author": "alexey-anufriev", "createdAt": "2020-10-16T07:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwODE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwODY2OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505908669", "bodyText": "These 3 are Obsolete.", "author": "pshipton", "createdAt": "2020-10-15T22:53:32Z", "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1771,84 +1771,84 @@ TraceAssert=Trc_SHR_Assert_True_KNOWNPROBLEM NoEnv Obsolete Overhead=1 Level=3 A\n \n TraceExit=Trc_SHR_OSC_recreateSemaphore_Exit4Obsolete NoEnv Obsolete Overhead=1 Level=1 Group=OSCache Template=\"OSCache recreateSemaphore Exit, failure = semaphore id is different, semid in cache header=%d, current %d\"\n \n-TraceEvent=Trc_SHR_BDMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"BDMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n-TraceException=Trc_SHR_BDMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"BDMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n+TraceEvent=Trc_SHR_BDMI_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"BDMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n+TraceException=Trc_SHR_BDMI_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"BDMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n-TraceEvent=Trc_SHR_CMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"CMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n-TraceException=Trc_SHR_CMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"CMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n+TraceEvent=Trc_SHR_CMI_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"CMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n+TraceException=Trc_SHR_CMI_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"CMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n-TraceEvent=Trc_SHR_RMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"RMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n-TraceException=Trc_SHR_RMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"RMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n+TraceEvent=Trc_SHR_RMI_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"RMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n+TraceException=Trc_SHR_RMI_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"RMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n-TraceEvent=Trc_SHR_RRM_primeHashtables_addingHint Overhead=9 Level=9 Template=\"RRM primeHashtables: Adding hint, cachelet=0x%p hashValue=0x%p\"\n-TraceException=Trc_SHR_RRM_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"RRM primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=0x%p\"\n+TraceEvent=Trc_SHR_RRM_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"RRM primeHashtables: Adding hint, cachelet=0x%p hashValue=0x%p\"\n+TraceException=Trc_SHR_RRM_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"RRM primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=0x%p\"\n \n-TraceEvent=Trc_SHR_SMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"SMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n-TraceException=Trc_SHR_SMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"SMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n+TraceEvent=Trc_SHR_SMI_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"SMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n+TraceException=Trc_SHR_SMI_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"SMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n TraceExit=Trc_SHR_CC_startup_Exit8 Overhead=1 Level=1 Template=\"CC startup: Exiting due to running nested on existing cache not containing cachelets\"\n \n-TraceEntry=Trc_SHR_CM_createNewCachelet_Entry Overhead=1 Level=1 Template=\"CM createNewCachelet: Entering\"\n-TraceExit=Trc_SHR_CM_createNewCachelet_Exit Overhead=1 Level=1 Template=\"CM createNewCachelet: Exiting with returnVal=0x%p\"\n+TraceEntry=Trc_SHR_CM_createNewCachelet_Entry Obsolete Overhead=1 Level=1 Template=\"CM createNewCachelet: Entering\"\n+TraceExit=Trc_SHR_CM_createNewCachelet_Exit Obsolete Overhead=1 Level=1 Template=\"CM createNewCachelet: Exiting with returnVal=0x%p\"\n \n-TraceEntry=Trc_SHR_CM_createNewChainedCache_Entry Overhead=1 Level=1 Template=\"CM createNewChainedCache: Entering with requiredSize=%d (0x%x)\"\n-TraceExit=Trc_SHR_CM_createNewChainedCache_Exit Overhead=1 Level=1 Template=\"CM createNewChainedCache: Exiting with newCache=0x%p\"\n+TraceEntry=Trc_SHR_CM_createNewChainedCache_Entry Obsolete Overhead=1 Level=1 Template=\"CM createNewChainedCache: Entering with requiredSize=%d (0x%x)\"\n+TraceExit=Trc_SHR_CM_createNewChainedCache_Exit Obsolete Overhead=1 Level=1 Template=\"CM createNewChainedCache: Exiting with newCache=0x%p\"\n \n-TraceEvent=Trc_SHR_CM_writeROMClassToCache_classpathNotInNewSupercache Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Classpath not in current supercache. Re-storing.\"\n-TraceException=Trc_SHR_CM_writeROMClassToCache_failedToReStoreClasspath Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Failed to re-store classpath in new supercache. Classpath item=0x%p, size=%u. Supercache free=%u, total=%u. Cachelet free=%u, total=%u.\"\n+TraceEvent=Trc_SHR_CM_writeROMClassToCache_classpathNotInNewSupercache Obsolete Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Classpath not in current supercache. Re-storing.\"\n+TraceException=Trc_SHR_CM_writeROMClassToCache_failedToReStoreClasspath Obsolete Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Failed to re-store classpath in new supercache. Classpath item=0x%p, size=%u. Supercache free=%u, total=%u. Cachelet free=%u, total=%u.\"\n \n TraceExit=Trc_SHR_CM_addROMClassToCache_ExitFull Overhead=1 Level=1 Template=\"CM addROMClassToCache: Exiting due to full cache\"\n \n TraceException=Trc_SHR_RMI_compareROMClasses_NoCachelet Overhead=1 Level=1 Template=\"RMI compareROMClasses: ERROR: 0x%p not found in any cachelet\"\n \n-TraceEntry=Trc_SHR_INIT_hookSerializeSharedCache_entry Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Entering hookSerializeSharedCache\"\n-TraceExit=Trc_SHR_INIT_hookSerializeSharedCache_exit Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Exiting hookSerializeSharedCache\"\n-\n-TraceEntry=Trc_SHR_OSC_Vmem_startup_Entry NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Entering cache name = %s, control dir = %s, cache size = %zu, numSems = %zd, create flags = 0x%zx, verbose flags = 0x%zx, openFlags = 0x%x\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_commonStartupFailure NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup failed\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_commonStartupSuccess NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup succeeded\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_detectedNetworkCache NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: detected network cache - aborting\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badfileopen NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open failed for cache path name = %s\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodfileopen NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open successful for cache path name = %s, file handle %d\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_failed_mutex_init NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to initialize mutex %zu\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized_mutexes NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Succeeded initializing mutexes\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badAcquireHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Acquire header write lock failed\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodAcquireHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully acquired header write lock\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_cacheNotInUse NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock acquired, cache is not in use\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_cacheInUse NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock not acquired, cache is in use\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_fileOpened NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: File length > 0, file opened\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_cacheTooSmall Noenv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Cache is too small even for OSCache header\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseAttachReadLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release attach read lock\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseAttachReadLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released attach read lock\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release header write lock\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released header write lock\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_closefilefailed NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Exiting - closeCacheFile failed\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_cacheNotInitialized NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attempting to open read-only but cache is not initialized\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_allocation_failed NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Memory allocation of %d bytes failed\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_callinginit NoEnv  Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Calling init with _mapDataAddr=%p, _mapDataLength=%zu, sharedClassMinAOTSize=%zd, sharedClassMaxAOTSize=%zd, sharedClassReadWriteBytes=%zd\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Returned from init method\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_Exit NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successful exit\"\n-\n-TraceEntry=Trc_SHR_OSC_Vmem_attach_Entry Obsolete NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Entered\"\n-TraceExit=Trc_SHR_OSC_Vmem_attach_corruptCacheHeader NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is corrupt\"\n-TraceExit=Trc_SHR_OSC_Vmem_attach_differentBuildID NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: cache has an unrecognised buildID\"\n-TraceExit=Trc_SHR_OSC_Vmem_attach_invalidCacheHeader NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is invalid\"\n-TraceExit=Trc_SHR_OSC_Vmem_attach_validCacheHeader NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is valid\"\n-\n-TraceEntry=Trc_SHR_M_startupHintCachelets_Entry Overhead=1 Level=1 Template=\"M startupHintCachelets: hint=%u\"\n-TraceExit=Trc_SHR_M_startupHintCachelets_Exit Overhead=1 Level=1 Template=\"M startupHintCachelets: cacheletsStarted=%d\"\n-TraceEvent=Trc_SHR_M_startupHintCachelets_startingCacheletForHint Overhead=1 Level=1 Template=\"M startupHintCachelets: starting cachelet 0x%p from hint %u (0x%p)\"\n-TraceException=Trc_SHR_M_startupHintCachelets_startupCacheletFailed Overhead=1 Level=1 Template=\"M startupHintCachelets: Cachelet startup failed, rc=%d, cachelet=0x%p, hint=%u (0x%p)\"\n+TraceEntry=Trc_SHR_INIT_hookSerializeSharedCache_entry Noenv Obsolete Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Entering hookSerializeSharedCache\"\n+TraceExit=Trc_SHR_INIT_hookSerializeSharedCache_exit Noenv Obsolete Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Exiting hookSerializeSharedCache\"\n+\n+TraceEntry=Trc_SHR_OSC_Vmem_startup_Entry NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Entering cache name = %s, control dir = %s, cache size = %zu, numSems = %zd, create flags = 0x%zx, verbose flags = 0x%zx, openFlags = 0x%x\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_commonStartupFailure NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup failed\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_commonStartupSuccess NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup succeeded\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_detectedNetworkCache NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: detected network cache - aborting\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badfileopen NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open failed for cache path name = %s\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodfileopen NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open successful for cache path name = %s, file handle %d\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_failed_mutex_init NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to initialize mutex %zu\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized_mutexes NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Succeeded initializing mutexes\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badAcquireHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Acquire header write lock failed\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodAcquireHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully acquired header write lock\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_cacheNotInUse NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock acquired, cache is not in use\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_cacheInUse NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock not acquired, cache is in use\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_fileOpened NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: File length > 0, file opened\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_cacheTooSmall Noenv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Cache is too small even for OSCache header\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseAttachReadLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release attach read lock\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseAttachReadLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released attach read lock\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release header write lock\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released header write lock\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_closefilefailed NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Exiting - closeCacheFile failed\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_cacheNotInitialized NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attempting to open read-only but cache is not initialized\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_allocation_failed NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Memory allocation of %d bytes failed\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_callinginit NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Calling init with _mapDataAddr=%p, _mapDataLength=%zu, sharedClassMinAOTSize=%zd, sharedClassMaxAOTSize=%zd, sharedClassReadWriteBytes=%zd\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Returned from init method\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_Exit NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successful exit\"\n+\n+TraceEntry=Trc_SHR_OSC_Vmem_attach_Entry NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Entered\"\n+TraceExit=Trc_SHR_OSC_Vmem_attach_corruptCacheHeader NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is corrupt\"\n+TraceExit=Trc_SHR_OSC_Vmem_attach_differentBuildID NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: cache has an unrecognised buildID\"\n+TraceExit=Trc_SHR_OSC_Vmem_attach_invalidCacheHeader NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is invalid\"\n+TraceExit=Trc_SHR_OSC_Vmem_attach_validCacheHeader NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is valid\"\n+\n+TraceEntry=Trc_SHR_M_startupHintCachelets_Entry Obsolete Overhead=1 Level=1 Template=\"M startupHintCachelets: hint=%u\"\n+TraceExit=Trc_SHR_M_startupHintCachelets_Exit Obsolete Overhead=1 Level=1 Template=\"M startupHintCachelets: cacheletsStarted=%d\"\n+TraceEvent=Trc_SHR_M_startupHintCachelets_startingCacheletForHint Obsolete Overhead=1 Level=1 Template=\"M startupHintCachelets: starting cachelet 0x%p from hint %u (0x%p)\"\n+TraceException=Trc_SHR_M_startupHintCachelets_startupCacheletFailed Obsolete Overhead=1 Level=1 Template=\"M startupHintCachelets: Cachelet startup failed, rc=%d, cachelet=0x%p, hint=%u (0x%p)\"\n TraceException=Trc_SHR_M_startupHintCachelets_lockStartupMonitorFailed Overhead=1 Level=1 Template=\"M startupHintCachelets: Can't lock startup monitor, rc=%d, cachelet=0x%p, for hint=%u (0x%p)\"", "originalCommit": "1253518c01a6c38abe109969af22e325cf78855b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEyNzQyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r506127422", "bodyText": "Marked.", "author": "alexey-anufriev", "createdAt": "2020-10-16T07:36:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwODY2OQ=="}], "type": "inlineReview"}, {"oid": "153d72e8c769600d918c06e83e091208d1594748", "url": "https://github.com/eclipse-openj9/openj9/commit/153d72e8c769600d918c06e83e091208d1594748", "message": "Remove J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro\n\nThis patch removes J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro along with related code\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>", "committedDate": "2020-10-16T07:35:28Z", "type": "commit"}, {"oid": "153d72e8c769600d918c06e83e091208d1594748", "url": "https://github.com/eclipse-openj9/openj9/commit/153d72e8c769600d918c06e83e091208d1594748", "message": "Remove J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro\n\nThis patch removes J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro along with related code\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>", "committedDate": "2020-10-16T07:35:28Z", "type": "forcePushed"}]}