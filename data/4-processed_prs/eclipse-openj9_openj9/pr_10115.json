{"pr_number": 10115, "pr_title": "Add TypeLayoutEntry build for flattened fields", "pr_createdAt": "2020-07-08T14:22:51Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10115", "timeline": [{"oid": "d9540a6d694b86a679581141668f5b22425549ed", "url": "https://github.com/eclipse-openj9/openj9/commit/d9540a6d694b86a679581141668f5b22425549ed", "message": "Add TypeLayoutEntry build for flattened fields\n\nCreate TypeLayoutEntry for flattened fields with adjusted\noffset from the top level class for value types.\n\nThis change was originally authored by Yi Zhang\nwho is listed as a co-author below.\n\nCo-authored-by: Yi Zhang yizhang@ca.ibm.com\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-07-10T19:35:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNzk4OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r459837989", "bodyText": "The field signature might be a class name or it might indicate the field is a primitive.  I would suggest renaming classNameData and classNameLength to signatureData and signatureLength to prevent anyone from thinking it must be a class.", "author": "hzongaro", "createdAt": "2020-07-24T03:40:22Z", "path": "runtime/compiler/env/J9ClassEnv.cpp", "diffHunk": "@@ -417,24 +418,81 @@ J9::ClassEnv::isAnonymousClass(TR::Compilation *comp, TR_OpaqueClassBlock *clazz\n    return comp->fej9()->isAnonymousClass(clazz);\n    }\n \n-const TR::TypeLayout*\n-J9::ClassEnv::enumerateFields(TR::Region& region, TR_OpaqueClassBlock * opaqueClazz, TR::Compilation *comp)\n-   {  \n-   J9Class *clazz = (J9Class*)opaqueClazz;\n-   TR_VMFieldsInfo fieldsInfo(comp, clazz, 1, stackAlloc);\n-   ListIterator<TR_VMField> iter(fieldsInfo.getFields());\n-   TR::TypeLayoutBuilder tlb(region);\n-   for (TR_VMField *field = iter.getFirst(); field; field = iter.getNext())\n+/*\n+ * \\param prefix\n+ *    prefix is ended with `.`\n+ */\n+static char * mergeFieldNames(char * prefix, char * fieldName, bool withDotAtTheEnd, TR::Region &region)\n+   {\n+   int prefixLength = prefix ? strlen(prefix) : 0;\n+   int nameLength = strlen(fieldName);\n+   int mergedLength = nameLength + prefixLength;\n+\n+   if (withDotAtTheEnd)\n+      mergedLength++;\n+   mergedLength++; /* for adding \\0 at the end */;\n+\n+   char * newName = new (region) char[mergedLength];\n+   if (prefixLength > 0)\n+      strncpy(newName, prefix, prefixLength);\n+\n+   strncpy(newName + prefixLength, fieldName, nameLength);\n+\n+   if (withDotAtTheEnd)\n+      newName[mergedLength-2] = '.';\n+   newName[mergedLength-1] = '\\0';\n+   return newName;\n+   }\n+\n+static bool isFieldShapeQType(J9ROMFieldShape * shape)\n+   {\n+   // QType field signature example: \"QNestedB;\"\n+   bool isQType = false;\n+   J9UTF8 * signature = J9ROMNAMEANDSIGNATURE_SIGNATURE(&shape->nameAndSignature);\n+   U_8 * classNameData = J9UTF8_DATA(signature);\n+   U_16 classNameLength = J9UTF8_LENGTH(signature);", "originalCommit": "d9540a6d694b86a679581141668f5b22425549ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzODkxNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r459838917", "bodyText": "I would suggest renaming withDotAtTheEnd to indicate the purpose - maybe, lastFieldInFlattenedChain or something like that?  I know that's not a great name - hopefully you can think of something better. . . .", "author": "hzongaro", "createdAt": "2020-07-24T03:45:18Z", "path": "runtime/compiler/env/J9ClassEnv.cpp", "diffHunk": "@@ -417,24 +418,81 @@ J9::ClassEnv::isAnonymousClass(TR::Compilation *comp, TR_OpaqueClassBlock *clazz\n    return comp->fej9()->isAnonymousClass(clazz);\n    }\n \n-const TR::TypeLayout*\n-J9::ClassEnv::enumerateFields(TR::Region& region, TR_OpaqueClassBlock * opaqueClazz, TR::Compilation *comp)\n-   {  \n-   J9Class *clazz = (J9Class*)opaqueClazz;\n-   TR_VMFieldsInfo fieldsInfo(comp, clazz, 1, stackAlloc);\n-   ListIterator<TR_VMField> iter(fieldsInfo.getFields());\n-   TR::TypeLayoutBuilder tlb(region);\n-   for (TR_VMField *field = iter.getFirst(); field; field = iter.getNext())\n+/*\n+ * \\param prefix\n+ *    prefix is ended with `.`\n+ */\n+static char * mergeFieldNames(char * prefix, char * fieldName, bool withDotAtTheEnd, TR::Region &region)", "originalCommit": "d9540a6d694b86a679581141668f5b22425549ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDYwODk1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r460608956", "bodyText": "I'll change it to buildFlattenedFieldPrefix. mergeFieldNames() is called recursively and the name is merged from the top level down to the bottom.", "author": "a7ehuo", "createdAt": "2020-07-27T01:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzODkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzOTk0Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r459839947", "bodyText": "I'm not sure whether these unguarded calls to traceMsg should be kept here.", "author": "hzongaro", "createdAt": "2020-07-24T03:51:23Z", "path": "runtime/compiler/env/J9ClassEnv.cpp", "diffHunk": "@@ -417,24 +418,81 @@ J9::ClassEnv::isAnonymousClass(TR::Compilation *comp, TR_OpaqueClassBlock *clazz\n    return comp->fej9()->isAnonymousClass(clazz);\n    }\n \n-const TR::TypeLayout*\n-J9::ClassEnv::enumerateFields(TR::Region& region, TR_OpaqueClassBlock * opaqueClazz, TR::Compilation *comp)\n-   {  \n-   J9Class *clazz = (J9Class*)opaqueClazz;\n-   TR_VMFieldsInfo fieldsInfo(comp, clazz, 1, stackAlloc);\n-   ListIterator<TR_VMField> iter(fieldsInfo.getFields());\n-   TR::TypeLayoutBuilder tlb(region);\n-   for (TR_VMField *field = iter.getFirst(); field; field = iter.getNext())\n+/*\n+ * \\param prefix\n+ *    prefix is ended with `.`\n+ */\n+static char * mergeFieldNames(char * prefix, char * fieldName, bool withDotAtTheEnd, TR::Region &region)\n+   {\n+   int prefixLength = prefix ? strlen(prefix) : 0;\n+   int nameLength = strlen(fieldName);\n+   int mergedLength = nameLength + prefixLength;\n+\n+   if (withDotAtTheEnd)\n+      mergedLength++;\n+   mergedLength++; /* for adding \\0 at the end */;\n+\n+   char * newName = new (region) char[mergedLength];\n+   if (prefixLength > 0)\n+      strncpy(newName, prefix, prefixLength);\n+\n+   strncpy(newName + prefixLength, fieldName, nameLength);\n+\n+   if (withDotAtTheEnd)\n+      newName[mergedLength-2] = '.';\n+   newName[mergedLength-1] = '\\0';\n+   return newName;\n+   }\n+\n+static bool isFieldShapeQType(J9ROMFieldShape * shape)\n+   {\n+   // QType field signature example: \"QNestedB;\"\n+   bool isQType = false;\n+   J9UTF8 * signature = J9ROMNAMEANDSIGNATURE_SIGNATURE(&shape->nameAndSignature);\n+   U_8 * classNameData = J9UTF8_DATA(signature);\n+   U_16 classNameLength = J9UTF8_LENGTH(signature);\n+\n+   if ((classNameLength > 0) &&\n+       (';' == classNameData[classNameLength - 1]) &&\n+       ('Q' == classNameData[0]))\n+      {\n+      isQType = true;\n+      }\n+   return isQType;\n+   }\n+\n+static void addEntryForField(TR_VMField *field, TR::TypeLayoutBuilder &tlb, TR::Region& region, J9Class * definingClass,\n+                             char * prefix, IDATA offsetBase, TR::Compilation * comp)\n+   {\n+   J9JavaVM *vm = comp->fej9()->getJ9JITConfig()->javaVM;\n+   if (isFieldShapeQType(field->shape) &&\n+       vm->internalVMFunctions->isFlattenableFieldFlattened(definingClass, field->shape))\n+      {\n+      char * prefixForChild = mergeFieldNames(prefix, field->name, true /*withDotAtTheEnd*/, comp->trMemory()->currentStackRegion());\n+      IDATA offsetBaseForChild = field->offset + offsetBase;\n+      traceMsg(comp, \"field %s:%s is flattened. offset from TR_VMField %d, offset from fcc %d\\n\",\n+            field->name, field->signature, field->offset,\n+            vm->internalVMFunctions->getFlattenableFieldOffset(definingClass, field->shape));", "originalCommit": "d9540a6d694b86a679581141668f5b22425549ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzOTk4MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r459839980", "bodyText": "I'm not sure whether these unguarded calls to traceMsg should be kept here.", "author": "hzongaro", "createdAt": "2020-07-24T03:51:34Z", "path": "runtime/compiler/env/J9ClassEnv.cpp", "diffHunk": "@@ -464,16 +522,28 @@ J9::ClassEnv::enumerateFields(TR::Region& region, TR_OpaqueClassBlock * opaqueCl\n             break;\n             }\n          }\n-      size_t nameSize = strlen(field->name)+1;\n-      char *fieldName = new (region) char[nameSize];\n-      strncpy(fieldName, field->name, nameSize);\n-      TR_ASSERT_FATAL(fieldName[nameSize-1] == '\\0', \"fieldName buffer was too small.\");\n-      int32_t offset = field->offset + TR::Compiler->om.objectHeaderSizeInBytes();\n+\n+      char *fieldName = mergeFieldNames(prefix, field->name, false /* withDotAtTheEnd */ , region);\n+      int32_t offset = offsetBase + field->offset + TR::Compiler->om.objectHeaderSizeInBytes();\n       bool isVolatile = (field->modifiers & J9AccVolatile) ? true : false;\n       bool isPrivate = (field->modifiers & J9AccPrivate) ? true : false;\n       bool isFinal = (field->modifiers & J9AccFinal) ? true : false;\n+      traceMsg(comp, \"type layout definingClass %p field: %s, field offset: %d offsetBase %d\\n\", definingClass, fieldName, field->offset, offsetBase);", "originalCommit": "d9540a6d694b86a679581141668f5b22425549ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA5NTU5NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r460095595", "bodyText": "Likely we'd care about such information during ILGen phase, I'll guard it with TR_TraceILGen, although it shouldn't cause any issue since the definition of traceMsg checks if (comp)->getDebug() exists.\nhttps://github.com/eclipse/openj9-omr/blob/025d6b2b62be8def4c8887e5c92f71195d037042/compiler/compile/OMRCompilation.hpp#L260-L264\n         #define traceMsg(comp, msg, ...) \\\n      ((comp)->getDebug() ? \\\n            (comp)->getDebug()->trace(msg, ##__VA_ARGS__) : \\\n            (void)0)", "author": "a7ehuo", "createdAt": "2020-07-24T14:40:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzOTk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEwMzEzOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r460103139", "bodyText": "Unguarded traceMsg calls don't normally cause functional issues (as you said, it checks if comp->getDebug() exists) but it can be a bit annoying when you get extra trace information you didn't ask for (e.g. you only specified traceFull but still got trace messages from ilgen). \ud83d\ude09", "author": "Leonardo2718", "createdAt": "2020-07-24T14:52:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzOTk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg0NzMwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r459847306", "bodyText": "You might want to note that the prefix can be NULL.", "author": "hzongaro", "createdAt": "2020-07-24T04:33:04Z", "path": "runtime/compiler/env/J9ClassEnv.cpp", "diffHunk": "@@ -417,24 +418,81 @@ J9::ClassEnv::isAnonymousClass(TR::Compilation *comp, TR_OpaqueClassBlock *clazz\n    return comp->fej9()->isAnonymousClass(clazz);\n    }\n \n-const TR::TypeLayout*\n-J9::ClassEnv::enumerateFields(TR::Region& region, TR_OpaqueClassBlock * opaqueClazz, TR::Compilation *comp)\n-   {  \n-   J9Class *clazz = (J9Class*)opaqueClazz;\n-   TR_VMFieldsInfo fieldsInfo(comp, clazz, 1, stackAlloc);\n-   ListIterator<TR_VMField> iter(fieldsInfo.getFields());\n-   TR::TypeLayoutBuilder tlb(region);\n-   for (TR_VMField *field = iter.getFirst(); field; field = iter.getNext())\n+/*\n+ * \\param prefix\n+ *    prefix is ended with `.`", "originalCommit": "d9540a6d694b86a679581141668f5b22425549ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAxNTMwOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r460015309", "bodyText": "I have this nagging concern about the number of allocations of char arrays and string copies that are happening to create the prefixes as things go along.  If you picture the recursion through the fields as a tree, there are allocations and copies of the prefix for each internal node of the tree, as well as for each leaf node.  I know the copies for the leaf nodes are required, but the copies for the internal nodes feel like overhead.\nBut to avoid all of that, I think the code would need to allocate a buffer for the maximum prefix length, or pass around an array of pointers to the pieces of the prefix, copying only at the leaf nodes.  And that would only avoid most of the copying for the internal nodes in the tree, not the leaf nodes.\nSo maybe the extra complication isn't worth it, but it might be something to keep in mind or at least run an experiment. . . .", "author": "hzongaro", "createdAt": "2020-07-24T12:14:06Z", "path": "runtime/compiler/env/J9ClassEnv.cpp", "diffHunk": "@@ -417,24 +418,81 @@ J9::ClassEnv::isAnonymousClass(TR::Compilation *comp, TR_OpaqueClassBlock *clazz\n    return comp->fej9()->isAnonymousClass(clazz);\n    }\n \n-const TR::TypeLayout*\n-J9::ClassEnv::enumerateFields(TR::Region& region, TR_OpaqueClassBlock * opaqueClazz, TR::Compilation *comp)\n-   {  \n-   J9Class *clazz = (J9Class*)opaqueClazz;\n-   TR_VMFieldsInfo fieldsInfo(comp, clazz, 1, stackAlloc);\n-   ListIterator<TR_VMField> iter(fieldsInfo.getFields());\n-   TR::TypeLayoutBuilder tlb(region);\n-   for (TR_VMField *field = iter.getFirst(); field; field = iter.getNext())\n+/*\n+ * \\param prefix\n+ *    prefix is ended with `.`\n+ */\n+static char * mergeFieldNames(char * prefix, char * fieldName, bool withDotAtTheEnd, TR::Region &region)\n+   {\n+   int prefixLength = prefix ? strlen(prefix) : 0;\n+   int nameLength = strlen(fieldName);\n+   int mergedLength = nameLength + prefixLength;\n+\n+   if (withDotAtTheEnd)\n+      mergedLength++;\n+   mergedLength++; /* for adding \\0 at the end */;\n+\n+   char * newName = new (region) char[mergedLength];", "originalCommit": "d9540a6d694b86a679581141668f5b22425549ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA3NTY2MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r460075661", "bodyText": "I think what you want here is a Radix Tree.\nMoving to a clean Radix Tree representation is doable but will require a lot of work. To keep the complexity contained, we would have to refactor all the APIs that currently use strings (at least that ones related to type signatures and symrefs) to work in terms of tree nodes.", "author": "Leonardo2718", "createdAt": "2020-07-24T14:08:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAxNTMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU5Mjg2Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r460592867", "bodyText": "I wasn't thinking of going as far as that.  I was thinking purely in the context of the one time creation of the flattened field names.  If there was a prepass, say, that determined the maximum length of the flattened and merged field names, a prefix buffer could be allocated.  The name of the \"root\" field could be copied into the prefix buffer just once, each of its child field's names could be copied into the prefix buffer just once, etc.\nWhether any of this is really worth it really depends on to what extent we might have large value types that are nested \"several\" levels deep.  Maybe it's not worth considering right now, so I will withdraw this comment.\nA simple small improvement that is worth making is adding a prefixLength argument to mergeFieldNames.  At least that would avoid the repeated calls to strlen(prefix), when that is already known by the caller.", "author": "hzongaro", "createdAt": "2020-07-27T00:21:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAxNTMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDYxMTczMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r460611731", "bodyText": "A simple small improvement that is worth making is adding a prefixLength argument to mergeFieldNames\n\nI'll take a look at how to improve it. addEntryForField() is invoked recursively, so is mergeFieldNames(). To avoid the call of strlen(prefix) inside mergeFieldNames(), on top of my head I think the calculated length would need to be passed as a parameter through addEntryForField()  and mergeFieldNames() , and mergeFieldNames() needs to return the new length back for the child field.", "author": "a7ehuo", "createdAt": "2020-07-27T02:10:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAxNTMwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAyMTczNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r460021736", "bodyText": "Leo @Leonardo2718 is working on using helpers to load and store flattened fields.  Will those changes need symrefs for the aggregate fields to exist?  I'm just wondering whether the flattening of the symrefs should happen unconditionally like this or whether they should not be flattened if the JIT will use the load and store helpers.", "author": "hzongaro", "createdAt": "2020-07-24T12:28:53Z", "path": "runtime/compiler/env/J9ClassEnv.cpp", "diffHunk": "@@ -417,24 +418,81 @@ J9::ClassEnv::isAnonymousClass(TR::Compilation *comp, TR_OpaqueClassBlock *clazz\n    return comp->fej9()->isAnonymousClass(clazz);\n    }\n \n-const TR::TypeLayout*\n-J9::ClassEnv::enumerateFields(TR::Region& region, TR_OpaqueClassBlock * opaqueClazz, TR::Compilation *comp)\n-   {  \n-   J9Class *clazz = (J9Class*)opaqueClazz;\n-   TR_VMFieldsInfo fieldsInfo(comp, clazz, 1, stackAlloc);\n-   ListIterator<TR_VMField> iter(fieldsInfo.getFields());\n-   TR::TypeLayoutBuilder tlb(region);\n-   for (TR_VMField *field = iter.getFirst(); field; field = iter.getNext())\n+/*\n+ * \\param prefix\n+ *    prefix is ended with `.`\n+ */\n+static char * mergeFieldNames(char * prefix, char * fieldName, bool withDotAtTheEnd, TR::Region &region)\n+   {\n+   int prefixLength = prefix ? strlen(prefix) : 0;\n+   int nameLength = strlen(fieldName);\n+   int mergedLength = nameLength + prefixLength;\n+\n+   if (withDotAtTheEnd)\n+      mergedLength++;\n+   mergedLength++; /* for adding \\0 at the end */;\n+\n+   char * newName = new (region) char[mergedLength];\n+   if (prefixLength > 0)\n+      strncpy(newName, prefix, prefixLength);\n+\n+   strncpy(newName + prefixLength, fieldName, nameLength);\n+\n+   if (withDotAtTheEnd)\n+      newName[mergedLength-2] = '.';\n+   newName[mergedLength-1] = '\\0';\n+   return newName;\n+   }\n+\n+static bool isFieldShapeQType(J9ROMFieldShape * shape)\n+   {\n+   // QType field signature example: \"QNestedB;\"\n+   bool isQType = false;\n+   J9UTF8 * signature = J9ROMNAMEANDSIGNATURE_SIGNATURE(&shape->nameAndSignature);\n+   U_8 * classNameData = J9UTF8_DATA(signature);\n+   U_16 classNameLength = J9UTF8_LENGTH(signature);\n+\n+   if ((classNameLength > 0) &&\n+       (';' == classNameData[classNameLength - 1]) &&\n+       ('Q' == classNameData[0]))\n+      {\n+      isQType = true;\n+      }\n+   return isQType;\n+   }\n+\n+static void addEntryForField(TR_VMField *field, TR::TypeLayoutBuilder &tlb, TR::Region& region, J9Class * definingClass,\n+                             char * prefix, IDATA offsetBase, TR::Compilation * comp)\n+   {\n+   J9JavaVM *vm = comp->fej9()->getJ9JITConfig()->javaVM;\n+   if (isFieldShapeQType(field->shape) &&\n+       vm->internalVMFunctions->isFlattenableFieldFlattened(definingClass, field->shape))", "originalCommit": "d9540a6d694b86a679581141668f5b22425549ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA2MjIwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r460062208", "bodyText": "The code I have doesn't need the symrefs for the aggregate fields. The helpers can handle both flattened and unflattened fields so my code just needs to check whether the field is a QType. The new symrefs will be needed however if we want to add fastpaths around the calls (or at least have some way of determining whether a flattenable if is flattened).", "author": "Leonardo2718", "createdAt": "2020-07-24T13:46:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAyMTczNg=="}], "type": "inlineReview"}, {"oid": "0518ee63f9b9413a5446956876a9c302787cf5cd", "url": "https://github.com/eclipse-openj9/openj9/commit/0518ee63f9b9413a5446956876a9c302787cf5cd", "message": "Add TypeLayoutEntry build for flattened fields\n\nCreate TypeLayoutEntry for flattened fields with adjusted\noffset from the top level class for value types.\n\nThis change was originally authored by Yi Zhang\nwho is listed as a co-author below.\n\nCo-authored-by: Yi Zhang yizhang@ca.ibm.com\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-07-27T18:55:26Z", "type": "forcePushed"}, {"oid": "6091388627a4473bcaa214a00899a88446ee8082", "url": "https://github.com/eclipse-openj9/openj9/commit/6091388627a4473bcaa214a00899a88446ee8082", "message": "Add TypeLayoutEntry build for flattened fields\n\nCreate TypeLayoutEntry for flattened fields with adjusted\noffset from the top level class for value types.\n\nThis change was originally authored by Yi Zhang\nwho is listed as a co-author below.\n\nCo-authored-by: Yi Zhang yizhang@ca.ibm.com\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-08-05T13:49:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMTQ5OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r465811499", "bodyText": "why is this called bTrace? shouldn't it be trace or traceILGen or something a bit more intuitive?", "author": "andrewcraik", "createdAt": "2020-08-05T15:27:30Z", "path": "runtime/compiler/env/J9ClassEnv.cpp", "diffHunk": "@@ -417,24 +418,79 @@ J9::ClassEnv::isAnonymousClass(TR::Compilation *comp, TR_OpaqueClassBlock *clazz\n    return comp->fej9()->isAnonymousClass(clazz);\n    }\n \n-const TR::TypeLayout*\n-J9::ClassEnv::enumerateFields(TR::Region& region, TR_OpaqueClassBlock * opaqueClazz, TR::Compilation *comp)\n-   {  \n-   J9Class *clazz = (J9Class*)opaqueClazz;\n-   TR_VMFieldsInfo fieldsInfo(comp, clazz, 1, stackAlloc);\n-   ListIterator<TR_VMField> iter(fieldsInfo.getFields());\n-   TR::TypeLayoutBuilder tlb(region);\n-   for (TR_VMField *field = iter.getFirst(); field; field = iter.getNext())\n+/*\n+ * \\param prefix\n+ *    prefix could be ended with `.` or NULL.\n+ * \\param prefixLength\n+ *    The length of the prefix string.\n+ * \\param toConcatenateAsPrefix\n+ *    If true, the new name is appended with \".\" to be used as a part of the flattened field chain name.\n+ * \\param mergedLength\n+ *    The merged length of the concatenated field name that is returned to the caller.\n+ */\n+static char * mergeFieldNames(char * prefix, uint32_t prefixLength, J9ROMFieldShape * field,\n+                              bool toConcatenateAsPrefix, TR::Region &region, uint32_t &mergedLength)\n+   {\n+   J9UTF8 * fieldNameUTF = J9ROMFIELDSHAPE_NAME(field);\n+   char * fieldName = reinterpret_cast<char *>(J9UTF8_DATA(fieldNameUTF));\n+   uint32_t nameLength = J9UTF8_LENGTH(fieldNameUTF);\n+\n+   mergedLength = nameLength + prefixLength;\n+   if (toConcatenateAsPrefix)\n+      mergedLength++;\n+   mergedLength++; /* for adding \\0 at the end */\n+\n+   char * newName = new (region) char[mergedLength];\n+\n+   if (prefixLength > 0)\n+      strncpy(newName, prefix, prefixLength);\n+   strncpy(newName + prefixLength, fieldName, nameLength);\n+\n+   if (toConcatenateAsPrefix)\n+      newName[mergedLength-2] = '.';\n+   newName[mergedLength-1] = '\\0';\n+\n+   return newName;\n+   }\n+\n+static void addEntryForField(TR_VMField * field, TR::TypeLayoutBuilder &tlb, TR::Region& region, J9Class * definingClass,\n+                             char * prefix, uint32_t prefixLength, IDATA offsetBase, TR::Compilation * comp)\n+   {\n+   J9JavaVM * vm = comp->fej9()->getJ9JITConfig()->javaVM;\n+   bool bTrace = comp->getOption(TR_TraceILGen);", "originalCommit": "6091388627a4473bcaa214a00899a88446ee8082", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxODk0Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r465818942", "bodyText": "b is to indicate the variable type is a boolean. I'll change it to trace to be consistent with the rest of the file.", "author": "a7ehuo", "createdAt": "2020-08-05T15:38:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMTQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMjYxMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r465812613", "bodyText": "Not a huge fan of the bool here - it is hard to read - an enum would be better or perhaps two functions with an impl using a boolean flag - I just don't like the boolean flags spraying all over the codebase....", "author": "andrewcraik", "createdAt": "2020-08-05T15:29:06Z", "path": "runtime/compiler/env/J9ClassEnv.cpp", "diffHunk": "@@ -417,24 +418,79 @@ J9::ClassEnv::isAnonymousClass(TR::Compilation *comp, TR_OpaqueClassBlock *clazz\n    return comp->fej9()->isAnonymousClass(clazz);\n    }\n \n-const TR::TypeLayout*\n-J9::ClassEnv::enumerateFields(TR::Region& region, TR_OpaqueClassBlock * opaqueClazz, TR::Compilation *comp)\n-   {  \n-   J9Class *clazz = (J9Class*)opaqueClazz;\n-   TR_VMFieldsInfo fieldsInfo(comp, clazz, 1, stackAlloc);\n-   ListIterator<TR_VMField> iter(fieldsInfo.getFields());\n-   TR::TypeLayoutBuilder tlb(region);\n-   for (TR_VMField *field = iter.getFirst(); field; field = iter.getNext())\n+/*\n+ * \\param prefix\n+ *    prefix could be ended with `.` or NULL.\n+ * \\param prefixLength\n+ *    The length of the prefix string.\n+ * \\param toConcatenateAsPrefix\n+ *    If true, the new name is appended with \".\" to be used as a part of the flattened field chain name.\n+ * \\param mergedLength\n+ *    The merged length of the concatenated field name that is returned to the caller.\n+ */\n+static char * mergeFieldNames(char * prefix, uint32_t prefixLength, J9ROMFieldShape * field,", "originalCommit": "6091388627a4473bcaa214a00899a88446ee8082", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzMTEyOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r465831128", "bodyText": "I'll use two functions. something like\n\nmergeFieldNames : simply merge names without appending .\nbuildTransitiveFieldNames : merge names with . at the end.", "author": "a7ehuo", "createdAt": "2020-08-05T15:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMjYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMzk2Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r465813967", "bodyText": "can we keep the definingClass as an OpaqueClassBlock and only do the cast internally when passing to the VM APIs to keep consistency in how the JIT code uses the types?", "author": "andrewcraik", "createdAt": "2020-08-05T15:31:07Z", "path": "runtime/compiler/env/J9ClassEnv.cpp", "diffHunk": "@@ -417,24 +418,79 @@ J9::ClassEnv::isAnonymousClass(TR::Compilation *comp, TR_OpaqueClassBlock *clazz\n    return comp->fej9()->isAnonymousClass(clazz);\n    }\n \n-const TR::TypeLayout*\n-J9::ClassEnv::enumerateFields(TR::Region& region, TR_OpaqueClassBlock * opaqueClazz, TR::Compilation *comp)\n-   {  \n-   J9Class *clazz = (J9Class*)opaqueClazz;\n-   TR_VMFieldsInfo fieldsInfo(comp, clazz, 1, stackAlloc);\n-   ListIterator<TR_VMField> iter(fieldsInfo.getFields());\n-   TR::TypeLayoutBuilder tlb(region);\n-   for (TR_VMField *field = iter.getFirst(); field; field = iter.getNext())\n+/*\n+ * \\param prefix\n+ *    prefix could be ended with `.` or NULL.\n+ * \\param prefixLength\n+ *    The length of the prefix string.\n+ * \\param toConcatenateAsPrefix\n+ *    If true, the new name is appended with \".\" to be used as a part of the flattened field chain name.\n+ * \\param mergedLength\n+ *    The merged length of the concatenated field name that is returned to the caller.\n+ */\n+static char * mergeFieldNames(char * prefix, uint32_t prefixLength, J9ROMFieldShape * field,\n+                              bool toConcatenateAsPrefix, TR::Region &region, uint32_t &mergedLength)\n+   {\n+   J9UTF8 * fieldNameUTF = J9ROMFIELDSHAPE_NAME(field);\n+   char * fieldName = reinterpret_cast<char *>(J9UTF8_DATA(fieldNameUTF));\n+   uint32_t nameLength = J9UTF8_LENGTH(fieldNameUTF);\n+\n+   mergedLength = nameLength + prefixLength;\n+   if (toConcatenateAsPrefix)\n+      mergedLength++;\n+   mergedLength++; /* for adding \\0 at the end */\n+\n+   char * newName = new (region) char[mergedLength];\n+\n+   if (prefixLength > 0)\n+      strncpy(newName, prefix, prefixLength);\n+   strncpy(newName + prefixLength, fieldName, nameLength);\n+\n+   if (toConcatenateAsPrefix)\n+      newName[mergedLength-2] = '.';\n+   newName[mergedLength-1] = '\\0';\n+\n+   return newName;\n+   }\n+\n+static void addEntryForField(TR_VMField * field, TR::TypeLayoutBuilder &tlb, TR::Region& region, J9Class * definingClass,", "originalCommit": "6091388627a4473bcaa214a00899a88446ee8082", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxNTg0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r465815849", "bodyText": "the prefix, prefixLength and offsetBase params only seem used with the recursion perhaps create a frontend function to default these with the recrusion taking all the params with an impl suffix to keep usage simple and to make it easy to change defaults in the future...", "author": "andrewcraik", "createdAt": "2020-08-05T15:33:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMzk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyNjcyNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r465826724", "bodyText": "can we keep the definingClass as an OpaqueClassBlock and only do the cast internally when passing to the VM APIs to keep consistency in how the JIT code uses the types?\n\naddEntryForField() is called recursively when the field is flattened. It passes J9Class * pointer received from VM to addEntryForField() again. If TR_OpaqueClassBlock * is used, the pointer needs to be recast back to TR_OpaqueClassBlock * again. If we use J9Class * as now, it will avoid the recast in the recursive calls.\n      J9Class *fieldClass = vm->internalVMFunctions->getFlattenableFieldType(definingClass, field->shape);\n      TR_VMFieldsInfo fieldsInfo(comp, fieldClass, 1, stackAlloc);\n      ListIterator<TR_VMField> iter(fieldsInfo.getFields());\n      for (TR_VMField *childField = iter.getFirst(); childField; childField = iter.getNext())\n         {\n         addEntryForField(childField, tlb, region, fieldClass, prefixForChild, mergedLength-1, offsetBaseForChild, comp);\n         }", "author": "a7ehuo", "createdAt": "2020-08-05T15:49:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMzk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzNjQ5NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r465836495", "bodyText": "the prefix, prefixLength and offsetBase params only seem used with the recursion perhaps create a frontend function to default these with the recrusion taking all the params with an impl suffix\n\nI'm not sure I'm following. Could you elaborate it a bit? Or an example?", "author": "a7ehuo", "createdAt": "2020-08-05T16:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMzk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NjkyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r465986926", "bodyText": "so apart from the addEntryForField recursive call there is one call elsewhere in the file where the parameters for prefix, prefixLenght and offsetBase seem to be given an initial value - these are updated during the recursion from what I can see. So rather than having the non-recursive call look like addEntryForField(...., 0, 0, NULL) you could create an addEntryForField without those params which supplies those default values to call the current method renamed to addEntryForFieldImpl. That way if we add more dependencies on to it later the defaults are all in one place and not spread around the code base. Does that make sense?", "author": "andrewcraik", "createdAt": "2020-08-05T20:32:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMzk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NzM2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10115#discussion_r465987364", "bodyText": "For the API issue above splitting the method into addEntryForField and addEntryForFieldImpl would allow the OpaqueClassBlock to J9Class conversion to be done in addEntryForField and for addEntryForFieldImpl to use the J9Class for the beneficial reasons you note.", "author": "andrewcraik", "createdAt": "2020-08-05T20:33:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMzk2Nw=="}], "type": "inlineReview"}, {"oid": "c485fd3977c24cf11c831f2fd0dad4893ac4ab9e", "url": "https://github.com/eclipse-openj9/openj9/commit/c485fd3977c24cf11c831f2fd0dad4893ac4ab9e", "message": "Add TypeLayoutEntry build for flattened fields\n\nCreate TypeLayoutEntry for flattened fields with adjusted\noffset from the top level class for value types.\n\nThis change was originally authored by Yi Zhang\nwho is listed as a co-author below.\n\nCo-authored-by: Yi Zhang yizhang@ca.ibm.com\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-08-05T22:14:12Z", "type": "forcePushed"}, {"oid": "5c4db51ceb4a661a239caa4e2fe495eb633be002", "url": "https://github.com/eclipse-openj9/openj9/commit/5c4db51ceb4a661a239caa4e2fe495eb633be002", "message": "Add TypeLayoutEntry build for flattened fields\n\nCreate TypeLayoutEntry for flattened fields with adjusted\noffset from the top level class for value types.\n\nThis change was originally authored by Yi Zhang\nwho is listed as a co-author below.\n\nCo-authored-by: Yi Zhang yizhang@ca.ibm.com\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-08-06T14:37:57Z", "type": "commit"}, {"oid": "5c4db51ceb4a661a239caa4e2fe495eb633be002", "url": "https://github.com/eclipse-openj9/openj9/commit/5c4db51ceb4a661a239caa4e2fe495eb633be002", "message": "Add TypeLayoutEntry build for flattened fields\n\nCreate TypeLayoutEntry for flattened fields with adjusted\noffset from the top level class for value types.\n\nThis change was originally authored by Yi Zhang\nwho is listed as a co-author below.\n\nCo-authored-by: Yi Zhang yizhang@ca.ibm.com\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>", "committedDate": "2020-08-06T14:37:57Z", "type": "forcePushed"}]}