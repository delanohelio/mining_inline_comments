{"pr_number": 10017, "pr_title": "Group cache field and static info in JITServer", "pr_createdAt": "2020-06-25T17:15:00Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10017", "timeline": [{"oid": "7a9dde65cfe0a18e4b4b8a6387dc7007d501e67e", "url": "https://github.com/eclipse-openj9/openj9/commit/7a9dde65cfe0a18e4b4b8a6387dc7007d501e67e", "message": "Group cache field and static info in JITServer\n\n- `TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n- This commit also implements caching for `jitStaticsAreSame`\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-06-25T17:17:31Z", "type": "forcePushed"}, {"oid": "ab218f19ae775db9f48500332deeacef8e8c4873", "url": "https://github.com/eclipse-openj9/openj9/commit/ab218f19ae775db9f48500332deeacef8e8c4873", "message": "Group cache field and static info in JITServer\n\n- `TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n- This commit also implements caching for `jitStaticsAreSame`\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-06-25T17:31:34Z", "type": "forcePushed"}, {"oid": "aa8eb2b0cc78fabe95402fe9dfa85dc66d46c552", "url": "https://github.com/eclipse-openj9/openj9/commit/aa8eb2b0cc78fabe95402fe9dfa85dc66d46c552", "message": "Group cache field and static info in JITServer\n\n- `TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n- Implement caching for `jitStaticsAreSame`\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\n- Simplify client-side code for finding field data.\nnon-JITServer code doesn't look for field data if both fields are\nresolved and their value offsets are different. This is an optimization\nthat shouldn't affect functional correctness, so this commit always\nlooks for field data, because it improves caching and simplifies the\ncode.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-06-25T18:51:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMzcwOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447003709", "bodyText": "comp()->getMethodBeingCompiled() has changed to _methodSymbol->getResolvedMethod() which I believe is more correct. Does the test on comp()->getMethodBeingCompiled() make sense anymore?", "author": "mpirvu", "createdAt": "2020-06-29T14:14:10Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -229,7 +229,11 @@ TR::Block * TR_J9ByteCodeIlGenerator::walker(TR::Block * prevBlock)\n       //\n       // NOTE: first request occurs in the switch statement over bytecodes,\n       // second request occurs in stashArgumentsForOSR\n-      static_cast<TR_ResolvedJ9JITServerMethod *>(comp()->getMethodBeingCompiled())->cacheResolvedMethodsCallees(2);\n+      static_cast<TR_ResolvedJ9JITServerMethod *>(_methodSymbol->getResolvedMethod())->cacheResolvedMethodsCallees(2);", "originalCommit": "aa8eb2b0cc78fabe95402fe9dfa85dc66d46c552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwNTE4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447005188", "bodyText": "Also, is walker called for inlined methods as well? I wonder if we do double duty with the code that prefeteches all resolved methods during estimateCallSize", "author": "mpirvu", "createdAt": "2020-06-29T14:16:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMzcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc2NjU1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447766551", "bodyText": "The test on comp()->getMethodBeingCompiled() should be replaced with _methodSymbol->getResolvedMethod().\nIndeed, the walker is called for inlined methods as well. However, removing the caching from estimateCallSize increases the number of messages, which leads me to believe that code size estimation may happen before IL for inlined methods is generated. I should test if caching in walker just for the method being compiled does not result in message increase.", "author": "dmitry-ten", "createdAt": "2020-06-30T15:18:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMzcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgyMTA4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447821082", "bodyText": "I measured that caching resolved methods only for method being compiled in walker does not lead to any significant difference in the number of messages compared to caching for inlined methods as well. This makes sense, since if the methods were already cached during code size estimation, no remote call would be made from walker. We still waste some time iterating over bytecodes though. Thus, I think it's better to cache only for method being compiled.", "author": "dmitry-ten", "createdAt": "2020-06-30T16:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMzcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgyMTM4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447821383", "bodyText": "I assume _methodSymbol->getResolvedMethod() == comp()->getMethodBeingCompiled() would be a sufficient check.", "author": "dmitry-ten", "createdAt": "2020-06-30T16:32:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMzcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2OTk2MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r449069961", "bodyText": "yes, that check is sufficient", "author": "mpirvu", "createdAt": "2020-07-02T15:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMzcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEzNzM3Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447137373", "bodyText": "Let's move  cpIndex, field and declaringClass down under if (isField) test", "author": "mpirvu", "createdAt": "2020-06-29T17:32:19Z", "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -438,34 +467,63 @@ TR_J9ServerVM::cacheField(J9Class *ramClass, int32_t cpIndex, J9Class *declaring\n       }\n    }\n \n-bool\n-TR_J9ServerVM::jitStaticsAreSame(TR_ResolvedMethod *method1, I_32 cpIndex1, TR_ResolvedMethod *method2, I_32 cpIndex2)\n-   {\n-   JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+void\n+TR_J9ServerVM::cacheFields(TR_ResolvedJ9Method *owningMethod)\n+   {\n+   // 1. Iterate through bytecodes and look for loads/stores\n+   // If the corresponding field or static is not cached, add it\n+   // to the list of fields that will be sent to the client in one batch.\n+   TR_J9ByteCodeIterator bci(0, owningMethod, this, _compInfoPT->getCompilation());\n+   std::vector<int32_t> cpIndices;\n+   std::vector<uint8_t> isStaticField;\n+   J9Class *ramClass = owningMethod->constantPoolHdr();\n+   for(TR_J9ByteCode bc = bci.first(); bc != J9BCunknown; bc = bci.next())\n+      {\n+      J9Class *declaringClass;\n+      UDATA field;\n+      int32_t cpIndex = bci.next2Bytes();", "originalCommit": "aa8eb2b0cc78fabe95402fe9dfa85dc66d46c552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgyODg2Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447828867", "bodyText": "Done", "author": "dmitry-ten", "createdAt": "2020-06-30T16:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEzNzM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE0OTgwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447149808", "bodyText": "What is the sign that the field is unresolved? I am guessing field == 0 and declaringClass == NULL.\nWe could check these at the server and avoid caching them if needed.", "author": "mpirvu", "createdAt": "2020-06-29T17:54:14Z", "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -1152,6 +1093,31 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n          client->write(response, fe->getObjectSizeClass(std::get<0>(recv)));\n          }\n          break;\n+      case MessageType::VM_getFields:\n+         {\n+         auto recv = client->getRecvData<TR_ResolvedJ9Method *, std::vector<int32_t>, std::vector<uint8_t>>();\n+         TR_ResolvedJ9Method *owningMethod = std::get<0>(recv);\n+         auto &cpIndices = std::get<1>(recv);\n+         auto &isStatic = std::get<2>(recv);\n+\n+         int32_t numFields = cpIndices.size();\n+         std::vector<J9Class *> declaringClasses;\n+         std::vector<UDATA> fields;\n+         declaringClasses.reserve(numFields);\n+         fields.reserve(numFields);\n+\n+         J9ConstantPool *cp = reinterpret_cast<J9ConstantPool *>(owningMethod->ramConstantPool());\n+         for (int32_t i = 0; i < numFields; ++i)\n+            {\n+            J9Class *declaringClass;\n+            // do we need to check if the field is resolved?", "originalCommit": "aa8eb2b0cc78fabe95402fe9dfa85dc66d46c552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3MDAyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447770021", "bodyText": "field == 0 should be sufficient to prove that the field is unresolved. I will add the check on the server.", "author": "dmitry-ten", "createdAt": "2020-06-30T15:22:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE0OTgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3NDg2NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447774865", "bodyText": "Actually, cacheField already does this check.", "author": "dmitry-ten", "createdAt": "2020-06-30T15:29:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE0OTgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIzMzAxNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447233017", "bodyText": "Maybe we should enter a critical section for this entire for loop ( OMR::CriticalSection getRemoteROMClass(_compInfoPT->getClientData()->getROMMapMonitor());)\nThe reason is, acquiring a monitor recursively (while have it) is faster than acquiring it from scratch.", "author": "mpirvu", "createdAt": "2020-06-29T20:26:42Z", "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -438,34 +467,63 @@ TR_J9ServerVM::cacheField(J9Class *ramClass, int32_t cpIndex, J9Class *declaring\n       }\n    }\n \n-bool\n-TR_J9ServerVM::jitStaticsAreSame(TR_ResolvedMethod *method1, I_32 cpIndex1, TR_ResolvedMethod *method2, I_32 cpIndex2)\n-   {\n-   JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+void\n+TR_J9ServerVM::cacheFields(TR_ResolvedJ9Method *owningMethod)\n+   {\n+   // 1. Iterate through bytecodes and look for loads/stores\n+   // If the corresponding field or static is not cached, add it\n+   // to the list of fields that will be sent to the client in one batch.\n+   TR_J9ByteCodeIterator bci(0, owningMethod, this, _compInfoPT->getCompilation());\n+   std::vector<int32_t> cpIndices;\n+   std::vector<uint8_t> isStaticField;\n+   J9Class *ramClass = owningMethod->constantPoolHdr();\n+   for(TR_J9ByteCode bc = bci.first(); bc != J9BCunknown; bc = bci.next())\n+      {\n+      J9Class *declaringClass;\n+      UDATA field;\n+      int32_t cpIndex = bci.next2Bytes();\n+      bool isField = false;\n+      bool isStatic;\n+      if (bc == J9BCgetfield || bc == J9BCputfield)\n+         {\n+         isField = true;\n+         isStatic = false;\n+         }\n+      else if (bc == J9BCgetstatic || bc == J9BCputstatic)\n+         {\n+         isField = true;\n+         isStatic = true;\n+         }\n+      if (isField && !getCachedField(ramClass, cpIndex, &declaringClass, &field))\n+         {\n+         cpIndices.push_back(cpIndex);\n+         isStaticField.push_back(isStatic);\n+         }\n+      }\n \n-   // Pass pointers to client mirrors of the ResolvedMethod objects instead of local objects\n-   TR_ResolvedJ9JITServerMethod *serverMethod1 = static_cast<TR_ResolvedJ9JITServerMethod*>(method1);\n-   TR_ResolvedJ9JITServerMethod *serverMethod2 = static_cast<TR_ResolvedJ9JITServerMethod*>(method2);\n-   TR_ResolvedMethod *clientMethod1 = serverMethod1->getRemoteMirror();\n-   TR_ResolvedMethod *clientMethod2 = serverMethod2->getRemoteMirror();\n+   // If there's just one field, it's faster to get it through regular means,\n+   // to avoid overhead of vectors\n+   int32_t numFields = cpIndices.size();\n+   if (numFields < 2)\n+      return;\n \n-   bool result = false;\n+   // 2. Send a message to get info for all fields\n+   JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+   stream->write(\n+      JITServer::MessageType::VM_getFields,\n+      static_cast<TR_ResolvedJ9JITServerMethod *>(owningMethod)->getRemoteMirror(),\n+      cpIndices,\n+      isStaticField);\n+   auto recv = stream->read<std::vector<J9Class *>, std::vector<UDATA>>();\n \n-   bool sigSame = true;\n-   if (serverMethod1->staticsAreSame(cpIndex1, serverMethod2, cpIndex2, sigSame))\n+   // 3. Cache all received fields\n+   auto &declaringClasses = std::get<0>(recv);\n+   auto &fields = std::get<1>(recv);\n+   TR_ASSERT(numFields == declaringClasses.size(), \"Number of received fields does not match the requested number\");\n+   for (int32_t i = 0; i < numFields; ++i)\n       {\n-      result = true;\n+      cacheField(ramClass, cpIndices[i], declaringClasses[i], fields[i]);", "originalCommit": "aa8eb2b0cc78fabe95402fe9dfa85dc66d46c552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgyODkzMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447828932", "bodyText": "Done", "author": "dmitry-ten", "createdAt": "2020-06-30T16:43:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIzMzAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIzNzQyNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447237424", "bodyText": "I would prefer a logical and rather than a bit-wise and operator here:\nbool cached = getCachedField(ramClass1, cpIndex1, &declaringClass1, &field1) &&\n              getCachedField(ramClass2, cpIndex2, &declaringClass2, &field2);", "author": "mpirvu", "createdAt": "2020-06-29T20:34:54Z", "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -343,20 +344,61 @@ TR_J9ServerVM::getSystemClassLoader()\n    }\n \n bool\n-TR_J9ServerVM::jitFieldsAreSame(TR_ResolvedMethod * method1, I_32 cpIndex1, TR_ResolvedMethod * method2, I_32 cpIndex2, int32_t isStatic)\n+TR_J9ServerVM::jitFieldsOrStaticsAreIdentical(TR_ResolvedMethod * method1, I_32 cpIndex1, TR_ResolvedMethod * method2, I_32 cpIndex2, int32_t isStatic)\n    {\n-   JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n-\n-   // Pass pointers to client mirrors of the ResolvedMethod objects instead of local objects\n-   TR_ResolvedJ9JITServerMethod *serverMethod1 = static_cast<TR_ResolvedJ9JITServerMethod*>(method1);\n-   TR_ResolvedJ9JITServerMethod *serverMethod2 = static_cast<TR_ResolvedJ9JITServerMethod*>(method2);\n-   TR_ResolvedMethod *clientMethod1 = serverMethod1->getRemoteMirror();\n-   TR_ResolvedMethod *clientMethod2 = serverMethod2->getRemoteMirror();\n+   auto serverMethod1 = static_cast<TR_ResolvedJ9JITServerMethod*>(method1);\n+   auto serverMethod2 = static_cast<TR_ResolvedJ9JITServerMethod*>(method2);\n+   J9Class *ramClass1 = serverMethod1->constantPoolHdr();\n+   J9Class *ramClass2 = serverMethod2->constantPoolHdr();\n+   UDATA field1 = 0, field2 = 0;\n+   J9Class *declaringClass1 = NULL, *declaringClass2 = NULL;\n \n    bool result = false;\n+   bool needRemoteCall = true;\n+   bool cached = getCachedField(ramClass1, cpIndex1, &declaringClass1, &field1);", "originalCommit": "aa8eb2b0cc78fabe95402fe9dfa85dc66d46c552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgyODk4NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447828984", "bodyText": "Done", "author": "dmitry-ten", "createdAt": "2020-06-30T16:43:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIzNzQyNA=="}], "type": "inlineReview"}, {"oid": "089954ef0033e6a31c8fff3dc752770f4a56d313", "url": "https://github.com/eclipse-openj9/openj9/commit/089954ef0033e6a31c8fff3dc752770f4a56d313", "message": "Group cache field and static info in JITServer\n\n- `TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n- Implement caching for `jitStaticsAreSame`\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\n- Simplify client-side code for finding field data.\nnon-JITServer code doesn't look for field data if both fields are\nresolved and their value offsets are different. This is an optimization\nthat shouldn't affect functional correctness, so this commit always\nlooks for field data, because it improves caching and simplifies the\ncode.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-06-30T16:43:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgyOTY1NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447829654", "bodyText": "I moved caching code out of the if statement, since if one field is resolved, while the other one isn't it still makes sense to cache the resolved one.", "author": "dmitry-ten", "createdAt": "2020-06-30T16:44:42Z", "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -343,20 +344,62 @@ TR_J9ServerVM::getSystemClassLoader()\n    }\n \n bool\n-TR_J9ServerVM::jitFieldsAreSame(TR_ResolvedMethod * method1, I_32 cpIndex1, TR_ResolvedMethod * method2, I_32 cpIndex2, int32_t isStatic)\n+TR_J9ServerVM::jitFieldsOrStaticsAreIdentical(TR_ResolvedMethod * method1, I_32 cpIndex1, TR_ResolvedMethod * method2, I_32 cpIndex2, int32_t isStatic)\n    {\n-   JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n-\n-   // Pass pointers to client mirrors of the ResolvedMethod objects instead of local objects\n-   TR_ResolvedJ9JITServerMethod *serverMethod1 = static_cast<TR_ResolvedJ9JITServerMethod*>(method1);\n-   TR_ResolvedJ9JITServerMethod *serverMethod2 = static_cast<TR_ResolvedJ9JITServerMethod*>(method2);\n-   TR_ResolvedMethod *clientMethod1 = serverMethod1->getRemoteMirror();\n-   TR_ResolvedMethod *clientMethod2 = serverMethod2->getRemoteMirror();\n+   auto serverMethod1 = static_cast<TR_ResolvedJ9JITServerMethod*>(method1);\n+   auto serverMethod2 = static_cast<TR_ResolvedJ9JITServerMethod*>(method2);\n+   J9Class *ramClass1 = serverMethod1->constantPoolHdr();\n+   J9Class *ramClass2 = serverMethod2->constantPoolHdr();\n+   UDATA field1 = 0, field2 = 0;\n+   J9Class *declaringClass1 = NULL, *declaringClass2 = NULL;\n \n    bool result = false;\n+   bool needRemoteCall = true;\n+   bool cached =\n+      getCachedField(ramClass1, cpIndex1, &declaringClass1, &field1) &&\n+      getCachedField(ramClass2, cpIndex2, &declaringClass2, &field2);\n+   if (cached)\n+      {\n+      needRemoteCall = false;\n+      result = declaringClass1 == declaringClass2 && field1 == field2;\n+#if defined(DEBUG) || defined(PROD_WITH_ASSUMES)\n+      // validate cached result\n+      needRemoteCall = true;\n+#endif\n+      }\n+   if (needRemoteCall)\n+      {\n+      JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+      // Pass pointers to client mirrors of the ResolvedMethod objects instead of local objects\n+      TR_ResolvedMethod *clientMethod1 = serverMethod1->getRemoteMirror();\n+      TR_ResolvedMethod *clientMethod2 = serverMethod2->getRemoteMirror();\n+\n+      stream->write(JITServer::MessageType::VM_jitFieldsOrStaticsAreSame, clientMethod1, cpIndex1, clientMethod2, cpIndex2, isStatic);\n+      auto recv = stream->read<J9Class *, J9Class *, UDATA, UDATA>();\n+      declaringClass1 = std::get<0>(recv);\n+      declaringClass2 = std::get<1>(recv);\n+      field1 = std::get<2>(recv);\n+      field2 = std::get<3>(recv);\n+      cacheField(ramClass1, cpIndex1, declaringClass1, field1);\n+      cacheField(ramClass2, cpIndex2, declaringClass2, field2);", "originalCommit": "089954ef0033e6a31c8fff3dc752770f4a56d313", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4MDc1MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r449080750", "bodyText": "I just realized that the comments with the message number are going to be off after this change. To ease further changes like this I suggest we put comments only every 10 entries.", "author": "mpirvu", "createdAt": "2020-07-02T15:23:58Z", "path": "runtime/compiler/net/MessageTypes.hpp", "diffHunk": "@@ -387,8 +387,7 @@ static const char *messageNames[MessageType_ARRAYSIZE] =\n    \"VM_getLeafComponentClassFromArrayClass\", // 82\n    \"VM_isClassLoadedBySystemClassLoader\", // 83\n    \"VM_getClassFromSignature\", // 84\n-   \"VM_jitFieldsAreSame\", // 85\n-   \"VM_jitStaticsAreSame\", // 86\n+   \"VM_jitFieldsOrStaticsAreSame\", // 85", "originalCommit": "089954ef0033e6a31c8fff3dc752770f4a56d313", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyODc2MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r449628760", "bodyText": "I see that in MessageType enum, only first message of each category is numbered. I'll do the same here.", "author": "dmitry-ten", "createdAt": "2020-07-03T15:12:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4MDc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA5ODM5NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r449098395", "bodyText": "I looked at the possibility to calling walker several times for the same method which would result in several calls to cacheFields(). I see it called once as walker(0) during genILFromBytecodes() and another time as walker(lastBlock) from getExceptionHandlers(). At the very least I think we need to block the second attempt by checking that the parameter to walker is 0.", "author": "mpirvu", "createdAt": "2020-07-02T15:39:32Z", "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -220,7 +220,7 @@ TR::Block * TR_J9ByteCodeIlGenerator::walker(TR::Block * prevBlock)\n \n \n #if defined(J9VM_OPT_JITSERVER)\n-   if (comp()->isOutOfProcessCompilation() && comp()->getMethodBeingCompiled())\n+   if (comp()->isOutOfProcessCompilation() && _methodSymbol->getResolvedMethod())", "originalCommit": "089954ef0033e6a31c8fff3dc752770f4a56d313", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyNDA4Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r449224087", "bodyText": "I see that we only send remote requests for fields that are not cached, so there is no additional burden at the client unless the field is unresolved and we ask again.\nThere is also the code that walks the bytecodes at the server and checks whether the fields are cached. Ideally we would not repeat these calls if possible.", "author": "mpirvu", "createdAt": "2020-07-02T19:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA5ODM5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NDM0Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r449644347", "bodyText": "I can't think of an easy way to keep track of whether we already cached fields for this method, so I just added a check that walker parameter must be 0.", "author": "dmitry-ten", "createdAt": "2020-07-03T15:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA5ODM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzMzQxMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r449233410", "bodyText": "This delegates to the frontend implementation. Can we move the implementation from TR_J9ServerVM into this method so that we eliminate one level of indirection?", "author": "mpirvu", "createdAt": "2020-07-02T19:47:32Z", "path": "runtime/compiler/env/j9methodServer.cpp", "diffHunk": "@@ -1891,6 +1891,12 @@ TR_ResolvedJ9JITServerMethod::cacheResolvedMethodsCallees(int32_t ttlForUnresolv\n       }\n    }\n \n+void\n+TR_ResolvedJ9JITServerMethod::cacheFields()", "originalCommit": "089954ef0033e6a31c8fff3dc752770f4a56d313", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYzNzUxMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r449637512", "bodyText": "Yeah, I implemented in the front-end because methods cacheField and getCachedField are defined there.\nI suppose I could make these methods public and call them from the resolved method.", "author": "dmitry-ten", "createdAt": "2020-07-03T15:36:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzMzQxMA=="}], "type": "inlineReview"}, {"oid": "9c474c3e170f164ce71283bdfc884412d99ddf9b", "url": "https://github.com/eclipse-openj9/openj9/commit/9c474c3e170f164ce71283bdfc884412d99ddf9b", "message": "Group cache field and static info in JITServer\n\n- `TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n- Implement caching for `jitStaticsAreSame`\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\n- Simplify client-side code for finding field data.\nnon-JITServer code doesn't look for field data if both fields are\nresolved and their value offsets are different. This is an optimization\nthat shouldn't affect functional correctness, so this commit always\nlooks for field data, because it improves caching and simplifies the\ncode.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-03T15:57:39Z", "type": "commit"}, {"oid": "9c474c3e170f164ce71283bdfc884412d99ddf9b", "url": "https://github.com/eclipse-openj9/openj9/commit/9c474c3e170f164ce71283bdfc884412d99ddf9b", "message": "Group cache field and static info in JITServer\n\n- `TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n- Implement caching for `jitStaticsAreSame`\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\n- Simplify client-side code for finding field data.\nnon-JITServer code doesn't look for field data if both fields are\nresolved and their value offsets are different. This is an optimization\nthat shouldn't affect functional correctness, so this commit always\nlooks for field data, because it improves caching and simplifies the\ncode.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-03T15:57:39Z", "type": "forcePushed"}, {"oid": "9c474c3e170f164ce71283bdfc884412d99ddf9b", "url": "https://github.com/eclipse-openj9/openj9/commit/9c474c3e170f164ce71283bdfc884412d99ddf9b", "message": "Group cache field and static info in JITServer\n\n- `TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n- Implement caching for `jitStaticsAreSame`\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\n- Simplify client-side code for finding field data.\nnon-JITServer code doesn't look for field data if both fields are\nresolved and their value offsets are different. This is an optimization\nthat shouldn't affect functional correctness, so this commit always\nlooks for field data, because it improves caching and simplifies the\ncode.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>", "committedDate": "2020-07-03T15:57:39Z", "type": "forcePushed"}]}