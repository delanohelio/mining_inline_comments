{"pr_number": 11331, "pr_title": "Fully serialize ROMClasses sent to JITServer", "pr_createdAt": "2020-12-02T12:49:53Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/11331", "timeline": [{"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99", "url": "https://github.com/eclipse-openj9/openj9/commit/cf8bac93c10483471c4cef95c99e5644d0834e99", "message": "Increment JITServer protocol version\n\nSigned-off-by: Alexey Khrabrov <khrabrov@cs.toronto.edu>", "committedDate": "2020-12-04T20:01:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0MDkzNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537840935", "bodyText": "So, here src is a non-padded string, while dst is padded, correct? I would like a comment of that sort.", "author": "mpirvu", "createdAt": "2020-12-07T21:20:28Z", "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)", "originalCommit": "cf8bac93c10483471c4cef95c99e5644d0834e99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAwMjk1OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r538002959", "bodyText": "Correct. Will add a comment.", "author": "AlexeyKhrabrov", "createdAt": "2020-12-08T03:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0MDkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0MjU2Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537842566", "bodyText": "Also please add a comment of what this function returns.\nIsn't easier if we return J9UTF8_TOTAL_SIZE(dst) ?", "author": "mpirvu", "createdAt": "2020-12-07T21:23:09Z", "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));", "originalCommit": "cf8bac93c10483471c4cef95c99e5644d0834e99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAwMzUwMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r538003503", "bodyText": "It returns the padded size, i.e. getUTF8Size(src) == getUTF8Size(dst), but it's different from J9UTF8_TOTAL_SIZE(dst). I'll change it to return getUTF8Size(dst).", "author": "AlexeyKhrabrov", "createdAt": "2020-12-08T03:20:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0MjU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0NDE4MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537844180", "bodyText": "Please add a leading underscore to fields of data structures", "author": "mpirvu", "createdAt": "2020-12-07T21:25:47Z", "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;", "originalCommit": "cf8bac93c10483471c4cef95c99e5644d0834e99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg3OTk1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537879956", "bodyText": "is the hint it useful?", "author": "mpirvu", "createdAt": "2020-12-07T22:26:05Z", "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });", "originalCommit": "cf8bac93c10483471c4cef95c99e5644d0834e99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAwNDA3MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r538004071", "bodyText": "Yes, it's a bit faster since it avoids a hash lookup.", "author": "AlexeyKhrabrov", "createdAt": "2020-12-08T03:21:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg3OTk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxNDEwMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537914101", "bodyText": "Do strings that were inside the definition of a ROMClass keep their offsets in the packed version?", "author": "mpirvu", "createdAt": "2020-12-07T23:29:18Z", "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.\n+static size_t\n+getArrayROMClassPackedSize(const J9ROMClass *romClass)\n+   {\n+   size_t totalSize = sizeof(*romClass);\n+   totalSize += getUTF8Size(J9ROMCLASS_CLASSNAME(romClass));\n+   totalSize += getUTF8Size(J9ROMCLASS_SUPERCLASSNAME(romClass));\n+\n+   totalSize += romClass->interfaceCount * sizeof(J9SRP);\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      totalSize += getUTF8Size(name);\n+      }\n+\n+   return OMR::alignNoCheck(totalSize, sizeof(uint64_t));\n+   }\n+\n+static void\n+packUTF8(const J9UTF8 *str, J9SRP &srp, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(srp, ctx.cursor);\n+   ctx.cursor += copyUTF8((J9UTF8 *)ctx.cursor, str);\n+   }\n+\n+// Packs the data stored outside of the array ROMClass header\n+static void\n+packArrayROMClassData(const J9ROMClass *romClass, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(ctx.packedRomClass->interfaces, ctx.cursor);\n+   ctx.cursor += ctx.packedRomClass->interfaceCount * sizeof(J9SRP);\n+\n+   packUTF8(J9ROMCLASS_CLASSNAME(romClass), ctx.packedRomClass->className, ctx);\n+   packUTF8(J9ROMCLASS_SUPERCLASSNAME(romClass), ctx.packedRomClass->superclassName, ctx);\n+\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      packUTF8(name, J9ROMCLASS_INTERFACES(ctx.packedRomClass)[i], ctx);\n+      }\n    }\n \n // Packs a ROMClass into a std::string to be transferred to the server.\n-// Some of the name and signature strings are interned and stored outside\n-// of the ROMClass body. Such strings are appended to the end of the cloned\n-// ROMClass body and the self referential pointers to them are updated.\n+// UTF8 strings that a ROMClass refers to can be interned and stored outside of\n+// the ROMClass body. This function puts all the strings (including interned ones)\n+// at the end of the cloned ROMClass in deterministic order and updates the SRPs\n+// to them. It also removes some of the data that is not used by the JIT compiler.\n+//\n+// Packing involves 2 passes over all the strings that a ROMClass refers to:\n+// 1. Compute total size and map original strings to their locations in the packed ROMClass.\n+// 2. Copy each original string to its location in the packed ROMClass.", "originalCommit": "cf8bac93c10483471c4cef95c99e5644d0834e99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAwNDI1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r538004258", "bodyText": "In general, no. I will add a comment about that.", "author": "AlexeyKhrabrov", "createdAt": "2020-12-08T03:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxNDEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2MDQxNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537960414", "bodyText": "What is intermediate class data?", "author": "mpirvu", "createdAt": "2020-12-08T01:24:32Z", "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.\n+static size_t\n+getArrayROMClassPackedSize(const J9ROMClass *romClass)\n+   {\n+   size_t totalSize = sizeof(*romClass);\n+   totalSize += getUTF8Size(J9ROMCLASS_CLASSNAME(romClass));\n+   totalSize += getUTF8Size(J9ROMCLASS_SUPERCLASSNAME(romClass));\n+\n+   totalSize += romClass->interfaceCount * sizeof(J9SRP);\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      totalSize += getUTF8Size(name);\n+      }\n+\n+   return OMR::alignNoCheck(totalSize, sizeof(uint64_t));\n+   }\n+\n+static void\n+packUTF8(const J9UTF8 *str, J9SRP &srp, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(srp, ctx.cursor);\n+   ctx.cursor += copyUTF8((J9UTF8 *)ctx.cursor, str);\n+   }\n+\n+// Packs the data stored outside of the array ROMClass header\n+static void\n+packArrayROMClassData(const J9ROMClass *romClass, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(ctx.packedRomClass->interfaces, ctx.cursor);\n+   ctx.cursor += ctx.packedRomClass->interfaceCount * sizeof(J9SRP);\n+\n+   packUTF8(J9ROMCLASS_CLASSNAME(romClass), ctx.packedRomClass->className, ctx);\n+   packUTF8(J9ROMCLASS_SUPERCLASSNAME(romClass), ctx.packedRomClass->superclassName, ctx);\n+\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      packUTF8(name, J9ROMCLASS_INTERFACES(ctx.packedRomClass)[i], ctx);\n+      }\n    }\n \n // Packs a ROMClass into a std::string to be transferred to the server.\n-// Some of the name and signature strings are interned and stored outside\n-// of the ROMClass body. Such strings are appended to the end of the cloned\n-// ROMClass body and the self referential pointers to them are updated.\n+// UTF8 strings that a ROMClass refers to can be interned and stored outside of\n+// the ROMClass body. This function puts all the strings (including interned ones)\n+// at the end of the cloned ROMClass in deterministic order and updates the SRPs\n+// to them. It also removes some of the data that is not used by the JIT compiler.\n+//\n+// Packing involves 2 passes over all the strings that a ROMClass refers to:\n+// 1. Compute total size and map original strings to their locations in the packed ROMClass.\n+// 2. Copy each original string to its location in the packed ROMClass.\n static std::string\n-packROMClass(J9ROMClass *origRomClass, TR_Memory *trMemory)\n+packROMClass(J9ROMClass *romClass, TR_Memory *trMemory)\n    {\n-   size_t totalSize = origRomClass->romSize;\n-   J9UTF8 *className = J9ROMCLASS_CLASSNAME(origRomClass);\n-   totalSize += getPackedUTF8Size(className, origRomClass);\n-\n-   J9ROMMethod *romMethod = J9ROMCLASS_ROMMETHODS(origRomClass);\n-   for (size_t i = 0; i < origRomClass->romMethodCount; ++i)\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   // Primitive ROMClasses have different layout (see runtime/vm/romclasses.c): the last\n+   // ROMClass includes all the others' UTF8 name strings in its romSize, which breaks the\n+   // generic packing implementation. Pretend that its romSize only includes the header.\n+   size_t origRomSize = J9ROMCLASS_IS_PRIMITIVE_TYPE(romClass) ? sizeof(*romClass) : romClass->romSize;\n+   size_t totalSize = origRomSize;\n+\n+   // Remove intermediate class data (not used by JIT)\n+   uint8_t *icData = J9ROMCLASS_INTERMEDIATECLASSDATA(romClass);", "originalCommit": "cf8bac93c10483471c4cef95c99e5644d0834e99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAwNTA5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r538005094", "bodyText": "Not sure, I haven't explored enough VM code to fully understand it yet. But it looks like the JIT never accesses it, so it should be safe to exclude it if it's present.", "author": "AlexeyKhrabrov", "createdAt": "2020-12-08T03:24:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2MDQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2MDk3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537960977", "bodyText": "I am guessing that you cannot have intermediate class data for primitive classes that only have the \"header\"", "author": "mpirvu", "createdAt": "2020-12-08T01:26:11Z", "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.\n+static size_t\n+getArrayROMClassPackedSize(const J9ROMClass *romClass)\n+   {\n+   size_t totalSize = sizeof(*romClass);\n+   totalSize += getUTF8Size(J9ROMCLASS_CLASSNAME(romClass));\n+   totalSize += getUTF8Size(J9ROMCLASS_SUPERCLASSNAME(romClass));\n+\n+   totalSize += romClass->interfaceCount * sizeof(J9SRP);\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      totalSize += getUTF8Size(name);\n+      }\n+\n+   return OMR::alignNoCheck(totalSize, sizeof(uint64_t));\n+   }\n+\n+static void\n+packUTF8(const J9UTF8 *str, J9SRP &srp, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(srp, ctx.cursor);\n+   ctx.cursor += copyUTF8((J9UTF8 *)ctx.cursor, str);\n+   }\n+\n+// Packs the data stored outside of the array ROMClass header\n+static void\n+packArrayROMClassData(const J9ROMClass *romClass, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(ctx.packedRomClass->interfaces, ctx.cursor);\n+   ctx.cursor += ctx.packedRomClass->interfaceCount * sizeof(J9SRP);\n+\n+   packUTF8(J9ROMCLASS_CLASSNAME(romClass), ctx.packedRomClass->className, ctx);\n+   packUTF8(J9ROMCLASS_SUPERCLASSNAME(romClass), ctx.packedRomClass->superclassName, ctx);\n+\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      packUTF8(name, J9ROMCLASS_INTERFACES(ctx.packedRomClass)[i], ctx);\n+      }\n    }\n \n // Packs a ROMClass into a std::string to be transferred to the server.\n-// Some of the name and signature strings are interned and stored outside\n-// of the ROMClass body. Such strings are appended to the end of the cloned\n-// ROMClass body and the self referential pointers to them are updated.\n+// UTF8 strings that a ROMClass refers to can be interned and stored outside of\n+// the ROMClass body. This function puts all the strings (including interned ones)\n+// at the end of the cloned ROMClass in deterministic order and updates the SRPs\n+// to them. It also removes some of the data that is not used by the JIT compiler.\n+//\n+// Packing involves 2 passes over all the strings that a ROMClass refers to:\n+// 1. Compute total size and map original strings to their locations in the packed ROMClass.\n+// 2. Copy each original string to its location in the packed ROMClass.\n static std::string\n-packROMClass(J9ROMClass *origRomClass, TR_Memory *trMemory)\n+packROMClass(J9ROMClass *romClass, TR_Memory *trMemory)\n    {\n-   size_t totalSize = origRomClass->romSize;\n-   J9UTF8 *className = J9ROMCLASS_CLASSNAME(origRomClass);\n-   totalSize += getPackedUTF8Size(className, origRomClass);\n-\n-   J9ROMMethod *romMethod = J9ROMCLASS_ROMMETHODS(origRomClass);\n-   for (size_t i = 0; i < origRomClass->romMethodCount; ++i)\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   // Primitive ROMClasses have different layout (see runtime/vm/romclasses.c): the last\n+   // ROMClass includes all the others' UTF8 name strings in its romSize, which breaks the\n+   // generic packing implementation. Pretend that its romSize only includes the header.\n+   size_t origRomSize = J9ROMCLASS_IS_PRIMITIVE_TYPE(romClass) ? sizeof(*romClass) : romClass->romSize;\n+   size_t totalSize = origRomSize;\n+\n+   // Remove intermediate class data (not used by JIT)\n+   uint8_t *icData = J9ROMCLASS_INTERMEDIATECLASSDATA(romClass);\n+   if (JITServerHelpers::isAddressInROMClass(icData, romClass) && (icData != (uint8_t *)romClass))\n       {\n-      totalSize += getPackedUTF8Size(J9ROMMETHOD_NAME(romMethod), origRomClass);\n-      totalSize += getPackedUTF8Size(J9ROMMETHOD_SIGNATURE(romMethod), origRomClass);\n-      romMethod = nextROMMethod(romMethod);\n+      TR_ASSERT_FATAL(icData + romClass->intermediateClassDataLength == (uint8_t *)romClass + romClass->romSize,\n+                      \"Intermediate class data not stored at the end of ROMClass %.*s\", name->length, name->data);\n+      totalSize -= romClass->intermediateClassDataLength;", "originalCommit": "cf8bac93c10483471c4cef95c99e5644d0834e99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAwNDQ4NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r538004485", "bodyText": "True, but this way the code is a bit simpler.", "author": "AlexeyKhrabrov", "createdAt": "2020-12-08T03:23:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2MDk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3NzUxNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537977516", "bodyText": "Why does end need to be the same as classEnd?\nend is what we computed with interned and non-interned strings.\nclassEnd is romClass+romClass->romSize which I thought it did not include the interned strings", "author": "mpirvu", "createdAt": "2020-12-08T02:07:54Z", "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.\n+static size_t\n+getArrayROMClassPackedSize(const J9ROMClass *romClass)\n+   {\n+   size_t totalSize = sizeof(*romClass);\n+   totalSize += getUTF8Size(J9ROMCLASS_CLASSNAME(romClass));\n+   totalSize += getUTF8Size(J9ROMCLASS_SUPERCLASSNAME(romClass));\n+\n+   totalSize += romClass->interfaceCount * sizeof(J9SRP);\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      totalSize += getUTF8Size(name);\n+      }\n+\n+   return OMR::alignNoCheck(totalSize, sizeof(uint64_t));\n+   }\n+\n+static void\n+packUTF8(const J9UTF8 *str, J9SRP &srp, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(srp, ctx.cursor);\n+   ctx.cursor += copyUTF8((J9UTF8 *)ctx.cursor, str);\n+   }\n+\n+// Packs the data stored outside of the array ROMClass header\n+static void\n+packArrayROMClassData(const J9ROMClass *romClass, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(ctx.packedRomClass->interfaces, ctx.cursor);\n+   ctx.cursor += ctx.packedRomClass->interfaceCount * sizeof(J9SRP);\n+\n+   packUTF8(J9ROMCLASS_CLASSNAME(romClass), ctx.packedRomClass->className, ctx);\n+   packUTF8(J9ROMCLASS_SUPERCLASSNAME(romClass), ctx.packedRomClass->superclassName, ctx);\n+\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      packUTF8(name, J9ROMCLASS_INTERFACES(ctx.packedRomClass)[i], ctx);\n+      }\n    }\n \n // Packs a ROMClass into a std::string to be transferred to the server.\n-// Some of the name and signature strings are interned and stored outside\n-// of the ROMClass body. Such strings are appended to the end of the cloned\n-// ROMClass body and the self referential pointers to them are updated.\n+// UTF8 strings that a ROMClass refers to can be interned and stored outside of\n+// the ROMClass body. This function puts all the strings (including interned ones)\n+// at the end of the cloned ROMClass in deterministic order and updates the SRPs\n+// to them. It also removes some of the data that is not used by the JIT compiler.\n+//\n+// Packing involves 2 passes over all the strings that a ROMClass refers to:\n+// 1. Compute total size and map original strings to their locations in the packed ROMClass.\n+// 2. Copy each original string to its location in the packed ROMClass.\n static std::string\n-packROMClass(J9ROMClass *origRomClass, TR_Memory *trMemory)\n+packROMClass(J9ROMClass *romClass, TR_Memory *trMemory)\n    {\n-   size_t totalSize = origRomClass->romSize;\n-   J9UTF8 *className = J9ROMCLASS_CLASSNAME(origRomClass);\n-   totalSize += getPackedUTF8Size(className, origRomClass);\n-\n-   J9ROMMethod *romMethod = J9ROMCLASS_ROMMETHODS(origRomClass);\n-   for (size_t i = 0; i < origRomClass->romMethodCount; ++i)\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   // Primitive ROMClasses have different layout (see runtime/vm/romclasses.c): the last\n+   // ROMClass includes all the others' UTF8 name strings in its romSize, which breaks the\n+   // generic packing implementation. Pretend that its romSize only includes the header.\n+   size_t origRomSize = J9ROMCLASS_IS_PRIMITIVE_TYPE(romClass) ? sizeof(*romClass) : romClass->romSize;\n+   size_t totalSize = origRomSize;\n+\n+   // Remove intermediate class data (not used by JIT)\n+   uint8_t *icData = J9ROMCLASS_INTERMEDIATECLASSDATA(romClass);\n+   if (JITServerHelpers::isAddressInROMClass(icData, romClass) && (icData != (uint8_t *)romClass))\n       {\n-      totalSize += getPackedUTF8Size(J9ROMMETHOD_NAME(romMethod), origRomClass);\n-      totalSize += getPackedUTF8Size(J9ROMMETHOD_SIGNATURE(romMethod), origRomClass);\n-      romMethod = nextROMMethod(romMethod);\n+      TR_ASSERT_FATAL(icData + romClass->intermediateClassDataLength == (uint8_t *)romClass + romClass->romSize,\n+                      \"Intermediate class data not stored at the end of ROMClass %.*s\", name->length, name->data);\n+      totalSize -= romClass->intermediateClassDataLength;\n       }\n \n-   // Check if the contiguous part of the ROMClass already contains all the strings visited above\n-   if (totalSize == origRomClass->romSize)\n-      return std::string((char *)origRomClass, origRomClass->romSize);\n+   // All allocated memory is only used in this function\n+   TR::StackMemoryRegion stackMemoryRegion(*trMemory);\n+   ROMClassPackContext ctx(trMemory, origRomSize);\n \n-   J9ROMClass *romClass = (J9ROMClass *)trMemory->allocateHeapMemory(totalSize);\n-   if (!romClass)\n+   size_t copySize = 0;\n+   if (isArrayROMClass(romClass))\n+      {\n+      copySize = sizeof(*romClass);\n+      totalSize = getArrayROMClassPackedSize(romClass);\n+      }\n+   else\n+      {\n+      // 1st pass: iterate all strings in the ROMClass to compute its total size (including\n+      // interned strings) and map the strings to their locations in the packed ROMClass\n+      ctx.callback = sizeInfoCallback;\n+      allSlotsInROMClassDo(romClass, slotCallback, NULL, NULL, &ctx);\n+      // Handle the case when all strings are interned\n+      auto classEnd = (const uint8_t *)romClass + totalSize;\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, classEnd);\n+\n+      auto end = ctx.utf8SectionEnd ? ctx.utf8SectionEnd : classEnd;\n+      TR_ASSERT_FATAL(ctx.utf8SectionSize == end - ctx.utf8SectionStart,\n+                      \"Missed strings in ROMClass %.*s UTF8 section: %zu != %zu\",\n+                      name->length, name->data, ctx.utf8SectionSize, end - ctx.utf8SectionStart);\n+      end = (const uint8_t *)OMR::alignNoCheck((uintptr_t)end, sizeof(uint64_t));\n+      TR_ASSERT_FATAL(end == classEnd, \"UTF8 section not stored at the end of ROMClass %.*s: %p != %p\",", "originalCommit": "cf8bac93c10483471c4cef95c99e5644d0834e99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAwNjIyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r538006221", "bodyText": "end is computed with non-interned strings only.", "author": "AlexeyKhrabrov", "createdAt": "2020-12-08T03:28:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3NzUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ1Mzk2Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r538453963", "bodyText": "Right", "author": "mpirvu", "createdAt": "2020-12-08T14:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3NzUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk4NTc3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537985777", "bodyText": "Does this mean that for array ROMClasses we may send interface names multiple times?", "author": "mpirvu", "createdAt": "2020-12-08T02:31:11Z", "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.", "originalCommit": "cf8bac93c10483471c4cef95c99e5644d0834e99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAwOTc4NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r538009784", "bodyText": "For a given array ROMClass (or any ROMClass) we send all the strings it refers to (a single copy of each string). Overall, if we consider all the ROMClasses for a given client, there will be multiple copies of some strings (ones that were interned at the client). But it's the same for the current implementation - remote strings are retrieved and cached for each class separately. Deduplicating the strings on the server side would be non-trivial.", "author": "AlexeyKhrabrov", "createdAt": "2020-12-08T03:39:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk4NTc3Nw=="}], "type": "inlineReview"}, {"oid": "82b20ffb8e468d432005c6e502b3c52430ce193b", "url": "https://github.com/eclipse-openj9/openj9/commit/82b20ffb8e468d432005c6e502b3c52430ce193b", "message": "Increment JITServer protocol version\n\nSigned-off-by: Alexey Khrabrov <khrabrov@cs.toronto.edu>", "committedDate": "2020-12-09T19:41:36Z", "type": "forcePushed"}, {"oid": "da35bc6db67fd8c89034713986f7e262d6a50508", "url": "https://github.com/eclipse-openj9/openj9/commit/da35bc6db67fd8c89034713986f7e262d6a50508", "message": "Fully serialize ROMClasses sent to JITServer\n\nAll the UTF8 strings that a ROMClass refers to (including interned ones)\nare stored at the end in deterministic order. Strings that are only\nreferenced by SRPs stored outside the ROMClass bounds (such as method\ndebug info stored out-of-line) are excluded. Intermediate class data is\nremoved (if stored inside the ROMClass) and its SRP is set to 0. SRPs to\nout-of-line method debug info are set to 0.\n\nSigned-off-by: Alexey Khrabrov <khrabrov@cs.toronto.edu>", "committedDate": "2021-01-20T21:48:52Z", "type": "commit"}, {"oid": "26e3725cbb0b64c2411b1f8314a443cbb4809e11", "url": "https://github.com/eclipse-openj9/openj9/commit/26e3725cbb0b64c2411b1f8314a443cbb4809e11", "message": "Exclude inline method debug info strings from serialized ROMClass\n\nThis data is not used by the JIT and can be safely excluded during\nserialization in order to reduce the size of the packed ROMClass.\n\nSigned-off-by: Alexey Khrabrov <khrabrov@cs.toronto.edu>", "committedDate": "2021-01-20T21:48:52Z", "type": "commit"}, {"oid": "ed746f736d324b1b25298d973f79ec277bd6f3dd", "url": "https://github.com/eclipse-openj9/openj9/commit/ed746f736d324b1b25298d973f79ec277bd6f3dd", "message": "Remove obsolete code for retrieving and caching remote ROM strings\n\nWith full serialization of ROMClasses, this code is now obsolete and\nshould be removed.\n\nSigned-off-by: Alexey Khrabrov <khrabrov@cs.toronto.edu>", "committedDate": "2021-01-20T21:48:53Z", "type": "commit"}, {"oid": "42c6e42fc6b139b163b7c2bbaa5aadaf5defbee9", "url": "https://github.com/eclipse-openj9/openj9/commit/42c6e42fc6b139b163b7c2bbaa5aadaf5defbee9", "message": "Increment JITServer protocol version\n\nSigned-off-by: Alexey Khrabrov <khrabrov@cs.toronto.edu>", "committedDate": "2021-01-20T21:48:53Z", "type": "commit"}, {"oid": "42c6e42fc6b139b163b7c2bbaa5aadaf5defbee9", "url": "https://github.com/eclipse-openj9/openj9/commit/42c6e42fc6b139b163b7c2bbaa5aadaf5defbee9", "message": "Increment JITServer protocol version\n\nSigned-off-by: Alexey Khrabrov <khrabrov@cs.toronto.edu>", "committedDate": "2021-01-20T21:48:53Z", "type": "forcePushed"}]}