{"pr_number": 10850, "pr_title": "Improve performance of persistent memory allocator", "pr_createdAt": "2020-10-08T19:24:26Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10850", "timeline": [{"oid": "9587c68a2c87549a732acdb0097d112070a177cc", "url": "https://github.com/eclipse-openj9/openj9/commit/9587c68a2c87549a732acdb0097d112070a177cc", "message": "Improve performance of persistent memory allocator\n\nThe persistent memory allocator keeps a single linked list\nfor all freed memory blocks larger than 128 bytes. The list\nis sorted by the block size so every time we need to allocate\nfrom it or add a freed block to it we need to traverse it\nto find the appropriate spot. If this list becomes very large,\nsearching the list for the appropriate spot could consume an\nexcessive amount CPU.\nFor a regular JVM the usage pattern is not conducive to very\nlarge such lists. In contrast, JITServer makes extensive use\nof persistent memory. When one JVMClient ends, all of its\npersistent allocations (at JITServer) are put on this free\nblock list which could reach over 30K elements in size.\nThis makes allocations for a subsequent JVMClient very slow.\nThe solution implemented by this commit is to keep a set\nof indices to nodes whose sizes are power-of-two. This way,\nwhen searching for a free block, we don't have to start from\nthe beginning of the list, but start from a node in the middle\nbased on size.\nSince this change carries a bit of risk, it will be enabled\n(for the time being) only for JITServer\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-10-14T23:14:45Z", "type": "forcePushed"}, {"oid": "12f44e4f256ddd2371aea4cde37145b47a660403", "url": "https://github.com/eclipse-openj9/openj9/commit/12f44e4f256ddd2371aea4cde37145b47a660403", "message": "Improve performance of persistent memory allocator\n\nThe persistent memory allocator keeps a single linked list\nfor all freed memory blocks larger than 128 bytes. The list\nis sorted by the block size so every time we need to allocate\nfrom it or add a freed block to it we need to traverse it\nto find the appropriate spot. If this list becomes very large,\nsearching the list for the appropriate spot could consume an\nexcessive amount CPU.\nFor a regular JVM the usage pattern is not conducive to very\nlarge such lists. In contrast, JITServer makes extensive use\nof persistent memory. When one JVMClient ends, all of its\npersistent allocations (at JITServer) are put on this free\nblock list which could reach over 30K elements in size.\nThis makes allocations for a subsequent JVMClient very slow.\nThe solution implemented by this commit is to keep a set\nof indices to nodes whose sizes are power-of-two. This way,\nwhen searching for a free block, we don't have to start from\nthe beginning of the list, but start from a node in the middle\nbased on size.\nSince this change carries a bit of risk, it will be enabled\n(for the time being) only for JITServer\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-10-15T00:45:42Z", "type": "forcePushed"}, {"oid": "599c742bc1c529cd9bc4fd21ab89553e35d079b4", "url": "https://github.com/eclipse-openj9/openj9/commit/599c742bc1c529cd9bc4fd21ab89553e35d079b4", "message": "Improve performance of persistent memory allocator\n\nThe persistent memory allocator keeps a single linked list\nfor all freed memory blocks larger than 128 bytes. The list\nis sorted by the block size so every time we need to allocate\nfrom it or add a freed block to it we need to traverse it\nto find the appropriate spot. If this list becomes very large,\nsearching the list for the appropriate spot could consume an\nexcessive amount CPU.\nFor a regular JVM the usage pattern is not conducive to very\nlarge such lists. In contrast, JITServer makes extensive use\nof persistent memory. When one JVMClient ends, all of its\npersistent allocations (at JITServer) are put on this free\nblock list which could reach over 30K elements in size.\nThis makes allocations for a subsequent JVMClient very slow.\nThe solution implemented by this commit is to keep a set\nof indices to nodes whose sizes are power-of-two. This way,\nwhen searching for a free block, we don't have to start from\nthe beginning of the list, but start from a node in the middle\nbased on size.\nSince this change carries a bit of risk, it will be enabled\n(for the time being) only for JITServer\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-10-15T18:01:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyODg4Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505828887", "bodyText": "Why do we need shift one more than BITS_TO_SHIFT_FIRST_INTERVAL? Right now, since a \"large block\" is any allocation greater than 2^7 bytes, doesn't this means that the interval 0 will contain blocks ranging from [2^7, 2^9), whereas for any other interval m, the range would be [2^m, 2^m+1)? It looks like from the code above:\nif (blockSize >= (1 << (BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS - 1)))\n\nthe last interval is given to anything >= than 2^14. However, if the bits were only shifted BITS_TO_SHIFT_FIRST_INTERVAL, then:\nblock size 2^7 == b'1000 0000; 2^7 >> 8 == b'1000\nblock size 2^16 - 1 == b'1111 1111 1111 1111; 2^16 - 1 >> 8 == b'1111 1111\nThis ranges would yield valid indices into the __logTable. As it stands, it doesn't look like all the intervals will be used since 2^14 - 1 == b'11 1111 1111 1111; 2^14 - 1 >> 8 == b'11 1111, which  means it'll result with an interval of 4 + _logTable[3] == 5.", "author": "dsouzai", "createdAt": "2020-10-15T20:40:19Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -228,58 +324,256 @@ void\n PersistentAllocator::freeFixedSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   size_t const index = freeBlocksIndex(block->size());\n    TR_ASSERT(index != LARGE_BLOCK_LIST_INDEX, \"freeFixedSizeBlock should be used for small blocks, so index cannot be LARGE_BLOCK_LIST_INDEX\");\n-   block->_next = _freeBlocks[index];\n+   block->setNext(_freeBlocks[index]);\n    _freeBlocks[index] = block;\n    }\n \n void\n PersistentAllocator::freeVariableSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   block->_next = NULL;\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   block->setNext(NULL);\n    // Add block to the variable-size-block chain which is in ascending size order.\n    //\n-   TR_ASSERT(freeBlocksIndex(block->_size) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n+   TR_ASSERT(freeBlocksIndex(block->size()) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n    Block * blockIterator = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n-   if (!blockIterator || !(blockIterator->_size < block->_size) )\n+   if (!blockIterator || !(blockIterator->size() < block->size()) )\n       {\n-      block->_next = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n+      block->setNext(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n       _freeBlocks[LARGE_BLOCK_LIST_INDEX] = block;\n       }\n    else\n       {\n-      while (blockIterator->next() && blockIterator->next()->_size < block->_size)\n+      while (blockIterator->next() && blockIterator->next()->size() < block->size())\n          {\n          blockIterator = blockIterator->next();\n          }\n-      block->_next = blockIterator->next();\n-      blockIterator->_next = block;\n+      block->setNext(blockIterator->next());\n+      blockIterator->setNext(block);\n+      }\n+   }\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+size_t \n+PersistentAllocator::getInterval(size_t blockSize)\n+   {  \n+   // Find the power-of-two interval that this block size belongs to\n+   TR_ASSERT(blockSize >= PERSISTANT_BLOCK_SIZE_BUCKETS * sizeof(void *), \"getInterval should be used only on big blocks. blockSize=%zu\", blockSize);\n+   // If very large block\n+   if (blockSize >= (1 << (BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS - 1)))\n+      return NUM_INTERVALS - 1; // last one\n+   blockSize >>= (BITS_TO_SHIFT_FIRST_INTERVAL + 1);", "originalCommit": "599c742bc1c529cd9bc4fd21ab89553e35d079b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTk4NjQzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505986431", "bodyText": "You are right, blockSize needs to be shifted only by BITS_TO_SHIFT_FIRST_INTERVAL.\nThe original code for finding the interval is commented out at the end of this function. With that code I needed to shift by BITS_TO_SHIFT_FIRST_INTERVAL+1, but with my new (and supposedly faster) implementation using the lookup table I need to delete that 1.", "author": "mpirvu", "createdAt": "2020-10-16T02:13:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyODg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjUzMDM0OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r506530348", "bodyText": "Regarding if (blockSize >= (1 << (BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS - 1))), did you still want to max it 2^14? I believe 2^15 - 1 would yield a shift of 7, so you can make the maximum 2^16 (ie BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS + 1)", "author": "dsouzai", "createdAt": "2020-10-16T15:11:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyODg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU0NzIxNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r506547216", "bodyText": "I could increase the number of intervals from 8 to 9, though, from experiments, the number of blocks with very large sizes is low. Maybe just to be future proof.", "author": "mpirvu", "createdAt": "2020-10-16T15:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyODg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU1NDUxNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r506554515", "bodyText": "Sorry, I didn't mean to increase the number of intervals; I meant that with the current 8 intervals, BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS - 1 == 14 whereas you can have it be BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS + 1 == 16 with the 8 intervals.", "author": "dsouzai", "createdAt": "2020-10-16T15:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyODg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU1NjkxMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r506556913", "bodyText": "since 2^15 - 1 will yield 0xFFFFFFFF which, when shifted by 8 will give you 0xFFFF; the upper 4 bits will then be 15, so it can be indexed into the _logTable array.", "author": "dsouzai", "createdAt": "2020-10-16T15:41:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyODg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU3MDY3NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r506570675", "bodyText": "I don't understand what this will achieve. Currently, if the block size is greater than 16K, I directly return interval=7 (last one) without any log2 function (thus saving unnecessary overhead)", "author": "mpirvu", "createdAt": "2020-10-16T15:59:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyODg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU3NDc2MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r506574760", "bodyText": "I guess right now, 2^14 - 1 would get you 0x3FFF; after rsh8, you get 0x3F; so the interval you'd get out of this method is 4+_logTable[3] == 4+1 = 5. On the other hand 2^14 gets you interval 7. So we never end up using interval 6. I guess I'm asking if that matters.", "author": "dsouzai", "createdAt": "2020-10-16T16:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyODg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyMDM4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r506620383", "bodyText": "2^14 - 1 is 0x7FFF (not 0x3FFF) so this will map to interval 6, whereas all the big blocks over 2^14 get mapped to interval 7 (last one)", "author": "mpirvu", "createdAt": "2020-10-16T17:29:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyODg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyMzA0OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r506623048", "bodyText": "2^14 == 1 << 14 == b'0100 0000 0000 0000 == 0x4000, so 2^14 - 1 is 0x3FFF. (I verified on multiple calculators just in case I was inputting things wrong heh)", "author": "dsouzai", "createdAt": "2020-10-16T17:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyODg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY0MTUyMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r506641520", "bodyText": "You are right about 2^14-1 == 0x3FFF.\nLet me go step by step to avoid any mistakes.\nThis is the intent of the code I have:\n[128, 256) --> Interval 0\n[256, 512) --> Interval 1\n[512, 1K) --> Interval 2\n[1K, 2K) --> Interval 3\n[2K, 4K) --> Interval 4\n[4K, 8K) --> Interval 5\n[8K, 16K) --> Interval 6\nEverything larger or equal to 16K --> Interval 7\n2^14 - 1 falls in the [8K, 16K) range so it should yield interval 6\n2^14-1 = b'11 1111 1111 1111 (that's 14 of ones)\nAfter blockSize >>= BITS_TO_SHIFT_FIRST_INTERVAL; operation, block size removes 7 bits and we are left with just 7 of ones: b'111 1111.\nThen we get into (upper = blockSize >> 4) ? 4 + _logTable[upper] : _logTable[blockSize];\nblockSize is shifted 4 more positions so we are left with 111. The lookup table is consulted for position 7 which yields  value 2. This added to 4 to yield interval 6.", "author": "mpirvu", "createdAt": "2020-10-16T18:05:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyODg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY1NjY4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r506656688", "bodyText": "Ah, I see what I was doing wrong; I was right shifting by 8 (ie NUM_INTERVALS) instead of BITS_TO_SHIFT_FIRST_INTERVAL which is a right shift by 7. It's worth noting that we'll never actually read from _logTable[0].", "author": "dsouzai", "createdAt": "2020-10-16T18:36:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyODg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyOTY0OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505829648", "bodyText": "Isn't this doing the same thing as the floorLog2 function? Couldn't we just have one implementation?", "author": "dsouzai", "createdAt": "2020-10-15T20:41:14Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -228,58 +324,256 @@ void\n PersistentAllocator::freeFixedSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   size_t const index = freeBlocksIndex(block->size());\n    TR_ASSERT(index != LARGE_BLOCK_LIST_INDEX, \"freeFixedSizeBlock should be used for small blocks, so index cannot be LARGE_BLOCK_LIST_INDEX\");\n-   block->_next = _freeBlocks[index];\n+   block->setNext(_freeBlocks[index]);\n    _freeBlocks[index] = block;\n    }\n \n void\n PersistentAllocator::freeVariableSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   block->_next = NULL;\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   block->setNext(NULL);\n    // Add block to the variable-size-block chain which is in ascending size order.\n    //\n-   TR_ASSERT(freeBlocksIndex(block->_size) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n+   TR_ASSERT(freeBlocksIndex(block->size()) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n    Block * blockIterator = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n-   if (!blockIterator || !(blockIterator->_size < block->_size) )\n+   if (!blockIterator || !(blockIterator->size() < block->size()) )\n       {\n-      block->_next = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n+      block->setNext(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n       _freeBlocks[LARGE_BLOCK_LIST_INDEX] = block;\n       }\n    else\n       {\n-      while (blockIterator->next() && blockIterator->next()->_size < block->_size)\n+      while (blockIterator->next() && blockIterator->next()->size() < block->size())\n          {\n          blockIterator = blockIterator->next();\n          }\n-      block->_next = blockIterator->next();\n-      blockIterator->_next = block;\n+      block->setNext(blockIterator->next());\n+      blockIterator->setNext(block);\n+      }\n+   }\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+size_t \n+PersistentAllocator::getInterval(size_t blockSize)\n+   {  \n+   // Find the power-of-two interval that this block size belongs to\n+   TR_ASSERT(blockSize >= PERSISTANT_BLOCK_SIZE_BUCKETS * sizeof(void *), \"getInterval should be used only on big blocks. blockSize=%zu\", blockSize);\n+   // If very large block\n+   if (blockSize >= (1 << (BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS - 1)))\n+      return NUM_INTERVALS - 1; // last one\n+   blockSize >>= (BITS_TO_SHIFT_FIRST_INTERVAL + 1);\n+   // log2 implementation that uses a lookup table of 16 entries\n+   // The value to compute the log on cannot be larger than 1 byte\n+   static_assert(NUM_INTERVALS <= 9, \"For large values of NUM_INTERVALS the log2 implementation below will not work\");\n+   TR_ASSERT(blockSize < (1 << 8), \"blockSize is too large %zu to apply the log2 implementation below\", blockSize);\n+   static const uint8_t _logTable[16] = { 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3 };\n+   size_t upper;\n+   return (upper = blockSize >> 4) ? 4 + _logTable[upper] : _logTable[blockSize];", "originalCommit": "599c742bc1c529cd9bc4fd21ab89553e35d079b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTk4OTU1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505989555", "bodyText": "floorLog2 from the header file is not very efficient because it uses recursion and can recurse 64 times. That function is marked constexpr because it needs to be evaluated during the compilation and used as a hardcoded value by the compiler. In c++11 constexpr functions need to have only one line, which basically forces one to use recursion.", "author": "mpirvu", "createdAt": "2020-10-16T02:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyOTY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyOTk4Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505829987", "bodyText": "Do these comments need to be in the code?", "author": "dsouzai", "createdAt": "2020-10-15T20:41:41Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -228,58 +324,256 @@ void\n PersistentAllocator::freeFixedSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   size_t const index = freeBlocksIndex(block->size());\n    TR_ASSERT(index != LARGE_BLOCK_LIST_INDEX, \"freeFixedSizeBlock should be used for small blocks, so index cannot be LARGE_BLOCK_LIST_INDEX\");\n-   block->_next = _freeBlocks[index];\n+   block->setNext(_freeBlocks[index]);\n    _freeBlocks[index] = block;\n    }\n \n void\n PersistentAllocator::freeVariableSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   block->_next = NULL;\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   block->setNext(NULL);\n    // Add block to the variable-size-block chain which is in ascending size order.\n    //\n-   TR_ASSERT(freeBlocksIndex(block->_size) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n+   TR_ASSERT(freeBlocksIndex(block->size()) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n    Block * blockIterator = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n-   if (!blockIterator || !(blockIterator->_size < block->_size) )\n+   if (!blockIterator || !(blockIterator->size() < block->size()) )\n       {\n-      block->_next = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n+      block->setNext(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n       _freeBlocks[LARGE_BLOCK_LIST_INDEX] = block;\n       }\n    else\n       {\n-      while (blockIterator->next() && blockIterator->next()->_size < block->_size)\n+      while (blockIterator->next() && blockIterator->next()->size() < block->size())\n          {\n          blockIterator = blockIterator->next();\n          }\n-      block->_next = blockIterator->next();\n-      blockIterator->_next = block;\n+      block->setNext(blockIterator->next());\n+      blockIterator->setNext(block);\n+      }\n+   }\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+size_t \n+PersistentAllocator::getInterval(size_t blockSize)\n+   {  \n+   // Find the power-of-two interval that this block size belongs to\n+   TR_ASSERT(blockSize >= PERSISTANT_BLOCK_SIZE_BUCKETS * sizeof(void *), \"getInterval should be used only on big blocks. blockSize=%zu\", blockSize);\n+   // If very large block\n+   if (blockSize >= (1 << (BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS - 1)))\n+      return NUM_INTERVALS - 1; // last one\n+   blockSize >>= (BITS_TO_SHIFT_FIRST_INTERVAL + 1);\n+   // log2 implementation that uses a lookup table of 16 entries\n+   // The value to compute the log on cannot be larger than 1 byte\n+   static_assert(NUM_INTERVALS <= 9, \"For large values of NUM_INTERVALS the log2 implementation below will not work\");\n+   TR_ASSERT(blockSize < (1 << 8), \"blockSize is too large %zu to apply the log2 implementation below\", blockSize);\n+   static const uint8_t _logTable[16] = { 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3 };\n+   size_t upper;\n+   return (upper = blockSize >> 4) ? 4 + _logTable[upper] : _logTable[blockSize];\n+   //size_t index = 0;\n+   //for (; blockSize; ++index, blockSize >>=1) {}\n+   //return index;", "originalCommit": "599c742bc1c529cd9bc4fd21ab89553e35d079b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTk5MTM5NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505991395", "bodyText": "This is the old implementation of my log2 function. Less efficient than the one based on the lookup table, but more general (the one based on the lookup table works only for one byte values which limits the number of \"intervals\" one can have). I left it as an example, but I guess it's not hard to re-implement if we want more \"intervals\".", "author": "mpirvu", "createdAt": "2020-10-16T02:22:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyOTk4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2NTA5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505865092", "bodyText": "Would be better to have a more descriptive name than block1.", "author": "dsouzai", "createdAt": "2020-10-15T21:23:46Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -228,58 +324,256 @@ void\n PersistentAllocator::freeFixedSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   size_t const index = freeBlocksIndex(block->size());\n    TR_ASSERT(index != LARGE_BLOCK_LIST_INDEX, \"freeFixedSizeBlock should be used for small blocks, so index cannot be LARGE_BLOCK_LIST_INDEX\");\n-   block->_next = _freeBlocks[index];\n+   block->setNext(_freeBlocks[index]);\n    _freeBlocks[index] = block;\n    }\n \n void\n PersistentAllocator::freeVariableSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   block->_next = NULL;\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   block->setNext(NULL);\n    // Add block to the variable-size-block chain which is in ascending size order.\n    //\n-   TR_ASSERT(freeBlocksIndex(block->_size) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n+   TR_ASSERT(freeBlocksIndex(block->size()) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n    Block * blockIterator = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n-   if (!blockIterator || !(blockIterator->_size < block->_size) )\n+   if (!blockIterator || !(blockIterator->size() < block->size()) )\n       {\n-      block->_next = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n+      block->setNext(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n       _freeBlocks[LARGE_BLOCK_LIST_INDEX] = block;\n       }\n    else\n       {\n-      while (blockIterator->next() && blockIterator->next()->_size < block->_size)\n+      while (blockIterator->next() && blockIterator->next()->size() < block->size())\n          {\n          blockIterator = blockIterator->next();\n          }\n-      block->_next = blockIterator->next();\n-      blockIterator->_next = block;\n+      block->setNext(blockIterator->next());\n+      blockIterator->setNext(block);\n+      }\n+   }\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+size_t \n+PersistentAllocator::getInterval(size_t blockSize)\n+   {  \n+   // Find the power-of-two interval that this block size belongs to\n+   TR_ASSERT(blockSize >= PERSISTANT_BLOCK_SIZE_BUCKETS * sizeof(void *), \"getInterval should be used only on big blocks. blockSize=%zu\", blockSize);\n+   // If very large block\n+   if (blockSize >= (1 << (BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS - 1)))\n+      return NUM_INTERVALS - 1; // last one\n+   blockSize >>= (BITS_TO_SHIFT_FIRST_INTERVAL + 1);\n+   // log2 implementation that uses a lookup table of 16 entries\n+   // The value to compute the log on cannot be larger than 1 byte\n+   static_assert(NUM_INTERVALS <= 9, \"For large values of NUM_INTERVALS the log2 implementation below will not work\");\n+   TR_ASSERT(blockSize < (1 << 8), \"blockSize is too large %zu to apply the log2 implementation below\", blockSize);\n+   static const uint8_t _logTable[16] = { 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3 };\n+   size_t upper;\n+   return (upper = blockSize >> 4) ? 4 + _logTable[upper] : _logTable[blockSize];\n+   //size_t index = 0;\n+   //for (; blockSize; ++index, blockSize >>=1) {}\n+   //return index;\n+   }\n+\n+void\n+PersistentAllocator::freeBlockToIndexedList(Block * block1)", "originalCommit": "599c742bc1c529cd9bc4fd21ab89553e35d079b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTk5MTcwMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505991703", "bodyText": "Will change to blockToBeFreed", "author": "mpirvu", "createdAt": "2020-10-16T02:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2NTA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg4NTAxMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505885011", "bodyText": "I think you have to potentially update _startInterval here, since the blocks are added before the existing block, and hence when searching for a new block we won't realize a chain exists.", "author": "dsouzai", "createdAt": "2020-10-15T21:50:58Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -228,58 +324,256 @@ void\n PersistentAllocator::freeFixedSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   size_t const index = freeBlocksIndex(block->size());\n    TR_ASSERT(index != LARGE_BLOCK_LIST_INDEX, \"freeFixedSizeBlock should be used for small blocks, so index cannot be LARGE_BLOCK_LIST_INDEX\");\n-   block->_next = _freeBlocks[index];\n+   block->setNext(_freeBlocks[index]);\n    _freeBlocks[index] = block;\n    }\n \n void\n PersistentAllocator::freeVariableSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   block->_next = NULL;\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   block->setNext(NULL);\n    // Add block to the variable-size-block chain which is in ascending size order.\n    //\n-   TR_ASSERT(freeBlocksIndex(block->_size) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n+   TR_ASSERT(freeBlocksIndex(block->size()) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n    Block * blockIterator = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n-   if (!blockIterator || !(blockIterator->_size < block->_size) )\n+   if (!blockIterator || !(blockIterator->size() < block->size()) )\n       {\n-      block->_next = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n+      block->setNext(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n       _freeBlocks[LARGE_BLOCK_LIST_INDEX] = block;\n       }\n    else\n       {\n-      while (blockIterator->next() && blockIterator->next()->_size < block->_size)\n+      while (blockIterator->next() && blockIterator->next()->size() < block->size())\n          {\n          blockIterator = blockIterator->next();\n          }\n-      block->_next = blockIterator->next();\n-      blockIterator->_next = block;\n+      block->setNext(blockIterator->next());\n+      blockIterator->setNext(block);\n+      }\n+   }\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+size_t \n+PersistentAllocator::getInterval(size_t blockSize)\n+   {  \n+   // Find the power-of-two interval that this block size belongs to\n+   TR_ASSERT(blockSize >= PERSISTANT_BLOCK_SIZE_BUCKETS * sizeof(void *), \"getInterval should be used only on big blocks. blockSize=%zu\", blockSize);\n+   // If very large block\n+   if (blockSize >= (1 << (BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS - 1)))\n+      return NUM_INTERVALS - 1; // last one\n+   blockSize >>= (BITS_TO_SHIFT_FIRST_INTERVAL + 1);\n+   // log2 implementation that uses a lookup table of 16 entries\n+   // The value to compute the log on cannot be larger than 1 byte\n+   static_assert(NUM_INTERVALS <= 9, \"For large values of NUM_INTERVALS the log2 implementation below will not work\");\n+   TR_ASSERT(blockSize < (1 << 8), \"blockSize is too large %zu to apply the log2 implementation below\", blockSize);\n+   static const uint8_t _logTable[16] = { 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3 };\n+   size_t upper;\n+   return (upper = blockSize >> 4) ? 4 + _logTable[upper] : _logTable[blockSize];\n+   //size_t index = 0;\n+   //for (; blockSize; ++index, blockSize >>=1) {}\n+   //return index;\n+   }\n+\n+void\n+PersistentAllocator::freeBlockToIndexedList(Block * block1)\n+   {\n+   checkIntegrity(\"freeVariableSizeBlock start\");\n+   TR_ASSERT_FATAL(block1->next() == NULL, \"Double free detected %p\", block1);\n+   TR_ASSERT(block1->size() > 0, \"Block size is non-positive\");\n+   TR_ASSERT(freeBlocksIndex(block1->size()) == LARGE_BLOCK_LIST_INDEX, \"We must be working on the variable size block list\");\n+\n+   ExtendedBlock *block = reinterpret_cast<ExtendedBlock *>(block1);\n+   block->init(); // reset links to other nodes\n+\n+   size_t index = getInterval(block->size());\n+\n+   ExtendedBlock * blockIterator = reinterpret_cast<ExtendedBlock*>(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n+   if (!blockIterator || blockIterator->size() > block->size())\n+      {\n+      // Add at the beginning of the list\n+      block->setNext(reinterpret_cast<ExtendedBlock*>(_freeBlocks[LARGE_BLOCK_LIST_INDEX]));\n+      _freeBlocks[LARGE_BLOCK_LIST_INDEX] = reinterpret_cast<Block*>(block);\n+      if (block->next())\n+         block->next()->setPrevious(block);\n+      // Adjust the interval bounderies\n+      _startInterval[index] = block;\n+      if (!_endInterval[index])\n+         _endInterval[index] = block;\n+      }\n+   else // This will not be the very first block in the variable size block list\n+      {\n+      // Find position in the list\n+      if (_startInterval[index])\n+         {\n+         // Other blocks are present in this interval\n+         ExtendedBlock *startBlock = _startInterval[index];\n+         ExtendedBlock *blockIterator = startBlock;\n+\n+         ExtendedBlock *prev = NULL;\n+         while (blockIterator && blockIterator->size() < block->size())\n+            {\n+            prev = blockIterator;\n+            blockIterator = blockIterator->next();\n+            }\n+         if (blockIterator)\n+            {\n+            // Insert at or before blockIterator\n+            if (blockIterator->size() == block->size())\n+               {\n+               // Add the block to the list of blocks of same size\n+               block->setNextBlockSameSize(blockIterator->nextBlockSameSize());\n+               blockIterator->setNextBlockSameSize(block);\n+               }", "originalCommit": "599c742bc1c529cd9bc4fd21ab89553e35d079b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAwNzAzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r506007031", "bodyText": "I don't understand. For the code above we add our block to a list of blocks of same size.\nImagine the big list of variable size blocks as an entity that spans horizontally. The list of blocks that have same size is an entity that spans vertically in this diagram. Here we add to that vertical segment.\n128 --> 144 --> ...\n         |\n         V\n        144\n         |\n         V\n        NULL", "author": "mpirvu", "createdAt": "2020-10-16T02:50:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg4NTAxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjUyNTU4OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r506525589", "bodyText": "Ah yes, you're right; we don't add to the front of the chain, but rather the new block gets added right after the first element in the chain.", "author": "dsouzai", "createdAt": "2020-10-16T15:06:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg4NTAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg5MjcyNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505892724", "bodyText": "I don't think this is necessary, since prevBlock is set to block, and block is set to block->next(), so prevBlock->next() is always going to be block, except for I guess maybe some race condition.", "author": "dsouzai", "createdAt": "2020-10-15T22:09:48Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -228,58 +324,256 @@ void\n PersistentAllocator::freeFixedSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   size_t const index = freeBlocksIndex(block->size());\n    TR_ASSERT(index != LARGE_BLOCK_LIST_INDEX, \"freeFixedSizeBlock should be used for small blocks, so index cannot be LARGE_BLOCK_LIST_INDEX\");\n-   block->_next = _freeBlocks[index];\n+   block->setNext(_freeBlocks[index]);\n    _freeBlocks[index] = block;\n    }\n \n void\n PersistentAllocator::freeVariableSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   block->_next = NULL;\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   block->setNext(NULL);\n    // Add block to the variable-size-block chain which is in ascending size order.\n    //\n-   TR_ASSERT(freeBlocksIndex(block->_size) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n+   TR_ASSERT(freeBlocksIndex(block->size()) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n    Block * blockIterator = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n-   if (!blockIterator || !(blockIterator->_size < block->_size) )\n+   if (!blockIterator || !(blockIterator->size() < block->size()) )\n       {\n-      block->_next = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n+      block->setNext(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n       _freeBlocks[LARGE_BLOCK_LIST_INDEX] = block;\n       }\n    else\n       {\n-      while (blockIterator->next() && blockIterator->next()->_size < block->_size)\n+      while (blockIterator->next() && blockIterator->next()->size() < block->size())\n          {\n          blockIterator = blockIterator->next();\n          }\n-      block->_next = blockIterator->next();\n-      blockIterator->_next = block;\n+      block->setNext(blockIterator->next());\n+      blockIterator->setNext(block);\n+      }\n+   }\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+size_t \n+PersistentAllocator::getInterval(size_t blockSize)\n+   {  \n+   // Find the power-of-two interval that this block size belongs to\n+   TR_ASSERT(blockSize >= PERSISTANT_BLOCK_SIZE_BUCKETS * sizeof(void *), \"getInterval should be used only on big blocks. blockSize=%zu\", blockSize);\n+   // If very large block\n+   if (blockSize >= (1 << (BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS - 1)))\n+      return NUM_INTERVALS - 1; // last one\n+   blockSize >>= (BITS_TO_SHIFT_FIRST_INTERVAL + 1);\n+   // log2 implementation that uses a lookup table of 16 entries\n+   // The value to compute the log on cannot be larger than 1 byte\n+   static_assert(NUM_INTERVALS <= 9, \"For large values of NUM_INTERVALS the log2 implementation below will not work\");\n+   TR_ASSERT(blockSize < (1 << 8), \"blockSize is too large %zu to apply the log2 implementation below\", blockSize);\n+   static const uint8_t _logTable[16] = { 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3 };\n+   size_t upper;\n+   return (upper = blockSize >> 4) ? 4 + _logTable[upper] : _logTable[blockSize];\n+   //size_t index = 0;\n+   //for (; blockSize; ++index, blockSize >>=1) {}\n+   //return index;\n+   }\n+\n+void\n+PersistentAllocator::freeBlockToIndexedList(Block * block1)\n+   {\n+   checkIntegrity(\"freeVariableSizeBlock start\");\n+   TR_ASSERT_FATAL(block1->next() == NULL, \"Double free detected %p\", block1);\n+   TR_ASSERT(block1->size() > 0, \"Block size is non-positive\");\n+   TR_ASSERT(freeBlocksIndex(block1->size()) == LARGE_BLOCK_LIST_INDEX, \"We must be working on the variable size block list\");\n+\n+   ExtendedBlock *block = reinterpret_cast<ExtendedBlock *>(block1);\n+   block->init(); // reset links to other nodes\n+\n+   size_t index = getInterval(block->size());\n+\n+   ExtendedBlock * blockIterator = reinterpret_cast<ExtendedBlock*>(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n+   if (!blockIterator || blockIterator->size() > block->size())\n+      {\n+      // Add at the beginning of the list\n+      block->setNext(reinterpret_cast<ExtendedBlock*>(_freeBlocks[LARGE_BLOCK_LIST_INDEX]));\n+      _freeBlocks[LARGE_BLOCK_LIST_INDEX] = reinterpret_cast<Block*>(block);\n+      if (block->next())\n+         block->next()->setPrevious(block);\n+      // Adjust the interval bounderies\n+      _startInterval[index] = block;\n+      if (!_endInterval[index])\n+         _endInterval[index] = block;\n+      }\n+   else // This will not be the very first block in the variable size block list\n+      {\n+      // Find position in the list\n+      if (_startInterval[index])\n+         {\n+         // Other blocks are present in this interval\n+         ExtendedBlock *startBlock = _startInterval[index];\n+         ExtendedBlock *blockIterator = startBlock;\n+\n+         ExtendedBlock *prev = NULL;\n+         while (blockIterator && blockIterator->size() < block->size())\n+            {\n+            prev = blockIterator;\n+            blockIterator = blockIterator->next();\n+            }\n+         if (blockIterator)\n+            {\n+            // Insert at or before blockIterator\n+            if (blockIterator->size() == block->size())\n+               {\n+               // Add the block to the list of blocks of same size\n+               block->setNextBlockSameSize(blockIterator->nextBlockSameSize());\n+               blockIterator->setNextBlockSameSize(block);\n+               }\n+            else // Insert before blockIterator\n+               {\n+               block->setNext(blockIterator);\n+               block->setPrevious(blockIterator->previous());\n+               TR_ASSERT(blockIterator->previous(), \"blockIterator->previous() must exist because we already treated the case where we insert at the beginning of the list\");\n+               blockIterator->previous()->setNext(block);\n+               blockIterator->setPrevious(block);\n+               // Adjust the interval bounderies\n+               if (_startInterval[index]->size() > block->size())\n+                  {\n+                  // block becomes the first entry in this interval\n+                  TR_ASSERT(_startInterval[index] == blockIterator, \"blockInterator must be first block in this interval\"); \n+                  _startInterval[index] = block;\n+                  }\n+               else // Insert in the middle or end of interval\n+                  {\n+                  // blockIterator may belong to the next interval in\n+                  // which case _endInterval needs to be changed to block\n+                  if (_endInterval[index]->size() < block->size())\n+                     {\n+                     TR_ASSERT(getInterval(blockIterator->size()) > index, \"blockInterator must be first block in the next interval: index=%zu b->sz=%zu bi->sz=%zu\", index, block->size(), blockIterator->size());\n+                     _endInterval[index] = block;\n+                     }\n+                  }\n+               }\n+            }\n+         else // Insert after 'prev'; block will be the very last entry in the list\n+            {\n+            TR_ASSERT(prev, \"prev must exist\");\n+            TR_ASSERT(!prev->next(), \"this must be the last element in the list\");\n+            block->setPrevious(prev);\n+            block->setNext(NULL);\n+            prev->setNext(block);\n+            _endInterval[index] = block;\n+            }\n+         }\n+      else // There are no other blocks in this interval\n+         {\n+         // Find the closest interval that has a block\n+         // I verified that the block will not be attached at the beginning of the list.\n+         // Thus, there must be a previous interval with some block in it\n+         TR_ASSERT(index > 0, \"Index must be greater than 0\");\n+         for (int i = (int)index - 1; i >= 0; i--)\n+            {\n+            if (_endInterval[i])\n+               {\n+               block->setPrevious(_endInterval[i]);\n+               block->setNext(_endInterval[i]->next());\n+               TR_ASSERT(block->size() > _endInterval[i]->size(), \"wrong sizes previous\");\n+               if (block->next())\n+                  {\n+                  block->next()->setPrevious(block);\n+                  TR_ASSERT(block->size() < block->next()->size(), \"wrong sizes after block->size()=%zu next->size()=%zu\", block->size(), block->next()->size());\n+                  }\n+               _endInterval[i]->setNext(block);\n+               break;\n+               }\n+            }\n+         TR_ASSERT(block->previous(), \"I must have attached my block to the list\");\n+         _startInterval[index] = block;\n+         _endInterval[index] = block;\n+         }\n       }\n+      checkIntegrity(\"freeVariableSizeBlock end\");   \n    }\n \n+void \n+PersistentAllocator::checkIntegrity(const char msg[])\n+   {\n+#ifdef DEBUG\n+   ExtendedBlock *firstBlock = reinterpret_cast<ExtendedBlock*>(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n+   ExtendedBlock *prevBlock = NULL;\n+   TR_ASSERT_FATAL(!firstBlock || firstBlock->previous() == NULL, \"Error for first block\");\n+   for (ExtendedBlock *block = firstBlock; block; prevBlock = block, block = block->next())\n+      {\n+      if (prevBlock)\n+         {\n+         TR_ASSERT_FATAL(prevBlock->size() < block->size(), \"Blocks are not correctly ordered\");\n+         TR_ASSERT_FATAL(block->previous() == prevBlock, \"block->previous() != prevBlock\");\n+         TR_ASSERT_FATAL(prevBlock->next() == block, \"prevBlock->next() != block\");", "originalCommit": "599c742bc1c529cd9bc4fd21ab89553e35d079b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTk5OTIzOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505999239", "bodyText": "Correct. I'll delete the last assert.", "author": "mpirvu", "createdAt": "2020-10-16T02:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg5MjcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg5MzAzNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505893037", "bodyText": "Since we don't really build debug builds, maybe this is better guarded with an option, or env var. Otherwise, we risk this code getting stale.", "author": "dsouzai", "createdAt": "2020-10-15T22:10:27Z", "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -228,58 +324,256 @@ void\n PersistentAllocator::freeFixedSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   size_t const index = freeBlocksIndex(block->size());\n    TR_ASSERT(index != LARGE_BLOCK_LIST_INDEX, \"freeFixedSizeBlock should be used for small blocks, so index cannot be LARGE_BLOCK_LIST_INDEX\");\n-   block->_next = _freeBlocks[index];\n+   block->setNext(_freeBlocks[index]);\n    _freeBlocks[index] = block;\n    }\n \n void\n PersistentAllocator::freeVariableSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   block->_next = NULL;\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   block->setNext(NULL);\n    // Add block to the variable-size-block chain which is in ascending size order.\n    //\n-   TR_ASSERT(freeBlocksIndex(block->_size) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n+   TR_ASSERT(freeBlocksIndex(block->size()) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n    Block * blockIterator = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n-   if (!blockIterator || !(blockIterator->_size < block->_size) )\n+   if (!blockIterator || !(blockIterator->size() < block->size()) )\n       {\n-      block->_next = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n+      block->setNext(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n       _freeBlocks[LARGE_BLOCK_LIST_INDEX] = block;\n       }\n    else\n       {\n-      while (blockIterator->next() && blockIterator->next()->_size < block->_size)\n+      while (blockIterator->next() && blockIterator->next()->size() < block->size())\n          {\n          blockIterator = blockIterator->next();\n          }\n-      block->_next = blockIterator->next();\n-      blockIterator->_next = block;\n+      block->setNext(blockIterator->next());\n+      blockIterator->setNext(block);\n+      }\n+   }\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+size_t \n+PersistentAllocator::getInterval(size_t blockSize)\n+   {  \n+   // Find the power-of-two interval that this block size belongs to\n+   TR_ASSERT(blockSize >= PERSISTANT_BLOCK_SIZE_BUCKETS * sizeof(void *), \"getInterval should be used only on big blocks. blockSize=%zu\", blockSize);\n+   // If very large block\n+   if (blockSize >= (1 << (BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS - 1)))\n+      return NUM_INTERVALS - 1; // last one\n+   blockSize >>= (BITS_TO_SHIFT_FIRST_INTERVAL + 1);\n+   // log2 implementation that uses a lookup table of 16 entries\n+   // The value to compute the log on cannot be larger than 1 byte\n+   static_assert(NUM_INTERVALS <= 9, \"For large values of NUM_INTERVALS the log2 implementation below will not work\");\n+   TR_ASSERT(blockSize < (1 << 8), \"blockSize is too large %zu to apply the log2 implementation below\", blockSize);\n+   static const uint8_t _logTable[16] = { 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3 };\n+   size_t upper;\n+   return (upper = blockSize >> 4) ? 4 + _logTable[upper] : _logTable[blockSize];\n+   //size_t index = 0;\n+   //for (; blockSize; ++index, blockSize >>=1) {}\n+   //return index;\n+   }\n+\n+void\n+PersistentAllocator::freeBlockToIndexedList(Block * block1)\n+   {\n+   checkIntegrity(\"freeVariableSizeBlock start\");\n+   TR_ASSERT_FATAL(block1->next() == NULL, \"Double free detected %p\", block1);\n+   TR_ASSERT(block1->size() > 0, \"Block size is non-positive\");\n+   TR_ASSERT(freeBlocksIndex(block1->size()) == LARGE_BLOCK_LIST_INDEX, \"We must be working on the variable size block list\");\n+\n+   ExtendedBlock *block = reinterpret_cast<ExtendedBlock *>(block1);\n+   block->init(); // reset links to other nodes\n+\n+   size_t index = getInterval(block->size());\n+\n+   ExtendedBlock * blockIterator = reinterpret_cast<ExtendedBlock*>(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n+   if (!blockIterator || blockIterator->size() > block->size())\n+      {\n+      // Add at the beginning of the list\n+      block->setNext(reinterpret_cast<ExtendedBlock*>(_freeBlocks[LARGE_BLOCK_LIST_INDEX]));\n+      _freeBlocks[LARGE_BLOCK_LIST_INDEX] = reinterpret_cast<Block*>(block);\n+      if (block->next())\n+         block->next()->setPrevious(block);\n+      // Adjust the interval bounderies\n+      _startInterval[index] = block;\n+      if (!_endInterval[index])\n+         _endInterval[index] = block;\n+      }\n+   else // This will not be the very first block in the variable size block list\n+      {\n+      // Find position in the list\n+      if (_startInterval[index])\n+         {\n+         // Other blocks are present in this interval\n+         ExtendedBlock *startBlock = _startInterval[index];\n+         ExtendedBlock *blockIterator = startBlock;\n+\n+         ExtendedBlock *prev = NULL;\n+         while (blockIterator && blockIterator->size() < block->size())\n+            {\n+            prev = blockIterator;\n+            blockIterator = blockIterator->next();\n+            }\n+         if (blockIterator)\n+            {\n+            // Insert at or before blockIterator\n+            if (blockIterator->size() == block->size())\n+               {\n+               // Add the block to the list of blocks of same size\n+               block->setNextBlockSameSize(blockIterator->nextBlockSameSize());\n+               blockIterator->setNextBlockSameSize(block);\n+               }\n+            else // Insert before blockIterator\n+               {\n+               block->setNext(blockIterator);\n+               block->setPrevious(blockIterator->previous());\n+               TR_ASSERT(blockIterator->previous(), \"blockIterator->previous() must exist because we already treated the case where we insert at the beginning of the list\");\n+               blockIterator->previous()->setNext(block);\n+               blockIterator->setPrevious(block);\n+               // Adjust the interval bounderies\n+               if (_startInterval[index]->size() > block->size())\n+                  {\n+                  // block becomes the first entry in this interval\n+                  TR_ASSERT(_startInterval[index] == blockIterator, \"blockInterator must be first block in this interval\"); \n+                  _startInterval[index] = block;\n+                  }\n+               else // Insert in the middle or end of interval\n+                  {\n+                  // blockIterator may belong to the next interval in\n+                  // which case _endInterval needs to be changed to block\n+                  if (_endInterval[index]->size() < block->size())\n+                     {\n+                     TR_ASSERT(getInterval(blockIterator->size()) > index, \"blockInterator must be first block in the next interval: index=%zu b->sz=%zu bi->sz=%zu\", index, block->size(), blockIterator->size());\n+                     _endInterval[index] = block;\n+                     }\n+                  }\n+               }\n+            }\n+         else // Insert after 'prev'; block will be the very last entry in the list\n+            {\n+            TR_ASSERT(prev, \"prev must exist\");\n+            TR_ASSERT(!prev->next(), \"this must be the last element in the list\");\n+            block->setPrevious(prev);\n+            block->setNext(NULL);\n+            prev->setNext(block);\n+            _endInterval[index] = block;\n+            }\n+         }\n+      else // There are no other blocks in this interval\n+         {\n+         // Find the closest interval that has a block\n+         // I verified that the block will not be attached at the beginning of the list.\n+         // Thus, there must be a previous interval with some block in it\n+         TR_ASSERT(index > 0, \"Index must be greater than 0\");\n+         for (int i = (int)index - 1; i >= 0; i--)\n+            {\n+            if (_endInterval[i])\n+               {\n+               block->setPrevious(_endInterval[i]);\n+               block->setNext(_endInterval[i]->next());\n+               TR_ASSERT(block->size() > _endInterval[i]->size(), \"wrong sizes previous\");\n+               if (block->next())\n+                  {\n+                  block->next()->setPrevious(block);\n+                  TR_ASSERT(block->size() < block->next()->size(), \"wrong sizes after block->size()=%zu next->size()=%zu\", block->size(), block->next()->size());\n+                  }\n+               _endInterval[i]->setNext(block);\n+               break;\n+               }\n+            }\n+         TR_ASSERT(block->previous(), \"I must have attached my block to the list\");\n+         _startInterval[index] = block;\n+         _endInterval[index] = block;\n+         }\n       }\n+      checkIntegrity(\"freeVariableSizeBlock end\");   \n    }\n \n+void \n+PersistentAllocator::checkIntegrity(const char msg[])\n+   {\n+#ifdef DEBUG", "originalCommit": "599c742bc1c529cd9bc4fd21ab89553e35d079b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTk5NzA0Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505997046", "bodyText": "My initial intent was to delete this function altogether once testing was done.\nThen, I reconsidered: if we ever suspect a bug in this code I may want this code reinstated and since it took me some time to write it, I don't want to spend that time again.\nHowever, I also don't want any additional overhead since this allocation code is called very frequently for JITServer. I would like the compiler to not even call this function and the only I can do that is if the compiler sees an empty function that inlines to nothing. Adding an if statement based on an option will not achieve my goal.\nI could change DEBUG into some other preprocessor variable that is not defined by default.", "author": "mpirvu", "createdAt": "2020-10-16T02:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg5MzAzNw=="}], "type": "inlineReview"}, {"oid": "e9dbcb0257dfbf8681052f75475a53280ab42bb9", "url": "https://github.com/eclipse-openj9/openj9/commit/e9dbcb0257dfbf8681052f75475a53280ab42bb9", "message": "Improve performance of persistent memory allocator\n\nThe persistent memory allocator keeps a single linked list\nfor all freed memory blocks larger than 128 bytes. The list\nis sorted by the block size so every time we need to allocate\nfrom it or add a freed block to it we need to traverse it\nto find the appropriate spot. If this list becomes very large,\nsearching the list for the appropriate spot could consume an\nexcessive amount CPU.\nFor a regular JVM the usage pattern is not conducive to very\nlarge such lists. In contrast, JITServer makes extensive use\nof persistent memory. When one JVMClient ends, all of its\npersistent allocations (at JITServer) are put on this free\nblock list which could reach over 30K elements in size.\nThis makes allocations for a subsequent JVMClient very slow.\nThe solution implemented by this commit is to keep a set\nof indices to nodes whose sizes are power-of-two. This way,\nwhen searching for a free block, we don't have to start from\nthe beginning of the list, but start from a node in the middle\nbased on size.\nSince this change carries a bit of risk, it will be enabled\n(for the time being) only for JITServer\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-10-16T03:38:23Z", "type": "commit"}, {"oid": "e9dbcb0257dfbf8681052f75475a53280ab42bb9", "url": "https://github.com/eclipse-openj9/openj9/commit/e9dbcb0257dfbf8681052f75475a53280ab42bb9", "message": "Improve performance of persistent memory allocator\n\nThe persistent memory allocator keeps a single linked list\nfor all freed memory blocks larger than 128 bytes. The list\nis sorted by the block size so every time we need to allocate\nfrom it or add a freed block to it we need to traverse it\nto find the appropriate spot. If this list becomes very large,\nsearching the list for the appropriate spot could consume an\nexcessive amount CPU.\nFor a regular JVM the usage pattern is not conducive to very\nlarge such lists. In contrast, JITServer makes extensive use\nof persistent memory. When one JVMClient ends, all of its\npersistent allocations (at JITServer) are put on this free\nblock list which could reach over 30K elements in size.\nThis makes allocations for a subsequent JVMClient very slow.\nThe solution implemented by this commit is to keep a set\nof indices to nodes whose sizes are power-of-two. This way,\nwhen searching for a free block, we don't have to start from\nthe beginning of the list, but start from a node in the middle\nbased on size.\nSince this change carries a bit of risk, it will be enabled\n(for the time being) only for JITServer\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>", "committedDate": "2020-10-16T03:38:23Z", "type": "forcePushed"}]}