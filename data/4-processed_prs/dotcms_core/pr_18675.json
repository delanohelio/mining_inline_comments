{"pr_number": 18675, "pr_title": "#18279 adding first changes for the SAML into the dotCMS core", "pr_createdAt": "2020-06-16T18:40:49Z", "pr_url": "https://github.com/dotCMS/core/pull/18675", "timeline": [{"oid": "3753cb3e3a006893a0104f6e42ef314209cbd064", "url": "https://github.com/dotCMS/core/commit/3753cb3e3a006893a0104f6e42ef314209cbd064", "message": "#18279 adding first changes for the SAML into the dotCMS core", "committedDate": "2020-06-16T18:38:53Z", "type": "commit"}, {"oid": "8f710e50ce8f833e1810cacb12389035d44fd4d6", "url": "https://github.com/dotCMS/core/commit/8f710e50ce8f833e1810cacb12389035d44fd4d6", "message": "#18279 adding some progress into the SamlWebInterceptor, work is not done yet and still with errors", "committedDate": "2020-06-22T07:25:37Z", "type": "commit"}, {"oid": "833e0bba04d4b96906b3fa5c6c8468563b34993c", "url": "https://github.com/dotCMS/core/commit/833e0bba04d4b96906b3fa5c6c8468563b34993c", "message": "#18279 more changes and refactoring", "committedDate": "2020-06-22T08:42:13Z", "type": "commit"}, {"oid": "ec8f7aa9c510360397c568e5b3d42bef787e3619", "url": "https://github.com/dotCMS/core/commit/ec8f7aa9c510360397c568e5b3d42bef787e3619", "message": "#18279 Web Interceptor kinda migrated and not errors, probably does not run yet", "committedDate": "2020-06-22T16:44:37Z", "type": "commit"}, {"oid": "ef146d716632097438ee12691eb8e0bfc78271ff", "url": "https://github.com/dotCMS/core/commit/ef146d716632097438ee12691eb8e0bfc78271ff", "message": "#18279 making some progress on the default configuration", "committedDate": "2020-06-22T19:30:28Z", "type": "commit"}, {"oid": "084ce7058909ac01239d693da6e43257c619c4eb", "url": "https://github.com/dotCMS/core/commit/084ce7058909ac01239d693da6e43257c619c4eb", "message": "#18279 adding more support for the configuration, inital values are in progress", "committedDate": "2020-06-22T22:51:02Z", "type": "commit"}, {"oid": "bde1eba8c82a764b99421cb7c6708abb4b229bf8", "url": "https://github.com/dotCMS/core/commit/bde1eba8c82a764b99421cb7c6708abb4b229bf8", "message": "#18279 starting the idp config factory, after a chat with scout the approach is not right, will change later", "committedDate": "2020-06-23T22:43:25Z", "type": "commit"}, {"oid": "f45b29c287bd6221cc43552d0b3b80e3fc8bbc87", "url": "https://github.com/dotCMS/core/commit/f45b29c287bd6221cc43552d0b3b80e3fc8bbc87", "message": "#18279 latest changes for the configuration of SAML bundle OSGI on dotCMS, we are missing the support from apps to retrieve file (for metadata, private key and cert) but it will be mock by now", "committedDate": "2020-06-24T22:14:45Z", "type": "commit"}, {"oid": "1d320b2d45e0dbeb53cab634b88ec433cd23a103", "url": "https://github.com/dotCMS/core/commit/1d320b2d45e0dbeb53cab634b88ec433cd23a103", "message": "#18279 minor changes", "committedDate": "2020-06-25T18:39:01Z", "type": "commit"}, {"oid": "b3311c8f8cb986512c78d19d894faf9b311190d7", "url": "https://github.com/dotCMS/core/commit/b3311c8f8cb986512c78d19d894faf9b311190d7", "message": "#18279 fixing a compilation issue", "committedDate": "2020-06-29T17:32:29Z", "type": "commit"}, {"oid": "bbd0b93c0f8b7689746df16f0b53391fec86d4c6", "url": "https://github.com/dotCMS/core/commit/bbd0b93c0f8b7689746df16f0b53391fec86d4c6", "message": "#18279 adding the osgi bundle dependency", "committedDate": "2020-06-29T17:34:13Z", "type": "commit"}, {"oid": "4a0215140cdecc7bc002c94f237ebcd88754c5ef", "url": "https://github.com/dotCMS/core/commit/4a0215140cdecc7bc002c94f237ebcd88754c5ef", "message": "#18279 more changes to integrate SAML into the core", "committedDate": "2020-06-30T07:38:30Z", "type": "commit"}, {"oid": "9096e1dabf01a634f5ad80d32922dc522cdd5656", "url": "https://github.com/dotCMS/core/commit/9096e1dabf01a634f5ad80d32922dc522cdd5656", "message": "Merge branch 'master' of github.com:dotCMS/core into issue-18279-saml-core", "committedDate": "2020-06-30T07:38:36Z", "type": "commit"}, {"oid": "16dcfe3e7f3539e6e27454155963fd26ae3478b2", "url": "https://github.com/dotCMS/core/commit/16dcfe3e7f3539e6e27454155963fd26ae3478b2", "message": "#18279 good progress on integrate SAML is done as part of the commit, SMAL is being started and the interaction between the bundle and dotcms is right", "committedDate": "2020-07-01T07:58:15Z", "type": "commit"}, {"oid": "38f99287d5208384c3495b5960b42db05b552f64", "url": "https://github.com/dotCMS/core/commit/38f99287d5208384c3495b5960b42db05b552f64", "message": "#18279 latest change to handle post login request from the idp", "committedDate": "2020-07-07T08:44:32Z", "type": "commit"}, {"oid": "8889d4966105ca990aa711b81c1f0766ae8ca960", "url": "https://github.com/dotCMS/core/commit/8889d4966105ca990aa711b81c1f0766ae8ca960", "message": "Merge branch 'master' of github.com:dotCMS/core into issue-18279-saml-core", "committedDate": "2020-07-07T08:46:46Z", "type": "commit"}, {"oid": "d9825cdfb976fa74413be8b6d6253343b7d7f560", "url": "https://github.com/dotCMS/core/commit/d9825cdfb976fa74413be8b6d6253343b7d7f560", "message": "#18279 now saml is alive and working, were successfully connected with google account", "committedDate": "2020-07-09T18:17:29Z", "type": "commit"}, {"oid": "fa9f87b7215768dfa65d9389651088873398f089", "url": "https://github.com/dotCMS/core/commit/fa9f87b7215768dfa65d9389651088873398f089", "message": "Merge branch 'master' of github.com:dotCMS/core into issue-18279-saml-core", "committedDate": "2020-07-10T18:07:05Z", "type": "commit"}, {"oid": "e9829352dff0c9f242dd66c79ecb5d8bcc257e22", "url": "https://github.com/dotCMS/core/commit/e9829352dff0c9f242dd66c79ecb5d8bcc257e22", "message": "#18279 name id was set in a wrong way", "committedDate": "2020-07-11T03:01:12Z", "type": "commit"}, {"oid": "df7e24d5c55e520547cad838eb34d2abf2565881", "url": "https://github.com/dotCMS/core/commit/df7e24d5c55e520547cad838eb34d2abf2565881", "message": "#18279 adding codacy feedback", "committedDate": "2020-07-11T03:24:20Z", "type": "commit"}, {"oid": "c58a2f937cb547c0d456292d44179a74b9426547", "url": "https://github.com/dotCMS/core/commit/c58a2f937cb547c0d456292d44179a74b9426547", "message": "#18279 adding unit test for SAML core", "committedDate": "2020-07-16T21:33:48Z", "type": "commit"}, {"oid": "a0263cf9059d09d69ef9e67e17d80368a5007d77", "url": "https://github.com/dotCMS/core/commit/a0263cf9059d09d69ef9e67e17d80368a5007d77", "message": "#18279 merge done", "committedDate": "2020-07-16T21:37:32Z", "type": "commit"}, {"oid": "d63ea59984a3129a74f4fcaf50476aed58797502", "url": "https://github.com/dotCMS/core/commit/d63ea59984a3129a74f4fcaf50476aed58797502", "message": "#18279 fixing a compilation error", "committedDate": "2020-07-16T21:39:54Z", "type": "commit"}, {"oid": "cef89c85b07674bc62662fc7dcbc9bffabbf158e", "url": "https://github.com/dotCMS/core/commit/cef89c85b07674bc62662fc7dcbc9bffabbf158e", "message": "#18279 adding unit test", "committedDate": "2020-07-17T15:14:30Z", "type": "commit"}, {"oid": "7a28fa62ac1b125da7f719f20616b237027c8ce2", "url": "https://github.com/dotCMS/core/commit/7a28fa62ac1b125da7f719f20616b237027c8ce2", "message": "#18279 adding validators for the SAML configuration", "committedDate": "2020-07-21T07:24:36Z", "type": "commit"}, {"oid": "6c6f3261dea6d0a3777b7611826bf9a9952495d3", "url": "https://github.com/dotCMS/core/commit/6c6f3261dea6d0a3777b7611826bf9a9952495d3", "message": "#18279 changes for validation", "committedDate": "2020-07-22T21:13:19Z", "type": "commit"}, {"oid": "b13ade391fb402ad8d176ebccb4d524d59fc5952", "url": "https://github.com/dotCMS/core/commit/b13ade391fb402ad8d176ebccb4d524d59fc5952", "message": "#18279 merge master done", "committedDate": "2020-07-23T18:13:30Z", "type": "commit"}, {"oid": "270f01b7818fe2c1de0be8d27fcb02913e8d7025", "url": "https://github.com/dotCMS/core/commit/270f01b7818fe2c1de0be8d27fcb02913e8d7025", "message": "#18279 adding latest changes", "committedDate": "2020-07-24T17:39:50Z", "type": "commit"}, {"oid": "48a4be8c7c5aa3841007d52dd67213d6c6e200f2", "url": "https://github.com/dotCMS/core/commit/48a4be8c7c5aa3841007d52dd67213d6c6e200f2", "message": "Merge branch 'master' of github.com:dotCMS/core into issue-18279-saml-core", "committedDate": "2020-07-24T19:33:27Z", "type": "commit"}, {"oid": "8a1afd3ab4551f3d33b5b8288bb8a36d0e6592df", "url": "https://github.com/dotCMS/core/commit/8a1afd3ab4551f3d33b5b8288bb8a36d0e6592df", "message": "#18279 added the new yaml", "committedDate": "2020-07-24T20:45:01Z", "type": "commit"}, {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade", "url": "https://github.com/dotCMS/core/commit/c9ab4a5741e430712727366c1e06afdc7ed62ade", "message": "#18279 minor fix", "committedDate": "2020-07-27T16:34:54Z", "type": "commit"}, {"oid": "b71ab3256ea991e0ff62d0a37872bac71e58875f", "url": "https://github.com/dotCMS/core/commit/b71ab3256ea991e0ff62d0a37872bac71e58875f", "message": "#18279 adding the dotsaml yml to the default config", "committedDate": "2020-07-27T20:29:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwMTM1OQ==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463101359", "bodyText": "Please remove commented dependencies", "author": "nollymar", "createdAt": "2020-07-30T15:57:13Z", "path": "dotCMS/build.gradle", "diffHunk": "@@ -161,10 +161,21 @@ dependencies {\n     felix(group: 'org.apache.tika', name: 'tika-bundle', version: '1.17') {\n         transitive = false\n     }\n+\n     felix group: 'org.slf4j', name: 'slf4j-simple', version: '1.7.25'\n     felix group: 'org.slf4j', name: 'jcl-over-slf4j', version: '1.7.25'\n     felix group: 'com.dotcms.tika', name: 'com.dotcms.tika', version: '0.2'\n \n+  /*  felix group: 'org.opensaml',          name: 'opensaml-core',           version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-saml-api',       version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-security-api',   version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-xmlsec-impl',    version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-xmlsec-api',     version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-security-impl',  version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-messaging-impl', version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-messaging-api',  version: '3.4.5'*/\n+\n+    felix group: 'com.dotcms.samlbundle', name: 'com.dotcms.samlbundle', version: '5.3.3'", "originalCommit": "c9ab4a5741e430712727366c1e06afdc7ed62ade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcxNTExNw==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463715117", "bodyText": "Done", "author": "jdotcms", "createdAt": "2020-07-31T16:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwMTM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwMjEwOQ==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463102109", "bodyText": "same here", "author": "nollymar", "createdAt": "2020-07-30T15:58:18Z", "path": "dotCMS/dependencies.gradle", "diffHunk": "@@ -509,4 +509,8 @@ dependencies {\n     providedCompile \"javax.servlet:javax.servlet-api:3.1.0\"\n     providedCompile fileTree(\"../libs/buildlibs\").include('**/*.jar')\n     providedCompile fileTree(\"../libs/buildlibs\").include('mail.jar')\n+\n+    // todo: remove this when deploy saml bundle on artifactory", "originalCommit": "c9ab4a5741e430712727366c1e06afdc7ed62ade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcxNTQxNw==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463715417", "bodyText": "Done", "author": "jdotcms", "createdAt": "2020-07-31T16:40:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwMjEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwODAyNQ==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463108025", "bodyText": "Needs javadoc", "author": "nollymar", "createdAt": "2020-07-30T16:07:25Z", "path": "dotCMS/src/integration-test/java/com/dotcms/saml/MockIdentityProviderConfigurationFactory.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.dotcms.saml;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyPair;\n+import java.security.cert.Certificate;\n+\n+public class MockIdentityProviderConfigurationFactory implements IdentityProviderConfigurationFactory {", "originalCommit": "c9ab4a5741e430712727366c1e06afdc7ed62ade", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwODY4NQ==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463108685", "bodyText": "The name should be SamlConfigurationServiceTest to follow naming convention", "author": "nollymar", "createdAt": "2020-07-30T16:08:26Z", "path": "dotCMS/src/integration-test/java/com/dotcms/saml/TestSamlConfigurationService.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.dotcms.saml;\n+\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.util.Config;\n+import org.apache.felix.framework.OSGIUtil;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+public class TestSamlConfigurationService {", "originalCommit": "c9ab4a5741e430712727366c1e06afdc7ed62ade", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzExMDU1Mg==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463110552", "bodyText": "Is there any place where these endpoints are documented? For example, it is not clear for me the difference between doLogin and processLogin", "author": "nollymar", "createdAt": "2020-07-30T16:11:19Z", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/DotSamlResource.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.rest.annotation.NoCache;\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.IdentityProviderConfigurationFactory;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.WebKeys;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.server.JSONP;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Path(\"/v1/dotsaml\")\n+public class DotSamlResource implements Serializable {", "originalCommit": "c9ab4a5741e430712727366c1e06afdc7ed62ade", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzExMTM3Nw==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463111377", "bodyText": "Needs javadoc and testing", "author": "nollymar", "createdAt": "2020-07-30T16:12:38Z", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "diffHunk": "@@ -0,0 +1,469 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotcms.saml.SamlName;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.NoSuchUserException;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.business.UserAPI;\n+import com.dotmarketing.business.web.HostWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.cms.factories.PublicEncryptionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.ActivityLogger;\n+import com.dotmarketing.util.AdminLogger;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.RegEX;\n+import com.dotmarketing.util.SecurityLogger;\n+import com.dotmarketing.util.UUIDGenerator;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.User;\n+import org.apache.commons.lang.StringUtils;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static com.dotmarketing.util.UtilMethods.isSet;\n+\n+public class SAMLHelper {", "originalCommit": "c9ab4a5741e430712727366c1e06afdc7ed62ade", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwNjA0Nw==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463106047", "bodyText": "Why Serializable??", "author": "fabrizzio-dotCMS", "createdAt": "2020-07-30T16:04:17Z", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/DotSamlResource.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.rest.annotation.NoCache;\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.IdentityProviderConfigurationFactory;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.WebKeys;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.server.JSONP;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Path(\"/v1/dotsaml\")\n+public class DotSamlResource implements Serializable {\n+\n+\tprivate static final long serialVersionUID = 8015545653539491684L;\n+", "originalCommit": "c9ab4a5741e430712727366c1e06afdc7ed62ade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEyNTIzMw==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463125233", "bodyText": "Javadoc the whole thing.", "author": "fabrizzio-dotCMS", "createdAt": "2020-07-30T16:34:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwNjA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEyNjEzMw==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463126133", "bodyText": "could have used a return here. instead of the noConfig flag", "author": "fabrizzio-dotCMS", "createdAt": "2020-07-30T16:36:10Z", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/DotSamlResource.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.rest.annotation.NoCache;\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.IdentityProviderConfigurationFactory;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.WebKeys;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.server.JSONP;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Path(\"/v1/dotsaml\")\n+public class DotSamlResource implements Serializable {\n+\n+\tprivate static final long serialVersionUID = 8015545653539491684L;\n+\n+\tprivate final SAMLHelper           \t\t\t\t   samlHelper;\n+\tprivate final SamlAuthenticationService            samlAuthenticationService;\n+\tprivate final IdentityProviderConfigurationFactory identityProviderConfigurationFactory;\n+\n+\tpublic static final List<String> dotsamlPathSegments = new ArrayList<String>() {\n+\t\t{\n+\t\t\tadd(\"login\");\n+\t\t\tadd(\"logout\");\n+\t\t\tadd(\"metadata\");\n+\t\t}\n+\t};\n+\n+\n+\tpublic DotSamlResource() {\n+\n+\t\tthis.samlAuthenticationService            = DotSamlProxyFactory.getInstance().samlAuthenticationService();\n+\t\tthis.identityProviderConfigurationFactory = DotSamlProxyFactory.getInstance().identityProviderConfigurationFactory();\n+\t\tthis.samlHelper                           = new SAMLHelper(this.samlAuthenticationService);\n+\t}\n+\n+\t// Login configuration by id\n+\t@GET\n+\t@Path( \"/login/{idpConfigId}\" )\n+\t@JSONP\n+\t@NoCache\n+\t@Produces( { MediaType.APPLICATION_JSON, \"application/javascript\" } )\n+\tpublic Response doLogin(@PathParam( \"idpConfigId\" ) final String idpConfigId,\n+\t\t\t\t\t\t  @Context final HttpServletRequest httpServletRequest,\n+\t\t\t\t\t\t  @Context final HttpServletResponse httpServletResponse) {\n+\n+\t\tIdentityProviderConfiguration identityProviderConfiguration = null;\n+\n+\t\ttry {\n+\t\t\tif (DotSamlProxyFactory.getInstance().isAnyHostConfiguredAsSAML()) {\n+\n+\t\t\t\tidentityProviderConfiguration =\n+\t\t\t\t\t\tthis.identityProviderConfigurationFactory.findIdentityProviderConfigurationById(idpConfigId);\n+\n+\t\t\t\t// If idpConfig is null, means this site does not need SAML processing\n+\t\t\t\tif (identityProviderConfiguration != null && identityProviderConfiguration.isEnabled()) {\n+\n+\t\t\t\t\tLogger.debug(this, () -> \"Processing saml login request for idpConfig id: \" + idpConfigId);\n+\t\t\t\t\tthis.samlHelper.doRequestLoginSecurityLog(httpServletRequest, identityProviderConfiguration);\n+\n+\t\t\t\t\t// This will redirect the user to the IdP Login Page.\n+\t\t\t\t\tthis.samlAuthenticationService.authentication(httpServletRequest,\n+\t\t\t\t\t\t\thttpServletResponse, identityProviderConfiguration);\n+\n+\t\t\t\t\treturn Response.ok().build();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} finally {\n+\n+\t\t\tif (null != identityProviderConfiguration) {\n+\t\t\t\tidentityProviderConfiguration.destroy();\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal String message = \"No idpConfig for idpConfigId: \" + idpConfigId + \". At \" + httpServletRequest.getRequestURI();\n+\t\tLogger.debug( this, ()-> message);\n+\t\tthrow new SamlException(message);\n+\t}\n+\n+\t@POST\n+\t@Path(\"/login/{idpConfigId}\")\n+\t@Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_FORM_URLENCODED})\n+\t@NoCache\n+\tpublic void processLogin(@PathParam(\"idpConfigId\") final String idpConfigId,\n+\t\t\t\t\t  @Context final HttpServletRequest httpServletRequest,\n+\t\t\t\t\t  @Context final HttpServletResponse httpServletResponse) throws IOException {\n+\n+\t\tif (DotSamlProxyFactory.getInstance().isAnyHostConfiguredAsSAML()) {\n+\n+\t\t\tfinal IdentityProviderConfiguration identityProviderConfiguration =\n+\t\t\t\t\tthis.identityProviderConfigurationFactory.findIdentityProviderConfigurationById(idpConfigId);\n+\t\t\ttry {\n+\n+\t\t\t\t// If idpConfig is null, means this site does not need SAML processing\n+\t\t\t\tif (identityProviderConfiguration != null && identityProviderConfiguration.isEnabled()) {\n+\n+\t\t\t\t\tLogger.debug(this, () -> \"Processing saml login request for idpConfig id: \" + idpConfigId);\n+\t\t\t\t\tthis.samlHelper.doRequestLoginSecurityLog(httpServletRequest, identityProviderConfiguration);\n+\n+\t\t\t\t\tfinal HttpSession session = httpServletRequest.getSession();\n+\t\t\t\t\tif (null == session) {\n+\n+\t\t\t\t\t\tthrow new SamlException(\"No session has been created.\");\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// Extracts data from the assertion - if it can't process a DotSamlException is thrown\n+\t\t\t\t\tfinal Attributes attributes = this.samlAuthenticationService.resolveAttributes(httpServletRequest,\n+\t\t\t\t\t\t\thttpServletResponse, identityProviderConfiguration);\n+\n+\t\t\t\t\tif (null == attributes) {\n+\n+\t\t\t\t\t\tthrow new SamlException(\"User cannot be extracted from Assertion!\");\n+\t\t\t\t\t}\n+\t\t\t\t\t// Creates the user object and adds a user if it doesn't already exist\n+\t\t\t\t\tfinal User user = this.samlHelper.resolveUser(attributes, identityProviderConfiguration);\n+\t\t\t\t\tif (null == user) {\n+\n+\t\t\t\t\t\tthrow new SamlException(\"User cannot be extracted from Assertion!\");\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tLogger.debug(this, ()-> \"Resolved user: \" + user);\n+\n+\t\t\t\t\tfinal String samlSessionIndex = attributes.getSessionIndex();\n+\t\t\t\t\tif (null != samlSessionIndex) {\n+\n+\t\t\t\t\t\tLogger.debug(this, ()-> \"SAMLSessionIndex: \" + samlSessionIndex);\n+\t\t\t\t\t\t// Session Attributes used to build logout request\n+\t\t\t\t\t\tfinal String sessionIndexKey = identityProviderConfiguration.getId() + DotSamlConstants.SAML_SESSION_INDEX;\n+\t\t\t\t\t\tfinal String samlNameIdKey   = identityProviderConfiguration.getId() + DotSamlConstants.SAML_NAME_ID;\n+\t\t\t\t\t\tsession.setAttribute(sessionIndexKey, samlSessionIndex);\n+\t\t\t\t\t\tsession.setAttribute(samlNameIdKey,  attributes.getNameID());\n+\t\t\t\t\t\tLogger.debug(this, ()->\"Session index with key: \" + sessionIndexKey + \" and value: \" + session.getAttribute(sessionIndexKey) + \" is already set.\");\n+\t\t\t\t\t\tLogger.debug(this, ()->\"NameID with key: \" + samlNameIdKey + \" and value: \" + session.getAttribute(samlNameIdKey) + \" is already set.\");\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// Add session based user ID to be used on the redirect.\n+\t\t\t\t\tsession.setAttribute(identityProviderConfiguration.getId() + DotSamlConstants.SAML_USER_ID, user.getUserId());\n+\t\t\t\t\tsession.setAttribute(com.liferay.portal.util.WebKeys.USER,    user);\n+\t\t\t\t\tsession.setAttribute(com.liferay.portal.util.WebKeys.USER_ID, user.getUserId());\n+\t\t\t\t\tsession.setAttribute(WebKeys.CMS_USER, user);\n+\n+\t\t\t\t\tString loginPath = (String) session.getAttribute(WebKeys.REDIRECT_AFTER_LOGIN);\n+\t\t\t\t\tif (null == loginPath) {\n+\t\t\t\t\t\t// At this stage we cannot determine whether this was a front\n+\t\t\t\t\t\t// end or back end request since we cannot determine\n+\t\t\t\t\t\t// original request.\n+\t\t\t\t\t\t//\n+\t\t\t\t\t\t// REDIRECT_AFTER_LOGIN should have already been set in relay\n+\t\t\t\t\t\t// request to IdP. 'autoLogin' will check the ORIGINAL_REQUEST\n+\t\t\t\t\t\t// session attribute.\n+\t\t\t\t\t\tloginPath = DotSamlConstants.DEFAULT_LOGIN_PATH;\n+\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\tsession.removeAttribute(WebKeys.REDIRECT_AFTER_LOGIN);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\thttpServletResponse.sendRedirect(loginPath);\n+\t\t\t\t}\n+\t\t\t} finally {\n+\t\t\t\tif (null != identityProviderConfiguration) {\n+\t\t\t\t\tidentityProviderConfiguration.destroy();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal String message = \"No idpConfig for idpConfigId: \" + idpConfigId + \". At \" + httpServletRequest.getRequestURI();\n+\t\tLogger.debug( this, ()-> message);\n+\t\tthrow new SamlException(message);\n+\t}\n+\n+\t// Gets metadata configuration by id\n+\t@GET\n+\t@Path( \"/metadata/{idpConfigId}\" )\n+\t@JSONP\n+\t@NoCache\n+\t@Produces( { MediaType.APPLICATION_JSON, \"application/javascript\" } )\n+\tpublic void metadata( @PathParam( \"idpConfigId\" ) final String idpConfigId,\n+\t\t\t\t\t\t  @Context final HttpServletRequest httpServletRequest,\n+\t\t\t\t\t\t  @Context final HttpServletResponse httpServletResponse ) throws IOException {\n+\n+\t\tboolean noConfig = true;\n+\n+\t\tif (DotSamlProxyFactory.getInstance().isAnyHostConfiguredAsSAML()) {\n+\n+\t\t\tfinal IdentityProviderConfiguration identityProviderConfiguration =\n+\t\t\t\t\tthis.identityProviderConfigurationFactory.findIdentityProviderConfigurationById(idpConfigId);\n+\t\t\ttry {\n+\t\t\t\t// If idpConfig is null, means this site does not need SAML processing\n+\t\t\t\tif (identityProviderConfiguration != null && identityProviderConfiguration.isEnabled()) {\n+\n+\t\t\t\t\tLogger.debug(this, () -> \"Processing saml login request for idpConfig id: \" + idpConfigId);\n+\t\t\t\t\tthis.samlAuthenticationService.renderMetadataXML(httpServletResponse.getWriter(), identityProviderConfiguration);\n+\t\t\t\t\tnoConfig = false;", "originalCommit": "c9ab4a5741e430712727366c1e06afdc7ed62ade", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEzNTY5OQ==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463135699", "bodyText": "is this the intended???? We're adding the same rule to the DotUrlRewriteFilter every time we call getInstance", "author": "fabrizzio-dotCMS", "createdAt": "2020-07-30T16:51:38Z", "path": "dotCMS/src/main/java/com/dotcms/saml/DotSamlProxyFactory.java", "diffHunk": "@@ -0,0 +1,267 @@\n+package com.dotcms.saml;\n+\n+import com.dotcms.auth.providers.saml.v1.DotSamlResource;\n+import com.dotcms.osgi.OSGIConstants;\n+import com.dotcms.security.apps.AppDescriptor;\n+import com.dotcms.security.apps.AppSecretSavedEvent;\n+import com.dotcms.security.apps.AppsAPI;\n+import com.dotcms.security.apps.Secret;\n+import com.dotcms.system.event.local.model.EventSubscriber;\n+import com.dotcms.system.event.local.model.KeyFilterable;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.filters.DotUrlRewriteFilter;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+import org.apache.felix.framework.OSGIUtil;\n+import org.tuckey.web.filters.urlrewrite.NormalRule;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * This is the proxy to provides the object to interact with the Saml Osgi Bundle\n+ *\n+ * @author jsanca\n+ */\n+public class DotSamlProxyFactory implements EventSubscriber<AppSecretSavedEvent>, KeyFilterable {\n+\n+    public static final String SAML_APP_CONFIG_KEY = \"dotsaml-config\";\n+    public static final String PROPERTIES_PATH     = File.separator + \"saml\" + File.separator + \"dotcms-saml-default.properties\";\n+\n+    private static final String ASSETS_PATH   = Config.getStringProperty(\"ASSET_REAL_PATH\",\n+            FileUtil.getRealPath(Config.getStringProperty(\"ASSET_PATH\", \"/assets\")));\n+    private static final String IDP_FILE_PATH = ASSETS_PATH + PROPERTIES_PATH;\n+\n+    private final MessageObserver    messageObserver    = new DotLoggerMessageObserver();\n+    private final AppsAPI            appsAPI            = APILocator.getAppsAPI();\n+    private final IdentityProviderConfigurationFactory identityProviderConfigurationFactory =\n+            new DotIdentityProviderConfigurationFactoryImpl(this.appsAPI, APILocator.getHostAPI());\n+\n+    private SamlServiceBuilder        samlServiceBuilder;\n+    private SamlConfigurationService  samlConfigurationService;\n+    private SamlAuthenticationService samlAuthenticationService;\n+\n+    private static class SingletonHolder {\n+\n+        private static final DotSamlProxyFactory INSTANCE = new DotSamlProxyFactory();\n+    }\n+    /**\n+     * Get the instance.\n+     * @return DotSamlFactory\n+     */\n+    public static DotSamlProxyFactory getInstance() {\n+\n+        addRedirects();", "originalCommit": "c9ab4a5741e430712727366c1e06afdc7ed62ade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc4NTA4NQ==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463785085", "bodyText": "Good catch", "author": "jdotcms", "createdAt": "2020-07-31T19:13:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEzNTY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEzNzYyNA==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463137624", "bodyText": "good.", "author": "fabrizzio-dotCMS", "createdAt": "2020-07-30T16:54:53Z", "path": "dotCMS/src/main/java/com/dotcms/saml/DotSamlProxyFactory.java", "diffHunk": "@@ -0,0 +1,267 @@\n+package com.dotcms.saml;\n+\n+import com.dotcms.auth.providers.saml.v1.DotSamlResource;\n+import com.dotcms.osgi.OSGIConstants;\n+import com.dotcms.security.apps.AppDescriptor;\n+import com.dotcms.security.apps.AppSecretSavedEvent;\n+import com.dotcms.security.apps.AppsAPI;\n+import com.dotcms.security.apps.Secret;\n+import com.dotcms.system.event.local.model.EventSubscriber;\n+import com.dotcms.system.event.local.model.KeyFilterable;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.filters.DotUrlRewriteFilter;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+import org.apache.felix.framework.OSGIUtil;\n+import org.tuckey.web.filters.urlrewrite.NormalRule;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * This is the proxy to provides the object to interact with the Saml Osgi Bundle\n+ *\n+ * @author jsanca\n+ */\n+public class DotSamlProxyFactory implements EventSubscriber<AppSecretSavedEvent>, KeyFilterable {\n+\n+    public static final String SAML_APP_CONFIG_KEY = \"dotsaml-config\";\n+    public static final String PROPERTIES_PATH     = File.separator + \"saml\" + File.separator + \"dotcms-saml-default.properties\";\n+\n+    private static final String ASSETS_PATH   = Config.getStringProperty(\"ASSET_REAL_PATH\",\n+            FileUtil.getRealPath(Config.getStringProperty(\"ASSET_PATH\", \"/assets\")));\n+    private static final String IDP_FILE_PATH = ASSETS_PATH + PROPERTIES_PATH;\n+\n+    private final MessageObserver    messageObserver    = new DotLoggerMessageObserver();\n+    private final AppsAPI            appsAPI            = APILocator.getAppsAPI();\n+    private final IdentityProviderConfigurationFactory identityProviderConfigurationFactory =\n+            new DotIdentityProviderConfigurationFactoryImpl(this.appsAPI, APILocator.getHostAPI());\n+\n+    private SamlServiceBuilder        samlServiceBuilder;\n+    private SamlConfigurationService  samlConfigurationService;\n+    private SamlAuthenticationService samlAuthenticationService;\n+\n+    private static class SingletonHolder {\n+\n+        private static final DotSamlProxyFactory INSTANCE = new DotSamlProxyFactory();\n+    }\n+    /**\n+     * Get the instance.\n+     * @return DotSamlFactory\n+     */\n+    public static DotSamlProxyFactory getInstance() {\n+\n+        addRedirects();\n+        return DotSamlProxyFactory.SingletonHolder.INSTANCE;\n+    } // getInstance.\n+\n+    /**\n+     * Key for the discard non-SAML AppSecretSavedEvent\n+     * @return Comparable\n+     */\n+    @Override\n+    public Comparable getKey() {\n+        return SAML_APP_CONFIG_KEY;\n+    }\n+\n+    /**\n+     * When\n+     * @param event\n+     */\n+    @Override\n+    public void notify(final AppSecretSavedEvent event) {\n+\n+        final  Map<String, Secret> secretMap = event.getAppSecrets().getSecrets();\n+        if (null != secretMap) {\n+\n+            SamlValidator.validateURL(\"sPEndpointHostname\", secretMap.get(\"sPEndpointHostname\").getString(), event.getUserId());\n+            SamlValidator.validateXML(\"idPMetadataFile\",    secretMap.get(\"idPMetadataFile\").getString(),    event.getUserId());\n+        }\n+    }\n+\n+    /**\n+     * Returns the dotCMS implementation of the identity provider config.\n+     * This one basically returns (if exists) the configuration for a idp for a host\n+     * @return IdentityProviderConfigurationFactory\n+     */\n+    public IdentityProviderConfigurationFactory identityProviderConfigurationFactory() {\n+\n+        return identityProviderConfigurationFactory;\n+    }\n+\n+    private static void addRedirects() {\n+\n+        final NormalRule rule = new NormalRule();\n+        rule.setFrom(\"^\\\\/dotsaml\\\\/(\"+String.join(\"|\", DotSamlResource.dotsamlPathSegments)+\")\\\\/(.+)$\");\n+        rule.setToType(\"forward\");\n+        rule.setTo(\"/api/v1/dotsaml/$1/$2\");\n+        rule.setName(\"Dotsaml REST Service Redirect\");\n+        DotUrlRewriteFilter urlRewriteFilter = DotUrlRewriteFilter.getUrlRewriteFilter();\n+        try {\n+            if(urlRewriteFilter != null) {\n+                urlRewriteFilter.addRule(rule);\n+            }else {\n+                throw new Exception();\n+            }\n+        } catch (Exception e) {\n+            Logger.error(DotSamlProxyFactory.class, \"Could not add the Dotsaml REST Service Redirect Rule. Requests to \" +\n+                    \"/dotsaml/login/{UUID} will fail!\");\n+        }\n+    }\n+\n+    private SamlServiceBuilder samlServiceBuilder() {\n+\n+        if (null == this.samlServiceBuilder) {\n+\n+            synchronized (this) {\n+\n+                if (null == this.samlServiceBuilder) {\n+\n+\n+                    try {\n+                        if (!OSGIUtil.getInstance().isInitialized()) {\n+                            Logger.warn(this.getClass(),\n+                                    \"OSGI Framework not initialized, trying to initialize...\");\n+                            OSGIUtil.getInstance().initializeFramework(Config.CONTEXT);\n+                        }\n+                    } catch (Exception e) {\n+\n+                        Logger.error(this.getClass(), \"Unable to initialized OSGI Framework\", e);\n+                    }\n+\n+                    if (OSGIUtil.getInstance().isInitialized()) {\n+                        try {\n+\n+                            this.samlServiceBuilder = OSGIUtil.getInstance().getService(SamlServiceBuilder.class,\n+                                    OSGIConstants.BUNDLE_NAME_DOTCMS_SAML);\n+\n+                            Logger.info(this, \"SAML Osgi Bundle has been started\");\n+                        } catch (Exception e) {\n+                            Logger.error(this.getClass(),\n+                                    String.format(\"Failure retrieving OSGI Service [%s] in bundle [%s]\",\n+                                            SamlServiceBuilder.class,\n+                                            OSGIConstants.BUNDLE_NAME_DOTCMS_SAML), e);\n+                        }\n+                    } else {\n+\n+                        Logger.error(this.getClass(), \"OSGI Framework is not initialized, SAML couldn't start\");\n+                    }\n+                }\n+            }\n+        }\n+\n+        return this.samlServiceBuilder;\n+    }\n+\n+    /**\n+     * Returns the dotCMS implementation of the {@link MessageObserver} for the saml osgi bundle\n+     * @return MessageObserver\n+     */\n+    private MessageObserver messageObserver() {\n+\n+        return this.messageObserver;\n+    }\n+\n+    /**\n+     * Returns the service that helps to retrieve the actual values or default values from the {@link com.dotcms.saml.IdentityProviderConfiguration}\n+     *\n+     * @return SamlConfigurationService\n+     */\n+    public SamlConfigurationService samlConfigurationService() {\n+\n+        if (null == this.samlConfigurationService) {\n+\n+            final SamlServiceBuilder samlServiceBuilder = this.samlServiceBuilder();\n+            if (null != samlServiceBuilder) {\n+\n+                synchronized (this) {\n+\n+                    if (null == this.samlConfigurationService) {\n+\n+                        this.samlConfigurationService = samlServiceBuilder.buildSamlConfigurationService();\n+                        this.samlConfigurationService.initService(\n+                                CollectionsUtils.map(SamlConfigurationService.DOT_SAML_DEFAULT_PROPERTIES_CONTEXT_MAP_KEY, IDP_FILE_PATH));\n+                    }\n+                }\n+            } else {\n+\n+                Logger.error(this.getClass(), \"OSGI Framework may be not initialized, couldn't get the Saml Configuration\");\n+            }\n+        }\n+\n+        return this.samlConfigurationService;\n+    }\n+\n+    /**\n+     * Retrieve the authentication service, this is the proxy with the SAML Osgi bundle and must exists at least one host configurated with SAML in order to init this service.\n+     * @return SamlAuthenticationService\n+     */\n+    public SamlAuthenticationService samlAuthenticationService() {\n+\n+        if (this.isAnyHostConfiguredAsSAML()) {\n+\n+            if (null == this.samlAuthenticationService) {\n+\n+                final SamlServiceBuilder samlServiceBuilder = this.samlServiceBuilder();\n+\n+                if (null != samlServiceBuilder) {\n+\n+                    synchronized (this) {\n+\n+                        if (null == this.samlAuthenticationService) {\n+\n+                            this.samlAuthenticationService =\n+                                    this.samlServiceBuilder.buildAuthenticationService(this.identityProviderConfigurationFactory(),\n+                                            this.messageObserver(), this.samlConfigurationService());\n+\n+                            Logger.info(this, \"Initing SAML Authentication\");\n+                            samlAuthenticationService.initService(Collections.emptyMap());\n+                        }\n+                    }\n+                } else {\n+\n+                    Logger.error(this.getClass(), \"OSGI Framework may be not initialized, couldn't get the Saml Configuration\");\n+                }\n+            }\n+\n+            return this.samlAuthenticationService;\n+        }\n+\n+        throw new SamlException(\"Not any host has been configured as a SAML\");\n+    }\n+\n+    /**\n+     * Returns true is any host is configured as a SAML\n+     * @return boolean\n+     */\n+    public boolean isAnyHostConfiguredAsSAML () {\n+\n+        boolean isAnyConfigured = false;\n+        final User user         = APILocator.systemUser();\n+\n+        final Optional<AppDescriptor> appDescriptorOptional = Try.of(\n+                ()-> this.appsAPI\n+                        .getAppDescriptor(SAML_APP_CONFIG_KEY, user)).getOrElseGet(e-> Optional.empty());\n+        if (appDescriptorOptional.isPresent()) {\n+\n+            final AppDescriptor appDescriptor = appDescriptorOptional.get();\n+\n+            final Map<String, Set<String>>  appKeysByHost = Try.of(()-> this.appsAPI.appKeysByHost())\n+                    .getOrElseGet(e -> Collections.emptyMap());\n+            final Set<String> sitesWithConfigurations     = this.appsAPI\n+                    .filterSitesForAppKey(appDescriptor.getKey(), appKeysByHost.keySet(), user);\n+\n+            isAnyConfigured                   = !sitesWithConfigurations.isEmpty();\n+        }\n+\n+        return isAnyConfigured;\n+    }\n+", "originalCommit": "c9ab4a5741e430712727366c1e06afdc7ed62ade", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2MTExMw==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463161113", "bodyText": "seems like you're assuming you're never gonna get an \"empty\".\nyou should probably make appSecrets var Optional and not assume its present at all times", "author": "fabrizzio-dotCMS", "createdAt": "2020-07-30T17:36:14Z", "path": "dotCMS/src/main/java/com/dotcms/saml/DotIdentityProviderConfigurationImpl.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package com.dotcms.saml;\n+\n+import com.dotcms.security.apps.AppSecrets;\n+import com.dotcms.security.apps.AppsAPI;\n+import com.dotcms.security.apps.Secret;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+\n+import java.util.Optional;\n+\n+/**\n+ * Default implementation to retrieve the configuration from apps\n+ * @author jsanca\n+ */\n+public class DotIdentityProviderConfigurationImpl implements IdentityProviderConfiguration {\n+\n+    private final AppsAPI    appsAPI;\n+    private final Host       host;\n+    private final AppSecrets appSecrets;\n+\n+    public DotIdentityProviderConfigurationImpl(final AppsAPI appsAPI, final Host host) throws DotSecurityException, DotDataException {\n+\n+        this.appsAPI    = appsAPI;\n+        this.host       = host;\n+        this.appSecrets = this.appsAPI.getSecrets(DotSamlProxyFactory.SAML_APP_CONFIG_KEY,\n+                true, host, APILocator.systemUser()).get();", "originalCommit": "c9ab4a5741e430712727366c1e06afdc7ed62ade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc4NDQxMg==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463784412", "bodyText": "before making this, we verify that the secrets exists, so I guess it should be ok", "author": "jdotcms", "createdAt": "2020-07-31T19:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2MTExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE4Mjg5MA==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463182890", "bodyText": "This destroys the secrets. NICE", "author": "fabrizzio-dotCMS", "createdAt": "2020-07-30T18:14:40Z", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/DotSamlResource.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.rest.annotation.NoCache;\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.IdentityProviderConfigurationFactory;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.WebKeys;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.server.JSONP;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Path(\"/v1/dotsaml\")\n+public class DotSamlResource implements Serializable {\n+\n+\tprivate static final long serialVersionUID = 8015545653539491684L;\n+\n+\tprivate final SAMLHelper           \t\t\t\t   samlHelper;\n+\tprivate final SamlAuthenticationService            samlAuthenticationService;\n+\tprivate final IdentityProviderConfigurationFactory identityProviderConfigurationFactory;\n+\n+\tpublic static final List<String> dotsamlPathSegments = new ArrayList<String>() {\n+\t\t{\n+\t\t\tadd(\"login\");\n+\t\t\tadd(\"logout\");\n+\t\t\tadd(\"metadata\");\n+\t\t}\n+\t};\n+\n+\n+\tpublic DotSamlResource() {\n+\n+\t\tthis.samlAuthenticationService            = DotSamlProxyFactory.getInstance().samlAuthenticationService();\n+\t\tthis.identityProviderConfigurationFactory = DotSamlProxyFactory.getInstance().identityProviderConfigurationFactory();\n+\t\tthis.samlHelper                           = new SAMLHelper(this.samlAuthenticationService);\n+\t}\n+\n+\t// Login configuration by id\n+\t@GET\n+\t@Path( \"/login/{idpConfigId}\" )\n+\t@JSONP\n+\t@NoCache\n+\t@Produces( { MediaType.APPLICATION_JSON, \"application/javascript\" } )\n+\tpublic Response doLogin(@PathParam( \"idpConfigId\" ) final String idpConfigId,\n+\t\t\t\t\t\t  @Context final HttpServletRequest httpServletRequest,\n+\t\t\t\t\t\t  @Context final HttpServletResponse httpServletResponse) {\n+\n+\t\tIdentityProviderConfiguration identityProviderConfiguration = null;\n+\n+\t\ttry {\n+\t\t\tif (DotSamlProxyFactory.getInstance().isAnyHostConfiguredAsSAML()) {\n+\n+\t\t\t\tidentityProviderConfiguration =\n+\t\t\t\t\t\tthis.identityProviderConfigurationFactory.findIdentityProviderConfigurationById(idpConfigId);\n+\n+\t\t\t\t// If idpConfig is null, means this site does not need SAML processing\n+\t\t\t\tif (identityProviderConfiguration != null && identityProviderConfiguration.isEnabled()) {\n+\n+\t\t\t\t\tLogger.debug(this, () -> \"Processing saml login request for idpConfig id: \" + idpConfigId);\n+\t\t\t\t\tthis.samlHelper.doRequestLoginSecurityLog(httpServletRequest, identityProviderConfiguration);\n+\n+\t\t\t\t\t// This will redirect the user to the IdP Login Page.\n+\t\t\t\t\tthis.samlAuthenticationService.authentication(httpServletRequest,\n+\t\t\t\t\t\t\thttpServletResponse, identityProviderConfiguration);\n+\n+\t\t\t\t\treturn Response.ok().build();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} finally {\n+\n+\t\t\tif (null != identityProviderConfiguration) {\n+\t\t\t\tidentityProviderConfiguration.destroy();\n+\t\t\t}", "originalCommit": "c9ab4a5741e430712727366c1e06afdc7ed62ade", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE4NzAxMQ==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463187011", "bodyText": "rename to DotSamlException for consistency", "author": "fabrizzio-dotCMS", "createdAt": "2020-07-30T18:22:15Z", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/DotSamlResource.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.rest.annotation.NoCache;\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.IdentityProviderConfigurationFactory;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;", "originalCommit": "c9ab4a5741e430712727366c1e06afdc7ed62ade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc2MjAwNw==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463762007", "bodyText": "Done", "author": "jdotcms", "createdAt": "2020-07-31T18:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE4NzAxMQ=="}], "type": "inlineReview"}, {"oid": "26e42a74fc13f2b6c39e2b3c8ae1072c3612f9d2", "url": "https://github.com/dotCMS/core/commit/26e42a74fc13f2b6c39e2b3c8ae1072c3612f9d2", "message": "Merge branch 'master' of github.com:dotCMS/core into issue-18279-saml-core", "committedDate": "2020-07-30T20:36:56Z", "type": "commit"}, {"oid": "3cbd8a6dea1e4de9b1504e5e45f84f0ac7235624", "url": "https://github.com/dotCMS/core/commit/3cbd8a6dea1e4de9b1504e5e45f84f0ac7235624", "message": "#18279 removing by now the test, will see later", "committedDate": "2020-07-31T15:49:54Z", "type": "commit"}, {"oid": "cfb5a0a6296ad2d6afd4f01bc2310f6bb0718fe5", "url": "https://github.com/dotCMS/core/commit/cfb5a0a6296ad2d6afd4f01bc2310f6bb0718fe5", "message": "Merge branch 'master' of github.com:dotCMS/core into issue-18279-saml-core", "committedDate": "2020-07-31T15:57:04Z", "type": "commit"}, {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "url": "https://github.com/dotCMS/core/commit/0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "message": "#18279 removing commented dependencies on gradle", "committedDate": "2020-07-31T18:03:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzc2MA==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757760", "bodyText": "Codacy found an issue: Substitute calls to size() == 0 (or size() != 0, size() > 0, size() < 1) with calls to isEmpty()", "author": "dev-dotcms", "createdAt": "2020-07-31T18:10:55Z", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "diffHunk": "@@ -0,0 +1,469 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotcms.saml.SamlName;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.NoSuchUserException;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.business.UserAPI;\n+import com.dotmarketing.business.web.HostWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.cms.factories.PublicEncryptionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.ActivityLogger;\n+import com.dotmarketing.util.AdminLogger;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.RegEX;\n+import com.dotmarketing.util.SecurityLogger;\n+import com.dotmarketing.util.UUIDGenerator;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.User;\n+import org.apache.commons.lang.StringUtils;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static com.dotmarketing.util.UtilMethods.isSet;\n+\n+public class SAMLHelper {\n+\n+    private final HostWebAPI hostWebAPI;\n+    private final UserAPI    userAPI;\n+    private final RoleAPI    roleAPI;\n+    private final SamlAuthenticationService  samlAuthenticationService;\n+\n+    public SAMLHelper(final SamlAuthenticationService samlAuthenticationService) {\n+\n+        this.userAPI      = APILocator.getUserAPI();\n+        this.roleAPI      = APILocator.getRoleAPI();\n+        this.hostWebAPI   = WebAPILocator.getHostWebAPI();\n+        this.samlAuthenticationService = samlAuthenticationService;\n+    }\n+\n+    // Gets the attributes from the Assertion, based on the attributes\n+    // see if the user exists return it from the dotCMS records, if does not\n+    // exist then, tries to create it.\n+    // the existing or created user, will be updated the roles if they present\n+    // on the assertion.\n+    protected User resolveUser(final Attributes attributes,\n+                             final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        User user       = null;\n+        User systemUser = null;\n+        try {\n+\n+            Logger.debug(this, ()-> \"Validating user - \" + attributes);\n+\n+            systemUser             = this.userAPI.getSystemUser();\n+            final Company company  = APILocator.getCompanyAPI().getDefaultCompany();\n+            final String  authType = company.getAuthType();\n+            user                   = Company.AUTH_TYPE_ID.equals(authType)?\n+                    this.userAPI.loadUserById(this.samlAuthenticationService.getValue(attributes.getNameID()),      systemUser, false):\n+                    this.userAPI.loadByUserByEmail(this.samlAuthenticationService.getValue(attributes.getNameID()), systemUser, false);\n+        } catch (NoSuchUserException e) {\n+\n+            Logger.error(this, \"No user matches ID '\" +\n+                    this.samlAuthenticationService.getValue(attributes.getNameID()) + \"'. Creating one...\", e);\n+            user = null;\n+        } catch (Exception e) {\n+\n+            Logger.error(this, \"An error occurred when loading user with ID '\" +\n+                    (null != attributes && null != attributes.getNameID()?\n+                    this.samlAuthenticationService.getValue(attributes.getNameID()): \"null\") + \"'\", e);\n+            user = null;\n+        }\n+\n+        // check if the client wants synchronization\n+        final boolean createUserWhenDoesNotExists = DotSamlProxyFactory.getInstance()\n+                .samlConfigurationService().getConfigAsBoolean(identityProviderConfiguration, SamlName.DOT_SAML_ALLOW_USER_SYNCHRONIZATION);\n+        if (createUserWhenDoesNotExists) {\n+\n+            user = null == user?\n+                    this.createNewUser(systemUser,    attributes, identityProviderConfiguration):  // if user does not exists, create a new one.\n+                    this.updateUser(user, systemUser, attributes, identityProviderConfiguration); // update it, since exists\n+\n+            if (user.isActive()) {\n+\n+                this.addRoles(user, attributes, identityProviderConfiguration);\n+            } else {\n+\n+                Logger.info(this, ()-> \"User with ID '\" + this.samlAuthenticationService.getValue(attributes.getNameID()) + \"' is not active. No roles \" +\n+                        \"were added.\");\n+            }\n+        }\n+\n+        return user;\n+    }\n+\n+    protected User updateUser(final User user, final User systemUser,\n+                              final Attributes attributesBean, final IdentityProviderConfiguration identityProviderConfiguration) {\n+        try {\n+\n+            if (DotSamlProxyFactory.getInstance().samlConfigurationService()\n+                    .getConfigAsBoolean(identityProviderConfiguration, SamlName.DOTCMS_SAML_LOGIN_UPDATE_EMAIL)){\n+\n+                user.setEmailAddress(attributesBean.getEmail());\n+            }\n+\n+            user.setFirstName(attributesBean.getFirstName());\n+            user.setLastName(attributesBean.getLastName());\n+\n+            this.userAPI.save(user, systemUser, false);\n+            Logger.debug(this, ()-> \"User with email '\" + attributesBean.getEmail() + \"' has been updated\");\n+        } catch (Exception e) {\n+\n+            Logger.error(this, \"Error updating user with email '\" + attributesBean.getEmail() + \"': \" + e.getMessage()\n+                    , e);\n+            throw new SamlException(e.getMessage());\n+        }\n+\n+        return user;\n+    }\n+\n+    private String getBuildRoles(final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        final String buildRolesStrategy = DotSamlProxyFactory.getInstance()\n+                .samlConfigurationService().getConfigAsString(identityProviderConfiguration, SamlName.DOTCMS_SAML_BUILD_ROLES);\n+\n+        return this.checkBuildRoles(buildRolesStrategy)?\n+                buildRolesStrategy: this.getDefaultBuildRoles(buildRolesStrategy);\n+    }\n+\n+    private String getDefaultBuildRoles(final String invalidBuildRolesStrategy) {\n+        Logger.info(this, ()-> \"The build.roles: \" + invalidBuildRolesStrategy + \", property is invalid. Using the default \" +\n+                \"strategy: \" + DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_ALL_VALUE);\n+\n+        return DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_ALL_VALUE;\n+    }\n+\n+    public boolean checkBuildRoles(final String buildRolesProperty) {\n+\n+        return DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_ALL_VALUE.equalsIgnoreCase( buildRolesProperty )  ||\n+                DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_IDP_VALUE.equalsIgnoreCase( buildRolesProperty ) ||\n+                DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_STATIC_ONLY_VALUE.equalsIgnoreCase( buildRolesProperty ) ||\n+                DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_STATIC_ADD_VALUE.equalsIgnoreCase( buildRolesProperty )  ||\n+                DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_NONE_VALUE.equalsIgnoreCase( buildRolesProperty );\n+    }\n+\n+    private void addRoles(final User user, final Attributes attributesBean, final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        final String buildRolesStrategy = this.getBuildRoles(identityProviderConfiguration);\n+\n+        Logger.debug(this, ()-> \"Using the build roles Strategy: \" + buildRolesStrategy);\n+\n+        if (!DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_NONE_VALUE.equalsIgnoreCase(buildRolesStrategy)) {\n+            try {\n+                // remove previous roles\n+                if (!DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_STATIC_ADD_VALUE.equalsIgnoreCase(buildRolesStrategy)) {\n+\n+                    Logger.debug(this, ()-> \"Removing ALL existing roles from user '\" + user.getUserId() + \"'...\");\n+                    this.roleAPI.removeAllRolesFromUser(user);\n+                } else {\n+\n+                    Logger.debug(this, ()-> \"The buildRoles strategy is: 'staticadd'. It won't remove any existing dotCMS role\");\n+                }\n+\n+                this.handleRoles(user, attributesBean, identityProviderConfiguration, buildRolesStrategy);\n+            } catch (DotDataException e) {\n+\n+                Logger.error(this, \"Error adding roles to user '\" + user.getUserId() + \"': \" + e.getMessage(), e);\n+                throw new SamlException(e.getMessage());\n+            }\n+        } else {\n+\n+            Logger.info(this, ()->\"The build roles strategy is 'none'. No user roles were added/changed.\");\n+        }\n+    }\n+\n+    private void handleRoles(final User user, final Attributes attributesBean,\n+                             final IdentityProviderConfiguration identityProviderConfiguration,\n+                             final String buildRolesStrategy) throws DotDataException {\n+\n+        this.addRolesFromIDP(user, attributesBean, identityProviderConfiguration, buildRolesStrategy);\n+\n+        // Add SAML User role\n+        this.addRole(user, DotSamlConstants.DOTCMS_SAML_USER_ROLE, true, true);\n+        Logger.debug(this, ()->\"Default SAML User role has been assigned\");\n+\n+        // the only strategy that does not include the saml user role is the \"idp\"\n+        if (!DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_IDP_VALUE.equalsIgnoreCase(buildRolesStrategy)) {\n+            // Add DOTCMS_SAML_OPTIONAL_USER_ROLE\n+            if (DotSamlProxyFactory.getInstance().samlConfigurationService().getConfigAsString(identityProviderConfiguration,\n+                    SamlName.DOTCMS_SAML_OPTIONAL_USER_ROLE) != null) {\n+\n+                this.addRole(user, DotSamlProxyFactory.getInstance().samlConfigurationService().getConfigAsString(identityProviderConfiguration,\n+                        SamlName.DOTCMS_SAML_OPTIONAL_USER_ROLE), false, false);\n+                Logger.debug(this, ()-> \"Optional user role: \" +\n+                        DotSamlProxyFactory.getInstance().samlConfigurationService().getConfigAsString(identityProviderConfiguration,\n+                                SamlName.DOTCMS_SAML_OPTIONAL_USER_ROLE) + \" has been assigned\");\n+            }\n+        } else {\n+\n+            Logger.info(this, \"The build roles strategy is 'idp'. No saml_user_role has been added\");\n+        }\n+    }\n+\n+    private boolean isValidRole(final String role, final String[] rolePatterns) {\n+\n+        boolean isValidRole = false;\n+\n+        if (null != rolePatterns) {\n+            for (final String rolePattern : rolePatterns) {\n+                Logger.debug(this, ()-> \"Valid Role: \" + role + \", pattern: \" + rolePattern);\n+                isValidRole |= this.match(role, rolePattern);\n+            }\n+        } else {\n+            // if not pattern, role is valid.\n+            isValidRole = true;\n+        }\n+\n+        return isValidRole;\n+    }\n+\n+    private boolean match(final String role, final String rolePattern) {\n+        String uftRole = null;\n+\n+        try {\n+\n+            uftRole = URLDecoder.decode(role, \"UTF-8\");\n+        } catch (UnsupportedEncodingException e) {\n+            uftRole = role;\n+        }\n+\n+        return RegEX.contains(uftRole, rolePattern);\n+    }\n+\n+    private void addRolesFromIDP(final User user, final Attributes attributesBean, final IdentityProviderConfiguration identityProviderConfiguration,\n+                                 final String buildRolesStrategy) throws DotDataException {\n+\n+        final boolean includeIDPRoles = DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_ALL_VALUE.equalsIgnoreCase(buildRolesStrategy)\n+                || DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_IDP_VALUE.equalsIgnoreCase(buildRolesStrategy);\n+\n+        Logger.debug(this, ()-> \"Including roles from IdP '\" + includeIDPRoles + \"' for the build roles Strategy: \" + buildRolesStrategy);\n+\n+        if (includeIDPRoles && attributesBean.isAddRoles() && null != attributesBean.getRoles()) {\n+\n+            final List<String> roleList = this.samlAuthenticationService.getValues(attributesBean.getRoles());\n+            if (null != roleList && roleList.size() > 0) {", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzc2Nw==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757767", "bodyText": "Codacy found an issue: Consider using varargs for methods or constructors which take an array the last parameter.", "author": "dev-dotcms", "createdAt": "2020-07-31T18:10:56Z", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "diffHunk": "@@ -0,0 +1,469 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotcms.saml.SamlName;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.NoSuchUserException;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.business.UserAPI;\n+import com.dotmarketing.business.web.HostWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.cms.factories.PublicEncryptionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.ActivityLogger;\n+import com.dotmarketing.util.AdminLogger;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.RegEX;\n+import com.dotmarketing.util.SecurityLogger;\n+import com.dotmarketing.util.UUIDGenerator;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.User;\n+import org.apache.commons.lang.StringUtils;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static com.dotmarketing.util.UtilMethods.isSet;\n+\n+public class SAMLHelper {\n+\n+    private final HostWebAPI hostWebAPI;\n+    private final UserAPI    userAPI;\n+    private final RoleAPI    roleAPI;\n+    private final SamlAuthenticationService  samlAuthenticationService;\n+\n+    public SAMLHelper(final SamlAuthenticationService samlAuthenticationService) {\n+\n+        this.userAPI      = APILocator.getUserAPI();\n+        this.roleAPI      = APILocator.getRoleAPI();\n+        this.hostWebAPI   = WebAPILocator.getHostWebAPI();\n+        this.samlAuthenticationService = samlAuthenticationService;\n+    }\n+\n+    // Gets the attributes from the Assertion, based on the attributes\n+    // see if the user exists return it from the dotCMS records, if does not\n+    // exist then, tries to create it.\n+    // the existing or created user, will be updated the roles if they present\n+    // on the assertion.\n+    protected User resolveUser(final Attributes attributes,\n+                             final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        User user       = null;\n+        User systemUser = null;\n+        try {\n+\n+            Logger.debug(this, ()-> \"Validating user - \" + attributes);\n+\n+            systemUser             = this.userAPI.getSystemUser();\n+            final Company company  = APILocator.getCompanyAPI().getDefaultCompany();\n+            final String  authType = company.getAuthType();\n+            user                   = Company.AUTH_TYPE_ID.equals(authType)?\n+                    this.userAPI.loadUserById(this.samlAuthenticationService.getValue(attributes.getNameID()),      systemUser, false):\n+                    this.userAPI.loadByUserByEmail(this.samlAuthenticationService.getValue(attributes.getNameID()), systemUser, false);\n+        } catch (NoSuchUserException e) {\n+\n+            Logger.error(this, \"No user matches ID '\" +\n+                    this.samlAuthenticationService.getValue(attributes.getNameID()) + \"'. Creating one...\", e);\n+            user = null;\n+        } catch (Exception e) {\n+\n+            Logger.error(this, \"An error occurred when loading user with ID '\" +\n+                    (null != attributes && null != attributes.getNameID()?\n+                    this.samlAuthenticationService.getValue(attributes.getNameID()): \"null\") + \"'\", e);\n+            user = null;\n+        }\n+\n+        // check if the client wants synchronization\n+        final boolean createUserWhenDoesNotExists = DotSamlProxyFactory.getInstance()\n+                .samlConfigurationService().getConfigAsBoolean(identityProviderConfiguration, SamlName.DOT_SAML_ALLOW_USER_SYNCHRONIZATION);\n+        if (createUserWhenDoesNotExists) {\n+\n+            user = null == user?\n+                    this.createNewUser(systemUser,    attributes, identityProviderConfiguration):  // if user does not exists, create a new one.\n+                    this.updateUser(user, systemUser, attributes, identityProviderConfiguration); // update it, since exists\n+\n+            if (user.isActive()) {\n+\n+                this.addRoles(user, attributes, identityProviderConfiguration);\n+            } else {\n+\n+                Logger.info(this, ()-> \"User with ID '\" + this.samlAuthenticationService.getValue(attributes.getNameID()) + \"' is not active. No roles \" +\n+                        \"were added.\");\n+            }\n+        }\n+\n+        return user;\n+    }\n+\n+    protected User updateUser(final User user, final User systemUser,\n+                              final Attributes attributesBean, final IdentityProviderConfiguration identityProviderConfiguration) {\n+        try {\n+\n+            if (DotSamlProxyFactory.getInstance().samlConfigurationService()\n+                    .getConfigAsBoolean(identityProviderConfiguration, SamlName.DOTCMS_SAML_LOGIN_UPDATE_EMAIL)){\n+\n+                user.setEmailAddress(attributesBean.getEmail());\n+            }\n+\n+            user.setFirstName(attributesBean.getFirstName());\n+            user.setLastName(attributesBean.getLastName());\n+\n+            this.userAPI.save(user, systemUser, false);\n+            Logger.debug(this, ()-> \"User with email '\" + attributesBean.getEmail() + \"' has been updated\");\n+        } catch (Exception e) {\n+\n+            Logger.error(this, \"Error updating user with email '\" + attributesBean.getEmail() + \"': \" + e.getMessage()\n+                    , e);\n+            throw new SamlException(e.getMessage());\n+        }\n+\n+        return user;\n+    }\n+\n+    private String getBuildRoles(final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        final String buildRolesStrategy = DotSamlProxyFactory.getInstance()\n+                .samlConfigurationService().getConfigAsString(identityProviderConfiguration, SamlName.DOTCMS_SAML_BUILD_ROLES);\n+\n+        return this.checkBuildRoles(buildRolesStrategy)?\n+                buildRolesStrategy: this.getDefaultBuildRoles(buildRolesStrategy);\n+    }\n+\n+    private String getDefaultBuildRoles(final String invalidBuildRolesStrategy) {\n+        Logger.info(this, ()-> \"The build.roles: \" + invalidBuildRolesStrategy + \", property is invalid. Using the default \" +\n+                \"strategy: \" + DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_ALL_VALUE);\n+\n+        return DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_ALL_VALUE;\n+    }\n+\n+    public boolean checkBuildRoles(final String buildRolesProperty) {\n+\n+        return DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_ALL_VALUE.equalsIgnoreCase( buildRolesProperty )  ||\n+                DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_IDP_VALUE.equalsIgnoreCase( buildRolesProperty ) ||\n+                DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_STATIC_ONLY_VALUE.equalsIgnoreCase( buildRolesProperty ) ||\n+                DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_STATIC_ADD_VALUE.equalsIgnoreCase( buildRolesProperty )  ||\n+                DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_NONE_VALUE.equalsIgnoreCase( buildRolesProperty );\n+    }\n+\n+    private void addRoles(final User user, final Attributes attributesBean, final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        final String buildRolesStrategy = this.getBuildRoles(identityProviderConfiguration);\n+\n+        Logger.debug(this, ()-> \"Using the build roles Strategy: \" + buildRolesStrategy);\n+\n+        if (!DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_NONE_VALUE.equalsIgnoreCase(buildRolesStrategy)) {\n+            try {\n+                // remove previous roles\n+                if (!DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_STATIC_ADD_VALUE.equalsIgnoreCase(buildRolesStrategy)) {\n+\n+                    Logger.debug(this, ()-> \"Removing ALL existing roles from user '\" + user.getUserId() + \"'...\");\n+                    this.roleAPI.removeAllRolesFromUser(user);\n+                } else {\n+\n+                    Logger.debug(this, ()-> \"The buildRoles strategy is: 'staticadd'. It won't remove any existing dotCMS role\");\n+                }\n+\n+                this.handleRoles(user, attributesBean, identityProviderConfiguration, buildRolesStrategy);\n+            } catch (DotDataException e) {\n+\n+                Logger.error(this, \"Error adding roles to user '\" + user.getUserId() + \"': \" + e.getMessage(), e);\n+                throw new SamlException(e.getMessage());\n+            }\n+        } else {\n+\n+            Logger.info(this, ()->\"The build roles strategy is 'none'. No user roles were added/changed.\");\n+        }\n+    }\n+\n+    private void handleRoles(final User user, final Attributes attributesBean,\n+                             final IdentityProviderConfiguration identityProviderConfiguration,\n+                             final String buildRolesStrategy) throws DotDataException {\n+\n+        this.addRolesFromIDP(user, attributesBean, identityProviderConfiguration, buildRolesStrategy);\n+\n+        // Add SAML User role\n+        this.addRole(user, DotSamlConstants.DOTCMS_SAML_USER_ROLE, true, true);\n+        Logger.debug(this, ()->\"Default SAML User role has been assigned\");\n+\n+        // the only strategy that does not include the saml user role is the \"idp\"\n+        if (!DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_IDP_VALUE.equalsIgnoreCase(buildRolesStrategy)) {\n+            // Add DOTCMS_SAML_OPTIONAL_USER_ROLE\n+            if (DotSamlProxyFactory.getInstance().samlConfigurationService().getConfigAsString(identityProviderConfiguration,\n+                    SamlName.DOTCMS_SAML_OPTIONAL_USER_ROLE) != null) {\n+\n+                this.addRole(user, DotSamlProxyFactory.getInstance().samlConfigurationService().getConfigAsString(identityProviderConfiguration,\n+                        SamlName.DOTCMS_SAML_OPTIONAL_USER_ROLE), false, false);\n+                Logger.debug(this, ()-> \"Optional user role: \" +\n+                        DotSamlProxyFactory.getInstance().samlConfigurationService().getConfigAsString(identityProviderConfiguration,\n+                                SamlName.DOTCMS_SAML_OPTIONAL_USER_ROLE) + \" has been assigned\");\n+            }\n+        } else {\n+\n+            Logger.info(this, \"The build roles strategy is 'idp'. No saml_user_role has been added\");\n+        }\n+    }\n+\n+    private boolean isValidRole(final String role, final String[] rolePatterns) {", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzc3Ng==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757776", "bodyText": "Codacy found an issue: Field lastName has the same name as a method", "author": "dev-dotcms", "createdAt": "2020-07-31T18:10:57Z", "path": "dotCMS/src/main/java/com/dotcms/saml/Attributes.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.dotcms.saml;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Encapsulates the attributes retrieve from the Saml Assertion\n+ *\n+ * @author jsanca\n+ */\n+public class Attributes implements Serializable {\n+\n+\tprivate static final long serialVersionUID = 1836313856887837731L;\n+\n+\t// user email from opensaml\n+\tprivate final String email;\n+\n+\t// user last name from opensaml\n+\tprivate final String lastName;\n+\n+\t// user first name from opensaml\n+\tprivate final String firstName;\n+\n+\t// true if opensaml returned roles\n+\tprivate final boolean addRoles;\n+\n+\t// Saml object with the roles info.\n+\tprivate final Object roles;\n+\n+\t// Saml object with the NameID.\n+\tprivate final Object nameID;\n+\n+\t// SAML Session Index\n+\tprivate final String sessionIndex;\n+\n+\tprivate Attributes(final Builder builder) {\n+\n+\t\tthis.email        = builder.email;\n+\t\tthis.lastName     = builder.lastName;\n+\t\tthis.firstName    = builder.firstName;\n+\t\tthis.addRoles     = builder.addRoles;\n+\t\tthis.roles        = builder.roles;\n+\t\tthis.nameID       = builder.nameID;\n+\t\tthis.sessionIndex = builder.sessionIndex;\n+\t}\n+\n+\tpublic String getEmail()\n+\t{\n+\t\treturn email;\n+\t}\n+\n+\tpublic String getLastName()\n+\t{\n+\t\treturn lastName;\n+\t}\n+\n+\tpublic String getFirstName()\n+\t{\n+\t\treturn firstName;\n+\t}\n+\n+\tpublic boolean isAddRoles()\n+\t{\n+\t\treturn addRoles;\n+\t}\n+\n+\tpublic Object getRoles()\n+\t{\n+\t\treturn roles;\n+\t}\n+\n+\tpublic Object getNameID()\n+\t{\n+\t\treturn nameID;\n+\t}\n+\n+\tpublic String getSessionIndex() {\n+\t\treturn sessionIndex;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"AttributesBean{\" + \"nameID='\" + nameID + '\\'' + \", email='\" + email + '\\'' + \", lastName='\" + lastName + '\\''\n+\t\t\t\t+ \", firstName='\" + firstName + '\\'' + \", addRoles=\" + addRoles + \", roles=\" + roles + '}';\n+\t}\n+\n+\tpublic static final class Builder {\n+\t\tString email     = \"\";\n+\t\tString lastName  = \"\";", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzc4Nw==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757787", "bodyText": "Codacy found an issue: Field nameID has the same name as a method", "author": "dev-dotcms", "createdAt": "2020-07-31T18:10:58Z", "path": "dotCMS/src/main/java/com/dotcms/saml/Attributes.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.dotcms.saml;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Encapsulates the attributes retrieve from the Saml Assertion\n+ *\n+ * @author jsanca\n+ */\n+public class Attributes implements Serializable {\n+\n+\tprivate static final long serialVersionUID = 1836313856887837731L;\n+\n+\t// user email from opensaml\n+\tprivate final String email;\n+\n+\t// user last name from opensaml\n+\tprivate final String lastName;\n+\n+\t// user first name from opensaml\n+\tprivate final String firstName;\n+\n+\t// true if opensaml returned roles\n+\tprivate final boolean addRoles;\n+\n+\t// Saml object with the roles info.\n+\tprivate final Object roles;\n+\n+\t// Saml object with the NameID.\n+\tprivate final Object nameID;\n+\n+\t// SAML Session Index\n+\tprivate final String sessionIndex;\n+\n+\tprivate Attributes(final Builder builder) {\n+\n+\t\tthis.email        = builder.email;\n+\t\tthis.lastName     = builder.lastName;\n+\t\tthis.firstName    = builder.firstName;\n+\t\tthis.addRoles     = builder.addRoles;\n+\t\tthis.roles        = builder.roles;\n+\t\tthis.nameID       = builder.nameID;\n+\t\tthis.sessionIndex = builder.sessionIndex;\n+\t}\n+\n+\tpublic String getEmail()\n+\t{\n+\t\treturn email;\n+\t}\n+\n+\tpublic String getLastName()\n+\t{\n+\t\treturn lastName;\n+\t}\n+\n+\tpublic String getFirstName()\n+\t{\n+\t\treturn firstName;\n+\t}\n+\n+\tpublic boolean isAddRoles()\n+\t{\n+\t\treturn addRoles;\n+\t}\n+\n+\tpublic Object getRoles()\n+\t{\n+\t\treturn roles;\n+\t}\n+\n+\tpublic Object getNameID()\n+\t{\n+\t\treturn nameID;\n+\t}\n+\n+\tpublic String getSessionIndex() {\n+\t\treturn sessionIndex;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"AttributesBean{\" + \"nameID='\" + nameID + '\\'' + \", email='\" + email + '\\'' + \", lastName='\" + lastName + '\\''\n+\t\t\t\t+ \", firstName='\" + firstName + '\\'' + \", addRoles=\" + addRoles + \", roles=\" + roles + '}';\n+\t}\n+\n+\tpublic static final class Builder {\n+\t\tString email     = \"\";\n+\t\tString lastName  = \"\";\n+\t\tString firstName = \"\";\n+\t\tboolean addRoles = false;\n+\t\tObject roles     = null;\n+\t\tObject nameID    = null;", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzc5Mw==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757793", "bodyText": "Codacy found an issue: Return an empty array rather than null.", "author": "dev-dotcms", "createdAt": "2020-07-31T18:10:59Z", "path": "dotCMS/src/main/java/com/dotcms/saml/DotAbstractSamlConfigurationServiceImpl.java", "diffHunk": "@@ -0,0 +1,254 @@\n+package com.dotcms.saml;\n+\n+import com.dotmarketing.util.Logger;\n+import org.apache.commons.lang.StringUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Supplier;\n+\n+/**\n+ * This service will retrieve information form the idp config, but also if the value is not set will provide the default value for the saml name.\n+ * It has different implementation for several kinds of values\n+ * @author jsanca\n+ */\n+public abstract class DotAbstractSamlConfigurationServiceImpl implements SamlConfigurationService {\n+\n+    private static final String NULL = \"NULL\";\n+    private static final String UNABLE_TO_READ_FILE = \"File does not exist or unable to read : \";\n+    private static final String NOT_FOUND_ERROR = \"Property Name not Found: \";\n+\n+    private AtomicBoolean init = new AtomicBoolean(false);\n+    private final Map<String, String> defaultProperties = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public void initService(final Map<String, Object> contextMap) {\n+\n+        if (!this.init.get()) {\n+\n+            final Map<String, String> samlInitialMap = this.createInitialMap();\n+            for (final Map.Entry<String, String> entry : samlInitialMap.entrySet()) {\n+\n+                this.defaultProperties.put(entry.getKey(), null == entry.getValue()?NULL:entry.getValue());\n+            }\n+\n+            this.internalInit(contextMap);\n+        }\n+    }\n+\n+    private synchronized void internalInit(final Map<String, Object> contextMap) {\n+\n+        final String dotSamlDefaultPropertiesValue = (String)contextMap.get(DOT_SAML_DEFAULT_PROPERTIES_CONTEXT_MAP_KEY);\n+\n+        if (null == dotSamlDefaultPropertiesValue) {\n+\n+            Logger.warn(this, DOT_SAML_DEFAULT_PROPERTIES_CONTEXT_MAP_KEY + \" must be set on the argument context map\");\n+        } else {\n+\n+            final File dotSamlDefaultPropertiesFile = new File(dotSamlDefaultPropertiesValue);\n+\n+            if (!dotSamlDefaultPropertiesFile.exists() || !dotSamlDefaultPropertiesFile.canRead()) {\n+\n+                Logger.warn(this, \"The \" + dotSamlDefaultPropertiesValue + \" does not exists or can not read\");\n+            } else {\n+\n+                final Properties properties = new Properties();\n+\n+                try (InputStream input = Files.newInputStream(dotSamlDefaultPropertiesFile.toPath())) {\n+\n+                    properties.load(input);\n+                } catch (IOException ex) {\n+                    // Since this is optional, it is valid to not have the file.\n+                    // Log and go on.\n+                    Logger.warn(this, UNABLE_TO_READ_FILE + dotSamlDefaultPropertiesValue);\n+\n+                }\n+\n+                properties.forEach((key, value) -> {\n+\n+                    final SamlName samlName = SamlName.findProperty((String)key);\n+                    if (null != samlName) {\n+\n+                        this.defaultProperties.put(samlName.getPropertyName(), (String)value);\n+                    }\n+                });\n+\n+                this.init.set(true);\n+            }\n+        }\n+    }\n+\n+\n+    @Override\n+    public String getConfigAsString(final IdentityProviderConfiguration identityProviderConfiguration, final SamlName samlName) {\n+\n+        try {\n+\n+            final String value = identityProviderConfiguration.containsOptionalProperty(samlName.getPropertyName())?\n+                    (String) identityProviderConfiguration.getOptionalProperty(samlName.getPropertyName()):\n+                    this.getDefaultStringParameter(samlName);\n+\n+            Logger.debug(this,\n+                    ()-> \"Found \" + samlName.getPropertyName() + \" : \" + ((value == null) ? \"null\" : value));\n+\n+            return value;\n+        } catch (Exception e) {\n+\n+            Logger.warn(this, ()-> \"Cast exception on \" + samlName.getPropertyName()\n+                    + \" property. idpConfigId: \" + identityProviderConfiguration.getId());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public String getConfigAsString(final IdentityProviderConfiguration identityProviderConfiguration,\n+                                    final SamlName samlName, final Supplier<String> defaultValueSupplier) {\n+\n+        try {\n+\n+            final String value = identityProviderConfiguration.containsOptionalProperty(samlName.getPropertyName())?\n+                    (String) identityProviderConfiguration.getOptionalProperty(samlName.getPropertyName()):\n+                    defaultValueSupplier.get();\n+\n+            Logger.debug(this,\n+                    ()-> \"Found \" + samlName.getPropertyName() + \" : \" + ((value == null) ? \"null\" : value));\n+\n+            return value;\n+        } catch (Exception e) {\n+\n+            Logger.warn(this, ()-> \"Cast exception on \" + samlName.getPropertyName()\n+                    + \" property. idpConfigId: \" + identityProviderConfiguration.getId());\n+        }\n+\n+        return defaultValueSupplier.get();\n+    }\n+\n+    @Override\n+    public Boolean getConfigAsBoolean(final IdentityProviderConfiguration identityProviderConfiguration, final SamlName samlName) {\n+\n+        try {\n+\n+            final Boolean value =  identityProviderConfiguration.containsOptionalProperty(samlName.getPropertyName())?\n+                Boolean.parseBoolean((String) identityProviderConfiguration.getOptionalProperty(samlName.getPropertyName())):\n+                this.getDefaultBooleanParameter(samlName);\n+\n+            Logger.debug(this,\n+                    ()->\"Found \" + samlName.getPropertyName() + \" : \" + ((value == null) ? \"null\" : value));\n+\n+            return value;\n+        } catch (Exception e) {\n+\n+            Logger.warn(this, \"Cast exception on \" + samlName.getPropertyName()\n+                    + \" property. idpConfigId: \" + identityProviderConfiguration.getId());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public String[] getConfigAsArrayString(final IdentityProviderConfiguration identityProviderConfiguration, final SamlName samlName) {", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzgwMA==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757800", "bodyText": "Codacy found an issue: Document empty method body", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:00Z", "path": "dotCMS/src/integration-test/java/com/dotcms/saml/MockIdentityProviderConfigurationFactory.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.dotcms.saml;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyPair;\n+import java.security.cert.Certificate;\n+\n+public class MockIdentityProviderConfigurationFactory implements IdentityProviderConfigurationFactory {\n+\n+\n+    @Override\n+    public IdentityProviderConfiguration findIdentityProviderConfigurationById(String s) {\n+        return new IdentityProviderConfiguration() {\n+            @Override\n+            public boolean isEnabled() {\n+                return true;\n+            }\n+\n+            @Override\n+            public String getSpIssuerURL() {\n+                return \"https://test.com\";\n+            }\n+\n+            @Override\n+            public String getIdpName() {\n+                return \"test.com/sp\";\n+            }\n+\n+            @Override\n+            public String getId() {\n+                return \"123\";\n+            }\n+\n+            @Override\n+            public String getSpEndpointHostname() {\n+                return \"test.com\";\n+            }\n+\n+            @Override\n+            public String getSignatureValidationType() {\n+                return \"signature\";\n+            }\n+\n+            @Override\n+            public char[] getIdPMetadataFile() {\n+\n+                return new char[0];\n+            }\n+\n+            @Override\n+            public char[] getPublicCert() {\n+                return new char[0];\n+            }\n+\n+            @Override\n+            public char[] getPrivateKey() {\n+                return new char[0];\n+            }\n+\n+            @Override\n+            public Object getOptionalProperty(String s) {\n+                return null;\n+            }\n+\n+            @Override\n+            public boolean containsOptionalProperty(String s) {\n+                return false;\n+            }\n+\n+            @Override\n+            public void destroy() {", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzgwNw==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757807", "bodyText": "Codacy found an issue: Avoid unused imports such as 'java.io.IOException'", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:01Z", "path": "dotCMS/src/integration-test/java/com/dotcms/saml/MockIdentityProviderConfigurationFactory.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.dotcms.saml;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzgxMA==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757810", "bodyText": "Codacy found an issue: Use equals() to compare object references.", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:02Z", "path": "dotCMS/src/main/java/com/dotcms/saml/DotAbstractSamlConfigurationServiceImpl.java", "diffHunk": "@@ -0,0 +1,254 @@\n+package com.dotcms.saml;\n+\n+import com.dotmarketing.util.Logger;\n+import org.apache.commons.lang.StringUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Supplier;\n+\n+/**\n+ * This service will retrieve information form the idp config, but also if the value is not set will provide the default value for the saml name.\n+ * It has different implementation for several kinds of values\n+ * @author jsanca\n+ */\n+public abstract class DotAbstractSamlConfigurationServiceImpl implements SamlConfigurationService {\n+\n+    private static final String NULL = \"NULL\";\n+    private static final String UNABLE_TO_READ_FILE = \"File does not exist or unable to read : \";\n+    private static final String NOT_FOUND_ERROR = \"Property Name not Found: \";\n+\n+    private AtomicBoolean init = new AtomicBoolean(false);\n+    private final Map<String, String> defaultProperties = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public void initService(final Map<String, Object> contextMap) {\n+\n+        if (!this.init.get()) {\n+\n+            final Map<String, String> samlInitialMap = this.createInitialMap();\n+            for (final Map.Entry<String, String> entry : samlInitialMap.entrySet()) {\n+\n+                this.defaultProperties.put(entry.getKey(), null == entry.getValue()?NULL:entry.getValue());\n+            }\n+\n+            this.internalInit(contextMap);\n+        }\n+    }\n+\n+    private synchronized void internalInit(final Map<String, Object> contextMap) {\n+\n+        final String dotSamlDefaultPropertiesValue = (String)contextMap.get(DOT_SAML_DEFAULT_PROPERTIES_CONTEXT_MAP_KEY);\n+\n+        if (null == dotSamlDefaultPropertiesValue) {\n+\n+            Logger.warn(this, DOT_SAML_DEFAULT_PROPERTIES_CONTEXT_MAP_KEY + \" must be set on the argument context map\");\n+        } else {\n+\n+            final File dotSamlDefaultPropertiesFile = new File(dotSamlDefaultPropertiesValue);\n+\n+            if (!dotSamlDefaultPropertiesFile.exists() || !dotSamlDefaultPropertiesFile.canRead()) {\n+\n+                Logger.warn(this, \"The \" + dotSamlDefaultPropertiesValue + \" does not exists or can not read\");\n+            } else {\n+\n+                final Properties properties = new Properties();\n+\n+                try (InputStream input = Files.newInputStream(dotSamlDefaultPropertiesFile.toPath())) {\n+\n+                    properties.load(input);\n+                } catch (IOException ex) {\n+                    // Since this is optional, it is valid to not have the file.\n+                    // Log and go on.\n+                    Logger.warn(this, UNABLE_TO_READ_FILE + dotSamlDefaultPropertiesValue);\n+\n+                }\n+\n+                properties.forEach((key, value) -> {\n+\n+                    final SamlName samlName = SamlName.findProperty((String)key);\n+                    if (null != samlName) {\n+\n+                        this.defaultProperties.put(samlName.getPropertyName(), (String)value);\n+                    }\n+                });\n+\n+                this.init.set(true);\n+            }\n+        }\n+    }\n+\n+\n+    @Override\n+    public String getConfigAsString(final IdentityProviderConfiguration identityProviderConfiguration, final SamlName samlName) {\n+\n+        try {\n+\n+            final String value = identityProviderConfiguration.containsOptionalProperty(samlName.getPropertyName())?\n+                    (String) identityProviderConfiguration.getOptionalProperty(samlName.getPropertyName()):\n+                    this.getDefaultStringParameter(samlName);\n+\n+            Logger.debug(this,\n+                    ()-> \"Found \" + samlName.getPropertyName() + \" : \" + ((value == null) ? \"null\" : value));\n+\n+            return value;\n+        } catch (Exception e) {\n+\n+            Logger.warn(this, ()-> \"Cast exception on \" + samlName.getPropertyName()\n+                    + \" property. idpConfigId: \" + identityProviderConfiguration.getId());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public String getConfigAsString(final IdentityProviderConfiguration identityProviderConfiguration,\n+                                    final SamlName samlName, final Supplier<String> defaultValueSupplier) {\n+\n+        try {\n+\n+            final String value = identityProviderConfiguration.containsOptionalProperty(samlName.getPropertyName())?\n+                    (String) identityProviderConfiguration.getOptionalProperty(samlName.getPropertyName()):\n+                    defaultValueSupplier.get();\n+\n+            Logger.debug(this,\n+                    ()-> \"Found \" + samlName.getPropertyName() + \" : \" + ((value == null) ? \"null\" : value));\n+\n+            return value;\n+        } catch (Exception e) {\n+\n+            Logger.warn(this, ()-> \"Cast exception on \" + samlName.getPropertyName()\n+                    + \" property. idpConfigId: \" + identityProviderConfiguration.getId());\n+        }\n+\n+        return defaultValueSupplier.get();\n+    }\n+\n+    @Override\n+    public Boolean getConfigAsBoolean(final IdentityProviderConfiguration identityProviderConfiguration, final SamlName samlName) {\n+\n+        try {\n+\n+            final Boolean value =  identityProviderConfiguration.containsOptionalProperty(samlName.getPropertyName())?\n+                Boolean.parseBoolean((String) identityProviderConfiguration.getOptionalProperty(samlName.getPropertyName())):\n+                this.getDefaultBooleanParameter(samlName);\n+\n+            Logger.debug(this,\n+                    ()->\"Found \" + samlName.getPropertyName() + \" : \" + ((value == null) ? \"null\" : value));\n+\n+            return value;\n+        } catch (Exception e) {\n+\n+            Logger.warn(this, \"Cast exception on \" + samlName.getPropertyName()\n+                    + \" property. idpConfigId: \" + identityProviderConfiguration.getId());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public String[] getConfigAsArrayString(final IdentityProviderConfiguration identityProviderConfiguration, final SamlName samlName) {\n+\n+        try {\n+\n+            final String[] array = identityProviderConfiguration.containsOptionalProperty(samlName.getPropertyName())?\n+                    StringUtils.split((String) identityProviderConfiguration.getOptionalProperty(samlName.getPropertyName()), DotSamlConstants.ARRAY_SEPARATOR_CHAR):\n+                    this.getDefaultArrayStringParameter(samlName);\n+\n+            Logger.debug(this, ()-> \"Found \" + samlName.getPropertyName() + \" : \" + ((array == null) ? \"null\" : array));\n+\n+            return array;\n+        } catch (Exception e) {\n+\n+            Logger.warn(this, \"Cast exception on \" + samlName.getPropertyName()\n+                    + \" property. idpConfigId: \" + identityProviderConfiguration.getId());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Integer getConfigAsInteger(final IdentityProviderConfiguration identityProviderConfiguration, final SamlName samlName) {\n+\n+        try {\n+\n+            final Integer value = identityProviderConfiguration.containsOptionalProperty(samlName.getPropertyName())?\n+                Integer.parseInt((String) identityProviderConfiguration.getOptionalProperty(samlName.getPropertyName())):\n+                this.getDefaultIntegerParameter(samlName);\n+\n+            Logger.debug(this, ()-> \"Found \" + samlName.getPropertyName() + \" : \" + ((value == null) ? \"null\" : value));\n+\n+            return value;\n+        } catch (Exception e) {\n+\n+            Logger.warn(this, \"Cast exception on \" + samlName.getPropertyName()\n+                    + \" property. idpConfigId: \" + identityProviderConfiguration.getId());\n+        }\n+\n+        return null;\n+    }\n+\n+    ////////\n+\n+    private Integer getDefaultIntegerParameter(final SamlName samlName) {\n+\n+        if (samlName == null) {\n+\n+            throw new SamlException(\"The 'getDefaultIntegerParameter' property is null\");\n+        }\n+\n+        if (this.defaultProperties.containsKey(samlName.getPropertyName())) {\n+\n+            return Integer.parseInt(this.defaultProperties.get(samlName.getPropertyName()));\n+        }\n+\n+        throw new SamlException(NOT_FOUND_ERROR + samlName.getPropertyName());\n+    }\n+\n+    private String[] getDefaultArrayStringParameter(final SamlName samlName) {\n+\n+        final String value = this.getDefaultStringParameter(samlName);\n+        if (value != null) {\n+            return StringUtils.split(value, DotSamlConstants.ARRAY_SEPARATOR_CHAR);\n+        }\n+\n+        throw new SamlException(NOT_FOUND_ERROR + samlName.getPropertyName());\n+    }\n+\n+    public String getDefaultStringParameter(final SamlName property) {\n+\n+        if (property == null) {\n+\n+            throw new SamlException(\"The 'getDefaultStringParameter' property is null\");\n+        }\n+\n+        if (this.defaultProperties.containsKey(property.getPropertyName())) {\n+\n+            final String string = this.defaultProperties.get(property.getPropertyName());\n+            return NULL == string? null : string;", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzgyMg==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757822", "bodyText": "Codacy found an issue: Field sessionIndex has the same name as a method", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:03Z", "path": "dotCMS/src/main/java/com/dotcms/saml/Attributes.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.dotcms.saml;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Encapsulates the attributes retrieve from the Saml Assertion\n+ *\n+ * @author jsanca\n+ */\n+public class Attributes implements Serializable {\n+\n+\tprivate static final long serialVersionUID = 1836313856887837731L;\n+\n+\t// user email from opensaml\n+\tprivate final String email;\n+\n+\t// user last name from opensaml\n+\tprivate final String lastName;\n+\n+\t// user first name from opensaml\n+\tprivate final String firstName;\n+\n+\t// true if opensaml returned roles\n+\tprivate final boolean addRoles;\n+\n+\t// Saml object with the roles info.\n+\tprivate final Object roles;\n+\n+\t// Saml object with the NameID.\n+\tprivate final Object nameID;\n+\n+\t// SAML Session Index\n+\tprivate final String sessionIndex;\n+\n+\tprivate Attributes(final Builder builder) {\n+\n+\t\tthis.email        = builder.email;\n+\t\tthis.lastName     = builder.lastName;\n+\t\tthis.firstName    = builder.firstName;\n+\t\tthis.addRoles     = builder.addRoles;\n+\t\tthis.roles        = builder.roles;\n+\t\tthis.nameID       = builder.nameID;\n+\t\tthis.sessionIndex = builder.sessionIndex;\n+\t}\n+\n+\tpublic String getEmail()\n+\t{\n+\t\treturn email;\n+\t}\n+\n+\tpublic String getLastName()\n+\t{\n+\t\treturn lastName;\n+\t}\n+\n+\tpublic String getFirstName()\n+\t{\n+\t\treturn firstName;\n+\t}\n+\n+\tpublic boolean isAddRoles()\n+\t{\n+\t\treturn addRoles;\n+\t}\n+\n+\tpublic Object getRoles()\n+\t{\n+\t\treturn roles;\n+\t}\n+\n+\tpublic Object getNameID()\n+\t{\n+\t\treturn nameID;\n+\t}\n+\n+\tpublic String getSessionIndex() {\n+\t\treturn sessionIndex;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"AttributesBean{\" + \"nameID='\" + nameID + '\\'' + \", email='\" + email + '\\'' + \", lastName='\" + lastName + '\\''\n+\t\t\t\t+ \", firstName='\" + firstName + '\\'' + \", addRoles=\" + addRoles + \", roles=\" + roles + '}';\n+\t}\n+\n+\tpublic static final class Builder {\n+\t\tString email     = \"\";\n+\t\tString lastName  = \"\";\n+\t\tString firstName = \"\";\n+\t\tboolean addRoles = false;\n+\t\tObject roles     = null;\n+\t\tObject nameID    = null;\n+\t\tString sessionIndex;", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzgzMg==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757832", "bodyText": "Codacy found an issue: Avoid throwing raw exception types.", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:04Z", "path": "dotCMS/src/main/java/com/dotcms/saml/DotSamlProxyFactory.java", "diffHunk": "@@ -0,0 +1,267 @@\n+package com.dotcms.saml;\n+\n+import com.dotcms.auth.providers.saml.v1.DotSamlResource;\n+import com.dotcms.osgi.OSGIConstants;\n+import com.dotcms.security.apps.AppDescriptor;\n+import com.dotcms.security.apps.AppSecretSavedEvent;\n+import com.dotcms.security.apps.AppsAPI;\n+import com.dotcms.security.apps.Secret;\n+import com.dotcms.system.event.local.model.EventSubscriber;\n+import com.dotcms.system.event.local.model.KeyFilterable;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.filters.DotUrlRewriteFilter;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+import org.apache.felix.framework.OSGIUtil;\n+import org.tuckey.web.filters.urlrewrite.NormalRule;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * This is the proxy to provides the object to interact with the Saml Osgi Bundle\n+ *\n+ * @author jsanca\n+ */\n+public class DotSamlProxyFactory implements EventSubscriber<AppSecretSavedEvent>, KeyFilterable {\n+\n+    public static final String SAML_APP_CONFIG_KEY = \"dotsaml-config\";\n+    public static final String PROPERTIES_PATH     = File.separator + \"saml\" + File.separator + \"dotcms-saml-default.properties\";\n+\n+    private static final String ASSETS_PATH   = Config.getStringProperty(\"ASSET_REAL_PATH\",\n+            FileUtil.getRealPath(Config.getStringProperty(\"ASSET_PATH\", \"/assets\")));\n+    private static final String IDP_FILE_PATH = ASSETS_PATH + PROPERTIES_PATH;\n+\n+    private final MessageObserver    messageObserver    = new DotLoggerMessageObserver();\n+    private final AppsAPI            appsAPI            = APILocator.getAppsAPI();\n+    private final IdentityProviderConfigurationFactory identityProviderConfigurationFactory =\n+            new DotIdentityProviderConfigurationFactoryImpl(this.appsAPI, APILocator.getHostAPI());\n+\n+    private SamlServiceBuilder        samlServiceBuilder;\n+    private SamlConfigurationService  samlConfigurationService;\n+    private SamlAuthenticationService samlAuthenticationService;\n+\n+    private static class SingletonHolder {\n+\n+        private static final DotSamlProxyFactory INSTANCE = new DotSamlProxyFactory();\n+    }\n+    /**\n+     * Get the instance.\n+     * @return DotSamlFactory\n+     */\n+    public static DotSamlProxyFactory getInstance() {\n+\n+        addRedirects();\n+        return DotSamlProxyFactory.SingletonHolder.INSTANCE;\n+    } // getInstance.\n+\n+    /**\n+     * Key for the discard non-SAML AppSecretSavedEvent\n+     * @return Comparable\n+     */\n+    @Override\n+    public Comparable getKey() {\n+        return SAML_APP_CONFIG_KEY;\n+    }\n+\n+    /**\n+     * When\n+     * @param event\n+     */\n+    @Override\n+    public void notify(final AppSecretSavedEvent event) {\n+\n+        final  Map<String, Secret> secretMap = event.getAppSecrets().getSecrets();\n+        if (null != secretMap) {\n+\n+            SamlValidator.validateURL(\"sPEndpointHostname\", secretMap.get(\"sPEndpointHostname\").getString(), event.getUserId());\n+            SamlValidator.validateXML(\"idPMetadataFile\",    secretMap.get(\"idPMetadataFile\").getString(),    event.getUserId());\n+        }\n+    }\n+\n+    /**\n+     * Returns the dotCMS implementation of the identity provider config.\n+     * This one basically returns (if exists) the configuration for a idp for a host\n+     * @return IdentityProviderConfigurationFactory\n+     */\n+    public IdentityProviderConfigurationFactory identityProviderConfigurationFactory() {\n+\n+        return identityProviderConfigurationFactory;\n+    }\n+\n+    private static void addRedirects() {\n+\n+        final NormalRule rule = new NormalRule();\n+        rule.setFrom(\"^\\\\/dotsaml\\\\/(\"+String.join(\"|\", DotSamlResource.dotsamlPathSegments)+\")\\\\/(.+)$\");\n+        rule.setToType(\"forward\");\n+        rule.setTo(\"/api/v1/dotsaml/$1/$2\");\n+        rule.setName(\"Dotsaml REST Service Redirect\");\n+        DotUrlRewriteFilter urlRewriteFilter = DotUrlRewriteFilter.getUrlRewriteFilter();\n+        try {\n+            if(urlRewriteFilter != null) {\n+                urlRewriteFilter.addRule(rule);\n+            }else {\n+                throw new Exception();", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzg1NA==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757854", "bodyText": "Codacy found an issue: Field firstName has the same name as a method", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:05Z", "path": "dotCMS/src/main/java/com/dotcms/saml/Attributes.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.dotcms.saml;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Encapsulates the attributes retrieve from the Saml Assertion\n+ *\n+ * @author jsanca\n+ */\n+public class Attributes implements Serializable {\n+\n+\tprivate static final long serialVersionUID = 1836313856887837731L;\n+\n+\t// user email from opensaml\n+\tprivate final String email;\n+\n+\t// user last name from opensaml\n+\tprivate final String lastName;\n+\n+\t// user first name from opensaml\n+\tprivate final String firstName;\n+\n+\t// true if opensaml returned roles\n+\tprivate final boolean addRoles;\n+\n+\t// Saml object with the roles info.\n+\tprivate final Object roles;\n+\n+\t// Saml object with the NameID.\n+\tprivate final Object nameID;\n+\n+\t// SAML Session Index\n+\tprivate final String sessionIndex;\n+\n+\tprivate Attributes(final Builder builder) {\n+\n+\t\tthis.email        = builder.email;\n+\t\tthis.lastName     = builder.lastName;\n+\t\tthis.firstName    = builder.firstName;\n+\t\tthis.addRoles     = builder.addRoles;\n+\t\tthis.roles        = builder.roles;\n+\t\tthis.nameID       = builder.nameID;\n+\t\tthis.sessionIndex = builder.sessionIndex;\n+\t}\n+\n+\tpublic String getEmail()\n+\t{\n+\t\treturn email;\n+\t}\n+\n+\tpublic String getLastName()\n+\t{\n+\t\treturn lastName;\n+\t}\n+\n+\tpublic String getFirstName()\n+\t{\n+\t\treturn firstName;\n+\t}\n+\n+\tpublic boolean isAddRoles()\n+\t{\n+\t\treturn addRoles;\n+\t}\n+\n+\tpublic Object getRoles()\n+\t{\n+\t\treturn roles;\n+\t}\n+\n+\tpublic Object getNameID()\n+\t{\n+\t\treturn nameID;\n+\t}\n+\n+\tpublic String getSessionIndex() {\n+\t\treturn sessionIndex;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"AttributesBean{\" + \"nameID='\" + nameID + '\\'' + \", email='\" + email + '\\'' + \", lastName='\" + lastName + '\\''\n+\t\t\t\t+ \", firstName='\" + firstName + '\\'' + \", addRoles=\" + addRoles + \", roles=\" + roles + '}';\n+\t}\n+\n+\tpublic static final class Builder {\n+\t\tString email     = \"\";\n+\t\tString lastName  = \"\";\n+\t\tString firstName = \"\";", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzg2MQ==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757861", "bodyText": "Codacy found an issue: Avoid variables with short names like id", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:06Z", "path": "dotCMS/src/main/java/com/dotcms/saml/IdentityProviderConfigurationFactory.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package com.dotcms.saml;\n+\n+/**\n+ * This factory is in charge of provide the configuration associated to the identifier in the parameters.\n+ * @author jsanca\n+ */\n+public interface IdentityProviderConfigurationFactory {\n+\n+    /**\n+     * Returns the configuration for the identifier passed as a parameters\n+     * @param id String\n+     * @return IdentityProviderConfiguration\n+     */\n+    IdentityProviderConfiguration findIdentityProviderConfigurationById(String id);", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzg2OA==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757868", "bodyText": "Codacy found an issue: Avoid variables with short names like s", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:07Z", "path": "dotCMS/src/integration-test/java/com/dotcms/saml/MockIdentityProviderConfigurationFactory.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.dotcms.saml;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyPair;\n+import java.security.cert.Certificate;\n+\n+public class MockIdentityProviderConfigurationFactory implements IdentityProviderConfigurationFactory {\n+\n+\n+    @Override\n+    public IdentityProviderConfiguration findIdentityProviderConfigurationById(String s) {", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzg3NQ==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757875", "bodyText": "Codacy found an issue: A catch statement should never catch throwable since it includes errors.", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:08Z", "path": "dotCMS/src/main/java/com/dotcms/filters/interceptor/saml/SamlWebInterceptor.java", "diffHunk": "@@ -0,0 +1,557 @@\n+package com.dotcms.filters.interceptor.saml;\n+\n+import com.dotcms.cms.login.LoginServiceAPI;\n+import com.dotcms.filters.interceptor.Result;\n+import com.dotcms.filters.interceptor.WebInterceptor;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.IdentityProviderConfigurationFactory;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlConfigurationService;\n+import com.dotcms.saml.SamlName;\n+import com.dotcms.security.apps.AppsAPI;\n+import com.dotcms.util.security.Encryptor;\n+import com.dotcms.util.security.EncryptorFactory;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.NoSuchUserException;\n+import com.dotmarketing.business.UserAPI;\n+import com.dotmarketing.business.web.HostWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.RegEX;\n+import com.dotmarketing.util.SecurityLogger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.dotmarketing.util.WebKeys;\n+import com.liferay.portal.auth.PrincipalThreadLocal;\n+import com.liferay.portal.model.User;\n+import com.liferay.portal.servlet.PortletSessionPool;\n+import io.vavr.control.Try;\n+import org.apache.commons.lang.StringUtils;\n+\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.dotcms.saml.DotSamlConstants.SAML_USER_ID;\n+\n+/**\n+ * This interceptor encapsulates the logic for Saml\n+ * Basically if there is any configuration set on dot apps portlet for \"app-saml-config\" and there is a configuration for the current host,\n+ * the interceptor will try to autologin the user (if there is any saml user id on the session) otherwise will redirect to the IDP login.\n+ * In addition if there is any saml host configuration for logout and the interceptor realized it is a logout request, will do the logout on dotCMS\n+ * in addition to the logout on the idp if the configuration requires.\n+ * @author jsanca\n+ */\n+public class SamlWebInterceptor implements WebInterceptor {\n+\n+    public static final String REFERRER_PARAMETER_KEY = \"referrer\";\n+    public static final String ORIGINAL_REQUEST       = \"original_request\";\n+\n+    protected final Encryptor       encryptor;\n+    protected final LoginServiceAPI loginService;\n+    protected final UserAPI         userAPI;\n+    protected final HostWebAPI      hostWebAPI;\n+    protected final AppsAPI         appsAPI;\n+    protected final SamlWebUtils    samlWebUtils;\n+    protected final IdentityProviderConfigurationFactory identityProviderConfigurationFactory;\n+    protected volatile SamlConfigurationService samlConfigurationService;\n+\n+    public SamlWebInterceptor() {\n+\n+        this(EncryptorFactory.getInstance().getEncryptor(),\n+                APILocator.getLoginServiceAPI(),\n+                APILocator.getUserAPI(),\n+                WebAPILocator.getHostWebAPI(),\n+                APILocator.getAppsAPI(),\n+                new SamlWebUtils(),\n+                DotSamlProxyFactory.getInstance().identityProviderConfigurationFactory());\n+    }\n+\n+    public SamlWebInterceptor(final Encryptor       encryptor,\n+            final LoginServiceAPI loginService,\n+            final UserAPI         userAPI,\n+            final HostWebAPI      hostWebAPI,\n+            final AppsAPI         appsAPI,\n+            final SamlWebUtils    samlWebUtils,\n+            final IdentityProviderConfigurationFactory identityProviderConfigurationFactory) {\n+\n+        this.encryptor    = encryptor;\n+        this.loginService = loginService;\n+        this.userAPI      = userAPI;\n+        this.hostWebAPI   = hostWebAPI;\n+        this.appsAPI      = appsAPI;\n+        this.samlWebUtils = samlWebUtils;\n+        this.identityProviderConfigurationFactory = identityProviderConfigurationFactory;\n+    }\n+\n+    private SamlConfigurationService samlConfig() {\n+\n+        if (null == samlConfigurationService) {\n+\n+            this.samlConfigurationService = Try.of(()->DotSamlProxyFactory.getInstance().samlConfigurationService()).getOrNull();\n+        }\n+\n+        return this.samlConfigurationService;\n+    }\n+\n+    @Override\n+    public Result intercept(final HttpServletRequest request,\n+                            final HttpServletResponse response) throws IOException {\n+\n+        HttpSession session = request.getSession(false);\n+\n+        if (this.samlWebUtils.isByPass(request, session)) {\n+\n+            Logger.info(this, ()->\"Using SAML by pass\");\n+            return Result.NEXT;\n+        }\n+\n+        IdentityProviderConfiguration identityProviderConfiguration = null;\n+\n+        try {\n+\n+            if (null != this.samlConfig() && null != session && this.isAnySamlConfigurated()) {\n+\n+                final Host host = hostWebAPI.getCurrentHostNoThrow(request);\n+                identityProviderConfiguration = // gets the SAML Configuration for this site.\n+                        this.identityProviderConfigurationFactory.findIdentityProviderConfigurationById(\n+                                host.getIdentifier());\n+\n+                // If idpConfig is null, means this site does not need SAML processing\n+                if (null != identityProviderConfiguration && identityProviderConfiguration.isEnabled()) { // SAML is configurated, so continue\n+\n+                    // check if there is any exception filter path, to avoid to canApply all the logic.\n+                    if (!this.checkAccessFilters(request.getRequestURI(), this.getAccessFilterArray(identityProviderConfiguration))\n+                            && this.checkIncludePath(request.getRequestURI(), this.getIncludePathArray(identityProviderConfiguration))) {\n+\n+                        if (this.samlWebUtils.isNotLogged(request)) {\n+\n+                            final AutoLoginResult autoLoginResult = this.autoLogin(request, response, session, identityProviderConfiguration);\n+\n+                            // we have to assign again the session, since the doAutoLogin might be renewed.\n+                            session = autoLoginResult.getSession();\n+\n+                            // if the auto login couldn't logged the user, then send it to the IdP login page (if it is not already logged in).\n+                            if (null == session || !autoLoginResult.isAutoLogin() || this.samlWebUtils.isNotLogged(request)) {\n+\n+                                this.doAuthentication(request, response, session, identityProviderConfiguration);\n+                                return Result.SKIP_NO_CHAIN;\n+                            }\n+                        }\n+                    }\n+\n+                    final boolean isLogoutNeed = this.samlConfigurationService.getConfigAsBoolean(\n+                            identityProviderConfiguration, SamlName.DOTCMS_SAML_IS_LOGOUT_NEED);\n+                    // Starting the logout if it is logout\n+                    Logger.debug(this, ()-> \"----------------------------- doFilter --------------------------------\");\n+                    Logger.debug(this, ()-> \"- isLogoutNeed = \" + isLogoutNeed);\n+                    Logger.debug(this, ()-> \"- httpServletRequest.getRequestURI() = \" + request.getRequestURI());\n+\n+                    if (isLogoutNeed &&\n+                            this.samlWebUtils.isLogoutRequest(request.getRequestURI(), this.getLogoutPathArray(identityProviderConfiguration))) {\n+\n+                        if (this.doLogout(response, request, session, identityProviderConfiguration)) {\n+\n+                            Logger.info(this, \"SAML Logout DONE!!!\");\n+                        }\n+                    }\n+                } else {\n+\n+                    Logger.info(this, \"No idpConfig for site '\" + request.getServerName()\n+                            + \"'. No SAML filtering for this request: \" + request.getRequestURI());\n+                }\n+            }\n+        } catch (final Exception exception) { // todo: better error handling?\n+\n+            Logger.error(this,  \"Error [\" + exception.getMessage() + \"] Unable to get idpConfig for Site '\" +\n+                    request.getServerName() + \"'. Incoming URL: \" + request.getRequestURL(), exception);\n+            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n+            return Result.SKIP_NO_CHAIN;\n+        } finally {\n+            if (null != identityProviderConfiguration) {\n+                identityProviderConfiguration.destroy();\n+            }\n+        }\n+\n+        return Result.NEXT;\n+    } // intercept.\n+\n+    private void doAuthentication(final HttpServletRequest request,\n+                                  final HttpServletResponse response,\n+                                  final HttpSession session,\n+                                  final IdentityProviderConfiguration identityProviderConfiguration) throws IOException {\n+\n+        Logger.debug(this, ()-> \"There's no logged-in user. Processing SAML request...\");\n+        this.doRequestLoginSecurityLog(request, identityProviderConfiguration);\n+\n+        final String originalRequest = request.getRequestURI() +\n+                (UtilMethods.isSet(request.getQueryString())?\n+                    \"?\" + request.getQueryString() : StringUtils.EMPTY);\n+\n+        final String redirectAfterLogin = UtilMethods.isSet(request.getParameter(REFERRER_PARAMETER_KEY))\n+                ?request.getParameter(REFERRER_PARAMETER_KEY) :\n+                // this is safe, just to make a redirection when the user get's logged.\n+                originalRequest;\n+\n+        Logger.debug(this.getClass(),\n+                ()-> \"Executing SAML Login Redirection with request: \" + redirectAfterLogin);\n+\n+        // if we don't have a redirect yet\n+        if (null != session) {\n+\n+            session.setAttribute(WebKeys.REDIRECT_AFTER_LOGIN, redirectAfterLogin);\n+            session.setAttribute(ORIGINAL_REQUEST,             originalRequest);\n+        }\n+\n+        try {\n+            // this will redirect the user to the IdP Login Page.\n+            DotSamlProxyFactory.getInstance().samlAuthenticationService()\n+                    .authentication(request, response, identityProviderConfiguration);\n+        } catch (Exception exception) {\n+\n+            Logger.error(this,  \"An error occurred when redirecting to the IdP Login page: \" +\n+                    exception.getMessage(), exception);\n+            Logger.debug(this, ()-> \"An error occurred when redirecting to the IdP Login page. Setting 500 \" +\n+                    \"response status.\");\n+            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n+        }\n+    }\n+\n+    protected boolean isAnySamlConfigurated() {\n+\n+        return\n+                Try.of(()->this.appsAPI.getAppDescriptor(DotSamlProxyFactory.SAML_APP_CONFIG_KEY,\n+                        APILocator.systemUser())).getOrElseGet(e->Optional.empty()).isPresent();\n+    }\n+\n+    protected AutoLoginResult autoLogin(final HttpServletRequest request,\n+                                        final HttpServletResponse response,\n+                                        HttpSession session,\n+                                        final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        final User user          = this.getUser(request, identityProviderConfiguration);\n+        boolean continueFilter   = null != user; // by default continue with the filter\n+        HttpSession renewSession = session;\n+\n+        if (continueFilter) {\n+            // we are going to do the autologin, so if the session is null,\n+            // create it!\n+            try {\n+\n+                Logger.debug(this, \"User with ID '\" + user.getUserId()\n+                        + \"' has been returned by SAML Service. User \" + \"Map: \" + user.toMap());\n+            } catch (Exception e) {\n+\n+                Logger.error(this,\n+                        \"An error occurred when retrieving data from user '\" + user.getUserId() + \"': \" + e.getMessage(), e);\n+            }\n+\n+            final boolean doCookieLogin = this.loginService\n+                    .doCookieLogin(this.encryptor.encryptString(user.getUserId()), request, response);\n+\n+            Logger.debug(this, ()->\"Cookie Login by LoginService = \" + doCookieLogin);\n+\n+            if (doCookieLogin) {\n+\n+                session = request.getSession(false);\n+                if (null != session && null != user.getUserId()) {\n+                    // this is what the PortalRequestProcessor needs to check the login.\n+                    Logger.debug(this, ()->\"Adding user ID '\" + user.getUserId() + \"' to the session\");\n+\n+                    final String uri = session.getAttribute(ORIGINAL_REQUEST) != null?\n+                            (String) session.getAttribute(ORIGINAL_REQUEST):\n+                            request.getRequestURI();\n+\n+                    session.removeAttribute(ORIGINAL_REQUEST);\n+\n+                    Logger.debug(this, ()->  \"URI '\" + uri + \"' belongs to the back-end. Setting the user session data\");\n+                    session.setAttribute(com.liferay.portal.util.WebKeys.USER_ID, user.getUserId());\n+                    session.setAttribute(com.liferay.portal.util.WebKeys.USER,    user);\n+                    PrincipalThreadLocal.setName(user.getUserId());\n+\n+                    renewSession =\n+                            this.samlConfigurationService.getConfigAsBoolean(identityProviderConfiguration, SamlName.DOT_RENEW_SESSION)?\n+                                this.samlWebUtils.renewSession(request, session): session;\n+\n+                    this.doAuthenticationLoginSecurityLog(request, identityProviderConfiguration, user);\n+                }\n+            }\n+        }\n+\n+        return new AutoLoginResult(renewSession, continueFilter);\n+    }\n+\n+    public boolean doLogout(final HttpServletResponse response, final HttpServletRequest request,\n+                            final HttpSession session, final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        Logger.debug(this, ()-> \"------------------------------ IdP doLogout ---------------------------------\");\n+\n+        final Object nameID           = session.getAttribute(identityProviderConfiguration.getId() + SamlAuthenticationService.SAML_NAME_ID);\n+        final String samlSessionIndex = (String) session.getAttribute(identityProviderConfiguration.getId() + SamlAuthenticationService.SAML_SESSION_INDEX);\n+        boolean doLogoutDone          = false;\n+        Logger.debug(this, ()-> \"- idpConfig = \" + identityProviderConfiguration);\n+        Logger.debug(this, ()-> \"- NameID = \" + nameID);\n+        Logger.debug(this, ()-> \"- samlSessionIndex = \" + samlSessionIndex);\n+\n+        try {\n+\n+            if (null != nameID && null != samlSessionIndex) {\n+\n+                Logger.debug(this, ()-> \"The URI '\" + request.getRequestURI() + \"' is a logout request. Executing the logout call to SAML\");\n+                Logger.debug(this, ()-> \"Executing dotCMS logout\");\n+\n+                doLogout(response, request);\n+\n+                Logger.debug(this, ()-> \"Executing SAML redirect logout\");\n+\n+                DotSamlProxyFactory.getInstance().samlAuthenticationService().logout(request, response, nameID, samlSessionIndex, identityProviderConfiguration);\n+\n+                Logger.info(this, ()-> \"User '\" + nameID + \"' has logged out\");\n+\n+                doLogoutDone = true;\n+            } else {\n+\n+                Logger.warn(this, ()->\"Couldn't execute the logout request. The SAML NameID or the SAML session index are not in the HTTP session\");\n+            }\n+        } catch (Throwable e) {", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzg4Ng==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757886", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:10Z", "path": "dotCMS/src/integration-test/java/com/dotcms/saml/TestSamlConfigurationService.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.dotcms.saml;\n+\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.util.Config;\n+import org.apache.felix.framework.OSGIUtil;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+public class TestSamlConfigurationService {\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzg5Mw==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757893", "bodyText": "Codacy found an issue: Avoid reassigning parameters such as 'session'", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:11Z", "path": "dotCMS/src/main/java/com/dotcms/filters/interceptor/saml/SamlWebInterceptor.java", "diffHunk": "@@ -0,0 +1,557 @@\n+package com.dotcms.filters.interceptor.saml;\n+\n+import com.dotcms.cms.login.LoginServiceAPI;\n+import com.dotcms.filters.interceptor.Result;\n+import com.dotcms.filters.interceptor.WebInterceptor;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.IdentityProviderConfigurationFactory;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlConfigurationService;\n+import com.dotcms.saml.SamlName;\n+import com.dotcms.security.apps.AppsAPI;\n+import com.dotcms.util.security.Encryptor;\n+import com.dotcms.util.security.EncryptorFactory;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.NoSuchUserException;\n+import com.dotmarketing.business.UserAPI;\n+import com.dotmarketing.business.web.HostWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.RegEX;\n+import com.dotmarketing.util.SecurityLogger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.dotmarketing.util.WebKeys;\n+import com.liferay.portal.auth.PrincipalThreadLocal;\n+import com.liferay.portal.model.User;\n+import com.liferay.portal.servlet.PortletSessionPool;\n+import io.vavr.control.Try;\n+import org.apache.commons.lang.StringUtils;\n+\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.dotcms.saml.DotSamlConstants.SAML_USER_ID;\n+\n+/**\n+ * This interceptor encapsulates the logic for Saml\n+ * Basically if there is any configuration set on dot apps portlet for \"app-saml-config\" and there is a configuration for the current host,\n+ * the interceptor will try to autologin the user (if there is any saml user id on the session) otherwise will redirect to the IDP login.\n+ * In addition if there is any saml host configuration for logout and the interceptor realized it is a logout request, will do the logout on dotCMS\n+ * in addition to the logout on the idp if the configuration requires.\n+ * @author jsanca\n+ */\n+public class SamlWebInterceptor implements WebInterceptor {\n+\n+    public static final String REFERRER_PARAMETER_KEY = \"referrer\";\n+    public static final String ORIGINAL_REQUEST       = \"original_request\";\n+\n+    protected final Encryptor       encryptor;\n+    protected final LoginServiceAPI loginService;\n+    protected final UserAPI         userAPI;\n+    protected final HostWebAPI      hostWebAPI;\n+    protected final AppsAPI         appsAPI;\n+    protected final SamlWebUtils    samlWebUtils;\n+    protected final IdentityProviderConfigurationFactory identityProviderConfigurationFactory;\n+    protected volatile SamlConfigurationService samlConfigurationService;\n+\n+    public SamlWebInterceptor() {\n+\n+        this(EncryptorFactory.getInstance().getEncryptor(),\n+                APILocator.getLoginServiceAPI(),\n+                APILocator.getUserAPI(),\n+                WebAPILocator.getHostWebAPI(),\n+                APILocator.getAppsAPI(),\n+                new SamlWebUtils(),\n+                DotSamlProxyFactory.getInstance().identityProviderConfigurationFactory());\n+    }\n+\n+    public SamlWebInterceptor(final Encryptor       encryptor,\n+            final LoginServiceAPI loginService,\n+            final UserAPI         userAPI,\n+            final HostWebAPI      hostWebAPI,\n+            final AppsAPI         appsAPI,\n+            final SamlWebUtils    samlWebUtils,\n+            final IdentityProviderConfigurationFactory identityProviderConfigurationFactory) {\n+\n+        this.encryptor    = encryptor;\n+        this.loginService = loginService;\n+        this.userAPI      = userAPI;\n+        this.hostWebAPI   = hostWebAPI;\n+        this.appsAPI      = appsAPI;\n+        this.samlWebUtils = samlWebUtils;\n+        this.identityProviderConfigurationFactory = identityProviderConfigurationFactory;\n+    }\n+\n+    private SamlConfigurationService samlConfig() {\n+\n+        if (null == samlConfigurationService) {\n+\n+            this.samlConfigurationService = Try.of(()->DotSamlProxyFactory.getInstance().samlConfigurationService()).getOrNull();\n+        }\n+\n+        return this.samlConfigurationService;\n+    }\n+\n+    @Override\n+    public Result intercept(final HttpServletRequest request,\n+                            final HttpServletResponse response) throws IOException {\n+\n+        HttpSession session = request.getSession(false);\n+\n+        if (this.samlWebUtils.isByPass(request, session)) {\n+\n+            Logger.info(this, ()->\"Using SAML by pass\");\n+            return Result.NEXT;\n+        }\n+\n+        IdentityProviderConfiguration identityProviderConfiguration = null;\n+\n+        try {\n+\n+            if (null != this.samlConfig() && null != session && this.isAnySamlConfigurated()) {\n+\n+                final Host host = hostWebAPI.getCurrentHostNoThrow(request);\n+                identityProviderConfiguration = // gets the SAML Configuration for this site.\n+                        this.identityProviderConfigurationFactory.findIdentityProviderConfigurationById(\n+                                host.getIdentifier());\n+\n+                // If idpConfig is null, means this site does not need SAML processing\n+                if (null != identityProviderConfiguration && identityProviderConfiguration.isEnabled()) { // SAML is configurated, so continue\n+\n+                    // check if there is any exception filter path, to avoid to canApply all the logic.\n+                    if (!this.checkAccessFilters(request.getRequestURI(), this.getAccessFilterArray(identityProviderConfiguration))\n+                            && this.checkIncludePath(request.getRequestURI(), this.getIncludePathArray(identityProviderConfiguration))) {\n+\n+                        if (this.samlWebUtils.isNotLogged(request)) {\n+\n+                            final AutoLoginResult autoLoginResult = this.autoLogin(request, response, session, identityProviderConfiguration);\n+\n+                            // we have to assign again the session, since the doAutoLogin might be renewed.\n+                            session = autoLoginResult.getSession();\n+\n+                            // if the auto login couldn't logged the user, then send it to the IdP login page (if it is not already logged in).\n+                            if (null == session || !autoLoginResult.isAutoLogin() || this.samlWebUtils.isNotLogged(request)) {\n+\n+                                this.doAuthentication(request, response, session, identityProviderConfiguration);\n+                                return Result.SKIP_NO_CHAIN;\n+                            }\n+                        }\n+                    }\n+\n+                    final boolean isLogoutNeed = this.samlConfigurationService.getConfigAsBoolean(\n+                            identityProviderConfiguration, SamlName.DOTCMS_SAML_IS_LOGOUT_NEED);\n+                    // Starting the logout if it is logout\n+                    Logger.debug(this, ()-> \"----------------------------- doFilter --------------------------------\");\n+                    Logger.debug(this, ()-> \"- isLogoutNeed = \" + isLogoutNeed);\n+                    Logger.debug(this, ()-> \"- httpServletRequest.getRequestURI() = \" + request.getRequestURI());\n+\n+                    if (isLogoutNeed &&\n+                            this.samlWebUtils.isLogoutRequest(request.getRequestURI(), this.getLogoutPathArray(identityProviderConfiguration))) {\n+\n+                        if (this.doLogout(response, request, session, identityProviderConfiguration)) {\n+\n+                            Logger.info(this, \"SAML Logout DONE!!!\");\n+                        }\n+                    }\n+                } else {\n+\n+                    Logger.info(this, \"No idpConfig for site '\" + request.getServerName()\n+                            + \"'. No SAML filtering for this request: \" + request.getRequestURI());\n+                }\n+            }\n+        } catch (final Exception exception) { // todo: better error handling?\n+\n+            Logger.error(this,  \"Error [\" + exception.getMessage() + \"] Unable to get idpConfig for Site '\" +\n+                    request.getServerName() + \"'. Incoming URL: \" + request.getRequestURL(), exception);\n+            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n+            return Result.SKIP_NO_CHAIN;\n+        } finally {\n+            if (null != identityProviderConfiguration) {\n+                identityProviderConfiguration.destroy();\n+            }\n+        }\n+\n+        return Result.NEXT;\n+    } // intercept.\n+\n+    private void doAuthentication(final HttpServletRequest request,\n+                                  final HttpServletResponse response,\n+                                  final HttpSession session,\n+                                  final IdentityProviderConfiguration identityProviderConfiguration) throws IOException {\n+\n+        Logger.debug(this, ()-> \"There's no logged-in user. Processing SAML request...\");\n+        this.doRequestLoginSecurityLog(request, identityProviderConfiguration);\n+\n+        final String originalRequest = request.getRequestURI() +\n+                (UtilMethods.isSet(request.getQueryString())?\n+                    \"?\" + request.getQueryString() : StringUtils.EMPTY);\n+\n+        final String redirectAfterLogin = UtilMethods.isSet(request.getParameter(REFERRER_PARAMETER_KEY))\n+                ?request.getParameter(REFERRER_PARAMETER_KEY) :\n+                // this is safe, just to make a redirection when the user get's logged.\n+                originalRequest;\n+\n+        Logger.debug(this.getClass(),\n+                ()-> \"Executing SAML Login Redirection with request: \" + redirectAfterLogin);\n+\n+        // if we don't have a redirect yet\n+        if (null != session) {\n+\n+            session.setAttribute(WebKeys.REDIRECT_AFTER_LOGIN, redirectAfterLogin);\n+            session.setAttribute(ORIGINAL_REQUEST,             originalRequest);\n+        }\n+\n+        try {\n+            // this will redirect the user to the IdP Login Page.\n+            DotSamlProxyFactory.getInstance().samlAuthenticationService()\n+                    .authentication(request, response, identityProviderConfiguration);\n+        } catch (Exception exception) {\n+\n+            Logger.error(this,  \"An error occurred when redirecting to the IdP Login page: \" +\n+                    exception.getMessage(), exception);\n+            Logger.debug(this, ()-> \"An error occurred when redirecting to the IdP Login page. Setting 500 \" +\n+                    \"response status.\");\n+            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n+        }\n+    }\n+\n+    protected boolean isAnySamlConfigurated() {\n+\n+        return\n+                Try.of(()->this.appsAPI.getAppDescriptor(DotSamlProxyFactory.SAML_APP_CONFIG_KEY,\n+                        APILocator.systemUser())).getOrElseGet(e->Optional.empty()).isPresent();\n+    }\n+\n+    protected AutoLoginResult autoLogin(final HttpServletRequest request,\n+                                        final HttpServletResponse response,\n+                                        HttpSession session,", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzkwNQ==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757905", "bodyText": "Codacy found an issue: Avoid unused imports such as 'com.dotcms.concurrent.DotConcurrentFactory'", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:12Z", "path": "dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventSubscribersInitializer.java", "diffHunk": "@@ -1,6 +1,9 @@\n package com.dotcms.system.event.local.business;\n \n+import com.dotcms.concurrent.DotConcurrentFactory;", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzkxMg==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757912", "bodyText": "Codacy found an issue: New exception is thrown in catch block, original stack trace may be lost", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:13Z", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "diffHunk": "@@ -0,0 +1,469 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotcms.saml.SamlName;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.NoSuchUserException;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.business.UserAPI;\n+import com.dotmarketing.business.web.HostWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.cms.factories.PublicEncryptionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.ActivityLogger;\n+import com.dotmarketing.util.AdminLogger;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.RegEX;\n+import com.dotmarketing.util.SecurityLogger;\n+import com.dotmarketing.util.UUIDGenerator;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.User;\n+import org.apache.commons.lang.StringUtils;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static com.dotmarketing.util.UtilMethods.isSet;\n+\n+public class SAMLHelper {\n+\n+    private final HostWebAPI hostWebAPI;\n+    private final UserAPI    userAPI;\n+    private final RoleAPI    roleAPI;\n+    private final SamlAuthenticationService  samlAuthenticationService;\n+\n+    public SAMLHelper(final SamlAuthenticationService samlAuthenticationService) {\n+\n+        this.userAPI      = APILocator.getUserAPI();\n+        this.roleAPI      = APILocator.getRoleAPI();\n+        this.hostWebAPI   = WebAPILocator.getHostWebAPI();\n+        this.samlAuthenticationService = samlAuthenticationService;\n+    }\n+\n+    // Gets the attributes from the Assertion, based on the attributes\n+    // see if the user exists return it from the dotCMS records, if does not\n+    // exist then, tries to create it.\n+    // the existing or created user, will be updated the roles if they present\n+    // on the assertion.\n+    protected User resolveUser(final Attributes attributes,\n+                             final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        User user       = null;\n+        User systemUser = null;\n+        try {\n+\n+            Logger.debug(this, ()-> \"Validating user - \" + attributes);\n+\n+            systemUser             = this.userAPI.getSystemUser();\n+            final Company company  = APILocator.getCompanyAPI().getDefaultCompany();\n+            final String  authType = company.getAuthType();\n+            user                   = Company.AUTH_TYPE_ID.equals(authType)?\n+                    this.userAPI.loadUserById(this.samlAuthenticationService.getValue(attributes.getNameID()),      systemUser, false):\n+                    this.userAPI.loadByUserByEmail(this.samlAuthenticationService.getValue(attributes.getNameID()), systemUser, false);\n+        } catch (NoSuchUserException e) {\n+\n+            Logger.error(this, \"No user matches ID '\" +\n+                    this.samlAuthenticationService.getValue(attributes.getNameID()) + \"'. Creating one...\", e);\n+            user = null;\n+        } catch (Exception e) {\n+\n+            Logger.error(this, \"An error occurred when loading user with ID '\" +\n+                    (null != attributes && null != attributes.getNameID()?\n+                    this.samlAuthenticationService.getValue(attributes.getNameID()): \"null\") + \"'\", e);\n+            user = null;\n+        }\n+\n+        // check if the client wants synchronization\n+        final boolean createUserWhenDoesNotExists = DotSamlProxyFactory.getInstance()\n+                .samlConfigurationService().getConfigAsBoolean(identityProviderConfiguration, SamlName.DOT_SAML_ALLOW_USER_SYNCHRONIZATION);\n+        if (createUserWhenDoesNotExists) {\n+\n+            user = null == user?\n+                    this.createNewUser(systemUser,    attributes, identityProviderConfiguration):  // if user does not exists, create a new one.\n+                    this.updateUser(user, systemUser, attributes, identityProviderConfiguration); // update it, since exists\n+\n+            if (user.isActive()) {\n+\n+                this.addRoles(user, attributes, identityProviderConfiguration);\n+            } else {\n+\n+                Logger.info(this, ()-> \"User with ID '\" + this.samlAuthenticationService.getValue(attributes.getNameID()) + \"' is not active. No roles \" +\n+                        \"were added.\");\n+            }\n+        }\n+\n+        return user;\n+    }\n+\n+    protected User updateUser(final User user, final User systemUser,\n+                              final Attributes attributesBean, final IdentityProviderConfiguration identityProviderConfiguration) {\n+        try {\n+\n+            if (DotSamlProxyFactory.getInstance().samlConfigurationService()\n+                    .getConfigAsBoolean(identityProviderConfiguration, SamlName.DOTCMS_SAML_LOGIN_UPDATE_EMAIL)){\n+\n+                user.setEmailAddress(attributesBean.getEmail());\n+            }\n+\n+            user.setFirstName(attributesBean.getFirstName());\n+            user.setLastName(attributesBean.getLastName());\n+\n+            this.userAPI.save(user, systemUser, false);\n+            Logger.debug(this, ()-> \"User with email '\" + attributesBean.getEmail() + \"' has been updated\");\n+        } catch (Exception e) {\n+\n+            Logger.error(this, \"Error updating user with email '\" + attributesBean.getEmail() + \"': \" + e.getMessage()\n+                    , e);\n+            throw new SamlException(e.getMessage());", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzkxOA==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757918", "bodyText": "Codacy found an issue: Consider using varargs for methods or constructors which take an array the last parameter.", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:14Z", "path": "dotCMS/src/main/java/com/dotcms/filters/interceptor/saml/SamlWebUtils.java", "diffHunk": "@@ -0,0 +1,188 @@\n+package com.dotcms.filters.interceptor.saml;\n+\n+import com.dotmarketing.business.web.UserWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.PageMode;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.liferay.portal.PortalException;\n+import com.liferay.portal.SystemException;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpSession;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Encapsulates Saml util methods for Web.\n+ * @author jsanca\n+ */\n+public class SamlWebUtils {\n+\n+    public static final String BY_PASS_KEY   = \"native\";\n+    public static final String BY_PASS_VALUE = \"true\";\n+\n+    protected     final UserWebAPI userWebAPI;\n+\n+    public SamlWebUtils() {\n+        this(WebAPILocator.getUserWebAPI());\n+    }\n+\n+    @VisibleForTesting\n+    public SamlWebUtils(final UserWebAPI userWebAPI) {\n+        this.userWebAPI = userWebAPI;\n+    }\n+\n+    protected boolean isByPass(final HttpServletRequest request, final HttpSession session) {\n+\n+        String byPass = request.getParameter(BY_PASS_KEY);\n+\n+        if (null != session) {\n+            if (null != byPass) {\n+\n+                session.setAttribute(BY_PASS_KEY, byPass);\n+            } else {\n+\n+                if (this.isNotLogged(request)) {\n+\n+                    byPass = (String) session.getAttribute(BY_PASS_KEY);\n+                } else if (null != session.getAttribute(BY_PASS_KEY)) {\n+\n+                    session.removeAttribute(BY_PASS_KEY);\n+                }\n+            }\n+        }\n+\n+        return BY_PASS_VALUE.equalsIgnoreCase(byPass);\n+    }\n+\n+    /**\n+     * Return true if the user is not logged. Work for FE and BE\n+     *\n+     * @param request\n+     *            {@link HttpServletRequest}\n+     * @return boolean\n+     */\n+    protected boolean isNotLogged(final HttpServletRequest request) {\n+\n+        boolean isNotLogged     = true;\n+        final boolean isBackend = this.isBackEndAdmin(request, request.getRequestURI());\n+\n+        try {\n+\n+            isNotLogged = isBackend?\n+                    !this.userWebAPI.isLoggedToBackend(request):\n+                    null == this.userWebAPI.getLoggedInFrontendUser(request);\n+\n+            Logger.debug(this, \"Trying to go to back-end login? \" + isBackend\n+                    + \", Is user NOT logged in? \" + isNotLogged);\n+        } catch (PortalException | SystemException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            isNotLogged = true;\n+        }\n+\n+        return isNotLogged;\n+    }\n+\n+    /**\n+     * Determines whether the user in the {@link HttpServletRequest} object or the incoming URI belong to the\n+     * dotCMS back-end login mechanism or not.\n+     *\n+     * @param request The {@link HttpServletRequest} request\n+     * @param uri     The incoming URI for login.\n+     *\n+     * @return If the user or its URI can be associated to the dotCMS back-end login, returns {@code true}. Otherwise,\n+     * returns {@code false}.\n+     */\n+    protected boolean isBackEndAdmin(final HttpServletRequest request, final String uri) {\n+\n+        return PageMode.get(request).isAdmin || this.isBackEndLoginPage(uri);\n+    }\n+\n+    /**\n+     * Analyzes the incoming URI and determines whether it belongs to dotCMS back-end login or logout URIs or not.\n+     *\n+     * @param uri The incoming URI.\n+     *\n+     * @return If the URI can be associated to the dotCMS back-end login or logout, returns {@code true}. Otherwise,\n+     * returns {@code false}.\n+     */\n+    protected boolean isBackEndLoginPage(final String uri) {\n+\n+        return uri.startsWith(\"/dotAdmin\") || uri.startsWith(\"/html/portal/login\") || uri.startsWith(\"/c/public/login\")\n+                || uri.startsWith(\"/c/portal_public/login\") || uri.startsWith(\"/c/portal/logout\");\n+    }\n+\n+    protected boolean isFrontEndLoginPage(final String uri){\n+\n+        return uri.startsWith(\"/dotCMS/login\") || uri.startsWith(\"/application/login\");\n+    }\n+\n+    public boolean isLogoutRequest(final String requestURI, final String[] logoutPathArray) {", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzkzMA==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757930", "bodyText": "Codacy found an issue: Avoid variables with short names like s", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:15Z", "path": "dotCMS/src/integration-test/java/com/dotcms/saml/MockIdentityProviderConfigurationFactory.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.dotcms.saml;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyPair;\n+import java.security.cert.Certificate;\n+\n+public class MockIdentityProviderConfigurationFactory implements IdentityProviderConfigurationFactory {\n+\n+\n+    @Override\n+    public IdentityProviderConfiguration findIdentityProviderConfigurationById(String s) {\n+        return new IdentityProviderConfiguration() {\n+            @Override\n+            public boolean isEnabled() {\n+                return true;\n+            }\n+\n+            @Override\n+            public String getSpIssuerURL() {\n+                return \"https://test.com\";\n+            }\n+\n+            @Override\n+            public String getIdpName() {\n+                return \"test.com/sp\";\n+            }\n+\n+            @Override\n+            public String getId() {\n+                return \"123\";\n+            }\n+\n+            @Override\n+            public String getSpEndpointHostname() {\n+                return \"test.com\";\n+            }\n+\n+            @Override\n+            public String getSignatureValidationType() {\n+                return \"signature\";\n+            }\n+\n+            @Override\n+            public char[] getIdPMetadataFile() {\n+\n+                return new char[0];\n+            }\n+\n+            @Override\n+            public char[] getPublicCert() {\n+                return new char[0];\n+            }\n+\n+            @Override\n+            public char[] getPrivateKey() {\n+                return new char[0];\n+            }\n+\n+            @Override\n+            public Object getOptionalProperty(String s) {\n+                return null;\n+            }\n+\n+            @Override\n+            public boolean containsOptionalProperty(String s) {", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzkzNQ==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757935", "bodyText": "Codacy found an issue: Avoid unused imports such as 'org.junit.Assert'", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:16Z", "path": "dotCMS/src/integration-test/java/com/dotcms/saml/TestSamlConfigurationService.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.dotcms.saml;\n+\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.util.Config;\n+import org.apache.felix.framework.OSGIUtil;\n+import org.junit.Assert;", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzk0MQ==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757941", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:17Z", "path": "dotCMS/src/main/java/com/dotcms/saml/DotSamlProxyFactory.java", "diffHunk": "@@ -0,0 +1,267 @@\n+package com.dotcms.saml;\n+\n+import com.dotcms.auth.providers.saml.v1.DotSamlResource;\n+import com.dotcms.osgi.OSGIConstants;\n+import com.dotcms.security.apps.AppDescriptor;\n+import com.dotcms.security.apps.AppSecretSavedEvent;\n+import com.dotcms.security.apps.AppsAPI;\n+import com.dotcms.security.apps.Secret;\n+import com.dotcms.system.event.local.model.EventSubscriber;\n+import com.dotcms.system.event.local.model.KeyFilterable;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.filters.DotUrlRewriteFilter;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+import org.apache.felix.framework.OSGIUtil;\n+import org.tuckey.web.filters.urlrewrite.NormalRule;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * This is the proxy to provides the object to interact with the Saml Osgi Bundle\n+ *\n+ * @author jsanca\n+ */\n+public class DotSamlProxyFactory implements EventSubscriber<AppSecretSavedEvent>, KeyFilterable {\n+\n+    public static final String SAML_APP_CONFIG_KEY = \"dotsaml-config\";\n+    public static final String PROPERTIES_PATH     = File.separator + \"saml\" + File.separator + \"dotcms-saml-default.properties\";\n+\n+    private static final String ASSETS_PATH   = Config.getStringProperty(\"ASSET_REAL_PATH\",\n+            FileUtil.getRealPath(Config.getStringProperty(\"ASSET_PATH\", \"/assets\")));\n+    private static final String IDP_FILE_PATH = ASSETS_PATH + PROPERTIES_PATH;\n+\n+    private final MessageObserver    messageObserver    = new DotLoggerMessageObserver();\n+    private final AppsAPI            appsAPI            = APILocator.getAppsAPI();\n+    private final IdentityProviderConfigurationFactory identityProviderConfigurationFactory =\n+            new DotIdentityProviderConfigurationFactoryImpl(this.appsAPI, APILocator.getHostAPI());\n+\n+    private SamlServiceBuilder        samlServiceBuilder;\n+    private SamlConfigurationService  samlConfigurationService;\n+    private SamlAuthenticationService samlAuthenticationService;\n+\n+    private static class SingletonHolder {\n+\n+        private static final DotSamlProxyFactory INSTANCE = new DotSamlProxyFactory();\n+    }\n+    /**\n+     * Get the instance.\n+     * @return DotSamlFactory\n+     */\n+    public static DotSamlProxyFactory getInstance() {\n+\n+        addRedirects();\n+        return DotSamlProxyFactory.SingletonHolder.INSTANCE;\n+    } // getInstance.\n+\n+    /**\n+     * Key for the discard non-SAML AppSecretSavedEvent\n+     * @return Comparable\n+     */\n+    @Override\n+    public Comparable getKey() {\n+        return SAML_APP_CONFIG_KEY;\n+    }\n+\n+    /**\n+     * When\n+     * @param event\n+     */\n+    @Override\n+    public void notify(final AppSecretSavedEvent event) {\n+\n+        final  Map<String, Secret> secretMap = event.getAppSecrets().getSecrets();\n+        if (null != secretMap) {\n+\n+            SamlValidator.validateURL(\"sPEndpointHostname\", secretMap.get(\"sPEndpointHostname\").getString(), event.getUserId());\n+            SamlValidator.validateXML(\"idPMetadataFile\",    secretMap.get(\"idPMetadataFile\").getString(),    event.getUserId());\n+        }\n+    }\n+\n+    /**\n+     * Returns the dotCMS implementation of the identity provider config.\n+     * This one basically returns (if exists) the configuration for a idp for a host\n+     * @return IdentityProviderConfigurationFactory\n+     */\n+    public IdentityProviderConfigurationFactory identityProviderConfigurationFactory() {\n+\n+        return identityProviderConfigurationFactory;\n+    }\n+\n+    private static void addRedirects() {\n+\n+        final NormalRule rule = new NormalRule();\n+        rule.setFrom(\"^\\\\/dotsaml\\\\/(\"+String.join(\"|\", DotSamlResource.dotsamlPathSegments)+\")\\\\/(.+)$\");\n+        rule.setToType(\"forward\");\n+        rule.setTo(\"/api/v1/dotsaml/$1/$2\");\n+        rule.setName(\"Dotsaml REST Service Redirect\");\n+        DotUrlRewriteFilter urlRewriteFilter = DotUrlRewriteFilter.getUrlRewriteFilter();\n+        try {\n+            if(urlRewriteFilter != null) {\n+                urlRewriteFilter.addRule(rule);\n+            }else {\n+                throw new Exception();\n+            }\n+        } catch (Exception e) {", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzk1MA==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757950", "bodyText": "Codacy found an issue: Assigning an Object to null is a code smell.  Consider refactoring.", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:18Z", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "diffHunk": "@@ -0,0 +1,469 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotcms.saml.SamlName;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.NoSuchUserException;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.business.UserAPI;\n+import com.dotmarketing.business.web.HostWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.cms.factories.PublicEncryptionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.ActivityLogger;\n+import com.dotmarketing.util.AdminLogger;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.RegEX;\n+import com.dotmarketing.util.SecurityLogger;\n+import com.dotmarketing.util.UUIDGenerator;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.User;\n+import org.apache.commons.lang.StringUtils;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static com.dotmarketing.util.UtilMethods.isSet;\n+\n+public class SAMLHelper {\n+\n+    private final HostWebAPI hostWebAPI;\n+    private final UserAPI    userAPI;\n+    private final RoleAPI    roleAPI;\n+    private final SamlAuthenticationService  samlAuthenticationService;\n+\n+    public SAMLHelper(final SamlAuthenticationService samlAuthenticationService) {\n+\n+        this.userAPI      = APILocator.getUserAPI();\n+        this.roleAPI      = APILocator.getRoleAPI();\n+        this.hostWebAPI   = WebAPILocator.getHostWebAPI();\n+        this.samlAuthenticationService = samlAuthenticationService;\n+    }\n+\n+    // Gets the attributes from the Assertion, based on the attributes\n+    // see if the user exists return it from the dotCMS records, if does not\n+    // exist then, tries to create it.\n+    // the existing or created user, will be updated the roles if they present\n+    // on the assertion.\n+    protected User resolveUser(final Attributes attributes,\n+                             final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        User user       = null;\n+        User systemUser = null;\n+        try {\n+\n+            Logger.debug(this, ()-> \"Validating user - \" + attributes);\n+\n+            systemUser             = this.userAPI.getSystemUser();\n+            final Company company  = APILocator.getCompanyAPI().getDefaultCompany();\n+            final String  authType = company.getAuthType();\n+            user                   = Company.AUTH_TYPE_ID.equals(authType)?\n+                    this.userAPI.loadUserById(this.samlAuthenticationService.getValue(attributes.getNameID()),      systemUser, false):\n+                    this.userAPI.loadByUserByEmail(this.samlAuthenticationService.getValue(attributes.getNameID()), systemUser, false);\n+        } catch (NoSuchUserException e) {\n+\n+            Logger.error(this, \"No user matches ID '\" +\n+                    this.samlAuthenticationService.getValue(attributes.getNameID()) + \"'. Creating one...\", e);\n+            user = null;", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc3MDA5Nw==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463770097", "bodyText": "it is ok", "author": "jdotcms", "createdAt": "2020-07-31T18:38:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzk2MQ==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757961", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:19Z", "path": "dotCMS/src/main/java/com/dotcms/saml/DotAbstractSamlConfigurationServiceImpl.java", "diffHunk": "@@ -0,0 +1,254 @@\n+package com.dotcms.saml;\n+\n+import com.dotmarketing.util.Logger;\n+import org.apache.commons.lang.StringUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Supplier;\n+\n+/**\n+ * This service will retrieve information form the idp config, but also if the value is not set will provide the default value for the saml name.\n+ * It has different implementation for several kinds of values\n+ * @author jsanca\n+ */\n+public abstract class DotAbstractSamlConfigurationServiceImpl implements SamlConfigurationService {\n+\n+    private static final String NULL = \"NULL\";\n+    private static final String UNABLE_TO_READ_FILE = \"File does not exist or unable to read : \";\n+    private static final String NOT_FOUND_ERROR = \"Property Name not Found: \";\n+\n+    private AtomicBoolean init = new AtomicBoolean(false);\n+    private final Map<String, String> defaultProperties = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public void initService(final Map<String, Object> contextMap) {\n+\n+        if (!this.init.get()) {\n+\n+            final Map<String, String> samlInitialMap = this.createInitialMap();\n+            for (final Map.Entry<String, String> entry : samlInitialMap.entrySet()) {\n+\n+                this.defaultProperties.put(entry.getKey(), null == entry.getValue()?NULL:entry.getValue());\n+            }\n+\n+            this.internalInit(contextMap);\n+        }\n+    }\n+\n+    private synchronized void internalInit(final Map<String, Object> contextMap) {\n+\n+        final String dotSamlDefaultPropertiesValue = (String)contextMap.get(DOT_SAML_DEFAULT_PROPERTIES_CONTEXT_MAP_KEY);\n+\n+        if (null == dotSamlDefaultPropertiesValue) {\n+\n+            Logger.warn(this, DOT_SAML_DEFAULT_PROPERTIES_CONTEXT_MAP_KEY + \" must be set on the argument context map\");\n+        } else {\n+\n+            final File dotSamlDefaultPropertiesFile = new File(dotSamlDefaultPropertiesValue);\n+\n+            if (!dotSamlDefaultPropertiesFile.exists() || !dotSamlDefaultPropertiesFile.canRead()) {\n+\n+                Logger.warn(this, \"The \" + dotSamlDefaultPropertiesValue + \" does not exists or can not read\");\n+            } else {\n+\n+                final Properties properties = new Properties();\n+\n+                try (InputStream input = Files.newInputStream(dotSamlDefaultPropertiesFile.toPath())) {\n+\n+                    properties.load(input);\n+                } catch (IOException ex) {\n+                    // Since this is optional, it is valid to not have the file.\n+                    // Log and go on.\n+                    Logger.warn(this, UNABLE_TO_READ_FILE + dotSamlDefaultPropertiesValue);\n+\n+                }\n+\n+                properties.forEach((key, value) -> {\n+\n+                    final SamlName samlName = SamlName.findProperty((String)key);\n+                    if (null != samlName) {\n+\n+                        this.defaultProperties.put(samlName.getPropertyName(), (String)value);\n+                    }\n+                });\n+\n+                this.init.set(true);\n+            }\n+        }\n+    }\n+\n+\n+    @Override\n+    public String getConfigAsString(final IdentityProviderConfiguration identityProviderConfiguration, final SamlName samlName) {\n+\n+        try {\n+\n+            final String value = identityProviderConfiguration.containsOptionalProperty(samlName.getPropertyName())?\n+                    (String) identityProviderConfiguration.getOptionalProperty(samlName.getPropertyName()):\n+                    this.getDefaultStringParameter(samlName);\n+\n+            Logger.debug(this,\n+                    ()-> \"Found \" + samlName.getPropertyName() + \" : \" + ((value == null) ? \"null\" : value));\n+\n+            return value;\n+        } catch (Exception e) {", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzk2OA==", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757968", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "author": "dev-dotcms", "createdAt": "2020-07-31T18:11:20Z", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "diffHunk": "@@ -0,0 +1,469 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotcms.saml.SamlName;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.NoSuchUserException;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.business.UserAPI;\n+import com.dotmarketing.business.web.HostWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.cms.factories.PublicEncryptionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.ActivityLogger;\n+import com.dotmarketing.util.AdminLogger;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.RegEX;\n+import com.dotmarketing.util.SecurityLogger;\n+import com.dotmarketing.util.UUIDGenerator;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.User;\n+import org.apache.commons.lang.StringUtils;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static com.dotmarketing.util.UtilMethods.isSet;\n+\n+public class SAMLHelper {\n+\n+    private final HostWebAPI hostWebAPI;\n+    private final UserAPI    userAPI;\n+    private final RoleAPI    roleAPI;\n+    private final SamlAuthenticationService  samlAuthenticationService;\n+\n+    public SAMLHelper(final SamlAuthenticationService samlAuthenticationService) {\n+\n+        this.userAPI      = APILocator.getUserAPI();\n+        this.roleAPI      = APILocator.getRoleAPI();\n+        this.hostWebAPI   = WebAPILocator.getHostWebAPI();\n+        this.samlAuthenticationService = samlAuthenticationService;\n+    }\n+\n+    // Gets the attributes from the Assertion, based on the attributes\n+    // see if the user exists return it from the dotCMS records, if does not\n+    // exist then, tries to create it.\n+    // the existing or created user, will be updated the roles if they present\n+    // on the assertion.\n+    protected User resolveUser(final Attributes attributes,\n+                             final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        User user       = null;\n+        User systemUser = null;\n+        try {\n+\n+            Logger.debug(this, ()-> \"Validating user - \" + attributes);\n+\n+            systemUser             = this.userAPI.getSystemUser();\n+            final Company company  = APILocator.getCompanyAPI().getDefaultCompany();\n+            final String  authType = company.getAuthType();\n+            user                   = Company.AUTH_TYPE_ID.equals(authType)?\n+                    this.userAPI.loadUserById(this.samlAuthenticationService.getValue(attributes.getNameID()),      systemUser, false):\n+                    this.userAPI.loadByUserByEmail(this.samlAuthenticationService.getValue(attributes.getNameID()), systemUser, false);\n+        } catch (NoSuchUserException e) {\n+\n+            Logger.error(this, \"No user matches ID '\" +\n+                    this.samlAuthenticationService.getValue(attributes.getNameID()) + \"'. Creating one...\", e);\n+            user = null;\n+        } catch (Exception e) {", "originalCommit": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}