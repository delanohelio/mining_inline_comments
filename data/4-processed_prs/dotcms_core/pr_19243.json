{"pr_number": 19243, "pr_title": "#18554: Adding support quartz job for when executing integrity check in a receiver cluster ", "pr_createdAt": "2020-09-09T15:48:36Z", "pr_url": "https://github.com/dotCMS/core/pull/19243", "timeline": [{"oid": "ed0294df40e6d9ec64d79d9331a61c60faa94f7a", "url": "https://github.com/dotCMS/core/commit/ed0294df40e6d9ec64d79d9331a61c60faa94f7a", "message": "Addint integration tests for new job", "committedDate": "2020-09-14T17:39:39Z", "type": "forcePushed"}, {"oid": "974b8964b1ce20f9534bf900d656c5aad174d7e8", "url": "https://github.com/dotCMS/core/commit/974b8964b1ce20f9534bf900d656c5aad174d7e8", "message": "#18554: Introducing IntegritiGenerationDataJob to support multi node receivers creation of file and query process for status", "committedDate": "2020-09-14T21:40:57Z", "type": "forcePushed"}, {"oid": "3e7f99f163978aacc7c06b80d1a5aa33e374b21d", "url": "https://github.com/dotCMS/core/commit/3e7f99f163978aacc7c06b80d1a5aa33e374b21d", "message": "#18554: Introducing IntegritiGenerationDataJob to support multi node receivers creation of file and query process for status", "committedDate": "2020-09-14T22:57:42Z", "type": "forcePushed"}, {"oid": "4e39e4135f52861792260306f1f961d31c4ef37e", "url": "https://github.com/dotCMS/core/commit/4e39e4135f52861792260306f1f961d31c4ef37e", "message": "Applying codacy feedback", "committedDate": "2020-09-15T16:16:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1MTQ4MQ==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r488751481", "bodyText": "remove this commented code", "author": "freddyucv", "createdAt": "2020-09-15T15:17:10Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/quartz/job/CleanUpFieldReferencesJobTest.java", "diffHunk": "@@ -133,7 +134,7 @@ public void testCleanUpFieldJob(TestCase testCase)\n                 cal1.setTime((Date) fieldValue);\n                 cal2.setTime((Date) testCase.fieldValue);\n \n-                assertNotEquals(cal1.get(Calendar.DAY_OF_YEAR), cal2.get(Calendar.DAY_OF_YEAR));\n+                //assertNotEquals(cal1.get(Calendar.DAY_OF_YEAR), cal2.get(Calendar.DAY_OF_YEAR));", "originalCommit": "3e7f99f163978aacc7c06b80d1a5aa33e374b21d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MDMzNQ==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r489080335", "bodyText": "As you wish.", "author": "victoralfaro-dotcms", "createdAt": "2020-09-15T23:50:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1MTQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1MzUxMg==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r488753512", "bodyText": "more than a String this is a path, right?", "author": "freddyucv", "createdAt": "2020-09-15T15:19:50Z", "path": "dotCMS/src/main/java/com/dotcms/integritycheckers/IntegrityUtil.java", "diffHunk": "@@ -243,79 +256,212 @@ public static void unzipFile(InputStream zipFile, String outputDir) throws Excep\n         }\n     }\n \n+    /**\n+     * Creates a String representing the integrity data path based on provided endpointId.\n+     *", "originalCommit": "3e7f99f163978aacc7c06b80d1a5aa33e374b21d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MTEzNA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r489081134", "bodyText": "Yes. I changed a little the java doc.", "author": "victoralfaro-dotcms", "createdAt": "2020-09-15T23:52:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1MzUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1MzYzNA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r488753634", "bodyText": "same before", "author": "freddyucv", "createdAt": "2020-09-15T15:20:02Z", "path": "dotCMS/src/main/java/com/dotcms/integritycheckers/IntegrityUtil.java", "diffHunk": "@@ -243,79 +256,212 @@ public static void unzipFile(InputStream zipFile, String outputDir) throws Excep\n         }\n     }\n \n+    /**\n+     * Creates a String representing the integrity data path based on provided endpointId.\n+     *\n+     * @param endpointId endpoint if\n+     * @return integrity data path\n+     */\n+    public static String getIntegrityDataPath(final String endpointId) {\n+        return ConfigUtils.getIntegrityPath() + File.separator + endpointId;\n+    }\n+\n+    /**\n+     * Creates a String representing the integrity data file path based on provided endpointId and the file name.\n+     * File names to be used: DataToCheck.zip, DataToFix.zip and DataStatus.properties.", "originalCommit": "3e7f99f163978aacc7c06b80d1a5aa33e374b21d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1NDcwOA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r488754708", "bodyText": "I think a better name is getIntegrityDataFilePath because it really return the path", "author": "freddyucv", "createdAt": "2020-09-15T15:21:29Z", "path": "dotCMS/src/main/java/com/dotcms/integritycheckers/IntegrityUtil.java", "diffHunk": "@@ -243,79 +256,212 @@ public static void unzipFile(InputStream zipFile, String outputDir) throws Excep\n         }\n     }\n \n+    /**\n+     * Creates a String representing the integrity data path based on provided endpointId.\n+     *\n+     * @param endpointId endpoint if\n+     * @return integrity data path\n+     */\n+    public static String getIntegrityDataPath(final String endpointId) {\n+        return ConfigUtils.getIntegrityPath() + File.separator + endpointId;\n+    }\n+\n+    /**\n+     * Creates a String representing the integrity data file path based on provided endpointId and the file name.\n+     * File names to be used: DataToCheck.zip, DataToFix.zip and DataStatus.properties.\n+     *\n+     * @param endpointId endpoint gid\n+     * @param dataFile data filename\n+     * @return path to filename\n+     */\n+    public static String getIntegrityDataFile(final String endpointId, final String dataFile) {", "originalCommit": "3e7f99f163978aacc7c06b80d1a5aa33e374b21d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MTI3Mw==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r489081273", "bodyText": "You are right.", "author": "victoralfaro-dotcms", "createdAt": "2020-09-15T23:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1NDcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc4OTY1Nw==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r488789657", "bodyText": "I think that the triggerIntegrityDataGeneration method should check if the Quartz is running inner, I mean this code:\nhttps://github.com/dotCMS/core/pull/19243/files#diff-1c1ba904ed03287c1c0b48a6f3971449R204\nand if the quartz is running throw a exception then in the resource catch the exception and send the response", "author": "freddyucv", "createdAt": "2020-09-15T16:10:11Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -153,68 +149,99 @@ private Response postWithEndpointState(String endpointId, String url, MediaType\n \t\treturn response;\n \t}\n \n+    /**\n+     * Resolves remote IP address from request.\n+     * @param request {@link HttpServletRequest}\n+     * @return a String representing the remote IP address (or hostname)\n+     */\n+    private static String resolveRemoteIp(@Context final HttpServletRequest request) {\n+        final String remoteIP = request.getRemoteHost();\n+        return !UtilMethods.isSet(remoteIP) ? remoteIP : request.getRemoteAddr();\n+    }\n+\n+    private static String getFullLocalIp(@Context final HttpServletRequest request) {\n+        final String localIp = request.getLocalName();\n+        Optional<String> port = HttpRequestDataUtil.getServerPort();\n+        return (!UtilMethods.isSet(localIp) ? localIp : request.getLocalName())\n+                + ':' + port.orElse(request.getLocalPort() + \"\");\n+    }\n \n     /**\n      * <p>Returns a zip with data from structures and folders for integrity check\n-     *\n-     * Usage: /getdata\n-     *\n      */\n-\n     @POST\n     @Path(\"/generateintegritydata/{params:.*}\")\n     @Consumes(MediaType.MULTIPART_FORM_DATA)\n     @Produces(\"text/plain\")\n-    public Response generateIntegrityData(@Context HttpServletRequest request, @FormDataParam(\"AUTH_TOKEN\") String auth_token_digest)  {\n+    public Response generateIntegrityData(\n+            @Context final HttpServletRequest request,\n+            @FormDataParam(\"AUTH_TOKEN\") final String auth_token_digest)  {\n+        final String localAddress = getFullLocalIp(request);\n+        if (!UtilMethods.isSet(auth_token_digest)) {\n+            final String message = \"Error: Authentication Token was not found.\";\n+            Logger.error(IntegrityResource.class, String.format(\"Receiver at %s> :%s\", localAddress, message));\n+            return Response\n+                    .status(HttpStatus.SC_BAD_REQUEST)\n+                    .entity(message)\n+                    .build();\n+        }\n \n-        String remoteIP = null;\n+        final String remoteIp = resolveRemoteIp(request);\n+        final PublishingEndPointAPI endpointAPI = APILocator.getPublisherEndPointAPI();\n         try {\n-\n-            if ( !UtilMethods.isSet( auth_token_digest ) ) {\n-                return Response.status( HttpStatus.SC_BAD_REQUEST ).entity( \"Error: 'endpoint' is a required param.\" ).build();\n-            }\n-\n-\n-\n-            remoteIP = request.getRemoteHost();\n-            if(!UtilMethods.isSet(remoteIP))\n-                remoteIP = request.getRemoteAddr();\n-\n-            PublishingEndPointAPI endpointAPI = APILocator.getPublisherEndPointAPI();\n-            final PublishingEndPoint requesterEndPoint = endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n-\n-            if(!BundlePublisherResource.isValidToken(auth_token_digest, remoteIP, requesterEndPoint)) {\n+            final PublishingEndPoint requesterEndpoint = endpointAPI.findEnabledSendingEndPointByAddress(remoteIp);\n+            if (!BundlePublisherResource.isValidToken(auth_token_digest, remoteIp, requesterEndpoint)) {\n+                Logger.error(\n+                        IntegrityResource.class,\n+                        String.format(\n+                                \"Receiver at %s:> Authentication Token is invalid for ip: %s and endpoint id %s\",\n+                                localAddress,\n+                                remoteIp,\n+                                requesterEndpoint.getId()));\n                 return Response.status(HttpStatus.SC_UNAUTHORIZED).build();\n             }\n \n-            ServletContext servletContext = request.getSession().getServletContext();\n-\n-            if(servletContext.getAttribute(\"integrityRunning\")!=null && ((Boolean) servletContext.getAttribute(\"integrityRunning\"))) {\n-                throw new WebApplicationException(Response.status(HttpStatus.SC_CONFLICT).entity(\"Already Running\").build());\n+            if (QuartzUtils.isJobRunning(\n+                    IntegrityDataGenerationJob.JOB_NAME,\n+                    IntegrityDataGenerationJob.JOB_GROUP)) {\n+                Logger.error(\n+                        IntegrityResource.class,\n+                        String.format(\n+                                \"Receiver at %s:> job is already running for endpoint id: %s, so aborting generation\",\n+                                localAddress,\n+                                requesterEndpoint.getId()));\n+                throw new WebApplicationException(\n+                        Response.status(HttpStatus.SC_CONFLICT)\n+                                .entity(\"Already Running\")\n+                                .build());\n             }\n \n-            String transactionId = UUIDGenerator.generateUuid();\n-            servletContext.setAttribute(\"integrityDataRequestID\", transactionId);\n-\n-            // start data generation process\n-            IntegrityDataGeneratorThread idg = new IntegrityDataGeneratorThread( requesterEndPoint, request.getSession().getServletContext() );\n-            idg.start();\n-            //Saving the thread on the session context for a later use\n-            servletContext.setAttribute( \"integrityDataGeneratorThread_\" + transactionId, idg );\n+            final String transactionId = UUIDGenerator.generateUuid();\n+            IntegrityDataGenerationJob.triggerIntegrityDataGeneration(requesterEndpoint, transactionId);", "originalCommit": "3e7f99f163978aacc7c06b80d1a5aa33e374b21d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4Mzc3MA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r489083770", "bodyText": "Isn't Quartz in charge of checking that for me?", "author": "victoralfaro-dotcms", "createdAt": "2020-09-16T00:01:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc4OTY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc5MDc1Mg==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r488790752", "bodyText": "same before", "author": "freddyucv", "createdAt": "2020-09-15T16:11:43Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -230,79 +257,139 @@ public Response generateIntegrityData(@Context HttpServletRequest request, @Form\n     @Path(\"/getintegritydata/{params:.*}\")\n     @Produces(\"application/zip\")\n     @Consumes(MediaType.MULTIPART_FORM_DATA)\n-    public Response getIntegrityData(@Context HttpServletRequest request, @FormDataParam(\"AUTH_TOKEN\") String auth_token_digest, @FormDataParam(\"REQUEST_ID\") String requestId)  {\n-        String remoteIP = null;\n+    public Response getIntegrityData(@Context final HttpServletRequest request,\n+                                     @FormDataParam(\"AUTH_TOKEN\") final String auth_token_digest,\n+                                     @FormDataParam(\"REQUEST_ID\") final String requestId)  {\n+        final String remoteIp = resolveRemoteIp(request);\n+        final String localAddress = getFullLocalIp(request);\n \n+        final PublishingEndPointAPI endpointAPI = APILocator.getPublisherEndPointAPI();\n         try {\n+            final PublishingEndPoint requesterEndpoint = endpointAPI.findEnabledSendingEndPointByAddress(remoteIp);\n+\n+            if (!BundlePublisherResource.isValidToken(auth_token_digest, remoteIp, requesterEndpoint) ||\n+                    !UtilMethods.isSet(requestId)) {\n+                Logger.error(\n+                        IntegrityResource.class,\n+                        String.format(\n+                                \"Receiver at %s:> Authentication Token is invalid for ip: %s and endpoint id %s\",\n+                                localAddress,\n+                                remoteIp,\n+                                requesterEndpoint.getId()));\n+                return Response.status(HttpStatus.SC_UNAUTHORIZED).build();\n+            }\n \n+            if (QuartzUtils.isJobRunning(", "originalCommit": "3e7f99f163978aacc7c06b80d1a5aa33e374b21d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk5MDMyNg==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r488990326", "bodyText": "This needs to be the *Test class instead of the Job itself", "author": "dsilvam", "createdAt": "2020-09-15T21:39:29Z", "path": "dotCMS/src/integration-test/java/com/dotcms/MainSuite.java", "diffHunk": "@@ -316,7 +317,9 @@\n         ContentletWebAPIImplIntegrationTest.class,\n         Task05370AddAppsPortletToLayoutTest.class,\n         FolderFactoryImplTest.class,\n-        DotSamlResourceTest.class\n+        DotSamlResourceTest.class,\n+        FolderFactoryImplTest.class,\n+        IntegrityDataGenerationJob.class", "originalCommit": "3582e642600efd7982e82aef08539fcb17969afd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA5Mzg0NA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r489093844", "bodyText": "You are right.", "author": "victoralfaro-dotcms", "createdAt": "2020-09-16T00:37:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk5MDMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk5MTQ1Mw==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r488991453", "bodyText": "@victoralfaro-dotcms here we use the following convention for the test javadoc:\n/**\n* Method to test: include this in case the method to test does not belong to the class this test-class is testing \n* Given Scenario: Scenario under test\n* ExpectedResult: Expected result that the assertion is checking against\n*\n*/", "author": "dsilvam", "createdAt": "2020-09-15T21:40:46Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/quartz/job/IntegrityDataGenerationJobTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+package com.dotmarketing.quartz.job;\n+\n+import com.dotcms.IntegrationTestBase;\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.publisher.endpoint.bean.impl.PushPublishingEndPoint;\n+import com.dotcms.rest.IntegrityResource;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.exception.DotDataException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import com.tngtech.java.junit.dataprovider.DataProviderRunner;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.quartz.JobDataMap;\n+import org.quartz.JobDetail;\n+import org.quartz.JobExecutionContext;\n+import org.quartz.SchedulerException;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * @author victor\n+ */\n+@RunWith(DataProviderRunner.class)\n+public class IntegrityDataGenerationJobTest extends IntegrationTestBase {\n+\n+    private IntegrityDataGenerationJob integrityDataGenerationJob;\n+    private PublishingEndPoint endpoint;\n+    private String requestId;\n+\n+    @BeforeClass\n+    public static void beforeClass() throws Exception {\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void before() throws DotDataException {\n+        integrityDataGenerationJob = new IntegrityDataGenerationJob();\n+        endpoint = new PushPublishingEndPoint();\n+        endpoint.setId(UUID.randomUUID().toString());\n+        requestId = UUID.randomUUID().toString();\n+\n+        DotConnect dotConnect = new DotConnect();\n+        dotConnect\n+                .setSQL(\"delete from QRTZ_EXCL_SIMPLE_TRIGGERS where TRIGGER_NAME = ? and TRIGGER_GROUP = ?\")\n+                .addParam(IntegrityDataGenerationJob.TRIGGER_NAME)\n+                .addParam(IntegrityDataGenerationJob.TRIGGER_GROUP)\n+                .loadObjectResults();\n+        dotConnect\n+                .setSQL(\"delete from QRTZ_EXCL_TRIGGERS where TRIGGER_NAME = ? and TRIGGER_GROUP = ?\")\n+                .addParam(IntegrityDataGenerationJob.TRIGGER_NAME)\n+                .addParam(IntegrityDataGenerationJob.TRIGGER_GROUP)\n+                .loadObjectResults();\n+        dotConnect\n+                .setSQL(\"delete from QRTZ_EXCL_JOB_DETAILS where JOB_NAME = ? and JOB_GROUP = ?\")\n+                .addParam(IntegrityDataGenerationJob.JOB_NAME)\n+                .addParam(IntegrityDataGenerationJob.JOB_GROUP)\n+                .loadObjectResults();\n+    }\n+\n+    @Test\n+    public void testGenerateIntegrationData() throws Exception {", "originalCommit": "3582e642600efd7982e82aef08539fcb17969afd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA5NzIzMA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r489097230", "bodyText": "Alright.", "author": "victoralfaro-dotcms", "createdAt": "2020-09-16T00:50:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk5MTQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk5Nzg0MA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r488997840", "bodyText": "good thing to rename the variable", "author": "dsilvam", "createdAt": "2020-09-15T21:48:14Z", "path": "dotCMS/src/main/java/com/dotcms/integritycheckers/IntegrityUtil.java", "diffHunk": "@@ -243,83 +256,216 @@ public static void unzipFile(InputStream zipFile, String outputDir) throws Excep\n         }\n     }\n \n+    /**\n+     * Creates a String representing the integrity data path based on provided endpointId.\n+     *\n+     * @param endpointId endpoint if\n+     * @return integrity data path\n+     */\n+    public static String getIntegrityDataPath(final String endpointId) {\n+        return ConfigUtils.getIntegrityPath() + File.separator + endpointId;\n+    }\n+\n+    /**\n+     * Creates a String representing the integrity data file path based on provided endpointId and the file name.\n+     * File names to be used: DataToCheck.zip, DataToFix.zip and DataStatus.properties.\n+     *\n+     * @param endpointId endpoint gid\n+     * @param dataFile data filename\n+     * @return path to filename\n+     */\n+    public static String getIntegrityDataFile(final String endpointId, final String dataFile) {\n+        return getIntegrityDataPath(endpointId) + File.separator + dataFile;\n+    }\n+\n+    /**\n+     * Tells whether a integrity file exists based on provided endpointId and the file name.\n+     *\n+     * @param endpointId endpoint id\n+     * @param dataFile data filename\n+     * @return path to filename\n+     */\n+    public static boolean doesIntegrityDataFileExist(final String endpointId, final String dataFile) {\n+        return new File(getIntegrityDataFile(endpointId, dataFile)).exists();\n+    }\n+\n+    /**\n+     * Gets a {@link IntegrityDataExecutionMetadata} instance based on provided endpoint id which contains metadata of the\n+     * integrity data generation execution.\n+     *\n+     * @param endpointId endpoint id\n+     * @return Optional wrapping the integrity generation  metadata\n+     */\n+    public static Optional<IntegrityDataExecutionMetadata> getIntegrityMetadata(final String endpointId) {\n+        final File statusFile = new File(getIntegrityDataFile(endpointId, INTEGRITY_DATA_STATUS_FILENAME));\n+        if (!statusFile.exists()) {\n+            return Optional.empty();\n+        }\n+\n+        final Properties statusData = new Properties();\n+        try {\n+            statusData.load(new FileInputStream(statusFile));\n+        } catch (IOException e) {\n+            Logger.error(\n+                    IntegrityUtil.class,\n+                    String.format(\"Could load status from %s\", statusFile.getAbsolutePath()),\n+                    e);\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(new IntegrityDataExecutionMetadata(\n+                statusData.getProperty(REQUESTER_ENDPOINT),\n+                statusData.getProperty(INTEGRITY_DATA_REQUEST_ID),\n+                statusData.getProperty(INTEGRITY_DATA_STATUS),\n+                statusData.getProperty(INTEGRITY_DATA_ERROR_MESSAGE)));\n+    }\n+\n+    /**\n+     * Saves a integrity data generation metadata in a to-be-discovered location so it can be read by concurrent parts\n+     * that need to know what is the status of the integrity data generation.\n+     * The data is saved as {@link Properties} file.\n+     *\n+     * @param integrityDataExecutionMetadata execution metadata\n+     */\n+    private static void saveIntegrityDataStatus(IntegrityDataExecutionMetadata integrityDataExecutionMetadata) {\n+        final String endpointId = integrityDataExecutionMetadata.getEndpointId();\n+        final File integrityDir = new File(getIntegrityDataPath(endpointId));\n+        if (!integrityDir.exists()) {\n+            integrityDir.mkdir();\n+        }\n+\n+        final File statusFile = new File(getIntegrityDataFile(endpointId, INTEGRITY_DATA_STATUS_FILENAME));\n+        if (statusFile.exists()) {\n+            statusFile.delete();\n+        }\n+\n+        final Properties statusData = new Properties();\n+        final BiConsumer<String, String> addData = (data, name) -> {\n+            if (StringUtils.isNotBlank(data)) {\n+                statusData.setProperty(name, data);\n+            }\n+        };\n+\n+        addData.accept(endpointId, REQUESTER_ENDPOINT);\n+        addData.accept(integrityDataExecutionMetadata.getRequestId(), INTEGRITY_DATA_REQUEST_ID);\n+        statusData.setProperty(INTEGRITY_DATA_STATUS, integrityDataExecutionMetadata.getProcessStatus().toString().toUpperCase());\n+        addData.accept(integrityDataExecutionMetadata.getErrorMessage(), INTEGRITY_DATA_ERROR_MESSAGE);\n+\n+        try (FileOutputStream output = new FileOutputStream(statusFile)) {\n+            statusData.store(output, null);\n+        } catch (IOException e) {\n+            throw new DotExecutionException(\n+                    String.format(\"Could not save status to %s\", statusFile.getAbsolutePath()),\n+                    e);\n+        }\n+    }\n+\n+    /**\n+     * Saves a integrity data generation metadata in a to-be-discovered location so it can be read by concurrent parts\n+     * that need to know what is the status of the integrity data generation.\n+     * Individual parameters are used to create a {@link IntegrityDataExecutionMetadata}.\n+     *\n+     * @param endpointId endpoint id\n+     * @param requestId request id\n+     * @param processStatus {@link IntegrityResource.ProcessStatus} instance to reflect the current status\n+     * @param errorMessage error message associated to detected error\n+     */\n+    public static void saveIntegrityDataStatus(final String endpointId,\n+                                               final String requestId,\n+                                               final IntegrityResource.ProcessStatus processStatus,\n+                                               final String errorMessage) {\n+        saveIntegrityDataStatus(new IntegrityDataExecutionMetadata(endpointId, requestId, processStatus, errorMessage));\n+    }\n+\n+    /**\n+     * Saves a integrity data generation metadata in a to-be-discovered location so it can be read by concurrent parts\n+     * that need to know what is the status of the integrity data generation.\n+     * Individual parameters are used to create a {@link IntegrityDataExecutionMetadata}.\n+     *\n+     * @param endpointId endpoint id\n+     * @param requestId request id\n+     * @param processStatus {@link IntegrityResource.ProcessStatus} instance to reflect the current status\n+     */\n+    public static void saveIntegrityDataStatus(final String endpointId,\n+                                               final String requestId,\n+                                               final IntegrityResource.ProcessStatus processStatus) {\n+        saveIntegrityDataStatus(endpointId, requestId, processStatus, null);\n+    }\n+\n     /**\n      * Creates all the CSV from End Point database table and store them inside\n      * zip file.\n      *\n      * @param endpointId\n      * @throws Exception\n      */\n-    public void generateDataToCheckZip(String endpointId) throws Exception {\n-        File zipFile = null;\n-\n-        try {\n-            if (!UtilMethods.isSet(endpointId))\n-                return;\n-\n-            final String outputPath = ConfigUtils.getIntegrityPath() + File.separator + endpointId;\n+    public static void generateDataToCheckZip(final String endpointId) {\n+        if (!UtilMethods.isSet(endpointId)) {\n+            Logger.error(IntegrityUtil.class, \"Endpoint was not provided\");\n+            return;\n+        }\n \n-            File dir = new File(outputPath);\n+        Logger.info(\n+                IntegrityUtil.class,\n+                String.format(\"Starting integrity data generation job for endpoint %s\", endpointId));\n \n+        File zipFile = null;\n+        try {\n+            final String outputPath = getIntegrityDataPath(endpointId);\n+            final File dir = new File(outputPath);\n             // if file doesn't exist, create it\n             if (!dir.exists()) {\n                 dir.mkdir();\n             }\n \n-            zipFile = new File(outputPath + File.separator\n-                    + IntegrityResource.INTEGRITY_DATA_TO_CHECK_ZIP_FILE_NAME);\n-\n-            try (OutputStream os = Files.newOutputStream(zipFile.toPath());\n-                    ZipOutputStream zos = new ZipOutputStream(os)) {\n-                IntegrityType[] types = IntegrityType.values();\n+            zipFile = new File(getIntegrityDataFile(endpointId, INTEGRITY_DATA_TO_CHECK_ZIP_FILENAME));\n+            try(final OutputStream os = Files.newOutputStream(zipFile.toPath());\n+                final ZipOutputStream zos = new ZipOutputStream(os)) {\n+                final IntegrityType[] types = IntegrityType.values();\n                 for (IntegrityType integrityType : types) {\n                     File fileToCheckCsvFile = null;\n \n                     try {\n-                        fileToCheckCsvFile = integrityType.getIntegrityChecker()\n-                        \t\t.generateCSVFile(outputPath);\n-\n-                        addToZipFile(fileToCheckCsvFile.getAbsolutePath(), zos,\n-                                integrityType.getDataToCheckCSVName());\n+                        fileToCheckCsvFile = integrityType.getIntegrityChecker().generateCSVFile(outputPath);\n+                        addToZipFile(fileToCheckCsvFile.getAbsolutePath(), zos, integrityType.getDataToCheckCSVName());\n                     } finally {\n-                        if (fileToCheckCsvFile != null && fileToCheckCsvFile.exists())\n+                        if (fileToCheckCsvFile != null && fileToCheckCsvFile.exists()) {\n                             fileToCheckCsvFile.delete();\n+                        }\n                     }\n                 }\n             }\n         } catch (Exception e) {\n-            if (zipFile != null && zipFile.exists())\n+            if (zipFile != null && zipFile.exists()) {\n                 zipFile.delete();\n+            }\n \n-            throw new Exception(e);\n+            throw new DotExecutionException(e);\n         }\n     }\n \n-    public void generateDataToFixZip(String endpointId, IntegrityType type) {\n+    public void generateDataToFixZip(final String endpointId, final IntegrityType type) {\n+        if (!UtilMethods.isSet(endpointId)) {\n+            return;\n+        }\n+\n         File dataToFixCsvFile = null;\n         File zipFile = null;\n-\n         try {\n-            if (!UtilMethods.isSet(endpointId))\n-                return;\n-\n-            final String outputPath = ConfigUtils.getIntegrityPath() + File.separator + endpointId;\n-\n-            File dir = new File(outputPath);\n-\n+            final String outputPath = getIntegrityDataPath(endpointId);\n+            final File dir = new File(outputPath);\n             // if file doesn't exist, create it\n             if (!dir.exists()) {\n                 dir.mkdir();\n             }\n \n-            zipFile = new File(outputPath + File.separator\n-                    + IntegrityResource.INTEGRITY_DATA_TO_FIX_ZIP_FILE_NAME);\n-            try (OutputStream os = Files.newOutputStream(zipFile.toPath());\n-                    ZipOutputStream zos = new ZipOutputStream(os)) {\n+            zipFile = new File(getIntegrityDataFile(endpointId, INTEGRITY_DATA_TO_FIX_ZIP_FILENAME));\n+            try (OutputStream outputStream = Files.newOutputStream(zipFile.toPath());\n+                 ZipOutputStream zipOutputStream = new ZipOutputStream(outputStream)) {\n                 // create Folders CSV\n                 dataToFixCsvFile = generateDataToFixCSV(outputPath, endpointId, type);\n \n-                addToZipFile(dataToFixCsvFile.getAbsolutePath(), zos, type.getDataToFixCSVName());\n+                addToZipFile(dataToFixCsvFile.getAbsolutePath(), zipOutputStream, type.getDataToFixCSVName());", "originalCommit": "3582e642600efd7982e82aef08539fcb17969afd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2MDg5Nw==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r489160897", "bodyText": "this is a static method, not sure if the context annotation make sense here", "author": "jdotcms", "createdAt": "2020-09-16T04:55:07Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -153,68 +149,104 @@ private Response postWithEndpointState(String endpointId, String url, MediaType\n \t\treturn response;\n \t}\n \n+    /**\n+     * Resolves remote IP address from request.\n+     * @param request {@link HttpServletRequest}\n+     * @return a String representing the remote IP address (or hostname)\n+     */\n+    private static String resolveRemoteIp(@Context final HttpServletRequest request) {", "originalCommit": "19487250aaad39a2eb9e74175f2c6fa7a2c81682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk2ODE0MQ==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r490968141", "bodyText": "Removed.", "author": "victoralfaro-dotcms", "createdAt": "2020-09-18T13:57:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2MDg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2Mzc1MA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r489163750", "bodyText": "This method looks very bad I would separated in a new class as a Runnable and do some refactoring and transaction handling etc", "author": "jdotcms", "createdAt": "2020-09-16T05:00:18Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -373,81 +463,75 @@ public Response checkIntegrity(@Context HttpServletRequest httpServletRequest, @\n             return response( \"Error checking existence of integrity data\" , true );\n         }\n \n-        try {\n-\n-            //Setting the process status\n-            setStatus( httpServletRequest, endpointId, ProcessStatus.PROCESSING );\n+        //Setting the process status\n+        setStatus(httpServletRequest, endpointId, ProcessStatus.PROCESSING);\n \n+        try {\n             final PublishingEndPoint endpoint = APILocator.getPublisherEndPointAPI().findEndPointById(endpointId);\n             final Optional<String> authToken = PushPublisher.retriveEndpointKeyDigest(endpoint);\n-            if(!authToken.isPresent()) {\n+            if (!authToken.isPresent()) {\n               Logger.warn(IntegrityResource.class, \"No Auth Token set for endpoint:\" + endpointId);\n               return response(\"No Auth Token set for endpoint\", true);\n             }\n-            FormDataMultiPart form = new FormDataMultiPart();\n-            form.field(\"AUTH_TOKEN\",authToken.get());\n \n-            //Sending bundle to endpoint\n-            String url = endpoint.toURL()+\"/api/integrity/generateintegritydata/\";\n+            final FormDataMultiPart form = new FormDataMultiPart();\n+            form.field(\"AUTH_TOKEN\", authToken.get());\n \n-            Response response = postWithEndpointState(\n-            \tendpoint.getId(), url, MediaType.TEXT_PLAIN_TYPE, Entity.entity(form, form.getMediaType())\n+            //Sending bundle to endpoint\n+            final String url = endpoint.toURL() + \"/api/integrity/generateintegritydata/\";\n+            final Response response = postWithEndpointState(\n+                    endpoint.getId(),\n+                    url,\n+                    MediaType.TEXT_PLAIN_TYPE,\n+                    Entity.entity(form, form.getMediaType())\n             );\n \n-            if(response.getStatus() == HttpStatus.SC_OK) {\n+            if (response.getStatus() == HttpStatus.SC_OK) {\n                 final String integrityDataRequestID = response.readEntity(String.class);\n-\n-                Thread integrityDataRequestChecker = new Thread() {\n-\n+                final Thread integrityDataRequestChecker = new Thread() {", "originalCommit": "19487250aaad39a2eb9e74175f2c6fa7a2c81682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMyOTcwOA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r490329708", "bodyText": "You are right. I wanted to move it out of the IntegrityResource class from the beginning but then I forgot.", "author": "victoralfaro-dotcms", "createdAt": "2020-09-17T15:09:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2Mzc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk2ODAyMA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r490968020", "bodyText": "Moved.", "author": "victoralfaro-dotcms", "createdAt": "2020-09-18T13:57:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2Mzc1MA=="}], "type": "inlineReview"}, {"oid": "39039e53e5d35451c7a80124eb3f009b92860481", "url": "https://github.com/dotCMS/core/commit/39039e53e5d35451c7a80124eb3f009b92860481", "message": "Attempt to fix integration test", "committedDate": "2020-09-17T21:28:47Z", "type": "forcePushed"}, {"oid": "380e059dcd1202c2d721c2b3ae8e10d2bce152f1", "url": "https://github.com/dotCMS/core/commit/380e059dcd1202c2d721c2b3ae8e10d2bce152f1", "message": "18554: Introducing IntegritiGenerationDataJob to support multi node receivers creation of file and query process for status", "committedDate": "2020-09-17T21:49:50Z", "type": "commit"}, {"oid": "2f44d02fac21853b75748443f26618c48ad12f42", "url": "https://github.com/dotCMS/core/commit/2f44d02fac21853b75748443f26618c48ad12f42", "message": "Applying codacy feedback", "committedDate": "2020-09-17T21:52:31Z", "type": "commit"}, {"oid": "506d9fdd15d52dec15f170deb09a0f97f85f3fb3", "url": "https://github.com/dotCMS/core/commit/506d9fdd15d52dec15f170deb09a0f97f85f3fb3", "message": "Applying more feedback\n\nAttempt to fix integration test", "committedDate": "2020-09-17T21:52:35Z", "type": "forcePushed"}, {"oid": "06afc2bc1630fc6c8d3a16d314bddf753f0a1a2f", "url": "https://github.com/dotCMS/core/commit/06afc2bc1630fc6c8d3a16d314bddf753f0a1a2f", "message": "Applying more feedback\n\nAttempt to fix integration test", "committedDate": "2020-09-17T22:22:51Z", "type": "forcePushed"}, {"oid": "69d6e4a25b1ffd22ecd1778d0921b94494530d94", "url": "https://github.com/dotCMS/core/commit/69d6e4a25b1ffd22ecd1778d0921b94494530d94", "message": "Applying more feedback\n\nAttempt to fix integration test", "committedDate": "2020-09-18T01:58:18Z", "type": "forcePushed"}, {"oid": "823395c96667b62ed06c7a6d91c7c5575a4af002", "url": "https://github.com/dotCMS/core/commit/823395c96667b62ed06c7a6d91c7c5575a4af002", "message": "Applying more feedback\n\nAttempt to fix integration test", "committedDate": "2020-09-18T02:55:47Z", "type": "forcePushed"}, {"oid": "a2615465da169dc121d453829b52538c2bf3f3c2", "url": "https://github.com/dotCMS/core/commit/a2615465da169dc121d453829b52538c2bf3f3c2", "message": "Applying more feedback\n\nAttempt to fix integration test", "committedDate": "2020-09-18T13:56:33Z", "type": "commit"}, {"oid": "a2615465da169dc121d453829b52538c2bf3f3c2", "url": "https://github.com/dotCMS/core/commit/a2615465da169dc121d453829b52538c2bf3f3c2", "message": "Applying more feedback\n\nAttempt to fix integration test", "committedDate": "2020-09-18T13:56:33Z", "type": "forcePushed"}, {"oid": "27f755491956ce8c6f990869e5a2013e8af4d886", "url": "https://github.com/dotCMS/core/commit/27f755491956ce8c6f990869e5a2013e8af4d886", "message": "Fix broken of tests", "committedDate": "2020-09-18T20:17:46Z", "type": "forcePushed"}, {"oid": "a27c0efc8d35b3952112e417badb6159f0595c9a", "url": "https://github.com/dotCMS/core/commit/a27c0efc8d35b3952112e417badb6159f0595c9a", "message": "Fix broken of tests", "committedDate": "2020-09-18T22:48:50Z", "type": "commit"}, {"oid": "a27c0efc8d35b3952112e417badb6159f0595c9a", "url": "https://github.com/dotCMS/core/commit/a27c0efc8d35b3952112e417badb6159f0595c9a", "message": "Fix broken of tests", "committedDate": "2020-09-18T22:48:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NjQyMA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492166420", "bodyText": "we should annotate IntegrityUtil.completeDiscardConflicts as @WrapInTransaction", "author": "dsilvam", "createdAt": "2020-09-21T15:48:37Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityDataRequestChecker.java", "diffHunk": "@@ -0,0 +1,188 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.repackage.org.apache.commons.httpclient.HttpStatus;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotHibernateException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.media.multipart.FormDataMultiPart;\n+\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+\n+/**\n+ * Thread to constantly check the integrity check status by hitting on receiver host endpoint.\n+ * Anything but {@link com.dotcms.rest.IntegrityResource.ProcessStatus}.PROCESSING is considered that the integrity data\n+ * generation process is done.\n+ */\n+public class IntegrityDataRequestChecker implements Runnable {\n+\n+    private final String authToken;\n+    private final PublishingEndPoint endpoint;\n+    private final String integrityDataRequestId;\n+    private final HttpSession session;\n+    private final InitDataObject initData;\n+\n+    public IntegrityDataRequestChecker(String authToken,\n+                                       PublishingEndPoint endpoint,\n+                                       String integrityDataRequestId,\n+                                       HttpSession session,\n+                                       InitDataObject initData) {\n+        this.authToken = authToken;\n+        this.endpoint = endpoint;\n+        this.integrityDataRequestId = integrityDataRequestId;\n+        this.session = session;\n+        this.initData = initData;\n+    }\n+\n+    @Override\n+    public void run() {\n+        final Map<String, String> paramsMap = initData.getParamsMap();\n+        final String endpointId = paramsMap.get(\"endpoint\");\n+        final User loggedUser = initData.getUser();\n+        final FormDataMultiPart form = new FormDataMultiPart();\n+        form.field(\"AUTH_TOKEN\",authToken);\n+        form.field(\"REQUEST_ID\", integrityDataRequestId);\n+        final String url = endpoint.toURL() + \"/api/integrity/getintegritydata/\";\n+\n+        boolean processing = true;\n+        while(processing) {\n+            final Response response = IntegrityResource.postWithEndpointState(\n+                    endpoint.getId(),\n+                    url,\n+                    new MediaType(\"application\", \"zip\"),\n+                    Entity.entity(form, form.getMediaType()));\n+\n+            if (response.getStatus() == HttpStatus.SC_OK) {\n+                processing = false;\n+\n+                final String outputDir = IntegrityUtil.getIntegrityDataPath(endpoint.getId());\n+                final InputStream zipFile = response.readEntity(InputStream.class);\n+\n+                try {\n+                    IntegrityUtil.unzipFile(zipFile, outputDir);\n+                } catch(Exception e) {\n+                    //Special handling if the thread was interrupted\n+                    if (e instanceof InterruptedException) {\n+                        //Setting the process status\n+                        IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.CANCELLED, null);\n+                        final String message = \"Requested interruption of the integrity checking process [unzipping Integrity Data] by the user.\";\n+                        Logger.debug(IntegrityResource.class, message, e);\n+                        throw new RuntimeException(message, e);\n+                    }\n+\n+                    //Setting the process status\n+                    IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.ERROR, null);\n+                    final String message = \"Error while unzipping Integrity Data\";\n+                    Logger.error(IntegrityResource.class, message, e);\n+                    throw new RuntimeException(message, e);\n+                } finally {\n+                    if (zipFile != null) {\n+                        try {\n+                            zipFile.close();\n+                        } catch ( IOException e ) {\n+                            Logger.warn(IntegrityResource.class, \"Error closing zip file stream\", e);\n+                        }\n+                    }\n+                }\n+\n+                // set session variable\n+                // call IntegrityChecker\n+                boolean conflictPresent ;\n+                try {\n+                    HibernateUtil.startTransaction();\n+                    IntegrityUtil.completeDiscardConflicts(endpointId);", "originalCommit": "a27c0efc8d35b3952112e417badb6159f0595c9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE5MTkxOA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492191918", "bodyText": "Same as below.", "author": "victoralfaro-dotcms", "createdAt": "2020-09-21T16:27:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NjQyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NjUzMw==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492166533", "bodyText": "we should annotate IntegrityUtil.completeDiscardConflicts as @WrapInTransaction", "author": "dsilvam", "createdAt": "2020-09-21T15:48:45Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityDataRequestChecker.java", "diffHunk": "@@ -0,0 +1,188 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.repackage.org.apache.commons.httpclient.HttpStatus;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotHibernateException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.media.multipart.FormDataMultiPart;\n+\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+\n+/**\n+ * Thread to constantly check the integrity check status by hitting on receiver host endpoint.\n+ * Anything but {@link com.dotcms.rest.IntegrityResource.ProcessStatus}.PROCESSING is considered that the integrity data\n+ * generation process is done.\n+ */\n+public class IntegrityDataRequestChecker implements Runnable {\n+\n+    private final String authToken;\n+    private final PublishingEndPoint endpoint;\n+    private final String integrityDataRequestId;\n+    private final HttpSession session;\n+    private final InitDataObject initData;\n+\n+    public IntegrityDataRequestChecker(String authToken,\n+                                       PublishingEndPoint endpoint,\n+                                       String integrityDataRequestId,\n+                                       HttpSession session,\n+                                       InitDataObject initData) {\n+        this.authToken = authToken;\n+        this.endpoint = endpoint;\n+        this.integrityDataRequestId = integrityDataRequestId;\n+        this.session = session;\n+        this.initData = initData;\n+    }\n+\n+    @Override\n+    public void run() {\n+        final Map<String, String> paramsMap = initData.getParamsMap();\n+        final String endpointId = paramsMap.get(\"endpoint\");\n+        final User loggedUser = initData.getUser();\n+        final FormDataMultiPart form = new FormDataMultiPart();\n+        form.field(\"AUTH_TOKEN\",authToken);\n+        form.field(\"REQUEST_ID\", integrityDataRequestId);\n+        final String url = endpoint.toURL() + \"/api/integrity/getintegritydata/\";\n+\n+        boolean processing = true;\n+        while(processing) {\n+            final Response response = IntegrityResource.postWithEndpointState(\n+                    endpoint.getId(),\n+                    url,\n+                    new MediaType(\"application\", \"zip\"),\n+                    Entity.entity(form, form.getMediaType()));\n+\n+            if (response.getStatus() == HttpStatus.SC_OK) {\n+                processing = false;\n+\n+                final String outputDir = IntegrityUtil.getIntegrityDataPath(endpoint.getId());\n+                final InputStream zipFile = response.readEntity(InputStream.class);\n+\n+                try {\n+                    IntegrityUtil.unzipFile(zipFile, outputDir);\n+                } catch(Exception e) {\n+                    //Special handling if the thread was interrupted\n+                    if (e instanceof InterruptedException) {\n+                        //Setting the process status\n+                        IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.CANCELLED, null);\n+                        final String message = \"Requested interruption of the integrity checking process [unzipping Integrity Data] by the user.\";\n+                        Logger.debug(IntegrityResource.class, message, e);\n+                        throw new RuntimeException(message, e);\n+                    }\n+\n+                    //Setting the process status\n+                    IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.ERROR, null);\n+                    final String message = \"Error while unzipping Integrity Data\";\n+                    Logger.error(IntegrityResource.class, message, e);\n+                    throw new RuntimeException(message, e);\n+                } finally {\n+                    if (zipFile != null) {\n+                        try {\n+                            zipFile.close();\n+                        } catch ( IOException e ) {\n+                            Logger.warn(IntegrityResource.class, \"Error closing zip file stream\", e);\n+                        }\n+                    }\n+                }\n+\n+                // set session variable\n+                // call IntegrityChecker\n+                boolean conflictPresent ;\n+                try {\n+                    HibernateUtil.startTransaction();\n+                    IntegrityUtil.completeDiscardConflicts(endpointId);\n+                    HibernateUtil.commitTransaction();\n+\n+                    HibernateUtil.startTransaction();\n+                    conflictPresent = IntegrityUtil.completeCheckIntegrity(endpointId);", "originalCommit": "a27c0efc8d35b3952112e417badb6159f0595c9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE5MTg0Mw==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492191843", "bodyText": "Removed and using @WrapInTransaction annotation.", "author": "victoralfaro-dotcms", "createdAt": "2020-09-21T16:27:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NjUzMw=="}], "type": "inlineReview"}, {"oid": "3732e947085bd528c7950a2fbd8153b17d71324d", "url": "https://github.com/dotCMS/core/commit/3732e947085bd528c7950a2fbd8153b17d71324d", "message": "Replacing manual transaction handling by @WrapInTransaction", "committedDate": "2020-09-21T16:24:39Z", "type": "commit"}, {"oid": "bec50a104819f020e85de9a754b814af4422bed3", "url": "https://github.com/dotCMS/core/commit/bec50a104819f020e85de9a754b814af4422bed3", "message": "Replacing manual transaction handling by @WrapInTransaction", "committedDate": "2020-09-21T16:26:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjc1MA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222750", "bodyText": "Codacy found an issue: Avoid instantiating FileInputStream, FileOutputStream, FileReader, or FileWriter", "author": "dev-dotcms", "createdAt": "2020-09-21T17:19:11Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/quartz/job/IntegrityDataGenerationJobTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.dotmarketing.quartz.job;\n+\n+import com.dotcms.IntegrationTestBase;\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.publisher.endpoint.bean.impl.PushPublishingEndPoint;\n+import com.dotcms.rest.IntegrityResource;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.exception.DotDataException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import com.tngtech.java.junit.dataprovider.DataProviderRunner;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.quartz.JobDataMap;\n+import org.quartz.JobDetail;\n+import org.quartz.JobExecutionContext;\n+import org.quartz.SchedulerException;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * @author victor\n+ */\n+@RunWith(DataProviderRunner.class)\n+public class IntegrityDataGenerationJobTest extends IntegrationTestBase {\n+\n+    private IntegrityDataGenerationJob integrityDataGenerationJob;\n+    private PublishingEndPoint endpoint;\n+    private String requestId;\n+\n+    @BeforeClass\n+    public static void beforeClass() throws Exception {\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void before() throws DotDataException {\n+        integrityDataGenerationJob = new IntegrityDataGenerationJob();\n+        endpoint = new PushPublishingEndPoint();\n+        endpoint.setId(UUID.randomUUID().toString());\n+        requestId = UUID.randomUUID().toString();\n+\n+        DotConnect dotConnect = new DotConnect();\n+        dotConnect\n+                .setSQL(\"delete from QRTZ_EXCL_SIMPLE_TRIGGERS where TRIGGER_NAME = ? and TRIGGER_GROUP = ?\")\n+                .addParam(IntegrityDataGenerationJob.TRIGGER_NAME)\n+                .addParam(IntegrityDataGenerationJob.TRIGGER_GROUP)\n+                .loadObjectResults();\n+        dotConnect\n+                .setSQL(\"delete from QRTZ_EXCL_TRIGGERS where TRIGGER_NAME = ? and TRIGGER_GROUP = ?\")\n+                .addParam(IntegrityDataGenerationJob.TRIGGER_NAME)\n+                .addParam(IntegrityDataGenerationJob.TRIGGER_GROUP)\n+                .loadObjectResults();\n+        dotConnect\n+                .setSQL(\"delete from QRTZ_EXCL_JOB_DETAILS where JOB_NAME = ? and JOB_GROUP = ?\")\n+                .addParam(IntegrityDataGenerationJob.JOB_NAME)\n+                .addParam(IntegrityDataGenerationJob.JOB_GROUP)\n+                .loadObjectResults();\n+    }\n+\n+    /**\n+     * Method to test: IntegrityDataGenerationJob.run() which generates integrity data generation.\n+     * Given Scenario: Given an integrity data generation is triggered for a provided endpoint and request id.\n+     * ExpectedResult: to have Quartz job tables populated as well as the integrity data file created with its status file.\n+     *\n+     */\n+    @Test\n+    public void test_generateIntegrationData() throws Exception {\n+        runJob(Sneaky.sneaked(() -> integrityDataGenerationJob.run(getJobContext())));\n+\n+        assertTrue(new File(\n+                IntegrityUtil.getIntegrityDataFilePath(\n+                        endpoint.getId(),\n+                        IntegrityUtil.INTEGRITY_DATA_TO_CHECK_ZIP_FILENAME))\n+                .exists());\n+        assertTrue(new File(\n+                IntegrityUtil.getIntegrityDataFilePath(endpoint.getId(), IntegrityUtil.INTEGRITY_DATA_STATUS_FILENAME))\n+                .exists());\n+        assertStatus(IntegrityResource.ProcessStatus.FINISHED.toString());\n+    }\n+\n+    /**\n+     * Method to test: IntegrityDataGenerationJob.interrupt() which is run when job is attempted to be interrupted.\n+     * Given Scenario: Given an integrity data generation is triggered and running for a provided endpoint and request id.\n+     * ExpectedResult: to have a status file with the CANCELLED status.\n+     *\n+     */\n+    @Test\n+    public void test_interrupt() throws Exception {\n+        integrityDataGenerationJob = new IntegrityDataGenerationJob() {\n+            @Override\n+            public void run(JobExecutionContext jobContext) {\n+                try {\n+                    Thread.sleep(4000);\n+                } catch (InterruptedException e) {}\n+                super.run(jobContext);\n+            }\n+        };\n+\n+        runJob(Sneaky.sneaked(() -> integrityDataGenerationJob.run(getJobContext())));\n+        interruptJob(Sneaky.sneaked(() -> integrityDataGenerationJob.interrupt()));\n+        assertStatus(\n+                IntegrityResource.ProcessStatus.CANCELLED.name(),\n+                IntegrityResource.ProcessStatus.FINISHED.name());\n+    }\n+\n+    private void runJob(Runnable runnable) {\n+        runnable.run();\n+    }\n+\n+    private void interruptJob(Runnable runnable) throws SchedulerException {\n+        IntegrityDataGenerationJob.getJobScheduler().interrupt(\n+                IntegrityDataGenerationJob.JOB_NAME,\n+                IntegrityDataGenerationJob.JOB_GROUP);\n+        runnable.run();\n+    }\n+\n+    private JobExecutionContext getJobContext() throws SchedulerException {\n+        return new JobExecutionContext(\n+                IntegrityDataGenerationJob.getJobScheduler(),\n+                new TestJobExecutor.TriggerFiredBundleTest(getJobDetail(endpoint, requestId)),\n+                integrityDataGenerationJob);\n+    }\n+\n+    private JobDetail getJobDetail(PublishingEndPoint endpoint, String requestId) {\n+        JobDataMap jobDataMap = new JobDataMap();\n+        jobDataMap.put(IntegrityUtil.REQUESTER_ENDPOINT, endpoint);\n+        jobDataMap.put(IntegrityUtil.INTEGRITY_DATA_REQUEST_ID, requestId);\n+\n+        final JobDetail jobDetail = new JobDetail(\n+                IntegrityDataGenerationJob.JOB_NAME,\n+                IntegrityDataGenerationJob.JOB_GROUP, IntegrityDataGenerationJob.class);\n+        jobDetail.setJobDataMap(jobDataMap);\n+        jobDetail.setDurability(false);\n+        jobDetail.setVolatility(false);\n+        jobDetail.setRequestsRecovery(true);\n+\n+        return jobDetail;\n+    }\n+\n+    private void assertStatus(String status) throws IOException {\n+        Properties properties = new Properties();\n+        properties.load(new FileInputStream(IntegrityUtil.getIntegrityDataFilePath(", "originalCommit": "bec50a104819f020e85de9a754b814af4422bed3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjc2MA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222760", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "author": "dev-dotcms", "createdAt": "2020-09-21T17:19:12Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/quartz/job/IntegrityDataGenerationJobTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.dotmarketing.quartz.job;\n+\n+import com.dotcms.IntegrationTestBase;\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.publisher.endpoint.bean.impl.PushPublishingEndPoint;\n+import com.dotcms.rest.IntegrityResource;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.exception.DotDataException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import com.tngtech.java.junit.dataprovider.DataProviderRunner;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.quartz.JobDataMap;\n+import org.quartz.JobDetail;\n+import org.quartz.JobExecutionContext;\n+import org.quartz.SchedulerException;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * @author victor\n+ */\n+@RunWith(DataProviderRunner.class)\n+public class IntegrityDataGenerationJobTest extends IntegrationTestBase {\n+\n+    private IntegrityDataGenerationJob integrityDataGenerationJob;\n+    private PublishingEndPoint endpoint;\n+    private String requestId;\n+\n+    @BeforeClass\n+    public static void beforeClass() throws Exception {", "originalCommit": "bec50a104819f020e85de9a754b814af4422bed3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjc3OA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222778", "bodyText": "Codacy found an issue: Classes implementing Serializable should set a serialVersionUID", "author": "dev-dotcms", "createdAt": "2020-09-21T17:19:13Z", "path": "dotCMS/src/main/java/com/dotcms/integritycheckers/IntegrityUtil.java", "diffHunk": "@@ -625,4 +792,50 @@ public boolean completeCheckIntegrity(final String endpointId) throws Exception\n \n         return existConflicts;\n     }\n+\n+    /**\n+     * Integrity data generation metadata bean to be saved.\n+     */\n+    public static class IntegrityDataExecutionMetadata implements Serializable {", "originalCommit": "bec50a104819f020e85de9a754b814af4422bed3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjc5Mg==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222792", "bodyText": "Codacy found an issue: Avoid throwing raw exception types.", "author": "dev-dotcms", "createdAt": "2020-09-21T17:19:14Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityDataRequestChecker.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.repackage.org.apache.commons.httpclient.HttpStatus;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotHibernateException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.media.multipart.FormDataMultiPart;\n+\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+\n+/**\n+ * Thread to constantly check the integrity check status by hitting on receiver host endpoint.\n+ * Anything but {@link com.dotcms.rest.IntegrityResource.ProcessStatus}.PROCESSING is considered that the integrity data\n+ * generation process is done.\n+ */\n+public class IntegrityDataRequestChecker implements Runnable {\n+\n+    private final String authToken;\n+    private final PublishingEndPoint endpoint;\n+    private final String integrityDataRequestId;\n+    private final HttpSession session;\n+    private final InitDataObject initData;\n+\n+    public IntegrityDataRequestChecker(String authToken,\n+                                       PublishingEndPoint endpoint,\n+                                       String integrityDataRequestId,\n+                                       HttpSession session,\n+                                       InitDataObject initData) {\n+        this.authToken = authToken;\n+        this.endpoint = endpoint;\n+        this.integrityDataRequestId = integrityDataRequestId;\n+        this.session = session;\n+        this.initData = initData;\n+    }\n+\n+    @Override\n+    public void run() {\n+        final Map<String, String> paramsMap = initData.getParamsMap();\n+        final String endpointId = paramsMap.get(\"endpoint\");\n+        final User loggedUser = initData.getUser();\n+        final FormDataMultiPart form = new FormDataMultiPart();\n+        form.field(\"AUTH_TOKEN\",authToken);\n+        form.field(\"REQUEST_ID\", integrityDataRequestId);\n+        final String url = endpoint.toURL() + \"/api/integrity/getintegritydata/\";\n+\n+        boolean processing = true;\n+        while(processing) {\n+            final Response response = IntegrityResource.postWithEndpointState(\n+                    endpoint.getId(),\n+                    url,\n+                    new MediaType(\"application\", \"zip\"),\n+                    Entity.entity(form, form.getMediaType()));\n+\n+            if (response.getStatus() == HttpStatus.SC_OK) {\n+                processing = false;\n+\n+                final String outputDir = IntegrityUtil.getIntegrityDataPath(endpoint.getId());\n+                final InputStream zipFile = response.readEntity(InputStream.class);\n+\n+                try {\n+                    IntegrityUtil.unzipFile(zipFile, outputDir);\n+                } catch(Exception e) {\n+                    //Special handling if the thread was interrupted\n+                    if (e instanceof InterruptedException) {\n+                        //Setting the process status\n+                        IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.CANCELLED, null);\n+                        final String message = \"Requested interruption of the integrity checking process [unzipping Integrity Data] by the user.\";\n+                        Logger.debug(IntegrityResource.class, message, e);\n+                        throw new RuntimeException(message, e);", "originalCommit": "bec50a104819f020e85de9a754b814af4422bed3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjc5OQ==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222799", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "author": "dev-dotcms", "createdAt": "2020-09-21T17:19:15Z", "path": "dotCMS/src/main/java/com/dotcms/integritycheckers/IntegrityUtil.java", "diffHunk": "@@ -614,7 +780,8 @@ public void completeDiscardConflicts(final String endpointId) throws DotDataExce\n      * @return is there is at least one conflict returns true, otherwise false\n      * @throws Exception\n      */\n-    public boolean completeCheckIntegrity(final String endpointId) throws Exception {\n+    @WrapInTransaction\n+    public static boolean completeCheckIntegrity(final String endpointId) throws Exception {", "originalCommit": "bec50a104819f020e85de9a754b814af4422bed3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjgxMQ==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222811", "bodyText": "Codacy found an issue: The String literal \"params\" appears 6 times in this file; the first occurrence is on line 328", "author": "dev-dotcms", "createdAt": "2020-09-21T17:19:16Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -332,38 +421,37 @@ public void write(OutputStream output) throws IOException, WebApplicationExcepti\n     @GET\n     @Path(\"/checkintegrity/{params:.*}\")\n     @Produces (MediaType.APPLICATION_JSON)\n-    public Response checkIntegrity(@Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam(\"params\") String params)  {\n-        InitDataObject initData = webResource.init(params, httpServletRequest, httpServletResponse, true, null);\n-\n-        Map<String, String> paramsMap = initData.getParamsMap();\n-\n+    public Response checkIntegrity(@Context final HttpServletRequest httpServletRequest,\n+                                   @Context final HttpServletResponse httpServletResponse,\n+                                   @PathParam(\"params\") final String params)  {", "originalCommit": "bec50a104819f020e85de9a754b814af4422bed3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjgyNA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222824", "bodyText": "Codacy found an issue: [The String literal \"Error checking the integrity process status for End Point server: \" appears 5 times in this file; the first occurrence is on line 667", "author": "dev-dotcms", "createdAt": "2020-09-21T17:19:17Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -570,98 +556,104 @@ public void run(){\n     @GET\n     @Path (\"/cancelIntegrityProcess/{params:.*}\")\n     @Produces (MediaType.APPLICATION_JSON)\n-    public Response cancelIntegrityProcess ( @Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam (\"params\") String params ) throws JSONException {\n-\n-        StringBuilder responseMessage = new StringBuilder();\n-\n-        InitDataObject initData = webResource.init(params, httpServletRequest, httpServletResponse, true, null);\n-        Map<String, String> paramsMap = initData.getParamsMap();\n+    public Response cancelIntegrityProcess(@Context final HttpServletRequest httpServletRequest,\n+                                           @Context final HttpServletResponse httpServletResponse,\n+                                           @PathParam(\"params\") final String params ) {\n+        final StringBuilder responseMessage = new StringBuilder();\n+        final InitDataObject initData = webResource.init(params, httpServletRequest, httpServletResponse, true, null);\n+        final Map<String, String> paramsMap = initData.getParamsMap();\n \n         //Validate the parameters\n-        String endpointId = paramsMap.get( \"endpoint\" );\n-        if ( !UtilMethods.isSet( endpointId ) ) {\n-            Response.ResponseBuilder responseBuilder = Response.status( HttpStatus.SC_BAD_REQUEST );\n-            responseBuilder.entity( responseMessage.append( \"Error: \" ).append( \"endpoint\" ).append( \" is a required Field.\" ) );\n-\n+        final String endpointId = paramsMap.get(\"endpoint\");\n+        if (!UtilMethods.isSet(endpointId)) {\n+            final Response.ResponseBuilder responseBuilder = Response.status(HttpStatus.SC_BAD_REQUEST);\n+            responseBuilder.entity(responseMessage.append(\"Error: endpoint is a required Field.\"));\n             return responseBuilder.build();\n         }\n \n         try {\n-            JSONObject jsonResponse = new JSONObject();\n+            final JSONObject jsonResponse = new JSONObject();\n+            final HttpSession session = httpServletRequest.getSession();\n \n-            HttpSession session = httpServletRequest.getSession();\n             //Verify if we have something set on the session\n             if ( session.getAttribute( \"integrityCheck_\" + endpointId ) == null ) {\n                 //And prepare the response\n-                jsonResponse.put( \"success\", false );\n-                jsonResponse.put( \"message\", \"No checking process found for End point server [\" + endpointId + \"]\" );\n-            } else if ( session.getAttribute( \"integrityThread_\" + endpointId ) == null ) {\n+                jsonResponse.put(\"success\", false);\n+                jsonResponse.put(\"message\", \"No checking process found for End point server [\" + endpointId + \"]\");\n+            } else if (session.getAttribute(\"integrityThread_\" + endpointId) == null) {\n                 //And prepare the response\n-                jsonResponse.put( \"success\", false );\n-                jsonResponse.put( \"message\", \"No checking process found for End point server [\" + endpointId + \"]\" );\n+                jsonResponse.put(\"success\", false);\n+                jsonResponse.put(\"message\", \"No checking process found for End point server [\" + endpointId + \"]\");\n             } else {\n-\n                 //Search for the status on session\n-                ProcessStatus status = (ProcessStatus) session.getAttribute( \"integrityCheck_\" + endpointId );\n+                final ProcessStatus status = (ProcessStatus) session.getAttribute(\"integrityCheck_\" + endpointId);\n \n                 //And prepare the response\n-                jsonResponse.put( \"endPoint\", endpointId );\n-                if ( status == ProcessStatus.PROCESSING ) {\n-\n-                    //Get the thread associated to this endpoint and the integrity request id\n-                    Thread runningThread = (Thread) session.getAttribute( \"integrityThread_\" + endpointId );\n-                    String integrityDataRequestId = (String) session.getAttribute( \"integrityDataRequest_\" + endpointId );\n-\n+                jsonResponse.put(\"endPoint\", endpointId);\n+                if (status == ProcessStatus.PROCESSING) {\n                     //Find the registered auth token in order to connect to the end point server\n-                    PublishingEndPoint endpoint = APILocator.getPublisherEndPointAPI().findEndPointById( endpointId );\n-                    Optional<String> authToken = PushPublisher.retriveEndpointKeyDigest(endpoint);\n+                    final PublishingEndPoint endpoint = APILocator.getPublisherEndPointAPI().findEndPointById(endpointId);\n+                    final Optional<String> authToken = PushPublisher.retriveEndpointKeyDigest(endpoint);\n                     if(!authToken.isPresent()) {\n-                      return Response.status( HttpStatus.SC_BAD_REQUEST )\n-                          .entity( responseMessage.append( \"Error: endpoint requires an authorization key\" ) ).build();\n-\n+                        return Response\n+                                .status(HttpStatus.SC_BAD_REQUEST)\n+                                .entity(responseMessage.append(\"Error: endpoint requires an authorization key\"))\n+                                .build();\n                     }\n-                    FormDataMultiPart form = new FormDataMultiPart();\n-                    form.field( \"AUTH_TOKEN\", authToken.get() );\n-                    form.field( \"REQUEST_ID\", integrityDataRequestId );\n \n+                    final String integrityDataRequestId = (String) session.getAttribute( \"integrityDataRequest_\" + endpointId );\n+                    final FormDataMultiPart form = new FormDataMultiPart();\n+                    form.field(\"AUTH_TOKEN\", authToken.get());\n+                    form.field(\"REQUEST_ID\", integrityDataRequestId);\n                     //Prepare the connection\n-                    String url = endpoint.toURL() + \"/api/integrity/cancelIntegrityProcessOnEndpoint/\";\n-\n+                    final String url = endpoint.toURL() + \"/api/integrity/cancelIntegrityProcessOnEndpoint/\";\n                     //Execute the call\n-                \tResponse response = postWithEndpointState(\n-                \t\tendpoint.getId(), url, MediaType.APPLICATION_JSON_TYPE, Entity.entity(form, form.getMediaType())\n-                \t);\n+                    final Response response = postWithEndpointState(\n+                            endpoint.getId(),\n+                            url,\n+                            MediaType.APPLICATION_JSON_TYPE,\n+                            Entity.entity(form, form.getMediaType()));\n \n-                    if ( response.getStatus() == HttpStatus.SC_OK ) {\n+                    if (response.getStatus() == HttpStatus.SC_OK) {\n                         //Nothing to do here, we found no process to cancel\n-                    } else if ( response.getStatus() == HttpStatus.SC_RESET_CONTENT ) {\n+                    } else if (response.getStatus() == HttpStatus.SC_RESET_CONTENT) {\n                         //Expected return status if a cancel was made on the end point server\n                     } else {\n-                        Logger.error( this.getClass(), \"Response indicating a \" + response.getStatusInfo().getReasonPhrase() + \" (\" + response.getStatus() + \") Error trying to interrupt the running process on the Endpoint [ \" + endpointId + \"].\" );\n+                        Logger.error(\n+                                this.getClass(),\n+                                \"Response indicating a \" + response.getStatusInfo().getReasonPhrase() + \" (\"\n+                                        + response.getStatus()\n+                                        + \") Error trying to interrupt the running process on the Endpoint [ \"\n+                                        + endpointId + \"].\");\n                     }\n \n+                    //Get the thread associated to this endpoint and the integrity request id\n+                    final Thread runningThread = (Thread) session.getAttribute( \"integrityThread_\" + endpointId );\n                     //Interrupt the Thread process\n                     runningThread.interrupt();\n-\n                     //Remove the thread from the session\n-                    clearThreadInSession( httpServletRequest, endpointId );\n+                    clearThreadInSession(httpServletRequest, endpointId);\n \n-                    jsonResponse.put( \"success\", true );\n-                    jsonResponse.put( \"message\", LanguageUtil.get( initData.getUser().getLocale(), \"IntegrityCheckingCanceled\" ) );\n-                } else {\n-                    jsonResponse.put( \"success\", false );\n-                    jsonResponse.put( \"message\", \"The integrity process for End Point server: [\" + endpointId + \"] was already stopped.\" );\n+                    jsonResponse.put(\"success\", true);\n+                    jsonResponse.put(\n+                            \"message\",\n+                            LanguageUtil.get(initData.getUser().getLocale(), \"IntegrityCheckingCanceled\"));\n                 }\n             }\n \n-            responseMessage.append( jsonResponse.toString() );\n-\n-        } catch ( Exception e ) {\n-            Logger.error( this.getClass(), \"Error checking the integrity process status for End Point server: [\" + endpointId + \"]\", e );\n+            responseMessage.append(jsonResponse.toString());\n+        } catch (Exception e) {\n+            Logger.error(\n+                    this.getClass(),\n+                    \"Error checking the integrity process status for End Point server: [\" + endpointId + \"]\",", "originalCommit": "bec50a104819f020e85de9a754b814af4422bed3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjgzNg==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222836", "bodyText": "Codacy found an issue: Avoid throwing raw exception types.", "author": "dev-dotcms", "createdAt": "2020-09-21T17:19:18Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityDataRequestChecker.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.repackage.org.apache.commons.httpclient.HttpStatus;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotHibernateException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.media.multipart.FormDataMultiPart;\n+\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+\n+/**\n+ * Thread to constantly check the integrity check status by hitting on receiver host endpoint.\n+ * Anything but {@link com.dotcms.rest.IntegrityResource.ProcessStatus}.PROCESSING is considered that the integrity data\n+ * generation process is done.\n+ */\n+public class IntegrityDataRequestChecker implements Runnable {\n+\n+    private final String authToken;\n+    private final PublishingEndPoint endpoint;\n+    private final String integrityDataRequestId;\n+    private final HttpSession session;\n+    private final InitDataObject initData;\n+\n+    public IntegrityDataRequestChecker(String authToken,\n+                                       PublishingEndPoint endpoint,\n+                                       String integrityDataRequestId,\n+                                       HttpSession session,\n+                                       InitDataObject initData) {\n+        this.authToken = authToken;\n+        this.endpoint = endpoint;\n+        this.integrityDataRequestId = integrityDataRequestId;\n+        this.session = session;\n+        this.initData = initData;\n+    }\n+\n+    @Override\n+    public void run() {\n+        final Map<String, String> paramsMap = initData.getParamsMap();\n+        final String endpointId = paramsMap.get(\"endpoint\");\n+        final User loggedUser = initData.getUser();\n+        final FormDataMultiPart form = new FormDataMultiPart();\n+        form.field(\"AUTH_TOKEN\",authToken);\n+        form.field(\"REQUEST_ID\", integrityDataRequestId);\n+        final String url = endpoint.toURL() + \"/api/integrity/getintegritydata/\";\n+\n+        boolean processing = true;\n+        while(processing) {\n+            final Response response = IntegrityResource.postWithEndpointState(\n+                    endpoint.getId(),\n+                    url,\n+                    new MediaType(\"application\", \"zip\"),\n+                    Entity.entity(form, form.getMediaType()));\n+\n+            if (response.getStatus() == HttpStatus.SC_OK) {\n+                processing = false;\n+\n+                final String outputDir = IntegrityUtil.getIntegrityDataPath(endpoint.getId());\n+                final InputStream zipFile = response.readEntity(InputStream.class);\n+\n+                try {\n+                    IntegrityUtil.unzipFile(zipFile, outputDir);\n+                } catch(Exception e) {\n+                    //Special handling if the thread was interrupted\n+                    if (e instanceof InterruptedException) {\n+                        //Setting the process status\n+                        IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.CANCELLED, null);\n+                        final String message = \"Requested interruption of the integrity checking process [unzipping Integrity Data] by the user.\";\n+                        Logger.debug(IntegrityResource.class, message, e);\n+                        throw new RuntimeException(message, e);\n+                    }\n+\n+                    //Setting the process status\n+                    IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.ERROR, null);\n+                    final String message = \"Error while unzipping Integrity Data\";\n+                    Logger.error(IntegrityResource.class, message, e);\n+                    throw new RuntimeException(message, e);\n+                } finally {\n+                    if (zipFile != null) {\n+                        try {\n+                            zipFile.close();\n+                        } catch ( IOException e ) {\n+                            Logger.warn(IntegrityResource.class, \"Error closing zip file stream\", e);\n+                        }\n+                    }\n+                }\n+\n+                // set session variable\n+                // call IntegrityChecker\n+                boolean conflictPresent ;\n+                try {\n+                    IntegrityUtil.completeDiscardConflicts(endpointId);\n+                    conflictPresent = IntegrityUtil.completeCheckIntegrity(endpointId);\n+                } catch(Exception e) {\n+                    //Special handling if the thread was interrupted\n+                    if (e instanceof InterruptedException) {\n+                        //Setting the process status\n+                        IntegrityResource.setStatus(\n+                                session,\n+                                endpointId,\n+                                IntegrityResource.ProcessStatus.CANCELLED,\n+                                null);\n+                        final String message =\n+                                \"Requested interruption of the integrity checking process by the user.\";\n+                        Logger.debug(IntegrityResource.class, message, e);\n+                        throw new RuntimeException(message, e);\n+                    }\n+\n+                    Logger.error(IntegrityResource.class, \"Error checking integrity\", e);\n+                    //Setting the process status\n+                    IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.ERROR, null);\n+                    throw new RuntimeException(\"Error checking integrity\", e);", "originalCommit": "bec50a104819f020e85de9a754b814af4422bed3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjg0NA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222844", "bodyText": "Codacy found an issue: An instanceof check is being performed on the caught exception.  Create a separate catch clause for this exception type.", "author": "dev-dotcms", "createdAt": "2020-09-21T17:19:19Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityDataRequestChecker.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.repackage.org.apache.commons.httpclient.HttpStatus;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotHibernateException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.media.multipart.FormDataMultiPart;\n+\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+\n+/**\n+ * Thread to constantly check the integrity check status by hitting on receiver host endpoint.\n+ * Anything but {@link com.dotcms.rest.IntegrityResource.ProcessStatus}.PROCESSING is considered that the integrity data\n+ * generation process is done.\n+ */\n+public class IntegrityDataRequestChecker implements Runnable {\n+\n+    private final String authToken;\n+    private final PublishingEndPoint endpoint;\n+    private final String integrityDataRequestId;\n+    private final HttpSession session;\n+    private final InitDataObject initData;\n+\n+    public IntegrityDataRequestChecker(String authToken,\n+                                       PublishingEndPoint endpoint,\n+                                       String integrityDataRequestId,\n+                                       HttpSession session,\n+                                       InitDataObject initData) {\n+        this.authToken = authToken;\n+        this.endpoint = endpoint;\n+        this.integrityDataRequestId = integrityDataRequestId;\n+        this.session = session;\n+        this.initData = initData;\n+    }\n+\n+    @Override\n+    public void run() {\n+        final Map<String, String> paramsMap = initData.getParamsMap();\n+        final String endpointId = paramsMap.get(\"endpoint\");\n+        final User loggedUser = initData.getUser();\n+        final FormDataMultiPart form = new FormDataMultiPart();\n+        form.field(\"AUTH_TOKEN\",authToken);\n+        form.field(\"REQUEST_ID\", integrityDataRequestId);\n+        final String url = endpoint.toURL() + \"/api/integrity/getintegritydata/\";\n+\n+        boolean processing = true;\n+        while(processing) {\n+            final Response response = IntegrityResource.postWithEndpointState(\n+                    endpoint.getId(),\n+                    url,\n+                    new MediaType(\"application\", \"zip\"),\n+                    Entity.entity(form, form.getMediaType()));\n+\n+            if (response.getStatus() == HttpStatus.SC_OK) {\n+                processing = false;\n+\n+                final String outputDir = IntegrityUtil.getIntegrityDataPath(endpoint.getId());\n+                final InputStream zipFile = response.readEntity(InputStream.class);\n+\n+                try {\n+                    IntegrityUtil.unzipFile(zipFile, outputDir);\n+                } catch(Exception e) {\n+                    //Special handling if the thread was interrupted\n+                    if (e instanceof InterruptedException) {", "originalCommit": "bec50a104819f020e85de9a754b814af4422bed3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjg2MA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222860", "bodyText": "Codacy found an issue: The String literal \"AUTH_TOKEN\" appears 8 times in this file; the first occurrence is on line 169", "author": "dev-dotcms", "createdAt": "2020-09-21T17:19:20Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -153,68 +147,104 @@ private Response postWithEndpointState(String endpointId, String url, MediaType\n \t\treturn response;\n \t}\n \n+    /**\n+     * Resolves remote IP address from request.\n+     * @param request {@link HttpServletRequest}\n+     * @return a String representing the remote IP address (or hostname)\n+     */\n+    private static String resolveRemoteIp(final HttpServletRequest request) {\n+        final String remoteIP = request.getRemoteHost();\n+        return !UtilMethods.isSet(remoteIP) ? remoteIP : request.getRemoteAddr();\n+    }\n \n     /**\n-     * <p>Returns a zip with data from structures and folders for integrity check\n-     *\n-     * Usage: /getdata\n-     *\n+     * Tries to get the local address plus the port in a \"host:port\" format\n+     * @param request http servlet request\n+     * @return a string representing the address plus the port\n      */\n+    private static String getFullLocalIp(@Context final HttpServletRequest request) {\n+        final String localIp = request.getLocalName();\n+        final Optional<String> port = HttpRequestDataUtil.getServerPort();\n+        return (!UtilMethods.isSet(localIp) ? localIp : request.getLocalName())\n+                + ':' + port.orElse(String.valueOf(request.getLocalPort()));\n+    }\n \n+    /**\n+     * <p>Returns a zip with data from structures and folders for integrity check\n+     */\n     @POST\n     @Path(\"/generateintegritydata/{params:.*}\")\n     @Consumes(MediaType.MULTIPART_FORM_DATA)\n     @Produces(\"text/plain\")\n-    public Response generateIntegrityData(@Context HttpServletRequest request, @FormDataParam(\"AUTH_TOKEN\") String auth_token_digest)  {\n+    public Response generateIntegrityData(\n+            @Context final HttpServletRequest request,\n+            @FormDataParam(\"AUTH_TOKEN\") final String auth_token_digest)  {", "originalCommit": "bec50a104819f020e85de9a754b814af4422bed3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjg3Mg==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222872", "bodyText": "Codacy found an issue: Avoid empty if statements", "author": "dev-dotcms", "createdAt": "2020-09-21T17:19:21Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityDataRequestChecker.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.repackage.org.apache.commons.httpclient.HttpStatus;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotHibernateException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.media.multipart.FormDataMultiPart;\n+\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+\n+/**\n+ * Thread to constantly check the integrity check status by hitting on receiver host endpoint.\n+ * Anything but {@link com.dotcms.rest.IntegrityResource.ProcessStatus}.PROCESSING is considered that the integrity data\n+ * generation process is done.\n+ */\n+public class IntegrityDataRequestChecker implements Runnable {\n+\n+    private final String authToken;\n+    private final PublishingEndPoint endpoint;\n+    private final String integrityDataRequestId;\n+    private final HttpSession session;\n+    private final InitDataObject initData;\n+\n+    public IntegrityDataRequestChecker(String authToken,\n+                                       PublishingEndPoint endpoint,\n+                                       String integrityDataRequestId,\n+                                       HttpSession session,\n+                                       InitDataObject initData) {\n+        this.authToken = authToken;\n+        this.endpoint = endpoint;\n+        this.integrityDataRequestId = integrityDataRequestId;\n+        this.session = session;\n+        this.initData = initData;\n+    }\n+\n+    @Override\n+    public void run() {\n+        final Map<String, String> paramsMap = initData.getParamsMap();\n+        final String endpointId = paramsMap.get(\"endpoint\");\n+        final User loggedUser = initData.getUser();\n+        final FormDataMultiPart form = new FormDataMultiPart();\n+        form.field(\"AUTH_TOKEN\",authToken);\n+        form.field(\"REQUEST_ID\", integrityDataRequestId);\n+        final String url = endpoint.toURL() + \"/api/integrity/getintegritydata/\";\n+\n+        boolean processing = true;\n+        while(processing) {\n+            final Response response = IntegrityResource.postWithEndpointState(\n+                    endpoint.getId(),\n+                    url,\n+                    new MediaType(\"application\", \"zip\"),\n+                    Entity.entity(form, form.getMediaType()));\n+\n+            if (response.getStatus() == HttpStatus.SC_OK) {\n+                processing = false;\n+\n+                final String outputDir = IntegrityUtil.getIntegrityDataPath(endpoint.getId());\n+                final InputStream zipFile = response.readEntity(InputStream.class);\n+\n+                try {\n+                    IntegrityUtil.unzipFile(zipFile, outputDir);\n+                } catch(Exception e) {\n+                    //Special handling if the thread was interrupted\n+                    if (e instanceof InterruptedException) {\n+                        //Setting the process status\n+                        IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.CANCELLED, null);\n+                        final String message = \"Requested interruption of the integrity checking process [unzipping Integrity Data] by the user.\";\n+                        Logger.debug(IntegrityResource.class, message, e);\n+                        throw new RuntimeException(message, e);\n+                    }\n+\n+                    //Setting the process status\n+                    IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.ERROR, null);\n+                    final String message = \"Error while unzipping Integrity Data\";\n+                    Logger.error(IntegrityResource.class, message, e);\n+                    throw new RuntimeException(message, e);\n+                } finally {\n+                    if (zipFile != null) {\n+                        try {\n+                            zipFile.close();\n+                        } catch ( IOException e ) {\n+                            Logger.warn(IntegrityResource.class, \"Error closing zip file stream\", e);\n+                        }\n+                    }\n+                }\n+\n+                // set session variable\n+                // call IntegrityChecker\n+                boolean conflictPresent ;\n+                try {\n+                    IntegrityUtil.completeDiscardConflicts(endpointId);\n+                    conflictPresent = IntegrityUtil.completeCheckIntegrity(endpointId);\n+                } catch(Exception e) {\n+                    //Special handling if the thread was interrupted\n+                    if (e instanceof InterruptedException) {\n+                        //Setting the process status\n+                        IntegrityResource.setStatus(\n+                                session,\n+                                endpointId,\n+                                IntegrityResource.ProcessStatus.CANCELLED,\n+                                null);\n+                        final String message =\n+                                \"Requested interruption of the integrity checking process by the user.\";\n+                        Logger.debug(IntegrityResource.class, message, e);\n+                        throw new RuntimeException(message, e);\n+                    }\n+\n+                    Logger.error(IntegrityResource.class, \"Error checking integrity\", e);\n+                    //Setting the process status\n+                    IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.ERROR, null);\n+                    throw new RuntimeException(\"Error checking integrity\", e);\n+                } finally {\n+                    try {\n+                        IntegrityUtil.dropTempTables(endpointId);\n+                        HibernateUtil.closeSession();\n+                    } catch (DotHibernateException e) {\n+                        Logger.warn(this, e.getMessage(), e);\n+                    } catch (DotDataException e) {\n+                        Logger.error(IntegrityResource.class, \"Error while deleting temp tables\", e);\n+                    }\n+                }\n+\n+                if (conflictPresent) {\n+                    //Setting the process status\n+                    IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.FINISHED, null);\n+                } else {\n+                    String noConflictMessage;\n+                    try {\n+                        noConflictMessage = LanguageUtil.get(\n+                                loggedUser.getLocale(),\n+                                \"push_publish_integrity_conflicts_not_found\");\n+                    } catch ( LanguageException e ) {\n+                        noConflictMessage = \"No Integrity Conflicts found\";\n+                    }\n+                    //Setting the process status\n+                    IntegrityResource.setStatus(\n+                            session,\n+                            endpointId,\n+                            IntegrityResource.ProcessStatus.NO_CONFLICTS,\n+                            noConflictMessage);\n+                }\n+            } else if ( response.getStatus() == HttpStatus.SC_PROCESSING ) {", "originalCommit": "bec50a104819f020e85de9a754b814af4422bed3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjg4MQ==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222881", "bodyText": "Codacy found an issue: Avoid assignments in operands", "author": "dev-dotcms", "createdAt": "2020-09-21T17:19:22Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -230,79 +260,138 @@ public Response generateIntegrityData(@Context HttpServletRequest request, @Form\n     @Path(\"/getintegritydata/{params:.*}\")\n     @Produces(\"application/zip\")\n     @Consumes(MediaType.MULTIPART_FORM_DATA)\n-    public Response getIntegrityData(@Context HttpServletRequest request, @FormDataParam(\"AUTH_TOKEN\") String auth_token_digest, @FormDataParam(\"REQUEST_ID\") String requestId)  {\n-        String remoteIP = null;\n+    public Response getIntegrityData(@Context final HttpServletRequest request,\n+                                     @FormDataParam(\"AUTH_TOKEN\") final String auth_token_digest,\n+                                     @FormDataParam(\"REQUEST_ID\") final String requestId)  {\n+        final String remoteIp = resolveRemoteIp(request);\n+        final String localAddress = getFullLocalIp(request);\n \n+        final PublishingEndPointAPI endpointAPI = APILocator.getPublisherEndPointAPI();\n         try {\n+            final PublishingEndPoint requesterEndpoint = endpointAPI.findEnabledSendingEndPointByAddress(remoteIp);\n+\n+            if (!BundlePublisherResource.isValidToken(auth_token_digest, remoteIp, requesterEndpoint) ||\n+                    !UtilMethods.isSet(requestId)) {\n+                Logger.error(\n+                        IntegrityResource.class,\n+                        String.format(\n+                                \"Receiver at %s:> Authentication Token is invalid for ip: %s and endpoint id %s\",\n+                                localAddress,\n+                                remoteIp,\n+                                requesterEndpoint.getId()));\n+                return Response.status(HttpStatus.SC_UNAUTHORIZED).build();\n+            }\n \n+            if (QuartzUtils.isJobRunning(\n+                    IntegrityDataGenerationJob.JOB_NAME,\n+                    IntegrityDataGenerationJob.JOB_GROUP)) {\n+                Logger.error(\n+                        IntegrityResource.class,\n+                        String.format(\n+                                \"Receiver at %s:> job is already running for endpoint id: %s, therefore it's not ready and need to wait\",\n+                                localAddress,\n+                                requesterEndpoint.getId()));\n+                return Response.status(HttpStatus.SC_PROCESSING).build();\n+            }\n \n-            remoteIP = request.getRemoteHost();\n-            if(!UtilMethods.isSet(remoteIP))\n-                remoteIP = request.getRemoteAddr();\n-\n-            PublishingEndPointAPI endpointAPI = APILocator.getPublisherEndPointAPI();\n-            final PublishingEndPoint requesterEndPoint = endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n-\n-            if(!BundlePublisherResource.isValidToken(auth_token_digest, remoteIP, requesterEndPoint) || !UtilMethods.isSet(requestId)) {\n+            final Optional<IntegrityUtil.IntegrityDataExecutionMetadata> integrityMetadata =\n+                    IntegrityUtil.getIntegrityMetadata(requesterEndpoint.getId());\n+            if (!integrityMetadata.isPresent()) {\n+                Logger.error(\n+                        IntegrityResource.class,\n+                        String.format(\n+                                \"Receiver at %s:> integrity data generation metadata for endpoint id %s is not found \",\n+                                localAddress,\n+                                requesterEndpoint.getId()));\n                 return Response.status(HttpStatus.SC_UNAUTHORIZED).build();\n             }\n \n-            ServletContext servletContext = request.getSession().getServletContext();\n-            if(!UtilMethods.isSet(servletContext.getAttribute(\"integrityDataRequestID\"))\n-                    || !((String) servletContext.getAttribute(\"integrityDataRequestID\")).equals(requestId)) {\n+            if (!requestId.equals(integrityMetadata.get().getRequestId())) {\n+                Logger.error(\n+                        IntegrityResource.class,\n+                        String.format(\n+                                \"Receiver at %s:> integrity data generation metadata for endpoint id %s has a request id %s which does not match the provided %s\",\n+                                localAddress,\n+                                requesterEndpoint.getId(),\n+                                integrityMetadata.get().getRequestId(),\n+                                requestId));\n                 return Response.status(HttpStatus.SC_UNAUTHORIZED).build();\n             }\n \n-            ProcessStatus integrityDataGeneratorStatus = (ProcessStatus) servletContext.getAttribute(\"integrityDataGenerationStatus\");\n-\n-            if(UtilMethods.isSet( integrityDataGeneratorStatus )) {\n-                switch (integrityDataGeneratorStatus) {\n-                    case PROCESSING:\n-                        return Response.status(HttpStatus.SC_PROCESSING).build();\n-                    case FINISHED:\n-                        StreamingOutput output = new StreamingOutput() {\n-                            public void write(OutputStream output) throws IOException, WebApplicationException {\n-                                InputStream is = Files.newInputStream(Paths.get(\n-                                        ConfigUtils.getIntegrityPath() + File.separator\n-                                                + requesterEndPoint.getId() + File.separator\n-                                                + INTEGRITY_DATA_TO_CHECK_ZIP_FILE_NAME));\n-\n-                                byte[] buffer = new byte[1024];\n-                                int bytesRead;\n-                                //read from is to buffer\n-                                while((bytesRead = is.read(buffer)) !=-1){\n-                                    output.write(buffer, 0, bytesRead);\n-                                }\n-                                is.close();\n-                                //flush OutputStream to write any buffered data to file\n-                                output.flush();\n-                                output.close();\n-\n-                            }\n-                        };\n-                        return Response.ok(output).build();\n-\n-                    case CANCELED:\n-                        return Response.status( HttpStatus.SC_RESET_CONTENT ).entity( servletContext.getAttribute( \"integrityDataGenerationError\" ) ).build();\n-\n-                    case ERROR:\n-                        return Response.status(HttpStatus.SC_INTERNAL_SERVER_ERROR).entity(servletContext.getAttribute(\"integrityDataGenerationError\")).build();\n+            if (integrityMetadata.get().getProcessStatus() == ProcessStatus.PROCESSING) {\n+                Logger.info(\n+                        IntegrityResource.class,\n+                        String.format(\n+                                \"Receiver at %s:> integrity data generation for endpoint id %s still ongoing therefore it's not ready and need to wait\",\n+                                localAddress,\n+                                requesterEndpoint.getId()));\n+                return Response.status(HttpStatus.SC_PROCESSING).build();\n+            } else if (integrityMetadata.get().getProcessStatus() == ProcessStatus.FINISHED &&\n+                    IntegrityUtil.doesIntegrityDataFileExist(\n+                            requesterEndpoint.getId(),\n+                            IntegrityUtil.INTEGRITY_DATA_TO_CHECK_ZIP_FILENAME)) {\n+                final String zipFilePath = IntegrityUtil.getIntegrityDataFilePath(\n+                        requesterEndpoint.getId(),\n+                        IntegrityUtil.INTEGRITY_DATA_TO_CHECK_ZIP_FILENAME);\n+                final StreamingOutput output = so -> {\n+                    final InputStream inputStream = Files.newInputStream(Paths.get(zipFilePath));\n+                    final byte[] buffer = new byte[1024];\n+                    int bytesRead;\n+                    //read from is to buffer\n+                    while((bytesRead = inputStream.read(buffer)) != -1){", "originalCommit": "bec50a104819f020e85de9a754b814af4422bed3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjg5NA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222894", "bodyText": "Codacy found an issue: Avoid instantiating FileInputStream, FileOutputStream, FileReader, or FileWriter", "author": "dev-dotcms", "createdAt": "2020-09-21T17:19:24Z", "path": "dotCMS/src/main/java/com/dotcms/integritycheckers/IntegrityUtil.java", "diffHunk": "@@ -243,83 +257,234 @@ public static void unzipFile(InputStream zipFile, String outputDir) throws Excep\n         }\n     }\n \n+    /**\n+     * Resolves the integrity data path based on provided endpoint id.\n+     *\n+     * @param endpointId endpoint if\n+     * @return integrity data path as a string\n+     */\n+    public static String getIntegrityDataPath(final String endpointId) {\n+        return ConfigUtils.getIntegrityPath() + File.separator + endpointId;\n+    }\n+\n+    /**\n+     * Generated the integrity data file path based on provided endpointId and the file name.\n+     * File names to be used: DataToCheck.zip, DataToFix.zip and DataStatus.properties.\n+     *\n+     * @param endpointId endpoint gid\n+     * @param dataFile data filename\n+     * @return path to filename\n+     */\n+    public static String getIntegrityDataFilePath(final String endpointId, final String dataFile) {\n+        return getIntegrityDataPath(endpointId) + File.separator + dataFile;\n+    }\n+\n+    /**\n+     * Tells whether a integrity file exists based on provided endpointId and the file name.\n+     *\n+     * @param endpointId endpoint id\n+     * @param dataFile data filename\n+     * @return path to filename\n+     */\n+    public static boolean doesIntegrityDataFileExist(final String endpointId, final String dataFile) {\n+        return new File(getIntegrityDataFilePath(endpointId, dataFile)).exists();\n+    }\n+\n+    /**\n+     * Gets a {@link IntegrityDataExecutionMetadata} instance based on provided endpoint id which contains metadata of the\n+     * integrity data generation execution.\n+     *\n+     * @param endpointId endpoint id\n+     * @return Optional wrapping the integrity generation  metadata\n+     */\n+    public static Optional<IntegrityDataExecutionMetadata> getIntegrityMetadata(final String endpointId) {\n+        final File statusFile = new File(getIntegrityDataFilePath(endpointId, INTEGRITY_DATA_STATUS_FILENAME));\n+        if (!statusFile.exists()) {\n+            return Optional.empty();\n+        }\n+\n+        final Properties statusData = new Properties();\n+        try {\n+            statusData.load(new FileInputStream(statusFile));\n+        } catch (IOException e) {\n+            Logger.error(\n+                    IntegrityUtil.class,\n+                    String.format(\"Could load status from %s\", statusFile.getAbsolutePath()),\n+                    e);\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(new IntegrityDataExecutionMetadata(\n+                statusData.getProperty(REQUESTER_ENDPOINT),\n+                statusData.getProperty(INTEGRITY_DATA_REQUEST_ID),\n+                statusData.getProperty(INTEGRITY_DATA_STATUS),\n+                statusData.getProperty(INTEGRITY_DATA_ERROR_MESSAGE)));\n+    }\n+\n+    /**\n+     * Removes any file leftovers from other integrity checks at the location based on the endpoint id.\n+     * That will be any data check and status files.\n+     *\n+     * @param endpointId endpoint id\n+     */\n+    public static void cleanUpIntegrityData(String endpointId) {\n+        final BiConsumer<String, String> resetConsumer = (id, filename) -> {\n+            final File file = new File(getIntegrityDataFilePath(id, filename));\n+            if (file.exists()) {\n+                file.delete();\n+            }\n+        };\n+\n+        resetConsumer.accept(endpointId, INTEGRITY_DATA_STATUS_FILENAME);\n+        resetConsumer.accept(endpointId, INTEGRITY_DATA_TO_CHECK_ZIP_FILENAME);\n+    }\n+\n+    /**\n+     * Saves a integrity data generation metadata in a to-be-discovered location so it can be read by concurrent parts\n+     * that need to know what is the status of the integrity data generation.\n+     * The data is saved as {@link Properties} file.\n+     *\n+     * @param integrityDataExecutionMetadata execution metadata\n+     */\n+    private static void saveIntegrityDataStatus(IntegrityDataExecutionMetadata integrityDataExecutionMetadata) {\n+        final String endpointId = integrityDataExecutionMetadata.getEndpointId();\n+        final File integrityDir = new File(getIntegrityDataPath(endpointId));\n+        if (!integrityDir.exists()) {\n+            integrityDir.mkdir();\n+        }\n+\n+        final File statusFile = new File(getIntegrityDataFilePath(endpointId, INTEGRITY_DATA_STATUS_FILENAME));\n+        /*if (statusFile.exists()) {\n+            statusFile.delete();\n+        }*/\n+\n+        final Properties statusData = new Properties();\n+        final BiConsumer<String, String> addData = (data, name) -> {\n+            if (StringUtils.isNotBlank(data)) {\n+                statusData.setProperty(name, data);\n+            }\n+        };\n+\n+        addData.accept(endpointId, REQUESTER_ENDPOINT);\n+        addData.accept(integrityDataExecutionMetadata.getRequestId(), INTEGRITY_DATA_REQUEST_ID);\n+        statusData.setProperty(INTEGRITY_DATA_STATUS, integrityDataExecutionMetadata.getProcessStatus().toString().toUpperCase());\n+        addData.accept(integrityDataExecutionMetadata.getErrorMessage(), INTEGRITY_DATA_ERROR_MESSAGE);\n+\n+        try (FileOutputStream output = new FileOutputStream(statusFile)) {", "originalCommit": "bec50a104819f020e85de9a754b814af4422bed3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjkxMA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222910", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "author": "dev-dotcms", "createdAt": "2020-09-21T17:19:25Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityDataRequestChecker.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.repackage.org.apache.commons.httpclient.HttpStatus;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotHibernateException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.media.multipart.FormDataMultiPart;\n+\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+\n+/**\n+ * Thread to constantly check the integrity check status by hitting on receiver host endpoint.\n+ * Anything but {@link com.dotcms.rest.IntegrityResource.ProcessStatus}.PROCESSING is considered that the integrity data\n+ * generation process is done.\n+ */\n+public class IntegrityDataRequestChecker implements Runnable {\n+\n+    private final String authToken;\n+    private final PublishingEndPoint endpoint;\n+    private final String integrityDataRequestId;\n+    private final HttpSession session;\n+    private final InitDataObject initData;\n+\n+    public IntegrityDataRequestChecker(String authToken,\n+                                       PublishingEndPoint endpoint,\n+                                       String integrityDataRequestId,\n+                                       HttpSession session,\n+                                       InitDataObject initData) {\n+        this.authToken = authToken;\n+        this.endpoint = endpoint;\n+        this.integrityDataRequestId = integrityDataRequestId;\n+        this.session = session;\n+        this.initData = initData;\n+    }\n+\n+    @Override\n+    public void run() {\n+        final Map<String, String> paramsMap = initData.getParamsMap();\n+        final String endpointId = paramsMap.get(\"endpoint\");\n+        final User loggedUser = initData.getUser();\n+        final FormDataMultiPart form = new FormDataMultiPart();\n+        form.field(\"AUTH_TOKEN\",authToken);\n+        form.field(\"REQUEST_ID\", integrityDataRequestId);\n+        final String url = endpoint.toURL() + \"/api/integrity/getintegritydata/\";\n+\n+        boolean processing = true;\n+        while(processing) {\n+            final Response response = IntegrityResource.postWithEndpointState(\n+                    endpoint.getId(),\n+                    url,\n+                    new MediaType(\"application\", \"zip\"),\n+                    Entity.entity(form, form.getMediaType()));\n+\n+            if (response.getStatus() == HttpStatus.SC_OK) {\n+                processing = false;\n+\n+                final String outputDir = IntegrityUtil.getIntegrityDataPath(endpoint.getId());\n+                final InputStream zipFile = response.readEntity(InputStream.class);\n+\n+                try {\n+                    IntegrityUtil.unzipFile(zipFile, outputDir);\n+                } catch(Exception e) {", "originalCommit": "bec50a104819f020e85de9a754b814af4422bed3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjkyMA==", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222920", "bodyText": "Codacy found an issue: Avoid instantiating FileInputStream, FileOutputStream, FileReader, or FileWriter", "author": "dev-dotcms", "createdAt": "2020-09-21T17:19:26Z", "path": "dotCMS/src/main/java/com/dotcms/integritycheckers/IntegrityUtil.java", "diffHunk": "@@ -243,83 +257,234 @@ public static void unzipFile(InputStream zipFile, String outputDir) throws Excep\n         }\n     }\n \n+    /**\n+     * Resolves the integrity data path based on provided endpoint id.\n+     *\n+     * @param endpointId endpoint if\n+     * @return integrity data path as a string\n+     */\n+    public static String getIntegrityDataPath(final String endpointId) {\n+        return ConfigUtils.getIntegrityPath() + File.separator + endpointId;\n+    }\n+\n+    /**\n+     * Generated the integrity data file path based on provided endpointId and the file name.\n+     * File names to be used: DataToCheck.zip, DataToFix.zip and DataStatus.properties.\n+     *\n+     * @param endpointId endpoint gid\n+     * @param dataFile data filename\n+     * @return path to filename\n+     */\n+    public static String getIntegrityDataFilePath(final String endpointId, final String dataFile) {\n+        return getIntegrityDataPath(endpointId) + File.separator + dataFile;\n+    }\n+\n+    /**\n+     * Tells whether a integrity file exists based on provided endpointId and the file name.\n+     *\n+     * @param endpointId endpoint id\n+     * @param dataFile data filename\n+     * @return path to filename\n+     */\n+    public static boolean doesIntegrityDataFileExist(final String endpointId, final String dataFile) {\n+        return new File(getIntegrityDataFilePath(endpointId, dataFile)).exists();\n+    }\n+\n+    /**\n+     * Gets a {@link IntegrityDataExecutionMetadata} instance based on provided endpoint id which contains metadata of the\n+     * integrity data generation execution.\n+     *\n+     * @param endpointId endpoint id\n+     * @return Optional wrapping the integrity generation  metadata\n+     */\n+    public static Optional<IntegrityDataExecutionMetadata> getIntegrityMetadata(final String endpointId) {\n+        final File statusFile = new File(getIntegrityDataFilePath(endpointId, INTEGRITY_DATA_STATUS_FILENAME));\n+        if (!statusFile.exists()) {\n+            return Optional.empty();\n+        }\n+\n+        final Properties statusData = new Properties();\n+        try {\n+            statusData.load(new FileInputStream(statusFile));", "originalCommit": "bec50a104819f020e85de9a754b814af4422bed3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}