{"pr_number": 18135, "pr_title": "Issue 17514 18015 url map fixes", "pr_createdAt": "2020-03-13T16:18:01Z", "pr_url": "https://github.com/dotCMS/core/pull/18135", "timeline": [{"oid": "2fc6c6fefca9effa216cc8af1f42d858c420fae2", "url": "https://github.com/dotCMS/core/commit/2fc6c6fefca9effa216cc8af1f42d858c420fae2", "message": "#17514 #18015", "committedDate": "2020-03-12T17:08:56Z", "type": "commit"}, {"oid": "b0cec7b5285dbee09a2ca00ba9791b28b8cec479", "url": "https://github.com/dotCMS/core/commit/b0cec7b5285dbee09a2ca00ba9791b28b8cec479", "message": "#17514 #18015", "committedDate": "2020-03-12T17:59:36Z", "type": "commit"}, {"oid": "ce9917656059ea661330380e0e2a9b506eca0390", "url": "https://github.com/dotCMS/core/commit/ce9917656059ea661330380e0e2a9b506eca0390", "message": "#17514 #18015", "committedDate": "2020-03-12T18:32:10Z", "type": "commit"}, {"oid": "4153d8096b574376d86e922639b47ddce6d9cd5c", "url": "https://github.com/dotCMS/core/commit/4153d8096b574376d86e922639b47ddce6d9cd5c", "message": "#17514 #18015", "committedDate": "2020-03-12T20:56:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzMjYxNg==", "url": "https://github.com/dotCMS/core/pull/18135#discussion_r392332616", "bodyText": "this would be handle by a Set and contains method", "author": "jdotcms", "createdAt": "2020-03-13T16:22:13Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESUtils.java", "diffHunk": "@@ -26,4 +26,29 @@ public static String sha256(final String fieldName, final Object fieldValue,\n \t\t\t\t+ (fieldValue == null ? \"\" : fieldValue.toString()) + \"_\"\n \t\t\t\t+ languageId, Charset.forName(\"UTF-8\")).toString();\n \t}\n+\n+\t/**\n+\t * Returns a String where those characters that QueryParser expects to be escaped are escaped by\n+\t * a preceding <code>\\</code> excluding the \"/\", we found some cases where we don't want to\n+\t * scape it.\n+\t * This method is a copy of the {@link QueryParser#escape(String)} where we remove the\n+\t * scape for slashes \"/\" and we included the scape for white spaces \" \"\n+\t */\n+\tpublic static String escapeExcludingSlashIncludingSpace(String s) {\n+\t\tStringBuilder sb = new StringBuilder();\n+\t\tfor (int i = 0; i < s.length(); i++) {\n+\t\t\tchar c = s.charAt(i);\n+\t\t\t// These characters are part of the query syntax and must be escaped\n+\t\t\tif (c == '\\\\' || c == '+' || c == '-' || c == '!' || c == '(' || c == ')' || c == ':'", "originalCommit": "4153d8096b574376d86e922639b47ddce6d9cd5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzMjcwNA==", "url": "https://github.com/dotCMS/core/pull/18135#discussion_r392332704", "bodyText": "set to final", "author": "jdotcms", "createdAt": "2020-03-13T16:22:22Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESUtils.java", "diffHunk": "@@ -26,4 +26,29 @@ public static String sha256(final String fieldName, final Object fieldValue,\n \t\t\t\t+ (fieldValue == null ? \"\" : fieldValue.toString()) + \"_\"\n \t\t\t\t+ languageId, Charset.forName(\"UTF-8\")).toString();\n \t}\n+\n+\t/**\n+\t * Returns a String where those characters that QueryParser expects to be escaped are escaped by\n+\t * a preceding <code>\\</code> excluding the \"/\", we found some cases where we don't want to\n+\t * scape it.\n+\t * This method is a copy of the {@link QueryParser#escape(String)} where we remove the\n+\t * scape for slashes \"/\" and we included the scape for white spaces \" \"\n+\t */\n+\tpublic static String escapeExcludingSlashIncludingSpace(String s) {", "originalCommit": "4153d8096b574376d86e922639b47ddce6d9cd5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzMjg1MA==", "url": "https://github.com/dotCMS/core/pull/18135#discussion_r392332850", "bodyText": "set to final", "author": "jdotcms", "createdAt": "2020-03-13T16:22:38Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESUtils.java", "diffHunk": "@@ -26,4 +26,29 @@ public static String sha256(final String fieldName, final Object fieldValue,\n \t\t\t\t+ (fieldValue == null ? \"\" : fieldValue.toString()) + \"_\"\n \t\t\t\t+ languageId, Charset.forName(\"UTF-8\")).toString();\n \t}\n+\n+\t/**\n+\t * Returns a String where those characters that QueryParser expects to be escaped are escaped by\n+\t * a preceding <code>\\</code> excluding the \"/\", we found some cases where we don't want to\n+\t * scape it.\n+\t * This method is a copy of the {@link QueryParser#escape(String)} where we remove the\n+\t * scape for slashes \"/\" and we included the scape for white spaces \" \"\n+\t */\n+\tpublic static String escapeExcludingSlashIncludingSpace(String s) {\n+\t\tStringBuilder sb = new StringBuilder();", "originalCommit": "4153d8096b574376d86e922639b47ddce6d9cd5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzMzU2MA==", "url": "https://github.com/dotCMS/core/pull/18135#discussion_r392333560", "bodyText": "add doc", "author": "jdotcms", "createdAt": "2020-03-13T16:23:55Z", "path": "dotCMS/src/main/java/com/dotmarketing/cms/urlmap/URLMapAPI.java", "diffHunk": "@@ -20,5 +20,7 @@\n     Optional<URLMapInfo> processURLMap(final UrlMapContext context)\n             throws DotSecurityException, DotDataException;\n \n-    public boolean isUrlPattern(final UrlMapContext urlMapContext) throws DotDataException;\n-}\n+    boolean isUrlPattern(final UrlMapContext urlMapContext)", "originalCommit": "4153d8096b574376d86e922639b47ddce6d9cd5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzNDE4OQ==", "url": "https://github.com/dotCMS/core/pull/18135#discussion_r392334189", "bodyText": "set to final", "author": "jdotcms", "createdAt": "2020-03-13T16:25:02Z", "path": "dotCMS/src/main/java/com/dotmarketing/cms/urlmap/URLMapAPIImpl.java", "diffHunk": "@@ -58,63 +57,65 @@\n      * @return\n      * @throws DotDataException\n      */\n-    public boolean isUrlPattern(final UrlMapContext urlMapContext) throws DotDataException {\n+    public boolean isUrlPattern(final UrlMapContext urlMapContext)\n+            throws DotDataException, DotSecurityException {\n         return matchingUrlPattern(urlMapContext.getUri()) && getContentlet(urlMapContext) != null;\n     }\n \n     public Optional<URLMapInfo> processURLMap(final UrlMapContext context)\n             throws DotSecurityException, DotDataException {\n \n-        if (this.matchingUrlPattern(context.getUri())) {\n-            final Matches matches = this.findPatternChange(context.getUri());\n-\n-            final Structure structure = CacheLocator.getContentTypeCache()\n-                    .getStructureByInode(matches.getPatternChange().getStructureInode());\n-\n-            final Field hostField = this.findHostField(structure);\n-\n-            final Contentlet contentlet = this.getContentlet(matches, structure, hostField, context);\n-\n-            if (contentlet == null) {\n-                return Optional.empty();\n-            }\n-\n-            final Identifier pageUriIdentifier = this.getDetailtPageUri(structure);\n-\n-            return Optional.of(new URLMapInfo(contentlet, pageUriIdentifier, context.getUri()));\n-        } else {\n+        final Contentlet contentlet = getContentlet(context);\n+        if (contentlet == null) {\n             return Optional.empty();\n         }\n+\n+        final Structure structure = CacheLocator.getContentTypeCache()\n+                .getStructureByInode(contentlet.getStructureInode());\n+        final Identifier pageUriIdentifier = this.getDetailtPageUri(structure);\n+\n+        return Optional.of(new URLMapInfo(contentlet, pageUriIdentifier, context.getUri()));\n     }\n \n     /**\n-     * Return the {@link Contentlet} the match the {@link UrlMapContext#getUri()} value,\n-     * if not exists any {@link com.dotcms.contenttype.model.type.UrlMapable} matching with the URI\n-     * then a {@link DotRuntimeException} is thrown\n+     * Return the {@link Contentlet} the match the {@link UrlMapContext#getUri()} value, if not\n+     * exists any {@link com.dotcms.contenttype.model.type.UrlMapable} matching with the URI then a\n+     * {@link DotRuntimeException} is thrown\n      *\n      * @param urlMapContext\n      * @return\n      */\n-    private Contentlet getContentlet(final UrlMapContext urlMapContext){\n-        final Matches matches = this.findPatternChange(urlMapContext.getUri());\n-        final Structure structure = CacheLocator.getContentTypeCache()\n-                .getStructureByInode(matches.getPatternChange().getStructureInode());\n+    private Contentlet getContentlet(final UrlMapContext urlMapContext) throws DotSecurityException {\n \n-        final Field hostField = this.findHostField(structure);\n+        Contentlet matchingContentlet = null;\n \n         try {\n-            return this.getContentlet(matches, structure, hostField, urlMapContext);\n-        } catch (DotDataException | DotSecurityException e){\n-            return null;\n-        }\n-    }\n+            // We could have multiple matches as multiple content types could have the same\n+            // URLMap pattern and we need to evaluate all until we find content match.\n+            final List<Matches> matchesFound = this.findMatch(urlMapContext.getUri());\n+            if (!matchesFound.isEmpty()) {\n+\n+                for (Matches matches : matchesFound) {", "originalCommit": "4153d8096b574376d86e922639b47ddce6d9cd5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzNDU5NQ==", "url": "https://github.com/dotCMS/core/pull/18135#discussion_r392334595", "bodyText": "if do not need mod, use Collections.empyList()", "author": "jdotcms", "createdAt": "2020-03-13T16:25:46Z", "path": "dotCMS/src/main/java/com/dotmarketing/cms/urlmap/URLMapAPIImpl.java", "diffHunk": "@@ -139,44 +140,64 @@ private Identifier getDetailtPageUri(final Structure structure) {\n         }\n     }\n \n-    private boolean containsRegEx(final String uri) {\n-        final String mastRegEx = this.getURLMasterPattern().orElse(null);\n+    /**\n+     * Return all the matches related to a given URI, multiple content types could use the URLMap\n+     * pattern and on those cases we need to evaluate all the matches.\n+     *\n+     * @param uri URI to evaluate for matches\n+     * @return List of found matches\n+     * @throws DotDataException\n+     */\n+    private List<Matches> findMatch(final String uri) throws DotDataException {\n \n-        if (mastRegEx == null) {\n-            return false;\n+        // We want to avoid unnecessary lookups for vanity urls when browsing in the backend\n+        for (final String backendFilter : CMSUrlUtil.BACKEND_FILTERED_LIST_ARRAY) {\n+            if (uri.startsWith(backendFilter)) {\n+                return new ArrayList<>();", "originalCommit": "4153d8096b574376d86e922639b47ddce6d9cd5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzNDc3Mg==", "url": "https://github.com/dotCMS/core/pull/18135#discussion_r392334772", "bodyText": "set final", "author": "jdotcms", "createdAt": "2020-03-13T16:26:01Z", "path": "dotCMS/src/main/java/com/dotmarketing/cms/urlmap/URLMapAPIImpl.java", "diffHunk": "@@ -139,44 +140,64 @@ private Identifier getDetailtPageUri(final Structure structure) {\n         }\n     }\n \n-    private boolean containsRegEx(final String uri) {\n-        final String mastRegEx = this.getURLMasterPattern().orElse(null);\n+    /**\n+     * Return all the matches related to a given URI, multiple content types could use the URLMap\n+     * pattern and on those cases we need to evaluate all the matches.\n+     *\n+     * @param uri URI to evaluate for matches\n+     * @return List of found matches\n+     * @throws DotDataException\n+     */\n+    private List<Matches> findMatch(final String uri) throws DotDataException {\n \n-        if (mastRegEx == null) {\n-            return false;\n+        // We want to avoid unnecessary lookups for vanity urls when browsing in the backend\n+        for (final String backendFilter : CMSUrlUtil.BACKEND_FILTERED_LIST_ARRAY) {\n+            if (uri.startsWith(backendFilter)) {\n+                return new ArrayList<>();\n+            }\n         }\n \n-        final String url = !uri.endsWith(StringPool.FORWARD_SLASH) ? uri + StringPool.FORWARD_SLASH : uri;\n-        return RegEX.contains(url, mastRegEx);\n-    }\n-\n-    private static Optional<String> getURLMasterPattern() {\n-        try {\n-            final String mastRegEx = CacheLocator.getContentTypeCache().getURLMasterPattern();\n-\n-            return Optional.ofNullable(mastRegEx);\n-        } catch (DotCacheException e) {\n-            throw new DotRuntimeException(e);\n+        if (this.shouldLoadPatterns()) {\n+            this.loadPatterns();\n         }\n-    }\n \n-    private Matches findPatternChange(final String uri) {\n-        final String url = !uri.endsWith(StringPool.FORWARD_SLASH) ? uri + StringPool.FORWARD_SLASH : uri;\n+        List<Matches> foundMatches = new ArrayList<>();", "originalCommit": "4153d8096b574376d86e922639b47ddce6d9cd5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzNDk5Mg==", "url": "https://github.com/dotCMS/core/pull/18135#discussion_r392334992", "bodyText": "set to final", "author": "jdotcms", "createdAt": "2020-03-13T16:26:23Z", "path": "dotCMS/src/main/java/com/dotmarketing/cms/urlmap/URLMapAPIImpl.java", "diffHunk": "@@ -139,44 +140,64 @@ private Identifier getDetailtPageUri(final Structure structure) {\n         }\n     }\n \n-    private boolean containsRegEx(final String uri) {\n-        final String mastRegEx = this.getURLMasterPattern().orElse(null);\n+    /**\n+     * Return all the matches related to a given URI, multiple content types could use the URLMap\n+     * pattern and on those cases we need to evaluate all the matches.\n+     *\n+     * @param uri URI to evaluate for matches\n+     * @return List of found matches\n+     * @throws DotDataException\n+     */\n+    private List<Matches> findMatch(final String uri) throws DotDataException {\n \n-        if (mastRegEx == null) {\n-            return false;\n+        // We want to avoid unnecessary lookups for vanity urls when browsing in the backend\n+        for (final String backendFilter : CMSUrlUtil.BACKEND_FILTERED_LIST_ARRAY) {\n+            if (uri.startsWith(backendFilter)) {\n+                return new ArrayList<>();\n+            }\n         }\n \n-        final String url = !uri.endsWith(StringPool.FORWARD_SLASH) ? uri + StringPool.FORWARD_SLASH : uri;\n-        return RegEX.contains(url, mastRegEx);\n-    }\n-\n-    private static Optional<String> getURLMasterPattern() {\n-        try {\n-            final String mastRegEx = CacheLocator.getContentTypeCache().getURLMasterPattern();\n-\n-            return Optional.ofNullable(mastRegEx);\n-        } catch (DotCacheException e) {\n-            throw new DotRuntimeException(e);\n+        if (this.shouldLoadPatterns()) {\n+            this.loadPatterns();\n         }\n-    }\n \n-    private Matches findPatternChange(final String uri) {\n-        final String url = !uri.endsWith(StringPool.FORWARD_SLASH) ? uri + StringPool.FORWARD_SLASH : uri;\n+        List<Matches> foundMatches = new ArrayList<>();\n+\n+        final String url =\n+                !uri.endsWith(StringPool.FORWARD_SLASH) ? uri + StringPool.FORWARD_SLASH : uri;\n \n         for (final ContentTypeURLPattern contentTypeURLPattern : this.patternsCache) {\n \n-            final List<RegExMatch> matches = RegEX.findForUrlMap(url, contentTypeURLPattern.getRegEx());\n+            final List<RegExMatch> matches = RegEX\n+                    .findForUrlMap(url, contentTypeURLPattern.getRegEx());\n             if (matches != null && !matches.isEmpty()) {\n-                return new Matches(contentTypeURLPattern, matches);\n+\n+                /*\n+                We need to make sure we have an exact match, we could have regex too generic, like\n+                a regex in the root: \"/{urlTitle}\" resulting in a regex like \"/(.+)/\" which basically\n+                will match any url.\n+                 */\n+                for (RegExMatch regExMatch : matches) {", "originalCommit": "4153d8096b574376d86e922639b47ddce6d9cd5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzNzI2MA==", "url": "https://github.com/dotCMS/core/pull/18135#discussion_r392337260", "bodyText": "consider a set to avoid log(N) time", "author": "jdotcms", "createdAt": "2020-03-13T16:30:21Z", "path": "dotCMS/src/main/java/com/dotmarketing/filters/CMSUrlUtil.java", "diffHunk": "@@ -47,7 +48,7 @@\n \tprivate static final String NOT_FOUND = \"NOTFOUND\";\n \tprivate static final String UNABLE_TO_FIND = \"Unable to find \";\n \n-\tprivate static final String [] VANITY_FILTERED_LIST_ARRAY =\n+\tpublic static final String [] BACKEND_FILTERED_LIST_ARRAY =", "originalCommit": "4153d8096b574376d86e922639b47ddce6d9cd5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7b29bc7a9b2d48b9772db137b230715bda82939a", "url": "https://github.com/dotCMS/core/commit/7b29bc7a9b2d48b9772db137b230715bda82939a", "message": "#17514 #18015 Applying feedback", "committedDate": "2020-03-13T17:07:19Z", "type": "commit"}, {"oid": "d3b11fce49790b7f7bdaa14b60b1424a9d296e47", "url": "https://github.com/dotCMS/core/commit/d3b11fce49790b7f7bdaa14b60b1424a9d296e47", "message": "#17514 #18015 Applying feedback", "committedDate": "2020-03-13T17:42:01Z", "type": "commit"}, {"oid": "76056f9051b7eb16deccc856a999091b65eb59ab", "url": "https://github.com/dotCMS/core/commit/76056f9051b7eb16deccc856a999091b65eb59ab", "message": "#17514 #18015 Applying feedback", "committedDate": "2020-03-13T17:44:14Z", "type": "commit"}, {"oid": "018cd22e3960381c5b4161cf0f2d46ba2d8f4df7", "url": "https://github.com/dotCMS/core/commit/018cd22e3960381c5b4161cf0f2d46ba2d8f4df7", "message": "#17514 #18015 Applying more feedback", "committedDate": "2020-03-13T18:17:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM5ODg0MQ==", "url": "https://github.com/dotCMS/core/pull/18135#discussion_r392398841", "bodyText": "Issue found: Avoid variables with short names like c", "author": "dev-dotcms", "createdAt": "2020-03-13T18:24:57Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESUtils.java", "diffHunk": "@@ -26,4 +40,26 @@ public static String sha256(final String fieldName, final Object fieldValue,\n \t\t\t\t+ (fieldValue == null ? \"\" : fieldValue.toString()) + \"_\"\n \t\t\t\t+ languageId, Charset.forName(\"UTF-8\")).toString();\n \t}\n+\n+\t/**\n+\t * Returns a String where those characters that QueryParser expects to be escaped are escaped by\n+\t * a preceding <code>\\</code> excluding the \"/\", we found some cases where we don't want to\n+\t * scape it.\n+\t * This method is a copy of the {@link QueryParser#escape(String)} where we remove the\n+\t * scape for slashes \"/\" and we included the scape for white spaces \" \"\n+\t */\n+\tpublic static String escapeExcludingSlashIncludingSpace(final String toEscape) {\n+\n+\t\tfinal StringBuilder escapedString = new StringBuilder();\n+\t\tfor (int i = 0; i < toEscape.length(); i++) {\n+\t\t\tfinal char c = toEscape.charAt(i);", "originalCommit": "018cd22e3960381c5b4161cf0f2d46ba2d8f4df7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}