{"pr_number": 18332, "pr_title": "Issue 18325 allow vanity urls to have params", "pr_createdAt": "2020-04-21T02:43:02Z", "pr_url": "https://github.com/dotCMS/core/pull/18332", "timeline": [{"oid": "252e4f50cfba2abf5149c34e0dc876e6c7574e64", "url": "https://github.com/dotCMS/core/commit/252e4f50cfba2abf5149c34e0dc876e6c7574e64", "message": "#18325 vanities can now pass query params", "committedDate": "2020-04-21T01:55:01Z", "type": "commit"}, {"oid": "91a69df4e471db51a84c00b88f503b33b9a43013", "url": "https://github.com/dotCMS/core/commit/91a69df4e471db51a84c00b88f503b33b9a43013", "message": "#18325 vanities can now pass query params", "committedDate": "2020-04-21T02:34:04Z", "type": "commit"}, {"oid": "5a007b9a5522c381887feaebad40cd52e08f955c", "url": "https://github.com/dotCMS/core/commit/5a007b9a5522c381887feaebad40cd52e08f955c", "message": "#18325 cleaner", "committedDate": "2020-04-21T02:36:01Z", "type": "commit"}, {"oid": "79f4ea2b6c3ff04e5a8d3101a40ebd8940ab7884", "url": "https://github.com/dotCMS/core/commit/79f4ea2b6c3ff04e5a8d3101a40ebd8940ab7884", "message": "#18325 another test", "committedDate": "2020-04-21T02:42:48Z", "type": "commit"}, {"oid": "1b7a3f01c6833503e31a0eebfe2e34a02ce09c97", "url": "https://github.com/dotCMS/core/commit/1b7a3f01c6833503e31a0eebfe2e34a02ce09c97", "message": "#18325 another assertion", "committedDate": "2020-04-21T02:46:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIzMzIwMQ==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r412233201", "bodyText": "really this chenge is not tested, I think this test is tested VanityURL maybe we can add a new query params test:\nhttps://github.com/dotCMS/core/blob/master/dotCMS/src/integration-test/java/com/dotmarketing/filters/FiltersTest.java#L162", "author": "freddyucv", "createdAt": "2020-04-21T14:26:51Z", "path": "dotCMS/src/main/java/com/dotmarketing/filters/VanityURLFilter.java", "diffHunk": "@@ -85,20 +86,10 @@ public void doFilter(final ServletRequest req, final ServletResponse res,\n                     return;\n                 }\n \n-                /*\n-                If the VanityURL has a query string we need to add it to the request in order to override\n-                in the other filters.\n-                 */\n-                if (vanityUrlResult.getQueryString() != null) {\n-                    request.setAttribute(CMS_FILTER_QUERY_STRING_OVERRIDE,\n-                            vanityUrlResult.getQueryString());\n-                }\n+                filterChain.doFilter(new  VanityUrlRequestWrapper(request, vanityUrlResult) , response);\n+                return;\n+           }\n \n-                /*\n-                Set into the request the VanityURL we need to use to rewrite the current URI\n-                 */\n-                request.setAttribute(CMS_FILTER_URI_OVERRIDE, vanityUrlResult.getRewrite());\n-            }", "originalCommit": "1b7a3f01c6833503e31a0eebfe2e34a02ce09c97", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bae34f0b794c99d56f0a36fbb6165e35741c668e", "url": "https://github.com/dotCMS/core/commit/bae34f0b794c99d56f0a36fbb6165e35741c668e", "message": "Merge branch 'master' of github.com:dotCMS/core into issue-18325-allow-vanity-urls-to-have-params", "committedDate": "2020-04-22T22:13:49Z", "type": "commit"}, {"oid": "18852872affcd21cf4ae1c46226b8a665e7b9ada", "url": "https://github.com/dotCMS/core/commit/18852872affcd21cf4ae1c46226b8a665e7b9ada", "message": "Merge remote-tracking branch 'origin/master' into issue-18325-allow-vanity-urls-to-have-params", "committedDate": "2020-04-23T17:07:21Z", "type": "commit"}, {"oid": "5429a396fc4a4ff20f6f1e6ca812dc019e614ae2", "url": "https://github.com/dotCMS/core/commit/5429a396fc4a4ff20f6f1e6ca812dc019e614ae2", "message": "Merge branch 'master' of github.com:dotCMS/core into issue-18325-allow-vanity-urls-to-have-params", "committedDate": "2020-04-23T17:23:14Z", "type": "commit"}, {"oid": "ee59687d4c72848248572ea1d8abb08ef51683b9", "url": "https://github.com/dotCMS/core/commit/ee59687d4c72848248572ea1d8abb08ef51683b9", "message": "#18325 more tests", "committedDate": "2020-04-23T20:05:26Z", "type": "commit"}, {"oid": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "url": "https://github.com/dotCMS/core/commit/fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "message": "Merge branch 'issue-18325-allow-vanity-urls-to-have-params' of https://github.com/dotcms/core into issue-18325-allow-vanity-urls-to-have-params", "committedDate": "2020-04-23T20:06:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjM2OA==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092368", "bodyText": "Issue found: Document empty method body", "author": "dev-dotcms", "createdAt": "2020-04-23T20:12:59Z", "path": "dotCMS/src/main/java/com/dotmarketing/filters/VanityURLFilter.java", "diffHunk": "@@ -29,83 +31,72 @@\n     private final CMSUrlUtil urlUtil;\n     private final HostWebAPI hostWebAPI;\n     private final LanguageWebAPI languageWebAPI;\n-    private final UserWebAPI  userWebAPI;\n+    private final UserWebAPI userWebAPI;\n \n     public VanityURLFilter() {\n \n-        this (VanityUrlHandlerResolver.getInstance(), CMSUrlUtil.getInstance(),\n-                WebAPILocator.getHostWebAPI(), WebAPILocator.getLanguageWebAPI(),\n-                WebAPILocator.getUserWebAPI());\n+        this(VanityUrlHandlerResolver.getInstance(), CMSUrlUtil.getInstance(), WebAPILocator.getHostWebAPI(),\n+                        WebAPILocator.getLanguageWebAPI(), WebAPILocator.getUserWebAPI());\n     }\n \n     @VisibleForTesting\n-    protected VanityURLFilter(final VanityUrlHandlerResolver vanityUrlHandlerResolver,\n-                           final CMSUrlUtil urlUtil,\n-                           final HostWebAPI hostWebAPI,\n-                           final LanguageWebAPI languageWebAPI,\n-                           final UserWebAPI  userWebAPI) {\n+    protected VanityURLFilter(final VanityUrlHandlerResolver vanityUrlHandlerResolver, final CMSUrlUtil urlUtil,\n+                    final HostWebAPI hostWebAPI, final LanguageWebAPI languageWebAPI, final UserWebAPI userWebAPI) {\n \n         this.vanityUrlHandlerResolver = vanityUrlHandlerResolver;\n-        this.urlUtil                  = urlUtil;\n-        this.hostWebAPI               = hostWebAPI;\n-        this.languageWebAPI           = languageWebAPI;\n-        this.userWebAPI               = userWebAPI;\n+        this.urlUtil = urlUtil;\n+        this.hostWebAPI = hostWebAPI;\n+        this.languageWebAPI = languageWebAPI;\n+        this.userWebAPI = userWebAPI;\n     }\n \n-    public void init(FilterConfig filterConfig) throws ServletException {\n-    }\n+    public void init(FilterConfig filterConfig) throws ServletException {}\n \n-    public void doFilter(final ServletRequest req, final ServletResponse res,\n-            final FilterChain filterChain) throws IOException, ServletException {\n+    public void doFilter(final ServletRequest req, final ServletResponse res, final FilterChain filterChain)\n+                    throws IOException, ServletException {\n \n-        final HttpServletRequest  request  = (HttpServletRequest)  req;\n+        final HttpServletRequest request = (HttpServletRequest) req;\n         final HttpServletResponse response = (HttpServletResponse) res;\n \n-        //Get the URI from the request and check for possible XSS hacks\n-        final String uri         = this.urlUtil.getURIFromRequest(request);\n-        final boolean isFiltered = this.urlUtil.isVanityUrlFiltered (uri);\n-        //Getting the site form the request\n-        final Host site          = WebAPILocator.getHostWebAPI().getCurrentHostNoThrow(request);\n-\n-        if (!isFiltered) {\n-\n-            //Get the user language\n+        // Get the URI from the request and check for possible XSS hacks\n+        final String uri = this.urlUtil.getURIFromRequest(request);\n+        \n+        final boolean isFiltered = this.urlUtil.isVanityUrlFiltered(uri);\n+        \n+        // Getting the site form the request\n+        final Host site = hostWebAPI.getCurrentHostNoThrow(request);\n+\n+        // do not run again if the filter has been run\n+        if (!isFiltered && request.getAttribute(Constants.VANITY_URL_HAS_RUN) == null) {\n+            request.setAttribute(Constants.VANITY_URL_HAS_RUN, true);\n+            // Get the user language\n             final long languageId = this.languageWebAPI.getLanguage(request).getId();\n \n-            //Verify if the given URI is a VanityURL\n+            // Verify if the given URI is a VanityURL\n             if (this.urlUtil.isVanityUrl(uri, site, languageId)) {\n \n-                //Find the Vanity URL handler and handle this given URI\n+                // Find the Vanity URL handler and handle this given URI\n                 final VanityUrlHandler vanityUrlHandler = this.vanityUrlHandlerResolver.getVanityUrlHandler();\n-                final VanityUrlResult vanityUrlResult = vanityUrlHandler\n-                        .handle(uri, response, site, languageId, this.userWebAPI.getUser(request));\n+                final VanityUrlResult vanityUrlResult =\n+                                vanityUrlHandler.handle(uri, response, site, languageId, this.userWebAPI.getUser(request));\n \n-                //If the handler already resolved the requested URI we stop the processing here\n+                // If the handler already resolved the requested URI we stop the processing here\n                 if (vanityUrlResult.isResolved()) {\n                     return;\n                 }\n \n-                /*\n-                If the VanityURL has a query string we need to add it to the request in order to override\n-                in the other filters.\n-                 */\n-                if (vanityUrlResult.getQueryString() != null) {\n-                    request.setAttribute(CMS_FILTER_QUERY_STRING_OVERRIDE,\n-                            vanityUrlResult.getQueryString());\n-                }\n-\n-                /*\n-                Set into the request the VanityURL we need to use to rewrite the current URI\n-                 */\n-                request.setAttribute(CMS_FILTER_URI_OVERRIDE, vanityUrlResult.getRewrite());\n+                filterChain.doFilter(new VanityUrlRequestWrapper(request, vanityUrlResult), response);\n+                return;\n             }\n+\n         }\n \n         filterChain.doFilter(request, response);\n     } // doFilter.\n \n \n-    public void destroy() {\n-    }\n+    public void destroy() {}", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjM3NA==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092374", "bodyText": "Issue found: JUnit tests should include assert() or fail()", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:00Z", "path": "dotCMS/src/test/java/com/dotmarketing/filters/VanityUrlRequestWrapperTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.dotmarketing.filters;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import org.junit.Test;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.request.MockParameterRequest;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.google.common.collect.ImmutableMap;\n+\n+public class VanityUrlRequestWrapperTest {\n+\n+    final String URL = \"URL\";\n+    final String FORM = \"FORM\";\n+    final String VANITY = \"VANITY\";\n+\n+\n+    /**\n+     * This tests if you have a vanity URL that has query parameters, that they will be merged into to\n+     * the request and if their keys match an existing parameter, the vanity url parameter will\n+     * overwrite any parameters that were in the original request\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_vanity_urls_with_query_params_override_incoming_requests() {\n+\n+        // three form params\n+        final Map<String, String> formParameters = ImmutableMap.of(\"param0\", FORM, \"param1\", FORM, \"param2\", FORM);\n+\n+\n+        // two url params (2 overlap)\n+        final HttpServletRequest baseRequest = new MockParameterRequest(\n+                        new MockHttpRequest(\"testing\", \"/test?param1=\" + URL + \"&param2=\" + URL).request(), formParameters)\n+                                        .request();\n+\n+        // two vanity params (1 overlaps)\n+        final VanityUrlResult vanityUrlResult = new VanityUrlResult(\"/newUrl\", \"param2=\" + VANITY + \"&param3=\" + VANITY, false);\n+\n+\n+        final HttpServletRequest request = new VanityUrlRequestWrapper(baseRequest, vanityUrlResult);\n+\n+\n+\n+        // we have 3 objects in our param map\n+        assert (request.getParameterMap().size() == 4);\n+\n+        assert (request.getParameter(\"param0\").equals(FORM));\n+        assert (request.getParameter(\"param1\").equals(URL));\n+\n+        // param2 have been overridden by the vanity url\n+        assert (request.getParameter(\"param2\").equals(VANITY));\n+\n+        assert (request.getParameter(\"param3\").equals(VANITY));\n+\n+        // param2 also has the original value from the url\n+        assert (request.getParameterValues(\"param2\").length == 2);\n+        assert (request.getParameterValues(\"param2\")[0].equals(VANITY));\n+        assert (request.getParameterValues(\"param2\")[1].equals(URL));\n+\n+\n+\n+    }\n+\n+    /**\n+     * This tests to insure that the new query string has both the old and the new query parameters\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_query_string_has_all_the_parameters() {", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjM3OQ==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092379", "bodyText": "Issue found: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:01Z", "path": "dotCMS/src/test/java/com/dotmarketing/filters/VanityUrlRequestWrapperTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.dotmarketing.filters;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import org.junit.Test;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.request.MockParameterRequest;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.google.common.collect.ImmutableMap;\n+\n+public class VanityUrlRequestWrapperTest {\n+\n+    final String URL = \"URL\";\n+    final String FORM = \"FORM\";\n+    final String VANITY = \"VANITY\";\n+\n+\n+    /**\n+     * This tests if you have a vanity URL that has query parameters, that they will be merged into to\n+     * the request and if their keys match an existing parameter, the vanity url parameter will\n+     * overwrite any parameters that were in the original request\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_vanity_urls_with_query_params_override_incoming_requests() {\n+\n+        // three form params\n+        final Map<String, String> formParameters = ImmutableMap.of(\"param0\", FORM, \"param1\", FORM, \"param2\", FORM);\n+\n+\n+        // two url params (2 overlap)\n+        final HttpServletRequest baseRequest = new MockParameterRequest(\n+                        new MockHttpRequest(\"testing\", \"/test?param1=\" + URL + \"&param2=\" + URL).request(), formParameters)\n+                                        .request();\n+\n+        // two vanity params (1 overlaps)\n+        final VanityUrlResult vanityUrlResult = new VanityUrlResult(\"/newUrl\", \"param2=\" + VANITY + \"&param3=\" + VANITY, false);\n+\n+\n+        final HttpServletRequest request = new VanityUrlRequestWrapper(baseRequest, vanityUrlResult);\n+\n+\n+\n+        // we have 3 objects in our param map\n+        assert (request.getParameterMap().size() == 4);\n+\n+        assert (request.getParameter(\"param0\").equals(FORM));\n+        assert (request.getParameter(\"param1\").equals(URL));\n+\n+        // param2 have been overridden by the vanity url\n+        assert (request.getParameter(\"param2\").equals(VANITY));\n+\n+        assert (request.getParameter(\"param3\").equals(VANITY));\n+\n+        // param2 also has the original value from the url\n+        assert (request.getParameterValues(\"param2\").length == 2);\n+        assert (request.getParameterValues(\"param2\")[0].equals(VANITY));\n+        assert (request.getParameterValues(\"param2\")[1].equals(URL));\n+\n+\n+\n+    }\n+\n+    /**\n+     * This tests to insure that the new query string has both the old and the new query parameters\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_query_string_has_all_the_parameters() {\n+\n+\n+        final HttpServletRequest baseRequest = new MockHttpRequest(\"testing\", \"/test?param1=\" + URL + \"&param2=\" + URL).request();\n+\n+        final VanityUrlResult vanityUrlResult = new VanityUrlResult(\"/newUrl\", \"param2=\" + VANITY + \"&param3=\" + VANITY, false);\n+\n+        final HttpServletRequest request = new VanityUrlRequestWrapper(baseRequest, vanityUrlResult);\n+\n+        final String queryString= request.getQueryString();\n+        assert(queryString!=null);\n+        assert(!queryString.startsWith(\"&\"));\n+        assert(!queryString.endsWith(\"&\"));\n+        assert(queryString.contains(\"param1=\" + URL));\n+        assert(queryString.contains(\"param2=\" + URL));\n+        assert(queryString.contains(\"param2=\" + VANITY));\n+        assert(queryString.contains(\"param3=\" + VANITY));", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjM5MQ==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092391", "bodyText": "Issue found: JUnit tests should include assert() or fail()", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:02Z", "path": "dotCMS/src/test/java/com/dotmarketing/filters/VanityUrlRequestWrapperTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.dotmarketing.filters;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import org.junit.Test;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.request.MockParameterRequest;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.google.common.collect.ImmutableMap;\n+\n+public class VanityUrlRequestWrapperTest {\n+\n+    final String URL = \"URL\";\n+    final String FORM = \"FORM\";\n+    final String VANITY = \"VANITY\";\n+\n+\n+    /**\n+     * This tests if you have a vanity URL that has query parameters, that they will be merged into to\n+     * the request and if their keys match an existing parameter, the vanity url parameter will\n+     * overwrite any parameters that were in the original request\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_vanity_urls_with_query_params_override_incoming_requests() {", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjQwMw==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092403", "bodyText": "Issue found: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:03Z", "path": "dotCMS/src/test/java/com/dotmarketing/filters/VanityUrlRequestWrapperTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.dotmarketing.filters;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import org.junit.Test;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.request.MockParameterRequest;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.google.common.collect.ImmutableMap;\n+\n+public class VanityUrlRequestWrapperTest {\n+\n+    final String URL = \"URL\";\n+    final String FORM = \"FORM\";\n+    final String VANITY = \"VANITY\";\n+\n+\n+    /**\n+     * This tests if you have a vanity URL that has query parameters, that they will be merged into to\n+     * the request and if their keys match an existing parameter, the vanity url parameter will\n+     * overwrite any parameters that were in the original request\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_vanity_urls_with_query_params_override_incoming_requests() {\n+\n+        // three form params\n+        final Map<String, String> formParameters = ImmutableMap.of(\"param0\", FORM, \"param1\", FORM, \"param2\", FORM);\n+\n+\n+        // two url params (2 overlap)\n+        final HttpServletRequest baseRequest = new MockParameterRequest(\n+                        new MockHttpRequest(\"testing\", \"/test?param1=\" + URL + \"&param2=\" + URL).request(), formParameters)\n+                                        .request();\n+\n+        // two vanity params (1 overlaps)\n+        final VanityUrlResult vanityUrlResult = new VanityUrlResult(\"/newUrl\", \"param2=\" + VANITY + \"&param3=\" + VANITY, false);\n+\n+\n+        final HttpServletRequest request = new VanityUrlRequestWrapper(baseRequest, vanityUrlResult);\n+\n+\n+\n+        // we have 3 objects in our param map\n+        assert (request.getParameterMap().size() == 4);\n+\n+        assert (request.getParameter(\"param0\").equals(FORM));\n+        assert (request.getParameter(\"param1\").equals(URL));\n+\n+        // param2 have been overridden by the vanity url\n+        assert (request.getParameter(\"param2\").equals(VANITY));\n+\n+        assert (request.getParameter(\"param3\").equals(VANITY));\n+\n+        // param2 also has the original value from the url\n+        assert (request.getParameterValues(\"param2\").length == 2);\n+        assert (request.getParameterValues(\"param2\")[0].equals(VANITY));\n+        assert (request.getParameterValues(\"param2\")[1].equals(URL));\n+\n+\n+\n+    }\n+\n+    /**\n+     * This tests to insure that the new query string has both the old and the new query parameters\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_query_string_has_all_the_parameters() {\n+\n+\n+        final HttpServletRequest baseRequest = new MockHttpRequest(\"testing\", \"/test?param1=\" + URL + \"&param2=\" + URL).request();\n+\n+        final VanityUrlResult vanityUrlResult = new VanityUrlResult(\"/newUrl\", \"param2=\" + VANITY + \"&param3=\" + VANITY, false);\n+\n+        final HttpServletRequest request = new VanityUrlRequestWrapper(baseRequest, vanityUrlResult);\n+\n+        final String queryString= request.getQueryString();\n+        assert(queryString!=null);\n+        assert(!queryString.startsWith(\"&\"));\n+        assert(!queryString.endsWith(\"&\"));", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjQxOQ==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092419", "bodyText": "Issue found: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:05Z", "path": "dotCMS/src/test/java/com/dotmarketing/filters/VanityUrlRequestWrapperTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.dotmarketing.filters;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import org.junit.Test;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.request.MockParameterRequest;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.google.common.collect.ImmutableMap;\n+\n+public class VanityUrlRequestWrapperTest {\n+\n+    final String URL = \"URL\";\n+    final String FORM = \"FORM\";\n+    final String VANITY = \"VANITY\";\n+\n+\n+    /**\n+     * This tests if you have a vanity URL that has query parameters, that they will be merged into to\n+     * the request and if their keys match an existing parameter, the vanity url parameter will\n+     * overwrite any parameters that were in the original request\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_vanity_urls_with_query_params_override_incoming_requests() {\n+\n+        // three form params\n+        final Map<String, String> formParameters = ImmutableMap.of(\"param0\", FORM, \"param1\", FORM, \"param2\", FORM);\n+\n+\n+        // two url params (2 overlap)\n+        final HttpServletRequest baseRequest = new MockParameterRequest(\n+                        new MockHttpRequest(\"testing\", \"/test?param1=\" + URL + \"&param2=\" + URL).request(), formParameters)\n+                                        .request();\n+\n+        // two vanity params (1 overlaps)\n+        final VanityUrlResult vanityUrlResult = new VanityUrlResult(\"/newUrl\", \"param2=\" + VANITY + \"&param3=\" + VANITY, false);\n+\n+\n+        final HttpServletRequest request = new VanityUrlRequestWrapper(baseRequest, vanityUrlResult);\n+\n+\n+\n+        // we have 3 objects in our param map\n+        assert (request.getParameterMap().size() == 4);\n+\n+        assert (request.getParameter(\"param0\").equals(FORM));\n+        assert (request.getParameter(\"param1\").equals(URL));\n+\n+        // param2 have been overridden by the vanity url\n+        assert (request.getParameter(\"param2\").equals(VANITY));\n+\n+        assert (request.getParameter(\"param3\").equals(VANITY));\n+\n+        // param2 also has the original value from the url\n+        assert (request.getParameterValues(\"param2\").length == 2);\n+        assert (request.getParameterValues(\"param2\")[0].equals(VANITY));\n+        assert (request.getParameterValues(\"param2\")[1].equals(URL));\n+\n+\n+\n+    }\n+\n+    /**\n+     * This tests to insure that the new query string has both the old and the new query parameters\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_query_string_has_all_the_parameters() {\n+\n+\n+        final HttpServletRequest baseRequest = new MockHttpRequest(\"testing\", \"/test?param1=\" + URL + \"&param2=\" + URL).request();\n+\n+        final VanityUrlResult vanityUrlResult = new VanityUrlResult(\"/newUrl\", \"param2=\" + VANITY + \"&param3=\" + VANITY, false);\n+\n+        final HttpServletRequest request = new VanityUrlRequestWrapper(baseRequest, vanityUrlResult);\n+\n+        final String queryString= request.getQueryString();\n+        assert(queryString!=null);\n+        assert(!queryString.startsWith(\"&\"));\n+        assert(!queryString.endsWith(\"&\"));\n+        assert(queryString.contains(\"param1=\" + URL));\n+        assert(queryString.contains(\"param2=\" + URL));", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjQzOA==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092438", "bodyText": "Issue found: Parameter 'invocation' is not assigned and could be declared final", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:06Z", "path": "dotCMS/src/main/java/com/dotcms/mock/request/MockHttpRequest.java", "diffHunk": "@@ -18,15 +26,36 @@\n public class MockHttpRequest implements MockRequest {\n \n     private final HttpServletRequest request;\n-\n+    private final Map<String,String[]> paramMap;\n     public MockHttpRequest(final String hostname, final String uri) {\n         HttpServletRequest mockReq = new BaseRequest().request();\n         Mockito.when(mockReq.getRequestURI()).thenReturn(uri);\n         Mockito.when(mockReq.getRequestURL()).thenReturn(new StringBuffer(\"http://\" + hostname + uri));\n         Mockito.when(mockReq.getServerName()).thenReturn(hostname);\n         Mockito.when(mockReq.getRemoteAddr()).thenReturn(\"127.0.0.1\");\n         Mockito.when(mockReq.getRemoteHost()).thenReturn(\"127.0.0.1\");\n+        paramMap = new HashMap<>();\n+        if(uri.contains(\"?\")) {\n+            final String queryString = uri.substring(uri.indexOf(\"?\") + 1, uri.length());\n+            Mockito.when(mockReq.getQueryString()).thenReturn(queryString);\n+            List<NameValuePair> additional = URLEncodedUtils.parse(queryString, Charset.forName(\"UTF-8\"));\n+            for(NameValuePair nvp : additional) {\n+                paramMap.compute(nvp.getName(), (k, v) -> (v == null) ? new String[] {nvp.getValue()} : new String[]{nvp.getValue(),v[0]});\n+            }\n+            Mockito.when(mockReq.getQueryString()).thenReturn(queryString);\n+            Mockito.when(mockReq.getParameterMap()).thenReturn(paramMap);\n+            Mockito.when(mockReq.getParameterNames()).thenReturn(Collections.enumeration(paramMap.keySet()));\n+            Mockito.when(mockReq.getParameter(Mockito.anyString())).thenAnswer(new Answer<String>() {\n+                public String answer(InvocationOnMock invocation) {", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjQ1OQ==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092459", "bodyText": "Issue found: The String literal \"param2\" appears 5 times in this file; the first occurrence is on line 33", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:07Z", "path": "dotCMS/src/test/java/com/dotmarketing/filters/VanityUrlRequestWrapperTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.dotmarketing.filters;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import org.junit.Test;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.request.MockParameterRequest;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.google.common.collect.ImmutableMap;\n+\n+public class VanityUrlRequestWrapperTest {\n+\n+    final String URL = \"URL\";\n+    final String FORM = \"FORM\";\n+    final String VANITY = \"VANITY\";\n+\n+\n+    /**\n+     * This tests if you have a vanity URL that has query parameters, that they will be merged into to\n+     * the request and if their keys match an existing parameter, the vanity url parameter will\n+     * overwrite any parameters that were in the original request\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_vanity_urls_with_query_params_override_incoming_requests() {\n+\n+        // three form params\n+        final Map<String, String> formParameters = ImmutableMap.of(\"param0\", FORM, \"param1\", FORM, \"param2\", FORM);", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjQ2OA==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092468", "bodyText": "Issue found: Local variable 'tempMap' could be declared final", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:08Z", "path": "dotCMS/src/main/java/com/dotmarketing/filters/VanityUrlRequestWrapper.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.dotmarketing.filters;\n+\n+import static com.dotmarketing.filters.Constants.CMS_FILTER_QUERY_STRING_OVERRIDE;\n+import static com.dotmarketing.filters.Constants.CMS_FILTER_URI_OVERRIDE;\n+import java.nio.charset.Charset;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.collect.ImmutableMap;\n+\n+\n+/**\n+ * The VanityUrlOverrideRequest merges the parameters set in the original request and merges them\n+ * with the parameters that are being set in the vanityUrl. In all cases, if there are parameters\n+ * set in the VanityURL Query String, they will override the ones being sent in by original visitors\n+ * request\n+ *\n+ */\n+class VanityUrlRequestWrapper extends HttpServletRequestWrapper {\n+    \n+    final Map<String, String[]> queryParamMap;\n+    final String newQueryString;\n+    final boolean vanityHasQueryString;\n+\n+\n+    public VanityUrlRequestWrapper(HttpServletRequest request, VanityUrlResult vanityUrlResult) {\n+        super(request);\n+\n+        \n+        this.vanityHasQueryString = UtilMethods.isSet(vanityUrlResult.getQueryString());\n+        \n+        this.newQueryString = vanityHasQueryString && UtilMethods.isSet(request.getQueryString())\n+                        ? request.getQueryString() + \"&\" + vanityUrlResult.getQueryString()\n+                        : vanityHasQueryString \n+                            ? vanityUrlResult.getQueryString()\n+                            : request.getQueryString();\n+\n+\n+        // we create a new map here because it merges the \n+        Map<String,String[]> tempMap = new HashMap<>(request.getParameterMap());", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjQ3Ng==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092476", "bodyText": "Issue found: Avoid declaring a variable if it is unreferenced before a possible exit point.", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:09Z", "path": "dotCMS/src/main/java/com/dotcms/mock/request/MockHttpRequest.java", "diffHunk": "@@ -18,15 +26,36 @@\n public class MockHttpRequest implements MockRequest {\n \n     private final HttpServletRequest request;\n-\n+    private final Map<String,String[]> paramMap;\n     public MockHttpRequest(final String hostname, final String uri) {\n         HttpServletRequest mockReq = new BaseRequest().request();\n         Mockito.when(mockReq.getRequestURI()).thenReturn(uri);\n         Mockito.when(mockReq.getRequestURL()).thenReturn(new StringBuffer(\"http://\" + hostname + uri));\n         Mockito.when(mockReq.getServerName()).thenReturn(hostname);\n         Mockito.when(mockReq.getRemoteAddr()).thenReturn(\"127.0.0.1\");\n         Mockito.when(mockReq.getRemoteHost()).thenReturn(\"127.0.0.1\");\n+        paramMap = new HashMap<>();\n+        if(uri.contains(\"?\")) {\n+            final String queryString = uri.substring(uri.indexOf(\"?\") + 1, uri.length());\n+            Mockito.when(mockReq.getQueryString()).thenReturn(queryString);\n+            List<NameValuePair> additional = URLEncodedUtils.parse(queryString, Charset.forName(\"UTF-8\"));\n+            for(NameValuePair nvp : additional) {\n+                paramMap.compute(nvp.getName(), (k, v) -> (v == null) ? new String[] {nvp.getValue()} : new String[]{nvp.getValue(),v[0]});\n+            }\n+            Mockito.when(mockReq.getQueryString()).thenReturn(queryString);\n+            Mockito.when(mockReq.getParameterMap()).thenReturn(paramMap);\n+            Mockito.when(mockReq.getParameterNames()).thenReturn(Collections.enumeration(paramMap.keySet()));\n+            Mockito.when(mockReq.getParameter(Mockito.anyString())).thenAnswer(new Answer<String>() {\n+                public String answer(InvocationOnMock invocation) {\n+                    Object[] args = invocation.getArguments();\n+                    Object mock = invocation.getMock();", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjQ4Ng==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092486", "bodyText": "Issue found: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:10Z", "path": "dotCMS/src/test/java/com/dotmarketing/filters/VanityUrlRequestWrapperTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.dotmarketing.filters;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import org.junit.Test;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.request.MockParameterRequest;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.google.common.collect.ImmutableMap;\n+\n+public class VanityUrlRequestWrapperTest {\n+\n+    final String URL = \"URL\";\n+    final String FORM = \"FORM\";\n+    final String VANITY = \"VANITY\";\n+\n+\n+    /**\n+     * This tests if you have a vanity URL that has query parameters, that they will be merged into to\n+     * the request and if their keys match an existing parameter, the vanity url parameter will\n+     * overwrite any parameters that were in the original request\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_vanity_urls_with_query_params_override_incoming_requests() {\n+\n+        // three form params\n+        final Map<String, String> formParameters = ImmutableMap.of(\"param0\", FORM, \"param1\", FORM, \"param2\", FORM);\n+\n+\n+        // two url params (2 overlap)\n+        final HttpServletRequest baseRequest = new MockParameterRequest(\n+                        new MockHttpRequest(\"testing\", \"/test?param1=\" + URL + \"&param2=\" + URL).request(), formParameters)\n+                                        .request();\n+\n+        // two vanity params (1 overlaps)\n+        final VanityUrlResult vanityUrlResult = new VanityUrlResult(\"/newUrl\", \"param2=\" + VANITY + \"&param3=\" + VANITY, false);\n+\n+\n+        final HttpServletRequest request = new VanityUrlRequestWrapper(baseRequest, vanityUrlResult);\n+\n+\n+\n+        // we have 3 objects in our param map\n+        assert (request.getParameterMap().size() == 4);\n+\n+        assert (request.getParameter(\"param0\").equals(FORM));\n+        assert (request.getParameter(\"param1\").equals(URL));\n+\n+        // param2 have been overridden by the vanity url\n+        assert (request.getParameter(\"param2\").equals(VANITY));\n+\n+        assert (request.getParameter(\"param3\").equals(VANITY));\n+\n+        // param2 also has the original value from the url\n+        assert (request.getParameterValues(\"param2\").length == 2);\n+        assert (request.getParameterValues(\"param2\")[0].equals(VANITY));\n+        assert (request.getParameterValues(\"param2\")[1].equals(URL));\n+\n+\n+\n+    }\n+\n+    /**\n+     * This tests to insure that the new query string has both the old and the new query parameters\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_query_string_has_all_the_parameters() {\n+\n+\n+        final HttpServletRequest baseRequest = new MockHttpRequest(\"testing\", \"/test?param1=\" + URL + \"&param2=\" + URL).request();\n+\n+        final VanityUrlResult vanityUrlResult = new VanityUrlResult(\"/newUrl\", \"param2=\" + VANITY + \"&param3=\" + VANITY, false);\n+\n+        final HttpServletRequest request = new VanityUrlRequestWrapper(baseRequest, vanityUrlResult);\n+\n+        final String queryString= request.getQueryString();\n+        assert(queryString!=null);\n+        assert(!queryString.startsWith(\"&\"));\n+        assert(!queryString.endsWith(\"&\"));\n+        assert(queryString.contains(\"param1=\" + URL));", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjUwMQ==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092501", "bodyText": "Issue found: Local variable 'additional' could be declared final", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:11Z", "path": "dotCMS/src/main/java/com/dotmarketing/filters/VanityUrlRequestWrapper.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.dotmarketing.filters;\n+\n+import static com.dotmarketing.filters.Constants.CMS_FILTER_QUERY_STRING_OVERRIDE;\n+import static com.dotmarketing.filters.Constants.CMS_FILTER_URI_OVERRIDE;\n+import java.nio.charset.Charset;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.collect.ImmutableMap;\n+\n+\n+/**\n+ * The VanityUrlOverrideRequest merges the parameters set in the original request and merges them\n+ * with the parameters that are being set in the vanityUrl. In all cases, if there are parameters\n+ * set in the VanityURL Query String, they will override the ones being sent in by original visitors\n+ * request\n+ *\n+ */\n+class VanityUrlRequestWrapper extends HttpServletRequestWrapper {\n+    \n+    final Map<String, String[]> queryParamMap;\n+    final String newQueryString;\n+    final boolean vanityHasQueryString;\n+\n+\n+    public VanityUrlRequestWrapper(HttpServletRequest request, VanityUrlResult vanityUrlResult) {\n+        super(request);\n+\n+        \n+        this.vanityHasQueryString = UtilMethods.isSet(vanityUrlResult.getQueryString());\n+        \n+        this.newQueryString = vanityHasQueryString && UtilMethods.isSet(request.getQueryString())\n+                        ? request.getQueryString() + \"&\" + vanityUrlResult.getQueryString()\n+                        : vanityHasQueryString \n+                            ? vanityUrlResult.getQueryString()\n+                            : request.getQueryString();\n+\n+\n+        // we create a new map here because it merges the \n+        Map<String,String[]> tempMap = new HashMap<>(request.getParameterMap());\n+        if(vanityHasQueryString) {\n+            List<NameValuePair> additional = URLEncodedUtils.parse(newQueryString, Charset.forName(\"UTF-8\"));", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjUwOA==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092508", "bodyText": "Issue found: Local variable 'val' could be declared final", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:12Z", "path": "dotCMS/src/main/java/com/dotmarketing/filters/VanityUrlRequestWrapper.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.dotmarketing.filters;\n+\n+import static com.dotmarketing.filters.Constants.CMS_FILTER_QUERY_STRING_OVERRIDE;\n+import static com.dotmarketing.filters.Constants.CMS_FILTER_URI_OVERRIDE;\n+import java.nio.charset.Charset;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.collect.ImmutableMap;\n+\n+\n+/**\n+ * The VanityUrlOverrideRequest merges the parameters set in the original request and merges them\n+ * with the parameters that are being set in the vanityUrl. In all cases, if there are parameters\n+ * set in the VanityURL Query String, they will override the ones being sent in by original visitors\n+ * request\n+ *\n+ */\n+class VanityUrlRequestWrapper extends HttpServletRequestWrapper {\n+    \n+    final Map<String, String[]> queryParamMap;\n+    final String newQueryString;\n+    final boolean vanityHasQueryString;\n+\n+\n+    public VanityUrlRequestWrapper(HttpServletRequest request, VanityUrlResult vanityUrlResult) {\n+        super(request);\n+\n+        \n+        this.vanityHasQueryString = UtilMethods.isSet(vanityUrlResult.getQueryString());\n+        \n+        this.newQueryString = vanityHasQueryString && UtilMethods.isSet(request.getQueryString())\n+                        ? request.getQueryString() + \"&\" + vanityUrlResult.getQueryString()\n+                        : vanityHasQueryString \n+                            ? vanityUrlResult.getQueryString()\n+                            : request.getQueryString();\n+\n+\n+        // we create a new map here because it merges the \n+        Map<String,String[]> tempMap = new HashMap<>(request.getParameterMap());\n+        if(vanityHasQueryString) {\n+            List<NameValuePair> additional = URLEncodedUtils.parse(newQueryString, Charset.forName(\"UTF-8\"));\n+            for(NameValuePair nvp : additional) {\n+                tempMap.compute(nvp.getName(), (k, v) -> (v == null) ? new String[] {nvp.getValue()} : new String[]{nvp.getValue(),v[0]});\n+            }\n+        }\n+        \n+\n+        this.queryParamMap = ImmutableMap.copyOf(tempMap);\n+\n+\n+\n+        this.setAttribute(CMS_FILTER_URI_OVERRIDE, vanityUrlResult.getRewrite());\n+        this.setAttribute(CMS_FILTER_QUERY_STRING_OVERRIDE, this.newQueryString);\n+\n+    }\n+\n+    @Override\n+    public String getQueryString() {\n+        return this.newQueryString;\n+    }\n+\n+    @Override\n+    public String getParameter(final String name) {\n+        String[] val = this.queryParamMap.get(name);", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjUxOQ==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092519", "bodyText": "Issue found: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:13Z", "path": "dotCMS/src/test/java/com/dotmarketing/filters/VanityUrlRequestWrapperTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.dotmarketing.filters;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import org.junit.Test;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.request.MockParameterRequest;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.google.common.collect.ImmutableMap;\n+\n+public class VanityUrlRequestWrapperTest {\n+\n+    final String URL = \"URL\";\n+    final String FORM = \"FORM\";\n+    final String VANITY = \"VANITY\";\n+\n+\n+    /**\n+     * This tests if you have a vanity URL that has query parameters, that they will be merged into to\n+     * the request and if their keys match an existing parameter, the vanity url parameter will\n+     * overwrite any parameters that were in the original request\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_vanity_urls_with_query_params_override_incoming_requests() {\n+\n+        // three form params\n+        final Map<String, String> formParameters = ImmutableMap.of(\"param0\", FORM, \"param1\", FORM, \"param2\", FORM);\n+\n+\n+        // two url params (2 overlap)\n+        final HttpServletRequest baseRequest = new MockParameterRequest(\n+                        new MockHttpRequest(\"testing\", \"/test?param1=\" + URL + \"&param2=\" + URL).request(), formParameters)\n+                                        .request();\n+\n+        // two vanity params (1 overlaps)\n+        final VanityUrlResult vanityUrlResult = new VanityUrlResult(\"/newUrl\", \"param2=\" + VANITY + \"&param3=\" + VANITY, false);\n+\n+\n+        final HttpServletRequest request = new VanityUrlRequestWrapper(baseRequest, vanityUrlResult);\n+\n+\n+\n+        // we have 3 objects in our param map\n+        assert (request.getParameterMap().size() == 4);\n+\n+        assert (request.getParameter(\"param0\").equals(FORM));", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjU0Mg==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092542", "bodyText": "Issue found: Local variable 'nvp' could be declared final", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:14Z", "path": "dotCMS/src/main/java/com/dotmarketing/filters/VanityUrlRequestWrapper.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.dotmarketing.filters;\n+\n+import static com.dotmarketing.filters.Constants.CMS_FILTER_QUERY_STRING_OVERRIDE;\n+import static com.dotmarketing.filters.Constants.CMS_FILTER_URI_OVERRIDE;\n+import java.nio.charset.Charset;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.collect.ImmutableMap;\n+\n+\n+/**\n+ * The VanityUrlOverrideRequest merges the parameters set in the original request and merges them\n+ * with the parameters that are being set in the vanityUrl. In all cases, if there are parameters\n+ * set in the VanityURL Query String, they will override the ones being sent in by original visitors\n+ * request\n+ *\n+ */\n+class VanityUrlRequestWrapper extends HttpServletRequestWrapper {\n+    \n+    final Map<String, String[]> queryParamMap;\n+    final String newQueryString;\n+    final boolean vanityHasQueryString;\n+\n+\n+    public VanityUrlRequestWrapper(HttpServletRequest request, VanityUrlResult vanityUrlResult) {\n+        super(request);\n+\n+        \n+        this.vanityHasQueryString = UtilMethods.isSet(vanityUrlResult.getQueryString());\n+        \n+        this.newQueryString = vanityHasQueryString && UtilMethods.isSet(request.getQueryString())\n+                        ? request.getQueryString() + \"&\" + vanityUrlResult.getQueryString()\n+                        : vanityHasQueryString \n+                            ? vanityUrlResult.getQueryString()\n+                            : request.getQueryString();\n+\n+\n+        // we create a new map here because it merges the \n+        Map<String,String[]> tempMap = new HashMap<>(request.getParameterMap());\n+        if(vanityHasQueryString) {\n+            List<NameValuePair> additional = URLEncodedUtils.parse(newQueryString, Charset.forName(\"UTF-8\"));\n+            for(NameValuePair nvp : additional) {", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjU1OQ==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092559", "bodyText": "Issue found: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:15Z", "path": "dotCMS/src/test/java/com/dotmarketing/filters/VanityUrlRequestWrapperTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.dotmarketing.filters;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import org.junit.Test;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.request.MockParameterRequest;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.google.common.collect.ImmutableMap;\n+\n+public class VanityUrlRequestWrapperTest {\n+\n+    final String URL = \"URL\";\n+    final String FORM = \"FORM\";\n+    final String VANITY = \"VANITY\";\n+\n+\n+    /**\n+     * This tests if you have a vanity URL that has query parameters, that they will be merged into to\n+     * the request and if their keys match an existing parameter, the vanity url parameter will\n+     * overwrite any parameters that were in the original request\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_vanity_urls_with_query_params_override_incoming_requests() {\n+\n+        // three form params\n+        final Map<String, String> formParameters = ImmutableMap.of(\"param0\", FORM, \"param1\", FORM, \"param2\", FORM);\n+\n+\n+        // two url params (2 overlap)\n+        final HttpServletRequest baseRequest = new MockParameterRequest(\n+                        new MockHttpRequest(\"testing\", \"/test?param1=\" + URL + \"&param2=\" + URL).request(), formParameters)\n+                                        .request();\n+\n+        // two vanity params (1 overlaps)\n+        final VanityUrlResult vanityUrlResult = new VanityUrlResult(\"/newUrl\", \"param2=\" + VANITY + \"&param3=\" + VANITY, false);\n+\n+\n+        final HttpServletRequest request = new VanityUrlRequestWrapper(baseRequest, vanityUrlResult);\n+\n+\n+\n+        // we have 3 objects in our param map\n+        assert (request.getParameterMap().size() == 4);\n+\n+        assert (request.getParameter(\"param0\").equals(FORM));\n+        assert (request.getParameter(\"param1\").equals(URL));\n+\n+        // param2 have been overridden by the vanity url\n+        assert (request.getParameter(\"param2\").equals(VANITY));\n+\n+        assert (request.getParameter(\"param3\").equals(VANITY));\n+\n+        // param2 also has the original value from the url\n+        assert (request.getParameterValues(\"param2\").length == 2);", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjU3Mg==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092572", "bodyText": "Issue found: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:16Z", "path": "dotCMS/src/test/java/com/dotmarketing/filters/VanityUrlRequestWrapperTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.dotmarketing.filters;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import org.junit.Test;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.request.MockParameterRequest;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.google.common.collect.ImmutableMap;\n+\n+public class VanityUrlRequestWrapperTest {\n+\n+    final String URL = \"URL\";\n+    final String FORM = \"FORM\";\n+    final String VANITY = \"VANITY\";\n+\n+\n+    /**\n+     * This tests if you have a vanity URL that has query parameters, that they will be merged into to\n+     * the request and if their keys match an existing parameter, the vanity url parameter will\n+     * overwrite any parameters that were in the original request\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_vanity_urls_with_query_params_override_incoming_requests() {\n+\n+        // three form params\n+        final Map<String, String> formParameters = ImmutableMap.of(\"param0\", FORM, \"param1\", FORM, \"param2\", FORM);\n+\n+\n+        // two url params (2 overlap)\n+        final HttpServletRequest baseRequest = new MockParameterRequest(\n+                        new MockHttpRequest(\"testing\", \"/test?param1=\" + URL + \"&param2=\" + URL).request(), formParameters)\n+                                        .request();\n+\n+        // two vanity params (1 overlaps)\n+        final VanityUrlResult vanityUrlResult = new VanityUrlResult(\"/newUrl\", \"param2=\" + VANITY + \"&param3=\" + VANITY, false);\n+\n+\n+        final HttpServletRequest request = new VanityUrlRequestWrapper(baseRequest, vanityUrlResult);\n+\n+\n+\n+        // we have 3 objects in our param map\n+        assert (request.getParameterMap().size() == 4);\n+\n+        assert (request.getParameter(\"param0\").equals(FORM));\n+        assert (request.getParameter(\"param1\").equals(URL));\n+\n+        // param2 have been overridden by the vanity url\n+        assert (request.getParameter(\"param2\").equals(VANITY));\n+\n+        assert (request.getParameter(\"param3\").equals(VANITY));\n+\n+        // param2 also has the original value from the url\n+        assert (request.getParameterValues(\"param2\").length == 2);\n+        assert (request.getParameterValues(\"param2\")[0].equals(VANITY));\n+        assert (request.getParameterValues(\"param2\")[1].equals(URL));\n+\n+\n+\n+    }\n+\n+    /**\n+     * This tests to insure that the new query string has both the old and the new query parameters\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_query_string_has_all_the_parameters() {\n+\n+\n+        final HttpServletRequest baseRequest = new MockHttpRequest(\"testing\", \"/test?param1=\" + URL + \"&param2=\" + URL).request();\n+\n+        final VanityUrlResult vanityUrlResult = new VanityUrlResult(\"/newUrl\", \"param2=\" + VANITY + \"&param3=\" + VANITY, false);\n+\n+        final HttpServletRequest request = new VanityUrlRequestWrapper(baseRequest, vanityUrlResult);\n+\n+        final String queryString= request.getQueryString();\n+        assert(queryString!=null);\n+        assert(!queryString.startsWith(\"&\"));\n+        assert(!queryString.endsWith(\"&\"));\n+        assert(queryString.contains(\"param1=\" + URL));\n+        assert(queryString.contains(\"param2=\" + URL));\n+        assert(queryString.contains(\"param2=\" + VANITY));\n+        assert(queryString.contains(\"param3=\" + VANITY));\n+        List<NameValuePair> queryParams = URLEncodedUtils.parse(queryString, Charset.forName(\"UTF-8\"));\n+        assert(queryParams.size()==4);", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjU4Ng==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092586", "bodyText": "Issue found: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:17Z", "path": "dotCMS/src/test/java/com/dotmarketing/filters/VanityUrlRequestWrapperTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.dotmarketing.filters;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import org.junit.Test;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.request.MockParameterRequest;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.google.common.collect.ImmutableMap;\n+\n+public class VanityUrlRequestWrapperTest {\n+\n+    final String URL = \"URL\";\n+    final String FORM = \"FORM\";\n+    final String VANITY = \"VANITY\";\n+\n+\n+    /**\n+     * This tests if you have a vanity URL that has query parameters, that they will be merged into to\n+     * the request and if their keys match an existing parameter, the vanity url parameter will\n+     * overwrite any parameters that were in the original request\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_vanity_urls_with_query_params_override_incoming_requests() {\n+\n+        // three form params\n+        final Map<String, String> formParameters = ImmutableMap.of(\"param0\", FORM, \"param1\", FORM, \"param2\", FORM);\n+\n+\n+        // two url params (2 overlap)\n+        final HttpServletRequest baseRequest = new MockParameterRequest(\n+                        new MockHttpRequest(\"testing\", \"/test?param1=\" + URL + \"&param2=\" + URL).request(), formParameters)\n+                                        .request();\n+\n+        // two vanity params (1 overlaps)\n+        final VanityUrlResult vanityUrlResult = new VanityUrlResult(\"/newUrl\", \"param2=\" + VANITY + \"&param3=\" + VANITY, false);\n+\n+\n+        final HttpServletRequest request = new VanityUrlRequestWrapper(baseRequest, vanityUrlResult);\n+\n+\n+\n+        // we have 3 objects in our param map\n+        assert (request.getParameterMap().size() == 4);\n+\n+        assert (request.getParameter(\"param0\").equals(FORM));\n+        assert (request.getParameter(\"param1\").equals(URL));", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjYwMQ==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092601", "bodyText": "Issue found: Local variable 'additional' could be declared final", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:18Z", "path": "dotCMS/src/main/java/com/dotcms/mock/request/MockParameterRequest.java", "diffHunk": "@@ -24,6 +27,13 @@ public MockParameterRequest(HttpServletRequest request) {\n     public MockParameterRequest(HttpServletRequest request, Map<String, String> setMe) {\n         super(request);\n         HashMap<String, String> mutable = new HashMap<String, String>();\n+        \n+        List<NameValuePair> additional = URLEncodedUtils.parse(request.getQueryString(), Charset.forName(\"UTF-8\"));", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjYxNw==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092617", "bodyText": "Issue found: This final field could be made static", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:19Z", "path": "dotCMS/src/test/java/com/dotmarketing/filters/VanityUrlRequestWrapperTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.dotmarketing.filters;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import org.junit.Test;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.request.MockParameterRequest;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.google.common.collect.ImmutableMap;\n+\n+public class VanityUrlRequestWrapperTest {\n+\n+    final String URL = \"URL\";\n+    final String FORM = \"FORM\";", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjYzMQ==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092631", "bodyText": "Issue found: Local variable 'nvp' could be declared final", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:20Z", "path": "dotCMS/src/main/java/com/dotcms/mock/request/MockHttpRequest.java", "diffHunk": "@@ -18,15 +26,36 @@\n public class MockHttpRequest implements MockRequest {\n \n     private final HttpServletRequest request;\n-\n+    private final Map<String,String[]> paramMap;\n     public MockHttpRequest(final String hostname, final String uri) {\n         HttpServletRequest mockReq = new BaseRequest().request();\n         Mockito.when(mockReq.getRequestURI()).thenReturn(uri);\n         Mockito.when(mockReq.getRequestURL()).thenReturn(new StringBuffer(\"http://\" + hostname + uri));\n         Mockito.when(mockReq.getServerName()).thenReturn(hostname);\n         Mockito.when(mockReq.getRemoteAddr()).thenReturn(\"127.0.0.1\");\n         Mockito.when(mockReq.getRemoteHost()).thenReturn(\"127.0.0.1\");\n+        paramMap = new HashMap<>();\n+        if(uri.contains(\"?\")) {\n+            final String queryString = uri.substring(uri.indexOf(\"?\") + 1, uri.length());\n+            Mockito.when(mockReq.getQueryString()).thenReturn(queryString);\n+            List<NameValuePair> additional = URLEncodedUtils.parse(queryString, Charset.forName(\"UTF-8\"));\n+            for(NameValuePair nvp : additional) {", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjYzOQ==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092639", "bodyText": "Issue found: This call to String.startsWith can be rewritten using String.charAt(0)", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:21Z", "path": "dotCMS/src/test/java/com/dotmarketing/filters/VanityUrlRequestWrapperTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.dotmarketing.filters;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import org.junit.Test;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.request.MockParameterRequest;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.google.common.collect.ImmutableMap;\n+\n+public class VanityUrlRequestWrapperTest {\n+\n+    final String URL = \"URL\";\n+    final String FORM = \"FORM\";\n+    final String VANITY = \"VANITY\";\n+\n+\n+    /**\n+     * This tests if you have a vanity URL that has query parameters, that they will be merged into to\n+     * the request and if their keys match an existing parameter, the vanity url parameter will\n+     * overwrite any parameters that were in the original request\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_vanity_urls_with_query_params_override_incoming_requests() {\n+\n+        // three form params\n+        final Map<String, String> formParameters = ImmutableMap.of(\"param0\", FORM, \"param1\", FORM, \"param2\", FORM);\n+\n+\n+        // two url params (2 overlap)\n+        final HttpServletRequest baseRequest = new MockParameterRequest(\n+                        new MockHttpRequest(\"testing\", \"/test?param1=\" + URL + \"&param2=\" + URL).request(), formParameters)\n+                                        .request();\n+\n+        // two vanity params (1 overlaps)\n+        final VanityUrlResult vanityUrlResult = new VanityUrlResult(\"/newUrl\", \"param2=\" + VANITY + \"&param3=\" + VANITY, false);\n+\n+\n+        final HttpServletRequest request = new VanityUrlRequestWrapper(baseRequest, vanityUrlResult);\n+\n+\n+\n+        // we have 3 objects in our param map\n+        assert (request.getParameterMap().size() == 4);\n+\n+        assert (request.getParameter(\"param0\").equals(FORM));\n+        assert (request.getParameter(\"param1\").equals(URL));\n+\n+        // param2 have been overridden by the vanity url\n+        assert (request.getParameter(\"param2\").equals(VANITY));\n+\n+        assert (request.getParameter(\"param3\").equals(VANITY));\n+\n+        // param2 also has the original value from the url\n+        assert (request.getParameterValues(\"param2\").length == 2);\n+        assert (request.getParameterValues(\"param2\")[0].equals(VANITY));\n+        assert (request.getParameterValues(\"param2\")[1].equals(URL));\n+\n+\n+\n+    }\n+\n+    /**\n+     * This tests to insure that the new query string has both the old and the new query parameters\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_query_string_has_all_the_parameters() {\n+\n+\n+        final HttpServletRequest baseRequest = new MockHttpRequest(\"testing\", \"/test?param1=\" + URL + \"&param2=\" + URL).request();\n+\n+        final VanityUrlResult vanityUrlResult = new VanityUrlResult(\"/newUrl\", \"param2=\" + VANITY + \"&param3=\" + VANITY, false);\n+\n+        final HttpServletRequest request = new VanityUrlRequestWrapper(baseRequest, vanityUrlResult);\n+\n+        final String queryString= request.getQueryString();\n+        assert(queryString!=null);\n+        assert(!queryString.startsWith(\"&\"));", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjY0OA==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092648", "bodyText": "Issue found: Local variable 'nvp' could be declared final", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:22Z", "path": "dotCMS/src/main/java/com/dotcms/mock/request/MockParameterRequest.java", "diffHunk": "@@ -24,6 +27,13 @@ public MockParameterRequest(HttpServletRequest request) {\n     public MockParameterRequest(HttpServletRequest request, Map<String, String> setMe) {\n         super(request);\n         HashMap<String, String> mutable = new HashMap<String, String>();\n+        \n+        List<NameValuePair> additional = URLEncodedUtils.parse(request.getQueryString(), Charset.forName(\"UTF-8\"));\n+        for(NameValuePair nvp : additional) {", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjY2MQ==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092661", "bodyText": "Issue found: Parameter 'vanityUrlResult' is not assigned and could be declared final", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:23Z", "path": "dotCMS/src/main/java/com/dotmarketing/filters/VanityUrlRequestWrapper.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.dotmarketing.filters;\n+\n+import static com.dotmarketing.filters.Constants.CMS_FILTER_QUERY_STRING_OVERRIDE;\n+import static com.dotmarketing.filters.Constants.CMS_FILTER_URI_OVERRIDE;\n+import java.nio.charset.Charset;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.collect.ImmutableMap;\n+\n+\n+/**\n+ * The VanityUrlOverrideRequest merges the parameters set in the original request and merges them\n+ * with the parameters that are being set in the vanityUrl. In all cases, if there are parameters\n+ * set in the VanityURL Query String, they will override the ones being sent in by original visitors\n+ * request\n+ *\n+ */\n+class VanityUrlRequestWrapper extends HttpServletRequestWrapper {\n+    \n+    final Map<String, String[]> queryParamMap;\n+    final String newQueryString;\n+    final boolean vanityHasQueryString;\n+\n+\n+    public VanityUrlRequestWrapper(HttpServletRequest request, VanityUrlResult vanityUrlResult) {", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjY3MQ==", "url": "https://github.com/dotCMS/core/pull/18332#discussion_r414092671", "bodyText": "Issue found: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-04-23T20:13:24Z", "path": "dotCMS/src/test/java/com/dotmarketing/filters/VanityUrlRequestWrapperTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.dotmarketing.filters;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import org.junit.Test;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.request.MockParameterRequest;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.google.common.collect.ImmutableMap;\n+\n+public class VanityUrlRequestWrapperTest {\n+\n+    final String URL = \"URL\";\n+    final String FORM = \"FORM\";\n+    final String VANITY = \"VANITY\";\n+\n+\n+    /**\n+     * This tests if you have a vanity URL that has query parameters, that they will be merged into to\n+     * the request and if their keys match an existing parameter, the vanity url parameter will\n+     * overwrite any parameters that were in the original request\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_vanity_urls_with_query_params_override_incoming_requests() {\n+\n+        // three form params\n+        final Map<String, String> formParameters = ImmutableMap.of(\"param0\", FORM, \"param1\", FORM, \"param2\", FORM);\n+\n+\n+        // two url params (2 overlap)\n+        final HttpServletRequest baseRequest = new MockParameterRequest(\n+                        new MockHttpRequest(\"testing\", \"/test?param1=\" + URL + \"&param2=\" + URL).request(), formParameters)\n+                                        .request();\n+\n+        // two vanity params (1 overlaps)\n+        final VanityUrlResult vanityUrlResult = new VanityUrlResult(\"/newUrl\", \"param2=\" + VANITY + \"&param3=\" + VANITY, false);\n+\n+\n+        final HttpServletRequest request = new VanityUrlRequestWrapper(baseRequest, vanityUrlResult);\n+\n+\n+\n+        // we have 3 objects in our param map\n+        assert (request.getParameterMap().size() == 4);\n+\n+        assert (request.getParameter(\"param0\").equals(FORM));\n+        assert (request.getParameter(\"param1\").equals(URL));\n+\n+        // param2 have been overridden by the vanity url\n+        assert (request.getParameter(\"param2\").equals(VANITY));\n+\n+        assert (request.getParameter(\"param3\").equals(VANITY));\n+\n+        // param2 also has the original value from the url\n+        assert (request.getParameterValues(\"param2\").length == 2);\n+        assert (request.getParameterValues(\"param2\")[0].equals(VANITY));\n+        assert (request.getParameterValues(\"param2\")[1].equals(URL));\n+\n+\n+\n+    }\n+\n+    /**\n+     * This tests to insure that the new query string has both the old and the new query parameters\n+     * \n+     * see: https://github.com/dotCMS/core/issues/18325\n+     */\n+    @Test\n+    public void test_that_query_string_has_all_the_parameters() {\n+\n+\n+        final HttpServletRequest baseRequest = new MockHttpRequest(\"testing\", \"/test?param1=\" + URL + \"&param2=\" + URL).request();\n+\n+        final VanityUrlResult vanityUrlResult = new VanityUrlResult(\"/newUrl\", \"param2=\" + VANITY + \"&param3=\" + VANITY, false);\n+\n+        final HttpServletRequest request = new VanityUrlRequestWrapper(baseRequest, vanityUrlResult);\n+\n+        final String queryString= request.getQueryString();\n+        assert(queryString!=null);", "originalCommit": "fe949d3b27169b6c046cf579d4a8b6e1aacf7c90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}