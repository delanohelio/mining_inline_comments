{"pr_number": 18603, "pr_title": "Issue 18589 refactor GraphQL API", "pr_createdAt": "2020-06-04T20:05:29Z", "pr_url": "https://github.com/dotCMS/core/pull/18603", "timeline": [{"oid": "615de987710983c1b07b809d6d44ab763d34138d", "url": "https://github.com/dotCMS/core/commit/615de987710983c1b07b809d6d44ab763d34138d", "message": "#18297 refactor GraphQLAPIImpl", "committedDate": "2020-06-01T23:41:16Z", "type": "commit"}, {"oid": "75c0a5e5e415fc3d93d782e4b5652ea4d2b2b2ab", "url": "https://github.com/dotCMS/core/commit/75c0a5e5e415fc3d93d782e4b5652ea4d2b2b2ab", "message": "Merge branch 'master' of github.com:dotCMS/core into issue-18297-page-api-graphql", "committedDate": "2020-06-02T15:16:24Z", "type": "commit"}, {"oid": "4ef578e9411c2558ff1afe157e4fe4f91cdaf977", "url": "https://github.com/dotCMS/core/commit/4ef578e9411c2558ff1afe157e4fe4f91cdaf977", "message": "#18589 Refactor GraphQLAPI", "committedDate": "2020-06-03T23:10:59Z", "type": "commit"}, {"oid": "bf16d0d83251305937ab75302e4f9f168240e48b", "url": "https://github.com/dotCMS/core/commit/bf16d0d83251305937ab75302e4f9f168240e48b", "message": "#18589 restore schema cache. Remove unneeded class", "committedDate": "2020-06-03T23:46:41Z", "type": "commit"}, {"oid": "ece472f94e2531d590982f8e5544699f032a6419", "url": "https://github.com/dotCMS/core/commit/ece472f94e2531d590982f8e5544699f032a6419", "message": "#18589 GraphQL refactor part II", "committedDate": "2020-06-04T20:01:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk0NTYyOA==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r435945628", "bodyText": "really we nned a new method here, should not the 'findAll' method respect license?", "author": "freddyucv", "createdAt": "2020-06-05T14:06:00Z", "path": "dotCMS/src/main/java/com/dotcms/contenttype/business/ContentTypeAPI.java", "diffHunk": "@@ -77,6 +78,15 @@\n    */\n   List<ContentType> findAll() throws DotDataException;\n \n+  /**\n+   * Finds All the Content Types that exists in the system but takes into consideration the {@link LicenseLevel}.\n+   * If the {@link LicenseLevel} is Community, only the content types that are not an {@link com.dotcms.contenttype.model.type.EnterpriseType} will be returned\n+   *\n+   * @return List of Content Types Objects\n+   * @throws DotDataException Error occurred when performing the action.\n+   */\n+  List<ContentType> findAllRespectingLicense() throws DotDataException;", "originalCommit": "ece472f94e2531d590982f8e5544699f032a6419", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MDk5Ng==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436170996", "bodyText": "After discussing with @freddyucv we decided it is better to create a new one. So no changes here.", "author": "dsilvam", "createdAt": "2020-06-05T21:25:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk0NTYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MTAzNQ==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436171035", "bodyText": "After discussing with @freddyucv we decided it is better to create a new one. So no changes here.", "author": "dsilvam", "createdAt": "2020-06-05T21:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk0NTYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk0NzI0OQ==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r435947249", "bodyText": "is this method test?", "author": "freddyucv", "createdAt": "2020-06-05T14:08:41Z", "path": "dotCMS/src/main/java/com/dotcms/contenttype/business/ContentTypeAPIImpl.java", "diffHunk": "@@ -128,6 +132,16 @@ public ContentType find(final String inodeOrVar) throws DotSecurityException, Do\n \n   }\n \n+  @CloseDBIfOpened\n+  @Override\n+  public List<ContentType> findAllRespectingLicense() throws DotDataException {", "originalCommit": "ece472f94e2531d590982f8e5544699f032a6419", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5NzkyNw==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436197927", "bodyText": "Integration Test included", "author": "dsilvam", "createdAt": "2020-06-05T22:52:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk0NzI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk1MTMyMg==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r435951322", "bodyText": "doc?", "author": "freddyucv", "createdAt": "2020-06-05T14:15:03Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/exception/TypeGenerationException.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package com.dotcms.graphql.exception;\n+\n+import com.dotmarketing.exception.DotRuntimeException;\n+\n+public class TypeGenerationException extends DotRuntimeException {", "originalCommit": "ece472f94e2531d590982f8e5544699f032a6419", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MjE5Ng==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436172196", "bodyText": "Done", "author": "dsilvam", "createdAt": "2020-06-05T21:28:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk1MTMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk1MTQ0NQ==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r435951445", "bodyText": "doc?", "author": "freddyucv", "createdAt": "2020-06-05T14:15:14Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/exception/FieldGenerationException.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package com.dotcms.graphql.exception;\n+\n+import com.dotmarketing.exception.DotRuntimeException;\n+\n+public class FieldGenerationException extends DotRuntimeException {", "originalCommit": "ece472f94e2531d590982f8e5544699f032a6419", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MjI2NQ==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436172265", "bodyText": "Done", "author": "dsilvam", "createdAt": "2020-06-05T21:28:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk1MTQ0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk1MjI2Mg==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r435952262", "bodyText": "I think is better do this in a constructor, you can create two constructor one without parameter and one with RelationshipAPI, the last one should be @VisibleForTesting", "author": "freddyucv", "createdAt": "2020-06-05T14:16:39Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/business/RelationshipFieldGenerator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.dotcms.graphql.business;\n+\n+import static graphql.schema.GraphQLFieldDefinition.newFieldDefinition;\n+import static graphql.schema.GraphQLList.list;\n+import static graphql.schema.GraphQLNonNull.nonNull;\n+\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.graphql.datafetcher.RelationshipFieldDataFetcher;\n+import com.dotcms.graphql.exception.FieldGenerationException;\n+import com.dotcms.util.DotPreconditions;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.structure.model.ContentletRelationships;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLOutputType;\n+import graphql.schema.GraphQLTypeReference;\n+\n+/**\n+ * This implementation generates a {@link GraphQLFieldDefinition} only for {@link Field}s\n+ * of type {@link com.dotcms.contenttype.model.field.RelationshipField}\n+ */\n+class RelationshipFieldGenerator implements GraphQLFieldGenerator {\n+\n+    private RelationshipAPI relationshipAPI = APILocator.getRelationshipAPI();\n+\n+    @VisibleForTesting\n+    protected void setRelationshipAPI(RelationshipAPI relationshipAPI) {", "originalCommit": "ece472f94e2531d590982f8e5544699f032a6419", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MjIyMQ==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436172221", "bodyText": "Done", "author": "dsilvam", "createdAt": "2020-06-05T21:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk1MjI2Mg=="}], "type": "inlineReview"}, {"oid": "6a6ecc2c5c7b610403a319e8a40f63060fb537a2", "url": "https://github.com/dotCMS/core/commit/6a6ecc2c5c7b610403a319e8a40f63060fb537a2", "message": "18589 Include javadoc for new exceptions", "committedDate": "2020-06-05T21:18:48Z", "type": "commit"}, {"oid": "c88fe2745b8418276abaeddaac5709efcff5da69", "url": "https://github.com/dotCMS/core/commit/c88fe2745b8418276abaeddaac5709efcff5da69", "message": "#18589 code-review, integration test for new method", "committedDate": "2020-06-05T22:51:25Z", "type": "commit"}, {"oid": "1bedaf19ff821d440401ccf87cff722d773b3783", "url": "https://github.com/dotCMS/core/commit/1bedaf19ff821d440401ccf87cff722d773b3783", "message": "Merge branch 'master' of github.com:dotCMS/core into issue-18297-page-api-graphql", "committedDate": "2020-06-08T17:52:42Z", "type": "commit"}, {"oid": "f12c9003394120fe60bee34b46ecd8012c8192fa", "url": "https://github.com/dotCMS/core/commit/f12c9003394120fe60bee34b46ecd8012c8192fa", "message": "#18589 Fix failing tests. New fix and test for missing case", "committedDate": "2020-06-08T18:05:37Z", "type": "commit"}, {"oid": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "url": "https://github.com/dotCMS/core/commit/e7286b91a0d431dac4ccfaa4637dae41709dde19", "message": "#18589 Refactor test cases for cleaner asserts and more specific test methods", "committedDate": "2020-06-08T18:27:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMTkwNA==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436911904", "bodyText": "Issue found: Parameter 'relationshipAPI' is not assigned and could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:33Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/business/RelationshipFieldGenerator.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package com.dotcms.graphql.business;\n+\n+import static graphql.schema.GraphQLFieldDefinition.newFieldDefinition;\n+import static graphql.schema.GraphQLList.list;\n+import static graphql.schema.GraphQLNonNull.nonNull;\n+\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.graphql.datafetcher.RelationshipFieldDataFetcher;\n+import com.dotcms.graphql.exception.FieldGenerationException;\n+import com.dotcms.util.DotPreconditions;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.structure.model.ContentletRelationships;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLOutputType;\n+import graphql.schema.GraphQLTypeReference;\n+\n+/**\n+ * This implementation generates a {@link GraphQLFieldDefinition} only for {@link Field}s\n+ * of type {@link com.dotcms.contenttype.model.field.RelationshipField}\n+ */\n+class RelationshipFieldGenerator implements GraphQLFieldGenerator {\n+\n+    private RelationshipAPI relationshipAPI;\n+\n+    @VisibleForTesting\n+    public RelationshipFieldGenerator(RelationshipAPI relationshipAPI) {", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMTkxMw==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436911913", "bodyText": "Issue found: Local variable 'schema' could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:34Z", "path": "dotCMS/src/integration-test/java/com/dotcms/graphql/business/GraphqlAPITest.java", "diffHunk": "@@ -782,12 +784,10 @@ public void testGetSchema_GivenFailuresInRelationshipField_SchemaShouldStillGene\n \n             APILocator.getGraphqlAPI().invalidateSchema();\n \n-            RelationshipAPI relationshipAPI = Mockito.mock(RelationshipAPI.class);\n-            Mockito.when(relationshipAPI.\n-                    getRelationshipFromField(relationshipField, APILocator.systemUser()))\n-                    .thenReturn(null);\n+            // this mock relationship api will produce errors when generating the rel field\n+            setMockRelationshipAPI(relationshipField);\n \n-            final GraphQLSchema schema = new GraphqlAPIImpl(relationshipAPI).getSchema();\n+            GraphQLSchema schema = APILocator.getGraphqlAPI().getSchema();", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMTkyNQ==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436911925", "bodyText": "Issue found: New exception is thrown in catch block, original stack trace may be lost", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:35Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/business/RelationshipFieldGenerator.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package com.dotcms.graphql.business;\n+\n+import static graphql.schema.GraphQLFieldDefinition.newFieldDefinition;\n+import static graphql.schema.GraphQLList.list;\n+import static graphql.schema.GraphQLNonNull.nonNull;\n+\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.graphql.datafetcher.RelationshipFieldDataFetcher;\n+import com.dotcms.graphql.exception.FieldGenerationException;\n+import com.dotcms.util.DotPreconditions;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.structure.model.ContentletRelationships;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLOutputType;\n+import graphql.schema.GraphQLTypeReference;\n+\n+/**\n+ * This implementation generates a {@link GraphQLFieldDefinition} only for {@link Field}s\n+ * of type {@link com.dotcms.contenttype.model.field.RelationshipField}\n+ */\n+class RelationshipFieldGenerator implements GraphQLFieldGenerator {\n+\n+    private RelationshipAPI relationshipAPI;\n+\n+    @VisibleForTesting\n+    public RelationshipFieldGenerator(RelationshipAPI relationshipAPI) {\n+        this.relationshipAPI = relationshipAPI;\n+    }\n+\n+    public RelationshipFieldGenerator() {\n+        this(APILocator.getRelationshipAPI());\n+    }\n+\n+    @Override\n+    public GraphQLFieldDefinition generateField(final Field field) {\n+        return createRelationshipField(field);\n+    }\n+\n+    private GraphQLFieldDefinition createRelationshipField(\n+            final Field field) {\n+\n+        final ContentType relatedContentType;\n+        ContentType contentType = null;\n+\n+        try {\n+            contentType = APILocator.getContentTypeAPI(APILocator.systemUser())\n+                    .find(field.contentTypeId());\n+            relatedContentType = getRelatedContentTypeForField(field);\n+        } catch (DotSecurityException | DotDataException e) {\n+            throw new FieldGenerationException(\n+                    \"Unable to create relationship field type for field: \" + (contentType!=null ? contentType.variable() : \"N/D\")\n+                            + \".\" + field.variable(), e);\n+        }\n+\n+        Relationship relationship;\n+\n+        try {\n+            relationship = relationshipAPI.getRelationshipFromField(field,\n+                    APILocator.systemUser());\n+        } catch (DotDataException | DotSecurityException e) {\n+            throw new DotRuntimeException(e);\n+        }\n+\n+        final ContentletRelationships contentletRelationships = new ContentletRelationships(null);\n+        final ContentletRelationships.ContentletRelationshipRecords\n+                records = contentletRelationships.new ContentletRelationshipRecords(\n+                relationship,\n+                relationshipAPI.isChildField(relationship, field));\n+\n+        GraphQLOutputType outputType = GraphQLTypeReference.typeRef(relatedContentType.variable());\n+\n+        outputType = records.doesAllowOnlyOne()\n+                ? outputType\n+                : list(outputType);\n+\n+        return newFieldDefinition()\n+                .name(field.variable())\n+                .type(field.required() ? nonNull(outputType) : outputType)\n+                .dataFetcher(new RelationshipFieldDataFetcher()).build();\n+    }\n+\n+    private ContentType getRelatedContentTypeForField(final Field field) {\n+        DotPreconditions.checkNotNull(field, \"Field can't be null\");\n+        DotPreconditions.checkArgument(UtilMethods.isSet(field.variable()), \"Field variable needs to be set\");\n+        DotPreconditions.checkArgument(UtilMethods.isSet(field.relationType()), \"Field relationType needs to be set\");\n+\n+        final Relationship relationship;\n+        try {\n+            relationship = relationshipAPI.getRelationshipFromField(field,\n+                    APILocator.systemUser());\n+        } catch (DotSecurityException | DotDataException e) {\n+            throw new FieldGenerationException(\"Relationship with name:\"", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMTkzNA==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436911934", "bodyText": "Issue found: Parameter 'contentType' is not assigned and could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:36Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/business/ContentAPIGraphQLTypesProvider.java", "diffHunk": "@@ -0,0 +1,246 @@\n+package com.dotcms.graphql.business;\n+\n+import static com.dotcms.graphql.CustomFieldType.isCustomFieldType;\n+import static com.dotcms.graphql.business.GraphqlAPI.TYPES_AND_FIELDS_VALID_NAME_REGEX;\n+import static graphql.Scalars.GraphQLFloat;\n+import static graphql.Scalars.GraphQLInt;\n+import static graphql.Scalars.GraphQLString;\n+import static graphql.schema.GraphQLList.list;\n+\n+import com.dotcms.contenttype.model.field.BinaryField;\n+import com.dotcms.contenttype.model.field.CategoryField;\n+import com.dotcms.contenttype.model.field.CheckboxField;\n+import com.dotcms.contenttype.model.field.ColumnField;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FileField;\n+import com.dotcms.contenttype.model.field.HostFolderField;\n+import com.dotcms.contenttype.model.field.ImageField;\n+import com.dotcms.contenttype.model.field.KeyValueField;\n+import com.dotcms.contenttype.model.field.MultiSelectField;\n+import com.dotcms.contenttype.model.field.RelationshipsTabField;\n+import com.dotcms.contenttype.model.field.RowField;\n+import com.dotcms.contenttype.model.field.TagField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.graphql.CustomFieldType;\n+import com.dotcms.graphql.InterfaceType;\n+import com.dotcms.graphql.datafetcher.BinaryFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.CategoryFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.FieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.FileFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.KeyValueFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.MultiValueFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.SiteOrFolderFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.TagsFieldDataFetcher;\n+import com.dotcms.graphql.exception.FieldGenerationException;\n+import com.dotcms.graphql.exception.TypeGenerationException;\n+import com.dotcms.util.DotPreconditions;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import graphql.scalars.ExtendedScalars;\n+import graphql.schema.DataFetcher;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLOutputType;\n+import graphql.schema.GraphQLType;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * This singleton class provides all the {@link GraphQLType}s needed for the Content Delivery API\n+ */\n+public enum ContentAPIGraphQLTypesProvider implements GraphQLTypesProvider {\n+\n+    INSTANCE;\n+\n+    private GraphQLFieldGeneratorFactory fieldGeneratorFactory = new GraphQLFieldGeneratorFactory();\n+\n+    private final Map<Class<? extends Field>, GraphQLOutputType> fieldClassGraphqlTypeMap = new HashMap<>();\n+\n+    private final Map<Class<? extends Field>, DataFetcher> fieldClassGraphqlDataFetcher = new HashMap<>();\n+\n+    private final Map<String, GraphQLType> typesMap = new HashMap<>();\n+\n+    {\n+        // custom type mappings\n+        this.fieldClassGraphqlTypeMap.put(BinaryField.class, CustomFieldType.BINARY.getType());\n+        this.fieldClassGraphqlTypeMap\n+                .put(CategoryField.class, list(CustomFieldType.CATEGORY.getType()));\n+        this.fieldClassGraphqlTypeMap.put(ImageField.class, CustomFieldType.FILEASSET.getType());\n+        this.fieldClassGraphqlTypeMap.put(FileField.class, CustomFieldType.FILEASSET.getType());\n+        this.fieldClassGraphqlTypeMap\n+                .put(KeyValueField.class, list(CustomFieldType.KEY_VALUE.getType()));\n+        this.fieldClassGraphqlTypeMap.put(CheckboxField.class, list(GraphQLString));\n+        this.fieldClassGraphqlTypeMap.put(MultiSelectField.class, list(GraphQLString));\n+        this.fieldClassGraphqlTypeMap.put(TagField.class, list(GraphQLString));\n+        this.fieldClassGraphqlTypeMap\n+                .put(HostFolderField.class, CustomFieldType.SITE_OR_FOLDER.getType());\n+\n+        // custom data fetchers\n+        this.fieldClassGraphqlDataFetcher.put(BinaryField.class, new BinaryFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(CategoryField.class, new CategoryFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(ImageField.class, new FileFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(FileField.class, new FileFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(KeyValueField.class, new KeyValueFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher\n+                .put(CheckboxField.class, new MultiValueFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher\n+                .put(MultiSelectField.class, new MultiValueFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(TagField.class, new TagsFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher\n+                .put(HostFolderField.class, new SiteOrFolderFieldDataFetcher());\n+    }\n+\n+    @Override\n+    public Collection<GraphQLType> getTypes() throws DotDataException {\n+        // we want to generate them always - no cache\n+        getContentAPITypes().forEach((graphQLType)->\n+                typesMap.put(graphQLType.getName(), graphQLType));\n+\n+        return typesMap.values();\n+    }\n+\n+    Map<String, GraphQLType> getCachedTypesAsMap() throws DotDataException {\n+        if (!UtilMethods.isSet(typesMap)) {\n+            getContentAPITypes().forEach((graphQLType)->\n+                    typesMap.put(graphQLType.getName(), graphQLType));\n+        }\n+        return typesMap;\n+    }\n+\n+    private Set<GraphQLType> getContentAPITypes() throws DotDataException {\n+\n+        Set<GraphQLType> contentAPITypes = new HashSet<>(InterfaceType.valuesAsSet());\n+\n+        contentAPITypes.add(ExtendedScalars.DateTime);\n+\n+        List<ContentType> allTypes = APILocator.getContentTypeAPI(APILocator.systemUser())\n+                .findAllRespectingLicense();\n+\n+        allTypes.forEach((type) -> {\n+            try {\n+                contentAPITypes.add(createType(type));\n+            }catch (TypeGenerationException e) {\n+                Logger.error(this, \"Unable to generate GraphQL Type for type: \" + type.variable());\n+            }\n+        });\n+\n+        return contentAPITypes;\n+    }\n+\n+    private GraphQLObjectType createType(ContentType contentType) {\n+\n+        DotPreconditions.checkArgument(contentType.variable()\n+                .matches(TYPES_AND_FIELDS_VALID_NAME_REGEX),\n+                \"Content Type variable does not conform to naming rules\",\n+                TypeGenerationException.class);\n+\n+        final GraphQLObjectType.Builder builder = GraphQLObjectType.newObject()\n+                .name(contentType.variable());\n+\n+        // add CONTENT interface fields\n+        builder.fields(InterfaceType.CONTENTLET.getType().getFieldDefinitions());\n+\n+        if (InterfaceType.getInterfaceForBaseType(contentType.baseType()) != null) {\n+            builder.withInterface(InterfaceType.getInterfaceForBaseType(contentType.baseType()));\n+        }\n+\n+        builder.fields(createFieldsForType(contentType));\n+\n+        builder.withInterface(InterfaceType.CONTENTLET.getType());\n+        return builder.build();\n+    }\n+\n+    private List<GraphQLFieldDefinition> createFieldsForType(ContentType contentType) {", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMTk0MQ==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436911941", "bodyText": "Issue found: Local variable 'relationshipFieldGenerator' could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:37Z", "path": "dotCMS/src/integration-test/java/com/dotcms/graphql/business/GraphqlAPITest.java", "diffHunk": "@@ -801,9 +801,33 @@ public void testGetSchema_GivenFailuresInRelationshipField_SchemaShouldStillGene\n             assertNotNull(titleFieldDefinition);\n         } finally {\n             APILocator.getContentTypeAPI(APILocator.systemUser()).delete(contentType);\n+            // restore normal RelationshipAPI for ContentAPIGraphQLTypesProvider\n+            ContentAPIGraphQLTypesProvider.INSTANCE.setFieldGeneratorFactory(\n+                    new GraphQLFieldGeneratorFactory());\n         }\n     }\n \n+    @NotNull\n+    private void setMockRelationshipAPI(Field relationshipField)\n+            throws DotDataException, DotSecurityException {\n+        RelationshipAPI relationshipAPI = Mockito.mock(RelationshipAPI.class);\n+        Mockito.when(relationshipAPI.\n+                getRelationshipFromField(relationshipField, APILocator.systemUser()))\n+                .thenReturn(null);\n+\n+        RelationshipFieldGenerator relationshipFieldGenerator =", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMTk1MQ==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436911951", "bodyText": "Issue found: Parameter 'cause' is not assigned and could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:38Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/exception/FieldGenerationException.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package com.dotcms.graphql.exception;\n+\n+import com.dotmarketing.exception.DotRuntimeException;\n+import graphql.schema.GraphQLFieldDefinition;\n+\n+/**\n+ * Runtime Exception thrown when a {@link GraphQLFieldDefinition} can't be generated\n+ */\n+public class FieldGenerationException extends DotRuntimeException {\n+\n+    public FieldGenerationException(String message) {\n+        super(message);\n+    }\n+\n+    public FieldGenerationException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+    public FieldGenerationException(String message, Throwable cause) {", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMTk2Mg==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436911962", "bodyText": "Issue found: Parameter 'fieldGeneratorFactory' is not assigned and could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:39Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/business/ContentAPIGraphQLTypesProvider.java", "diffHunk": "@@ -0,0 +1,246 @@\n+package com.dotcms.graphql.business;\n+\n+import static com.dotcms.graphql.CustomFieldType.isCustomFieldType;\n+import static com.dotcms.graphql.business.GraphqlAPI.TYPES_AND_FIELDS_VALID_NAME_REGEX;\n+import static graphql.Scalars.GraphQLFloat;\n+import static graphql.Scalars.GraphQLInt;\n+import static graphql.Scalars.GraphQLString;\n+import static graphql.schema.GraphQLList.list;\n+\n+import com.dotcms.contenttype.model.field.BinaryField;\n+import com.dotcms.contenttype.model.field.CategoryField;\n+import com.dotcms.contenttype.model.field.CheckboxField;\n+import com.dotcms.contenttype.model.field.ColumnField;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FileField;\n+import com.dotcms.contenttype.model.field.HostFolderField;\n+import com.dotcms.contenttype.model.field.ImageField;\n+import com.dotcms.contenttype.model.field.KeyValueField;\n+import com.dotcms.contenttype.model.field.MultiSelectField;\n+import com.dotcms.contenttype.model.field.RelationshipsTabField;\n+import com.dotcms.contenttype.model.field.RowField;\n+import com.dotcms.contenttype.model.field.TagField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.graphql.CustomFieldType;\n+import com.dotcms.graphql.InterfaceType;\n+import com.dotcms.graphql.datafetcher.BinaryFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.CategoryFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.FieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.FileFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.KeyValueFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.MultiValueFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.SiteOrFolderFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.TagsFieldDataFetcher;\n+import com.dotcms.graphql.exception.FieldGenerationException;\n+import com.dotcms.graphql.exception.TypeGenerationException;\n+import com.dotcms.util.DotPreconditions;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import graphql.scalars.ExtendedScalars;\n+import graphql.schema.DataFetcher;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLOutputType;\n+import graphql.schema.GraphQLType;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * This singleton class provides all the {@link GraphQLType}s needed for the Content Delivery API\n+ */\n+public enum ContentAPIGraphQLTypesProvider implements GraphQLTypesProvider {\n+\n+    INSTANCE;\n+\n+    private GraphQLFieldGeneratorFactory fieldGeneratorFactory = new GraphQLFieldGeneratorFactory();\n+\n+    private final Map<Class<? extends Field>, GraphQLOutputType> fieldClassGraphqlTypeMap = new HashMap<>();\n+\n+    private final Map<Class<? extends Field>, DataFetcher> fieldClassGraphqlDataFetcher = new HashMap<>();\n+\n+    private final Map<String, GraphQLType> typesMap = new HashMap<>();\n+\n+    {\n+        // custom type mappings\n+        this.fieldClassGraphqlTypeMap.put(BinaryField.class, CustomFieldType.BINARY.getType());\n+        this.fieldClassGraphqlTypeMap\n+                .put(CategoryField.class, list(CustomFieldType.CATEGORY.getType()));\n+        this.fieldClassGraphqlTypeMap.put(ImageField.class, CustomFieldType.FILEASSET.getType());\n+        this.fieldClassGraphqlTypeMap.put(FileField.class, CustomFieldType.FILEASSET.getType());\n+        this.fieldClassGraphqlTypeMap\n+                .put(KeyValueField.class, list(CustomFieldType.KEY_VALUE.getType()));\n+        this.fieldClassGraphqlTypeMap.put(CheckboxField.class, list(GraphQLString));\n+        this.fieldClassGraphqlTypeMap.put(MultiSelectField.class, list(GraphQLString));\n+        this.fieldClassGraphqlTypeMap.put(TagField.class, list(GraphQLString));\n+        this.fieldClassGraphqlTypeMap\n+                .put(HostFolderField.class, CustomFieldType.SITE_OR_FOLDER.getType());\n+\n+        // custom data fetchers\n+        this.fieldClassGraphqlDataFetcher.put(BinaryField.class, new BinaryFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(CategoryField.class, new CategoryFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(ImageField.class, new FileFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(FileField.class, new FileFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(KeyValueField.class, new KeyValueFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher\n+                .put(CheckboxField.class, new MultiValueFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher\n+                .put(MultiSelectField.class, new MultiValueFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(TagField.class, new TagsFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher\n+                .put(HostFolderField.class, new SiteOrFolderFieldDataFetcher());\n+    }\n+\n+    @Override\n+    public Collection<GraphQLType> getTypes() throws DotDataException {\n+        // we want to generate them always - no cache\n+        getContentAPITypes().forEach((graphQLType)->\n+                typesMap.put(graphQLType.getName(), graphQLType));\n+\n+        return typesMap.values();\n+    }\n+\n+    Map<String, GraphQLType> getCachedTypesAsMap() throws DotDataException {\n+        if (!UtilMethods.isSet(typesMap)) {\n+            getContentAPITypes().forEach((graphQLType)->\n+                    typesMap.put(graphQLType.getName(), graphQLType));\n+        }\n+        return typesMap;\n+    }\n+\n+    private Set<GraphQLType> getContentAPITypes() throws DotDataException {\n+\n+        Set<GraphQLType> contentAPITypes = new HashSet<>(InterfaceType.valuesAsSet());\n+\n+        contentAPITypes.add(ExtendedScalars.DateTime);\n+\n+        List<ContentType> allTypes = APILocator.getContentTypeAPI(APILocator.systemUser())\n+                .findAllRespectingLicense();\n+\n+        allTypes.forEach((type) -> {\n+            try {\n+                contentAPITypes.add(createType(type));\n+            }catch (TypeGenerationException e) {\n+                Logger.error(this, \"Unable to generate GraphQL Type for type: \" + type.variable());\n+            }\n+        });\n+\n+        return contentAPITypes;\n+    }\n+\n+    private GraphQLObjectType createType(ContentType contentType) {\n+\n+        DotPreconditions.checkArgument(contentType.variable()\n+                .matches(TYPES_AND_FIELDS_VALID_NAME_REGEX),\n+                \"Content Type variable does not conform to naming rules\",\n+                TypeGenerationException.class);\n+\n+        final GraphQLObjectType.Builder builder = GraphQLObjectType.newObject()\n+                .name(contentType.variable());\n+\n+        // add CONTENT interface fields\n+        builder.fields(InterfaceType.CONTENTLET.getType().getFieldDefinitions());\n+\n+        if (InterfaceType.getInterfaceForBaseType(contentType.baseType()) != null) {\n+            builder.withInterface(InterfaceType.getInterfaceForBaseType(contentType.baseType()));\n+        }\n+\n+        builder.fields(createFieldsForType(contentType));\n+\n+        builder.withInterface(InterfaceType.CONTENTLET.getType());\n+        return builder.build();\n+    }\n+\n+    private List<GraphQLFieldDefinition> createFieldsForType(ContentType contentType) {\n+        final List<Field> fields = contentType.fields();\n+\n+        final List<GraphQLFieldDefinition> fieldDefinitions = new ArrayList<>();\n+\n+        fields.forEach((field) -> {\n+            // skip field.variable not sticking to the regex\n+            if (!field.variable().matches(TYPES_AND_FIELDS_VALID_NAME_REGEX)\n+                    || field instanceof RelationshipsTabField) {\n+                return;\n+            }\n+\n+            if (!(field instanceof RowField) && !(field instanceof ColumnField)) {\n+                try {\n+                    fieldDefinitions.add(fieldGeneratorFactory.getGenerator(field).generateField(field));\n+                } catch(FieldGenerationException e) {\n+                    Logger.error(this, \"Unable to generate GraphQL Field for field: \" + field.variable(), e);\n+                }\n+            }\n+\n+        });\n+\n+        return fieldDefinitions;\n+    }\n+\n+    public GraphQLOutputType getGraphqlTypeForFieldClass(final Class<? extends Field> fieldClass,\n+            final Field field) {\n+        return fieldClassGraphqlTypeMap.get(fieldClass) != null\n+                ? fieldClassGraphqlTypeMap.get(fieldClass)\n+                : fieldClass.equals(TextField.class) && field.dataType().equals(DataTypes.INTEGER)\n+                        ? GraphQLInt\n+                        : fieldClass.equals(TextField.class) && field.dataType()\n+                                .equals(DataTypes.FLOAT) ? GraphQLFloat\n+                                : GraphQLString;\n+    }\n+\n+    public DataFetcher getGraphqlDataFetcherForFieldClass(final Class<Field> fieldClass) {\n+        return fieldClassGraphqlDataFetcher.get(fieldClass) != null\n+                ? fieldClassGraphqlDataFetcher.get(fieldClass)\n+                : new FieldDataFetcher();\n+    }\n+\n+    /**\n+     * This method determines whether a {@link Field}'s variable is compatible with the\n+     * current GraphQL Schema.\n+     *<p>\n+     * The {@link Field} is deemed compatibly if any of the followings conditions are true:\n+     * <ul>\n+     *     <li>The field variable does not match any of the inherited fields names from the {@link InterfaceType#getContentletInheritedFields} </li>\n+     *     <li>The field variable matches the name of a inherited field but neither of them have a {@link CustomFieldType#getCustomFieldTypes}\n+     *     as its mapped GraphQL Type\n+     * </ul>\n+     * @param variable the variable whose compatibility will be checked\n+     * @param field the field which the variable will be set to\n+     * @return\n+     */\n+    public boolean isFieldVariableGraphQLCompatible(final String variable, final Field field) {\n+        // first let's check if there's an inherited field with the same variable\n+        if (InterfaceType.getContentletInheritedFields().containsKey(variable)) {\n+            // now let's check if the graphql types are compatible\n+\n+            // get inherited field's graphql type\n+            final GraphQLType inheritedFieldGraphQLType = InterfaceType\n+                    .getContentletInheritedFields()\n+                    .get(variable).getType();\n+\n+            // get new field's type\n+            final GraphQLType fieldGraphQLType = getGraphqlTypeForFieldClass(field.type(), field);\n+\n+            // if at least one of them is a custom type, they need to be equal to be compatible\n+            return (!isCustomFieldType(inheritedFieldGraphQLType)\n+                    && !isCustomFieldType(fieldGraphQLType))\n+                    || inheritedFieldGraphQLType.equals(fieldGraphQLType);\n+        }\n+\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    protected void setFieldGeneratorFactory(\n+            GraphQLFieldGeneratorFactory fieldGeneratorFactory) {", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMTk3Mg==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436911972", "bodyText": "Issue found: Local variable 'tryVar' could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:40Z", "path": "dotCMS/src/main/java/com/dotcms/contenttype/business/FieldFactoryImpl.java", "diffHunk": "@@ -249,13 +249,8 @@ private Field dbSaveUpdate(final Field throwAwayField) throws DotDataException {\n       final List<String> takenFieldVars = fieldsAlreadyAdded.stream().map(Field::variable).collect(\n               Collectors.toList());\n \n-      // check if the field variable is compatible with GraphQL\n-      if(!GraphQLUtil.isVariableGraphQLCompatible(throwAwayField)) {\n-          takenFieldVars.add(throwAwayField.name());\n-      }\n+      String tryVar = getFieldVariable(throwAwayField, takenFieldVars);", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMTk4Mg==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436911982", "bodyText": "Issue found: Parameter 'relationshipField' is not assigned and could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:41Z", "path": "dotCMS/src/integration-test/java/com/dotcms/graphql/business/GraphqlAPITest.java", "diffHunk": "@@ -801,9 +801,33 @@ public void testGetSchema_GivenFailuresInRelationshipField_SchemaShouldStillGene\n             assertNotNull(titleFieldDefinition);\n         } finally {\n             APILocator.getContentTypeAPI(APILocator.systemUser()).delete(contentType);\n+            // restore normal RelationshipAPI for ContentAPIGraphQLTypesProvider\n+            ContentAPIGraphQLTypesProvider.INSTANCE.setFieldGeneratorFactory(\n+                    new GraphQLFieldGeneratorFactory());\n         }\n     }\n \n+    @NotNull\n+    private void setMockRelationshipAPI(Field relationshipField)", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMTk5Mw==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436911993", "bodyText": "Issue found: Local variable 'fieldDefinitions' could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:42Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/business/ContentAPIGraphQLFieldsProvider.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.dotcms.graphql.business;\n+\n+import static com.dotcms.graphql.util.TypeUtil.BASE_TYPE_SUFFIX;\n+import static graphql.Scalars.GraphQLInt;\n+import static graphql.Scalars.GraphQLString;\n+import static graphql.schema.GraphQLFieldDefinition.newFieldDefinition;\n+import static graphql.schema.GraphQLList.list;\n+\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.graphql.InterfaceType;\n+import com.dotcms.graphql.datafetcher.ContentletDataFetcher;\n+import com.dotcms.graphql.util.TypeUtil;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.Logger;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLType;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.commons.collections.PredicateUtils;\n+\n+/**\n+ * This singleton class provides all the {@link GraphQLFieldDefinition}s needed for the Content Delivery API\n+ */\n+enum ContentAPIGraphQLFieldsProvider implements GraphQLFieldsProvider {\n+\n+    INSTANCE;\n+\n+    @Override\n+    public Collection<GraphQLFieldDefinition> getFields() throws DotDataException {\n+        // Each ContentType as query'able collection field\n+        final List<ContentType> contentTypeList = APILocator.getContentTypeAPI(APILocator.systemUser())\n+                .findAllRespectingLicense();\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = new ArrayList<>();", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMjAwMw==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436912003", "bodyText": "Issue found: Parameter 'cause' is not assigned and could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:43Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/exception/TypeGenerationException.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package com.dotcms.graphql.exception;\n+\n+import com.dotmarketing.exception.DotRuntimeException;\n+import graphql.schema.GraphQLType;\n+\n+\n+/**\n+ * Runtime Exception thrown when a {@link GraphQLType} can't be generated\n+ */\n+public class TypeGenerationException extends DotRuntimeException {\n+\n+    public TypeGenerationException(String message) {\n+        super(message);\n+    }\n+\n+    public TypeGenerationException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+    public TypeGenerationException(String message, Throwable cause) {", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMjAxMg==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436912012", "bodyText": "Issue found: Local variable 'fieldGeneratorFactory' could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:44Z", "path": "dotCMS/src/integration-test/java/com/dotcms/graphql/business/GraphqlAPITest.java", "diffHunk": "@@ -801,9 +801,33 @@ public void testGetSchema_GivenFailuresInRelationshipField_SchemaShouldStillGene\n             assertNotNull(titleFieldDefinition);\n         } finally {\n             APILocator.getContentTypeAPI(APILocator.systemUser()).delete(contentType);\n+            // restore normal RelationshipAPI for ContentAPIGraphQLTypesProvider\n+            ContentAPIGraphQLTypesProvider.INSTANCE.setFieldGeneratorFactory(\n+                    new GraphQLFieldGeneratorFactory());\n         }\n     }\n \n+    @NotNull\n+    private void setMockRelationshipAPI(Field relationshipField)\n+            throws DotDataException, DotSecurityException {\n+        RelationshipAPI relationshipAPI = Mockito.mock(RelationshipAPI.class);\n+        Mockito.when(relationshipAPI.\n+                getRelationshipFromField(relationshipField, APILocator.systemUser()))\n+                .thenReturn(null);\n+\n+        RelationshipFieldGenerator relationshipFieldGenerator =\n+                new RelationshipFieldGenerator(relationshipAPI);\n+\n+        // lets create a mocked FieldGeneratorFactory\n+        GraphQLFieldGeneratorFactory fieldGeneratorFactory =", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMjAyMA==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436912020", "bodyText": "Issue found: Local variable 'contentAPITypes' could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:45Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/business/ContentAPIGraphQLTypesProvider.java", "diffHunk": "@@ -0,0 +1,246 @@\n+package com.dotcms.graphql.business;\n+\n+import static com.dotcms.graphql.CustomFieldType.isCustomFieldType;\n+import static com.dotcms.graphql.business.GraphqlAPI.TYPES_AND_FIELDS_VALID_NAME_REGEX;\n+import static graphql.Scalars.GraphQLFloat;\n+import static graphql.Scalars.GraphQLInt;\n+import static graphql.Scalars.GraphQLString;\n+import static graphql.schema.GraphQLList.list;\n+\n+import com.dotcms.contenttype.model.field.BinaryField;\n+import com.dotcms.contenttype.model.field.CategoryField;\n+import com.dotcms.contenttype.model.field.CheckboxField;\n+import com.dotcms.contenttype.model.field.ColumnField;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FileField;\n+import com.dotcms.contenttype.model.field.HostFolderField;\n+import com.dotcms.contenttype.model.field.ImageField;\n+import com.dotcms.contenttype.model.field.KeyValueField;\n+import com.dotcms.contenttype.model.field.MultiSelectField;\n+import com.dotcms.contenttype.model.field.RelationshipsTabField;\n+import com.dotcms.contenttype.model.field.RowField;\n+import com.dotcms.contenttype.model.field.TagField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.graphql.CustomFieldType;\n+import com.dotcms.graphql.InterfaceType;\n+import com.dotcms.graphql.datafetcher.BinaryFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.CategoryFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.FieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.FileFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.KeyValueFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.MultiValueFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.SiteOrFolderFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.TagsFieldDataFetcher;\n+import com.dotcms.graphql.exception.FieldGenerationException;\n+import com.dotcms.graphql.exception.TypeGenerationException;\n+import com.dotcms.util.DotPreconditions;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import graphql.scalars.ExtendedScalars;\n+import graphql.schema.DataFetcher;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLOutputType;\n+import graphql.schema.GraphQLType;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * This singleton class provides all the {@link GraphQLType}s needed for the Content Delivery API\n+ */\n+public enum ContentAPIGraphQLTypesProvider implements GraphQLTypesProvider {\n+\n+    INSTANCE;\n+\n+    private GraphQLFieldGeneratorFactory fieldGeneratorFactory = new GraphQLFieldGeneratorFactory();\n+\n+    private final Map<Class<? extends Field>, GraphQLOutputType> fieldClassGraphqlTypeMap = new HashMap<>();\n+\n+    private final Map<Class<? extends Field>, DataFetcher> fieldClassGraphqlDataFetcher = new HashMap<>();\n+\n+    private final Map<String, GraphQLType> typesMap = new HashMap<>();\n+\n+    {\n+        // custom type mappings\n+        this.fieldClassGraphqlTypeMap.put(BinaryField.class, CustomFieldType.BINARY.getType());\n+        this.fieldClassGraphqlTypeMap\n+                .put(CategoryField.class, list(CustomFieldType.CATEGORY.getType()));\n+        this.fieldClassGraphqlTypeMap.put(ImageField.class, CustomFieldType.FILEASSET.getType());\n+        this.fieldClassGraphqlTypeMap.put(FileField.class, CustomFieldType.FILEASSET.getType());\n+        this.fieldClassGraphqlTypeMap\n+                .put(KeyValueField.class, list(CustomFieldType.KEY_VALUE.getType()));\n+        this.fieldClassGraphqlTypeMap.put(CheckboxField.class, list(GraphQLString));\n+        this.fieldClassGraphqlTypeMap.put(MultiSelectField.class, list(GraphQLString));\n+        this.fieldClassGraphqlTypeMap.put(TagField.class, list(GraphQLString));\n+        this.fieldClassGraphqlTypeMap\n+                .put(HostFolderField.class, CustomFieldType.SITE_OR_FOLDER.getType());\n+\n+        // custom data fetchers\n+        this.fieldClassGraphqlDataFetcher.put(BinaryField.class, new BinaryFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(CategoryField.class, new CategoryFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(ImageField.class, new FileFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(FileField.class, new FileFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(KeyValueField.class, new KeyValueFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher\n+                .put(CheckboxField.class, new MultiValueFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher\n+                .put(MultiSelectField.class, new MultiValueFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(TagField.class, new TagsFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher\n+                .put(HostFolderField.class, new SiteOrFolderFieldDataFetcher());\n+    }\n+\n+    @Override\n+    public Collection<GraphQLType> getTypes() throws DotDataException {\n+        // we want to generate them always - no cache\n+        getContentAPITypes().forEach((graphQLType)->\n+                typesMap.put(graphQLType.getName(), graphQLType));\n+\n+        return typesMap.values();\n+    }\n+\n+    Map<String, GraphQLType> getCachedTypesAsMap() throws DotDataException {\n+        if (!UtilMethods.isSet(typesMap)) {\n+            getContentAPITypes().forEach((graphQLType)->\n+                    typesMap.put(graphQLType.getName(), graphQLType));\n+        }\n+        return typesMap;\n+    }\n+\n+    private Set<GraphQLType> getContentAPITypes() throws DotDataException {\n+\n+        Set<GraphQLType> contentAPITypes = new HashSet<>(InterfaceType.valuesAsSet());", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMjAyNw==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436912027", "bodyText": "Issue found: Local variable 'rootTypeBuilder' could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:46Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/business/GraphqlAPIImpl.java", "diffHunk": "@@ -160,137 +97,37 @@ private void printSchema() {\n         }\n     }\n \n-    private void createSchemaType(ContentType contentType,\n-                                              final Map<String, GraphQLObjectType> graphqlObjectTypes) {\n-\n-        // skip contentType.variable not sticking to the regex\n-        if(!contentType.variable().matches(TYPES_AND_FIELDS_VALID_NAME_REGEX)) {\n-            return;\n-        }\n-\n-        final GraphQLObjectType.Builder builder = GraphQLObjectType.newObject().name(contentType.variable());\n-\n-        // add CONTENT interface fields\n-        builder.fields(InterfaceType.CONTENTLET.getType().getFieldDefinitions());\n-\n-        if(InterfaceType.getInterfaceForBaseType(contentType.baseType())!=null) {\n-            builder.withInterface(InterfaceType.getInterfaceForBaseType(contentType.baseType()));\n-        }\n-\n-        final List<Field> fields = contentType.fields();\n-\n-        fields.forEach((field)->{\n-            // skip field.variable not sticking to the regex\n-            if(!field.variable().matches(TYPES_AND_FIELDS_VALID_NAME_REGEX)\n-                || field instanceof RelationshipsTabField) {\n-                return;\n-            }\n+    @LogTime(loggingLevel = \"INFO\")\n+    private GraphQLSchema generateSchema() throws DotDataException {\n+        final Set<GraphQLType> graphQLTypes = new HashSet<>();\n \n-            if(!(field instanceof RowField) && !(field instanceof ColumnField)) {\n-                if (field instanceof RelationshipField) {\n-                    try {\n-                        handleRelationshipField(contentType, builder, field, graphqlObjectTypes);\n-                    } catch(DotStateException e) {\n-                        Logger.error(this, \"Unable to create relationship field\", e);\n-                    }\n-                } else {\n-                    builder.field(newFieldDefinition()\n-                        .name(field.variable())\n-                        .type(field.required()\n-                            ? nonNull(getGraphqlTypeForFieldClass(field.type(), field))\n-                            : getGraphqlTypeForFieldClass(field.type(), field))\n-                        .dataFetcher(getGraphqlDataFetcherForFieldClass(field.type()))\n-                    );\n-                }\n+        for (GraphQLTypesProvider typesProvider : typesProviders) {\n+            try {\n+                graphQLTypes.addAll(typesProvider.getTypes());\n+            } catch (DotDataException e) {\n+                Logger.error(\"Unable to get types for type provider:\" + typesProvider\n+                        .getClass(), e);\n             }\n-        });\n-\n-        builder.withInterface(InterfaceType.CONTENTLET.getType());\n-        final GraphQLObjectType graphQLType = builder.build();\n-\n-        graphqlObjectTypes.put(graphQLType.getName(), graphQLType);\n-    }\n-\n-    private void handleRelationshipField(final ContentType contentType, GraphQLObjectType.Builder builder,\n-                                         final Field field, final Map<String, GraphQLObjectType> typesMap) {\n-\n-        final ContentType relatedContentType;\n-        try {\n-            relatedContentType = getRelatedContentTypeForField(field, APILocator.systemUser());\n-        } catch (DotSecurityException | DotDataException e) {\n-            throw new DotStateException(\"Unable to create relationship field type for field: \" + contentType.variable() + \".\" + field.variable(), e);\n         }\n \n-        Relationship relationship;\n+        List<GraphQLFieldDefinition> fieldDefinitions = new ArrayList<>();\n \n-        try {\n-            relationship = relationshipAPI.getRelationshipFromField(field,\n-                APILocator.systemUser());\n-        } catch (DotDataException | DotSecurityException e) {\n-            throw new DotRuntimeException(e);\n+        for (GraphQLFieldsProvider fieldsProvider : fieldsProviders) {\n+            try {\n+                fieldDefinitions.addAll(fieldsProvider.getFields());\n+            } catch (DotDataException e) {\n+                Logger.error(\"Unable to get types for type provider:\" + fieldsProvider.getClass(), e);\n+            }\n         }\n \n-        final ContentletRelationships contentletRelationships = new ContentletRelationships(null);\n-        final ContentletRelationships.ContentletRelationshipRecords\n-            records = contentletRelationships.new ContentletRelationshipRecords(\n-            relationship,\n-            relationshipAPI.isChildField(relationship, field));\n-\n-        GraphQLOutputType outputType = typesMap.get(relatedContentType.variable()) != null\n-            ? typesMap.get(relatedContentType.variable())\n-            : GraphQLTypeReference.typeRef(relatedContentType.variable());\n-\n-\n-        outputType = records.doesAllowOnlyOne()\n-            ? outputType\n-            : list(outputType);\n-\n-        builder.field(newFieldDefinition()\n-            .name(field.variable())\n-            .type(field.required()?nonNull(outputType):outputType)\n-            .dataFetcher(new RelationshipFieldDataFetcher())\n-        );\n-    }\n-\n-    @Override\n-    public GraphQLOutputType getGraphqlTypeForFieldClass(final Class<? extends Field> fieldClass, final Field field) {\n-        return fieldClassGraphqlTypeMap.get(fieldClass)!= null\n-            ? fieldClassGraphqlTypeMap.get(fieldClass)\n-            : fieldClass.equals(TextField.class) && field.dataType().equals(DataTypes.INTEGER) ? GraphQLInt\n-                : fieldClass.equals(TextField.class) && field.dataType().equals(DataTypes.FLOAT) ? GraphQLFloat\n-                    : GraphQLString;\n-    }\n+        // Root Type\n+        GraphQLObjectType.Builder rootTypeBuilder = createRootTypeBuilder().fields(fieldDefinitions);", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMjAzOQ==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436912039", "bodyText": "Issue found: Parameter 'contentType' is not assigned and could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:47Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/business/ContentAPIGraphQLTypesProvider.java", "diffHunk": "@@ -0,0 +1,246 @@\n+package com.dotcms.graphql.business;\n+\n+import static com.dotcms.graphql.CustomFieldType.isCustomFieldType;\n+import static com.dotcms.graphql.business.GraphqlAPI.TYPES_AND_FIELDS_VALID_NAME_REGEX;\n+import static graphql.Scalars.GraphQLFloat;\n+import static graphql.Scalars.GraphQLInt;\n+import static graphql.Scalars.GraphQLString;\n+import static graphql.schema.GraphQLList.list;\n+\n+import com.dotcms.contenttype.model.field.BinaryField;\n+import com.dotcms.contenttype.model.field.CategoryField;\n+import com.dotcms.contenttype.model.field.CheckboxField;\n+import com.dotcms.contenttype.model.field.ColumnField;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FileField;\n+import com.dotcms.contenttype.model.field.HostFolderField;\n+import com.dotcms.contenttype.model.field.ImageField;\n+import com.dotcms.contenttype.model.field.KeyValueField;\n+import com.dotcms.contenttype.model.field.MultiSelectField;\n+import com.dotcms.contenttype.model.field.RelationshipsTabField;\n+import com.dotcms.contenttype.model.field.RowField;\n+import com.dotcms.contenttype.model.field.TagField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.graphql.CustomFieldType;\n+import com.dotcms.graphql.InterfaceType;\n+import com.dotcms.graphql.datafetcher.BinaryFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.CategoryFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.FieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.FileFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.KeyValueFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.MultiValueFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.SiteOrFolderFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.TagsFieldDataFetcher;\n+import com.dotcms.graphql.exception.FieldGenerationException;\n+import com.dotcms.graphql.exception.TypeGenerationException;\n+import com.dotcms.util.DotPreconditions;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import graphql.scalars.ExtendedScalars;\n+import graphql.schema.DataFetcher;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLOutputType;\n+import graphql.schema.GraphQLType;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * This singleton class provides all the {@link GraphQLType}s needed for the Content Delivery API\n+ */\n+public enum ContentAPIGraphQLTypesProvider implements GraphQLTypesProvider {\n+\n+    INSTANCE;\n+\n+    private GraphQLFieldGeneratorFactory fieldGeneratorFactory = new GraphQLFieldGeneratorFactory();\n+\n+    private final Map<Class<? extends Field>, GraphQLOutputType> fieldClassGraphqlTypeMap = new HashMap<>();\n+\n+    private final Map<Class<? extends Field>, DataFetcher> fieldClassGraphqlDataFetcher = new HashMap<>();\n+\n+    private final Map<String, GraphQLType> typesMap = new HashMap<>();\n+\n+    {\n+        // custom type mappings\n+        this.fieldClassGraphqlTypeMap.put(BinaryField.class, CustomFieldType.BINARY.getType());\n+        this.fieldClassGraphqlTypeMap\n+                .put(CategoryField.class, list(CustomFieldType.CATEGORY.getType()));\n+        this.fieldClassGraphqlTypeMap.put(ImageField.class, CustomFieldType.FILEASSET.getType());\n+        this.fieldClassGraphqlTypeMap.put(FileField.class, CustomFieldType.FILEASSET.getType());\n+        this.fieldClassGraphqlTypeMap\n+                .put(KeyValueField.class, list(CustomFieldType.KEY_VALUE.getType()));\n+        this.fieldClassGraphqlTypeMap.put(CheckboxField.class, list(GraphQLString));\n+        this.fieldClassGraphqlTypeMap.put(MultiSelectField.class, list(GraphQLString));\n+        this.fieldClassGraphqlTypeMap.put(TagField.class, list(GraphQLString));\n+        this.fieldClassGraphqlTypeMap\n+                .put(HostFolderField.class, CustomFieldType.SITE_OR_FOLDER.getType());\n+\n+        // custom data fetchers\n+        this.fieldClassGraphqlDataFetcher.put(BinaryField.class, new BinaryFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(CategoryField.class, new CategoryFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(ImageField.class, new FileFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(FileField.class, new FileFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(KeyValueField.class, new KeyValueFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher\n+                .put(CheckboxField.class, new MultiValueFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher\n+                .put(MultiSelectField.class, new MultiValueFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(TagField.class, new TagsFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher\n+                .put(HostFolderField.class, new SiteOrFolderFieldDataFetcher());\n+    }\n+\n+    @Override\n+    public Collection<GraphQLType> getTypes() throws DotDataException {\n+        // we want to generate them always - no cache\n+        getContentAPITypes().forEach((graphQLType)->\n+                typesMap.put(graphQLType.getName(), graphQLType));\n+\n+        return typesMap.values();\n+    }\n+\n+    Map<String, GraphQLType> getCachedTypesAsMap() throws DotDataException {\n+        if (!UtilMethods.isSet(typesMap)) {\n+            getContentAPITypes().forEach((graphQLType)->\n+                    typesMap.put(graphQLType.getName(), graphQLType));\n+        }\n+        return typesMap;\n+    }\n+\n+    private Set<GraphQLType> getContentAPITypes() throws DotDataException {\n+\n+        Set<GraphQLType> contentAPITypes = new HashSet<>(InterfaceType.valuesAsSet());\n+\n+        contentAPITypes.add(ExtendedScalars.DateTime);\n+\n+        List<ContentType> allTypes = APILocator.getContentTypeAPI(APILocator.systemUser())\n+                .findAllRespectingLicense();\n+\n+        allTypes.forEach((type) -> {\n+            try {\n+                contentAPITypes.add(createType(type));\n+            }catch (TypeGenerationException e) {\n+                Logger.error(this, \"Unable to generate GraphQL Type for type: \" + type.variable());\n+            }\n+        });\n+\n+        return contentAPITypes;\n+    }\n+\n+    private GraphQLObjectType createType(ContentType contentType) {", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMjA0Ng==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436912046", "bodyText": "Issue found: Avoid unused local variables such as 'field'.", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:48Z", "path": "dotCMS/src/integration-test/java/com/dotcms/contenttype/business/FieldAPITest.java", "diffHunk": "@@ -1068,227 +1069,289 @@ public void testSaveFieldVariable_KeyWithSpecialChars_ShouldSucceed(final String\n \n \n     @DataProvider(format = \"%m: %p[0]\")\n-    public static Object[] dataProviderGraphQLReservedNames() {\n+    public static Object[] dataProviderGraphQLCompatibleFields() {\n+        final GraphQLFieldNameCompatibilityTestCase caseModDateCompatible = new GraphQLFieldNameCompatibilityTestCase();\n+        caseModDateCompatible.fieldName = MOD_DATE;\n+        caseModDateCompatible.fieldType = ImmutableDateField.class;\n+        caseModDateCompatible.testCaseName = \"caseModDateCompatible\";\n+\n+        final GraphQLFieldNameCompatibilityTestCase caseTitleCompatible = new GraphQLFieldNameCompatibilityTestCase();\n+        caseTitleCompatible.fieldName = TITLE;\n+        caseTitleCompatible.fieldType = ImmutableTextField.class;\n+        caseTitleCompatible.testCaseName = \"caseTitleCompatible\";\n+\n+        final GraphQLFieldNameCompatibilityTestCase caseTitleImageCompatible = new GraphQLFieldNameCompatibilityTestCase();\n+        caseTitleImageCompatible.fieldName = TITLE_IMAGE_KEY;\n+        caseTitleImageCompatible.fieldType = ImmutableBinaryField.class;\n+\n+        final GraphQLFieldNameCompatibilityTestCase caseContentTypeCompatible = new GraphQLFieldNameCompatibilityTestCase();\n+        caseContentTypeCompatible.fieldName = CONTENT_TYPE;\n+        caseContentTypeCompatible.fieldType = ImmutableTextField.class;\n+        caseContentTypeCompatible.testCaseName = \"caseContentTypeCompatible\";\n+\n+        final GraphQLFieldNameCompatibilityTestCase caseBaseTypeCompatible = new GraphQLFieldNameCompatibilityTestCase();\n+        caseBaseTypeCompatible.fieldName = BASE_TYPE;\n+        caseBaseTypeCompatible.fieldType = ImmutableTextField.class;\n+        caseBaseTypeCompatible.testCaseName = \"caseBaseTypeCompatible\";\n+\n+        final GraphQLFieldNameCompatibilityTestCase caseLiveCompatible = new GraphQLFieldNameCompatibilityTestCase();\n+        caseLiveCompatible.fieldName = LIVE;\n+        caseLiveCompatible.fieldType = ImmutableTextField.class;\n+        caseLiveCompatible.testCaseName = \"caseLiveCompatible\";\n+\n+        final GraphQLFieldNameCompatibilityTestCase caseWorkingCompatible = new GraphQLFieldNameCompatibilityTestCase();\n+        caseWorkingCompatible.fieldName = WORKING;\n+        caseWorkingCompatible.fieldType = ImmutableTextField.class;\n+        caseWorkingCompatible.testCaseName = \"caseWorkingCompatible\";\n+\n+        final GraphQLFieldNameCompatibilityTestCase caseArchivedCompatible = new GraphQLFieldNameCompatibilityTestCase();\n+        caseArchivedCompatible.fieldName = ARCHIVED_KEY;\n+        caseArchivedCompatible.fieldType = ImmutableTextField.class;\n+        caseArchivedCompatible.testCaseName = \"caseArchivedCompatible\";\n+\n+        final GraphQLFieldNameCompatibilityTestCase caseLockedCompatible = new GraphQLFieldNameCompatibilityTestCase();\n+        caseLockedCompatible.fieldName = LOCKED_KEY;\n+        caseLockedCompatible.fieldType = ImmutableTextField.class;\n+        caseLockedCompatible.testCaseName = \"caseLockedCompatible\";\n+\n+        final GraphQLFieldNameCompatibilityTestCase caseIdentifierCompatible = new GraphQLFieldNameCompatibilityTestCase();\n+        caseIdentifierCompatible.fieldName = IDENTIFIER;\n+        caseIdentifierCompatible.fieldType = ImmutableTextField.class;\n+        caseIdentifierCompatible.testCaseName = \"caseIdentifierCompatible\";\n+\n+        final GraphQLFieldNameCompatibilityTestCase caseInodeCompatible = new GraphQLFieldNameCompatibilityTestCase();\n+        caseInodeCompatible.fieldName = INODE;\n+        caseInodeCompatible.fieldType = ImmutableTextField.class;\n+        caseInodeCompatible.testCaseName = \"caseInodeCompatible\";\n+\n+        final GraphQLFieldNameCompatibilityTestCase caseUrlMapCompatible = new GraphQLFieldNameCompatibilityTestCase();\n+        caseUrlMapCompatible.fieldName = URL_MAP;\n+        caseUrlMapCompatible.fieldType = ImmutableTextField.class;\n+        caseUrlMapCompatible.testCaseName = \"caseUrlMapCompatible\";\n+\n+        return new GraphQLFieldNameCompatibilityTestCase[] {\n+                caseModDateCompatible,\n+                caseTitleCompatible,\n+                caseTitleImageCompatible,\n+                caseContentTypeCompatible,\n+                caseBaseTypeCompatible,\n+                caseLiveCompatible,\n+                caseWorkingCompatible,\n+                caseArchivedCompatible,\n+                caseLockedCompatible,\n+                caseIdentifierCompatible,\n+                caseInodeCompatible,\n+                caseUrlMapCompatible,\n+        };\n+    }\n+\n+    @DataProvider(format = \"%m: %p[0]\")\n+    public static Object[] dataProviderGraphQLIncompatibleFields() {\n \n         final GraphQLFieldNameCompatibilityTestCase caseModDateIncompatible = new GraphQLFieldNameCompatibilityTestCase();\n         caseModDateIncompatible.fieldName = MOD_DATE;\n         caseModDateIncompatible.fieldType = ImmutableBinaryField.class;\n-        caseModDateIncompatible.shouldCreateNewVariable = true;\n         caseModDateIncompatible.testCaseName = \"caseModDateIncompatible\";\n \n-        final GraphQLFieldNameCompatibilityTestCase caseModDateCompatible = new GraphQLFieldNameCompatibilityTestCase();\n-        caseModDateCompatible.fieldName = MOD_DATE;\n-        caseModDateCompatible.fieldType = ImmutableDateField.class;\n-        caseModDateCompatible.shouldCreateNewVariable = false;\n-        caseModDateCompatible.testCaseName = \"caseModDateCompatible\";\n-\n         final GraphQLFieldNameCompatibilityTestCase caseTitleIncompatible = new GraphQLFieldNameCompatibilityTestCase();\n         caseTitleIncompatible.fieldName = TITLE;\n         caseTitleIncompatible.fieldType = ImmutableCategoryField.class;\n-        caseTitleIncompatible.shouldCreateNewVariable = true;\n         caseTitleIncompatible.testCaseName = \"caseTitleIncompatible\";\n \n-        final GraphQLFieldNameCompatibilityTestCase caseTitleCompatible = new GraphQLFieldNameCompatibilityTestCase();\n-        caseTitleCompatible.fieldName = TITLE;\n-        caseTitleCompatible.fieldType = ImmutableTextField.class;\n-        caseTitleCompatible.shouldCreateNewVariable = false;\n-        caseTitleCompatible.testCaseName = \"caseTitleCompatible\";\n-\n         final GraphQLFieldNameCompatibilityTestCase caseTitleImageIncompatible = new GraphQLFieldNameCompatibilityTestCase();\n         caseTitleImageIncompatible.fieldName = TITLE_IMAGE_KEY;\n         caseTitleImageIncompatible.fieldType = ImmutableHostFolderField.class;\n-        caseTitleImageIncompatible.shouldCreateNewVariable = true;\n         caseTitleImageIncompatible.testCaseName = \"caseTitleImageIncompatible\";\n \n-        final GraphQLFieldNameCompatibilityTestCase caseTitleImageCompatible = new GraphQLFieldNameCompatibilityTestCase();\n-        caseTitleImageCompatible.fieldName = TITLE_IMAGE_KEY;\n-        caseTitleImageCompatible.fieldType = ImmutableBinaryField.class;\n-        caseTitleImageCompatible.shouldCreateNewVariable = false;\n-\n         final GraphQLFieldNameCompatibilityTestCase caseContentTypeIncompatible = new GraphQLFieldNameCompatibilityTestCase();\n         caseContentTypeIncompatible.fieldName = CONTENT_TYPE;\n         caseContentTypeIncompatible.fieldType = ImmutableHostFolderField.class;\n-        caseContentTypeIncompatible.shouldCreateNewVariable = true;\n         caseContentTypeIncompatible.testCaseName = \"caseContentTypeIncompatible\";\n \n-        final GraphQLFieldNameCompatibilityTestCase caseContentTypeCompatible = new GraphQLFieldNameCompatibilityTestCase();\n-        caseContentTypeCompatible.fieldName = CONTENT_TYPE;\n-        caseContentTypeCompatible.fieldType = ImmutableTextField.class;\n-        caseContentTypeCompatible.shouldCreateNewVariable = false;\n-        caseContentTypeCompatible.testCaseName = \"caseContentTypeCompatible\";\n-\n         final GraphQLFieldNameCompatibilityTestCase caseBaseTypeIncompatible = new GraphQLFieldNameCompatibilityTestCase();\n         caseBaseTypeIncompatible.fieldName = BASE_TYPE;\n         caseBaseTypeIncompatible.fieldType = ImmutableKeyValueField.class;\n-        caseBaseTypeIncompatible.shouldCreateNewVariable = true;\n         caseBaseTypeIncompatible.testCaseName = \"caseBaseTypeIncompatible\";\n \n-        final GraphQLFieldNameCompatibilityTestCase caseBaseTypeCompatible = new GraphQLFieldNameCompatibilityTestCase();\n-        caseBaseTypeCompatible.fieldName = BASE_TYPE;\n-        caseBaseTypeCompatible.fieldType = ImmutableTextField.class;\n-        caseBaseTypeCompatible.shouldCreateNewVariable = false;\n-        caseBaseTypeCompatible.testCaseName = \"caseBaseTypeCompatible\";\n-\n         final GraphQLFieldNameCompatibilityTestCase caseLiveIncompatible = new GraphQLFieldNameCompatibilityTestCase();\n         caseLiveIncompatible.fieldName = LIVE;\n         caseLiveIncompatible.fieldType = ImmutableCategoryField.class;\n-        caseLiveIncompatible.shouldCreateNewVariable = true;\n         caseLiveIncompatible.testCaseName = \"caseLiveIncompatible\";\n \n-        final GraphQLFieldNameCompatibilityTestCase caseLiveCompatible = new GraphQLFieldNameCompatibilityTestCase();\n-        caseLiveCompatible.fieldName = LIVE;\n-        caseLiveCompatible.fieldType = ImmutableTextField.class;\n-        caseLiveCompatible.shouldCreateNewVariable = false;\n-        caseLiveCompatible.testCaseName = \"caseLiveCompatible\";\n-\n         final GraphQLFieldNameCompatibilityTestCase caseWorkingIncompatible = new GraphQLFieldNameCompatibilityTestCase();\n         caseWorkingIncompatible.fieldName = WORKING;\n         caseWorkingIncompatible.fieldType = ImmutableCategoryField.class;\n-        caseWorkingIncompatible.shouldCreateNewVariable = true;\n         caseWorkingIncompatible.testCaseName = \"caseWorkingIncompatible\";\n \n-        final GraphQLFieldNameCompatibilityTestCase caseWorkingCompatible = new GraphQLFieldNameCompatibilityTestCase();\n-        caseWorkingCompatible.fieldName = WORKING;\n-        caseWorkingCompatible.fieldType = ImmutableTextField.class;\n-        caseWorkingCompatible.shouldCreateNewVariable = false;\n-        caseWorkingCompatible.testCaseName = \"caseWorkingCompatible\";\n-\n         final GraphQLFieldNameCompatibilityTestCase caseArchivedIncompatible = new GraphQLFieldNameCompatibilityTestCase();\n         caseArchivedIncompatible.fieldName = ARCHIVED_KEY;\n         caseArchivedIncompatible.fieldType = ImmutableCategoryField.class;\n-        caseArchivedIncompatible.shouldCreateNewVariable = true;\n         caseArchivedIncompatible.testCaseName = \"caseArchivedIncompatible\";\n \n-        final GraphQLFieldNameCompatibilityTestCase caseArchivedCompatible = new GraphQLFieldNameCompatibilityTestCase();\n-        caseArchivedCompatible.fieldName = ARCHIVED_KEY;\n-        caseArchivedCompatible.fieldType = ImmutableTextField.class;\n-        caseArchivedCompatible.shouldCreateNewVariable = false;\n-        caseArchivedCompatible.testCaseName = \"caseArchivedCompatible\";\n-\n         final GraphQLFieldNameCompatibilityTestCase caseLockedIncompatible = new GraphQLFieldNameCompatibilityTestCase();\n         caseLockedIncompatible.fieldName = LOCKED_KEY;\n         caseLockedIncompatible.fieldType = ImmutableCategoryField.class;\n-        caseLockedIncompatible.shouldCreateNewVariable = true;\n         caseLockedIncompatible.testCaseName = \"caseLockedIncompatible\";\n \n-        final GraphQLFieldNameCompatibilityTestCase caseLockedCompatible = new GraphQLFieldNameCompatibilityTestCase();\n-        caseLockedCompatible.fieldName = LOCKED_KEY;\n-        caseLockedCompatible.fieldType = ImmutableTextField.class;\n-        caseLockedCompatible.shouldCreateNewVariable = false;\n-        caseLockedCompatible.testCaseName = \"caseLockedCompatible\";\n-\n         final GraphQLFieldNameCompatibilityTestCase caseConLanguageIncompatible = new GraphQLFieldNameCompatibilityTestCase();\n         caseConLanguageIncompatible.fieldName = \"conLanguage\";\n         caseConLanguageIncompatible.fieldType = ImmutableCategoryField.class;\n-        caseConLanguageIncompatible.shouldCreateNewVariable = true;\n         caseConLanguageIncompatible.testCaseName = \"caseConLanguageIncompatible\";\n \n         final GraphQLFieldNameCompatibilityTestCase caseIdentifierIncompatible = new GraphQLFieldNameCompatibilityTestCase();\n         caseIdentifierIncompatible.fieldName = IDENTIFIER;\n         caseIdentifierIncompatible.fieldType = ImmutableCategoryField.class;\n-        caseIdentifierIncompatible.shouldCreateNewVariable = true;\n         caseIdentifierIncompatible.testCaseName = \"caseIdentifierIncompatible\";\n \n-        final GraphQLFieldNameCompatibilityTestCase caseIdentifierCompatible = new GraphQLFieldNameCompatibilityTestCase();\n-        caseIdentifierCompatible.fieldName = IDENTIFIER;\n-        caseIdentifierCompatible.fieldType = ImmutableTextField.class;\n-        caseIdentifierCompatible.shouldCreateNewVariable = false;\n-        caseIdentifierCompatible.testCaseName = \"caseIdentifierCompatible\";\n-\n         final GraphQLFieldNameCompatibilityTestCase caseInodeIncompatible = new GraphQLFieldNameCompatibilityTestCase();\n         caseInodeIncompatible.fieldName = INODE;\n         caseInodeIncompatible.fieldType = ImmutableCategoryField.class;\n-        caseInodeIncompatible.shouldCreateNewVariable = true;\n         caseInodeIncompatible.testCaseName = \"caseInodeIncompatible\";\n \n-        final GraphQLFieldNameCompatibilityTestCase caseInodeCompatible = new GraphQLFieldNameCompatibilityTestCase();\n-        caseInodeCompatible.fieldName = INODE;\n-        caseInodeCompatible.fieldType = ImmutableTextField.class;\n-        caseInodeCompatible.shouldCreateNewVariable = false;\n-        caseInodeCompatible.testCaseName = \"caseInodeCompatible\";\n-\n         final GraphQLFieldNameCompatibilityTestCase caseHostIncompatible = new GraphQLFieldNameCompatibilityTestCase();\n         caseHostIncompatible.fieldName = HOST_KEY;\n         caseHostIncompatible.fieldType = ImmutableCategoryField.class;\n-        caseHostIncompatible.shouldCreateNewVariable = true;\n         caseHostIncompatible.testCaseName = \"caseHostIncompatible\";\n \n         final GraphQLFieldNameCompatibilityTestCase caseFolderIncompatible = new GraphQLFieldNameCompatibilityTestCase();\n         caseFolderIncompatible.fieldName = FOLDER_KEY;\n         caseFolderIncompatible.fieldType = ImmutableCategoryField.class;\n-        caseFolderIncompatible.shouldCreateNewVariable = true;\n         caseFolderIncompatible.testCaseName = \"caseFolderIncompatible\";\n \n         final GraphQLFieldNameCompatibilityTestCase caseUrlMapIncompatible = new GraphQLFieldNameCompatibilityTestCase();\n         caseUrlMapIncompatible.fieldName = URL_MAP;\n         caseUrlMapIncompatible.fieldType = ImmutableCategoryField.class;\n-        caseUrlMapIncompatible.shouldCreateNewVariable = true;\n         caseUrlMapIncompatible.testCaseName = \"caseUrlMapIncompatible\";\n \n-        final GraphQLFieldNameCompatibilityTestCase caseUrlMapCompatible = new GraphQLFieldNameCompatibilityTestCase();\n-        caseUrlMapCompatible.fieldName = URL_MAP;\n-        caseUrlMapCompatible.fieldType = ImmutableTextField.class;\n-        caseUrlMapCompatible.shouldCreateNewVariable = false;\n-        caseUrlMapCompatible.testCaseName = \"caseUrlMapCompatible\";\n-\n         final GraphQLFieldNameCompatibilityTestCase caseOwnerIncompatible = new GraphQLFieldNameCompatibilityTestCase();\n         caseOwnerIncompatible.fieldName = OWNER_KEY;\n         caseOwnerIncompatible.fieldType = ImmutableCategoryField.class;\n-        caseOwnerIncompatible.shouldCreateNewVariable = true;\n         caseOwnerIncompatible.testCaseName = \"caseOwnerIncompatible\";\n \n         final GraphQLFieldNameCompatibilityTestCase caseModUserIncompatible = new GraphQLFieldNameCompatibilityTestCase();\n         caseModUserIncompatible.fieldName = MOD_USER_KEY;\n         caseModUserIncompatible.fieldType = ImmutableCategoryField.class;\n-        caseModUserIncompatible.shouldCreateNewVariable = true;\n         caseModUserIncompatible.testCaseName = \"caseModUserIncompatible\";\n \n         return new GraphQLFieldNameCompatibilityTestCase[] {\n                 caseModDateIncompatible,\n-                caseModDateCompatible,\n-                caseTitleCompatible,\n                 caseTitleIncompatible,\n                 caseTitleImageIncompatible,\n-                caseTitleImageCompatible,\n                 caseContentTypeIncompatible,\n-                caseContentTypeCompatible,\n                 caseBaseTypeIncompatible,\n-                caseBaseTypeCompatible,\n                 caseLiveIncompatible,\n-                caseLiveCompatible,\n-                caseWorkingCompatible,\n-                caseArchivedCompatible,\n-                caseLockedCompatible,\n                 caseIdentifierIncompatible,\n-                caseIdentifierCompatible,\n                 caseInodeIncompatible,\n-                caseInodeCompatible,\n                 caseHostIncompatible,\n                 caseFolderIncompatible,\n                 caseUrlMapIncompatible,\n-                caseUrlMapCompatible,\n                 caseOwnerIncompatible,\n                 caseModUserIncompatible\n         };\n     }\n \n+    /**\n+     * Method to test: {@link FieldAPIImpl#save(Field, User)}\n+     * <p>\n+     * Given scenario: A {@link ContentType} with a `name` that would normally result in a incompatible `variable` (generated by our API based on the name)\n+     * with the current GraphQL Schema.\n+     * <p>\n+     * Expected result: The generated (by our API) Content Type variable is different than the incompatible `variable`\n+     */\n+\n     @Test\n-    @UseDataProvider(\"dataProviderGraphQLReservedNames\")\n-    public void test_SaveFieldVariableNameCompatibilityWithGraphQL(\n+    @UseDataProvider(\"dataProviderGraphQLIncompatibleFields\")\n+    public void test_SaveField_GivenTypeName_GeneratedVariableIsDifferentThanProvidedOne(\n             final GraphQLFieldNameCompatibilityTestCase testCase)\n             throws DotSecurityException, DotDataException {\n \n         final ContentType type = new ContentTypeDataGen().nextPersisted();\n         try {\n             final ContentType contentType = new ContentTypeDataGen().nextPersisted();\n-            final Field field = createField(contentType, testCase.fieldName,\n+            final Field field = createField(contentType, testCase.fieldName, null,\n                     testCase.fieldType);\n \n-            if(testCase.shouldCreateNewVariable) {\n-                Assert.assertNotEquals(testCase.fieldName, field.variable());\n-            } else  {\n-                Assert.assertEquals(testCase.fieldName, field.variable());\n-            }\n+            Assert.assertNotEquals(testCase.fieldName, field.variable());\n+        } finally {\n+            contentTypeAPI.delete(type);\n+        }\n+    }\n+\n+    /**\n+     * Method to test: {@link FieldAPIImpl#save(Field, User)}\n+     * <p>\n+     * Given scenario: A {@link ContentType} with a `name` that would normally result in a Compatible `variable` (generated by our API based on the name)\n+     * with the current GraphQL Schema.\n+     * <p>\n+     * Expected result: The generated (by our API) Content Type variable is the same than the compatible `variable`\n+     */\n+\n+    @Test\n+    @UseDataProvider(\"dataProviderGraphQLCompatibleFields\")\n+    public void test_SaveField_GivenTypeName_GeneratedVariableIsSameAsProvidedOne(\n+            final GraphQLFieldNameCompatibilityTestCase testCase)\n+            throws DotSecurityException, DotDataException {\n+\n+        final ContentType type = new ContentTypeDataGen().nextPersisted();\n+        try {\n+            final ContentType contentType = new ContentTypeDataGen().nextPersisted();\n+            final Field field = createField(contentType, testCase.fieldName, null,\n+                    testCase.fieldType);\n+\n+            Assert.assertEquals(testCase.fieldName, field.variable());\n+        } finally {\n+            contentTypeAPI.delete(type);\n+        }\n+    }\n+\n+    /**\n+     * Method to test: {@link FieldAPIImpl#save(Field, User)}\n+     * <p>\n+     * Given scenario: A {@link ContentType} with an incompatible `variable` with the current GraphQL Schema.\n+     * <p>\n+     * Expected result: {@link DotDataException} thrown\n+     */\n+\n+    @Test(expected = DotDataException.class)\n+    @UseDataProvider(\"dataProviderGraphQLIncompatibleFields\")\n+    public void test_SaveField_GivenGraphQLIncompatibleVariable_ShouldThrowException(\n+            final GraphQLFieldNameCompatibilityTestCase testCase)\n+            throws DotSecurityException, DotDataException {\n+\n+        final ContentType type = new ContentTypeDataGen().nextPersisted();\n+        try {\n+            final ContentType contentType = new ContentTypeDataGen().nextPersisted();\n+            // passing the invalid graphql variable as both name and variable of the field\n+            final Field field = createField(contentType, testCase.fieldName,", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMjA2Nw==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436912067", "bodyText": "Issue found: Local variable 'typesProvider' could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:49Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/business/GraphqlAPIImpl.java", "diffHunk": "@@ -160,137 +97,37 @@ private void printSchema() {\n         }\n     }\n \n-    private void createSchemaType(ContentType contentType,\n-                                              final Map<String, GraphQLObjectType> graphqlObjectTypes) {\n-\n-        // skip contentType.variable not sticking to the regex\n-        if(!contentType.variable().matches(TYPES_AND_FIELDS_VALID_NAME_REGEX)) {\n-            return;\n-        }\n-\n-        final GraphQLObjectType.Builder builder = GraphQLObjectType.newObject().name(contentType.variable());\n-\n-        // add CONTENT interface fields\n-        builder.fields(InterfaceType.CONTENTLET.getType().getFieldDefinitions());\n-\n-        if(InterfaceType.getInterfaceForBaseType(contentType.baseType())!=null) {\n-            builder.withInterface(InterfaceType.getInterfaceForBaseType(contentType.baseType()));\n-        }\n-\n-        final List<Field> fields = contentType.fields();\n-\n-        fields.forEach((field)->{\n-            // skip field.variable not sticking to the regex\n-            if(!field.variable().matches(TYPES_AND_FIELDS_VALID_NAME_REGEX)\n-                || field instanceof RelationshipsTabField) {\n-                return;\n-            }\n+    @LogTime(loggingLevel = \"INFO\")\n+    private GraphQLSchema generateSchema() throws DotDataException {\n+        final Set<GraphQLType> graphQLTypes = new HashSet<>();\n \n-            if(!(field instanceof RowField) && !(field instanceof ColumnField)) {\n-                if (field instanceof RelationshipField) {\n-                    try {\n-                        handleRelationshipField(contentType, builder, field, graphqlObjectTypes);\n-                    } catch(DotStateException e) {\n-                        Logger.error(this, \"Unable to create relationship field\", e);\n-                    }\n-                } else {\n-                    builder.field(newFieldDefinition()\n-                        .name(field.variable())\n-                        .type(field.required()\n-                            ? nonNull(getGraphqlTypeForFieldClass(field.type(), field))\n-                            : getGraphqlTypeForFieldClass(field.type(), field))\n-                        .dataFetcher(getGraphqlDataFetcherForFieldClass(field.type()))\n-                    );\n-                }\n+        for (GraphQLTypesProvider typesProvider : typesProviders) {", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMjA3OQ==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436912079", "bodyText": "Issue found: Local variable 'fieldDefinitions' could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:51Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/business/GraphqlAPIImpl.java", "diffHunk": "@@ -160,137 +97,37 @@ private void printSchema() {\n         }\n     }\n \n-    private void createSchemaType(ContentType contentType,\n-                                              final Map<String, GraphQLObjectType> graphqlObjectTypes) {\n-\n-        // skip contentType.variable not sticking to the regex\n-        if(!contentType.variable().matches(TYPES_AND_FIELDS_VALID_NAME_REGEX)) {\n-            return;\n-        }\n-\n-        final GraphQLObjectType.Builder builder = GraphQLObjectType.newObject().name(contentType.variable());\n-\n-        // add CONTENT interface fields\n-        builder.fields(InterfaceType.CONTENTLET.getType().getFieldDefinitions());\n-\n-        if(InterfaceType.getInterfaceForBaseType(contentType.baseType())!=null) {\n-            builder.withInterface(InterfaceType.getInterfaceForBaseType(contentType.baseType()));\n-        }\n-\n-        final List<Field> fields = contentType.fields();\n-\n-        fields.forEach((field)->{\n-            // skip field.variable not sticking to the regex\n-            if(!field.variable().matches(TYPES_AND_FIELDS_VALID_NAME_REGEX)\n-                || field instanceof RelationshipsTabField) {\n-                return;\n-            }\n+    @LogTime(loggingLevel = \"INFO\")\n+    private GraphQLSchema generateSchema() throws DotDataException {\n+        final Set<GraphQLType> graphQLTypes = new HashSet<>();\n \n-            if(!(field instanceof RowField) && !(field instanceof ColumnField)) {\n-                if (field instanceof RelationshipField) {\n-                    try {\n-                        handleRelationshipField(contentType, builder, field, graphqlObjectTypes);\n-                    } catch(DotStateException e) {\n-                        Logger.error(this, \"Unable to create relationship field\", e);\n-                    }\n-                } else {\n-                    builder.field(newFieldDefinition()\n-                        .name(field.variable())\n-                        .type(field.required()\n-                            ? nonNull(getGraphqlTypeForFieldClass(field.type(), field))\n-                            : getGraphqlTypeForFieldClass(field.type(), field))\n-                        .dataFetcher(getGraphqlDataFetcherForFieldClass(field.type()))\n-                    );\n-                }\n+        for (GraphQLTypesProvider typesProvider : typesProviders) {\n+            try {\n+                graphQLTypes.addAll(typesProvider.getTypes());\n+            } catch (DotDataException e) {\n+                Logger.error(\"Unable to get types for type provider:\" + typesProvider\n+                        .getClass(), e);\n             }\n-        });\n-\n-        builder.withInterface(InterfaceType.CONTENTLET.getType());\n-        final GraphQLObjectType graphQLType = builder.build();\n-\n-        graphqlObjectTypes.put(graphQLType.getName(), graphQLType);\n-    }\n-\n-    private void handleRelationshipField(final ContentType contentType, GraphQLObjectType.Builder builder,\n-                                         final Field field, final Map<String, GraphQLObjectType> typesMap) {\n-\n-        final ContentType relatedContentType;\n-        try {\n-            relatedContentType = getRelatedContentTypeForField(field, APILocator.systemUser());\n-        } catch (DotSecurityException | DotDataException e) {\n-            throw new DotStateException(\"Unable to create relationship field type for field: \" + contentType.variable() + \".\" + field.variable(), e);\n         }\n \n-        Relationship relationship;\n+        List<GraphQLFieldDefinition> fieldDefinitions = new ArrayList<>();", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMjA4Mg==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436912082", "bodyText": "Issue found: Parameter 'cause' is not assigned and could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:52Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/exception/TypeGenerationException.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package com.dotcms.graphql.exception;\n+\n+import com.dotmarketing.exception.DotRuntimeException;\n+import graphql.schema.GraphQLType;\n+\n+\n+/**\n+ * Runtime Exception thrown when a {@link GraphQLType} can't be generated\n+ */\n+public class TypeGenerationException extends DotRuntimeException {\n+\n+    public TypeGenerationException(String message) {\n+        super(message);\n+    }\n+\n+    public TypeGenerationException(Throwable cause) {", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMjA5MQ==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436912091", "bodyText": "Issue found: Parameter 'message' is not assigned and could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:53Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/exception/TypeGenerationException.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package com.dotcms.graphql.exception;\n+\n+import com.dotmarketing.exception.DotRuntimeException;\n+import graphql.schema.GraphQLType;\n+\n+\n+/**\n+ * Runtime Exception thrown when a {@link GraphQLType} can't be generated\n+ */\n+public class TypeGenerationException extends DotRuntimeException {\n+\n+    public TypeGenerationException(String message) {", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMjEwMg==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436912102", "bodyText": "Issue found: Local variable 'expectedType' could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:54Z", "path": "dotCMS/src/integration-test/java/com/dotcms/graphql/business/GraphqlAPITest.java", "diffHunk": "@@ -522,7 +523,8 @@ public void testGetSchema_FieldOperations(final TypeTestCase testCase) throws Do\n         final GraphQLFieldDefinition fieldDefinition =\n                 schema.getObjectType(testCase.contentTypeName).getFieldDefinition(testCase.fieldVarName);\n \n-        GraphQLOutputType expectedType = api.getGraphqlTypeForFieldClass(\n+        GraphQLOutputType expectedType = ContentAPIGraphQLTypesProvider.INSTANCE", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMjExMg==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436912112", "bodyText": "Issue found: Local variable 'fieldsProvider' could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:55Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/business/GraphqlAPIImpl.java", "diffHunk": "@@ -160,137 +97,37 @@ private void printSchema() {\n         }\n     }\n \n-    private void createSchemaType(ContentType contentType,\n-                                              final Map<String, GraphQLObjectType> graphqlObjectTypes) {\n-\n-        // skip contentType.variable not sticking to the regex\n-        if(!contentType.variable().matches(TYPES_AND_FIELDS_VALID_NAME_REGEX)) {\n-            return;\n-        }\n-\n-        final GraphQLObjectType.Builder builder = GraphQLObjectType.newObject().name(contentType.variable());\n-\n-        // add CONTENT interface fields\n-        builder.fields(InterfaceType.CONTENTLET.getType().getFieldDefinitions());\n-\n-        if(InterfaceType.getInterfaceForBaseType(contentType.baseType())!=null) {\n-            builder.withInterface(InterfaceType.getInterfaceForBaseType(contentType.baseType()));\n-        }\n-\n-        final List<Field> fields = contentType.fields();\n-\n-        fields.forEach((field)->{\n-            // skip field.variable not sticking to the regex\n-            if(!field.variable().matches(TYPES_AND_FIELDS_VALID_NAME_REGEX)\n-                || field instanceof RelationshipsTabField) {\n-                return;\n-            }\n+    @LogTime(loggingLevel = \"INFO\")\n+    private GraphQLSchema generateSchema() throws DotDataException {\n+        final Set<GraphQLType> graphQLTypes = new HashSet<>();\n \n-            if(!(field instanceof RowField) && !(field instanceof ColumnField)) {\n-                if (field instanceof RelationshipField) {\n-                    try {\n-                        handleRelationshipField(contentType, builder, field, graphqlObjectTypes);\n-                    } catch(DotStateException e) {\n-                        Logger.error(this, \"Unable to create relationship field\", e);\n-                    }\n-                } else {\n-                    builder.field(newFieldDefinition()\n-                        .name(field.variable())\n-                        .type(field.required()\n-                            ? nonNull(getGraphqlTypeForFieldClass(field.type(), field))\n-                            : getGraphqlTypeForFieldClass(field.type(), field))\n-                        .dataFetcher(getGraphqlDataFetcherForFieldClass(field.type()))\n-                    );\n-                }\n+        for (GraphQLTypesProvider typesProvider : typesProviders) {\n+            try {\n+                graphQLTypes.addAll(typesProvider.getTypes());\n+            } catch (DotDataException e) {\n+                Logger.error(\"Unable to get types for type provider:\" + typesProvider\n+                        .getClass(), e);\n             }\n-        });\n-\n-        builder.withInterface(InterfaceType.CONTENTLET.getType());\n-        final GraphQLObjectType graphQLType = builder.build();\n-\n-        graphqlObjectTypes.put(graphQLType.getName(), graphQLType);\n-    }\n-\n-    private void handleRelationshipField(final ContentType contentType, GraphQLObjectType.Builder builder,\n-                                         final Field field, final Map<String, GraphQLObjectType> typesMap) {\n-\n-        final ContentType relatedContentType;\n-        try {\n-            relatedContentType = getRelatedContentTypeForField(field, APILocator.systemUser());\n-        } catch (DotSecurityException | DotDataException e) {\n-            throw new DotStateException(\"Unable to create relationship field type for field: \" + contentType.variable() + \".\" + field.variable(), e);\n         }\n \n-        Relationship relationship;\n+        List<GraphQLFieldDefinition> fieldDefinitions = new ArrayList<>();\n \n-        try {\n-            relationship = relationshipAPI.getRelationshipFromField(field,\n-                APILocator.systemUser());\n-        } catch (DotDataException | DotSecurityException e) {\n-            throw new DotRuntimeException(e);\n+        for (GraphQLFieldsProvider fieldsProvider : fieldsProviders) {", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMjEyNA==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436912124", "bodyText": "Issue found: Parameter 'type' is not assigned and could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:56Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/business/ContentAPIGraphQLFieldsProvider.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.dotcms.graphql.business;\n+\n+import static com.dotcms.graphql.util.TypeUtil.BASE_TYPE_SUFFIX;\n+import static graphql.Scalars.GraphQLInt;\n+import static graphql.Scalars.GraphQLString;\n+import static graphql.schema.GraphQLFieldDefinition.newFieldDefinition;\n+import static graphql.schema.GraphQLList.list;\n+\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.graphql.InterfaceType;\n+import com.dotcms.graphql.datafetcher.ContentletDataFetcher;\n+import com.dotcms.graphql.util.TypeUtil;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.Logger;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLType;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.commons.collections.PredicateUtils;\n+\n+/**\n+ * This singleton class provides all the {@link GraphQLFieldDefinition}s needed for the Content Delivery API\n+ */\n+enum ContentAPIGraphQLFieldsProvider implements GraphQLFieldsProvider {\n+\n+    INSTANCE;\n+\n+    @Override\n+    public Collection<GraphQLFieldDefinition> getFields() throws DotDataException {\n+        // Each ContentType as query'able collection field\n+        final List<ContentType> contentTypeList = APILocator.getContentTypeAPI(APILocator.systemUser())\n+                .findAllRespectingLicense();\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = new ArrayList<>();\n+\n+        contentTypeList.forEach((type) -> {\n+            fieldDefinitions.add(createCollectionField(type));\n+        });\n+\n+        // Each BaseType as query'able collection field\n+        InterfaceType.valuesAsSet().forEach((type)->{\n+            fieldDefinitions.add(createCollectionFieldForBaseType(type));\n+        });\n+\n+        CollectionUtils.filter(fieldDefinitions, PredicateUtils.notNullPredicate());\n+        return fieldDefinitions;\n+    }\n+\n+    /**\n+     * Given a {@link ContentType} it creates a {@link GraphQLFieldDefinition} that represents a queryable collection for the type\n+     * The name of the field will follow the convention \"{typeVariable}Collection\".\n+     * <p>\n+     * E.g Content Type Variable: Product. Resulting field name: ProductCollection\n+     * @param type the type we want to build a collection for\n+     * @return the field definition representing the collection\n+     */\n+\n+    private GraphQLFieldDefinition createCollectionField(ContentType type) {", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMjEzNA==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436912134", "bodyText": "Issue found: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:57Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/business/ContentAPIGraphQLTypesProvider.java", "diffHunk": "@@ -0,0 +1,246 @@\n+package com.dotcms.graphql.business;\n+\n+import static com.dotcms.graphql.CustomFieldType.isCustomFieldType;\n+import static com.dotcms.graphql.business.GraphqlAPI.TYPES_AND_FIELDS_VALID_NAME_REGEX;\n+import static graphql.Scalars.GraphQLFloat;\n+import static graphql.Scalars.GraphQLInt;\n+import static graphql.Scalars.GraphQLString;\n+import static graphql.schema.GraphQLList.list;\n+\n+import com.dotcms.contenttype.model.field.BinaryField;\n+import com.dotcms.contenttype.model.field.CategoryField;\n+import com.dotcms.contenttype.model.field.CheckboxField;\n+import com.dotcms.contenttype.model.field.ColumnField;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FileField;\n+import com.dotcms.contenttype.model.field.HostFolderField;\n+import com.dotcms.contenttype.model.field.ImageField;\n+import com.dotcms.contenttype.model.field.KeyValueField;\n+import com.dotcms.contenttype.model.field.MultiSelectField;\n+import com.dotcms.contenttype.model.field.RelationshipsTabField;\n+import com.dotcms.contenttype.model.field.RowField;\n+import com.dotcms.contenttype.model.field.TagField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.graphql.CustomFieldType;\n+import com.dotcms.graphql.InterfaceType;\n+import com.dotcms.graphql.datafetcher.BinaryFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.CategoryFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.FieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.FileFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.KeyValueFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.MultiValueFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.SiteOrFolderFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.TagsFieldDataFetcher;\n+import com.dotcms.graphql.exception.FieldGenerationException;\n+import com.dotcms.graphql.exception.TypeGenerationException;\n+import com.dotcms.util.DotPreconditions;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import graphql.scalars.ExtendedScalars;\n+import graphql.schema.DataFetcher;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLOutputType;\n+import graphql.schema.GraphQLType;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * This singleton class provides all the {@link GraphQLType}s needed for the Content Delivery API\n+ */\n+public enum ContentAPIGraphQLTypesProvider implements GraphQLTypesProvider {\n+\n+    INSTANCE;\n+\n+    private GraphQLFieldGeneratorFactory fieldGeneratorFactory = new GraphQLFieldGeneratorFactory();\n+\n+    private final Map<Class<? extends Field>, GraphQLOutputType> fieldClassGraphqlTypeMap = new HashMap<>();\n+\n+    private final Map<Class<? extends Field>, DataFetcher> fieldClassGraphqlDataFetcher = new HashMap<>();\n+\n+    private final Map<String, GraphQLType> typesMap = new HashMap<>();\n+\n+    {\n+        // custom type mappings\n+        this.fieldClassGraphqlTypeMap.put(BinaryField.class, CustomFieldType.BINARY.getType());\n+        this.fieldClassGraphqlTypeMap\n+                .put(CategoryField.class, list(CustomFieldType.CATEGORY.getType()));\n+        this.fieldClassGraphqlTypeMap.put(ImageField.class, CustomFieldType.FILEASSET.getType());\n+        this.fieldClassGraphqlTypeMap.put(FileField.class, CustomFieldType.FILEASSET.getType());\n+        this.fieldClassGraphqlTypeMap\n+                .put(KeyValueField.class, list(CustomFieldType.KEY_VALUE.getType()));\n+        this.fieldClassGraphqlTypeMap.put(CheckboxField.class, list(GraphQLString));\n+        this.fieldClassGraphqlTypeMap.put(MultiSelectField.class, list(GraphQLString));\n+        this.fieldClassGraphqlTypeMap.put(TagField.class, list(GraphQLString));\n+        this.fieldClassGraphqlTypeMap\n+                .put(HostFolderField.class, CustomFieldType.SITE_OR_FOLDER.getType());\n+\n+        // custom data fetchers\n+        this.fieldClassGraphqlDataFetcher.put(BinaryField.class, new BinaryFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(CategoryField.class, new CategoryFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(ImageField.class, new FileFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(FileField.class, new FileFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(KeyValueField.class, new KeyValueFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher\n+                .put(CheckboxField.class, new MultiValueFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher\n+                .put(MultiSelectField.class, new MultiValueFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(TagField.class, new TagsFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher\n+                .put(HostFolderField.class, new SiteOrFolderFieldDataFetcher());\n+    }\n+\n+    @Override\n+    public Collection<GraphQLType> getTypes() throws DotDataException {\n+        // we want to generate them always - no cache\n+        getContentAPITypes().forEach((graphQLType)->\n+                typesMap.put(graphQLType.getName(), graphQLType));\n+\n+        return typesMap.values();\n+    }\n+\n+    Map<String, GraphQLType> getCachedTypesAsMap() throws DotDataException {\n+        if (!UtilMethods.isSet(typesMap)) {\n+            getContentAPITypes().forEach((graphQLType)->\n+                    typesMap.put(graphQLType.getName(), graphQLType));\n+        }\n+        return typesMap;\n+    }\n+\n+    private Set<GraphQLType> getContentAPITypes() throws DotDataException {\n+\n+        Set<GraphQLType> contentAPITypes = new HashSet<>(InterfaceType.valuesAsSet());\n+\n+        contentAPITypes.add(ExtendedScalars.DateTime);\n+\n+        List<ContentType> allTypes = APILocator.getContentTypeAPI(APILocator.systemUser())\n+                .findAllRespectingLicense();\n+\n+        allTypes.forEach((type) -> {\n+            try {\n+                contentAPITypes.add(createType(type));\n+            }catch (TypeGenerationException e) {\n+                Logger.error(this, \"Unable to generate GraphQL Type for type: \" + type.variable());\n+            }\n+        });\n+\n+        return contentAPITypes;\n+    }\n+\n+    private GraphQLObjectType createType(ContentType contentType) {\n+\n+        DotPreconditions.checkArgument(contentType.variable()\n+                .matches(TYPES_AND_FIELDS_VALID_NAME_REGEX),\n+                \"Content Type variable does not conform to naming rules\",\n+                TypeGenerationException.class);\n+\n+        final GraphQLObjectType.Builder builder = GraphQLObjectType.newObject()\n+                .name(contentType.variable());\n+\n+        // add CONTENT interface fields\n+        builder.fields(InterfaceType.CONTENTLET.getType().getFieldDefinitions());\n+\n+        if (InterfaceType.getInterfaceForBaseType(contentType.baseType()) != null) {\n+            builder.withInterface(InterfaceType.getInterfaceForBaseType(contentType.baseType()));\n+        }\n+\n+        builder.fields(createFieldsForType(contentType));\n+\n+        builder.withInterface(InterfaceType.CONTENTLET.getType());\n+        return builder.build();\n+    }\n+\n+    private List<GraphQLFieldDefinition> createFieldsForType(ContentType contentType) {\n+        final List<Field> fields = contentType.fields();\n+\n+        final List<GraphQLFieldDefinition> fieldDefinitions = new ArrayList<>();\n+\n+        fields.forEach((field) -> {\n+            // skip field.variable not sticking to the regex\n+            if (!field.variable().matches(TYPES_AND_FIELDS_VALID_NAME_REGEX)\n+                    || field instanceof RelationshipsTabField) {\n+                return;\n+            }\n+\n+            if (!(field instanceof RowField) && !(field instanceof ColumnField)) {\n+                try {\n+                    fieldDefinitions.add(fieldGeneratorFactory.getGenerator(field).generateField(field));\n+                } catch(FieldGenerationException e) {\n+                    Logger.error(this, \"Unable to generate GraphQL Field for field: \" + field.variable(), e);\n+                }\n+            }\n+\n+        });\n+\n+        return fieldDefinitions;\n+    }\n+\n+    public GraphQLOutputType getGraphqlTypeForFieldClass(final Class<? extends Field> fieldClass,\n+            final Field field) {\n+        return fieldClassGraphqlTypeMap.get(fieldClass) != null\n+                ? fieldClassGraphqlTypeMap.get(fieldClass)\n+                : fieldClass.equals(TextField.class) && field.dataType().equals(DataTypes.INTEGER)\n+                        ? GraphQLInt\n+                        : fieldClass.equals(TextField.class) && field.dataType()\n+                                .equals(DataTypes.FLOAT) ? GraphQLFloat\n+                                : GraphQLString;\n+    }\n+\n+    public DataFetcher getGraphqlDataFetcherForFieldClass(final Class<Field> fieldClass) {\n+        return fieldClassGraphqlDataFetcher.get(fieldClass) != null\n+                ? fieldClassGraphqlDataFetcher.get(fieldClass)\n+                : new FieldDataFetcher();\n+    }\n+\n+    /**\n+     * This method determines whether a {@link Field}'s variable is compatible with the\n+     * current GraphQL Schema.\n+     *<p>\n+     * The {@link Field} is deemed compatibly if any of the followings conditions are true:\n+     * <ul>\n+     *     <li>The field variable does not match any of the inherited fields names from the {@link InterfaceType#getContentletInheritedFields} </li>\n+     *     <li>The field variable matches the name of a inherited field but neither of them have a {@link CustomFieldType#getCustomFieldTypes}\n+     *     as its mapped GraphQL Type\n+     * </ul>\n+     * @param variable the variable whose compatibility will be checked\n+     * @param field the field which the variable will be set to\n+     * @return\n+     */\n+    public boolean isFieldVariableGraphQLCompatible(final String variable, final Field field) {\n+        // first let's check if there's an inherited field with the same variable\n+        if (InterfaceType.getContentletInheritedFields().containsKey(variable)) {\n+            // now let's check if the graphql types are compatible\n+\n+            // get inherited field's graphql type\n+            final GraphQLType inheritedFieldGraphQLType = InterfaceType\n+                    .getContentletInheritedFields()\n+                    .get(variable).getType();\n+\n+            // get new field's type\n+            final GraphQLType fieldGraphQLType = getGraphqlTypeForFieldClass(field.type(), field);\n+\n+            // if at least one of them is a custom type, they need to be equal to be compatible\n+            return (!isCustomFieldType(inheritedFieldGraphQLType)", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMjE0MQ==", "url": "https://github.com/dotCMS/core/pull/18603#discussion_r436912141", "bodyText": "Issue found: Local variable 'allTypes' could be declared final", "author": "dev-dotcms", "createdAt": "2020-06-08T18:34:58Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/business/ContentAPIGraphQLTypesProvider.java", "diffHunk": "@@ -0,0 +1,246 @@\n+package com.dotcms.graphql.business;\n+\n+import static com.dotcms.graphql.CustomFieldType.isCustomFieldType;\n+import static com.dotcms.graphql.business.GraphqlAPI.TYPES_AND_FIELDS_VALID_NAME_REGEX;\n+import static graphql.Scalars.GraphQLFloat;\n+import static graphql.Scalars.GraphQLInt;\n+import static graphql.Scalars.GraphQLString;\n+import static graphql.schema.GraphQLList.list;\n+\n+import com.dotcms.contenttype.model.field.BinaryField;\n+import com.dotcms.contenttype.model.field.CategoryField;\n+import com.dotcms.contenttype.model.field.CheckboxField;\n+import com.dotcms.contenttype.model.field.ColumnField;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FileField;\n+import com.dotcms.contenttype.model.field.HostFolderField;\n+import com.dotcms.contenttype.model.field.ImageField;\n+import com.dotcms.contenttype.model.field.KeyValueField;\n+import com.dotcms.contenttype.model.field.MultiSelectField;\n+import com.dotcms.contenttype.model.field.RelationshipsTabField;\n+import com.dotcms.contenttype.model.field.RowField;\n+import com.dotcms.contenttype.model.field.TagField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.graphql.CustomFieldType;\n+import com.dotcms.graphql.InterfaceType;\n+import com.dotcms.graphql.datafetcher.BinaryFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.CategoryFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.FieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.FileFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.KeyValueFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.MultiValueFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.SiteOrFolderFieldDataFetcher;\n+import com.dotcms.graphql.datafetcher.TagsFieldDataFetcher;\n+import com.dotcms.graphql.exception.FieldGenerationException;\n+import com.dotcms.graphql.exception.TypeGenerationException;\n+import com.dotcms.util.DotPreconditions;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import graphql.scalars.ExtendedScalars;\n+import graphql.schema.DataFetcher;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLOutputType;\n+import graphql.schema.GraphQLType;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * This singleton class provides all the {@link GraphQLType}s needed for the Content Delivery API\n+ */\n+public enum ContentAPIGraphQLTypesProvider implements GraphQLTypesProvider {\n+\n+    INSTANCE;\n+\n+    private GraphQLFieldGeneratorFactory fieldGeneratorFactory = new GraphQLFieldGeneratorFactory();\n+\n+    private final Map<Class<? extends Field>, GraphQLOutputType> fieldClassGraphqlTypeMap = new HashMap<>();\n+\n+    private final Map<Class<? extends Field>, DataFetcher> fieldClassGraphqlDataFetcher = new HashMap<>();\n+\n+    private final Map<String, GraphQLType> typesMap = new HashMap<>();\n+\n+    {\n+        // custom type mappings\n+        this.fieldClassGraphqlTypeMap.put(BinaryField.class, CustomFieldType.BINARY.getType());\n+        this.fieldClassGraphqlTypeMap\n+                .put(CategoryField.class, list(CustomFieldType.CATEGORY.getType()));\n+        this.fieldClassGraphqlTypeMap.put(ImageField.class, CustomFieldType.FILEASSET.getType());\n+        this.fieldClassGraphqlTypeMap.put(FileField.class, CustomFieldType.FILEASSET.getType());\n+        this.fieldClassGraphqlTypeMap\n+                .put(KeyValueField.class, list(CustomFieldType.KEY_VALUE.getType()));\n+        this.fieldClassGraphqlTypeMap.put(CheckboxField.class, list(GraphQLString));\n+        this.fieldClassGraphqlTypeMap.put(MultiSelectField.class, list(GraphQLString));\n+        this.fieldClassGraphqlTypeMap.put(TagField.class, list(GraphQLString));\n+        this.fieldClassGraphqlTypeMap\n+                .put(HostFolderField.class, CustomFieldType.SITE_OR_FOLDER.getType());\n+\n+        // custom data fetchers\n+        this.fieldClassGraphqlDataFetcher.put(BinaryField.class, new BinaryFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(CategoryField.class, new CategoryFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(ImageField.class, new FileFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(FileField.class, new FileFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(KeyValueField.class, new KeyValueFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher\n+                .put(CheckboxField.class, new MultiValueFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher\n+                .put(MultiSelectField.class, new MultiValueFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher.put(TagField.class, new TagsFieldDataFetcher());\n+        this.fieldClassGraphqlDataFetcher\n+                .put(HostFolderField.class, new SiteOrFolderFieldDataFetcher());\n+    }\n+\n+    @Override\n+    public Collection<GraphQLType> getTypes() throws DotDataException {\n+        // we want to generate them always - no cache\n+        getContentAPITypes().forEach((graphQLType)->\n+                typesMap.put(graphQLType.getName(), graphQLType));\n+\n+        return typesMap.values();\n+    }\n+\n+    Map<String, GraphQLType> getCachedTypesAsMap() throws DotDataException {\n+        if (!UtilMethods.isSet(typesMap)) {\n+            getContentAPITypes().forEach((graphQLType)->\n+                    typesMap.put(graphQLType.getName(), graphQLType));\n+        }\n+        return typesMap;\n+    }\n+\n+    private Set<GraphQLType> getContentAPITypes() throws DotDataException {\n+\n+        Set<GraphQLType> contentAPITypes = new HashSet<>(InterfaceType.valuesAsSet());\n+\n+        contentAPITypes.add(ExtendedScalars.DateTime);\n+\n+        List<ContentType> allTypes = APILocator.getContentTypeAPI(APILocator.systemUser())", "originalCommit": "e7286b91a0d431dac4ccfaa4637dae41709dde19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}