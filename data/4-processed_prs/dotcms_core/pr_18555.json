{"pr_number": 18555, "pr_title": "#16796 adding fixes and comments to support the jwt on pp", "pr_createdAt": "2020-05-27T16:11:47Z", "pr_url": "https://github.com/dotCMS/core/pull/18555", "timeline": [{"oid": "435f564352e235d79f5a5fa753c32833bea9c80d", "url": "https://github.com/dotCMS/core/commit/435f564352e235d79f5a5fa753c32833bea9c80d", "message": "#16796 adding fixes and comments to support the jwt on pp", "committedDate": "2020-03-09T15:30:37Z", "type": "commit"}, {"oid": "53df03a0798348247b767f3b45da91c6ed66acea", "url": "https://github.com/dotCMS/core/commit/53df03a0798348247b767f3b45da91c6ed66acea", "message": "#16796 merge", "committedDate": "2020-06-09T19:19:17Z", "type": "commit"}, {"oid": "9b153c6a13d23f435d33b573b03053a5e5605afd", "url": "https://github.com/dotCMS/core/commit/9b153c6a13d23f435d33b573b03053a5e5605afd", "message": "#16796 Fixing error when some parameters not come in the request", "committedDate": "2020-06-12T17:14:11Z", "type": "commit"}, {"oid": "48e47307b1f9ddd707129e1997e7b487ce6539df", "url": "https://github.com/dotCMS/core/commit/48e47307b1f9ddd707129e1997e7b487ce6539df", "message": "#16796 Testing", "committedDate": "2020-06-15T15:24:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI2ODQ2Ng==", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r440268466", "bodyText": "Are we leaving this?", "author": "dsilvam", "createdAt": "2020-06-15T15:40:43Z", "path": "dotCMS/src/main/java/com/dotcms/rest/RestClientBuilder.java", "diffHunk": "@@ -25,7 +25,7 @@\n      *\n      * @return The REST {@link Client} object.\n      */\n-    public static Client newClient() {\n+    public static Client newClient() { // todo: create a DotConfigMap that wraps the config and allows to reuse this class on non-dotcms contexts", "originalCommit": "48e47307b1f9ddd707129e1997e7b487ce6539df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI2ODc1Ng==", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r440268756", "bodyText": "Are we leaving this todo?", "author": "dsilvam", "createdAt": "2020-06-15T15:41:12Z", "path": "dotCMS/src/main/java/com/dotcms/publisher/pusher/PushPublisher.java", "diffHunk": "@@ -350,7 +351,7 @@ private String getFormattedPort(String port){\n      * @return\n      * @throws IOException\n      */\n-\tpublic static Optional<String> retriveEndpointKeyDigest(final PublishingEndPoint endpoint) throws IOException {\n+\tpublic static Optional<String> retriveEndpointKeyDigest(final PublishingEndPoint endpoint) throws IOException { // todo: create a method that allows to receives a key and use the com.dotcms.util.security.Encryptor instead PublicEncryptionFactory", "originalCommit": "48e47307b1f9ddd707129e1997e7b487ce6539df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4NjE3NA==", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r441086174", "bodyText": "done d06b4af#diff-4b87c1c8d652c1a1bc15505b07076e25L354", "author": "freddyucv", "createdAt": "2020-06-16T19:18:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI2ODc1Ng=="}], "type": "inlineReview"}, {"oid": "d06b4af1f1a182020a2e8f609075197dec983b78", "url": "https://github.com/dotCMS/core/commit/d06b4af1f1a182020a2e8f609075197dec983b78", "message": "#16796 refactoring/testing", "committedDate": "2020-06-15T16:23:03Z", "type": "commit"}, {"oid": "1d1727a7af57fc681541d9aa72fbddcbc4357de3", "url": "https://github.com/dotCMS/core/commit/1d1727a7af57fc681541d9aa72fbddcbc4357de3", "message": "#16796 testing", "committedDate": "2020-06-15T17:16:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MTU5Ng==", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r440371596", "bodyText": "Missing Javadoc", "author": "jcastro-dotcms", "createdAt": "2020-06-15T18:39:08Z", "path": "dotCMS/src/main/java/com/dotcms/publisher/pusher/PushPublisher.java", "diffHunk": "@@ -350,15 +353,16 @@ private String getFormattedPort(String port){\n      * @return\n      * @throws IOException\n      */\n-\tpublic static Optional<String> retriveEndpointKeyDigest(final PublishingEndPoint endpoint) throws IOException {\n-\t  \n-\t  if(endpoint==null || endpoint.getAuthKey() ==null) {\n-\t    Logger.warn(PushPublisher.class,\"Endpoint or endpoint key is null:\" + endpoint);\n-\t    return Optional.empty();\n-\t  }\n-\t  \n-\t  String token = PublicEncryptionFactory.decryptString(endpoint.getAuthKey().toString());\n-\t\tString key = null;\n+\tpublic static Optional<String> retriveEndpointKeyDigest(final PublishingEndPoint endpoint)", "originalCommit": "1d1727a7af57fc681541d9aa72fbddcbc4357de3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwMzM0Ng==", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r441103346", "bodyText": "1aa6ff7#diff-4b87c1c8d652c1a1bc15505b07076e25R351", "author": "freddyucv", "createdAt": "2020-06-16T19:51:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MTU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MjU5Nw==", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r440372597", "bodyText": "This class only has blank spaces. Consider reverting it.", "author": "jcastro-dotcms", "createdAt": "2020-06-15T18:40:58Z", "path": "dotCMS/src/main/java/com/liferay/portal/model/User.java", "diffHunk": "@@ -300,11 +300,10 @@ public void setModificationDate(final Date modificationDate) {\n         setModified(true);\r\n     }\r\n \r\n-  public boolean isAnonymousUser(){\r\n+  \tpublic boolean isAnonymousUser(){\r", "originalCommit": "1d1727a7af57fc681541d9aa72fbddcbc4357de3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA5MTgwOQ==", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r441091809", "bodyText": "javadoc also 53df03a#diff-c944100d5305df9ed32bfd3b81e7ca81R307", "author": "freddyucv", "createdAt": "2020-06-16T19:29:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MjU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MzQzOQ==", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r440373439", "bodyText": "Include endpointId and bundleNameSent variables in error logging. Use the same error message for both the logging and the exception's message", "author": "jcastro-dotcms", "createdAt": "2020-06-15T18:42:31Z", "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -45,140 +54,178 @@\n      * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n      * to the {@link PublishThread Publish Thread}.\n      *\n-     * @param fileName       File name to be published\n-     * @param auth_token_enc Authentication token\n-     * @param groupId        Group who sent the Bundle\n-     * @param endpointId     End-point who sent the Bundle\n-\t * @param type\t\t\t response type\n-\t * @param callback \t\t response callback\n-\t * @param bundleName\t The name for the Bundle to publish\n-\t * @param forcePush \t true/false to Force the push\n-     * @param req            HttpRequest\n+     * @param fileName        File name to be published\n+     * @param authTokenDigest Authentication token\n+     * @param groupId         Group who sent the Bundle\n+     * @param endpointId      End-point who sent the Bundle\n+\t * @param type\t\t\t  response type\n+\t * @param callback \t\t  response callback\n+\t * @param bundleName\t  The name for the Bundle to publish\n+\t * @param forcePush \t  true/false to Force the push\n+     * @param request         {@link HttpServletRequest}\n+\t * @param response        {@link HttpServletResponse}\n      * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n      * @see PublishThread\n      */\n     @POST\n     @Path (\"/publish\")\n     @Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\t@Produces(MediaType.APPLICATION_JSON)\n \tpublic Response publish(\n-\t\t\t@QueryParam(\"FILE_NAME\") String fileName,\n-\t\t\t@QueryParam(\"AUTH_TOKEN\") String auth_token_digest,\n-\t\t\t@QueryParam(\"GROUP_ID\") String groupId,\n-\t\t\t@QueryParam(\"ENDPOINT_ID\") String endpointId,\n-\t\t\t@QueryParam(\"type\") String type,\n-\t\t\t@QueryParam(\"callback\") String callback,\n-\t\t\t@QueryParam(\"BUNDLE_NAME\") String bundleName,\n-\t\t\t@QueryParam(\"FORCE_PUSH\") final boolean forcePush,\n-\t\t\t@Context HttpServletRequest req\n-\t) {\n+\t\t\t@QueryParam(\"FILE_NAME\")   final String fileName,\n+\t\t\t@QueryParam(\"AUTH_TOKEN\")  final String authTokenDigest,\n+\t\t\t@QueryParam(\"GROUP_ID\")    final String groupId,\n+\t\t\t@QueryParam(\"ENDPOINT_ID\") final String endpointId,\n+\t\t\t@QueryParam(\"type\")        final String type,\n+\t\t\t@QueryParam(\"callback\")    final String callback,\n+\t\t\t@QueryParam(\"BUNDLE_NAME\") final String bundleName,\n+\t\t\t@QueryParam(\"FORCE_PUSH\")  final boolean forcePush,\n+\t\t\t@Context final HttpServletRequest  request,\n+\t\t\t@Context final HttpServletResponse response\n+\t) throws Exception {\n+\t\tfinal ResourceResponse responseResource = new ResourceResponse(\n+\t\t\t\tCollectionsUtils.map(\"type\", type, \"callback\", callback));\n+\t\tfinal String remoteIP = UtilMethods.isSet(request.getRemoteHost())?\n+\t\t\t\trequest.getRemoteHost() : request.getRemoteAddr();\n+\t\tfinal PublishingEndPoint sendingEndPointByAddress =\n+\t\t\t\tthis.endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n+\n+\t\tfinal boolean isPPByToken = sendingEndPointByAddress == null;\n+\n+\t\tif (isPPByToken && authTokenDigest == null) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" JWT token expected\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t}\n+\n+\t\tif (request.getInputStream().isFinished()) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" bundle expected\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_BAD_REQUEST);\n+\t\t}\n+\n+\t\tfinal InitDataObject initDataObject = this.init(authTokenDigest, request, response);\n+\n+\t\tif (isPPByToken && null == initDataObject || !this.isAdmin(initDataObject.getUser())) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" not permission\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t} else if (!isPPByToken &&\n+\t\t\t\t(sendingEndPointByAddress == null || !isValidToken(authTokenDigest, remoteIP, sendingEndPointByAddress))) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t}\n+\n+\t\tfinal Bundle bundle = this.publishBundle(fileName, groupId, endpointId, bundleName,\n+\t\t\t\tforcePush, request, remoteIP, sendingEndPointByAddress);\n+\n+\t\tif (isPPByToken && bundle != null) {\n+\t\t\treturn Response.ok((bundle)).build();\n+\t\t} else {\n+\t\t\treturn Response.ok().build();\n+\t\t}\n+\t}\n+\n+\n+\tfinal InitDataObject init (final String authTokenDigest, final HttpServletRequest  request,\n+\t\t\t\t\t\t\t   final HttpServletResponse response) {\n+\n     \ttry {\n-    \t\ttry (InputStream bundleStream = req.getInputStream()) {\n-\t\t        //Creating an utility response object\n-\t\t        Map<String, String> paramsMap = new HashMap<String, String>();\n-\t\t        paramsMap.put( \"type\", type );\n-\t\t        paramsMap.put( \"callback\", callback );\n-\t\t        ResourceResponse responseResource = new ResourceResponse( paramsMap );\n-\n-\t\t\t\tString remoteIP = \"\";\n-\t\t\t\ttry {\n-\n-\t\t\t\t\tremoteIP = req.getRemoteHost();\n-\t\t\t\t\tif(!UtilMethods.isSet(remoteIP))\n-\t\t\t\t\t\tremoteIP = req.getRemoteAddr();\n-\n-\t\t\t\t\tHibernateUtil.startTransaction();\n-\n-\t\t\t\t\tPublishingEndPoint mySelf = endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n-\n-\t\t\t\t\tif(mySelf==null || !isValidToken(auth_token_digest, remoteIP, mySelf)) {\n-\t\t\t\t\t\tbundleStream.close();\n-\t\t\t\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n-\t\t\t\t\t\t\n-\t\t        return responseResource.responseError( HttpStatus.SC_UNAUTHORIZED );\n-\t\t       }\n-\n-\t\t\t\t\tString bundlePath = ConfigUtils.getBundlePath()+File.separator+MY_TEMP;\n-\t\t\t\t\tString bundleFolder = fileName.substring(0, fileName.indexOf(\".tar.gz\"));\n-\n-\t\t            PublishAuditStatus status = PublishAuditAPI.getInstance().updateAuditTable( mySelf.getId(), mySelf.getId(), bundleFolder, true );\n-\n-\t\t            if(bundleName.trim().length()>0) {\n-\t\t\t\t\t    // save bundle if it doesn't exists\n-\t\t                Bundle foundBundle = APILocator.getBundleAPI().getBundleById( bundleFolder );\n-\t\t                if ( foundBundle == null || foundBundle.getId() == null ) {\n-\t\t                    Bundle bundle = new Bundle();\n-\t\t\t\t\t\t\tbundle.setId(bundleFolder);\n-\t\t\t\t\t\t\tbundle.setName(bundleName);\n-\t\t\t\t\t\t\tbundle.setPublishDate(Calendar.getInstance().getTime());\n-\t\t\t\t\t\t\tbundle.setOwner(APILocator.getUserAPI().getSystemUser().getUserId());\n-\t\t\t\t\t\t\tbundle.setForcePush(forcePush);\n-\t\t                    APILocator.getBundleAPI().saveBundle(bundle);\n-\t\t\t\t\t    }\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t//Write file on FS\n-\t\t\t\t\tFileUtil.writeToFile(bundleStream, bundlePath+fileName);\n-\n-\t\t\t\t\t//Start thread\n-\t\t\t\t\tif(!status.getStatus().equals(Status.PUBLISHING_BUNDLE)) {\n-\t\t\t\t\t\tnew Thread(new PublishThread(fileName, groupId, endpointId, status)).start();\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tHibernateUtil.commitTransaction();\n-\n-\t\t\t\t\treturn Response.status(HttpStatus.SC_OK).build();\n-\t\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class, \"Error caused by remote call of: \"+remoteIP);\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t}\n-\t\t\t\tfinally {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.closeSession();\n-\t\t            } catch (DotHibernateException e) {\n-\t\t                Logger.error(this, \"error close session\",e);\n-\t\t            }\n+\t\t\treturn new WebResource.InitBuilder().\n+\t\t\t\t\trejectWhenNoUser(false). // it would be a soft validation so not reject\n+\t\t\t\t\trequestAndResponse(\n+\t\t\t\t\tnew HttpHeaderHandlerHttpServletRequestWrapper(request,\n+\t\t\t\t\t\t\tCollectionsUtils.map(\n+\t\t\t\t\t\t\t\t\t\"Authorization\", (name, value) -> // if the authorization is set, uses it, otherwise try with the secret (could be a jwt)\n+\t\t\t\t\t\t\t\t\t\t\tUtilMethods.isSet(value) ? value : JsonWebTokenAuthCredentialProcessor.BEARER + authTokenDigest\n+\t\t\t\t\t\t\t)), response).init();\n+\t\t}catch (Exception e) {\n+    \t\treturn null;\n+\t\t}\n+\n+\t}\n+\n+\n+\t@WrapInTransaction\n+\tprivate Bundle publishBundle(final String fileNameSent,\n+\t\t\t\t\t\t\t\t  final String groupId,\n+\t\t\t\t\t\t\t\t  final String endpointId,\n+\t\t\t\t\t\t\t\t  final String bundleNameSent,\n+\t\t\t\t\t\t\t\t  final boolean forcePush,\n+\t\t\t\t\t\t\t\t  final HttpServletRequest request,\n+\t\t\t\t\t\t\t\t  final String remoteIP,\n+\t\t\t\t\t\t\t\t  final PublishingEndPoint sendingEndPointByAddress) throws Exception {\n+\n+    \tfinal String fileName = UtilMethods.isSet(fileNameSent) ? fileNameSent : generatedBundleFileName();\n+\t\tfinal String bundleName =  UtilMethods.isSet(bundleNameSent) ? bundleNameSent : fileName;\n+\n+\t\tBundle bundle = null;\n+\n+\t\ttry (InputStream bundleStream = request.getInputStream()) {\n+\n+\t\t\tfinal String bundlePath         = ConfigUtils.getBundlePath()+ File.separator + MY_TEMP;\n+\t\t\tfinal String bundleFolder       = fileName.substring(0, fileName.indexOf(\".tar.gz\"));\n+\t\t\tfinal String sendingEndPoint = sendingEndPointByAddress != null ? sendingEndPointByAddress.getId() : remoteIP;\n+\t\t\tfinal PublishAuditStatus status = PublishAuditAPI.getInstance().updateAuditTable(\n+\t\t\t\t\tsendingEndPoint, sendingEndPoint, bundleFolder, true);\n+\n+\t\t\tif(bundleName.trim().length() > 0) {\n+\t\t\t\t// save bundle if it doesn't exists\n+\t\t\t\tbundle = APILocator.getBundleAPI().getBundleById(bundleFolder);\n+\t\t\t\tif (bundle == null || bundle.getId() == null) {\n+\n+\t\t\t\t\tbundle = new Bundle();\n+\t\t\t\t\tbundle.setId(bundleFolder);\n+\t\t\t\t\tbundle.setName(bundleName);\n+\t\t\t\t\tbundle.setPublishDate(Calendar.getInstance().getTime());\n+\t\t\t\t\tbundle.setOwner(APILocator.getUserAPI().getSystemUser().getUserId());\n+\t\t\t\t\tbundle.setForcePush(forcePush);\n+\t\t\t\t\tAPILocator.getBundleAPI().saveBundle(bundle);\n \t\t\t\t}\n-    \t\t}\n-    \t} catch (IOException e) {\n-    \t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-    \t}\n+\t\t\t}\n+\n+\t\t\t//Write file on FS\n+\t\t\tFileUtil.writeToFile(bundleStream, bundlePath + fileName);\n+\n+\t\t\t//Start thread\n \n-\t\treturn Response.status(HttpStatus.SC_INTERNAL_SERVER_ERROR).build();\n+\t\t\tif(!status.getStatus().equals(Status.PUBLISHING_BUNDLE)) {\n+\t\t\t\tDotConcurrentFactory.getInstance()\n+\t\t\t\t\t\t.getSubmitter()\n+\t\t\t\t\t\t.submit(new PublishThread(fileName, groupId, endpointId, status));\n+\t\t\t}\n+\n+\t\t\treturn bundle;\n+\t\t} catch (Exception e) {\n+\n+\t\t\tLogger.error(PublisherQueueJob.class, \"Error caused by remote call of: \"+remoteIP);", "originalCommit": "1d1727a7af57fc681541d9aa72fbddcbc4357de3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwMzQzMQ==", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r441103431", "bodyText": "1aa6ff7#diff-4beff38a2c10d3a1c1843475075d0893R198", "author": "freddyucv", "createdAt": "2020-06-16T19:51:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MzQzOQ=="}], "type": "inlineReview"}, {"oid": "1aa6ff79d0ee2e5d6131b4a519f93d43a955a497", "url": "https://github.com/dotCMS/core/commit/1aa6ff79d0ee2e5d6131b4a519f93d43a955a497", "message": "#16796 refactorign", "committedDate": "2020-06-16T19:50:46Z", "type": "commit"}, {"oid": "338fb56a9e05348444336cf781d6ad1a9bff14fa", "url": "https://github.com/dotCMS/core/commit/338fb56a9e05348444336cf781d6ad1a9bff14fa", "message": "#16796 Refactoring", "committedDate": "2020-06-16T19:56:49Z", "type": "commit"}, {"oid": "04ed1411c8303c584b14070c03ccf47b61c816b9", "url": "https://github.com/dotCMS/core/commit/04ed1411c8303c584b14070c03ccf47b61c816b9", "message": "Revert \"#16796 refactoring/testing\"\n\nThis reverts commit d06b4af1f1a182020a2e8f609075197dec983b78.", "committedDate": "2020-06-16T21:06:49Z", "type": "commit"}, {"oid": "1b4ae1be7fbd781a883b0bd67106527461881c24", "url": "https://github.com/dotCMS/core/commit/1b4ae1be7fbd781a883b0bd67106527461881c24", "message": "refactoring", "committedDate": "2020-06-16T21:27:07Z", "type": "commit"}, {"oid": "80f78a9461e29a8df741584afb11b0eaaaba0b84", "url": "https://github.com/dotCMS/core/commit/80f78a9461e29a8df741584afb11b0eaaaba0b84", "message": "#16796 Fixing Test", "committedDate": "2020-06-17T16:06:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2NDUwNw==", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r441664507", "bodyText": "Codacy found an issue: Ternary operators that can be simplified with || or &&", "author": "dev-dotcms", "createdAt": "2020-06-17T16:13:23Z", "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -45,140 +47,182 @@\n      * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n      * to the {@link PublishThread Publish Thread}.\n      *\n-     * @param fileName       File name to be published\n-     * @param auth_token_enc Authentication token\n-     * @param groupId        Group who sent the Bundle\n-     * @param endpointId     End-point who sent the Bundle\n-\t * @param type\t\t\t response type\n-\t * @param callback \t\t response callback\n-\t * @param bundleName\t The name for the Bundle to publish\n-\t * @param forcePush \t true/false to Force the push\n-     * @param req            HttpRequest\n+     * @param fileName        File name to be published\n+     * @param authTokenDigest Authentication token\n+     * @param groupId         Group who sent the Bundle\n+     * @param endpointId      End-point who sent the Bundle\n+\t * @param type\t\t\t  response type\n+\t * @param callback \t\t  response callback\n+\t * @param bundleName\t  The name for the Bundle to publish\n+\t * @param forcePush \t  true/false to Force the push\n+     * @param request         {@link HttpServletRequest}\n+\t * @param response        {@link HttpServletResponse}\n      * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n      * @see PublishThread\n      */\n     @POST\n     @Path (\"/publish\")\n     @Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\t@Produces(MediaType.APPLICATION_JSON)\n \tpublic Response publish(\n-\t\t\t@QueryParam(\"FILE_NAME\") String fileName,\n-\t\t\t@QueryParam(\"AUTH_TOKEN\") String auth_token_digest,\n-\t\t\t@QueryParam(\"GROUP_ID\") String groupId,\n-\t\t\t@QueryParam(\"ENDPOINT_ID\") String endpointId,\n-\t\t\t@QueryParam(\"type\") String type,\n-\t\t\t@QueryParam(\"callback\") String callback,\n-\t\t\t@QueryParam(\"BUNDLE_NAME\") String bundleName,\n-\t\t\t@QueryParam(\"FORCE_PUSH\") final boolean forcePush,\n-\t\t\t@Context HttpServletRequest req\n-\t) {\n+\t\t\t@QueryParam(\"FILE_NAME\")   final String fileName,\n+\t\t\t@QueryParam(\"AUTH_TOKEN\")  final String authTokenDigest,\n+\t\t\t@QueryParam(\"GROUP_ID\")    final String groupId,\n+\t\t\t@QueryParam(\"ENDPOINT_ID\") final String endpointId,\n+\t\t\t@QueryParam(\"type\")        final String type,\n+\t\t\t@QueryParam(\"callback\")    final String callback,\n+\t\t\t@QueryParam(\"BUNDLE_NAME\") final String bundleName,\n+\t\t\t@QueryParam(\"FORCE_PUSH\")  final boolean forcePush,\n+\t\t\t@Context final HttpServletRequest  request,\n+\t\t\t@Context final HttpServletResponse response\n+\t) throws Exception {\n+\t\tfinal ResourceResponse responseResource = new ResourceResponse(\n+\t\t\t\tCollectionsUtils.map(\"type\", type, \"callback\", callback));\n+\t\tfinal String remoteIP = UtilMethods.isSet(request.getRemoteHost())?\n+\t\t\t\trequest.getRemoteHost() : request.getRemoteAddr();\n+\t\tfinal PublishingEndPoint sendingEndPointByAddress =\n+\t\t\t\tthis.endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n+\n+\t\tfinal boolean isPPByToken = sendingEndPointByAddress == null;\n+\n+\t\tif (isPPByToken && authTokenDigest == null) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" JWT token expected\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t}\n+\n+\t\tif (request.getInputStream().isFinished()) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" bundle expected\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_BAD_REQUEST);\n+\t\t}\n+\n+\t\tfinal InitDataObject initDataObject = this.init(authTokenDigest, request, response);\n+\n+\t\tif (isPPByToken && null == initDataObject || !this.isAdmin(initDataObject.getUser())) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" not permission\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t} else if (!isPPByToken &&\n+\t\t\t\t(sendingEndPointByAddress == null || !isValidToken(authTokenDigest, remoteIP, sendingEndPointByAddress))) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t}\n+\n+\t\tfinal Bundle bundle = this.publishBundle(fileName, groupId, endpointId, bundleName,\n+\t\t\t\tforcePush, request, remoteIP, sendingEndPointByAddress);\n+\n+\t\tif (isPPByToken && bundle != null) {\n+\t\t\treturn Response.ok(bundle).build();\n+\t\t} else {\n+\t\t\treturn Response.ok().build();\n+\t\t}\n+\t}\n+\n+\n+\tfinal InitDataObject init (final String authTokenDigest, final HttpServletRequest  request,\n+\t\t\t\t\t\t\t   final HttpServletResponse response) {\n+\n     \ttry {\n-    \t\ttry (InputStream bundleStream = req.getInputStream()) {\n-\t\t        //Creating an utility response object\n-\t\t        Map<String, String> paramsMap = new HashMap<String, String>();\n-\t\t        paramsMap.put( \"type\", type );\n-\t\t        paramsMap.put( \"callback\", callback );\n-\t\t        ResourceResponse responseResource = new ResourceResponse( paramsMap );\n-\n-\t\t\t\tString remoteIP = \"\";\n-\t\t\t\ttry {\n-\n-\t\t\t\t\tremoteIP = req.getRemoteHost();\n-\t\t\t\t\tif(!UtilMethods.isSet(remoteIP))\n-\t\t\t\t\t\tremoteIP = req.getRemoteAddr();\n-\n-\t\t\t\t\tHibernateUtil.startTransaction();\n-\n-\t\t\t\t\tPublishingEndPoint mySelf = endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n-\n-\t\t\t\t\tif(mySelf==null || !isValidToken(auth_token_digest, remoteIP, mySelf)) {\n-\t\t\t\t\t\tbundleStream.close();\n-\t\t\t\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n-\t\t\t\t\t\t\n-\t\t        return responseResource.responseError( HttpStatus.SC_UNAUTHORIZED );\n-\t\t       }\n-\n-\t\t\t\t\tString bundlePath = ConfigUtils.getBundlePath()+File.separator+MY_TEMP;\n-\t\t\t\t\tString bundleFolder = fileName.substring(0, fileName.indexOf(\".tar.gz\"));\n-\n-\t\t            PublishAuditStatus status = PublishAuditAPI.getInstance().updateAuditTable( mySelf.getId(), mySelf.getId(), bundleFolder, true );\n-\n-\t\t            if(bundleName.trim().length()>0) {\n-\t\t\t\t\t    // save bundle if it doesn't exists\n-\t\t                Bundle foundBundle = APILocator.getBundleAPI().getBundleById( bundleFolder );\n-\t\t                if ( foundBundle == null || foundBundle.getId() == null ) {\n-\t\t                    Bundle bundle = new Bundle();\n-\t\t\t\t\t\t\tbundle.setId(bundleFolder);\n-\t\t\t\t\t\t\tbundle.setName(bundleName);\n-\t\t\t\t\t\t\tbundle.setPublishDate(Calendar.getInstance().getTime());\n-\t\t\t\t\t\t\tbundle.setOwner(APILocator.getUserAPI().getSystemUser().getUserId());\n-\t\t\t\t\t\t\tbundle.setForcePush(forcePush);\n-\t\t                    APILocator.getBundleAPI().saveBundle(bundle);\n-\t\t\t\t\t    }\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t//Write file on FS\n-\t\t\t\t\tFileUtil.writeToFile(bundleStream, bundlePath+fileName);\n-\n-\t\t\t\t\t//Start thread\n-\t\t\t\t\tif(!status.getStatus().equals(Status.PUBLISHING_BUNDLE)) {\n-\t\t\t\t\t\tnew Thread(new PublishThread(fileName, groupId, endpointId, status)).start();\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tHibernateUtil.commitTransaction();\n-\n-\t\t\t\t\treturn Response.status(HttpStatus.SC_OK).build();\n-\t\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class, \"Error caused by remote call of: \"+remoteIP);\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t}\n-\t\t\t\tfinally {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.closeSession();\n-\t\t            } catch (DotHibernateException e) {\n-\t\t                Logger.error(this, \"error close session\",e);\n-\t\t            }\n+\t\t\treturn new WebResource.InitBuilder().\n+\t\t\t\t\trejectWhenNoUser(false). // it would be a soft validation so not reject\n+\t\t\t\t\trequestAndResponse(\n+\t\t\t\t\tnew HttpHeaderHandlerHttpServletRequestWrapper(request,\n+\t\t\t\t\t\t\tCollectionsUtils.map(\n+\t\t\t\t\t\t\t\t\t\"Authorization\", (name, value) -> // if the authorization is set, uses it, otherwise try with the secret (could be a jwt)\n+\t\t\t\t\t\t\t\t\t\t\tUtilMethods.isSet(value) ? value : JsonWebTokenAuthCredentialProcessor.BEARER + authTokenDigest\n+\t\t\t\t\t\t\t)), response).init();\n+\t\t}catch (Exception e) {\n+    \t\treturn null;\n+\t\t}\n+\n+\t}\n+\n+\n+\t@WrapInTransaction\n+\tprivate Bundle publishBundle(final String fileNameSent,\n+\t\t\t\t\t\t\t\t  final String groupId,\n+\t\t\t\t\t\t\t\t  final String endpointId,\n+\t\t\t\t\t\t\t\t  final String bundleNameSent,\n+\t\t\t\t\t\t\t\t  final boolean forcePush,\n+\t\t\t\t\t\t\t\t  final HttpServletRequest request,\n+\t\t\t\t\t\t\t\t  final String remoteIP,\n+\t\t\t\t\t\t\t\t  final PublishingEndPoint sendingEndPointByAddress) throws Exception {\n+\n+    \tfinal String fileName = UtilMethods.isSet(fileNameSent) ? fileNameSent : generatedBundleFileName();\n+\t\tfinal String bundleName =  UtilMethods.isSet(bundleNameSent) ? bundleNameSent : fileName;\n+\n+\t\tBundle bundle = null;\n+\n+\t\ttry (InputStream bundleStream = request.getInputStream()) {\n+\n+\t\t\tfinal String bundlePath         = ConfigUtils.getBundlePath()+ File.separator + MY_TEMP;\n+\t\t\tfinal String bundleFolder       = fileName.substring(0, fileName.indexOf(\".tar.gz\"));\n+\t\t\tfinal String sendingEndPoint = sendingEndPointByAddress != null ? sendingEndPointByAddress.getId() : remoteIP;\n+\t\t\tfinal PublishAuditStatus status = PublishAuditAPI.getInstance().updateAuditTable(\n+\t\t\t\t\tsendingEndPoint, sendingEndPoint, bundleFolder, true);\n+\n+\t\t\tif(bundleName.trim().length() > 0) {\n+\t\t\t\t// save bundle if it doesn't exists\n+\t\t\t\tbundle = APILocator.getBundleAPI().getBundleById(bundleFolder);\n+\t\t\t\tif (bundle == null || bundle.getId() == null) {\n+\n+\t\t\t\t\tbundle = new Bundle();\n+\t\t\t\t\tbundle.setId(bundleFolder);\n+\t\t\t\t\tbundle.setName(bundleName);\n+\t\t\t\t\tbundle.setPublishDate(Calendar.getInstance().getTime());\n+\t\t\t\t\tbundle.setOwner(APILocator.getUserAPI().getSystemUser().getUserId());\n+\t\t\t\t\tbundle.setForcePush(forcePush);\n+\t\t\t\t\tAPILocator.getBundleAPI().saveBundle(bundle);\n \t\t\t\t}\n-    \t\t}\n-    \t} catch (IOException e) {\n-    \t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-    \t}\n+\t\t\t}\n+\n+\t\t\t//Write file on FS\n+\t\t\tFileUtil.writeToFile(bundleStream, bundlePath + fileName);\n+\n+\t\t\t//Start thread\n \n-\t\treturn Response.status(HttpStatus.SC_INTERNAL_SERVER_ERROR).build();\n+\t\t\tif(!status.getStatus().equals(Status.PUBLISHING_BUNDLE)) {\n+\n+\t\t\t\tDotConcurrentFactory.getInstance()\n+\t\t\t\t\t\t.getSubmitter()\n+\t\t\t\t\t\t.submit(new PublishThread(fileName, groupId, endpointId, status));\n+\t\t\t}\n+\n+\t\t\treturn bundle;\n+\t\t} catch (Exception e) {\n+\n+\t\t\tLogger.error(\n+\t\t\t\t\tPublisherQueueJob.class,\n+\t\t\t\t\tString.format(\"Error caused by remote call of: Remote IP - %s, bundle name - %s, end point- %s\",\n+\t\t\t\t\t\t\tremoteIP, bundleNameSent,  endpointId));\n+\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n+\t\t\tthrow e;\n+\t\t}\n \t}\n \n-    /**\n+\tprivate String generatedBundleFileName() {\n+\t\treturn String.format(\"bundle_%d.tar.gz\", System.currentTimeMillis());\n+\t}\n+\n+\tprivate boolean isAdmin(final User user) {\n+\n+    \treturn null != user && user.isBackendUser() && user.isAdmin();\n+\t}\n+\n+\t/**\n      * Validates a received token\n      *\n      * @param token    Token to validate\n      * @param remoteIP Sender IP\n-     * @param mySelf   Current end point\n+     * @param publishingEndPoint   Current end point\n      * @return True if valid\n      * @throws IOException If fails reading the security token\n      */\n-    public static boolean isValidToken ( String token, String remoteIP, PublishingEndPoint mySelf ) throws IOException {\n+    public static boolean isValidToken (final String token,\n+\t\t\t\t\t\t\t\t\t\tfinal String remoteIP,\n+\t\t\t\t\t\t\t\t\t\tfinal PublishingEndPoint publishingEndPoint) throws IOException {\n \n         //My key\n-        Optional<String> myKey=PushPublisher.retriveEndpointKeyDigest(mySelf);\n-        if(!myKey.isPresent()) {\n-          return false;\n-        }\n-\n-\n-        return token.equals( myKey.get() );\n+        final  Optional<String> endpointKeyDigest = PushPublisher.retriveEndpointKeyDigest(publishingEndPoint);\n+        return endpointKeyDigest.isPresent()? token.equals( endpointKeyDigest.get() ): false;", "originalCommit": "80f78a9461e29a8df741584afb11b0eaaaba0b84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2NDUyNA==", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r441664524", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "author": "dev-dotcms", "createdAt": "2020-06-17T16:13:24Z", "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -45,140 +47,182 @@\n      * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n      * to the {@link PublishThread Publish Thread}.\n      *\n-     * @param fileName       File name to be published\n-     * @param auth_token_enc Authentication token\n-     * @param groupId        Group who sent the Bundle\n-     * @param endpointId     End-point who sent the Bundle\n-\t * @param type\t\t\t response type\n-\t * @param callback \t\t response callback\n-\t * @param bundleName\t The name for the Bundle to publish\n-\t * @param forcePush \t true/false to Force the push\n-     * @param req            HttpRequest\n+     * @param fileName        File name to be published\n+     * @param authTokenDigest Authentication token\n+     * @param groupId         Group who sent the Bundle\n+     * @param endpointId      End-point who sent the Bundle\n+\t * @param type\t\t\t  response type\n+\t * @param callback \t\t  response callback\n+\t * @param bundleName\t  The name for the Bundle to publish\n+\t * @param forcePush \t  true/false to Force the push\n+     * @param request         {@link HttpServletRequest}\n+\t * @param response        {@link HttpServletResponse}\n      * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n      * @see PublishThread\n      */\n     @POST\n     @Path (\"/publish\")\n     @Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\t@Produces(MediaType.APPLICATION_JSON)\n \tpublic Response publish(\n-\t\t\t@QueryParam(\"FILE_NAME\") String fileName,\n-\t\t\t@QueryParam(\"AUTH_TOKEN\") String auth_token_digest,\n-\t\t\t@QueryParam(\"GROUP_ID\") String groupId,\n-\t\t\t@QueryParam(\"ENDPOINT_ID\") String endpointId,\n-\t\t\t@QueryParam(\"type\") String type,\n-\t\t\t@QueryParam(\"callback\") String callback,\n-\t\t\t@QueryParam(\"BUNDLE_NAME\") String bundleName,\n-\t\t\t@QueryParam(\"FORCE_PUSH\") final boolean forcePush,\n-\t\t\t@Context HttpServletRequest req\n-\t) {\n+\t\t\t@QueryParam(\"FILE_NAME\")   final String fileName,\n+\t\t\t@QueryParam(\"AUTH_TOKEN\")  final String authTokenDigest,\n+\t\t\t@QueryParam(\"GROUP_ID\")    final String groupId,\n+\t\t\t@QueryParam(\"ENDPOINT_ID\") final String endpointId,\n+\t\t\t@QueryParam(\"type\")        final String type,\n+\t\t\t@QueryParam(\"callback\")    final String callback,\n+\t\t\t@QueryParam(\"BUNDLE_NAME\") final String bundleName,\n+\t\t\t@QueryParam(\"FORCE_PUSH\")  final boolean forcePush,\n+\t\t\t@Context final HttpServletRequest  request,\n+\t\t\t@Context final HttpServletResponse response\n+\t) throws Exception {", "originalCommit": "80f78a9461e29a8df741584afb11b0eaaaba0b84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2NDUzNA==", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r441664534", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "author": "dev-dotcms", "createdAt": "2020-06-17T16:13:25Z", "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -45,140 +47,182 @@\n      * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n      * to the {@link PublishThread Publish Thread}.\n      *\n-     * @param fileName       File name to be published\n-     * @param auth_token_enc Authentication token\n-     * @param groupId        Group who sent the Bundle\n-     * @param endpointId     End-point who sent the Bundle\n-\t * @param type\t\t\t response type\n-\t * @param callback \t\t response callback\n-\t * @param bundleName\t The name for the Bundle to publish\n-\t * @param forcePush \t true/false to Force the push\n-     * @param req            HttpRequest\n+     * @param fileName        File name to be published\n+     * @param authTokenDigest Authentication token\n+     * @param groupId         Group who sent the Bundle\n+     * @param endpointId      End-point who sent the Bundle\n+\t * @param type\t\t\t  response type\n+\t * @param callback \t\t  response callback\n+\t * @param bundleName\t  The name for the Bundle to publish\n+\t * @param forcePush \t  true/false to Force the push\n+     * @param request         {@link HttpServletRequest}\n+\t * @param response        {@link HttpServletResponse}\n      * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n      * @see PublishThread\n      */\n     @POST\n     @Path (\"/publish\")\n     @Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\t@Produces(MediaType.APPLICATION_JSON)\n \tpublic Response publish(\n-\t\t\t@QueryParam(\"FILE_NAME\") String fileName,\n-\t\t\t@QueryParam(\"AUTH_TOKEN\") String auth_token_digest,\n-\t\t\t@QueryParam(\"GROUP_ID\") String groupId,\n-\t\t\t@QueryParam(\"ENDPOINT_ID\") String endpointId,\n-\t\t\t@QueryParam(\"type\") String type,\n-\t\t\t@QueryParam(\"callback\") String callback,\n-\t\t\t@QueryParam(\"BUNDLE_NAME\") String bundleName,\n-\t\t\t@QueryParam(\"FORCE_PUSH\") final boolean forcePush,\n-\t\t\t@Context HttpServletRequest req\n-\t) {\n+\t\t\t@QueryParam(\"FILE_NAME\")   final String fileName,\n+\t\t\t@QueryParam(\"AUTH_TOKEN\")  final String authTokenDigest,\n+\t\t\t@QueryParam(\"GROUP_ID\")    final String groupId,\n+\t\t\t@QueryParam(\"ENDPOINT_ID\") final String endpointId,\n+\t\t\t@QueryParam(\"type\")        final String type,\n+\t\t\t@QueryParam(\"callback\")    final String callback,\n+\t\t\t@QueryParam(\"BUNDLE_NAME\") final String bundleName,\n+\t\t\t@QueryParam(\"FORCE_PUSH\")  final boolean forcePush,\n+\t\t\t@Context final HttpServletRequest  request,\n+\t\t\t@Context final HttpServletResponse response\n+\t) throws Exception {\n+\t\tfinal ResourceResponse responseResource = new ResourceResponse(\n+\t\t\t\tCollectionsUtils.map(\"type\", type, \"callback\", callback));\n+\t\tfinal String remoteIP = UtilMethods.isSet(request.getRemoteHost())?\n+\t\t\t\trequest.getRemoteHost() : request.getRemoteAddr();\n+\t\tfinal PublishingEndPoint sendingEndPointByAddress =\n+\t\t\t\tthis.endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n+\n+\t\tfinal boolean isPPByToken = sendingEndPointByAddress == null;\n+\n+\t\tif (isPPByToken && authTokenDigest == null) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" JWT token expected\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t}\n+\n+\t\tif (request.getInputStream().isFinished()) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" bundle expected\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_BAD_REQUEST);\n+\t\t}\n+\n+\t\tfinal InitDataObject initDataObject = this.init(authTokenDigest, request, response);\n+\n+\t\tif (isPPByToken && null == initDataObject || !this.isAdmin(initDataObject.getUser())) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" not permission\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t} else if (!isPPByToken &&\n+\t\t\t\t(sendingEndPointByAddress == null || !isValidToken(authTokenDigest, remoteIP, sendingEndPointByAddress))) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t}\n+\n+\t\tfinal Bundle bundle = this.publishBundle(fileName, groupId, endpointId, bundleName,\n+\t\t\t\tforcePush, request, remoteIP, sendingEndPointByAddress);\n+\n+\t\tif (isPPByToken && bundle != null) {\n+\t\t\treturn Response.ok(bundle).build();\n+\t\t} else {\n+\t\t\treturn Response.ok().build();\n+\t\t}\n+\t}\n+\n+\n+\tfinal InitDataObject init (final String authTokenDigest, final HttpServletRequest  request,\n+\t\t\t\t\t\t\t   final HttpServletResponse response) {\n+\n     \ttry {\n-    \t\ttry (InputStream bundleStream = req.getInputStream()) {\n-\t\t        //Creating an utility response object\n-\t\t        Map<String, String> paramsMap = new HashMap<String, String>();\n-\t\t        paramsMap.put( \"type\", type );\n-\t\t        paramsMap.put( \"callback\", callback );\n-\t\t        ResourceResponse responseResource = new ResourceResponse( paramsMap );\n-\n-\t\t\t\tString remoteIP = \"\";\n-\t\t\t\ttry {\n-\n-\t\t\t\t\tremoteIP = req.getRemoteHost();\n-\t\t\t\t\tif(!UtilMethods.isSet(remoteIP))\n-\t\t\t\t\t\tremoteIP = req.getRemoteAddr();\n-\n-\t\t\t\t\tHibernateUtil.startTransaction();\n-\n-\t\t\t\t\tPublishingEndPoint mySelf = endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n-\n-\t\t\t\t\tif(mySelf==null || !isValidToken(auth_token_digest, remoteIP, mySelf)) {\n-\t\t\t\t\t\tbundleStream.close();\n-\t\t\t\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n-\t\t\t\t\t\t\n-\t\t        return responseResource.responseError( HttpStatus.SC_UNAUTHORIZED );\n-\t\t       }\n-\n-\t\t\t\t\tString bundlePath = ConfigUtils.getBundlePath()+File.separator+MY_TEMP;\n-\t\t\t\t\tString bundleFolder = fileName.substring(0, fileName.indexOf(\".tar.gz\"));\n-\n-\t\t            PublishAuditStatus status = PublishAuditAPI.getInstance().updateAuditTable( mySelf.getId(), mySelf.getId(), bundleFolder, true );\n-\n-\t\t            if(bundleName.trim().length()>0) {\n-\t\t\t\t\t    // save bundle if it doesn't exists\n-\t\t                Bundle foundBundle = APILocator.getBundleAPI().getBundleById( bundleFolder );\n-\t\t                if ( foundBundle == null || foundBundle.getId() == null ) {\n-\t\t                    Bundle bundle = new Bundle();\n-\t\t\t\t\t\t\tbundle.setId(bundleFolder);\n-\t\t\t\t\t\t\tbundle.setName(bundleName);\n-\t\t\t\t\t\t\tbundle.setPublishDate(Calendar.getInstance().getTime());\n-\t\t\t\t\t\t\tbundle.setOwner(APILocator.getUserAPI().getSystemUser().getUserId());\n-\t\t\t\t\t\t\tbundle.setForcePush(forcePush);\n-\t\t                    APILocator.getBundleAPI().saveBundle(bundle);\n-\t\t\t\t\t    }\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t//Write file on FS\n-\t\t\t\t\tFileUtil.writeToFile(bundleStream, bundlePath+fileName);\n-\n-\t\t\t\t\t//Start thread\n-\t\t\t\t\tif(!status.getStatus().equals(Status.PUBLISHING_BUNDLE)) {\n-\t\t\t\t\t\tnew Thread(new PublishThread(fileName, groupId, endpointId, status)).start();\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tHibernateUtil.commitTransaction();\n-\n-\t\t\t\t\treturn Response.status(HttpStatus.SC_OK).build();\n-\t\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class, \"Error caused by remote call of: \"+remoteIP);\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t}\n-\t\t\t\tfinally {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.closeSession();\n-\t\t            } catch (DotHibernateException e) {\n-\t\t                Logger.error(this, \"error close session\",e);\n-\t\t            }\n+\t\t\treturn new WebResource.InitBuilder().\n+\t\t\t\t\trejectWhenNoUser(false). // it would be a soft validation so not reject\n+\t\t\t\t\trequestAndResponse(\n+\t\t\t\t\tnew HttpHeaderHandlerHttpServletRequestWrapper(request,\n+\t\t\t\t\t\t\tCollectionsUtils.map(\n+\t\t\t\t\t\t\t\t\t\"Authorization\", (name, value) -> // if the authorization is set, uses it, otherwise try with the secret (could be a jwt)\n+\t\t\t\t\t\t\t\t\t\t\tUtilMethods.isSet(value) ? value : JsonWebTokenAuthCredentialProcessor.BEARER + authTokenDigest\n+\t\t\t\t\t\t\t)), response).init();\n+\t\t}catch (Exception e) {\n+    \t\treturn null;\n+\t\t}\n+\n+\t}\n+\n+\n+\t@WrapInTransaction\n+\tprivate Bundle publishBundle(final String fileNameSent,\n+\t\t\t\t\t\t\t\t  final String groupId,\n+\t\t\t\t\t\t\t\t  final String endpointId,\n+\t\t\t\t\t\t\t\t  final String bundleNameSent,\n+\t\t\t\t\t\t\t\t  final boolean forcePush,\n+\t\t\t\t\t\t\t\t  final HttpServletRequest request,\n+\t\t\t\t\t\t\t\t  final String remoteIP,\n+\t\t\t\t\t\t\t\t  final PublishingEndPoint sendingEndPointByAddress) throws Exception {", "originalCommit": "80f78a9461e29a8df741584afb11b0eaaaba0b84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2NDU0NQ==", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r441664545", "bodyText": "Codacy found an issue: Avoid unused imports such as 'javax.ws.rs'", "author": "dev-dotcms", "createdAt": "2020-06-17T16:13:26Z", "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -8,27 +12,25 @@\n import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n import com.dotcms.publisher.endpoint.business.PublishingEndPointAPI;\n import com.dotcms.publisher.pusher.PushPublisher;\n-import javax.ws.rs.Consumes;\n-import javax.ws.rs.POST;\n-import javax.ws.rs.Path;\n-import javax.ws.rs.QueryParam;\n+\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.*;", "originalCommit": "80f78a9461e29a8df741584afb11b0eaaaba0b84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2NDU2MQ==", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r441664561", "bodyText": "Codacy found an issue: The String literal \"Push Publishing failed from \" appears 4 times in this file; the first occurrence is on line 94", "author": "dev-dotcms", "createdAt": "2020-06-17T16:13:28Z", "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -45,140 +47,182 @@\n      * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n      * to the {@link PublishThread Publish Thread}.\n      *\n-     * @param fileName       File name to be published\n-     * @param auth_token_enc Authentication token\n-     * @param groupId        Group who sent the Bundle\n-     * @param endpointId     End-point who sent the Bundle\n-\t * @param type\t\t\t response type\n-\t * @param callback \t\t response callback\n-\t * @param bundleName\t The name for the Bundle to publish\n-\t * @param forcePush \t true/false to Force the push\n-     * @param req            HttpRequest\n+     * @param fileName        File name to be published\n+     * @param authTokenDigest Authentication token\n+     * @param groupId         Group who sent the Bundle\n+     * @param endpointId      End-point who sent the Bundle\n+\t * @param type\t\t\t  response type\n+\t * @param callback \t\t  response callback\n+\t * @param bundleName\t  The name for the Bundle to publish\n+\t * @param forcePush \t  true/false to Force the push\n+     * @param request         {@link HttpServletRequest}\n+\t * @param response        {@link HttpServletResponse}\n      * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n      * @see PublishThread\n      */\n     @POST\n     @Path (\"/publish\")\n     @Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\t@Produces(MediaType.APPLICATION_JSON)\n \tpublic Response publish(\n-\t\t\t@QueryParam(\"FILE_NAME\") String fileName,\n-\t\t\t@QueryParam(\"AUTH_TOKEN\") String auth_token_digest,\n-\t\t\t@QueryParam(\"GROUP_ID\") String groupId,\n-\t\t\t@QueryParam(\"ENDPOINT_ID\") String endpointId,\n-\t\t\t@QueryParam(\"type\") String type,\n-\t\t\t@QueryParam(\"callback\") String callback,\n-\t\t\t@QueryParam(\"BUNDLE_NAME\") String bundleName,\n-\t\t\t@QueryParam(\"FORCE_PUSH\") final boolean forcePush,\n-\t\t\t@Context HttpServletRequest req\n-\t) {\n+\t\t\t@QueryParam(\"FILE_NAME\")   final String fileName,\n+\t\t\t@QueryParam(\"AUTH_TOKEN\")  final String authTokenDigest,\n+\t\t\t@QueryParam(\"GROUP_ID\")    final String groupId,\n+\t\t\t@QueryParam(\"ENDPOINT_ID\") final String endpointId,\n+\t\t\t@QueryParam(\"type\")        final String type,\n+\t\t\t@QueryParam(\"callback\")    final String callback,\n+\t\t\t@QueryParam(\"BUNDLE_NAME\") final String bundleName,\n+\t\t\t@QueryParam(\"FORCE_PUSH\")  final boolean forcePush,\n+\t\t\t@Context final HttpServletRequest  request,\n+\t\t\t@Context final HttpServletResponse response\n+\t) throws Exception {\n+\t\tfinal ResourceResponse responseResource = new ResourceResponse(\n+\t\t\t\tCollectionsUtils.map(\"type\", type, \"callback\", callback));\n+\t\tfinal String remoteIP = UtilMethods.isSet(request.getRemoteHost())?\n+\t\t\t\trequest.getRemoteHost() : request.getRemoteAddr();\n+\t\tfinal PublishingEndPoint sendingEndPointByAddress =\n+\t\t\t\tthis.endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n+\n+\t\tfinal boolean isPPByToken = sendingEndPointByAddress == null;\n+\n+\t\tif (isPPByToken && authTokenDigest == null) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" JWT token expected\");", "originalCommit": "80f78a9461e29a8df741584afb11b0eaaaba0b84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}