{"pr_number": 360, "pr_title": "Organize the spec into chapters and simplify", "pr_createdAt": "2020-04-03T22:54:52Z", "pr_url": "https://github.com/awslabs/smithy/pull/360", "timeline": [{"oid": "ae180441b695d003789b2416e433599390c3fe18", "url": "https://github.com/awslabs/smithy/commit/ae180441b695d003789b2416e433599390c3fe18", "message": "Organize the spec into chapters and simplify\n\nThis commit organizes the core specifications into chapters with\nautomatic numbering. This makes the spec easier to read and understand\nthe way it was intended -- piece by piece not all at once. The language\nspecification has also been folded into the normal flow of the spec.\nWhen the spec was first written, the IDL did not exist, so we just\ndocumented it in a separate spec. Now it's the de-facto way to write\nmodels, so it makes sense to move it into the normal flow.", "committedDate": "2020-04-05T04:46:35Z", "type": "forcePushed"}, {"oid": "fa4acf314de54a55532860d453c0edae21fd62e3", "url": "https://github.com/awslabs/smithy/commit/fa4acf314de54a55532860d453c0edae21fd62e3", "message": "Organize the spec into chapters and simplify\n\nThis commit organizes the core specifications into chapters with\nautomatic numbering. This makes the spec easier to read and understand\nthe way it was intended -- piece by piece not all at once. The language\nspecification has also been folded into the normal flow of the spec.\nWhen the spec was first written, the IDL did not exist, so we just\ndocumented it in a separate spec. Now it's the de-facto way to write\nmodels, so it makes sense to move it into the normal flow.", "committedDate": "2020-04-05T04:49:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMzNDgzMw==", "url": "https://github.com/awslabs/smithy/pull/360#discussion_r404334833", "bodyText": "Can the [ and ] chars get code formatting as well?", "author": "kstich", "createdAt": "2020-04-06T19:28:10Z", "path": "docs/source/spec/core/traits.rst", "diffHunk": "@@ -0,0 +1,700 @@\n+.. _traits:\n+\n+======\n+Traits\n+======\n+\n+*Traits* are model components that can be attached to :doc:`shapes <index>`\n+to describe additional information about the shape; shapes provide the\n+structure and layout of an API, while traits provide refinement and style.\n+\n+.. contents:: Table of contents\n+    :depth: 1\n+    :local:\n+    :backlinks: none\n+\n+\n+-------------------------\n+Applying traits to shapes\n+-------------------------\n+\n+Trait values immediately preceding a shape definition are applied to the\n+shape.\n+\n+The following example applies the ``sensitive`` and ``documentation`` trait\n+to ``MyString``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @sensitive\n+        @documentation(\"Contains a string\")\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#documentation\": \"Contains a string\",\n+                        \"smithy.api#sensitive\": true\n+                    }\n+                }\n+            }\n+        }\n+\n+The shape ID of a trait is *resolved* against :token:`use_statement`\\s and the\n+current namespace in exactly the same same way as\n+:ref:`other shape IDs <relative-shape-id>`.\n+\n+.. important::\n+\n+    Trait names are case-sensitive; it is invalid, for example, to refer to\n+    the :ref:`documentation-trait` as \"Documentation\").\n+\n+\n+Apply statement\n+===============\n+\n+Traits can be applied to shapes outside of a shape's definition using the\n+``apply`` statement. This can be useful for allowing different teams within\n+the same organization to independently own different facets of a model.\n+For example, a service team could own the Smithy model that defines the\n+shapes and traits of the API, and a documentation team could own a Smithy\n+model that applies documentation traits to the shapes.\n+\n+Apply statements are formed using the following grammar:\n+\n+.. productionlist:: smithy\n+    apply_statement         :\"apply\" `shape_id` `trait`\n+\n+The following example applies the :ref:`documentation-trait` and\n+:ref:`length-trait` to the ``smithy.example#MyString`` shape:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        apply MyString @documentation(\"This is my string!\")\n+        apply MyString @length(min: 1, max: 10)\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"apply\",\n+                    \"traits\": {\n+                        \"smithy.api#documentation\": \"This is my string!\",\n+                        \"smithy.api#length\": {\n+                            \"min\": 1,\n+                            \"max\": 10\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to members too:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    apply MyStructure$foo @documentation(\"Structure member documentation\")\n+    apply MyUnion$foo @documentation(\"Union member documentation\")\n+    apply MyList$member @documentation(\"List member documentation\")\n+    apply MySet$member @documentation(\"Set member documentation\")\n+    apply MyMap$key @documentation(\"Map key documentation\")\n+    apply MyMap$value @documentation(\"Map key documentation\")\n+\n+\n+Scope of member traits\n+======================\n+\n+Traits that target :ref:`members <member>` apply only in the context of\n+the member shape and do not affect the shape targeted by the member. Traits\n+applied to a member supersede traits applied to the shape referenced by the\n+member and do not conflict.\n+\n+\n+.. _trait-values:\n+\n+------------\n+Trait values\n+------------\n+\n+The value that can be provided for a trait depends on its type. A value for a\n+trait is defined in the IDL by enclosing the value in parenthesis. Trait values\n+can only appear immediately before a shape.\n+\n+.. productionlist:: smithy\n+    trait                   :\"@\" `shape_id` [\"(\" `trait_body_value` \")\"]\n+    trait_body_value        :`trait_structure` / `node_value`\n+    trait_structure         :`trait_structure_kvp` *(\",\" `trait_structure_kvp`)\n+    trait_structure_kvp     :`text` \":\" `node_value`\n+\n+The following example applies various traits to a structure shape and its\n+members.\n+\n+.. code-block:: smithy\n+\n+    @documentation(\"An animal in the animal kingdom\")\n+    structure Animal {\n+        @required\n+        name: smithy.api#String,\n+\n+        @length(min: 0)\n+        age: smithy.api#Integer,\n+    }\n+\n+\n+Structure, map, and union trait values\n+======================================\n+\n+Traits that are a ``structure``, ``union``, or ``map`` are defined using\n+a special syntax that places key-value pairs inside of the trait\n+parenthesis. Wrapping braces, \"{\" and \"}\", are not permitted.\n+\n+.. code-block:: smithy\n+    :caption: Example\n+\n+    @structuredTrait(foo: \"bar\", baz: \"bam\")\n+\n+Nested structure, map, and union values are defined using\n+:ref:`node value <node-values>` productions:\n+\n+.. code-block:: smithy\n+\n+    @structuredTrait(\n+        foo: {\n+            bar: \"baz\",\n+            qux: \"true\",\n+        }\n+    )\n+\n+Omitting a value is allowed on ``list``, ``set``, ``map``, and ``structure``\n+traits if the shapes have no ``length`` constraints or ``required`` members.\n+\n+\n+Annotation traits\n+=================\n+\n+A structure trait with no members is called an *annotation trait*. The\n+following example defines an annotation trait named ``foo``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @trait\n+        structure foo {}\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0.0\",\n+            \"shapes\": {\n+                \"smithy.example#foo\": {\n+                    \"type\": \"structure\",\n+                    \"traits\": {\n+                        \"smithy.api#trait\": true\n+                    }\n+                }\n+            }\n+        }\n+\n+It's hard to predict what information a trait needs to capture when modeling\n+a domain; a trait might start out as a simple annotation, but later might need\n+additional information. By defining an annotation trait rather than a boolean\n+shape, the trait can safely add optional members over time as needed.\n+\n+Smithy explicitly supports this use case by allowing ``true`` to be provided\n+for structure traits that have no required members.\n+\n+The following applications of the ``foo`` annotation trait are all equivalent:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @foo\n+        string MyString1\n+\n+        @foo()\n+        string MyString2\n+\n+        @foo(true)\n+        string MyString3\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString1\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#foo\": {}\n+                    }\n+                },\n+                \"smithy.example#MyString2\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#foo\": {}\n+                    }\n+                },\n+                \"smithy.example#MyString3\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#foo\": true\n+                    }\n+                }\n+            }\n+        }\n+\n+A member can be safely added to an annotation trait if the member is not\n+marked as required. The applications of the ``foo`` trait in the previous\n+example and the following example are all valid even after adding a member\n+to the ``foo`` trait:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @trait\n+        structure foo {\n+            baz: String,\n+        }\n+\n+        @foo(baz: \"bar\")\n+        string MyString4\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0.0\",\n+            \"shapes\": {\n+                \"smithy.example#foo\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"baz\": {\n+                            \"target\": \"smithy.api#String\"\n+                        }\n+                    },\n+                    \"traits\": {\n+                        \"smithy.api#trait\": true\n+                    }\n+                },\n+                \"smithy.example#MyString4\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#foo\": {\n+                            \"baz\": \"bar\"\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+List and set trait values\n+=========================\n+\n+Traits that are a ``list`` or ``set`` shape are defined inside\n+of brackets ([) and (]) using a :token:`node_array` production.", "originalCommit": "21274fb1b3c5a10e0518bde8e80bb4de08881a5b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM1NjMwMg==", "url": "https://github.com/awslabs/smithy/pull/360#discussion_r404356302", "bodyText": "This table is missing an entry for set.", "author": "kstich", "createdAt": "2020-04-06T20:07:49Z", "path": "docs/source/spec/core/traits.rst", "diffHunk": "@@ -0,0 +1,702 @@\n+.. _traits:\n+\n+======\n+Traits\n+======\n+\n+*Traits* are model components that can be attached to :doc:`shapes <index>`\n+to describe additional information about the shape; shapes provide the\n+structure and layout of an API, while traits provide refinement and style.\n+\n+.. contents:: Table of contents\n+    :depth: 1\n+    :local:\n+    :backlinks: none\n+\n+\n+-------------------------\n+Applying traits to shapes\n+-------------------------\n+\n+Trait values immediately preceding a shape definition are applied to the\n+shape.\n+\n+The following example applies the ``sensitive`` and ``documentation`` trait\n+to ``MyString``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @sensitive\n+        @documentation(\"Contains a string\")\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#documentation\": \"Contains a string\",\n+                        \"smithy.api#sensitive\": true\n+                    }\n+                }\n+            }\n+        }\n+\n+The shape ID of a trait is *resolved* against :token:`use_statement`\\s and the\n+current namespace in exactly the same same way as\n+:ref:`other shape IDs <relative-shape-id>`.\n+\n+.. important::\n+\n+    Trait names are case-sensitive; it is invalid, for example, to refer to\n+    the :ref:`documentation-trait` as \"Documentation\").\n+\n+\n+Apply statement\n+===============\n+\n+Traits can be applied to shapes outside of a shape's definition using the\n+``apply`` statement. This can be useful for allowing different teams within\n+the same organization to independently own different facets of a model.\n+For example, a service team could own the Smithy model that defines the\n+shapes and traits of the API, and a documentation team could own a Smithy\n+model that applies documentation traits to the shapes.\n+\n+Apply statements are formed using the following grammar:\n+\n+.. productionlist:: smithy\n+    apply_statement         :\"apply\" `shape_id` `trait`\n+\n+The following example applies the :ref:`documentation-trait` and\n+:ref:`length-trait` to the ``smithy.example#MyString`` shape:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        apply MyString @documentation(\"This is my string!\")\n+        apply MyString @length(min: 1, max: 10)\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"apply\",\n+                    \"traits\": {\n+                        \"smithy.api#documentation\": \"This is my string!\",\n+                        \"smithy.api#length\": {\n+                            \"min\": 1,\n+                            \"max\": 10\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to members too:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    apply MyStructure$foo @documentation(\"Structure member documentation\")\n+    apply MyUnion$foo @documentation(\"Union member documentation\")\n+    apply MyList$member @documentation(\"List member documentation\")\n+    apply MySet$member @documentation(\"Set member documentation\")\n+    apply MyMap$key @documentation(\"Map key documentation\")\n+    apply MyMap$value @documentation(\"Map key documentation\")\n+\n+\n+Scope of member traits\n+======================\n+\n+Traits that target :ref:`members <member>` apply only in the context of\n+the member shape and do not affect the shape targeted by the member. Traits\n+applied to a member supersede traits applied to the shape referenced by the\n+member and do not conflict.\n+\n+\n+.. _trait-values:\n+\n+------------\n+Trait values\n+------------\n+\n+The value that can be provided for a trait depends on its type. A value for a\n+trait is defined in the IDL by enclosing the value in parenthesis. Trait values\n+can only appear immediately before a shape.\n+\n+.. productionlist:: smithy\n+    trait                   :\"@\" `shape_id` [\"(\" `trait_body_value` \")\"]\n+    trait_body_value        :`trait_structure` / `node_value`\n+    trait_structure         :`trait_structure_kvp` *(\",\" `trait_structure_kvp`)\n+    trait_structure_kvp     :`text` \":\" `node_value`\n+\n+The following example applies various traits to a structure shape and its\n+members.\n+\n+.. code-block:: smithy\n+\n+    @documentation(\"An animal in the animal kingdom\")\n+    structure Animal {\n+        @required\n+        name: smithy.api#String,\n+\n+        @length(min: 0)\n+        age: smithy.api#Integer,\n+    }\n+\n+\n+Structure, map, and union trait values\n+======================================\n+\n+Traits that are a ``structure``, ``union``, or ``map`` are defined using\n+a special syntax that places key-value pairs inside of the trait\n+parenthesis. Wrapping braces, \"{\" and \"}\", are not permitted.\n+\n+.. code-block:: smithy\n+    :caption: Example\n+\n+    @structuredTrait(foo: \"bar\", baz: \"bam\")\n+\n+Nested structure, map, and union values are defined using\n+:ref:`node value <node-values>` productions:\n+\n+.. code-block:: smithy\n+\n+    @structuredTrait(\n+        foo: {\n+            bar: \"baz\",\n+            qux: \"true\",\n+        }\n+    )\n+\n+Omitting a value is allowed on ``list``, ``set``, ``map``, and ``structure``\n+traits if the shapes have no ``length`` constraints or ``required`` members.\n+\n+\n+Annotation traits\n+=================\n+\n+A structure trait with no members is called an *annotation trait*. The\n+following example defines an annotation trait named ``foo``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @trait\n+        structure foo {}\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0.0\",\n+            \"shapes\": {\n+                \"smithy.example#foo\": {\n+                    \"type\": \"structure\",\n+                    \"traits\": {\n+                        \"smithy.api#trait\": true\n+                    }\n+                }\n+            }\n+        }\n+\n+It's hard to predict what information a trait needs to capture when modeling\n+a domain; a trait might start out as a simple annotation, but later might need\n+additional information. By defining an annotation trait rather than a boolean\n+shape, the trait can safely add optional members over time as needed.\n+\n+Smithy explicitly supports this use case by allowing ``true`` to be provided\n+for structure traits that have no required members.\n+\n+The following applications of the ``foo`` annotation trait are all equivalent:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @foo\n+        string MyString1\n+\n+        @foo()\n+        string MyString2\n+\n+        @foo(true)\n+        string MyString3\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString1\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#foo\": {}\n+                    }\n+                },\n+                \"smithy.example#MyString2\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#foo\": {}\n+                    }\n+                },\n+                \"smithy.example#MyString3\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#foo\": true\n+                    }\n+                }\n+            }\n+        }\n+\n+A member can be safely added to an annotation trait if the member is not\n+marked as required. The applications of the ``foo`` trait in the previous\n+example and the following example are all valid even after adding a member\n+to the ``foo`` trait:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @trait\n+        structure foo {\n+            baz: String,\n+        }\n+\n+        @foo(baz: \"bar\")\n+        string MyString4\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0.0\",\n+            \"shapes\": {\n+                \"smithy.example#foo\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"baz\": {\n+                            \"target\": \"smithy.api#String\"\n+                        }\n+                    },\n+                    \"traits\": {\n+                        \"smithy.api#trait\": true\n+                    }\n+                },\n+                \"smithy.example#MyString4\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#foo\": {\n+                            \"baz\": \"bar\"\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+List and set trait values\n+=========================\n+\n+Traits that are a ``list`` or ``set`` shape are defined inside\n+of brackets ([) and (]) using a :token:`node_array` production.\n+\n+.. code-block:: smithy\n+    :caption: Example\n+\n+    @tags([\"a\", \"b\"])\n+\n+\n+Other trait values\n+==================\n+\n+All other trait values MUST adhere to the JSON type mappings defined\n+in :ref:`trait-definition-values` table.\n+\n+The following example defines a string trait value:\n+\n+.. code-block:: smithy\n+\n+    @documentation(\"Hello\")\n+\n+\n+.. _trait-shapes:\n+\n+---------------------\n+Defining trait shapes\n+---------------------\n+\n+A *trait shape* is a shape that is specialized to function as a trait.\n+Traits are defined inside of a namespace by applying ``smithy.api#trait``\n+to a shape. This trait can only be applied to simple types, ``list``,\n+``map``, ``set``, ``structure``, and ``union`` shapes.\n+\n+The following example defines a trait named ``myTraitName`` in the\n+``smithy.example`` namespace:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @trait(selector: \"*\")\n+        structure myTraitName {}\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0.0\",\n+            \"shapes\": {\n+                \"smithy.example#myTraitName\": {\n+                    \"type\": \"structure\",\n+                    \"traits\": {\n+                        \"smithy.api#trait\": {\n+                            \"selector\": \"*\"\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+.. tip::\n+\n+    By convention, trait shape names SHOULD use a lowercase name so that they\n+    visually stand out from normal shapes.\n+\n+After a trait is defined, it can be applied to any shape that matches its\n+selector. The following example applies the ``smithy.example#myTraitName``\n+trait to the ``MyString`` shape using a trait shape ID that is relative to\n+the current namespace:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @myTraitName\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#myTraitName\": true\n+                    }\n+                }\n+            }\n+        }\n+\n+Built-in traits defined in the Smithy :ref:`prelude <prelude>` namespace,\n+``smithy.api``, are automatically available in every Smithy model and\n+namespace through relative shape IDs.\n+\n+.. important::\n+\n+    The only valid reference to a trait shape is through applying the trait\n+    to a shape. Members and references within a model MUST NOT refer to\n+    trait shapes.\n+\n+\n+.. _trait-shape-properties:\n+\n+Trait shape properties\n+======================\n+\n+The ``smithy.api#trait`` trait is a structure that supports the following\n+members:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 20 70\n+\n+    * - Property\n+      - Type\n+      - Description\n+    * - selector\n+      - string\n+      - A valid :ref:`selector <selectors>` that defines where the trait\n+        can be applied. For example, a ``selector`` set to ``:test(list, map)``\n+        means that the trait can be applied to a :ref:`list` or :ref:`map`\n+        shape. This value defaults to ``*`` if not set, meaning the trait can\n+        be applied to any shape.\n+    * - conflicts\n+      - [string]\n+      - Defines the shape IDs of traits that MUST NOT be applied to the same\n+        shape as the trait being defined. This allows traits to be defined as\n+        mutually exclusive. Relative shape IDs that are not resolved in the IDL\n+        while parsing are assumed to refer to traits defined in the prelude\n+        namespace, ``smithy.api``. Conflict shape IDs MAY reference unknown\n+        trait shapes that are not defined in the model.\n+    * - structurallyExclusive\n+      - string\n+      - One of \"member\" or \"target\". When set to \"member\", only a single\n+        member of a structure can be marked with the trait. When set to\n+        \"target\", only a single member of a structure can target a shape\n+        marked with this trait.\n+\n+The following example defines two custom traits: ``beta`` and\n+``structuredTrait``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        /// A trait that can be applied to a member.\n+        @trait(selector: \"member:of(structure)\")\n+        structure beta {}\n+\n+        /// A trait that has members.\n+        @trait(selector: \"string\", conflicts: [beta])\n+        structure structuredTrait {\n+            @required\n+            lorem: StringShape,\n+\n+            @required\n+            ipsum: StringShape,\n+\n+            dolor: StringShape,\n+        }\n+\n+        // Apply the \"beta\" trait to the \"foo\" member.\n+        structure MyShape {\n+            @required\n+            @beta\n+            foo: StringShape,\n+        }\n+\n+        // Apply the structuredTrait to the string.\n+        @structuredTrait(\n+            lorem: \"This is a custom trait!\",\n+            ipsum: \"lorem and ipsum are both required values.\")\n+        string StringShape\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0.0\",\n+            \"shapes\": {\n+                \"smithy.example#beta\": {\n+                    \"type\": \"apply\",\n+                    \"traits\": {\n+                        \"smithy.api#type\": \"structure\",\n+                        \"smithy.api#trait\": {\n+                            \"selector\": \"member:of(structure)\"\n+                        },\n+                        \"smithy.api#documentation\": \"A trait that can be applied to a member.\"\n+                    }\n+                },\n+                \"smithy.example#structuredTrait\": {\n+                    \"type\": \"apply\",\n+                    \"traits\": {\n+                        \"smithy.api#type\": \"structure\",\n+                        \"smithy.api#trait\": {\n+                            \"selector\": \"string\",\n+                            \"conflicts\": [\n+                                \"smithy.example#beta\"\n+                            ]\n+                        },\n+                        \"smithy.api#members\": {\n+                            \"lorem\": {\n+                                \"target\": \"StringShape\",\n+                                \"required\": true\n+                            },\n+                            \"dolor\": {\n+                                \"target\": \"StringShape\"\n+                            }\n+                        },\n+                        \"smithy.api#documentation\": \"A trait that has members.\"\n+                    }\n+                },\n+                \"smithy.example#MyShape\": {\n+                    \"type\": \"apply\",\n+                    \"traits\": {\n+                        \"smithy.api#type\": \"structure\",\n+                        \"smithy.api#members\": {\n+                            \"beta\": {\n+                                \"target\": \"StringShape\",\n+                                \"required\": true,\n+                                \"beta\": true\n+                            }\n+                        }\n+                    }\n+                },\n+                \"smithy.example#StringShape\": {\n+                    \"type\": \"apply\",\n+                    \"traits\": {\n+                        \"smithy.api#type\": \"string\",\n+                        \"smithy.api#structuredTrait\": {\n+                            \"lorem\": \"This is a custom trait!\",\n+                            \"ipsum\": \"lorem and ipsum are both required values.\"\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _trait-definition-values:\n+\n+-----------------\n+Trait node values\n+-----------------\n+\n+The value provided for a trait MUST be compatible with the ``shape`` defined\n+for the trait. The following table defines each shape type that is available\n+to target from trait shapes and how values for those shapes are defined\n+in JSON and :token:`node <node_value>` values.\n+\n+.. list-table::", "originalCommit": "065ead26cf27a85bf8da179a6f9755ddebc9cb13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2MTA5MA==", "url": "https://github.com/awslabs/smithy/pull/360#discussion_r404361090", "bodyText": "This should link to the \"Shape ID conflicts\" section and be clearer about case insensitivity.", "author": "kstich", "createdAt": "2020-04-06T20:16:41Z", "path": "docs/source/spec/core/merging-models.rst", "diffHunk": "@@ -0,0 +1,17 @@\n+.. _merging-models:\n+\n+==============\n+Merging models\n+==============\n+\n+Smithy models MAY be divided into multiple files so that they are easier to\n+maintain and evolve. Smithy tools MUST take the following steps to merge two\n+models together to form a composite model:\n+\n+#. Assert that both models use a :ref:`version <smithy-version>` that is\n+   compatible with the tool versions specified.\n+#. Duplicate shape names, if found, MUST cause the model merge to fail.", "originalCommit": "065ead26cf27a85bf8da179a6f9755ddebc9cb13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3af2abd6fb9237b7b8c6dec46b2a6d33902c6ca8", "url": "https://github.com/awslabs/smithy/commit/3af2abd6fb9237b7b8c6dec46b2a6d33902c6ca8", "message": "Organize the spec into chapters and simplify\n\nThis commit organizes the core specifications into chapters with\nautomatic numbering. This makes the spec easier to read and understand\nthe way it was intended -- piece by piece not all at once. The language\nspecification has also been folded into the normal flow of the spec.\nWhen the spec was first written, the IDL did not exist, so we just\ndocumented it in a separate spec. Now it's the de-facto way to write\nmodels, so it makes sense to move it into the normal flow.", "committedDate": "2020-04-06T21:26:12Z", "type": "commit"}, {"oid": "34666078318129f3a76e54c739fe514b3af4f010", "url": "https://github.com/awslabs/smithy/commit/34666078318129f3a76e54c739fe514b3af4f010", "message": "Make structurallyExclusive more powerful\n\nThis commit updates the structurallyExclusive property of a trait\ndefinition to now be a string set to one of \"member\" (the current\nbehavior) or \"target\". \"member\" is the current behavior where only a\nsingle member of a structure can be marked with the trait. \"target\" is a\nnew feature that generalizes the validation previously performed on\ntraits like streaming and eventStream: only a single member of a\nstructure can target a shape marked with the trait.", "committedDate": "2020-04-06T21:26:30Z", "type": "commit"}, {"oid": "34666078318129f3a76e54c739fe514b3af4f010", "url": "https://github.com/awslabs/smithy/commit/34666078318129f3a76e54c739fe514b3af4f010", "message": "Make structurallyExclusive more powerful\n\nThis commit updates the structurallyExclusive property of a trait\ndefinition to now be a string set to one of \"member\" (the current\nbehavior) or \"target\". \"member\" is the current behavior where only a\nsingle member of a structure can be marked with the trait. \"target\" is a\nnew feature that generalizes the validation previously performed on\ntraits like streaming and eventStream: only a single member of a\nstructure can target a shape marked with the trait.", "committedDate": "2020-04-06T21:26:30Z", "type": "forcePushed"}]}