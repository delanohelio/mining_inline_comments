{"pr_number": 623, "pr_title": "Add support for \"waiters\"", "pr_createdAt": "2020-11-04T00:05:22Z", "pr_url": "https://github.com/awslabs/smithy/pull/623", "timeline": [{"oid": "e3ca3ead2e57a06c0055fc13512c3ea022988e5a", "url": "https://github.com/awslabs/smithy/commit/e3ca3ead2e57a06c0055fc13512c3ea022988e5a", "message": "Add support for \"waiters\"\n\nWaiters are a client-side abstraction used to poll a resource until a\ndesired state is reached, or until it is determined that the resource\nwill never enter into the desired state.\n\nWaiters have been available in AWS SDKs since around 2012, and are now\npart of Smithy as an additional specification. Note that this PR relies\non smithy-jmespath.", "committedDate": "2020-11-04T04:44:21Z", "type": "forcePushed"}, {"oid": "1340cc91f37b3adc99ca46f920d930614a75b72b", "url": "https://github.com/awslabs/smithy/commit/1340cc91f37b3adc99ca46f920d930614a75b72b", "message": "Add support for \"waiters\"\n\nWaiters are a client-side abstraction used to poll a resource until a\ndesired state is reached, or until it is determined that the resource\nwill never enter into the desired state.\n\nWaiters have been available in AWS SDKs since around 2012, and are now\npart of Smithy as an additional specification. Note that this PR relies\non smithy-jmespath.", "committedDate": "2020-11-04T22:21:34Z", "type": "commit"}, {"oid": "1340cc91f37b3adc99ca46f920d930614a75b72b", "url": "https://github.com/awslabs/smithy/commit/1340cc91f37b3adc99ca46f920d930614a75b72b", "message": "Add support for \"waiters\"\n\nWaiters are a client-side abstraction used to poll a resource until a\ndesired state is reached, or until it is determined that the resource\nwill never enter into the desired state.\n\nWaiters have been available in AWS SDKs since around 2012, and are now\npart of Smithy as an additional specification. Note that this PR relies\non smithy-jmespath.", "committedDate": "2020-11-04T22:21:34Z", "type": "forcePushed"}, {"oid": "75058e88706292c20f675bfd5b2f86228e144e8d", "url": "https://github.com/awslabs/smithy/commit/75058e88706292c20f675bfd5b2f86228e144e8d", "message": "Refactor waiters\n\nThis commit makes a few changes to waiters:\n\n1. I removed and, or, and not. I couldn't think of a real use case for\n   these as I was documenting them, so I am erring on the side of\n   simplicity.\n2. I removed the emptyArray comparator. This need more work to properly\n   validate and specify it, and it can actually be acheived using a\n   booleanEquals comparator by checking if a returned length of a value\n   in JMESPath is equal to 0. No need for an extra comparator.\n3. I added a new matcher named `inputOutput` that has two top level\n   keys: input and output. This allows both input and output data to be\n   queried *together* for successful operations, solving a longstanding\n   use case we've had for things like making sure the number of\n   autoscaling groups on input matches the number returned on output.\n4. Given that and, or, and not was removed, there's no purpose for a\n   standalone \"input\" matcher, particularly since there's now an\n   \"inputOutput\" matcher.", "committedDate": "2020-11-06T07:20:14Z", "type": "commit"}, {"oid": "75058e88706292c20f675bfd5b2f86228e144e8d", "url": "https://github.com/awslabs/smithy/commit/75058e88706292c20f675bfd5b2f86228e144e8d", "message": "Refactor waiters\n\nThis commit makes a few changes to waiters:\n\n1. I removed and, or, and not. I couldn't think of a real use case for\n   these as I was documenting them, so I am erring on the side of\n   simplicity.\n2. I removed the emptyArray comparator. This need more work to properly\n   validate and specify it, and it can actually be acheived using a\n   booleanEquals comparator by checking if a returned length of a value\n   in JMESPath is equal to 0. No need for an extra comparator.\n3. I added a new matcher named `inputOutput` that has two top level\n   keys: input and output. This allows both input and output data to be\n   queried *together* for successful operations, solving a longstanding\n   use case we've had for things like making sure the number of\n   autoscaling groups on input matches the number returned on output.\n4. Given that and, or, and not was removed, there's no purpose for a\n   standalone \"input\" matcher, particularly since there's now an\n   \"inputOutput\" matcher.", "committedDate": "2020-11-06T07:20:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5NTM5Nw==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r518895397", "bodyText": "retry isn't a final state.", "author": "kstich", "createdAt": "2020-11-06T17:24:09Z", "path": "smithy-waiters/src/main/java/software/amazon/smithy/waiters/AcceptorState.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.waiters;\n+\n+import java.util.Locale;\n+import software.amazon.smithy.model.node.ExpectationNotMetException;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.node.ToNode;\n+\n+/**\n+ * The transition state of a waiter.\n+ */\n+public enum AcceptorState implements ToNode {\n+\n+    /** Transition to a final success state. */\n+    SUCCESS,\n+\n+    /** Transition to a final failure state. */\n+    FAILURE,\n+\n+    /** Transition to a final retry state. */", "originalCommit": "75058e88706292c20f675bfd5b2f86228e144e8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkxMzQ1Mw==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r518913453", "bodyText": "Missing a word, \"allows\" looks likely.", "author": "kstich", "createdAt": "2020-11-06T17:57:27Z", "path": "smithy-waiters/src/main/java/software/amazon/smithy/waiters/ModelRuntimeTypeGenerator.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.waiters;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.shapes.BigDecimalShape;\n+import software.amazon.smithy.model.shapes.BigIntegerShape;\n+import software.amazon.smithy.model.shapes.BlobShape;\n+import software.amazon.smithy.model.shapes.BooleanShape;\n+import software.amazon.smithy.model.shapes.ByteShape;\n+import software.amazon.smithy.model.shapes.DocumentShape;\n+import software.amazon.smithy.model.shapes.DoubleShape;\n+import software.amazon.smithy.model.shapes.FloatShape;\n+import software.amazon.smithy.model.shapes.IntegerShape;\n+import software.amazon.smithy.model.shapes.ListShape;\n+import software.amazon.smithy.model.shapes.LongShape;\n+import software.amazon.smithy.model.shapes.MapShape;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.OperationShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.ServiceShape;\n+import software.amazon.smithy.model.shapes.SetShape;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.shapes.ShapeVisitor;\n+import software.amazon.smithy.model.shapes.ShortShape;\n+import software.amazon.smithy.model.shapes.StringShape;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.shapes.TimestampShape;\n+import software.amazon.smithy.model.shapes.UnionShape;\n+import software.amazon.smithy.model.traits.LengthTrait;\n+import software.amazon.smithy.model.traits.RangeTrait;\n+\n+/**\n+ * Generates fake data from a modeled shape for static JMESPath analysis.\n+ */\n+final class ModelRuntimeTypeGenerator implements ShapeVisitor<Object> {\n+\n+    private final Model model;\n+    private Set<MemberShape> visited = new HashSet<>();\n+\n+    ModelRuntimeTypeGenerator(Model model) {\n+        this.model = model;\n+    }\n+\n+    @Override\n+    public Object blobShape(BlobShape shape) {\n+        return \"blob\";\n+    }\n+\n+    @Override\n+    public Object booleanShape(BooleanShape shape) {\n+        return true;\n+    }\n+\n+    @Override\n+    public Object byteShape(ByteShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object shortShape(ShortShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object integerShape(IntegerShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object longShape(LongShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object floatShape(FloatShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object doubleShape(DoubleShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object bigIntegerShape(BigIntegerShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object bigDecimalShape(BigDecimalShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object documentShape(DocumentShape shape) {\n+        return LiteralExpression.ANY;\n+    }\n+\n+    @Override\n+    public Object stringShape(StringShape shape) {\n+        // Create a random string that does not exceed or go under the length trait.\n+        int chars = computeLength(shape);\n+\n+        // Fill a string with \"a\"'s up to chars.\n+        return new String(new char[chars]).replace(\"\\0\", \"a\");\n+    }\n+\n+    @Override\n+    public Object listShape(ListShape shape) {\n+        return createListOrSet(shape, shape.getMember());\n+    }\n+\n+    @Override\n+    public Object setShape(SetShape shape) {\n+        return createListOrSet(shape, shape.getMember());\n+    }\n+\n+    private Object createListOrSet(Shape shape, MemberShape member) {\n+        return withCopiedVisitors(() -> {\n+            int size = computeLength(shape);\n+            List<Object> result = new ArrayList<>(size);\n+            Object memberValue = member.accept(this);\n+            if (memberValue != null) {\n+                for (int i = 0; i < size; i++) {\n+                    result.add(memberValue);\n+                }\n+            }\n+            return result;\n+        });\n+    }\n+\n+    // Visits members and mutates a copy of the current set of\n+    // visited shapes rather than a shared set. This a shape to", "originalCommit": "75058e88706292c20f675bfd5b2f86228e144e8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkxNDk2Nw==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r518914967", "bodyText": "assumed*", "author": "kstich", "createdAt": "2020-11-06T18:00:19Z", "path": "smithy-waiters/src/main/java/software/amazon/smithy/waiters/ModelRuntimeTypeGenerator.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.waiters;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.shapes.BigDecimalShape;\n+import software.amazon.smithy.model.shapes.BigIntegerShape;\n+import software.amazon.smithy.model.shapes.BlobShape;\n+import software.amazon.smithy.model.shapes.BooleanShape;\n+import software.amazon.smithy.model.shapes.ByteShape;\n+import software.amazon.smithy.model.shapes.DocumentShape;\n+import software.amazon.smithy.model.shapes.DoubleShape;\n+import software.amazon.smithy.model.shapes.FloatShape;\n+import software.amazon.smithy.model.shapes.IntegerShape;\n+import software.amazon.smithy.model.shapes.ListShape;\n+import software.amazon.smithy.model.shapes.LongShape;\n+import software.amazon.smithy.model.shapes.MapShape;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.OperationShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.ServiceShape;\n+import software.amazon.smithy.model.shapes.SetShape;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.shapes.ShapeVisitor;\n+import software.amazon.smithy.model.shapes.ShortShape;\n+import software.amazon.smithy.model.shapes.StringShape;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.shapes.TimestampShape;\n+import software.amazon.smithy.model.shapes.UnionShape;\n+import software.amazon.smithy.model.traits.LengthTrait;\n+import software.amazon.smithy.model.traits.RangeTrait;\n+\n+/**\n+ * Generates fake data from a modeled shape for static JMESPath analysis.\n+ */\n+final class ModelRuntimeTypeGenerator implements ShapeVisitor<Object> {\n+\n+    private final Model model;\n+    private Set<MemberShape> visited = new HashSet<>();\n+\n+    ModelRuntimeTypeGenerator(Model model) {\n+        this.model = model;\n+    }\n+\n+    @Override\n+    public Object blobShape(BlobShape shape) {\n+        return \"blob\";\n+    }\n+\n+    @Override\n+    public Object booleanShape(BooleanShape shape) {\n+        return true;\n+    }\n+\n+    @Override\n+    public Object byteShape(ByteShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object shortShape(ShortShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object integerShape(IntegerShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object longShape(LongShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object floatShape(FloatShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object doubleShape(DoubleShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object bigIntegerShape(BigIntegerShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object bigDecimalShape(BigDecimalShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object documentShape(DocumentShape shape) {\n+        return LiteralExpression.ANY;\n+    }\n+\n+    @Override\n+    public Object stringShape(StringShape shape) {\n+        // Create a random string that does not exceed or go under the length trait.\n+        int chars = computeLength(shape);\n+\n+        // Fill a string with \"a\"'s up to chars.\n+        return new String(new char[chars]).replace(\"\\0\", \"a\");\n+    }\n+\n+    @Override\n+    public Object listShape(ListShape shape) {\n+        return createListOrSet(shape, shape.getMember());\n+    }\n+\n+    @Override\n+    public Object setShape(SetShape shape) {\n+        return createListOrSet(shape, shape.getMember());\n+    }\n+\n+    private Object createListOrSet(Shape shape, MemberShape member) {\n+        return withCopiedVisitors(() -> {\n+            int size = computeLength(shape);\n+            List<Object> result = new ArrayList<>(size);\n+            Object memberValue = member.accept(this);\n+            if (memberValue != null) {\n+                for (int i = 0; i < size; i++) {\n+                    result.add(memberValue);\n+                }\n+            }\n+            return result;\n+        });\n+    }\n+\n+    // Visits members and mutates a copy of the current set of\n+    // visited shapes rather than a shared set. This a shape to\n+    // be used multiple times in the closure of a single shape\n+    // without causing the reuse of the shape to always be\n+    // assume to be a recursive type.", "originalCommit": "75058e88706292c20f675bfd5b2f86228e144e8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkxNjE1Mw==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r518916153", "bodyText": "range trait*", "author": "kstich", "createdAt": "2020-11-06T18:02:29Z", "path": "smithy-waiters/src/main/java/software/amazon/smithy/waiters/ModelRuntimeTypeGenerator.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.waiters;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.shapes.BigDecimalShape;\n+import software.amazon.smithy.model.shapes.BigIntegerShape;\n+import software.amazon.smithy.model.shapes.BlobShape;\n+import software.amazon.smithy.model.shapes.BooleanShape;\n+import software.amazon.smithy.model.shapes.ByteShape;\n+import software.amazon.smithy.model.shapes.DocumentShape;\n+import software.amazon.smithy.model.shapes.DoubleShape;\n+import software.amazon.smithy.model.shapes.FloatShape;\n+import software.amazon.smithy.model.shapes.IntegerShape;\n+import software.amazon.smithy.model.shapes.ListShape;\n+import software.amazon.smithy.model.shapes.LongShape;\n+import software.amazon.smithy.model.shapes.MapShape;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.OperationShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.ServiceShape;\n+import software.amazon.smithy.model.shapes.SetShape;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.shapes.ShapeVisitor;\n+import software.amazon.smithy.model.shapes.ShortShape;\n+import software.amazon.smithy.model.shapes.StringShape;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.shapes.TimestampShape;\n+import software.amazon.smithy.model.shapes.UnionShape;\n+import software.amazon.smithy.model.traits.LengthTrait;\n+import software.amazon.smithy.model.traits.RangeTrait;\n+\n+/**\n+ * Generates fake data from a modeled shape for static JMESPath analysis.\n+ */\n+final class ModelRuntimeTypeGenerator implements ShapeVisitor<Object> {\n+\n+    private final Model model;\n+    private Set<MemberShape> visited = new HashSet<>();\n+\n+    ModelRuntimeTypeGenerator(Model model) {\n+        this.model = model;\n+    }\n+\n+    @Override\n+    public Object blobShape(BlobShape shape) {\n+        return \"blob\";\n+    }\n+\n+    @Override\n+    public Object booleanShape(BooleanShape shape) {\n+        return true;\n+    }\n+\n+    @Override\n+    public Object byteShape(ByteShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object shortShape(ShortShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object integerShape(IntegerShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object longShape(LongShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object floatShape(FloatShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object doubleShape(DoubleShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object bigIntegerShape(BigIntegerShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object bigDecimalShape(BigDecimalShape shape) {\n+        return computeRange(shape);\n+    }\n+\n+    @Override\n+    public Object documentShape(DocumentShape shape) {\n+        return LiteralExpression.ANY;\n+    }\n+\n+    @Override\n+    public Object stringShape(StringShape shape) {\n+        // Create a random string that does not exceed or go under the length trait.\n+        int chars = computeLength(shape);\n+\n+        // Fill a string with \"a\"'s up to chars.\n+        return new String(new char[chars]).replace(\"\\0\", \"a\");\n+    }\n+\n+    @Override\n+    public Object listShape(ListShape shape) {\n+        return createListOrSet(shape, shape.getMember());\n+    }\n+\n+    @Override\n+    public Object setShape(SetShape shape) {\n+        return createListOrSet(shape, shape.getMember());\n+    }\n+\n+    private Object createListOrSet(Shape shape, MemberShape member) {\n+        return withCopiedVisitors(() -> {\n+            int size = computeLength(shape);\n+            List<Object> result = new ArrayList<>(size);\n+            Object memberValue = member.accept(this);\n+            if (memberValue != null) {\n+                for (int i = 0; i < size; i++) {\n+                    result.add(memberValue);\n+                }\n+            }\n+            return result;\n+        });\n+    }\n+\n+    // Visits members and mutates a copy of the current set of\n+    // visited shapes rather than a shared set. This a shape to\n+    // be used multiple times in the closure of a single shape\n+    // without causing the reuse of the shape to always be\n+    // assume to be a recursive type.\n+    private Object withCopiedVisitors(Supplier<Object> supplier) {\n+        // Account for recursive shapes at the current\n+        Set<MemberShape> visitedCopy = new HashSet<>(visited);\n+        Object result = supplier.get();\n+        visited = visitedCopy;\n+        return result;\n+    }\n+\n+    @Override\n+    public Object mapShape(MapShape shape) {\n+        return withCopiedVisitors(() -> {\n+            int size = computeLength(shape);\n+            Map<String, Object> result = new HashMap<>();\n+            String key = (String) shape.getKey().accept(this);\n+            Object memberValue = shape.getValue().accept(this);\n+            for (int i = 0; i < size; i++) {\n+                result.put(key + i, memberValue);\n+            }\n+            return result;\n+        });\n+    }\n+\n+    @Override\n+    public Object structureShape(StructureShape shape) {\n+        return structureOrUnion(shape);\n+    }\n+\n+    @Override\n+    public Object unionShape(UnionShape shape) {\n+        return structureOrUnion(shape);\n+    }\n+\n+    private Object structureOrUnion(Shape shape) {\n+        return withCopiedVisitors(() -> {\n+            Map<String, Object> result = new LinkedHashMap<>();\n+            for (MemberShape member : shape.members()) {\n+                Object memberValue = member.accept(this);\n+                result.put(member.getMemberName(), memberValue);\n+            }\n+            return result;\n+        });\n+    }\n+\n+    @Override\n+    public Object memberShape(MemberShape shape) {\n+        // Account for recursive shapes.\n+        // A false return value means it was in the set.\n+        if (!visited.add(shape)) {\n+            return LiteralExpression.ANY;\n+        }\n+\n+        return model.getShape(shape.getTarget())\n+                .map(target -> target.accept(this))\n+                // Rather than fail on broken models during waiter validation,\n+                // return an ANY to get *some* validation.\n+                .orElse(LiteralExpression.ANY);\n+    }\n+\n+    @Override\n+    public Object timestampShape(TimestampShape shape) {\n+        return LiteralExpression.NUMBER;\n+    }\n+\n+    @Override\n+    public Object operationShape(OperationShape shape) {\n+        throw new UnsupportedOperationException(shape.toString());\n+    }\n+\n+    @Override\n+    public Object resourceShape(ResourceShape shape) {\n+        throw new UnsupportedOperationException(shape.toString());\n+    }\n+\n+    @Override\n+    public Object serviceShape(ServiceShape shape) {\n+        throw new UnsupportedOperationException(shape.toString());\n+    }\n+\n+    private int computeLength(Shape shape) {\n+        // Create a random string that does not exceed or go under the length trait.\n+        int chars = 2;\n+\n+        if (shape.hasTrait(LengthTrait.class)) {\n+            LengthTrait trait = shape.expectTrait(LengthTrait.class);\n+            if (trait.getMin().isPresent()) {\n+                chars = Math.max(chars, trait.getMin().get().intValue());\n+            }\n+            if (trait.getMax().isPresent()) {\n+                chars = Math.min(chars, trait.getMax().get().intValue());\n+            }\n+        }\n+\n+        return chars;\n+    }\n+\n+    private double computeRange(Shape shape) {\n+        // Create a random string that does not exceed or go under the length trait.", "originalCommit": "75058e88706292c20f675bfd5b2f86228e144e8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkyMTMzNw==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r518921337", "bodyText": "There are a chunk of ListPathMatcher and ListPathComparator references across a few files that don't map to any code, were these renamed and not updated? Are there any related pluralizations that got left behind?", "author": "kstich", "createdAt": "2020-11-06T18:12:45Z", "path": "smithy-waiters/src/main/java/software/amazon/smithy/waiters/PathComparator.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.waiters;\n+\n+import software.amazon.smithy.model.node.ExpectationNotMetException;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.ToNode;\n+\n+/**\n+ * Defines a comparison to perform in a ListPathMatcher.", "originalCommit": "75058e88706292c20f675bfd5b2f86228e144e8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAxOTU5Ng==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r519019596", "bodyText": "Weird! IntelliJ got overzealous with it's refactoring. Good catch. I fixed em all.", "author": "mtdowling", "createdAt": "2020-11-06T21:42:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkyMTMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkzNDg4MQ==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r518934881", "bodyText": "This default value is indicated as 120 in the other locations (code, spec, tests.)", "author": "kstich", "createdAt": "2020-11-06T18:38:58Z", "path": "smithy-waiters/src/main/resources/META-INF/smithy/waiters.smithy", "diffHunk": "@@ -0,0 +1,153 @@\n+namespace smithy.waiters\n+\n+/// Indicates that an operation has various named \"waiters\" that can be used\n+/// to poll a resource until it enters a desired state.\n+@trait(selector: \"operation :not(-[input, output]-> structure > member > union[trait|streaming])\")\n+@length(min: 1)\n+map waitable {\n+    key: WaiterName,\n+    value: Waiter,\n+}\n+\n+@pattern(\"^[A-Z]+[A-Za-z0-9]*$\")\n+string WaiterName\n+\n+/// Defines an individual operation waiter.\n+@private\n+structure Waiter {\n+    /// Documentation about the waiter. Can use CommonMark.\n+    documentation: String,\n+\n+    /// An ordered array of acceptors to check after executing an operation.\n+    @required\n+    acceptors: Acceptors,\n+\n+    /// The minimum amount of time in seconds to delay between each retry.\n+    /// This value defaults to 2 if not specified. If specified, this value\n+    /// MUST be greater than or equal to 1 and less than or equal to\n+    /// `maxDelay`.\n+    minDelay: WaiterDelay,\n+\n+    /// The maximum amount of time in seconds to delay between each retry.\n+    /// This value defaults to 256 if not specified (or, 4 minutes and 16", "originalCommit": "75058e88706292c20f675bfd5b2f86228e144e8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk2NTI4Nw==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r518965287", "bodyText": "I think these checks are handled in model loading now.", "author": "kstich", "createdAt": "2020-11-06T19:41:52Z", "path": "smithy-waiters/src/main/java/software/amazon/smithy/waiters/Acceptor.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.waiters;\n+\n+import java.util.Objects;\n+import java.util.Set;\n+import software.amazon.smithy.model.node.ExpectationNotMetException;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.ToNode;\n+import software.amazon.smithy.utils.SetUtils;\n+\n+/**\n+ * Represents an acceptor in a waiter's state machine.\n+ */\n+public final class Acceptor implements ToNode {\n+\n+    private static final String STATE = \"state\";\n+    private static final String MATCHER = \"matcher\";\n+    private static final Set<String> KEYS = SetUtils.of(STATE, MATCHER);\n+\n+    private final AcceptorState state;\n+    private final Matcher<?> matcher;\n+\n+    /**\n+     * @param state State the acceptor transitions to when matched.\n+     * @param matcher The matcher to match against.\n+     */\n+    public Acceptor(AcceptorState state, Matcher<?> matcher) {\n+        this.state = state;\n+        this.matcher = matcher;\n+    }\n+\n+    /**\n+     * Gets the state to transition to if matched.\n+     *\n+     * @return Acceptor state to transition to.\n+     */\n+    public AcceptorState getState() {\n+        return state;\n+    }\n+\n+    /**\n+     * Gets the matcher used to test if the acceptor.\n+     *\n+     * @return Returns the matcher.\n+     */\n+    public Matcher<?> getMatcher() {\n+        return matcher;\n+    }\n+\n+    /**\n+     * Creates an Acceptor from a {@link Node}.\n+     *\n+     * @param node Node to create the Acceptor from.\n+     * @return Returns the created Acceptor.\n+     * @throws ExpectationNotMetException if the given Node is invalid.\n+     */\n+    public static Acceptor fromNode(Node node) {\n+        ObjectNode value = node.expectObjectNode().warnIfAdditionalProperties(KEYS);", "originalCommit": "75058e88706292c20f675bfd5b2f86228e144e8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAyMDI3OA==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r519020278", "bodyText": "I don't think they are actually. In order for model loading to check these, the traits would need to retain all unknown properties, which most don't. That's because first the model is loaded and deserialized into traits, then the traits are converted into Nodes, and then those are checked against the model.", "author": "mtdowling", "createdAt": "2020-11-06T21:43:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk2NTI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3MjQzNQ==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r518972435", "bodyText": "created*", "author": "kstich", "createdAt": "2020-11-06T19:57:02Z", "path": "docs/source/1.0/spec/waiters.rst", "diffHunk": "@@ -0,0 +1,783 @@\n+.. _waiters:\n+\n+=======\n+Waiters\n+=======\n+\n+Waiters are a client-side abstraction used to poll a resource until a desired\n+state is reached, or until it is determined that the resource will never\n+enter into the desired state. This is a common task when working with\n+services that are eventually consistent like Amazon S3 or services that\n+asynchronously create resources like Amazon EC2. Writing logic to", "originalCommit": "75058e88706292c20f675bfd5b2f86228e144e8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAyMDY4Nw==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r519020687", "bodyText": "I think create is correct here.", "author": "mtdowling", "createdAt": "2020-11-06T21:44:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3MjQzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAyMTI3OA==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r519021278", "bodyText": "It is, I misread \"that\" as \"with\".", "author": "kstich", "createdAt": "2020-11-06T21:46:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3MjQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3NDM4Mg==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r518974382", "bodyText": "These sub-headings aren't consistent with those of all the other traits.", "author": "kstich", "createdAt": "2020-11-06T20:01:10Z", "path": "docs/source/1.0/spec/waiters.rst", "diffHunk": "@@ -0,0 +1,783 @@\n+.. _waiters:\n+\n+=======\n+Waiters\n+=======\n+\n+Waiters are a client-side abstraction used to poll a resource until a desired\n+state is reached, or until it is determined that the resource will never\n+enter into the desired state. This is a common task when working with\n+services that are eventually consistent like Amazon S3 or services that\n+asynchronously create resources like Amazon EC2. Writing logic to\n+continuously poll the status of a resource can be cumbersome and\n+error-prone. The goal of waiters is to move this responsibility out of\n+customer code and onto service teams who know their service best.\n+\n+For example, waiters can be used in code to turn the workflow of waiting\n+for an Amazon EC2 instance to be terminated into something like the\n+following client pseudocode:\n+\n+.. code-block:: java\n+\n+    InstanceTerminatedWaiter waiter = InstanceTerminatedWaiter.builder()\n+            .client(myClient)\n+            .instanceIds(Collections.singletonList(\"i-foo\"))\n+            .totalAllowedWaitTime(10, Duration.MINUTES)\n+            .wait();\n+\n+\n+.. _smithy.waiters#waitable-trait:\n+\n+``smithy.waiters#waitable`` trait\n+=================================\n+\n+Waiters are defined on :ref:`operations <operation>` using the\n+``smithy.waiters#waitable`` trait.\n+\n+Trait summary", "originalCommit": "75058e88706292c20f675bfd5b2f86228e144e8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3NDQzOQ==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r518974439", "bodyText": "Seems redundant.", "author": "kstich", "createdAt": "2020-11-06T20:01:17Z", "path": "docs/source/1.0/spec/waiters.rst", "diffHunk": "@@ -0,0 +1,783 @@\n+.. _waiters:\n+\n+=======\n+Waiters\n+=======\n+\n+Waiters are a client-side abstraction used to poll a resource until a desired\n+state is reached, or until it is determined that the resource will never\n+enter into the desired state. This is a common task when working with\n+services that are eventually consistent like Amazon S3 or services that\n+asynchronously create resources like Amazon EC2. Writing logic to\n+continuously poll the status of a resource can be cumbersome and\n+error-prone. The goal of waiters is to move this responsibility out of\n+customer code and onto service teams who know their service best.\n+\n+For example, waiters can be used in code to turn the workflow of waiting\n+for an Amazon EC2 instance to be terminated into something like the\n+following client pseudocode:\n+\n+.. code-block:: java\n+\n+    InstanceTerminatedWaiter waiter = InstanceTerminatedWaiter.builder()\n+            .client(myClient)\n+            .instanceIds(Collections.singletonList(\"i-foo\"))\n+            .totalAllowedWaitTime(10, Duration.MINUTES)\n+            .wait();\n+\n+\n+.. _smithy.waiters#waitable-trait:\n+\n+``smithy.waiters#waitable`` trait\n+=================================\n+\n+Waiters are defined on :ref:`operations <operation>` using the", "originalCommit": "75058e88706292c20f675bfd5b2f86228e144e8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3NTU0OA==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r518975548", "bodyText": "These descriptions are usually italic, not parenthesized.", "author": "kstich", "createdAt": "2020-11-06T20:03:52Z", "path": "docs/source/1.0/spec/waiters.rst", "diffHunk": "@@ -0,0 +1,783 @@\n+.. _waiters:\n+\n+=======\n+Waiters\n+=======\n+\n+Waiters are a client-side abstraction used to poll a resource until a desired\n+state is reached, or until it is determined that the resource will never\n+enter into the desired state. This is a common task when working with\n+services that are eventually consistent like Amazon S3 or services that\n+asynchronously create resources like Amazon EC2. Writing logic to\n+continuously poll the status of a resource can be cumbersome and\n+error-prone. The goal of waiters is to move this responsibility out of\n+customer code and onto service teams who know their service best.\n+\n+For example, waiters can be used in code to turn the workflow of waiting\n+for an Amazon EC2 instance to be terminated into something like the\n+following client pseudocode:\n+\n+.. code-block:: java\n+\n+    InstanceTerminatedWaiter waiter = InstanceTerminatedWaiter.builder()\n+            .client(myClient)\n+            .instanceIds(Collections.singletonList(\"i-foo\"))\n+            .totalAllowedWaitTime(10, Duration.MINUTES)\n+            .wait();\n+\n+\n+.. _smithy.waiters#waitable-trait:\n+\n+``smithy.waiters#waitable`` trait\n+=================================\n+\n+Waiters are defined on :ref:`operations <operation>` using the\n+``smithy.waiters#waitable`` trait.\n+\n+Trait summary\n+    Indicates that an operation has various named \"waiters\" that can be used\n+    to poll a resource until it enters a desired state.\n+Trait selector\n+    ``operation :not(-[input, output]-> structure > member > union[trait|streaming])``\n+\n+    (Operations that do not use :ref:`event streams <event-streams>` in their input or output)", "originalCommit": "75058e88706292c20f675bfd5b2f86228e144e8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAyMTAxMQ==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r519021011", "bodyText": "You can't do italic :ref:s for some reason, so ... tradeoffs", "author": "mtdowling", "createdAt": "2020-11-06T21:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3NTU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3NTc2Ng==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r518975766", "bodyText": "Should have a use statement.", "author": "kstich", "createdAt": "2020-11-06T20:04:25Z", "path": "docs/source/1.0/spec/waiters.rst", "diffHunk": "@@ -0,0 +1,783 @@\n+.. _waiters:\n+\n+=======\n+Waiters\n+=======\n+\n+Waiters are a client-side abstraction used to poll a resource until a desired\n+state is reached, or until it is determined that the resource will never\n+enter into the desired state. This is a common task when working with\n+services that are eventually consistent like Amazon S3 or services that\n+asynchronously create resources like Amazon EC2. Writing logic to\n+continuously poll the status of a resource can be cumbersome and\n+error-prone. The goal of waiters is to move this responsibility out of\n+customer code and onto service teams who know their service best.\n+\n+For example, waiters can be used in code to turn the workflow of waiting\n+for an Amazon EC2 instance to be terminated into something like the\n+following client pseudocode:\n+\n+.. code-block:: java\n+\n+    InstanceTerminatedWaiter waiter = InstanceTerminatedWaiter.builder()\n+            .client(myClient)\n+            .instanceIds(Collections.singletonList(\"i-foo\"))\n+            .totalAllowedWaitTime(10, Duration.MINUTES)\n+            .wait();\n+\n+\n+.. _smithy.waiters#waitable-trait:\n+\n+``smithy.waiters#waitable`` trait\n+=================================\n+\n+Waiters are defined on :ref:`operations <operation>` using the\n+``smithy.waiters#waitable`` trait.\n+\n+Trait summary\n+    Indicates that an operation has various named \"waiters\" that can be used\n+    to poll a resource until it enters a desired state.\n+Trait selector\n+    ``operation :not(-[input, output]-> structure > member > union[trait|streaming])``\n+\n+    (Operations that do not use :ref:`event streams <event-streams>` in their input or output)\n+Trait value\n+    A ``map`` of :ref:`waiter names <waiter-names>` to\n+    :ref:`Waiter structures <waiter-structure>`.\n+\n+The following example defines a waiter that waits until an Amazon S3 bucket\n+exists:\n+\n+.. code-block:: smithy\n+    :emphasize-lines: 3\n+\n+    namespace com.amazonaws.s3\n+\n+    @waitable(", "originalCommit": "75058e88706292c20f675bfd5b2f86228e144e8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4NDQ3NQ==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r518984475", "bodyText": "Would be helpful to emphasize the and in this.", "author": "kstich", "createdAt": "2020-11-06T20:17:50Z", "path": "docs/source/1.0/spec/waiters.rst", "diffHunk": "@@ -0,0 +1,783 @@\n+.. _waiters:\n+\n+=======\n+Waiters\n+=======\n+\n+Waiters are a client-side abstraction used to poll a resource until a desired\n+state is reached, or until it is determined that the resource will never\n+enter into the desired state. This is a common task when working with\n+services that are eventually consistent like Amazon S3 or services that\n+asynchronously create resources like Amazon EC2. Writing logic to\n+continuously poll the status of a resource can be cumbersome and\n+error-prone. The goal of waiters is to move this responsibility out of\n+customer code and onto service teams who know their service best.\n+\n+For example, waiters can be used in code to turn the workflow of waiting\n+for an Amazon EC2 instance to be terminated into something like the\n+following client pseudocode:\n+\n+.. code-block:: java\n+\n+    InstanceTerminatedWaiter waiter = InstanceTerminatedWaiter.builder()\n+            .client(myClient)\n+            .instanceIds(Collections.singletonList(\"i-foo\"))\n+            .totalAllowedWaitTime(10, Duration.MINUTES)\n+            .wait();\n+\n+\n+.. _smithy.waiters#waitable-trait:\n+\n+``smithy.waiters#waitable`` trait\n+=================================\n+\n+Waiters are defined on :ref:`operations <operation>` using the\n+``smithy.waiters#waitable`` trait.\n+\n+Trait summary\n+    Indicates that an operation has various named \"waiters\" that can be used\n+    to poll a resource until it enters a desired state.\n+Trait selector\n+    ``operation :not(-[input, output]-> structure > member > union[trait|streaming])``\n+\n+    (Operations that do not use :ref:`event streams <event-streams>` in their input or output)\n+Trait value\n+    A ``map`` of :ref:`waiter names <waiter-names>` to\n+    :ref:`Waiter structures <waiter-structure>`.\n+\n+The following example defines a waiter that waits until an Amazon S3 bucket\n+exists:\n+\n+.. code-block:: smithy\n+    :emphasize-lines: 3\n+\n+    namespace com.amazonaws.s3\n+\n+    @waitable(\n+        BucketExists: {\n+            documentation: \"Wait until a bucket exists\",\n+            acceptors: [\n+                {\n+                    state: \"success\",\n+                    matcher: {\n+                        success: true\n+                    }\n+                },\n+                {\n+                    state: \"retry\",\n+                    matcher: {\n+                        errorType: \"NotFound\"\n+                    }\n+                }\n+            ]\n+        }\n+    )\n+    operation HeadBucket {\n+        input: HeadBucketInput,\n+        output: HeadBucketOutput,\n+        errors: [NotFound]\n+    }\n+\n+Applying the steps defined in `Waiter workflow`_ to the above example,\n+a client performs the following steps:\n+\n+1. A ``HeadBucket`` operation is created, given the necessary input\n+   parameters, and sent to the service.\n+2. If the operation completes successfully, the waiter transitions to the\n+   ``success`` state and terminates. This is defined in the first acceptor\n+   of the waiter that uses the ``success`` matcher.\n+3. If the operation encounters an error named ``NotFound``, the waiter\n+   transitions to the ``retry`` state.\n+4. If the operation fails with any other error, the waiter transitions to\n+   the ``failure`` state and terminates.\n+5. The waiter is in the ``retry`` state and continues at step 1 after\n+   delaying with exponential backoff until the total allowed time to wait\n+   is exceeded.\n+\n+\n+.. _waiter-names:\n+\n+Waiter names\n+------------\n+\n+Waiter names MUST be defined using UpperCamelCase and only contain\n+alphanumeric characters. That is, waiters MUST adhere to the following\n+ABNF:\n+\n+.. code-block:: abnf\n+\n+    waiter-name: upper-alpha *(ALPHA / DIGIT)\n+    upper-alpha: %x41-5A ; A-Z\n+\n+.. seealso:: :ref:`waiter-best-practices` for additional best practices\n+    to follow when naming waiters.\n+\n+\n+Waiter workflow\n+===============\n+\n+Implementations MUST require callers to provide the total amount of time\n+they are willing to wait for a waiter to complete. Requiring the caller\n+to set a deadline removes any surprises as to how long a waiter can\n+potentially take to complete.\n+\n+While the total execution time of a waiter is less than the allowed time,\n+waiter implementations perform the following steps:\n+\n+1. Call the operation the :ref:`smithy.waiters#waitable-trait` is attached\n+   to using user-provided input for the operation. Any errors that can be\n+   encountered by the operation must be caught so that they can be inspected.\n+2. If the total time of the waiter exceeds the allowed time, the waiter\n+   SHOULD attempt to cancel any in-progress requests and MUST transition to a\n+   to a terminal ``failure`` state.\n+3. For every :ref:`acceptor <waiter-acceptor>` in the waiter:\n+\n+   1. If the acceptor :ref:`matcher <waiter-matcher>` is a match, transition\n+      to the :ref:`state <waiter-acceptor-state>` of the acceptor.\n+   2. If the acceptor transitions the waiter to the ``retry`` state, then\n+      continue to step 5.\n+   3. Stop waiting if the acceptor transitions the waiter to the ``success``\n+      or ``failure`` state.\n+\n+4. If none of the acceptors are matched and an error was encountered while", "originalCommit": "75058e88706292c20f675bfd5b2f86228e144e8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4NTQ4Ng==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r518985486", "bodyText": "number of*", "author": "kstich", "createdAt": "2020-11-06T20:20:12Z", "path": "docs/source/1.0/spec/waiters.rst", "diffHunk": "@@ -0,0 +1,783 @@\n+.. _waiters:\n+\n+=======\n+Waiters\n+=======\n+\n+Waiters are a client-side abstraction used to poll a resource until a desired\n+state is reached, or until it is determined that the resource will never\n+enter into the desired state. This is a common task when working with\n+services that are eventually consistent like Amazon S3 or services that\n+asynchronously create resources like Amazon EC2. Writing logic to\n+continuously poll the status of a resource can be cumbersome and\n+error-prone. The goal of waiters is to move this responsibility out of\n+customer code and onto service teams who know their service best.\n+\n+For example, waiters can be used in code to turn the workflow of waiting\n+for an Amazon EC2 instance to be terminated into something like the\n+following client pseudocode:\n+\n+.. code-block:: java\n+\n+    InstanceTerminatedWaiter waiter = InstanceTerminatedWaiter.builder()\n+            .client(myClient)\n+            .instanceIds(Collections.singletonList(\"i-foo\"))\n+            .totalAllowedWaitTime(10, Duration.MINUTES)\n+            .wait();\n+\n+\n+.. _smithy.waiters#waitable-trait:\n+\n+``smithy.waiters#waitable`` trait\n+=================================\n+\n+Waiters are defined on :ref:`operations <operation>` using the\n+``smithy.waiters#waitable`` trait.\n+\n+Trait summary\n+    Indicates that an operation has various named \"waiters\" that can be used\n+    to poll a resource until it enters a desired state.\n+Trait selector\n+    ``operation :not(-[input, output]-> structure > member > union[trait|streaming])``\n+\n+    (Operations that do not use :ref:`event streams <event-streams>` in their input or output)\n+Trait value\n+    A ``map`` of :ref:`waiter names <waiter-names>` to\n+    :ref:`Waiter structures <waiter-structure>`.\n+\n+The following example defines a waiter that waits until an Amazon S3 bucket\n+exists:\n+\n+.. code-block:: smithy\n+    :emphasize-lines: 3\n+\n+    namespace com.amazonaws.s3\n+\n+    @waitable(\n+        BucketExists: {\n+            documentation: \"Wait until a bucket exists\",\n+            acceptors: [\n+                {\n+                    state: \"success\",\n+                    matcher: {\n+                        success: true\n+                    }\n+                },\n+                {\n+                    state: \"retry\",\n+                    matcher: {\n+                        errorType: \"NotFound\"\n+                    }\n+                }\n+            ]\n+        }\n+    )\n+    operation HeadBucket {\n+        input: HeadBucketInput,\n+        output: HeadBucketOutput,\n+        errors: [NotFound]\n+    }\n+\n+Applying the steps defined in `Waiter workflow`_ to the above example,\n+a client performs the following steps:\n+\n+1. A ``HeadBucket`` operation is created, given the necessary input\n+   parameters, and sent to the service.\n+2. If the operation completes successfully, the waiter transitions to the\n+   ``success`` state and terminates. This is defined in the first acceptor\n+   of the waiter that uses the ``success`` matcher.\n+3. If the operation encounters an error named ``NotFound``, the waiter\n+   transitions to the ``retry`` state.\n+4. If the operation fails with any other error, the waiter transitions to\n+   the ``failure`` state and terminates.\n+5. The waiter is in the ``retry`` state and continues at step 1 after\n+   delaying with exponential backoff until the total allowed time to wait\n+   is exceeded.\n+\n+\n+.. _waiter-names:\n+\n+Waiter names\n+------------\n+\n+Waiter names MUST be defined using UpperCamelCase and only contain\n+alphanumeric characters. That is, waiters MUST adhere to the following\n+ABNF:\n+\n+.. code-block:: abnf\n+\n+    waiter-name: upper-alpha *(ALPHA / DIGIT)\n+    upper-alpha: %x41-5A ; A-Z\n+\n+.. seealso:: :ref:`waiter-best-practices` for additional best practices\n+    to follow when naming waiters.\n+\n+\n+Waiter workflow\n+===============\n+\n+Implementations MUST require callers to provide the total amount of time\n+they are willing to wait for a waiter to complete. Requiring the caller\n+to set a deadline removes any surprises as to how long a waiter can\n+potentially take to complete.\n+\n+While the total execution time of a waiter is less than the allowed time,\n+waiter implementations perform the following steps:\n+\n+1. Call the operation the :ref:`smithy.waiters#waitable-trait` is attached\n+   to using user-provided input for the operation. Any errors that can be\n+   encountered by the operation must be caught so that they can be inspected.\n+2. If the total time of the waiter exceeds the allowed time, the waiter\n+   SHOULD attempt to cancel any in-progress requests and MUST transition to a\n+   to a terminal ``failure`` state.\n+3. For every :ref:`acceptor <waiter-acceptor>` in the waiter:\n+\n+   1. If the acceptor :ref:`matcher <waiter-matcher>` is a match, transition\n+      to the :ref:`state <waiter-acceptor-state>` of the acceptor.\n+   2. If the acceptor transitions the waiter to the ``retry`` state, then\n+      continue to step 5.\n+   3. Stop waiting if the acceptor transitions the waiter to the ``success``\n+      or ``failure`` state.\n+\n+4. If none of the acceptors are matched and an error was encountered while\n+   calling the operation, then transition to the ``failure`` state and stop\n+   waiting.\n+5. Transition the waiter to the ``retry`` state, follow the process\n+   described in :ref:`waiter-retries`, and continue to step 1.\n+\n+\n+.. _waiter-retries:\n+\n+Waiter retries\n+--------------\n+\n+Waiter implementations MUST delay for a period of time before attempting a\n+retry. The amount of time a waiter delays between retries is computed using\n+`exponential backoff`_ through the following algorithm:\n+\n+* Let ``attempt`` be the number retry attempts.", "originalCommit": "75058e88706292c20f675bfd5b2f86228e144e8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk5MjQ2Mg==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r518992462", "bodyText": "This restriction should be rephrased to be a MUST like for output.", "author": "kstich", "createdAt": "2020-11-06T20:36:51Z", "path": "docs/source/1.0/spec/waiters.rst", "diffHunk": "@@ -0,0 +1,783 @@\n+.. _waiters:\n+\n+=======\n+Waiters\n+=======\n+\n+Waiters are a client-side abstraction used to poll a resource until a desired\n+state is reached, or until it is determined that the resource will never\n+enter into the desired state. This is a common task when working with\n+services that are eventually consistent like Amazon S3 or services that\n+asynchronously create resources like Amazon EC2. Writing logic to\n+continuously poll the status of a resource can be cumbersome and\n+error-prone. The goal of waiters is to move this responsibility out of\n+customer code and onto service teams who know their service best.\n+\n+For example, waiters can be used in code to turn the workflow of waiting\n+for an Amazon EC2 instance to be terminated into something like the\n+following client pseudocode:\n+\n+.. code-block:: java\n+\n+    InstanceTerminatedWaiter waiter = InstanceTerminatedWaiter.builder()\n+            .client(myClient)\n+            .instanceIds(Collections.singletonList(\"i-foo\"))\n+            .totalAllowedWaitTime(10, Duration.MINUTES)\n+            .wait();\n+\n+\n+.. _smithy.waiters#waitable-trait:\n+\n+``smithy.waiters#waitable`` trait\n+=================================\n+\n+Waiters are defined on :ref:`operations <operation>` using the\n+``smithy.waiters#waitable`` trait.\n+\n+Trait summary\n+    Indicates that an operation has various named \"waiters\" that can be used\n+    to poll a resource until it enters a desired state.\n+Trait selector\n+    ``operation :not(-[input, output]-> structure > member > union[trait|streaming])``\n+\n+    (Operations that do not use :ref:`event streams <event-streams>` in their input or output)\n+Trait value\n+    A ``map`` of :ref:`waiter names <waiter-names>` to\n+    :ref:`Waiter structures <waiter-structure>`.\n+\n+The following example defines a waiter that waits until an Amazon S3 bucket\n+exists:\n+\n+.. code-block:: smithy\n+    :emphasize-lines: 3\n+\n+    namespace com.amazonaws.s3\n+\n+    @waitable(\n+        BucketExists: {\n+            documentation: \"Wait until a bucket exists\",\n+            acceptors: [\n+                {\n+                    state: \"success\",\n+                    matcher: {\n+                        success: true\n+                    }\n+                },\n+                {\n+                    state: \"retry\",\n+                    matcher: {\n+                        errorType: \"NotFound\"\n+                    }\n+                }\n+            ]\n+        }\n+    )\n+    operation HeadBucket {\n+        input: HeadBucketInput,\n+        output: HeadBucketOutput,\n+        errors: [NotFound]\n+    }\n+\n+Applying the steps defined in `Waiter workflow`_ to the above example,\n+a client performs the following steps:\n+\n+1. A ``HeadBucket`` operation is created, given the necessary input\n+   parameters, and sent to the service.\n+2. If the operation completes successfully, the waiter transitions to the\n+   ``success`` state and terminates. This is defined in the first acceptor\n+   of the waiter that uses the ``success`` matcher.\n+3. If the operation encounters an error named ``NotFound``, the waiter\n+   transitions to the ``retry`` state.\n+4. If the operation fails with any other error, the waiter transitions to\n+   the ``failure`` state and terminates.\n+5. The waiter is in the ``retry`` state and continues at step 1 after\n+   delaying with exponential backoff until the total allowed time to wait\n+   is exceeded.\n+\n+\n+.. _waiter-names:\n+\n+Waiter names\n+------------\n+\n+Waiter names MUST be defined using UpperCamelCase and only contain\n+alphanumeric characters. That is, waiters MUST adhere to the following\n+ABNF:\n+\n+.. code-block:: abnf\n+\n+    waiter-name: upper-alpha *(ALPHA / DIGIT)\n+    upper-alpha: %x41-5A ; A-Z\n+\n+.. seealso:: :ref:`waiter-best-practices` for additional best practices\n+    to follow when naming waiters.\n+\n+\n+Waiter workflow\n+===============\n+\n+Implementations MUST require callers to provide the total amount of time\n+they are willing to wait for a waiter to complete. Requiring the caller\n+to set a deadline removes any surprises as to how long a waiter can\n+potentially take to complete.\n+\n+While the total execution time of a waiter is less than the allowed time,\n+waiter implementations perform the following steps:\n+\n+1. Call the operation the :ref:`smithy.waiters#waitable-trait` is attached\n+   to using user-provided input for the operation. Any errors that can be\n+   encountered by the operation must be caught so that they can be inspected.\n+2. If the total time of the waiter exceeds the allowed time, the waiter\n+   SHOULD attempt to cancel any in-progress requests and MUST transition to a\n+   to a terminal ``failure`` state.\n+3. For every :ref:`acceptor <waiter-acceptor>` in the waiter:\n+\n+   1. If the acceptor :ref:`matcher <waiter-matcher>` is a match, transition\n+      to the :ref:`state <waiter-acceptor-state>` of the acceptor.\n+   2. If the acceptor transitions the waiter to the ``retry`` state, then\n+      continue to step 5.\n+   3. Stop waiting if the acceptor transitions the waiter to the ``success``\n+      or ``failure`` state.\n+\n+4. If none of the acceptors are matched and an error was encountered while\n+   calling the operation, then transition to the ``failure`` state and stop\n+   waiting.\n+5. Transition the waiter to the ``retry`` state, follow the process\n+   described in :ref:`waiter-retries`, and continue to step 1.\n+\n+\n+.. _waiter-retries:\n+\n+Waiter retries\n+--------------\n+\n+Waiter implementations MUST delay for a period of time before attempting a\n+retry. The amount of time a waiter delays between retries is computed using\n+`exponential backoff`_ through the following algorithm:\n+\n+* Let ``attempt`` be the number retry attempts.\n+* Let ``minDelay`` be the minimum amount of time to delay between retries in\n+  seconds, specified by the ``minDelay`` property of a\n+  :ref:`waiter <waiter-structure>` with a default of 2.\n+* Let ``maxDelay`` be the maximum amount of time to delay between retries in\n+  seconds, specified by the ``maxDelay`` property of a\n+  :ref:`waiter <waiter-structure>` with a default of 120.\n+* Let ``min`` be a function that returns the smaller of two integers.\n+* Let ``max`` be a function that returns the larger of two integers.\n+* Let ``maxWaitTime`` be the amount of time in seconds a user is willing to\n+  wait for a waiter to complete.\n+* Let ``remainingTime`` be the amount of seconds remaining before the waiter\n+  has exceeded ``maxWaitTime``.\n+\n+.. code-block:: python\n+\n+    delay = min(maxDelay, minDelay * 2 ** (attempt - 1))\n+\n+    if remainingTime - delay <= minDelay:\n+        delay = remainingTime - minDelay\n+\n+If the computed ``delay`` subtracted from ``remainingTime`` is less than\n+or equal to ``minDelay``, then set ``delay`` to ``remainingTime`` minus\n+``minDelay`` and perform one last retry. This prevents a waiter from waiting\n+needlessly only to exceed ``maxWaitTime`` before issuing a final request.\n+\n+Using the default ``minDelay`` of 2, ``maxDelay`` of 120, a ``maxWaitTime``\n+of 300 (or 5 minutes), and assuming that requests complete in 0 seconds\n+(for example purposes only), delays are computed as followed:\n+\n+.. list-table::\n+    :header-rows: 1\n+\n+    * - Retry ``attempt``\n+      - ``delay``\n+      - Cumulative time\n+      - ``remainingTime``\n+    * - 1\n+      - 2\n+      - 2\n+      - 298\n+    * - 2\n+      - 4\n+      - 6\n+      - 294\n+    * - 3\n+      - 8\n+      - 14\n+      - 286\n+    * - 4\n+      - 16\n+      - 30\n+      - 270\n+    * - 5\n+      - 32\n+      - 62\n+      - 238\n+    * - 6\n+      - 64\n+      - 126\n+      - 174\n+    * - 7\n+      - 120\n+      - 254\n+      - 46\n+    * - 8 (last attempt)\n+      - 44\n+      - 298\n+      - N/A\n+\n+\n+.. _waiter-structure:\n+\n+Waiter structure\n+================\n+\n+A *waiter* defines a set of acceptors that are used to check if a resource\n+has entered into a desired state.\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 25 65\n+\n+    * - Property\n+      - Type\n+      - Description\n+    * - documentation\n+      - ``string``\n+      - Documentation about the waiter defined using CommonMark_.\n+    * - acceptors\n+      - ``[`` :ref:`Acceptor structure <waiter-acceptor>` ``]``\n+      - **Required**. An ordered array of acceptors to check after executing\n+        an operation. The list of ``acceptors`` MUST contain at least one\n+        acceptor with a ``success`` state transition.\n+    * - minDelay\n+      - ``integer``\n+      - The minimum amount of time in seconds to delay between each retry.\n+        This value defaults to ``2`` if not specified. If specified, this\n+        value MUST be greater than or equal to 1 and less than or equal to\n+        ``maxDelay``.\n+    * - maxDelay\n+      - ``integer``\n+      - The maximum amount of time in seconds to delay between each retry.\n+        This value defaults to ``120`` if not specified (2 minutes). If\n+        specified, this value MUST be greater than or equal to 1.\n+\n+\n+.. _waiter-acceptor:\n+\n+Acceptor structure\n+==================\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 25 65\n+\n+    * - Property\n+      - Type\n+      - Description\n+    * - state\n+      - ``string``\n+      - **Required**. The state the acceptor transitions to when matched. The\n+        string value MUST be a valid :ref:`AcceptorState enum <waiter-acceptor-state>`.\n+    * - matcher\n+      - :ref:`Matcher structure <waiter-matcher>`\n+      - **Required.** The matcher used to test if the resource is in a state\n+        that matches the requirements needed for a state transition.\n+\n+\n+.. _waiter-acceptor-state:\n+\n+AcceptorState enum\n+==================\n+\n+Acceptors cause a waiter to transition into one of the following states:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 20 80\n+\n+    * - Name\n+      - Description\n+    * - success\n+      - The waiter successfully finished waiting. This is a terminal state\n+        that causes the waiter to stop.\n+    * - failure\n+      - The waiter failed to enter into the desired state. This is a terminal\n+        state that causes the waiter to stop.\n+    * - retry\n+      - The waiter will retry the operation. This state transition is\n+        implicit if no accepter causes a state transition.\n+\n+\n+.. _waiter-matcher:\n+\n+Matcher union\n+=============\n+\n+A *matcher* defines how an acceptor determines if it matches the current\n+state of a resource. A matcher is a union where exactly one of the following\n+members MUST be set:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 25 65\n+\n+    * - Property\n+      - Type\n+      - Description\n+    * - output\n+      - :ref:`PathMatcher structure <waiter-PathMatcher>`\n+      - Matches on the successful output of an operation using a\n+        JMESPath_ expression. This matcher MUST NOT be used on operations\n+        with no output. This matcher is checked only if an operation\n+        completes successfully.\n+    * - inputOutput\n+      - :ref:`PathMatcher structure <waiter-PathMatcher>`\n+      - Matches on both the input and output of an operation using a JMESPath_\n+        expression. Input parameters are available through the top-level\n+        ``input`` field, and output data is available through the top-level\n+        ``output`` field. This matcher can only be used on operations that", "originalCommit": "75058e88706292c20f675bfd5b2f86228e144e8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk5NjcwMg==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r518996702", "bodyText": "Doesn't say anything about it being equal to the expected value.", "author": "kstich", "createdAt": "2020-11-06T20:46:40Z", "path": "docs/source/1.0/spec/waiters.rst", "diffHunk": "@@ -0,0 +1,783 @@\n+.. _waiters:\n+\n+=======\n+Waiters\n+=======\n+\n+Waiters are a client-side abstraction used to poll a resource until a desired\n+state is reached, or until it is determined that the resource will never\n+enter into the desired state. This is a common task when working with\n+services that are eventually consistent like Amazon S3 or services that\n+asynchronously create resources like Amazon EC2. Writing logic to\n+continuously poll the status of a resource can be cumbersome and\n+error-prone. The goal of waiters is to move this responsibility out of\n+customer code and onto service teams who know their service best.\n+\n+For example, waiters can be used in code to turn the workflow of waiting\n+for an Amazon EC2 instance to be terminated into something like the\n+following client pseudocode:\n+\n+.. code-block:: java\n+\n+    InstanceTerminatedWaiter waiter = InstanceTerminatedWaiter.builder()\n+            .client(myClient)\n+            .instanceIds(Collections.singletonList(\"i-foo\"))\n+            .totalAllowedWaitTime(10, Duration.MINUTES)\n+            .wait();\n+\n+\n+.. _smithy.waiters#waitable-trait:\n+\n+``smithy.waiters#waitable`` trait\n+=================================\n+\n+Waiters are defined on :ref:`operations <operation>` using the\n+``smithy.waiters#waitable`` trait.\n+\n+Trait summary\n+    Indicates that an operation has various named \"waiters\" that can be used\n+    to poll a resource until it enters a desired state.\n+Trait selector\n+    ``operation :not(-[input, output]-> structure > member > union[trait|streaming])``\n+\n+    (Operations that do not use :ref:`event streams <event-streams>` in their input or output)\n+Trait value\n+    A ``map`` of :ref:`waiter names <waiter-names>` to\n+    :ref:`Waiter structures <waiter-structure>`.\n+\n+The following example defines a waiter that waits until an Amazon S3 bucket\n+exists:\n+\n+.. code-block:: smithy\n+    :emphasize-lines: 3\n+\n+    namespace com.amazonaws.s3\n+\n+    @waitable(\n+        BucketExists: {\n+            documentation: \"Wait until a bucket exists\",\n+            acceptors: [\n+                {\n+                    state: \"success\",\n+                    matcher: {\n+                        success: true\n+                    }\n+                },\n+                {\n+                    state: \"retry\",\n+                    matcher: {\n+                        errorType: \"NotFound\"\n+                    }\n+                }\n+            ]\n+        }\n+    )\n+    operation HeadBucket {\n+        input: HeadBucketInput,\n+        output: HeadBucketOutput,\n+        errors: [NotFound]\n+    }\n+\n+Applying the steps defined in `Waiter workflow`_ to the above example,\n+a client performs the following steps:\n+\n+1. A ``HeadBucket`` operation is created, given the necessary input\n+   parameters, and sent to the service.\n+2. If the operation completes successfully, the waiter transitions to the\n+   ``success`` state and terminates. This is defined in the first acceptor\n+   of the waiter that uses the ``success`` matcher.\n+3. If the operation encounters an error named ``NotFound``, the waiter\n+   transitions to the ``retry`` state.\n+4. If the operation fails with any other error, the waiter transitions to\n+   the ``failure`` state and terminates.\n+5. The waiter is in the ``retry`` state and continues at step 1 after\n+   delaying with exponential backoff until the total allowed time to wait\n+   is exceeded.\n+\n+\n+.. _waiter-names:\n+\n+Waiter names\n+------------\n+\n+Waiter names MUST be defined using UpperCamelCase and only contain\n+alphanumeric characters. That is, waiters MUST adhere to the following\n+ABNF:\n+\n+.. code-block:: abnf\n+\n+    waiter-name: upper-alpha *(ALPHA / DIGIT)\n+    upper-alpha: %x41-5A ; A-Z\n+\n+.. seealso:: :ref:`waiter-best-practices` for additional best practices\n+    to follow when naming waiters.\n+\n+\n+Waiter workflow\n+===============\n+\n+Implementations MUST require callers to provide the total amount of time\n+they are willing to wait for a waiter to complete. Requiring the caller\n+to set a deadline removes any surprises as to how long a waiter can\n+potentially take to complete.\n+\n+While the total execution time of a waiter is less than the allowed time,\n+waiter implementations perform the following steps:\n+\n+1. Call the operation the :ref:`smithy.waiters#waitable-trait` is attached\n+   to using user-provided input for the operation. Any errors that can be\n+   encountered by the operation must be caught so that they can be inspected.\n+2. If the total time of the waiter exceeds the allowed time, the waiter\n+   SHOULD attempt to cancel any in-progress requests and MUST transition to a\n+   to a terminal ``failure`` state.\n+3. For every :ref:`acceptor <waiter-acceptor>` in the waiter:\n+\n+   1. If the acceptor :ref:`matcher <waiter-matcher>` is a match, transition\n+      to the :ref:`state <waiter-acceptor-state>` of the acceptor.\n+   2. If the acceptor transitions the waiter to the ``retry`` state, then\n+      continue to step 5.\n+   3. Stop waiting if the acceptor transitions the waiter to the ``success``\n+      or ``failure`` state.\n+\n+4. If none of the acceptors are matched and an error was encountered while\n+   calling the operation, then transition to the ``failure`` state and stop\n+   waiting.\n+5. Transition the waiter to the ``retry`` state, follow the process\n+   described in :ref:`waiter-retries`, and continue to step 1.\n+\n+\n+.. _waiter-retries:\n+\n+Waiter retries\n+--------------\n+\n+Waiter implementations MUST delay for a period of time before attempting a\n+retry. The amount of time a waiter delays between retries is computed using\n+`exponential backoff`_ through the following algorithm:\n+\n+* Let ``attempt`` be the number retry attempts.\n+* Let ``minDelay`` be the minimum amount of time to delay between retries in\n+  seconds, specified by the ``minDelay`` property of a\n+  :ref:`waiter <waiter-structure>` with a default of 2.\n+* Let ``maxDelay`` be the maximum amount of time to delay between retries in\n+  seconds, specified by the ``maxDelay`` property of a\n+  :ref:`waiter <waiter-structure>` with a default of 120.\n+* Let ``min`` be a function that returns the smaller of two integers.\n+* Let ``max`` be a function that returns the larger of two integers.\n+* Let ``maxWaitTime`` be the amount of time in seconds a user is willing to\n+  wait for a waiter to complete.\n+* Let ``remainingTime`` be the amount of seconds remaining before the waiter\n+  has exceeded ``maxWaitTime``.\n+\n+.. code-block:: python\n+\n+    delay = min(maxDelay, minDelay * 2 ** (attempt - 1))\n+\n+    if remainingTime - delay <= minDelay:\n+        delay = remainingTime - minDelay\n+\n+If the computed ``delay`` subtracted from ``remainingTime`` is less than\n+or equal to ``minDelay``, then set ``delay`` to ``remainingTime`` minus\n+``minDelay`` and perform one last retry. This prevents a waiter from waiting\n+needlessly only to exceed ``maxWaitTime`` before issuing a final request.\n+\n+Using the default ``minDelay`` of 2, ``maxDelay`` of 120, a ``maxWaitTime``\n+of 300 (or 5 minutes), and assuming that requests complete in 0 seconds\n+(for example purposes only), delays are computed as followed:\n+\n+.. list-table::\n+    :header-rows: 1\n+\n+    * - Retry ``attempt``\n+      - ``delay``\n+      - Cumulative time\n+      - ``remainingTime``\n+    * - 1\n+      - 2\n+      - 2\n+      - 298\n+    * - 2\n+      - 4\n+      - 6\n+      - 294\n+    * - 3\n+      - 8\n+      - 14\n+      - 286\n+    * - 4\n+      - 16\n+      - 30\n+      - 270\n+    * - 5\n+      - 32\n+      - 62\n+      - 238\n+    * - 6\n+      - 64\n+      - 126\n+      - 174\n+    * - 7\n+      - 120\n+      - 254\n+      - 46\n+    * - 8 (last attempt)\n+      - 44\n+      - 298\n+      - N/A\n+\n+\n+.. _waiter-structure:\n+\n+Waiter structure\n+================\n+\n+A *waiter* defines a set of acceptors that are used to check if a resource\n+has entered into a desired state.\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 25 65\n+\n+    * - Property\n+      - Type\n+      - Description\n+    * - documentation\n+      - ``string``\n+      - Documentation about the waiter defined using CommonMark_.\n+    * - acceptors\n+      - ``[`` :ref:`Acceptor structure <waiter-acceptor>` ``]``\n+      - **Required**. An ordered array of acceptors to check after executing\n+        an operation. The list of ``acceptors`` MUST contain at least one\n+        acceptor with a ``success`` state transition.\n+    * - minDelay\n+      - ``integer``\n+      - The minimum amount of time in seconds to delay between each retry.\n+        This value defaults to ``2`` if not specified. If specified, this\n+        value MUST be greater than or equal to 1 and less than or equal to\n+        ``maxDelay``.\n+    * - maxDelay\n+      - ``integer``\n+      - The maximum amount of time in seconds to delay between each retry.\n+        This value defaults to ``120`` if not specified (2 minutes). If\n+        specified, this value MUST be greater than or equal to 1.\n+\n+\n+.. _waiter-acceptor:\n+\n+Acceptor structure\n+==================\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 25 65\n+\n+    * - Property\n+      - Type\n+      - Description\n+    * - state\n+      - ``string``\n+      - **Required**. The state the acceptor transitions to when matched. The\n+        string value MUST be a valid :ref:`AcceptorState enum <waiter-acceptor-state>`.\n+    * - matcher\n+      - :ref:`Matcher structure <waiter-matcher>`\n+      - **Required.** The matcher used to test if the resource is in a state\n+        that matches the requirements needed for a state transition.\n+\n+\n+.. _waiter-acceptor-state:\n+\n+AcceptorState enum\n+==================\n+\n+Acceptors cause a waiter to transition into one of the following states:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 20 80\n+\n+    * - Name\n+      - Description\n+    * - success\n+      - The waiter successfully finished waiting. This is a terminal state\n+        that causes the waiter to stop.\n+    * - failure\n+      - The waiter failed to enter into the desired state. This is a terminal\n+        state that causes the waiter to stop.\n+    * - retry\n+      - The waiter will retry the operation. This state transition is\n+        implicit if no accepter causes a state transition.\n+\n+\n+.. _waiter-matcher:\n+\n+Matcher union\n+=============\n+\n+A *matcher* defines how an acceptor determines if it matches the current\n+state of a resource. A matcher is a union where exactly one of the following\n+members MUST be set:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 25 65\n+\n+    * - Property\n+      - Type\n+      - Description\n+    * - output\n+      - :ref:`PathMatcher structure <waiter-PathMatcher>`\n+      - Matches on the successful output of an operation using a\n+        JMESPath_ expression. This matcher MUST NOT be used on operations\n+        with no output. This matcher is checked only if an operation\n+        completes successfully.\n+    * - inputOutput\n+      - :ref:`PathMatcher structure <waiter-PathMatcher>`\n+      - Matches on both the input and output of an operation using a JMESPath_\n+        expression. Input parameters are available through the top-level\n+        ``input`` field, and output data is available through the top-level\n+        ``output`` field. This matcher can only be used on operations that\n+        define both input and output. This matcher is checked only if an\n+        operation completes successfully.\n+    * - success\n+      - ``boolean``\n+      - When set to ``true``, matches when an operation returns a successful\n+        response. When set to ``false``, matches when an operation fails with\n+        any error. This matcher is checked regardless of if an operation\n+        succeeds or fails with an error.\n+    * - errorType\n+      - ``string``\n+      - Matches if an operation returns an error of an expected type. If an\n+        absolute :ref:`shape ID <shape-id>` is provided, the error is\n+        matched only based on the name part of the shape ID. A relative shape\n+        name MAY be provided to match errors that are not defined in the\n+        model.\n+\n+        The ``errorType`` matcher SHOULD refer to errors that are associated\n+        with an operation through its ``errors`` property, though some\n+        operations might need to refer to framework errors or lower-level\n+        errors that are not defined in the model.\n+\n+\n+.. _waiter-PathMatcher:\n+\n+PathMatcher structure\n+=====================\n+\n+The ``output`` and ``inputOutput`` matchers test the result of a JMESPath_\n+expression against an expected value. These matchers are structures that\n+support the following members:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 25 65\n+\n+    * - Property\n+      - Type\n+      - Description\n+    * - path\n+      - ``string``\n+      - **Required.** A JMESPath expression applied to the input or output\n+        of an operation.\n+    * - expected\n+      - ``string``\n+      - **Required.** The expected return value of the expression.\n+    * - comparator\n+      - ``string``\n+      - **Required.** The comparator used to compare the result of the\n+        ``expression`` with the ``expected`` value. The string value MUST\n+        be a valid :ref:`PathComparator-enum`.\n+\n+\n+JMESPath data model\n+-------------------\n+\n+The data model exposed to JMESPath_ for input and output structures is\n+converted from Smithy types to `JMESPath types`_ using the following\n+conversion table:\n+\n+.. list-table::\n+    :header-rows: 1\n+\n+    * - Smithy type\n+      - JMESPath type\n+    * - blob\n+      - string (base64 encoded)\n+    * - boolean\n+      - boolean\n+    * - byte\n+      - number\n+    * - short\n+      - number\n+    * - integer\n+      - number\n+    * - long\n+      - number [#fnumbers]_\n+    * - float\n+      - number\n+    * - double\n+      - number\n+    * - bigDecimal\n+      - number [#fnumbers]_\n+    * - bigInteger\n+      - number [#fnumbers]_\n+    * - string\n+      - string\n+    * - timestamp\n+      - number [#ftimestamp]_\n+    * - document\n+      - any type\n+    * - list and set\n+      - array\n+    * - map\n+      - object\n+    * - structure\n+      - object [#fstructure]_\n+    * - union\n+      - object [#funion]_\n+\n+.. rubric:: Footnotes\n+\n+.. [#fnumbers] ``long``, ``bigInteger``, ``bigDecimal`` are exposed as\n+   numbers to JMESPath. If a value for one of these types truly exceeds\n+   the value of a double (the native numeric type of JMESPath), then\n+   querying these types in a waiter is a bad idea.\n+.. [#ftimestamp] ``timestamp`` values are represented in JMESPath expressions\n+   as epoch seconds with optional decimal precision. This allows for\n+   timestamp values to be used with relative comparators like ``<`` and ``>``.\n+.. [#fstructure] Structure members are referred to by member name and not\n+   the data sent over the wire. For example, the :ref:`jsonname-trait` is not\n+   respected in JMESPath expressions that select structure members.\n+.. [#funion] ``union`` values are represented exactly like structures except\n+   only a single member is set to a non-null value.\n+\n+\n+JMESPath static analysis\n+------------------------\n+\n+Smithy implementations that can statically analyze JMESPath expressions\n+MAY emit a :ref:`validation event <validation>` with an event ID of\n+``WaitableTraitJmespathProblem`` and a :ref:`severity of DANGER <severity-definition>`\n+if one of the following problems are detected in an expression:\n+\n+1. A JMESPath expression does not return a value that matches the expected\n+   return type of a :ref:`PathComparator-enum`\n+2. A JMESPath expression attempts to extract or operate on invalid model data.\n+\n+If such a problem is detected but is intentional, a\n+:ref:`suppression <suppression-definition>` can be used to ignore the error.\n+\n+\n+.. _PathComparator-enum:\n+\n+PathComparator enum\n+===================\n+\n+Each ``PathMatcher`` structure contains a ``comparator`` that is used to\n+check the result of a JMESPath expression against an expected value. A\n+comparator can be set to any of the following values:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 20 60 20\n+\n+    * - Name\n+      - Description\n+      - Required JMESPath return type\n+    * - stringEquals\n+      - Matches if the return value of a JMESPath expression is a string\n+        that is equal to an expected string.\n+      - ``string``\n+    * - booleanEquals\n+      - Matches if the return value of a JMESPath expression is a boolean.", "originalCommit": "75058e88706292c20f675bfd5b2f86228e144e8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMjI2Ng==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r519002266", "bodyText": "Add emphasis on the \"and\" here if added above.", "author": "kstich", "createdAt": "2020-11-06T20:59:25Z", "path": "docs/source/1.0/spec/waiters.rst", "diffHunk": "@@ -0,0 +1,783 @@\n+.. _waiters:\n+\n+=======\n+Waiters\n+=======\n+\n+Waiters are a client-side abstraction used to poll a resource until a desired\n+state is reached, or until it is determined that the resource will never\n+enter into the desired state. This is a common task when working with\n+services that are eventually consistent like Amazon S3 or services that\n+asynchronously create resources like Amazon EC2. Writing logic to\n+continuously poll the status of a resource can be cumbersome and\n+error-prone. The goal of waiters is to move this responsibility out of\n+customer code and onto service teams who know their service best.\n+\n+For example, waiters can be used in code to turn the workflow of waiting\n+for an Amazon EC2 instance to be terminated into something like the\n+following client pseudocode:\n+\n+.. code-block:: java\n+\n+    InstanceTerminatedWaiter waiter = InstanceTerminatedWaiter.builder()\n+            .client(myClient)\n+            .instanceIds(Collections.singletonList(\"i-foo\"))\n+            .totalAllowedWaitTime(10, Duration.MINUTES)\n+            .wait();\n+\n+\n+.. _smithy.waiters#waitable-trait:\n+\n+``smithy.waiters#waitable`` trait\n+=================================\n+\n+Waiters are defined on :ref:`operations <operation>` using the\n+``smithy.waiters#waitable`` trait.\n+\n+Trait summary\n+    Indicates that an operation has various named \"waiters\" that can be used\n+    to poll a resource until it enters a desired state.\n+Trait selector\n+    ``operation :not(-[input, output]-> structure > member > union[trait|streaming])``\n+\n+    (Operations that do not use :ref:`event streams <event-streams>` in their input or output)\n+Trait value\n+    A ``map`` of :ref:`waiter names <waiter-names>` to\n+    :ref:`Waiter structures <waiter-structure>`.\n+\n+The following example defines a waiter that waits until an Amazon S3 bucket\n+exists:\n+\n+.. code-block:: smithy\n+    :emphasize-lines: 3\n+\n+    namespace com.amazonaws.s3\n+\n+    @waitable(\n+        BucketExists: {\n+            documentation: \"Wait until a bucket exists\",\n+            acceptors: [\n+                {\n+                    state: \"success\",\n+                    matcher: {\n+                        success: true\n+                    }\n+                },\n+                {\n+                    state: \"retry\",\n+                    matcher: {\n+                        errorType: \"NotFound\"\n+                    }\n+                }\n+            ]\n+        }\n+    )\n+    operation HeadBucket {\n+        input: HeadBucketInput,\n+        output: HeadBucketOutput,\n+        errors: [NotFound]\n+    }\n+\n+Applying the steps defined in `Waiter workflow`_ to the above example,\n+a client performs the following steps:\n+\n+1. A ``HeadBucket`` operation is created, given the necessary input\n+   parameters, and sent to the service.\n+2. If the operation completes successfully, the waiter transitions to the\n+   ``success`` state and terminates. This is defined in the first acceptor\n+   of the waiter that uses the ``success`` matcher.\n+3. If the operation encounters an error named ``NotFound``, the waiter\n+   transitions to the ``retry`` state.\n+4. If the operation fails with any other error, the waiter transitions to\n+   the ``failure`` state and terminates.\n+5. The waiter is in the ``retry`` state and continues at step 1 after\n+   delaying with exponential backoff until the total allowed time to wait\n+   is exceeded.\n+\n+\n+.. _waiter-names:\n+\n+Waiter names\n+------------\n+\n+Waiter names MUST be defined using UpperCamelCase and only contain\n+alphanumeric characters. That is, waiters MUST adhere to the following\n+ABNF:\n+\n+.. code-block:: abnf\n+\n+    waiter-name: upper-alpha *(ALPHA / DIGIT)\n+    upper-alpha: %x41-5A ; A-Z\n+\n+.. seealso:: :ref:`waiter-best-practices` for additional best practices\n+    to follow when naming waiters.\n+\n+\n+Waiter workflow\n+===============\n+\n+Implementations MUST require callers to provide the total amount of time\n+they are willing to wait for a waiter to complete. Requiring the caller\n+to set a deadline removes any surprises as to how long a waiter can\n+potentially take to complete.\n+\n+While the total execution time of a waiter is less than the allowed time,\n+waiter implementations perform the following steps:\n+\n+1. Call the operation the :ref:`smithy.waiters#waitable-trait` is attached\n+   to using user-provided input for the operation. Any errors that can be\n+   encountered by the operation must be caught so that they can be inspected.\n+2. If the total time of the waiter exceeds the allowed time, the waiter\n+   SHOULD attempt to cancel any in-progress requests and MUST transition to a\n+   to a terminal ``failure`` state.\n+3. For every :ref:`acceptor <waiter-acceptor>` in the waiter:\n+\n+   1. If the acceptor :ref:`matcher <waiter-matcher>` is a match, transition\n+      to the :ref:`state <waiter-acceptor-state>` of the acceptor.\n+   2. If the acceptor transitions the waiter to the ``retry`` state, then\n+      continue to step 5.\n+   3. Stop waiting if the acceptor transitions the waiter to the ``success``\n+      or ``failure`` state.\n+\n+4. If none of the acceptors are matched and an error was encountered while\n+   calling the operation, then transition to the ``failure`` state and stop\n+   waiting.\n+5. Transition the waiter to the ``retry`` state, follow the process\n+   described in :ref:`waiter-retries`, and continue to step 1.\n+\n+\n+.. _waiter-retries:\n+\n+Waiter retries\n+--------------\n+\n+Waiter implementations MUST delay for a period of time before attempting a\n+retry. The amount of time a waiter delays between retries is computed using\n+`exponential backoff`_ through the following algorithm:\n+\n+* Let ``attempt`` be the number retry attempts.\n+* Let ``minDelay`` be the minimum amount of time to delay between retries in\n+  seconds, specified by the ``minDelay`` property of a\n+  :ref:`waiter <waiter-structure>` with a default of 2.\n+* Let ``maxDelay`` be the maximum amount of time to delay between retries in\n+  seconds, specified by the ``maxDelay`` property of a\n+  :ref:`waiter <waiter-structure>` with a default of 120.\n+* Let ``min`` be a function that returns the smaller of two integers.\n+* Let ``max`` be a function that returns the larger of two integers.\n+* Let ``maxWaitTime`` be the amount of time in seconds a user is willing to\n+  wait for a waiter to complete.\n+* Let ``remainingTime`` be the amount of seconds remaining before the waiter\n+  has exceeded ``maxWaitTime``.\n+\n+.. code-block:: python\n+\n+    delay = min(maxDelay, minDelay * 2 ** (attempt - 1))\n+\n+    if remainingTime - delay <= minDelay:\n+        delay = remainingTime - minDelay\n+\n+If the computed ``delay`` subtracted from ``remainingTime`` is less than\n+or equal to ``minDelay``, then set ``delay`` to ``remainingTime`` minus\n+``minDelay`` and perform one last retry. This prevents a waiter from waiting\n+needlessly only to exceed ``maxWaitTime`` before issuing a final request.\n+\n+Using the default ``minDelay`` of 2, ``maxDelay`` of 120, a ``maxWaitTime``\n+of 300 (or 5 minutes), and assuming that requests complete in 0 seconds\n+(for example purposes only), delays are computed as followed:\n+\n+.. list-table::\n+    :header-rows: 1\n+\n+    * - Retry ``attempt``\n+      - ``delay``\n+      - Cumulative time\n+      - ``remainingTime``\n+    * - 1\n+      - 2\n+      - 2\n+      - 298\n+    * - 2\n+      - 4\n+      - 6\n+      - 294\n+    * - 3\n+      - 8\n+      - 14\n+      - 286\n+    * - 4\n+      - 16\n+      - 30\n+      - 270\n+    * - 5\n+      - 32\n+      - 62\n+      - 238\n+    * - 6\n+      - 64\n+      - 126\n+      - 174\n+    * - 7\n+      - 120\n+      - 254\n+      - 46\n+    * - 8 (last attempt)\n+      - 44\n+      - 298\n+      - N/A\n+\n+\n+.. _waiter-structure:\n+\n+Waiter structure\n+================\n+\n+A *waiter* defines a set of acceptors that are used to check if a resource\n+has entered into a desired state.\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 25 65\n+\n+    * - Property\n+      - Type\n+      - Description\n+    * - documentation\n+      - ``string``\n+      - Documentation about the waiter defined using CommonMark_.\n+    * - acceptors\n+      - ``[`` :ref:`Acceptor structure <waiter-acceptor>` ``]``\n+      - **Required**. An ordered array of acceptors to check after executing\n+        an operation. The list of ``acceptors`` MUST contain at least one\n+        acceptor with a ``success`` state transition.\n+    * - minDelay\n+      - ``integer``\n+      - The minimum amount of time in seconds to delay between each retry.\n+        This value defaults to ``2`` if not specified. If specified, this\n+        value MUST be greater than or equal to 1 and less than or equal to\n+        ``maxDelay``.\n+    * - maxDelay\n+      - ``integer``\n+      - The maximum amount of time in seconds to delay between each retry.\n+        This value defaults to ``120`` if not specified (2 minutes). If\n+        specified, this value MUST be greater than or equal to 1.\n+\n+\n+.. _waiter-acceptor:\n+\n+Acceptor structure\n+==================\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 25 65\n+\n+    * - Property\n+      - Type\n+      - Description\n+    * - state\n+      - ``string``\n+      - **Required**. The state the acceptor transitions to when matched. The\n+        string value MUST be a valid :ref:`AcceptorState enum <waiter-acceptor-state>`.\n+    * - matcher\n+      - :ref:`Matcher structure <waiter-matcher>`\n+      - **Required.** The matcher used to test if the resource is in a state\n+        that matches the requirements needed for a state transition.\n+\n+\n+.. _waiter-acceptor-state:\n+\n+AcceptorState enum\n+==================\n+\n+Acceptors cause a waiter to transition into one of the following states:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 20 80\n+\n+    * - Name\n+      - Description\n+    * - success\n+      - The waiter successfully finished waiting. This is a terminal state\n+        that causes the waiter to stop.\n+    * - failure\n+      - The waiter failed to enter into the desired state. This is a terminal\n+        state that causes the waiter to stop.\n+    * - retry\n+      - The waiter will retry the operation. This state transition is\n+        implicit if no accepter causes a state transition.\n+\n+\n+.. _waiter-matcher:\n+\n+Matcher union\n+=============\n+\n+A *matcher* defines how an acceptor determines if it matches the current\n+state of a resource. A matcher is a union where exactly one of the following\n+members MUST be set:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 25 65\n+\n+    * - Property\n+      - Type\n+      - Description\n+    * - output\n+      - :ref:`PathMatcher structure <waiter-PathMatcher>`\n+      - Matches on the successful output of an operation using a\n+        JMESPath_ expression. This matcher MUST NOT be used on operations\n+        with no output. This matcher is checked only if an operation\n+        completes successfully.\n+    * - inputOutput\n+      - :ref:`PathMatcher structure <waiter-PathMatcher>`\n+      - Matches on both the input and output of an operation using a JMESPath_\n+        expression. Input parameters are available through the top-level\n+        ``input`` field, and output data is available through the top-level\n+        ``output`` field. This matcher can only be used on operations that\n+        define both input and output. This matcher is checked only if an\n+        operation completes successfully.\n+    * - success\n+      - ``boolean``\n+      - When set to ``true``, matches when an operation returns a successful\n+        response. When set to ``false``, matches when an operation fails with\n+        any error. This matcher is checked regardless of if an operation\n+        succeeds or fails with an error.\n+    * - errorType\n+      - ``string``\n+      - Matches if an operation returns an error of an expected type. If an\n+        absolute :ref:`shape ID <shape-id>` is provided, the error is\n+        matched only based on the name part of the shape ID. A relative shape\n+        name MAY be provided to match errors that are not defined in the\n+        model.\n+\n+        The ``errorType`` matcher SHOULD refer to errors that are associated\n+        with an operation through its ``errors`` property, though some\n+        operations might need to refer to framework errors or lower-level\n+        errors that are not defined in the model.\n+\n+\n+.. _waiter-PathMatcher:\n+\n+PathMatcher structure\n+=====================\n+\n+The ``output`` and ``inputOutput`` matchers test the result of a JMESPath_\n+expression against an expected value. These matchers are structures that\n+support the following members:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 25 65\n+\n+    * - Property\n+      - Type\n+      - Description\n+    * - path\n+      - ``string``\n+      - **Required.** A JMESPath expression applied to the input or output\n+        of an operation.\n+    * - expected\n+      - ``string``\n+      - **Required.** The expected return value of the expression.\n+    * - comparator\n+      - ``string``\n+      - **Required.** The comparator used to compare the result of the\n+        ``expression`` with the ``expected`` value. The string value MUST\n+        be a valid :ref:`PathComparator-enum`.\n+\n+\n+JMESPath data model\n+-------------------\n+\n+The data model exposed to JMESPath_ for input and output structures is\n+converted from Smithy types to `JMESPath types`_ using the following\n+conversion table:\n+\n+.. list-table::\n+    :header-rows: 1\n+\n+    * - Smithy type\n+      - JMESPath type\n+    * - blob\n+      - string (base64 encoded)\n+    * - boolean\n+      - boolean\n+    * - byte\n+      - number\n+    * - short\n+      - number\n+    * - integer\n+      - number\n+    * - long\n+      - number [#fnumbers]_\n+    * - float\n+      - number\n+    * - double\n+      - number\n+    * - bigDecimal\n+      - number [#fnumbers]_\n+    * - bigInteger\n+      - number [#fnumbers]_\n+    * - string\n+      - string\n+    * - timestamp\n+      - number [#ftimestamp]_\n+    * - document\n+      - any type\n+    * - list and set\n+      - array\n+    * - map\n+      - object\n+    * - structure\n+      - object [#fstructure]_\n+    * - union\n+      - object [#funion]_\n+\n+.. rubric:: Footnotes\n+\n+.. [#fnumbers] ``long``, ``bigInteger``, ``bigDecimal`` are exposed as\n+   numbers to JMESPath. If a value for one of these types truly exceeds\n+   the value of a double (the native numeric type of JMESPath), then\n+   querying these types in a waiter is a bad idea.\n+.. [#ftimestamp] ``timestamp`` values are represented in JMESPath expressions\n+   as epoch seconds with optional decimal precision. This allows for\n+   timestamp values to be used with relative comparators like ``<`` and ``>``.\n+.. [#fstructure] Structure members are referred to by member name and not\n+   the data sent over the wire. For example, the :ref:`jsonname-trait` is not\n+   respected in JMESPath expressions that select structure members.\n+.. [#funion] ``union`` values are represented exactly like structures except\n+   only a single member is set to a non-null value.\n+\n+\n+JMESPath static analysis\n+------------------------\n+\n+Smithy implementations that can statically analyze JMESPath expressions\n+MAY emit a :ref:`validation event <validation>` with an event ID of\n+``WaitableTraitJmespathProblem`` and a :ref:`severity of DANGER <severity-definition>`\n+if one of the following problems are detected in an expression:\n+\n+1. A JMESPath expression does not return a value that matches the expected\n+   return type of a :ref:`PathComparator-enum`\n+2. A JMESPath expression attempts to extract or operate on invalid model data.\n+\n+If such a problem is detected but is intentional, a\n+:ref:`suppression <suppression-definition>` can be used to ignore the error.\n+\n+\n+.. _PathComparator-enum:\n+\n+PathComparator enum\n+===================\n+\n+Each ``PathMatcher`` structure contains a ``comparator`` that is used to\n+check the result of a JMESPath expression against an expected value. A\n+comparator can be set to any of the following values:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 20 60 20\n+\n+    * - Name\n+      - Description\n+      - Required JMESPath return type\n+    * - stringEquals\n+      - Matches if the return value of a JMESPath expression is a string\n+        that is equal to an expected string.\n+      - ``string``\n+    * - booleanEquals\n+      - Matches if the return value of a JMESPath expression is a boolean.\n+        The ``expected`` value of a ``PathMatcher`` MUST be set to \"true\"\n+        or \"false\" to match the corresponding boolean value.\n+      - ``boolean``\n+    * - allStringEquals\n+      - Matches if the return value of a JMESPath expression is an array and\n+        every value in the array is a string that equals an expected string.\n+      - ``array`` of ``string``\n+    * - anyStringEquals\n+      - Matches if the return value of a JMESPath expression is an array and\n+        any value in the array is a string that equals an expected string.\n+      - ``array`` of ``string``\n+\n+\n+Waiter examples\n+===============\n+\n+This section provides examples for various features of waiters.\n+\n+The following example defines a ``ThingExists`` waiter that waits until the\n+``status`` member in the output of the ``GetThing`` operation returns\n+``\"success\"``. This example makes use of a \"fail-fast\"; in this example, if\n+a \"Thing\" has a ``failed`` status, then it can never enter the desired\n+``success`` state. To address this and prevent needlessly waiting on a\n+success state that can never happen, a ``failure`` state transition is\n+triggered if the ``status`` property equals ``failed``.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    use smithy.waiters#waitable\n+\n+    @waitable(\n+        ThingExists: {\n+            description: \"Waits until a thing has been created\",\n+            acceptors: [\n+                // Fail-fast if the thing transitions to a \"failed\" state.\n+                {\n+                    state: \"failure\",\n+                    matcher: {\n+                        output: {\n+                            path: \"status\",\n+                            comparator: \"stringEquals\",\n+                            expected: \"failed\"\n+                        }\n+                    }\n+                },\n+                // Succeed when the thing enters into a \"success\" state.\n+                {\n+                    state: \"success\",\n+                    matcher: {\n+                        output: {\n+                            path: \"status\",\n+                            comparator: \"stringEquals\",\n+                            expected: \"success\"\n+                        }\n+                    }\n+                }\n+            ]\n+        }\n+    )\n+    operation GetThing {\n+        input: GetThingInput,\n+        output: GetThingOutput,\n+    }\n+\n+    structure GetThingInput {\n+        @required\n+        name: String,\n+    }\n+\n+    structure GetThingOutput {\n+        status: String\n+    }\n+\n+Both input and output data can be queried using the ``inputOutput`` matcher.\n+The following example waiter completes successfully when the number of\n+provided groups on input matches the number of provided groups on output:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    use smithy.waiters#waitable\n+\n+    @waitable(\n+        GroupExists: {\n+            acceptors: [\n+                {\n+                    inputOutput: {\n+                        path: \"length(input.groups) == length(output.groups)\",\n+                        expected: \"true\",\n+                        comparator: \"booleanEquals\"\n+                    }\n+                }\n+            ]\n+        }\n+    )\n+    operation ListGroups {\n+        input: ListGroupsInput,\n+        output: ListGroupsOutput,\n+    }\n+\n+\n+.. _waiter-best-practices:\n+\n+Waiter best-practices\n+=====================\n+\n+The following non-normative section outlines best practices for defining\n+and implementing waiters.\n+\n+\n+Keep JMESPath expressions simple\n+--------------------------------\n+\n+Overly complex JMESPath_ expressions can easily lead to bugs. While static\n+analysis of JMESPath expressions can give some level of confidence in\n+expressions, it does not guarantee that the logic encoded in the\n+expression is correct. If it's overly difficult to describe a waiter for\n+a particular use-case, consider if the API itself is overly complex and\n+needs to be simplified.\n+\n+\n+Name waiters after the resource and state\n+-----------------------------------------\n+\n+Waiters SHOULD be named after the resource name and desired state, for example\n+``<Resource><StateName>``. \"StateName\" SHOULD match the expected state\n+name of the resource where possible. For example, if a \"Snapshot\" resource\n+can enter a \"deleted\" state, then the waiter name should be\n+``SnapshotDeleted`` and not ``SnapshotRemoved``.\n+\n+Good\n+    * ObjectExists\n+    * ConversionTaskDeleted\n+Bad\n+    The following examples are bad because they are named after the completion\n+    of an operation rather than the state of the resource:\n+\n+    * RunInstanceComplete\n+    * TerminateInstanceComplete\n+\n+    More appropriate names would be:\n+\n+    * InstanceRunning\n+    * InstanceTerminated\n+\n+.. note::\n+\n+    A common and acceptable exception to this rule are ``<Resource>Exists``\n+    and ``<Resource>NotExists`` waiters.\n+\n+\n+Do not model implicit acceptors\n+-------------------------------\n+\n+Implicit acceptors are unnecessary and can quickly become incomplete as new\n+resource states and errors are added. Waiters have 2 implicit\n+:ref:`acceptors <waiter-acceptor>`:\n+\n+* (Step 4) - If none of the acceptors are matched and an error was", "originalCommit": "75058e88706292c20f675bfd5b2f86228e144e8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MDY4Mw==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r519050683", "bodyText": "Looks like some ListPathComparator entries were left behind.", "author": "kstich", "createdAt": "2020-11-06T23:15:08Z", "path": "smithy-waiters/src/main/java/software/amazon/smithy/waiters/PathComparator.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.waiters;\n+\n+import software.amazon.smithy.model.node.ExpectationNotMetException;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.ToNode;\n+\n+/**\n+ * Defines a comparison to perform in a PathMatcher.\n+ */\n+public enum PathComparator implements ToNode {\n+\n+    /** Matches if all values in the list matches the expected string. */\n+    ALL_STRING_EQUALS(\"allStringEquals\"),\n+\n+    /** Matches if any value in the list matches the expected string. */\n+    ANY_STRING_EQUALS(\"anyStringEquals\"),\n+\n+    /** Matches if the return value is a string that is equal to the expected string. */\n+    STRING_EQUALS(\"stringEquals\"),\n+\n+    /** Matches if the return value is a boolean that is equal to the string literal 'true' or 'false'. */\n+    BOOLEAN_EQUALS(\"booleanEquals\");\n+\n+    private final String asString;\n+\n+    PathComparator(String asString) {\n+        this.asString = asString;\n+    }\n+\n+    /**\n+     * Creates a {@code PathComparator} from a {@link Node}.\n+     * @param node Node to create the {@code ListPathComparator} from.\n+     * @return Returns the created {@code ListPathComparator}.", "originalCommit": "4bc3ec3e71f443c559e2aa56ee68eaad117f3f45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2NDU4Ng==", "url": "https://github.com/awslabs/smithy/pull/623#discussion_r519064586", "bodyText": "doh!", "author": "mtdowling", "createdAt": "2020-11-07T00:14:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MDY4Mw=="}], "type": "inlineReview"}, {"oid": "06c1b6e8fbd296157896a48422c0a8be1a21b142", "url": "https://github.com/awslabs/smithy/commit/06c1b6e8fbd296157896a48422c0a8be1a21b142", "message": "Incorporate waiters PR feedback", "committedDate": "2020-11-07T00:13:49Z", "type": "forcePushed"}, {"oid": "02dfadb9999b232dbdd300f4679280a9070183c4", "url": "https://github.com/awslabs/smithy/commit/02dfadb9999b232dbdd300f4679280a9070183c4", "message": "Incorporate waiters PR feedback", "committedDate": "2020-11-10T20:43:26Z", "type": "commit"}, {"oid": "02dfadb9999b232dbdd300f4679280a9070183c4", "url": "https://github.com/awslabs/smithy/commit/02dfadb9999b232dbdd300f4679280a9070183c4", "message": "Incorporate waiters PR feedback", "committedDate": "2020-11-10T20:43:26Z", "type": "forcePushed"}]}