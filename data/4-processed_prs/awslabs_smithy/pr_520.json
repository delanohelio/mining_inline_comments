{"pr_number": 520, "pr_title": "Refactor model loading to allow equal conflicts", "pr_createdAt": "2020-08-03T02:31:45Z", "pr_url": "https://github.com/awslabs/smithy/pull/520", "timeline": [{"oid": "17fe59352242dd08e3f37d8e1a18c6046f6d7144", "url": "https://github.com/awslabs/smithy/commit/17fe59352242dd08e3f37d8e1a18c6046f6d7144", "message": "Refactor model loading to allow equal conflicts\n\nWhen using Smithy features like model discovery on the classpath, it's\nsometimes difficult to prevent the same Smithy models from being added\nto the model assembler multiple times. This is also true when using\nartifacts created for the \"model\" plugin for smithy-build along with\nmodel discovery. To address this, Smithy has been updated to allow\nconflicting shape definitions if the shapes, after they are fully built,\nare equivalent (meaning, they have the same exact members or references to\nother shapes and are the same type).", "committedDate": "2020-08-03T05:27:06Z", "type": "forcePushed"}, {"oid": "383b229a40c3e7b4e2ddaedac545a9bbd78b150e", "url": "https://github.com/awslabs/smithy/commit/383b229a40c3e7b4e2ddaedac545a9bbd78b150e", "message": "Refactor model loading to allow equal conflicts\n\nWhen using Smithy features like model discovery on the classpath, it's\nsometimes difficult to prevent the same Smithy models from being added\nto the model assembler multiple times. This is also true when using\nartifacts created for the \"model\" plugin for smithy-build along with\nmodel discovery. To address this, Smithy has been updated to allow\nconflicting shape definitions if the shapes, after they are fully built,\nare equivalent (meaning, they have the same exact members or references to\nother shapes and are the same type).", "committedDate": "2020-08-03T16:55:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc3MzcwOA==", "url": "https://github.com/awslabs/smithy/pull/520#discussion_r464773708", "bodyText": "Couldn't this also be a union or document?", "author": "JordonPhillips", "createdAt": "2020-08-04T03:14:07Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java", "diffHunk": "@@ -763,15 +691,27 @@ private void addTraits(ShapeId id, List<TraitEntry> traits) {\n      * @param isAnnotation Set to true to indicate that the value for the trait was omitted.\n      */\n     private void onDeferredTrait(ShapeId target, String traitName, Node traitValue, boolean isAnnotation) {\n-        onShapeTarget(traitName, traitValue.getSourceLocation(), id -> {\n-            if (isAnnotation) {\n-                visitor.onAnnotationTrait(target, id, traitValue.expectNullNode());\n-            } else {\n-                visitor.onTrait(target, id, traitValue);\n-            }\n+        modelFile.addForwardReference(traitName, (id, typeProvider) -> {\n+            modelFile.onTrait(target, id, coerceTraitValue(id, traitValue, isAnnotation, typeProvider));\n         });\n     }\n \n+    private Node coerceTraitValue(ShapeId traitId, Node value, boolean isAnnotation,\n+            Function<ShapeId, ShapeType> typeProvider) {\n+        if (isAnnotation && value.isNullNode()) {\n+            ShapeType targetType = typeProvider.apply(traitId);\n+            if (targetType != null) {\n+                if (targetType == ShapeType.STRUCTURE || targetType == ShapeType.MAP) {", "originalCommit": "383b229a40c3e7b4e2ddaedac545a9bbd78b150e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc4ODExNA==", "url": "https://github.com/awslabs/smithy/pull/520#discussion_r464788114", "bodyText": "No\u2014 a union requires a value as does a document.", "author": "mtdowling", "createdAt": "2020-08-04T04:12:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc3MzcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc4MjM2Nw==", "url": "https://github.com/awslabs/smithy/pull/520#discussion_r464782367", "bodyText": "This doesn't seem right, isn't it an equality check not a merge? Except if they're using apply statements?", "author": "JordonPhillips", "createdAt": "2020-08-04T03:49:34Z", "path": "docs/source/1.0/spec/core/model.rst", "diffHunk": "@@ -149,15 +149,32 @@ together to form a valid semantic model.\n Merging model files\n ===================\n \n-Implementations MUST take the following steps to merge models together to load\n-the semantic model:\n+Implementations MUST take the following steps to merge model files together to\n+form the semantic model:\n+\n+#. Merge the metadata objects of all model files using the steps defined in\n+   :ref:`merging-metadata`.\n+#. Shapes defined in a single model file are added to the semantic model as-is.\n+#. Shapes with the same shape ID defined in multiple model files are merged\n+   using the following rules:\n+\n+   #. All conflicting shapes MUST have the same shape type.\n+   #. Conflicting :ref:`aggregate shapes <aggregate-types>` MUST contain the\n+      same members that target the same shapes.\n+   #. Conflicting :ref:`service shapes <service-types>` MUST contain the same\n+      properties and target the same shapes.\n+   #. The traits of conflicting shapes and the traits of their members are", "originalCommit": "383b229a40c3e7b4e2ddaedac545a9bbd78b150e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc4ODY2NQ==", "url": "https://github.com/awslabs/smithy/pull/520#discussion_r464788665", "bodyText": "The traits are merged, but the shape itself isn\u2019t. I\u2019ll try to make this more clear.\nEdit: updated to clarify", "author": "mtdowling", "createdAt": "2020-08-04T04:15:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc4MjM2Nw=="}], "type": "inlineReview"}, {"oid": "3fdb5d5bf75b47394a740681fa8ea1fb1172c993", "url": "https://github.com/awslabs/smithy/commit/3fdb5d5bf75b47394a740681fa8ea1fb1172c993", "message": "Refactor model loading to allow equal conflicts\n\nWhen using Smithy features like model discovery on the classpath, it's\nsometimes difficult to prevent the same Smithy models from being added\nto the model assembler multiple times. This is also true when using\nartifacts created for the \"model\" plugin for smithy-build along with\nmodel discovery. To address this, Smithy has been updated to allow\nconflicting shape definitions if the shapes, after they are fully built,\nare equivalent (meaning, they have the same exact members or references to\nother shapes and are the same type).", "committedDate": "2020-08-04T17:46:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2NTA3NQ==", "url": "https://github.com/awslabs/smithy/pull/520#discussion_r465265075", "bodyText": "s/to to/to", "author": "kstich", "createdAt": "2020-08-04T19:02:50Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/loader/TraitContainer.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.loader;\n+\n+import static java.lang.String.format;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Logger;\n+import software.amazon.smithy.model.SourceException;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.traits.DynamicTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitFactory;\n+import software.amazon.smithy.model.validation.Severity;\n+import software.amazon.smithy.model.validation.ValidationEvent;\n+import software.amazon.smithy.model.validation.Validator;\n+\n+/**\n+ * Aggregates, merges, and creates traits.\n+ */\n+public interface TraitContainer {\n+\n+    /** Shared empty, immutable instance. */\n+    TraitContainer EMPTY = new TraitContainer() {\n+        @Override\n+        public Map<ShapeId, Map<ShapeId, Trait>> traits() {\n+            return Collections.emptyMap();\n+        }\n+\n+        @Override\n+        public Map<ShapeId, Trait> getTraitsForShape(ShapeId shape) {\n+            return Collections.emptyMap();\n+        }\n+\n+        @Override\n+        public Map<ShapeId, Map<ShapeId, Trait>> getTraitsAppliedToPrelude() {\n+            return Collections.emptyMap();\n+        }\n+\n+        @Override\n+        public void onTrait(ShapeId target, Trait value) {\n+            throw new UnsupportedOperationException(\"Cannot add trait \" + value.toShapeId() + \" to \" + target);\n+        }\n+\n+        @Override\n+        public void onTrait(ShapeId target, ShapeId traitId, Node value) {\n+            throw new UnsupportedOperationException(\"Cannot add trait \" + traitId + \" to \" + target);\n+        }\n+    };\n+\n+    /**\n+     * @return Gets all traits in the value map.\n+     */\n+    Map<ShapeId, Map<ShapeId, Trait>> traits();\n+\n+    /**\n+     * Gets the traits applied to a shape.\n+     *\n+     * @param shape Shape to get the traits of.\n+     * @return Returns the traits of the shape.\n+     */\n+    Map<ShapeId, Trait> getTraitsForShape(ShapeId shape);\n+\n+    /**\n+     * Gets all traits applied to to the prelude.", "originalCommit": "3fdb5d5bf75b47394a740681fa8ea1fb1172c993", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NTYxMw==", "url": "https://github.com/awslabs/smithy/pull/520#discussion_r465365613", "bodyText": "This test isn't carried over even though the functionality is retained and would be a break if the behavior changed unexpectedly.", "author": "kstich", "createdAt": "2020-08-04T22:28:20Z", "path": "smithy-model/src/test/java/software/amazon/smithy/model/loader/LoaderVisitorTest.java", "diffHunk": "@@ -1,209 +0,0 @@\n-/*\n- * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.smithy.model.loader;\n-\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.empty;\n-import static org.hamcrest.Matchers.equalTo;\n-import static org.hamcrest.Matchers.instanceOf;\n-import static org.hamcrest.Matchers.is;\n-import static org.hamcrest.Matchers.not;\n-\n-import java.net.URL;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-import software.amazon.smithy.model.Model;\n-import software.amazon.smithy.model.SourceException;\n-import software.amazon.smithy.model.node.Node;\n-import software.amazon.smithy.model.selector.Selector;\n-import software.amazon.smithy.model.shapes.MemberShape;\n-import software.amazon.smithy.model.shapes.Shape;\n-import software.amazon.smithy.model.shapes.ShapeId;\n-import software.amazon.smithy.model.shapes.StringShape;\n-import software.amazon.smithy.model.shapes.StructureShape;\n-import software.amazon.smithy.model.traits.DocumentationTrait;\n-import software.amazon.smithy.model.traits.DynamicTrait;\n-import software.amazon.smithy.model.traits.TraitDefinition;\n-import software.amazon.smithy.model.traits.TraitFactory;\n-import software.amazon.smithy.model.validation.ValidationEvent;\n-import software.amazon.smithy.utils.MapUtils;\n-\n-public class LoaderVisitorTest {\n-    private static final TraitFactory FACTORY = TraitFactory.createServiceFactory();\n-\n-    @Test\n-    public void callingOnEndTwiceIsIdempotent() {\n-        LoaderVisitor visitor = new LoaderVisitor(FACTORY);\n-\n-        assertThat(visitor.onEnd(), is(visitor.onEnd()));\n-    }\n-\n-    @Test\n-    public void cannotDuplicateTraitDefs() {\n-        Assertions.assertThrows(SourceException.class, () -> {\n-            LoaderVisitor visitor = new LoaderVisitor(FACTORY);\n-            StringShape def1 = StringShape.builder()\n-                    .id(\"foo.baz#Bar\")\n-                    .addTrait(TraitDefinition.builder().build())\n-                    .build();\n-            StringShape def2 = StringShape.builder()\n-                    .id(\"foo.baz#Bar\")\n-                    .addTrait(TraitDefinition.builder().selector(Selector.parse(\"string\")).build())\n-                    .build();\n-\n-            visitor.onShape(def1);\n-            visitor.onShape(def2);\n-            visitor.onEnd();\n-        });\n-    }\n-\n-    @Test\n-    public void ignoresDuplicateTraitDefsFromPrelude() {\n-        LoaderVisitor visitor = new LoaderVisitor(FACTORY);\n-        Shape def1 = StructureShape.builder()\n-                .id(\"smithy.api#deprecated\")\n-                .addTrait(TraitDefinition.builder().build())\n-                .build();\n-        Shape def2 = StructureShape.builder()\n-                .id(\"smithy.api#deprecated\")\n-                .addTrait(TraitDefinition.builder().build())\n-                .build();\n-\n-        visitor.onShape(def1);\n-        visitor.onShape(def2);\n-        List<ValidationEvent> events = visitor.onEnd().getValidationEvents();\n-\n-        assertThat(events, empty());\n-    }\n-\n-    @Test\n-    public void cannotDuplicateNonPreludeTraitDefs() {\n-        Assertions.assertThrows(SourceException.class, () -> {\n-            LoaderVisitor visitor = new LoaderVisitor(FACTORY);\n-            Shape def1 = StructureShape.builder()\n-                    .id(\"smithy.example#deprecated\")\n-                    .addTrait(TraitDefinition.builder().build())\n-                    .build();\n-            Shape def2 = StructureShape.builder()\n-                    .id(\"smithy.example#deprecated\")\n-                    .addTrait(TraitDefinition.builder().build())\n-                    .build();\n-\n-            visitor.onShape(def1);\n-            visitor.onShape(def2);\n-            visitor.onEnd();\n-        });\n-    }\n-\n-    @Test\n-    public void cannotDuplicateTraits() {\n-        LoaderVisitor visitor = new LoaderVisitor(FACTORY);\n-        ShapeId id = ShapeId.from(\"foo.bam#Boo\");\n-        visitor.onShape(StringShape.builder().id(id));\n-        visitor.onTrait(id, DocumentationTrait.ID, Node.from(\"abc\"));\n-        visitor.onTrait(id, DocumentationTrait.ID, Node.from(\"def\"));\n-        List<ValidationEvent> events = visitor.onEnd().getValidationEvents();\n-\n-        assertThat(events, not(empty()));\n-    }\n-\n-    @Test\n-    public void createsDynamicTraitWhenTraitFactoryReturnsEmpty() {", "originalCommit": "3fdb5d5bf75b47394a740681fa8ea1fb1172c993", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4Mzg0Mg==", "url": "https://github.com/awslabs/smithy/pull/520#discussion_r465383842", "bodyText": "Good catch. Fixed.", "author": "mtdowling", "createdAt": "2020-08-04T23:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NTYxMw=="}], "type": "inlineReview"}, {"oid": "f8287d461d2a3de34a78ed63dc6576a8df112c87", "url": "https://github.com/awslabs/smithy/commit/f8287d461d2a3de34a78ed63dc6576a8df112c87", "message": "Refactor model loading to allow equal conflicts\n\nWhen using Smithy features like model discovery on the classpath, it's\nsometimes difficult to prevent the same Smithy models from being added\nto the model assembler multiple times. This is also true when using\nartifacts created for the \"model\" plugin for smithy-build along with\nmodel discovery. To address this, Smithy has been updated to allow\nconflicting shape definitions if the shapes, after they are fully built,\nare equivalent (meaning, they have the same exact members or references to\nother shapes and are the same type).", "committedDate": "2020-08-04T23:22:27Z", "type": "commit"}, {"oid": "f8287d461d2a3de34a78ed63dc6576a8df112c87", "url": "https://github.com/awslabs/smithy/commit/f8287d461d2a3de34a78ed63dc6576a8df112c87", "message": "Refactor model loading to allow equal conflicts\n\nWhen using Smithy features like model discovery on the classpath, it's\nsometimes difficult to prevent the same Smithy models from being added\nto the model assembler multiple times. This is also true when using\nartifacts created for the \"model\" plugin for smithy-build along with\nmodel discovery. To address this, Smithy has been updated to allow\nconflicting shape definitions if the shapes, after they are fully built,\nare equivalent (meaning, they have the same exact members or references to\nother shapes and are the same type).", "committedDate": "2020-08-04T23:22:27Z", "type": "forcePushed"}]}