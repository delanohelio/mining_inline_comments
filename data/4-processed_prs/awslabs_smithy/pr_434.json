{"pr_number": 434, "pr_title": "Rewrite grammar and parser", "pr_createdAt": "2020-05-12T17:28:01Z", "pr_url": "https://github.com/awslabs/smithy/pull/434", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NjI3NA==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r423976274", "bodyText": "This isn't used anywhere", "author": "JordonPhillips", "createdAt": "2020-05-12T19:21:34Z", "path": "docs/source/1.0/spec/core/lexical-structure.rst", "diffHunk": "@@ -283,18 +271,13 @@ Shape IDs are formally defined by the following ABNF:\n \n .. productionlist:: smithy\n     shape_id               :`root_shape_id` [`shape_id_member`]\n-    root_shape_id          :`absolute_shape_id` / `identifier`\n-    absolute_shape_id      :`namespace` \"#\" `identifier`\n+    root_shape_id          :`absolute_root_shape_id` / `identifier`\n+    absolute_root_shape_id :`namespace` \"#\" `identifier`\n     namespace              :`identifier` *(\".\" `identifier`)\n     identifier             :(ALPHA / \"_\") *(ALPHA / DIGIT / \"_\")\n     shape_id_member        :\"$\" `identifier`\n     LOALPHA                :%x61-7A ; a-z", "originalCommit": "8b411a4b22bb6a57c0da174155fa4c5cda1ae2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAwOTM5OA==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r424009398", "bodyText": "Oh, LOALPHA -- removed", "author": "mtdowling", "createdAt": "2020-05-12T20:20:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NjI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4Mjc2MA==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r423982760", "bodyText": "This should probably have a ws after the comma", "author": "JordonPhillips", "createdAt": "2020-05-12T19:33:16Z", "path": "docs/source/1.0/spec/core/traits.rst", "diffHunk": "@@ -138,10 +138,12 @@ trait is defined in the IDL by enclosing the value in parenthesis. Trait values\n can only appear immediately before a shape.\n \n .. productionlist:: smithy\n-    trait                   :\"@\" `shape_id` [\"(\" `trait_body_value` \")\"]\n-    trait_body_value        :`trait_structure` / `node_value`\n-    trait_structure         :`trait_structure_kvp` *(\",\" `trait_structure_kvp`)\n-    trait_structure_kvp     :`text` \":\" `node_value`\n+    trait_statements    : *(`ws` `trait`) `ws`\n+    trait               :\"@\" `shape_id` [`trait_body`]\n+    trait_body          :\"(\" `ws` `trait_body_value` `ws` \")\"\n+    trait_body_value    :`trait_structure` / `node_value`\n+    trait_structure     :`trait_structure_kvp` *(`ws` `comma` `trait_structure_kvp`)", "originalCommit": "8b411a4b22bb6a57c0da174155fa4c5cda1ae2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAwODE1MA==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r424008150", "bodyText": "comma includes ws in the production:\ncomma = \",\" ws", "author": "mtdowling", "createdAt": "2020-05-12T20:18:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4Mjc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk0NzYyMQ==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r423947621", "bodyText": "nit: file name has a typo invalod...", "author": "kstich", "createdAt": "2020-05-12T18:31:55Z", "path": "smithy-model/src/test/resources/software/amazon/smithy/model/loader/invalid/strings/invalod-unicode-escape2.smithy", "diffHunk": "@@ -0,0 +1,5 @@\n+// Parse error at line 4, column 22 near `)\\n`: Invalid unclosed unicode escape found in string", "originalCommit": "8b411a4b22bb6a57c0da174155fa4c5cda1ae2e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk1OTUxMw==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r423959513", "bodyText": "This is pointing at what appears to be the wrong location for this error.", "author": "kstich", "createdAt": "2020-05-12T18:52:14Z", "path": "smithy-model/src/test/resources/software/amazon/smithy/model/loader/invalid/control-version-defined-twice.smithy", "diffHunk": "@@ -1,4 +1,4 @@\n-// Parse error at line 3, column 11 near `1.0`: Cannot define multiple versions in the same file\n+// Parse error at line 4, column 1 near `namespace`: Cannot define multiple versions in the same file", "originalCommit": "8b411a4b22bb6a57c0da174155fa4c5cda1ae2e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk2OTAxMQ==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r423969011", "bodyText": "s/if/is", "author": "kstich", "createdAt": "2020-05-12T19:08:29Z", "path": "docs/source/1.0/spec/core/lexical-structure.rst", "diffHunk": "@@ -24,33 +24,28 @@ for tooling and integrations.\n Smithy IDL ABNF\n ---------------\n \n-The Smithy IDL is a series of statements separated by newlines.\n+The Smithy IDL is defined by the following ABNF:\n \n .. productionlist:: smithy\n-    idl                     :[`statement` *(1*`br` `statement`)]\n-    statement               :`control_statement`\n-                            :/ `metadata_statement`\n-                            :/ `use_statement`\n-                            :/ `namespace_statement`\n-                            :/ `apply_statement`\n-                            :/ `documentation_comment`\n-                            :/ `shape_statement`\n+    idl:`ws`\n+       :/ `control_section`\n+       :/ `metadata_section`\n+       :/ `shape_section`\n \n \n -------------\n Lexical notes\n -------------\n \n Smithy models MUST be encoded using UTF-8 and SHOULD use Unix style\n-line endings (``\\n``).\n-\n-Whitespace is insignificant except for the following cases:\n-\n-* :token:`br` production which indicates that a new line MUST occur\n-* :ref:`shape ID ABNF productions <shape-id-abnf>`\n+line endings (``\\n``). The Smithy ABNF if whitespace sensitive.", "originalCommit": "8b411a4b22bb6a57c0da174155fa4c5cda1ae2e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NDE0NA==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r423974144", "bodyText": "This is inconsistent with the production list documentation in this PR.", "author": "kstich", "createdAt": "2020-05-12T19:17:46Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlTextParser.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.loader;\n+\n+/**\n+ * Parses IDL text and text blocks.\n+ */\n+final class IdlTextParser {\n+\n+    private IdlTextParser() {}\n+\n+    // node_text = shape_id / quoted_text / text_block", "originalCommit": "8b411a4b22bb6a57c0da174155fa4c5cda1ae2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5NzUxMw==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r424097513", "bodyText": "Good catch! This revealed several other issues that I fixed an added tests for, mostly around the difference between object keys and node_values. It wasn't implemented correctly in trait values in particular.", "author": "mtdowling", "createdAt": "2020-05-12T23:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NDE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4ODk3NQ==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r423988975", "bodyText": "Perf: any benefit to having this be a method reference instead of a lambda?", "author": "kstich", "createdAt": "2020-05-12T19:43:30Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlShapeIdParser.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.loader;\n+\n+/**\n+ * Parses IDL shape IDs.\n+ */\n+final class IdlShapeIdParser {\n+\n+    private IdlShapeIdParser() {}\n+\n+    static String parseShapeId(IdlModelParser parser) {\n+        int start = parser.position();\n+        consumeShapeId(parser);\n+        return parser.sliceFrom(start);\n+    }\n+\n+    static String parseIdentifier(IdlModelParser parser) {\n+        int start = parser.position();\n+        consumeIdentifier(parser);\n+        return parser.sliceFrom(start);\n+    }\n+\n+    // identifier = (ALPHA / \"_\") *(ALPHA / DIGIT / \"_\")\n+    static void consumeIdentifier(IdlModelParser parser) {\n+        // (ALPHA / \"_\")\n+        if (!isIdentifierStart(parser.charPeek())) {\n+            throw parser.syntax(\"Expected a valid identifier character, but found '\"\n+                                + parser.peekSingleCharForMessage() + '\\'');\n+        }\n+\n+        // *(ALPHA / DIGIT / \"_\")\n+        parser.consumeUntilNoLongerMatches(c -> isIdentifierStart(c) || isDigit(c));", "originalCommit": "8b411a4b22bb6a57c0da174155fa4c5cda1ae2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0MzM3Ng==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r424043376", "bodyText": "Probably not since the capture doesn't use any external variables, but I went ahead and made it a static method", "author": "mtdowling", "createdAt": "2020-05-12T21:26:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4ODk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyMTg1Mg==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r424021852", "bodyText": "The production for a list_statement no longer includes an identifier to name the list: it's not present in this production directly and is not part of a prefix to the shape_members production. It appears this issue was carried forward to many other shape_members related shape productions.", "author": "kstich", "createdAt": "2020-05-12T20:44:25Z", "path": "docs/source/1.0/spec/core/shapes.rst", "diffHunk": "@@ -388,18 +467,29 @@ targets the ``MyString`` shape in the same namespace.\n             }\n         }\n \n+All shapes that contain members use following ABNF to define members:\n+\n+.. productionlist:: smithy\n+    shape_members           :`empty_shape_members` / `populated_shape_members`\n+    empty_shape_members     :\"{\" `ws` \"}\"\n+    populated_shape_members :\"{\" `ws` `shape_member_kvp`\n+                            :  *(`comma` `shape_member_kvp` `ws`) `trailing_comma` \"}\"\n+    shape_member_kvp        :[`shape_documentation_comments`]\n+                            :  `trait_statements`\n+                            :  `identifier` `ws` \":\" `ws` `shape_id`\n+\n \n .. _list:\n \n List\n ====\n \n-The :dfn:`list` type represents a homogeneous collection of values. Lists\n-are defined using the following grammar:\n+The :dfn:`list` type represents a homogeneous collection of values. A list\n+statement requires that a :ref:`member <member>` named ``member`` is defined\n+in its body. Lists are defined using the following grammar:\n \n .. productionlist:: smithy\n-    list_statement          :\"list\" `list_and_set_body`\n-    list_and_set_body       :`identifier` \"{\" *`trait` \"member\" \":\" `shape_id` [\",\"] \"}\"\n+    list_statement :\"list\" `ws` `shape_members`", "originalCommit": "6533f90c1a3cfdddffd2f21e7e5017db650c8989", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyMzY1NQ==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r424023655", "bodyText": "Use clearPendingDocs for safety.", "author": "kstich", "createdAt": "2020-05-12T20:47:43Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java", "diffHunk": "@@ -0,0 +1,897 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.loader;\n+\n+import static java.lang.String.format;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.FromSourceLocation;\n+import software.amazon.smithy.model.SourceLocation;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.shapes.AbstractShapeBuilder;\n+import software.amazon.smithy.model.shapes.BigDecimalShape;\n+import software.amazon.smithy.model.shapes.BigIntegerShape;\n+import software.amazon.smithy.model.shapes.BlobShape;\n+import software.amazon.smithy.model.shapes.BooleanShape;\n+import software.amazon.smithy.model.shapes.ByteShape;\n+import software.amazon.smithy.model.shapes.CollectionShape;\n+import software.amazon.smithy.model.shapes.DocumentShape;\n+import software.amazon.smithy.model.shapes.DoubleShape;\n+import software.amazon.smithy.model.shapes.FloatShape;\n+import software.amazon.smithy.model.shapes.IntegerShape;\n+import software.amazon.smithy.model.shapes.ListShape;\n+import software.amazon.smithy.model.shapes.LongShape;\n+import software.amazon.smithy.model.shapes.MapShape;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.OperationShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.ServiceShape;\n+import software.amazon.smithy.model.shapes.SetShape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.ShapeType;\n+import software.amazon.smithy.model.shapes.ShortShape;\n+import software.amazon.smithy.model.shapes.StringShape;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.shapes.TimestampShape;\n+import software.amazon.smithy.model.shapes.UnionShape;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.validation.Severity;\n+import software.amazon.smithy.model.validation.ValidationEvent;\n+import software.amazon.smithy.model.validation.ValidationUtils;\n+import software.amazon.smithy.model.validation.Validator;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SetUtils;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+final class IdlModelParser {\n+\n+    private static final String PUT_KEY = \"put\";\n+    private static final String CREATE_KEY = \"create\";\n+    private static final String READ_KEY = \"read\";\n+    private static final String UPDATE_KEY = \"update\";\n+    private static final String DELETE_KEY = \"delete\";\n+    private static final String LIST_KEY = \"list\";\n+    private static final String RESOURCES_KEY = \"resources\";\n+    private static final String OPERATIONS_KEY = \"operations\";\n+    private static final String COLLECTION_OPERATIONS_KEY = \"collectionOperations\";\n+    private static final String IDENTIFIERS_KEY = \"identifiers\";\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String TYPE_KEY = \"type\";\n+\n+    static final Collection<String> RESOURCE_PROPERTY_NAMES = ListUtils.of(\n+            TYPE_KEY, CREATE_KEY, READ_KEY, UPDATE_KEY, DELETE_KEY, LIST_KEY,\n+            IDENTIFIERS_KEY, RESOURCES_KEY, OPERATIONS_KEY, PUT_KEY, COLLECTION_OPERATIONS_KEY);\n+    static final List<String> SERVICE_PROPERTY_NAMES = ListUtils.of(\n+            TYPE_KEY, VERSION_KEY, OPERATIONS_KEY, RESOURCES_KEY);\n+    private static final Collection<String> OPERATION_PROPERTY_NAMES = ListUtils.of(\"input\", \"output\", \"errors\");\n+    private static final Set<String> SHAPE_TYPES = new HashSet<>();\n+\n+    static {\n+        for (ShapeType type : ShapeType.values()) {\n+            if (type != ShapeType.MEMBER) {\n+                SHAPE_TYPES.add(type.toString());\n+            }\n+        }\n+    }\n+\n+    private final String filename;\n+    private final String model;\n+    private final LoaderVisitor visitor;\n+    private final int length;\n+    private int position = 0;\n+    private int line = 1;\n+    private int column = 1;\n+    private String namespace;\n+    private String definedVersion;\n+    private TraitEntry pendingDocumentationComment;\n+\n+    /** Map of shape aliases to their targets. */\n+    private final Map<String, ShapeId> useShapes = new HashMap<>();\n+\n+    // A pending trait that also doesn't yet have a resolved trait shape ID.\n+    static final class TraitEntry {\n+        final String traitName;\n+        final Node value;\n+        final boolean isAnnotation;\n+\n+        TraitEntry(String traitName, Node value, boolean isAnnotation) {\n+            this.traitName = traitName;\n+            this.value = value;\n+            this.isAnnotation = isAnnotation;\n+        }\n+    }\n+\n+    IdlModelParser(String filename, String model, LoaderVisitor visitor) {\n+        this.filename = filename;\n+        this.visitor = visitor;\n+        this.model = model;\n+        this.length = model.length();\n+    }\n+\n+    void parse() {\n+        ws();\n+        parseControlSection();\n+        parseMetadataSection();\n+        parseShapeSection();\n+    }\n+\n+    private void parseControlSection() {\n+        while (charPeek() == '$') {\n+            skip(); // Skip \"$\".\n+            ws();\n+            String key = IdlNodeParser.parseNodeObjectKey(this);\n+            ws();\n+            expect(':');\n+            ws();\n+            Node value = IdlNodeParser.parseNode(this);\n+            br();\n+            ws();\n+\n+            if (key.equals(\"version\")) {\n+                onVersion(value);\n+            } else {\n+                visitor.onError(ValidationEvent.builder()\n+                        .eventId(Validator.MODEL_ERROR)\n+                        .sourceLocation(value)\n+                        .severity(Severity.WARNING)\n+                        .message(format(\"Unknown control statement `%s` with value `%s\", key, Node.printJson(value)))\n+                        .build());\n+            }\n+        }\n+    }\n+\n+    private void onVersion(Node value) {\n+        if (!value.isStringNode()) {\n+            value.expectStringNode(\"The $version control statement must have a string value, but found \"\n+                                   + Node.printJson(value));\n+        }\n+\n+        String parsedVersion = value.expectStringNode().getValue();\n+\n+        if (definedVersion != null) {\n+            throw syntax(\"Cannot define multiple versions in the same file\");\n+        }\n+\n+        if (!visitor.isVersionSupported(parsedVersion)) {\n+            throw syntax(\"Unsupported Smithy version number: \" + parsedVersion);\n+        }\n+\n+        definedVersion = parsedVersion;\n+    }\n+\n+    private void parseMetadataSection() {\n+        while (charPeek() == 'm') {\n+            expect('m');\n+            expect('e');\n+            expect('t');\n+            expect('a');\n+            expect('d');\n+            expect('a');\n+            expect('t');\n+            expect('a');\n+            ws();\n+            String key = IdlNodeParser.parseNodeObjectKey(this);\n+            ws();\n+            expect('=');\n+            ws();\n+            visitor.onMetadata(key, IdlNodeParser.parseNode(this));\n+            br();\n+            ws();\n+        }\n+    }\n+\n+    private void parseShapeSection() {\n+        if (charPeek() == 'n') {\n+            expect('n');\n+            expect('a');\n+            expect('m');\n+            expect('e');\n+            expect('s');\n+            expect('p');\n+            expect('a');\n+            expect('c');\n+            expect('e');\n+            ws();\n+            namespace = IdlShapeIdParser.parseNamespace(this);\n+            br();\n+            // Clear out any erroneous documentation comments.\n+            pendingDocumentationComment = null;\n+            ws();\n+            parseUseSection();\n+            parseShapeStatements();\n+        } else if (!eof()) {\n+            if (!IdlShapeIdParser.isIdentifierStart(charPeek())) {\n+                throw syntax(\"Expected a namespace definition, but found unexpected syntax\");\n+            } else {\n+                throw syntax(\"A namespace must be defined before a use statement or shapes\");\n+            }\n+        }\n+    }\n+\n+    private void parseUseSection() {\n+        while (charPeek() == 'u' && charPeek(1) == 's') {\n+            expect('u');\n+            expect('s');\n+            expect('e');\n+            ws();\n+\n+            int start = position;\n+            IdlShapeIdParser.consumeNamespace(this);\n+            expect('#');\n+            IdlShapeIdParser.consumeIdentifier(this);\n+            String lexeme = sliceFrom(start);\n+            br();\n+            // Clear out any erroneous documentation comments.\n+            pendingDocumentationComment = null;", "originalCommit": "6533f90c1a3cfdddffd2f21e7e5017db650c8989", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyMzcxNg==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r424023716", "bodyText": "Use clearPendingDocs for safety.", "author": "kstich", "createdAt": "2020-05-12T20:47:48Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java", "diffHunk": "@@ -0,0 +1,897 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.loader;\n+\n+import static java.lang.String.format;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.FromSourceLocation;\n+import software.amazon.smithy.model.SourceLocation;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.shapes.AbstractShapeBuilder;\n+import software.amazon.smithy.model.shapes.BigDecimalShape;\n+import software.amazon.smithy.model.shapes.BigIntegerShape;\n+import software.amazon.smithy.model.shapes.BlobShape;\n+import software.amazon.smithy.model.shapes.BooleanShape;\n+import software.amazon.smithy.model.shapes.ByteShape;\n+import software.amazon.smithy.model.shapes.CollectionShape;\n+import software.amazon.smithy.model.shapes.DocumentShape;\n+import software.amazon.smithy.model.shapes.DoubleShape;\n+import software.amazon.smithy.model.shapes.FloatShape;\n+import software.amazon.smithy.model.shapes.IntegerShape;\n+import software.amazon.smithy.model.shapes.ListShape;\n+import software.amazon.smithy.model.shapes.LongShape;\n+import software.amazon.smithy.model.shapes.MapShape;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.OperationShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.ServiceShape;\n+import software.amazon.smithy.model.shapes.SetShape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.ShapeType;\n+import software.amazon.smithy.model.shapes.ShortShape;\n+import software.amazon.smithy.model.shapes.StringShape;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.shapes.TimestampShape;\n+import software.amazon.smithy.model.shapes.UnionShape;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.validation.Severity;\n+import software.amazon.smithy.model.validation.ValidationEvent;\n+import software.amazon.smithy.model.validation.ValidationUtils;\n+import software.amazon.smithy.model.validation.Validator;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SetUtils;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+final class IdlModelParser {\n+\n+    private static final String PUT_KEY = \"put\";\n+    private static final String CREATE_KEY = \"create\";\n+    private static final String READ_KEY = \"read\";\n+    private static final String UPDATE_KEY = \"update\";\n+    private static final String DELETE_KEY = \"delete\";\n+    private static final String LIST_KEY = \"list\";\n+    private static final String RESOURCES_KEY = \"resources\";\n+    private static final String OPERATIONS_KEY = \"operations\";\n+    private static final String COLLECTION_OPERATIONS_KEY = \"collectionOperations\";\n+    private static final String IDENTIFIERS_KEY = \"identifiers\";\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String TYPE_KEY = \"type\";\n+\n+    static final Collection<String> RESOURCE_PROPERTY_NAMES = ListUtils.of(\n+            TYPE_KEY, CREATE_KEY, READ_KEY, UPDATE_KEY, DELETE_KEY, LIST_KEY,\n+            IDENTIFIERS_KEY, RESOURCES_KEY, OPERATIONS_KEY, PUT_KEY, COLLECTION_OPERATIONS_KEY);\n+    static final List<String> SERVICE_PROPERTY_NAMES = ListUtils.of(\n+            TYPE_KEY, VERSION_KEY, OPERATIONS_KEY, RESOURCES_KEY);\n+    private static final Collection<String> OPERATION_PROPERTY_NAMES = ListUtils.of(\"input\", \"output\", \"errors\");\n+    private static final Set<String> SHAPE_TYPES = new HashSet<>();\n+\n+    static {\n+        for (ShapeType type : ShapeType.values()) {\n+            if (type != ShapeType.MEMBER) {\n+                SHAPE_TYPES.add(type.toString());\n+            }\n+        }\n+    }\n+\n+    private final String filename;\n+    private final String model;\n+    private final LoaderVisitor visitor;\n+    private final int length;\n+    private int position = 0;\n+    private int line = 1;\n+    private int column = 1;\n+    private String namespace;\n+    private String definedVersion;\n+    private TraitEntry pendingDocumentationComment;\n+\n+    /** Map of shape aliases to their targets. */\n+    private final Map<String, ShapeId> useShapes = new HashMap<>();\n+\n+    // A pending trait that also doesn't yet have a resolved trait shape ID.\n+    static final class TraitEntry {\n+        final String traitName;\n+        final Node value;\n+        final boolean isAnnotation;\n+\n+        TraitEntry(String traitName, Node value, boolean isAnnotation) {\n+            this.traitName = traitName;\n+            this.value = value;\n+            this.isAnnotation = isAnnotation;\n+        }\n+    }\n+\n+    IdlModelParser(String filename, String model, LoaderVisitor visitor) {\n+        this.filename = filename;\n+        this.visitor = visitor;\n+        this.model = model;\n+        this.length = model.length();\n+    }\n+\n+    void parse() {\n+        ws();\n+        parseControlSection();\n+        parseMetadataSection();\n+        parseShapeSection();\n+    }\n+\n+    private void parseControlSection() {\n+        while (charPeek() == '$') {\n+            skip(); // Skip \"$\".\n+            ws();\n+            String key = IdlNodeParser.parseNodeObjectKey(this);\n+            ws();\n+            expect(':');\n+            ws();\n+            Node value = IdlNodeParser.parseNode(this);\n+            br();\n+            ws();\n+\n+            if (key.equals(\"version\")) {\n+                onVersion(value);\n+            } else {\n+                visitor.onError(ValidationEvent.builder()\n+                        .eventId(Validator.MODEL_ERROR)\n+                        .sourceLocation(value)\n+                        .severity(Severity.WARNING)\n+                        .message(format(\"Unknown control statement `%s` with value `%s\", key, Node.printJson(value)))\n+                        .build());\n+            }\n+        }\n+    }\n+\n+    private void onVersion(Node value) {\n+        if (!value.isStringNode()) {\n+            value.expectStringNode(\"The $version control statement must have a string value, but found \"\n+                                   + Node.printJson(value));\n+        }\n+\n+        String parsedVersion = value.expectStringNode().getValue();\n+\n+        if (definedVersion != null) {\n+            throw syntax(\"Cannot define multiple versions in the same file\");\n+        }\n+\n+        if (!visitor.isVersionSupported(parsedVersion)) {\n+            throw syntax(\"Unsupported Smithy version number: \" + parsedVersion);\n+        }\n+\n+        definedVersion = parsedVersion;\n+    }\n+\n+    private void parseMetadataSection() {\n+        while (charPeek() == 'm') {\n+            expect('m');\n+            expect('e');\n+            expect('t');\n+            expect('a');\n+            expect('d');\n+            expect('a');\n+            expect('t');\n+            expect('a');\n+            ws();\n+            String key = IdlNodeParser.parseNodeObjectKey(this);\n+            ws();\n+            expect('=');\n+            ws();\n+            visitor.onMetadata(key, IdlNodeParser.parseNode(this));\n+            br();\n+            ws();\n+        }\n+    }\n+\n+    private void parseShapeSection() {\n+        if (charPeek() == 'n') {\n+            expect('n');\n+            expect('a');\n+            expect('m');\n+            expect('e');\n+            expect('s');\n+            expect('p');\n+            expect('a');\n+            expect('c');\n+            expect('e');\n+            ws();\n+            namespace = IdlShapeIdParser.parseNamespace(this);\n+            br();\n+            // Clear out any erroneous documentation comments.\n+            pendingDocumentationComment = null;", "originalCommit": "6533f90c1a3cfdddffd2f21e7e5017db650c8989", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyNTEwNw==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r424025107", "bodyText": "There's inconsistency here in ordering of calls to parseMembers vs visitor.onShape(), is there significance that's not documented or is it just happenstance?", "author": "kstich", "createdAt": "2020-05-12T20:50:20Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java", "diffHunk": "@@ -0,0 +1,897 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.loader;\n+\n+import static java.lang.String.format;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.FromSourceLocation;\n+import software.amazon.smithy.model.SourceLocation;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.shapes.AbstractShapeBuilder;\n+import software.amazon.smithy.model.shapes.BigDecimalShape;\n+import software.amazon.smithy.model.shapes.BigIntegerShape;\n+import software.amazon.smithy.model.shapes.BlobShape;\n+import software.amazon.smithy.model.shapes.BooleanShape;\n+import software.amazon.smithy.model.shapes.ByteShape;\n+import software.amazon.smithy.model.shapes.CollectionShape;\n+import software.amazon.smithy.model.shapes.DocumentShape;\n+import software.amazon.smithy.model.shapes.DoubleShape;\n+import software.amazon.smithy.model.shapes.FloatShape;\n+import software.amazon.smithy.model.shapes.IntegerShape;\n+import software.amazon.smithy.model.shapes.ListShape;\n+import software.amazon.smithy.model.shapes.LongShape;\n+import software.amazon.smithy.model.shapes.MapShape;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.OperationShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.ServiceShape;\n+import software.amazon.smithy.model.shapes.SetShape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.ShapeType;\n+import software.amazon.smithy.model.shapes.ShortShape;\n+import software.amazon.smithy.model.shapes.StringShape;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.shapes.TimestampShape;\n+import software.amazon.smithy.model.shapes.UnionShape;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.validation.Severity;\n+import software.amazon.smithy.model.validation.ValidationEvent;\n+import software.amazon.smithy.model.validation.ValidationUtils;\n+import software.amazon.smithy.model.validation.Validator;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SetUtils;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+final class IdlModelParser {\n+\n+    private static final String PUT_KEY = \"put\";\n+    private static final String CREATE_KEY = \"create\";\n+    private static final String READ_KEY = \"read\";\n+    private static final String UPDATE_KEY = \"update\";\n+    private static final String DELETE_KEY = \"delete\";\n+    private static final String LIST_KEY = \"list\";\n+    private static final String RESOURCES_KEY = \"resources\";\n+    private static final String OPERATIONS_KEY = \"operations\";\n+    private static final String COLLECTION_OPERATIONS_KEY = \"collectionOperations\";\n+    private static final String IDENTIFIERS_KEY = \"identifiers\";\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String TYPE_KEY = \"type\";\n+\n+    static final Collection<String> RESOURCE_PROPERTY_NAMES = ListUtils.of(\n+            TYPE_KEY, CREATE_KEY, READ_KEY, UPDATE_KEY, DELETE_KEY, LIST_KEY,\n+            IDENTIFIERS_KEY, RESOURCES_KEY, OPERATIONS_KEY, PUT_KEY, COLLECTION_OPERATIONS_KEY);\n+    static final List<String> SERVICE_PROPERTY_NAMES = ListUtils.of(\n+            TYPE_KEY, VERSION_KEY, OPERATIONS_KEY, RESOURCES_KEY);\n+    private static final Collection<String> OPERATION_PROPERTY_NAMES = ListUtils.of(\"input\", \"output\", \"errors\");\n+    private static final Set<String> SHAPE_TYPES = new HashSet<>();\n+\n+    static {\n+        for (ShapeType type : ShapeType.values()) {\n+            if (type != ShapeType.MEMBER) {\n+                SHAPE_TYPES.add(type.toString());\n+            }\n+        }\n+    }\n+\n+    private final String filename;\n+    private final String model;\n+    private final LoaderVisitor visitor;\n+    private final int length;\n+    private int position = 0;\n+    private int line = 1;\n+    private int column = 1;\n+    private String namespace;\n+    private String definedVersion;\n+    private TraitEntry pendingDocumentationComment;\n+\n+    /** Map of shape aliases to their targets. */\n+    private final Map<String, ShapeId> useShapes = new HashMap<>();\n+\n+    // A pending trait that also doesn't yet have a resolved trait shape ID.\n+    static final class TraitEntry {\n+        final String traitName;\n+        final Node value;\n+        final boolean isAnnotation;\n+\n+        TraitEntry(String traitName, Node value, boolean isAnnotation) {\n+            this.traitName = traitName;\n+            this.value = value;\n+            this.isAnnotation = isAnnotation;\n+        }\n+    }\n+\n+    IdlModelParser(String filename, String model, LoaderVisitor visitor) {\n+        this.filename = filename;\n+        this.visitor = visitor;\n+        this.model = model;\n+        this.length = model.length();\n+    }\n+\n+    void parse() {\n+        ws();\n+        parseControlSection();\n+        parseMetadataSection();\n+        parseShapeSection();\n+    }\n+\n+    private void parseControlSection() {\n+        while (charPeek() == '$') {\n+            skip(); // Skip \"$\".\n+            ws();\n+            String key = IdlNodeParser.parseNodeObjectKey(this);\n+            ws();\n+            expect(':');\n+            ws();\n+            Node value = IdlNodeParser.parseNode(this);\n+            br();\n+            ws();\n+\n+            if (key.equals(\"version\")) {\n+                onVersion(value);\n+            } else {\n+                visitor.onError(ValidationEvent.builder()\n+                        .eventId(Validator.MODEL_ERROR)\n+                        .sourceLocation(value)\n+                        .severity(Severity.WARNING)\n+                        .message(format(\"Unknown control statement `%s` with value `%s\", key, Node.printJson(value)))\n+                        .build());\n+            }\n+        }\n+    }\n+\n+    private void onVersion(Node value) {\n+        if (!value.isStringNode()) {\n+            value.expectStringNode(\"The $version control statement must have a string value, but found \"\n+                                   + Node.printJson(value));\n+        }\n+\n+        String parsedVersion = value.expectStringNode().getValue();\n+\n+        if (definedVersion != null) {\n+            throw syntax(\"Cannot define multiple versions in the same file\");\n+        }\n+\n+        if (!visitor.isVersionSupported(parsedVersion)) {\n+            throw syntax(\"Unsupported Smithy version number: \" + parsedVersion);\n+        }\n+\n+        definedVersion = parsedVersion;\n+    }\n+\n+    private void parseMetadataSection() {\n+        while (charPeek() == 'm') {\n+            expect('m');\n+            expect('e');\n+            expect('t');\n+            expect('a');\n+            expect('d');\n+            expect('a');\n+            expect('t');\n+            expect('a');\n+            ws();\n+            String key = IdlNodeParser.parseNodeObjectKey(this);\n+            ws();\n+            expect('=');\n+            ws();\n+            visitor.onMetadata(key, IdlNodeParser.parseNode(this));\n+            br();\n+            ws();\n+        }\n+    }\n+\n+    private void parseShapeSection() {\n+        if (charPeek() == 'n') {\n+            expect('n');\n+            expect('a');\n+            expect('m');\n+            expect('e');\n+            expect('s');\n+            expect('p');\n+            expect('a');\n+            expect('c');\n+            expect('e');\n+            ws();\n+            namespace = IdlShapeIdParser.parseNamespace(this);\n+            br();\n+            // Clear out any erroneous documentation comments.\n+            pendingDocumentationComment = null;\n+            ws();\n+            parseUseSection();\n+            parseShapeStatements();\n+        } else if (!eof()) {\n+            if (!IdlShapeIdParser.isIdentifierStart(charPeek())) {\n+                throw syntax(\"Expected a namespace definition, but found unexpected syntax\");\n+            } else {\n+                throw syntax(\"A namespace must be defined before a use statement or shapes\");\n+            }\n+        }\n+    }\n+\n+    private void parseUseSection() {\n+        while (charPeek() == 'u' && charPeek(1) == 's') {\n+            expect('u');\n+            expect('s');\n+            expect('e');\n+            ws();\n+\n+            int start = position;\n+            IdlShapeIdParser.consumeNamespace(this);\n+            expect('#');\n+            IdlShapeIdParser.consumeIdentifier(this);\n+            String lexeme = sliceFrom(start);\n+            br();\n+            // Clear out any erroneous documentation comments.\n+            pendingDocumentationComment = null;\n+            ws();\n+\n+            ShapeId target = ShapeId.from(lexeme);\n+            ShapeId previous = useShapes.put(target.getName(), target);\n+            if (previous != null) {\n+                throw syntax(String.format(\"Cannot use name `%s` because it conflicts with `%s`\",\n+                                           target, previous));\n+            }\n+        }\n+    }\n+\n+    private void parseShapeStatements() {\n+        while (!eof()) {\n+            ws();\n+            if (charPeek() == 'a') {\n+                parseApplyStatement();\n+            } else {\n+                boolean docsOnly = pendingDocumentationComment != null;\n+                List<TraitEntry> traits = parseDocsAndTraits();\n+                if (parseShapeDefinition(traits, docsOnly)) {\n+                    parseShape(traits);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void clearPendingDocs() {\n+        pendingDocumentationComment = null;\n+    }\n+\n+    private boolean parseShapeDefinition(List<TraitEntry> traits, boolean docsOnly) {\n+        if (eof()) {\n+            return !traits.isEmpty() && !docsOnly;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private List<TraitEntry> parseDocsAndTraits() {\n+        // Grab the pending docs, if present, and clear its state.\n+        TraitEntry docComment = pendingDocumentationComment;\n+        clearPendingDocs();\n+\n+        // Parse traits, if any.\n+        ws();\n+        List<TraitEntry> traits = IdlTraitParser.parseTraits(this);\n+        if (docComment != null) {\n+            traits.add(docComment);\n+        }\n+        ws();\n+\n+        return traits;\n+    }\n+\n+    private void parseShape(List<TraitEntry> traits) {\n+        SourceLocation location = currentLocation();\n+\n+        // Do a check here to give better parsing error messages.\n+        String shapeType = IdlShapeIdParser.parseIdentifier(this);\n+        if (!SHAPE_TYPES.contains(shapeType)) {\n+            switch (shapeType) {\n+                case \"use\":\n+                    throw syntax(\"A use statement must come before any shape definition\");\n+                case \"namespace\":\n+                    throw syntax(\"Only a single namespace can be declared per/file\");\n+                case \"metadata\":\n+                    throw syntax(\"Metadata statements must appear before a namespace statement\");\n+                default:\n+                    throw syntax(\"Unexpected shape type: \" + shapeType);\n+            }\n+        }\n+\n+        ws();\n+        ShapeId id = parseShapeName();\n+\n+        switch (shapeType) {\n+            case \"service\":\n+                parseServiceStatement(id, location);\n+                break;\n+            case \"resource\":\n+                parseResourceStatement(id, location);\n+                break;\n+            case \"operation\":\n+                parseOperationStatement(id, location);\n+                break;\n+            case \"structure\":\n+                parseStructuredShape(id, location, StructureShape.builder());\n+                break;\n+            case \"union\":\n+                parseStructuredShape(id, location, UnionShape.builder());\n+                break;\n+            case \"list\":\n+                parseCollection(id, location, ListShape.builder());\n+                break;\n+            case \"set\":\n+                parseCollection(id, location, SetShape.builder());\n+                break;\n+            case \"map\":\n+                parseMapStatement(id, location);\n+                break;\n+            case \"boolean\":\n+                parseSimpleShape(id, location, BooleanShape.builder());\n+                break;\n+            case \"string\":\n+                parseSimpleShape(id, location, StringShape.builder());\n+                break;\n+            case \"blob\":\n+                parseSimpleShape(id, location, BlobShape.builder());\n+                break;\n+            case \"byte\":\n+                parseSimpleShape(id, location, ByteShape.builder());\n+                break;\n+            case \"short\":\n+                parseSimpleShape(id, location, ShortShape.builder());\n+                break;\n+            case \"integer\":\n+                parseSimpleShape(id, location, IntegerShape.builder());\n+                break;\n+            case \"long\":\n+                parseSimpleShape(id, location, LongShape.builder());\n+                break;\n+            case \"float\":\n+                parseSimpleShape(id, location, FloatShape.builder());\n+                break;\n+            case \"document\":\n+                parseSimpleShape(id, location, DocumentShape.builder());\n+                break;\n+            case \"double\":\n+                parseSimpleShape(id, location, DoubleShape.builder());\n+                break;\n+            case \"bigInteger\":\n+                parseSimpleShape(id, location, BigIntegerShape.builder());\n+                break;\n+            case \"bigDecimal\":\n+                parseSimpleShape(id, location, BigDecimalShape.builder());\n+                break;\n+            case \"timestamp\":\n+                parseSimpleShape(id, location, TimestampShape.builder());\n+                break;\n+            default:\n+                // Unreachable.\n+                throw syntax(\"Unexpected shape type: \" + shapeType);\n+        }\n+\n+        addTraits(id, traits);\n+        clearPendingDocs();\n+        br();\n+    }\n+\n+    private ShapeId parseShapeName() {\n+        String name = IdlShapeIdParser.parseIdentifier(this);\n+\n+        if (useShapes.containsKey(name)) {\n+            throw syntax(String.format(\n+                    \"shape name `%s` conflicts with imported shape `%s`\", name, useShapes.get(name)));\n+        }\n+\n+        return ShapeId.fromRelative(namespace, name);\n+    }\n+\n+    private void parseSimpleShape(ShapeId id, SourceLocation location, AbstractShapeBuilder builder) {\n+        visitor.onShape(builder.source(location).id(id));\n+    }\n+\n+    private void parseCollection(ShapeId id, SourceLocation location, CollectionShape.Builder builder) {\n+        ws();\n+        builder.id(id).source(location);\n+        parseMembers(id, SetUtils.of(\"member\"));\n+        visitor.onShape(builder.id(id));\n+    }\n+\n+    private void parseMembers(ShapeId id, Set<String> requiredMembers) {\n+        Set<String> remaining = requiredMembers.isEmpty()\n+                ? requiredMembers\n+                : new HashSet<>(requiredMembers);\n+        ws();\n+        expect('{');\n+        // Don't keep any previous state of captured doc comments when\n+        // parsing members.\n+        clearPendingDocs();\n+        ws();\n+\n+        if (charPeek() != '}') {\n+            // Remove the parsed member from the remaining set to detect\n+            // when duplicates are found, or when members are missing.\n+            remaining.remove(parseMember(id, remaining));\n+            while (!eof()) {\n+                ws();\n+                if (charPeek() == ',') {\n+                    expect(',');\n+                    // A comma clears out any previously captured documentation\n+                    // comments that may have been found when parsing the member.\n+                    clearPendingDocs();\n+                    ws();\n+                    if (charPeek() == '}') {\n+                        // Trailing comma: \",\" \"}\"\n+                        break;\n+                    }\n+\n+                    // Special casing to detect invalid members early on, even\n+                    // after draining all the valid members. This keeps builders\n+                    // from raising confusing errors about invalid members.\n+                    if (remaining.isEmpty() && !requiredMembers.isEmpty()) {\n+                        parseMember(id, requiredMembers);\n+                    } else {\n+                        remaining.remove(parseMember(id, remaining));\n+                    }\n+                } else {\n+                    // Assume '}'; break to enforce.\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (!remaining.isEmpty()) {\n+            throw syntax(\"Missing required members of shape `\" + id + \"`: [\"\n+                         + ValidationUtils.tickedList(remaining) + ']');\n+        }\n+\n+        expect('}');\n+    }\n+\n+    private String parseMember(ShapeId parent, Set<String> requiredMembers) {\n+        // Parse optional member traits.\n+        List<TraitEntry> memberTraits = parseDocsAndTraits();\n+        SourceLocation memberLocation = currentLocation();\n+        String memberName = IdlShapeIdParser.parseIdentifier(this);\n+\n+        // Only enforce \"allowedMembers\" if it isn't empty.\n+        if (!requiredMembers.isEmpty() && !requiredMembers.contains(memberName)) {\n+            throw syntax(\"Unexpected member of \" + parent + \": '\" + memberName + '\\'');\n+        }\n+\n+        ws();\n+        expect(':');\n+        ws();\n+        ShapeId memberId = parent.withMember(memberName);\n+        MemberShape.Builder memberBuilder = MemberShape.builder().id(memberId).source(memberLocation);\n+        SourceLocation targetLocation = currentLocation();\n+        String target = IdlShapeIdParser.parseShapeId(this);\n+        visitor.onShape(memberBuilder);\n+        onShapeTarget(target, targetLocation, memberBuilder::target);\n+        addTraits(memberId, memberTraits);\n+\n+        return memberName;\n+    }\n+\n+    private void parseMapStatement(ShapeId id, SourceLocation location) {\n+        parseMembers(id, SetUtils.of(\"key\", \"value\"));\n+        visitor.onShape(MapShape.builder().id(id).source(location));\n+    }\n+\n+    private void parseStructuredShape(ShapeId id, SourceLocation location, AbstractShapeBuilder builder) {\n+        visitor.onShape(builder.id(id).source(location));", "originalCommit": "6533f90c1a3cfdddffd2f21e7e5017db650c8989", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0ODc1Mw==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r424048753", "bodyText": "Parsing members of list/set/map before registering the shape with the LoaderVisitor ensures that the shape is only registered if it as all of its required members. Otherwise, the LoaderVisitor gives a cryptic message with no context about how a \"member\" wasn't set on a builder. I added a comment to say this in code.\nAs for structures:\n// Register the structure/union with the loader before parsing members.\n// This will detect shape conflicts with other types (like an operation)\n// and still give useful error messages. Trying to parse members first\n// would otherwise result in cryptic error messages like:\n// \"Member `foo.baz#Foo$Baz` cannot be added to software.amazon.smithy.model.shapes.OperationShape$Builder\"", "author": "mtdowling", "createdAt": "2020-05-12T21:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyNTEwNw=="}], "type": "inlineReview"}, {"oid": "2752061a913913f089fe97bffbbb23f0551b357e", "url": "https://github.com/awslabs/smithy/commit/2752061a913913f089fe97bffbbb23f0551b357e", "message": "Rewrite grammar and parser\n\nThis commit is a complete rewrite of the Smithy IDL parser and grammar.\nIt is intended to clear up the intention of how the IDL works in\npractice by making the grammar embed things like how control statements\ncome before metadata, which come before namespace, etc.. It also\nclarifies how different node_value locations have different semantics\n(e.g., keys in objects are not resolved against keywords like\ntrue and do not perform relative shape ID resolution nor do they support\ntext blocks). Many other fixes have been made to the grammar too,\nincluding specifying where whitespace is allowed and where line breaks\nare required. This makes the grammar more verbose but also more accurate\nand in line with what was already implemented.\n\nWith these changes, control statement keyus, metadata keys, and object keys\nmust now be quoted if they contain \".\", \"#\", or \"$\". In practice, the\nmodel parser already enforced these constraints in some places.", "committedDate": "2020-05-12T23:51:36Z", "type": "forcePushed"}, {"oid": "e6836f863718c72e09a1f5be3e4a02df4e5df272", "url": "https://github.com/awslabs/smithy/commit/e6836f863718c72e09a1f5be3e4a02df4e5df272", "message": "Rewrite grammar and parser\n\nThis commit is a complete rewrite of the Smithy IDL parser and grammar.\nIt is intended to clear up the intention of how the IDL works in\npractice by making the grammar embed things like how control statements\ncome before metadata, which come before namespace, etc.. It also\nclarifies how different node_value locations have different semantics\n(e.g., keys in objects are not resolved against keywords like\ntrue and do not perform relative shape ID resolution nor do they support\ntext blocks). Many other fixes have been made to the grammar too,\nincluding specifying where whitespace is allowed and where line breaks\nare required. This makes the grammar more verbose but also more accurate\nand in line with what was already implemented.\n\nWith these changes, control statement keyus, metadata keys, and object keys\nmust now be quoted if they contain \".\", \"#\", or \"$\". In practice, the\nmodel parser already enforced these constraints in some places.", "committedDate": "2020-05-12T23:55:26Z", "type": "forcePushed"}, {"oid": "bec25c81b5763409c240aa83d015b34376bdf347", "url": "https://github.com/awslabs/smithy/commit/bec25c81b5763409c240aa83d015b34376bdf347", "message": "Rewrite grammar and parser\n\nThis commit is a complete rewrite of the Smithy IDL parser and grammar.\nIt is intended to clear up the intention of how the IDL works in\npractice by making the grammar embed things like how control statements\ncome before metadata, which come before namespace, etc.. It also\nclarifies how different node_value locations have different semantics\n(e.g., keys in objects are not resolved against keywords like\ntrue and do not perform relative shape ID resolution nor do they support\ntext blocks). Many other fixes have been made to the grammar too,\nincluding specifying where whitespace is allowed and where line breaks\nare required. This makes the grammar more verbose but also more accurate\nand in line with what was already implemented.\n\nWith these changes, control statement keyus, metadata keys, and object keys\nmust now be quoted if they contain \".\", \"#\", or \"$\". In practice, the\nmodel parser already enforced these constraints in some places.", "committedDate": "2020-05-13T00:03:43Z", "type": "forcePushed"}, {"oid": "1e2a417c522932ba346edbe0f94c459d95bdeeaf", "url": "https://github.com/awslabs/smithy/commit/1e2a417c522932ba346edbe0f94c459d95bdeeaf", "message": "Rewrite grammar and parser\n\nThis commit is a complete rewrite of the Smithy IDL parser and grammar.\nIt is intended to clear up the intention of how the IDL works in\npractice by making the grammar embed things like how control statements\ncome before metadata, which come before namespace, etc.. It also\nclarifies how different node_value locations have different semantics\n(e.g., keys in objects are not resolved against keywords like\ntrue and do not perform relative shape ID resolution nor do they support\ntext blocks). Many other fixes have been made to the grammar too,\nincluding specifying where whitespace is allowed and where line breaks\nare required. This makes the grammar more verbose but also more accurate\nand in line with what was already implemented.\n\nWith these changes, control statement keyus, metadata keys, and object keys\nmust now be quoted if they contain \".\", \"#\", or \"$\". In practice, the\nmodel parser already enforced these constraints in some places.", "committedDate": "2020-05-13T17:39:15Z", "type": "commit"}, {"oid": "1e2a417c522932ba346edbe0f94c459d95bdeeaf", "url": "https://github.com/awslabs/smithy/commit/1e2a417c522932ba346edbe0f94c459d95bdeeaf", "message": "Rewrite grammar and parser\n\nThis commit is a complete rewrite of the Smithy IDL parser and grammar.\nIt is intended to clear up the intention of how the IDL works in\npractice by making the grammar embed things like how control statements\ncome before metadata, which come before namespace, etc.. It also\nclarifies how different node_value locations have different semantics\n(e.g., keys in objects are not resolved against keywords like\ntrue and do not perform relative shape ID resolution nor do they support\ntext blocks). Many other fixes have been made to the grammar too,\nincluding specifying where whitespace is allowed and where line breaks\nare required. This makes the grammar more verbose but also more accurate\nand in line with what was already implemented.\n\nWith these changes, control statement keyus, metadata keys, and object keys\nmust now be quoted if they contain \".\", \"#\", or \"$\". In practice, the\nmodel parser already enforced these constraints in some places.", "committedDate": "2020-05-13T17:39:15Z", "type": "forcePushed"}]}