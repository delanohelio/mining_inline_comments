{"pr_number": 301, "pr_title": "Add a Node object mapper", "pr_createdAt": "2020-03-04T19:49:46Z", "pr_url": "https://github.com/awslabs/smithy/pull/301", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkzODIyOA==", "url": "https://github.com/awslabs/smithy/pull/301#discussion_r387938228", "bodyText": "Minor: Would be good to have a comment here indicating that these are priority ordered, and what determined the priority.", "author": "kstich", "createdAt": "2020-03-04T21:14:39Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/node/DefaultNodeDeserializers.java", "diffHunk": "@@ -0,0 +1,594 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.node;\n+\n+import static software.amazon.smithy.model.node.NodeMapper.ObjectCreatorFactory;\n+\n+import java.io.File;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+import software.amazon.smithy.model.FromSourceLocation;\n+import software.amazon.smithy.model.SourceLocation;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.MapUtils;\n+import software.amazon.smithy.utils.Pair;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * The default implementations use to convert Nodes into Objects through a {@link NodeMapper}.\n+ */\n+final class DefaultNodeDeserializers {\n+\n+    // Deserialize an exact type if it matches (i.e., the setter expects a Node value).\n+    private static final ObjectCreatorFactory EXACT_CREATOR_FACTORY = (nodeType, targetType) -> {\n+        return targetType == nodeType.getNodeClass()\n+               ? (node, target, param, pointer, mapper) -> node\n+               : null;\n+    };\n+\n+    // Creates booleans from BooleanNodes.\n+    private static final ObjectCreatorFactory BOOLEAN_CREATOR_FACTORY = (nodeType, targetType) -> {\n+        if (nodeType == NodeType.BOOLEAN) {\n+            if (targetType == Boolean.class || targetType == boolean.class || targetType == Object.class) {\n+                return (node, target, param, pointer, mapper) -> node.expectBooleanNode().getValue();\n+            }\n+        }\n+        return null;\n+    };\n+\n+    // Null nodes always return null values.\n+    private static final ObjectCreatorFactory NULL_CREATOR = (nodeType, targetType) -> {\n+        if (nodeType == NodeType.NULL) {\n+            return (node, target, param, pointer, mapper) -> null;\n+        }\n+        return null;\n+    };\n+\n+    // String nodes can create java.land.String or a Smithy ShapeId.\n+    private static final ObjectCreatorFactory STRING_CREATOR = (nodeType, into) -> {\n+        if (nodeType == NodeType.STRING) {\n+            if (into == String.class || into == Object.class) {\n+                return (node, target, param, pointer, mapper) -> node.expectStringNode().getValue();\n+            } else if (into == ShapeId.class) {\n+                return (node, target, param, pointer, mapper) -> node.expectStringNode().expectShapeId();\n+            }\n+        }\n+        return null;\n+    };\n+\n+    private static final Map<Class, Function<Number, Object>> NUMBER_MAPPERS = new HashMap<>();\n+\n+    static {\n+        NUMBER_MAPPERS.put(Object.class, n -> n);\n+        NUMBER_MAPPERS.put(Byte.class, Number::byteValue);\n+        NUMBER_MAPPERS.put(byte.class, Number::byteValue);\n+        NUMBER_MAPPERS.put(Short.class, Number::shortValue);\n+        NUMBER_MAPPERS.put(short.class, Number::shortValue);\n+        NUMBER_MAPPERS.put(Integer.class, Number::intValue);\n+        NUMBER_MAPPERS.put(int.class, Number::intValue);\n+        NUMBER_MAPPERS.put(Long.class, Number::longValue);\n+        NUMBER_MAPPERS.put(long.class, Number::longValue);\n+        NUMBER_MAPPERS.put(Float.class, Number::floatValue);\n+        NUMBER_MAPPERS.put(float.class, Number::floatValue);\n+        NUMBER_MAPPERS.put(Double.class, Number::doubleValue);\n+        NUMBER_MAPPERS.put(double.class, Number::doubleValue);\n+        NUMBER_MAPPERS.put(BigInteger.class, n -> BigInteger.valueOf(n.longValue()));\n+        NUMBER_MAPPERS.put(BigDecimal.class, n -> BigDecimal.valueOf(n.doubleValue()));\n+    }\n+\n+    // Creates numbers from NumberNodes.\n+    private static final ObjectCreatorFactory NUMBER_CREATOR = (nodeType, targetType) -> {\n+        if (nodeType == NodeType.NUMBER) {\n+            if (NUMBER_MAPPERS.containsKey(targetType)) {\n+                return (node, target, param, pointer, mapper) -> {\n+                    Number value = node.expectNumberNode().getValue();\n+                    return NUMBER_MAPPERS.get(target).apply(value);\n+                };\n+            }\n+        }\n+        return null;\n+    };\n+\n+    private interface ReflectiveSupplier<T> {\n+        T get() throws ReflectiveOperationException;\n+    }\n+\n+    // Deserialize an ArrayNode into a Collection.\n+    private static final ObjectCreatorFactory COLLECTION_CREATOR = new ObjectCreatorFactory() {\n+        @Override\n+        public NodeMapper.ObjectCreator getCreator(NodeType nodeType, Class<?> target) {\n+            if (nodeType != NodeType.ARRAY) {\n+                return null;\n+            }\n+\n+            ReflectiveSupplier<Collection<Object>> ctor = createSupplier(target);\n+\n+            if (ctor == null) {\n+                return null;\n+            }\n+\n+            return (node, targetType, param, pointer, mapper) -> {\n+                Collection<Object> collection;\n+\n+                try {\n+                    collection = ctor.get();\n+                } catch (ReflectiveOperationException e) {\n+                    String message = \"Unable to deserialize array into Collection: \" + getCauseMessage(e);\n+                    throw NodeDeserializationException.fromReflectiveContext(targetType, pointer, node, e, message);\n+                }\n+\n+                int i = 0;\n+                for (Node entry : node.expectArrayNode().getElements()) {\n+                    Object nextValue = mapper.deserializeNext(\n+                            entry, pointer + \"/\" + i++, param, Object.class, mapper);\n+                    collection.add(nextValue);\n+                }\n+                return collection;\n+            };\n+        }\n+\n+        private ReflectiveSupplier<Collection<Object>> createSupplier(Class<?> targetType) {\n+            // Create an ArrayList for most cases of lists or iterables.\n+            if (targetType.equals(List.class)\n+                    || targetType.equals(Collection.class)\n+                    || targetType.equals(Object.class)\n+                    || targetType.equals(ArrayList.class)\n+                    || targetType.equals(Iterable.class)) {\n+                return ArrayList::new;\n+            } else if (targetType.equals(Set.class) || targetType.equals(HashSet.class)) {\n+                // Special casing for Set or HashSet.\n+                return HashSet::new;\n+            } else if (Collection.class.isAssignableFrom(targetType)) {\n+                return createSupplierFromReflection(targetType);\n+            }\n+            return null;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private ReflectiveSupplier<Collection<Object>> createSupplierFromReflection(Class<?> into) {\n+            try {\n+                // Create the collection type by assuming it has a public, zero-arg constructor.\n+                Class<Collection> collectionTarget = (Class<Collection>) into;\n+                Constructor<Collection> classCtor = collectionTarget.getDeclaredConstructor();\n+                classCtor.setAccessible(true);\n+                return classCtor::newInstance;\n+            } catch (NoSuchMethodException e) {\n+                // We *could* pass here and try to let the next deserializer take a crack, but that would\n+                // probably never work in practice and results in a less descriptive error message.\n+                throw new NodeDeserializationException(\n+                        \"Unable to find a zero-arg constructor for Collection \" + into.getName(),\n+                        SourceLocation.NONE, e);\n+            }\n+        }\n+    };\n+\n+    private static String getCauseMessage(Throwable e) {\n+        // Don't pull back more than one layer since that context might be useful.\n+        return e.getCause() != null ? e.getCause().getMessage() : e.getMessage();\n+    }\n+\n+    // Deserialize an ObjectNode into a Map.\n+    private static final ObjectCreatorFactory MAP_CREATOR = new ObjectCreatorFactory() {\n+        @Override\n+        public NodeMapper.ObjectCreator getCreator(NodeType nodeType, Class<?> target) {\n+            if (nodeType != NodeType.OBJECT) {\n+                return null;\n+            }\n+\n+            ReflectiveSupplier<Map<String, Object>> ctor = createSupplier(target);\n+\n+            if (ctor == null) {\n+                return null;\n+            }\n+\n+            return (node, targetType, param, pointer, mapper) -> {\n+                Map<String, Object> map;\n+\n+                try {\n+                    map = ctor.get();\n+                } catch (ReflectiveOperationException e) {\n+                    String message = \"Unable to deserialize object into Map: \" + getCauseMessage(e);\n+                    throw NodeDeserializationException.fromReflectiveContext(targetType, pointer, node, e, message);\n+                }\n+\n+                ObjectNode objectNode = node.expectObjectNode();\n+                for (Map.Entry<String, Node> entry : objectNode.getStringMap().entrySet()) {\n+                    String key = entry.getKey();\n+                    Object value = mapper.deserializeNext(\n+                            entry.getValue(), pointer + \"/\" + key, param, Object.class, mapper);\n+                    map.put(key, value);\n+                }\n+\n+                return map;\n+            };\n+        }\n+\n+        private ReflectiveSupplier<Map<String, Object>> createSupplier(Class<?> into) {\n+            if (into == Object.class || into == Map.class || into == HashMap.class) {\n+                return HashMap::new;\n+            } else if (Map.class.isAssignableFrom(into)) {\n+                return createSupplierFromReflection(into);\n+            }\n+            return null;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private ReflectiveSupplier<Map<String, Object>> createSupplierFromReflection(Class<?> into) {\n+            try {\n+                // Try to create the map from an empty constructor.\n+                Class<Map<String, Object>> collectionTarget = (Class<Map<String, Object>>) into;\n+                Constructor<Map<String, Object>> mapCtor = collectionTarget.getDeclaredConstructor();\n+                return mapCtor::newInstance;\n+            } catch (NoSuchMethodException e) {\n+                // We *could* pass here and try to let the next deserializer take a crack, but that would\n+                // probably never work in practice and results in a less descriptive error message.\n+                throw new NodeDeserializationException(\n+                        \"Unable to find a zero-arg constructor for Map \" + into.getName(),\n+                        SourceLocation.NONE, e);\n+            }\n+        }\n+    };\n+\n+    // Creates an object from any type of Node using the #fromNode factory method.\n+    private static final ObjectCreatorFactory FROM_NODE_CREATOR = (nodeType, target) -> {\n+        for (Method method : target.getMethods()) {\n+            if ((method.getName().equals(\"fromNode\"))\n+                    && target.isAssignableFrom(method.getReturnType())\n+                    && method.getParameters().length == 1\n+                    && Node.class.isAssignableFrom(method.getParameters()[0].getType())\n+                    && Modifier.isStatic(method.getModifiers())) {\n+                return (node, targetType, paramType, pointer, mapper) -> {\n+                    try {\n+                        return method.invoke(null, node);\n+                    } catch (ReflectiveOperationException e) {\n+                        String message = \"Unable to deserialize Node using fromNode method: \" + getCauseMessage(e);\n+                        throw NodeDeserializationException.fromReflectiveContext(targetType, pointer, node, e, message);\n+                    }\n+                };\n+            }\n+        }\n+        return null;\n+    };\n+\n+    static final class BeanMapper {\n+        private static final ConcurrentMap<Pair<Class<?>, String>, Pair<Method, Class>> SETTER_CACHE\n+                = new ConcurrentHashMap<>();\n+\n+        static void apply(\n+                Object value,\n+                Node node,\n+                Class<?> target,\n+                String pointer,\n+                NodeMapper mapper\n+        ) throws ReflectiveOperationException {\n+            for (Map.Entry<String, Node> entry : node.expectObjectNode().getStringMap().entrySet()) {\n+                Pair<Method, Class> setterPair = findSetter(target, entry.getKey());\n+                if (setterPair == null) {\n+                    mapper.getWhenMissingSetter().handle(target, pointer, entry.getKey(), entry.getValue());\n+                } else {\n+                    Method method = setterPair.getLeft();\n+                    Class parameterizedType = setterPair.getRight();\n+                    Object member = mapper.deserializeNext(\n+                            entry.getValue(),\n+                            pointer + \"/\" + entry.getKey(),\n+                            method.getParameters()[0].getType(),\n+                            parameterizedType,\n+                            mapper);\n+                    method.invoke(value, member);\n+                }\n+            }\n+        }\n+\n+        // Return value is null or a pair of (the method to invoke, the generic collection parameter).\n+        private static Pair<Method, Class> findSetter(Class<?> type, String memberName) {\n+            return SETTER_CACHE.computeIfAbsent(Pair.of(type, memberName), pair -> {\n+                String sanitized = sanitizePropertyName(pair.right);\n+                if (sanitized == null) {\n+                    return null;\n+                }\n+                Class target = pair.left;\n+                for (Method method : target.getMethods()) {\n+                    if (isRightKindOfMethod(method)) {\n+                        if (isBeanSetter(method, sanitized) || isBuilderSetter(method, target, sanitized)) {\n+                            Class parameterizedType = determineParameterizedType(method);\n+                            return Pair.of(method, parameterizedType);\n+                        }\n+                    }\n+                }\n+                return null;\n+            });\n+        }\n+\n+        // Strips special characters by removing special characters and converting the character\n+        // after each special character to camel case (e.g., blah.blerg becomes \"blahBlerg\").\n+        private static String sanitizePropertyName(String value) {\n+            StringBuilder result = new StringBuilder(value.length());\n+            boolean nextUpper = false;\n+            for (int i = 0; i < value.length(); i++) {\n+                char c = value.charAt(i);\n+                if (!Character.isJavaIdentifierPart(c)) {\n+                    // Shy away from fixing things like \"foo..bar\". At least for now.\n+                    if (nextUpper) {\n+                        return null;\n+                    }\n+                    nextUpper = true;\n+                } else if (nextUpper) {\n+                    nextUpper = false;\n+                    result.append(Character.toUpperCase(c));\n+                } else {\n+                    result.append(c);\n+                }\n+            }\n+            return result.toString();\n+        }\n+\n+        private static boolean isRightKindOfMethod(Method method) {\n+            return method.getParameters().length == 1 && !Modifier.isStatic(method.getModifiers());\n+        }\n+\n+        private static boolean isBeanSetter(Method method, String propertyName) {\n+            String setterName = \"set\" + StringUtils.capitalize(propertyName);\n+            return method.getName().equals(setterName) && method.getReturnType().equals(void.class);\n+        }\n+\n+        private static boolean isBuilderSetter(Method method, Class<?> type, String propertyName) {\n+            return method.getName().equals(propertyName) && type == method.getReturnType();\n+        }\n+\n+        private static Class<?> determineParameterizedType(Method setter) {\n+            Type genericParameters = setter.getGenericParameterTypes()[0];\n+            Class<?> containingType = setter.getParameterTypes()[0];\n+\n+            if (genericParameters instanceof ParameterizedType) {\n+                Type[] parameterArgTypes = ((ParameterizedType) genericParameters).getActualTypeArguments();\n+                if (isSupportedCollectionType(containingType, parameterArgTypes)) {\n+                    // Return the collection value type.\n+                    return resolveClassFromType(parameterArgTypes[0]);\n+                } else if (isSupportedMapType(containingType, parameterArgTypes)) {\n+                    // Return the Map value type.\n+                    return resolveClassFromType(parameterArgTypes[1]);\n+                }\n+            }\n+\n+            return Object.class;\n+        }\n+\n+        private static boolean isSupportedCollectionType(Class<?> containingType, Type[] parameterArgTypes) {\n+            return parameterArgTypes.length == 1\n+                   && Collection.class.isAssignableFrom(containingType);\n+        }\n+\n+        private static boolean isSupportedMapType(Class<?> containingType, Type[] parameterArgTypes) {\n+            return parameterArgTypes.length == 2\n+                   && Map.class.isAssignableFrom(containingType)\n+                   && parameterArgTypes[0] == String.class;\n+        }\n+\n+        // These are the kinds of types that can come back.\n+        // This was informed by various other mappers, including jackson-jr:\n+        // https://github.com/FasterXML/jackson-jr/blob/ac845b88702a1f1b1b5a75a4791b08577f74e94d/jr-objects/src/main/java/com/fasterxml/jackson/jr/type/TypeResolver.java#L79\n+        private static Class<?> resolveClassFromType(Type type) {\n+            if (type instanceof Class) {\n+                return (Class) type;\n+            } else if (type instanceof ParameterizedType) {\n+                return (Class) ((ParameterizedType) type).getRawType();\n+            } else if (type instanceof WildcardType) {\n+                return resolveClassFromType(((WildcardType) type).getUpperBounds()[0]);\n+            } else if (type instanceof TypeVariable<?>) {\n+                throw new IllegalArgumentException(\"TypeVariable targets are not implemented: \" + type);\n+            } else if (type instanceof GenericArrayType) {\n+                throw new IllegalArgumentException(\"GenericArrayType targets are not implemented: \" + type);\n+            } else {\n+                throw new IllegalArgumentException(\"Unable to determine target Class from \" + type);\n+            }\n+        }\n+    }\n+\n+    // Creates an object from any type of Node using the #builder factory method.\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ObjectCreatorFactory FROM_BUILDER_CREATOR = (nodeType, target) -> {\n+        if (nodeType != NodeType.OBJECT) {\n+            return null;\n+        }\n+\n+        for (Method method : target.getMethods()) {\n+            if ((method.getName().equals(\"builder\"))\n+                    && SmithyBuilder.class.isAssignableFrom(method.getReturnType())\n+                    && method.getParameters().length == 0\n+                    && Modifier.isStatic(method.getModifiers())) {\n+                method.setAccessible(true);\n+                return (node, targetType, paramType, pointer, mapper) -> {\n+                    try {\n+                        SmithyBuilder<Object> builder = ((SmithyBuilder<Object>) method.invoke(null));\n+                        BeanMapper.apply(builder, node, builder.getClass(), pointer, mapper);\n+                        applySourceLocation(builder, node);\n+                        return builder.build();\n+                    } catch (ReflectiveOperationException e) {\n+                        String message = \"Unable to deserialize Node using a builder: \" + getCauseMessage(e);\n+                        throw NodeDeserializationException.fromReflectiveContext(targetType, pointer, node, e, message);\n+                    }\n+                };\n+            }\n+        }\n+        return null;\n+    };\n+\n+    private static void applySourceLocation(Object object, FromSourceLocation sourceLocation)\n+            throws ReflectiveOperationException {\n+        Pair<Method, Class> setter = BeanMapper.findSetter(object.getClass(), \"sourceLocation\");\n+        if (setter != null) {\n+            setter.left.invoke(object, sourceLocation.getSourceLocation());\n+        }\n+    }\n+\n+    // Attempts to create a Bean style POJO using a zero-value constructor.\n+    private static final ObjectCreatorFactory BEAN_CREATOR = (nodeType, target) -> {\n+        if (nodeType != NodeType.OBJECT) {\n+            return null;\n+        }\n+\n+        try {\n+            // TODO: we could potentially add support for this if it's not too complicated.\n+            if (target.getEnclosingClass() != null && !Modifier.isStatic(target.getModifiers())) {\n+                throw new NodeDeserializationException(\n+                        \"Cannot create non-static inner class: \" + target.getCanonicalName(), SourceLocation.NONE);\n+            }\n+\n+            Constructor<?> ctor = target.getDeclaredConstructor();\n+            ctor.setAccessible(true);\n+\n+            return (node, targetType, parameterizedType, pointer, mapper) -> {\n+                try {\n+                    Object value = ctor.newInstance();\n+                    BeanMapper.apply(value, node, targetType, pointer, mapper);\n+                    applySourceLocation(value, node);\n+                    return value;\n+                } catch (ReflectiveOperationException e) {\n+                    throw NodeDeserializationException.fromReflectiveContext(targetType, pointer, node, e,\n+                            \"Unable to deserialize a Node when invoking target constructor: \" + getCauseMessage(e));\n+                }\n+            };\n+        } catch (NoSuchMethodException e) {\n+            // Don't fail, and instead try the next deserializer.\n+            return null;\n+        }\n+    };\n+\n+    // Creates enums by checking each enum variant and detecting if the result of\n+    // calling toString on the variant matches the given string.\n+    // Mimic's Jackson's behavior when using READ_ENUMS_USING_TO_STRING\n+    // See https://github.com/FasterXML/jackson-databind/wiki/Deserialization-Features\n+    private static final ObjectCreatorFactory ENUM_CREATOR = (nodeType, target) -> {\n+        if (nodeType != NodeType.STRING || !Enum.class.isAssignableFrom(target)) {\n+            return null;\n+        }\n+\n+        return (node, targetType, parameterizedType, pointer, mapper) -> {\n+            String name = node.expectStringNode().getValue();\n+            for (Object constant : targetType.getEnumConstants()) {\n+                if (constant.toString().equals(name)) {\n+                    return constant;\n+                }\n+            }\n+\n+            // Give an error message with suggestions.\n+            List<String> names = new ArrayList<>();\n+            for (Object constant : targetType.getEnumConstants()) {\n+                names.add(constant.toString());\n+            }\n+\n+            throw NodeDeserializationException.fromContext(targetType, pointer, node, null,\n+                    \"Expected one of the following enum strings: \" + names);\n+        };\n+    };\n+\n+    private interface FromStringClassFactory {\n+        Object create(String input) throws Exception;\n+    }\n+\n+    // These types have special, built-in handling.\n+    // This mirrors the simpler behaviors allowed in Jackson.\n+    // See https://github.com/FasterXML/jackson-databind/blob/ab583fb2319ee33ef6b548b720afec84265d40a7/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n+    private static final Map<Class, FromStringClassFactory> FROM_STRING_CLASSES = MapUtils.of(\n+            URL.class, URL::new,\n+            URI.class, URI::new,\n+            Pattern.class, Pattern::compile,\n+            Path.class, Paths::get,\n+            File.class, File::new\n+    );\n+\n+    private static final ObjectCreatorFactory FROM_STRING = (nodeType, target) -> {\n+        if (nodeType != NodeType.STRING || !FROM_STRING_CLASSES.containsKey(target)) {\n+            return null;\n+        }\n+\n+        FromStringClassFactory factory = FROM_STRING_CLASSES.get(target);\n+        return (node, targetType, parameterizedType, pointer, mapper) -> {\n+            String value = node.expectStringNode().getValue();\n+            try {\n+                return factory.create(value);\n+            } catch (Exception e) {\n+                throw NodeDeserializationException.fromContext(\n+                        targetType, pointer, node, e, e.getMessage());\n+            }\n+        };\n+    };\n+\n+    private static final List<ObjectCreatorFactory> DEFAULT_FACTORIES = ListUtils.of(", "originalCommit": "ae738e8b54359d9455bbac9b37cde893cf99b658", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkzODQ5NQ==", "url": "https://github.com/awslabs/smithy/pull/301#discussion_r387938495", "bodyText": "Minor: would be nice to know what determined this priority for any future updating.", "author": "kstich", "createdAt": "2020-03-04T21:15:19Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/node/DefaultNodeSerializers.java", "diffHunk": "@@ -0,0 +1,383 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.node;\n+\n+import static software.amazon.smithy.model.node.NodeMapper.Serializer;\n+\n+import java.io.File;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.logging.Logger;\n+import java.util.regex.Pattern;\n+import software.amazon.smithy.model.FromSourceLocation;\n+import software.amazon.smithy.model.SourceLocation;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * The default implementations use to convert Objects to Node values in {@link NodeMapper}.\n+ */\n+final class DefaultNodeSerializers {\n+\n+    private static final Logger LOGGER = Logger.getLogger(DefaultNodeSerializers.class.getName());\n+\n+    // Serialize the result of calling the ToNode#toNode method of an object.\n+    private static final Serializer<ToNode> TO_NODE_SERIALIZER = new Serializer<ToNode>() {\n+        @Override\n+        public Class<ToNode> getType() {\n+            return ToNode.class;\n+        }\n+\n+        @Override\n+        public Node serialize(ToNode value, Set<Object> serializedObjects, NodeMapper mapper) {\n+            return value.toNode();\n+        }\n+    };\n+\n+    // Serialize the value contained in an Optional if present, or a NullNode if not present.\n+    private static final Serializer<Optional> OPTIONAL_SERIALIZER = new Serializer<Optional>() {\n+        @Override\n+        public Class<Optional> getType() {\n+            return Optional.class;\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public Node serialize(Optional value, Set<Object> serializedObjects, NodeMapper mapper) {\n+            return (Node) value.map(v -> mapper.serialize(v, serializedObjects)).orElse(Node.nullNode());\n+        }\n+    };\n+\n+    // Serialize a Number into a NumberNode.\n+    private static final Serializer<Number> NUMBER_SERIALIZER = new Serializer<Number>() {\n+        @Override\n+        public Class<Number> getType() {\n+            return Number.class;\n+        }\n+\n+        @Override\n+        public Node serialize(Number value, Set<Object> serializedObjects, NodeMapper mapper) {\n+            return Node.from(value);\n+        }\n+    };\n+\n+    // Serialize a String into a StringNode.\n+    private static final Serializer<String> STRING_SERIALIZER = new Serializer<String>() {\n+        @Override\n+        public Class<String> getType() {\n+            return String.class;\n+        }\n+\n+        @Override\n+        public Node serialize(String value, Set<Object> serializedObjects, NodeMapper mapper) {\n+            return Node.from(value);\n+        }\n+    };\n+\n+    // Serializes File instances.\n+    private static final Serializer<File> FILE_SERIALIZER = new Serializer<File>() {\n+        @Override\n+        public Class<File> getType() {\n+            return File.class;\n+        }\n+\n+        @Override\n+        public Node serialize(File value, Set<Object> serializedObjects, NodeMapper mapper) {\n+            return Node.from(value.getAbsolutePath());\n+        }\n+    };\n+\n+    // Serializes Path instances.\n+    private static final Serializer<Path> PATH_SERIALIZER = new Serializer<Path>() {\n+        @Override\n+        public Class<Path> getType() {\n+            return Path.class;\n+        }\n+\n+        @Override\n+        public Node serialize(Path value, Set<Object> serializedObjects, NodeMapper mapper) {\n+            return Node.from(value.toUri().toString());\n+        }\n+    };\n+\n+    private static final class ToStringSerializer<T> implements Serializer<T> {\n+        private Class<T> type;\n+\n+        ToStringSerializer(Class<T> type) {\n+            this.type = type;\n+        }\n+\n+        @Override\n+        public Class<T> getType() {\n+            return type;\n+        }\n+\n+        @Override\n+        public Node serialize(T value, Set<Object> serializedObjects, NodeMapper mapper) {\n+            return Node.from(value.toString());\n+        }\n+    }\n+\n+    private static final Serializer<ShapeId> SHAPE_ID_SERIALIZER = new ToStringSerializer<>(ShapeId.class);\n+\n+    // Mirror's Jackson's behavior of WRITE_ENUMS_USING_TO_STRING\n+    // See https://github.com/FasterXML/jackson-databind/wiki/Serialization-features\n+    private static final Serializer<Enum> ENUM_SERIALIZER = new ToStringSerializer<>(Enum.class);\n+\n+    // Mirror's a subset of Jackson's behavior.\n+    // See https://github.com/FasterXML/jackson-databind/blob/62c9d3dfe4b512380fdb7cfb38f6f9a0204f0c1a/src/main/java/com/fasterxml/jackson/databind/ser/std/StringLikeSerializer.java\n+    private static final Serializer<URL> URL_SERIALIZER = new ToStringSerializer<>(URL.class);\n+    private static final Serializer<URI> URI_SERIALIZER = new ToStringSerializer<>(URI.class);\n+    private static final Serializer<Pattern> PATTERN_SERIALIZER = new ToStringSerializer<>(Pattern.class);\n+\n+    // Serialize a Boolean/boolean into a BooleanNode.\n+    private static final Serializer<Boolean> BOOLEAN_SERIALIZER = new Serializer<Boolean>() {\n+        @Override\n+        public Class<Boolean> getType() {\n+            return Boolean.class;\n+        }\n+\n+        @Override\n+        public Node serialize(Boolean value, Set<Object> serializedObjects, NodeMapper mapper) {\n+            return Node.from(value);\n+        }\n+    };\n+\n+    // Serialize a Map into an ObjectNode.\n+    private static final Serializer<Map> MAP_SERIALIZER = new Serializer<Map>() {\n+        @Override\n+        public Class<Map> getType() {\n+            return Map.class;\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public Node serialize(Map value, Set<Object> serializedObjects, NodeMapper mapper) {\n+            Map<StringNode, Node> mappings = new HashMap<>();\n+            Set<Map.Entry<Object, Object>> entries = (Set<Map.Entry<Object, Object>>) value.entrySet();\n+\n+            // Iterate over the map entries and populate map entries for an ObjectNode.\n+            for (Map.Entry<Object, Object> entry : entries) {\n+                // Serialize the key and require that it is serialized as a StringNode.\n+                Node key = mapper.serialize(entry.getKey(), serializedObjects);\n+                if (key instanceof StringNode) {\n+                    mappings.put((StringNode) key, mapper.serialize(entry.getValue(), serializedObjects));\n+                } else {\n+                    throw new NodeSerializationException(\n+                            \"Unable to write Map key because it was not serialized as a string: \"\n+                            + entry.getKey() + \" -> \" + Node.printJson(key));\n+                }\n+            }\n+\n+            return new ObjectNode(mappings, SourceLocation.NONE);\n+        }\n+    };\n+\n+    // Serialize the elements of an Iterable into an ArrayNode.\n+    private static final Serializer<Iterable> ITERABLE_SERIALIZER = new Serializer<Iterable>() {\n+        @Override\n+        public Class<Iterable> getType() {\n+            return Iterable.class;\n+        }\n+\n+        @Override\n+        public Node serialize(Iterable value, Set<Object> serializedObjects, NodeMapper mapper) {\n+            List<Node> nodes = new ArrayList<>();\n+            for (Object item : value) {\n+                nodes.add(mapper.serialize(item, serializedObjects));\n+            }\n+            return new ArrayNode(nodes, SourceLocation.NONE);\n+        }\n+    };\n+\n+    // Serialize an array of values into an ArrayNode.\n+    private static final Serializer<Object[]> ARRAY_SERIALIZER = new Serializer<Object[]>() {\n+        @Override\n+        public Class<Object[]> getType() {\n+            return Object[].class;\n+        }\n+\n+        @Override\n+        public Node serialize(Object[] value, Set<Object> serializedObjects, NodeMapper mapper) {\n+            List<Node> nodes = new ArrayList<>();\n+            for (Object item : value) {\n+                nodes.add(mapper.serialize(item, serializedObjects));\n+            }\n+            return new ArrayNode(nodes, SourceLocation.NONE);\n+        }\n+    };\n+\n+    /**\n+     * Contains the getters of a class that are eligible to convert to a Node.\n+     *\n+     * <p>Getters are public methods that take zero arguments and start with\n+     * \"get\" or \"is\". Getters that are associated with properties marked as\n+     * {@code transient} are not serialized.\n+     */\n+    private static final class ClassInfo {\n+        // Cache previously evaluated objects.\n+        private static final ConcurrentMap<Class, ClassInfo> CACHE = new ConcurrentHashMap<>();\n+\n+        // Methods aren't returned normally in any particular order, so give them an order.\n+        final Map<String, Method> getters = new TreeMap<>(String::compareToIgnoreCase);\n+\n+        static ClassInfo fromClass(Class<?> type) {\n+            return CACHE.computeIfAbsent(type, klass -> {\n+                ClassInfo info = new ClassInfo();\n+                Set<String> transientFields = getTransientFields(klass);\n+                // Determine which methods are getters that aren't backed by transient properties.\n+                for (Method method : klass.getMethods()) {\n+                    // Ignore Object.class, getSourceLocation, etc.\n+                    if (isIgnoredMethod(klass, method)) {\n+                        continue;\n+                    }\n+                    int fieldPrefixChars = getGetterPrefixCharCount(method);\n+                    // If the method starts with the parsed prefix characters, then check if it's transient.\n+                    if (fieldPrefixChars > 0 && fieldPrefixChars != method.getName().length()) {\n+                        // Always normalize as the lowercase name (i.e., \"getFoo\" -> \"foo\").\n+                        String lowerFieldName = StringUtils.uncapitalize(method.getName().substring(fieldPrefixChars));\n+                        if (!transientFields.contains(lowerFieldName)) {\n+                            info.getters.put(lowerFieldName, method);\n+                        } else {\n+                            LOGGER.fine(klass.getName() + \" getter \" + method.getName() + \" is transient\");\n+                        }\n+                    }\n+                }\n+                LOGGER.fine(() -> \"Detected the following getters for \" + klass.getName() + \": \" + info.getters);\n+                return info;\n+            });\n+        }\n+\n+        private static boolean isIgnoredMethod(Class<?> klass, Method method) {\n+            // Ignore Object.class methods.\n+            if (method.getDeclaringClass() == Object.class) {\n+                return true;\n+            }\n+            // Special casing for ignore getSourceLocation.\n+            // Does this need to be made more generic?\n+            if (FromSourceLocation.class.isAssignableFrom(klass) && method.getName().equals(\"getSourceLocation\")) {\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private static Set<String> getTransientFields(Class klass) {\n+            Set<String> transientFields = new HashSet<>();\n+            for (Field field : klass.getDeclaredFields()) {\n+                if (Modifier.isTransient(field.getModifiers())) {\n+                    // Normalize field names to lowercase the first character.\n+                    transientFields.add(StringUtils.uncapitalize(field.getName()));\n+                }\n+            }\n+            return transientFields;\n+        }\n+\n+        private static int getGetterPrefixCharCount(Method method) {\n+            // Don't use static methods, or methods with arguments.\n+            if (!Modifier.isStatic(method.getModifiers()) && method.getParameterCount() == 0) {\n+                if (method.getName().startsWith(\"get\")) {\n+                    return 3;\n+                } else if (method.getName().startsWith(\"is\") && method.getReturnType() == boolean.class) {\n+                    return 2;\n+                }\n+            }\n+            return 0;\n+        }\n+    }\n+\n+    static final Serializer<Object> FROM_BEAN = new Serializer<Object>() {\n+        @Override\n+        public Class<Object> getType() {\n+            return Object.class;\n+        }\n+\n+        @Override\n+        public Node serialize(Object value, Set<Object> serializedObjects, NodeMapper mapper) {\n+            if (serializedObjects.contains(value)) {\n+                return Node.nullNode();\n+            }\n+\n+            // Add the current value to the set.\n+            serializedObjects.add(value);\n+            Map<StringNode, Node> mappings = new HashMap<>();\n+            ClassInfo info = ClassInfo.fromClass(value.getClass());\n+\n+            for (Map.Entry<String, Method> entry : info.getters.entrySet()) {\n+                try {\n+                    Object getterResult = entry.getValue().invoke(value);\n+                    Node result = mapper.serialize(getterResult, serializedObjects);\n+                    if (mapper.getSerializeNullValues() || !result.isNullNode()) {\n+                        mappings.put(Node.from(entry.getKey()), result);\n+                    }\n+                } catch (ReflectiveOperationException e) {\n+                    // There's almost always a previous exception, so grab it's more useful message.\n+                    // If this isn't done, I observed that the message of ReflectiveOperationException is null.\n+                    String causeMessage = e.getCause() != null ? e.getCause().getMessage() : e.getMessage();\n+                    String message = String.format(\n+                            \"Error serializing `%s` field of %s using %s(): %s\",\n+                            entry.getKey(),\n+                            value.getClass().getName(),\n+                            entry.getValue().getName(),\n+                            causeMessage);\n+                    throw new NodeSerializationException(message, e);\n+                }\n+            }\n+\n+            // Remove the current value from the set to ensure that it can be serialized\n+            // multiple times (like in a List<T>).\n+            serializedObjects.remove(value);\n+\n+            return new ObjectNode(mappings, SourceLocation.NONE);\n+        }\n+    };\n+\n+    // The priority-ordered list of default serializers.", "originalCommit": "ae738e8b54359d9455bbac9b37cde893cf99b658", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkzOTk0OQ==", "url": "https://github.com/awslabs/smithy/pull/301#discussion_r387939949", "bodyText": "s/int he/in the", "author": "kstich", "createdAt": "2020-03-04T21:18:25Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/node/NodeMapper.java", "diffHunk": "@@ -0,0 +1,466 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.node;\n+\n+import static java.lang.String.format;\n+\n+import java.io.File;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import java.util.regex.Pattern;\n+import software.amazon.smithy.model.SourceLocation;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+\n+/**\n+ * Serializes and deserializes Smithy {@code Node} values to/from objects.\n+ *\n+ * <p>This class <em>does not</em> serialize a {@code Node} value as a JSON\n+ * string. It converts Java Object values to and from {@code Node} values.\n+ * Use {@link Node#printJson(Node)} to serialize JSON strings from a\n+ * {@code Node} value.\n+ *\n+ * <p>When stable, we may add the ability to add custom serializers and\n+ * deserializers. Until then, there is no way to customize the serialization\n+ * and deserialization rules.\n+ */\n+public final class NodeMapper {\n+\n+    /**\n+     * Specifies the behavior of the mapper when attempting to deserialize an unknown property.\n+     */\n+    public enum WhenMissing {\n+        /**\n+         * Throws an exception when attempting to deserialize an unknown property.\n+         */\n+        FAIL {\n+            public void handle(Class<?> into, String pointer, String property, Node value) {\n+                String message = createMessage(property, pointer, into, value);\n+                throw new NodeDeserializationException(message, value.getSourceLocation());\n+            }\n+        },\n+\n+        /**\n+         * Warns when attempting to deserialize an unknown property.\n+         */\n+        WARN {\n+            public void handle(Class<?> into, String pointer, String property, Node value) {\n+                LOGGER.warning(createMessage(property, pointer, into, value));\n+            }\n+        };\n+\n+        /**\n+         * Invoked when an object property cannot be deserialized.\n+         *\n+         * @param into The value type being created.\n+         * @param pointer The JSON pointer to the type from the original node.\n+         * @param property The property that was unknown to the type.\n+         * @param value The Node being deserialized.\n+         */\n+        public abstract void handle(Class<?> into, String pointer, String property, Node value);\n+\n+        private static String createMessage(String property, String pointer, Class<?> into, Node node) {\n+            String location = node.getSourceLocation() == SourceLocation.NONE\n+                    ? \"\"\n+                    : \" \" + node.getSourceLocation().toString().trim();\n+            return format(\"Deserialization error at %s%s: unable to find setter method for `%s` on %s\",\n+                          getNormalizedPointer(pointer), location, property, into.getCanonicalName());\n+        }\n+    }\n+\n+    /**\n+     * Converts an object of type {@code T} into a {@code Node}.\n+     *\n+     * <p>This API is currently package-private until we're confident in the\n+     * implementation.\n+     *\n+     * @param <T> Type to convert into a {@code Node} value.\n+     */\n+    interface Serializer<T> {\n+        /**\n+         * Gets the type that this serializer handles.\n+         *\n+         * @return Returns the serialization type.\n+         */\n+        Class<T> getType();\n+\n+        /**\n+         * Converts an object of type {@code T} into a {@code Node}.\n+         *\n+         * @param value Value to convert into a {@code Node}.\n+         * @param serializedObjects Identity set used to track recursion.\n+         * @param mapper Mapper used to recursively serialize types.\n+         * @return Returns the serialized {@code Node} value.\n+         */\n+        Node serialize(T value, Set<Object> serializedObjects, NodeMapper mapper);\n+    }\n+\n+    /**\n+     * Creates objects from Node values for a specific type.\n+     */\n+    @FunctionalInterface\n+    interface ObjectCreator {\n+        /**\n+         * Creates an Object from the given {@code Node} into the given {@code target}.\n+         *\n+         * @param node Node to convert into {@code target}.\n+         * @param target Type to create.\n+         * @param param The nullable parametric type of a {@link Collection} or {@link Map}.\n+         * @param pointer The JSON pointer to the current serialization context.\n+         * @param mapper Mapper to invoke to recursively deserialize values.\n+         * @return Returns the created {@code target} instance.\n+         * @throws NodeDeserializationException when unable to deserialize a value.\n+         */\n+        Object create(Node node, Class<?> target, Class<?> param, String pointer, NodeMapper mapper);\n+    }\n+\n+    /**\n+     * Factory method used to create an {@link ObjectCreator} for a given\n+     * {@code NodeType} and target class.\n+     *\n+     * <p>This interface is introduced to allow for caching of the reflection\n+     * necessary to determine <em>how</em> to create the target type.\n+     */\n+    @FunctionalInterface\n+    interface ObjectCreatorFactory {\n+        /**\n+         * Returns an {@code ObjectCreator} used to create {@code target} from a\n+         * {@code Node} of type {@code nodeType}.\n+         *\n+         * @param nodeType Node type being converted.\n+         * @param target The class to create from the Node.\n+         * @return Returns the {@code ObjectCreator} or {@code null} if the factory cannot handle the given arguments.\n+         * @throws NodeDeserializationException when unable to create a factory.\n+         */\n+        ObjectCreator getCreator(NodeType nodeType, Class<?> target);\n+    }\n+\n+    private static final Logger LOGGER = Logger.getLogger(NodeMapper.class.getName());\n+    private boolean serializeNullValues = false;\n+    private WhenMissing whenMissing = WhenMissing.WARN;\n+\n+    private final List<Serializer> serializers = DefaultNodeSerializers.SERIALIZERS;\n+    private final ObjectCreatorFactory creatorFactory = DefaultNodeDeserializers.DEFAULT_CACHED_CREATOR;\n+\n+    /**\n+     * Specifies if {@code null} values returned from getters are serialized.\n+     *\n+     * @param serializeNullValues Set to true to serialize {@code null} values.\n+     */\n+    public void setSerializeNullValues(boolean serializeNullValues) {\n+        this.serializeNullValues = serializeNullValues;\n+    }\n+\n+    /**\n+     * @return Gets whether or not {@code null} values are serialized.\n+     */\n+    public boolean getSerializeNullValues() {\n+        return serializeNullValues;\n+    }\n+\n+    /**\n+     * Sets the behavior of the deserializer when a setting is missing.\n+     *\n+     * @param whenMissing Behavior when a property is not matched to a setter.\n+     */\n+    public void setWhenMissingSetter(WhenMissing whenMissing) {\n+        this.whenMissing = Objects.requireNonNull(whenMissing);\n+    }\n+\n+    /**\n+     * @return Gets the behavior of the deserializer when a setting is missing.\n+     */\n+    public WhenMissing getWhenMissingSetter() {\n+        return whenMissing;\n+    }\n+\n+    /**\n+     * Serializes the given {@code object} as a {@code Node}.\n+     *\n+     * <p>This method is able to serialize the following types in the\n+     * given evaluation order:\n+     *\n+     * <ol>\n+     *     <li>A {@code null} value is serialized as a {@link NullNode} if {@link #getSerializeNullValues()}\n+     *     returns {@code true}.\n+     *     </li>\n+     *     <li>Instances of {@link ToNode} will return the result of calling {@link ToNode#toNode()}.\n+     *     </li>\n+     *     <li>Instances of {@link Optional} will serialize a {@link NullNode} when the Optional is empty, or\n+     *     the result of serializing the value contained in the {@code Optional} when present.\n+     *     </li>\n+     *     <li>{@link String} value is serialized as a {@link StringNode}.\n+     *     </li>\n+     *     <li>{@link Boolean} value or {@code boolean} is serialized as a {@link BooleanNode}.\n+     *     </li>\n+     *     <li>Any instance of {@link Number} value is serialized as a {@link NumberNode}.\n+     *     </li>\n+     *     <li>The {@code toString} method is called when {@link URL}, {@link URI}, {@link Pattern}, and\n+     *     {@link Path} are serialized.\n+     *     </li>\n+     *     <li>A {@link File} is serialized by serializing the string value of {@link File#toURI()}.\n+     *     </li>\n+     *     <li>{@link Enum} value is serialized as a {@link StringNode} by calling its {@code toString} method.\n+     *     <li>{@link ShapeId} is serialized as a {@link StringNode} that contains the absolute shape ID.\n+     *     </li>\n+     *     <li>Any instance of a {@link Map} is supported as long as the key and value of the map are both\n+     *     supported types (note that Map keys must serialize as StringNode). A {@code Map} is converted to\n+     *     an {@link ObjectNode}.\n+     *     </li>\n+     *     <li>Any instance of a {@link Iterable} is supported as long as the value contained in the\n+     *     {@code Iterable} is a supported type. An {@code Iterable} is converted to an {@link ArrayNode}.\n+     *     An {@code Iterable} broadly covers many Java types, including {@link Collection}.\n+     *     </li>\n+     *     <li>Primitive arrays are converted to an {@code ArrayNode} if and only if the values contained in the\n+     *     array are one of the supported types supported by the serializer.\n+     *     </li>\n+     *     <li>Finally, an object is serialized using Bean style semantics; any public getter\n+     *     (get* or is* method with no arguments) is invoked and it's return value is put in the {@link ObjectNode}.\n+     *     Each property of the Bean recursively invokes the serializer and must be one of the supported types.\n+     *     Properties associated with a getter that are marked as {@code transient} are not serialized (where an\n+     *     \"association\" is defined as a class field with the same lowercase name as the suffix of the getter\n+     *     method). For example, given a method \"getFoo\", both \"foo\" and \"Foo\" are checked as associated\n+     *     property names.\n+     *     </li>\n+     * </ol>\n+     *\n+     * @param object Object to serialize.\n+     * @return Returns the serialized {@code Node}.\n+     * @throws NodeSerializationException on error.\n+     */\n+    public Node serialize(Object object) {\n+        return serialize(object, Collections.newSetFromMap(new IdentityHashMap<>()));\n+    }\n+\n+    /**\n+     * Serializes the given {@code object} as a {@code Node}.\n+     *\n+     * <p>This method is used when serializing values recursively from another serializer.\n+     *\n+     * @param object Object to serialize.\n+     * @param serializedObject An identity set of objects that have already been serialized.\n+     *   This prevents infinite recursion on a self-referencing value.\n+     * @return Returns the serialized {@code Node}.\n+     * @throws NodeSerializationException on error.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    Node serialize(Object object, Set<Object> serializedObject) {\n+        if (object == null) {\n+            return Node.nullNode();\n+        }\n+\n+        // Iterate over the serializers in the correct order.\n+        for (Serializer serializer : serializers) {\n+            if (serializer.getType().isInstance(object)) {\n+                return serializer.serialize(object, serializedObject, this);\n+            }\n+        }\n+\n+        // Finally, attempt to serialize using bean conventions.\n+        return DefaultNodeSerializers.FROM_BEAN.serialize(object, serializedObject, this);\n+    }\n+\n+    /**\n+     * Deserialize a Node {@code value} into an instance of {@code T}.\n+     *\n+     * <p>This method can deserialize various kinds of values depending on the given\n+     * node type and the target type:\n+     *\n+     * <ol>\n+     *     <li>{@code null}</li>\n+     *     <li>String</li>\n+     *     <li>Primitive and boxed booleans</li>\n+     *     <li>Primitive and boxed {@link Number} types</li>\n+     *     <li>Lists and Sets of any support value</li>\n+     *     <li>Maps with String keys and values of any supported type</li>\n+     *     <li>Direct {@link Node} to {@code Node} conversions.</li>\n+     *     <li>Any object that has a public static {@code fromNode} method that accepts a\n+     *     {@link Node} and returns an instance of the object.</li>\n+     *     <li>Strings are deserialized to enums by finding the first enum value that has a {@code toString}\n+     *     method that matches the string value.</li>\n+     *     <li>Built-in support for URI, URL, Pattern, Path, and File</li>\n+     *     <li>When deserializing an object, any target object that provides a public static method named\n+     *     {@code builder} that returns an instance of {@link SmithyBuilder} is invoked, and the builder is then\n+     *     mutated using bean like setters (with an optional \"set\") prefix, until finally, the build method is\n+     *     called and its result is returned.</li>\n+     *     <li>When deserializing an object, the last thing tried is to find a public, zero-arg constructor,\n+     *     and then the object is mutated using bean-style setter conventions for each key-value pair.</li>\n+     *     <li>NodeMapper does not support non-static inner classes, classes with generic parameters, or\n+     *     generic arrays. Support for these may be added int he future.</li>", "originalCommit": "ae738e8b54359d9455bbac9b37cde893cf99b658", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b8a09005a0ac584937ebb6519d7181d234f5d789", "url": "https://github.com/awslabs/smithy/commit/b8a09005a0ac584937ebb6519d7181d234f5d789", "message": "Add Node object mapper\n\nA Node object mapper is a useful abstraction for refactoring how\nSmithyBuild transforms and plugins are implemented and simplifying\nthe definition of configurable validators. The NodeMapper is meant\nto be very simple: there's no annotations, there's currently no\nway to customize it beyond whether or not nulls are serialized and\nif it fails/warns when missing keys are deserialized. It handles\nthe serialization/deserialization of primitives, strings, collections,\nmaps, POJOs, File, Path, URI, URL, Enum, and a few other things. The\nway types are serialized and deserialized is meant to be compatible\nwith Jackson if we ever need to move over to it for whatever reason.\nCompatibility means that we could swap out the NodeMapper implementation\nin the future for Jackson or Jackson-JR if needed without breaking\nthe existing API. We can potentially open up the NodeMapper abstractions\nfor extension later, but that might lead us further away from Jackson\ncompatibility.\n\nWhy are we not just adding a dependency on Jackson? Mainly because it's\na ridiculously popular serialization library that spans lots of versions.\nAdding a dependency on Jackson would cause a headache for the Smithy team,\nservice teams, and build teams within Amazon trying to deal with\ndepenency version conflicts. While implementing an object mapper adds a\nlot of complexity and code to maintain, keeping dependencies minimal is\none of our primary project goals. Adding NodeMapper isn't a one-way door:\nwe can swap it out for Jackson databind in the future if needed.", "committedDate": "2020-03-04T22:24:47Z", "type": "commit"}, {"oid": "32eb2521a95973a20f328ad94cc1a5d46b13d8bd", "url": "https://github.com/awslabs/smithy/commit/32eb2521a95973a20f328ad94cc1a5d46b13d8bd", "message": "Use NodeMapper in configurable linters", "committedDate": "2020-03-04T22:25:16Z", "type": "commit"}, {"oid": "32eb2521a95973a20f328ad94cc1a5d46b13d8bd", "url": "https://github.com/awslabs/smithy/commit/32eb2521a95973a20f328ad94cc1a5d46b13d8bd", "message": "Use NodeMapper in configurable linters", "committedDate": "2020-03-04T22:25:16Z", "type": "forcePushed"}]}