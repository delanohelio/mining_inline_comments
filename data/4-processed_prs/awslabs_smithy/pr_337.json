{"pr_number": 337, "pr_title": "Add service closure name conflict validation", "pr_createdAt": "2020-03-31T17:23:08Z", "pr_url": "https://github.com/awslabs/smithy/pull/337", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwMDI3MA==", "url": "https://github.com/awslabs/smithy/pull/337#discussion_r401100270", "bodyText": "Should these be DANGER instead?", "author": "kstich", "createdAt": "2020-03-31T17:47:43Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/validation/validators/ServiceValidator.java", "diffHunk": "@@ -16,55 +16,210 @@\n package software.amazon.smithy.model.validation.validators;\n \n import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.stream.Collectors;\n import software.amazon.smithy.model.Model;\n-import software.amazon.smithy.model.knowledge.TopDownIndex;\n+import software.amazon.smithy.model.knowledge.NeighborProviderIndex;\n+import software.amazon.smithy.model.neighbor.Walker;\n+import software.amazon.smithy.model.shapes.CollectionShape;\n+import software.amazon.smithy.model.shapes.MemberShape;\n import software.amazon.smithy.model.shapes.ServiceShape;\n+import software.amazon.smithy.model.shapes.Shape;\n import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.ShapeType;\n+import software.amazon.smithy.model.shapes.SimpleShape;\n import software.amazon.smithy.model.validation.AbstractValidator;\n+import software.amazon.smithy.model.validation.Severity;\n import software.amazon.smithy.model.validation.ValidationEvent;\n import software.amazon.smithy.model.validation.ValidationUtils;\n+import software.amazon.smithy.utils.Pair;\n \n /**\n- * Validates that service shapes do not contain duplicate resource or\n- * operation shape names.\n+ * Validates that service closures do not contain duplicate case-insensitive\n+ * shape names.\n+ *\n+ * <p>This validator allows some kinds of conflicts when they are likely\n+ * inconsequential. Some classes of conflicts are permitted, and in those\n+ * cases a WARNING or NOTE is emitted. A conflict is permitted if the shapes\n+ * are the same type; the two shapes are either a simple shape, list, or set;\n+ * both shapes have the same exact traits; and both shapes have equivalent\n+ * members (that is, the members follow these same rules). Permitted conflicts\n+ * detected between simple shapes are emitted as a NOTE, permitted conflicts\n+ * detected on other shapes are emitted as a WARNING, forbidden conflicts\n+ * detected for an operation or resource are emitted as an ERROR, and all\n+ * other forbidden conflicts are emitted as DANGER.\n  */\n public class ServiceValidator extends AbstractValidator {\n \n     @Override\n     public List<ValidationEvent> validate(Model model) {\n-        TopDownIndex topDownIndex = model.getKnowledge(TopDownIndex.class);\n         return model.shapes(ServiceShape.class)\n-                .flatMap(shape -> validateService(topDownIndex, shape).stream())\n+                .flatMap(shape -> validateService(model, shape).stream())\n                 .collect(Collectors.toList());\n     }\n \n-    private List<ValidationEvent> validateService(TopDownIndex topDownIndex, ServiceShape shape) {\n-        List<ValidationEvent> events = new ArrayList<>();\n+    private List<ValidationEvent> validateService(Model model, ServiceShape service) {\n+        // Ensure that shapes bound to the service have unique shape names.\n+        Walker walker = new Walker(model.getKnowledge(NeighborProviderIndex.class).getProvider());\n+        Set<Shape> serviceClosure = walker.walkShapes(service);\n+        Map<String, List<ShapeId>> conflicts = ValidationUtils.findDuplicateShapeNames(serviceClosure);\n \n-        // Ensure that resources bound to the service have unique shape names.\n-        Map<String, List<ShapeId>> duplicateResourceNames = ValidationUtils.findDuplicateShapeNames(\n-                topDownIndex.getContainedResources(shape.getId()));\n-        if (!duplicateResourceNames.isEmpty()) {\n-            events.add(conflictingNames(shape, \"resources\", duplicateResourceNames));\n+        if (conflicts.isEmpty()) {\n+            return Collections.emptyList();\n         }\n \n-        // Ensure that operations bound to the service have unique shape names.\n-        Map<String, List<ShapeId>> duplicateOperationNames = ValidationUtils.findDuplicateShapeNames(\n-                topDownIndex.getContainedOperations(shape));\n-        if (!duplicateOperationNames.isEmpty()) {\n-            events.add(conflictingNames(shape, \"operations\", duplicateOperationNames));\n+        // Determine the severity of each conflict.\n+        ConflictDetector detector = new ConflictDetector(model);\n+        List<ValidationEvent> events = new ArrayList<>();\n+\n+        // Figure out if each conflict can be ignored, and then emit events for\n+        // both sides of the conflict using the appropriate severity.\n+        for (Map.Entry<String, List<ShapeId>> entry : conflicts.entrySet()) {\n+            List<ShapeId> ids = entry.getValue();\n+            for (int i = 0; i < ids.size(); i++) {\n+                Shape subject = model.expectShape(ids.get(i));\n+                for (int j = 0; j < ids.size(); j++) {\n+                    if (i != j) {\n+                        Shape other = model.expectShape(ids.get(j));\n+                        Severity severity = detector.detect(subject, other);\n+                        if (severity != null) {\n+                            events.add(conflictingNames(severity, service, subject, other));\n+                            events.add(conflictingNames(severity, service, other, subject));\n+                        }\n+                    }\n+                }\n+            }\n         }\n \n         return events;\n     }\n \n-    private ValidationEvent conflictingNames(ServiceShape shape, String descriptor, Map<String, List<ShapeId>> dupes) {\n-        return error(shape, String.format(\n-                \"All %s contained within a service hierarchy must have case-insensitively unique names regardless of \"\n-                + \"their namespaces. The following %s were found in this service to have conflicting names: %s\",\n-                descriptor, descriptor, dupes));\n+    private ValidationEvent conflictingNames(Severity severity, ServiceShape shape, Shape subject, Shape other) {\n+        // Whether it's a should or a must based on the severity.\n+        String declaration = severity == Severity.DANGER || severity == Severity.ERROR ? \"must\" : \"should\";\n+\n+        return ValidationEvent.builder()\n+                .eventId(getName())\n+                .severity(severity)\n+                .shape(subject)\n+                .message(String.format(\n+                        \"Shape name `%s` conflicts with `%s` in the `%s` service closure. Shapes in the closure \"\n+                        + \"of a service %s have case-insensitively unique names regardless of their namespaces.\",\n+                        subject.getId().getName(),\n+                        other.getId(),\n+                        shape.getId(),\n+                        declaration))\n+                .build();\n+    }\n+\n+    private static final class ConflictDetector {\n+\n+        private static final EnumMap<ShapeType, Severity> FORBIDDEN = new EnumMap<>(ShapeType.class);\n+\n+        static {\n+            // Service types are never allowed to conflict.\n+            FORBIDDEN.put(ShapeType.RESOURCE, Severity.ERROR);\n+            FORBIDDEN.put(ShapeType.OPERATION, Severity.ERROR);\n+            FORBIDDEN.put(ShapeType.SERVICE, Severity.ERROR);\n+            // These aggregate types are never allowed to conflict either, but\n+            // we will present the ability to suppress the violation if needed.\n+            FORBIDDEN.put(ShapeType.MAP, Severity.WARNING);", "originalCommit": "7b6bfe86bdcf8ffa01e85d99ba394e4daf32fc95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEyMjg2MQ==", "url": "https://github.com/awslabs/smithy/pull/337#discussion_r401122861", "bodyText": "Subtle tweak to the wording - \"These shapes in the closure...\" - to point that the sentence is referring to explicitly the listed shapes. I can foresee some reading the last part and being confused when encountering this taken from the test outputs, with one saying must and the other saying should worded to a general case:\n[DANGER] another.ns#ListC: Shape name `ListC` conflicts with `ns.foo#ListC` in the `ns.foo#MyService` service closure. Shapes in the closure of a service must have case-insensitively unique names regardless of their namespaces. | Service\n[NOTE] ns.foo#String: Shape name `String` conflicts with `smithy.api#String` in the `ns.foo#MyService` service closure. Shapes in the closure of a service should have case-insensitively unique names regardless of their namespaces. | Service", "author": "kstich", "createdAt": "2020-03-31T18:25:13Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/validation/validators/ServiceValidator.java", "diffHunk": "@@ -16,55 +16,210 @@\n package software.amazon.smithy.model.validation.validators;\n \n import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.stream.Collectors;\n import software.amazon.smithy.model.Model;\n-import software.amazon.smithy.model.knowledge.TopDownIndex;\n+import software.amazon.smithy.model.knowledge.NeighborProviderIndex;\n+import software.amazon.smithy.model.neighbor.Walker;\n+import software.amazon.smithy.model.shapes.CollectionShape;\n+import software.amazon.smithy.model.shapes.MemberShape;\n import software.amazon.smithy.model.shapes.ServiceShape;\n+import software.amazon.smithy.model.shapes.Shape;\n import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.ShapeType;\n+import software.amazon.smithy.model.shapes.SimpleShape;\n import software.amazon.smithy.model.validation.AbstractValidator;\n+import software.amazon.smithy.model.validation.Severity;\n import software.amazon.smithy.model.validation.ValidationEvent;\n import software.amazon.smithy.model.validation.ValidationUtils;\n+import software.amazon.smithy.utils.Pair;\n \n /**\n- * Validates that service shapes do not contain duplicate resource or\n- * operation shape names.\n+ * Validates that service closures do not contain duplicate case-insensitive\n+ * shape names.\n+ *\n+ * <p>This validator allows some kinds of conflicts when they are likely\n+ * inconsequential. Some classes of conflicts are permitted, and in those\n+ * cases a WARNING or NOTE is emitted. A conflict is permitted if the shapes\n+ * are the same type; the two shapes are either a simple shape, list, or set;\n+ * both shapes have the same exact traits; and both shapes have equivalent\n+ * members (that is, the members follow these same rules). Permitted conflicts\n+ * detected between simple shapes are emitted as a NOTE, permitted conflicts\n+ * detected on other shapes are emitted as a WARNING, forbidden conflicts\n+ * detected for an operation or resource are emitted as an ERROR, and all\n+ * other forbidden conflicts are emitted as DANGER.\n  */\n public class ServiceValidator extends AbstractValidator {\n \n     @Override\n     public List<ValidationEvent> validate(Model model) {\n-        TopDownIndex topDownIndex = model.getKnowledge(TopDownIndex.class);\n         return model.shapes(ServiceShape.class)\n-                .flatMap(shape -> validateService(topDownIndex, shape).stream())\n+                .flatMap(shape -> validateService(model, shape).stream())\n                 .collect(Collectors.toList());\n     }\n \n-    private List<ValidationEvent> validateService(TopDownIndex topDownIndex, ServiceShape shape) {\n-        List<ValidationEvent> events = new ArrayList<>();\n+    private List<ValidationEvent> validateService(Model model, ServiceShape service) {\n+        // Ensure that shapes bound to the service have unique shape names.\n+        Walker walker = new Walker(model.getKnowledge(NeighborProviderIndex.class).getProvider());\n+        Set<Shape> serviceClosure = walker.walkShapes(service);\n+        Map<String, List<ShapeId>> conflicts = ValidationUtils.findDuplicateShapeNames(serviceClosure);\n \n-        // Ensure that resources bound to the service have unique shape names.\n-        Map<String, List<ShapeId>> duplicateResourceNames = ValidationUtils.findDuplicateShapeNames(\n-                topDownIndex.getContainedResources(shape.getId()));\n-        if (!duplicateResourceNames.isEmpty()) {\n-            events.add(conflictingNames(shape, \"resources\", duplicateResourceNames));\n+        if (conflicts.isEmpty()) {\n+            return Collections.emptyList();\n         }\n \n-        // Ensure that operations bound to the service have unique shape names.\n-        Map<String, List<ShapeId>> duplicateOperationNames = ValidationUtils.findDuplicateShapeNames(\n-                topDownIndex.getContainedOperations(shape));\n-        if (!duplicateOperationNames.isEmpty()) {\n-            events.add(conflictingNames(shape, \"operations\", duplicateOperationNames));\n+        // Determine the severity of each conflict.\n+        ConflictDetector detector = new ConflictDetector(model);\n+        List<ValidationEvent> events = new ArrayList<>();\n+\n+        // Figure out if each conflict can be ignored, and then emit events for\n+        // both sides of the conflict using the appropriate severity.\n+        for (Map.Entry<String, List<ShapeId>> entry : conflicts.entrySet()) {\n+            List<ShapeId> ids = entry.getValue();\n+            for (int i = 0; i < ids.size(); i++) {\n+                Shape subject = model.expectShape(ids.get(i));\n+                for (int j = 0; j < ids.size(); j++) {\n+                    if (i != j) {\n+                        Shape other = model.expectShape(ids.get(j));\n+                        Severity severity = detector.detect(subject, other);\n+                        if (severity != null) {\n+                            events.add(conflictingNames(severity, service, subject, other));\n+                            events.add(conflictingNames(severity, service, other, subject));\n+                        }\n+                    }\n+                }\n+            }\n         }\n \n         return events;\n     }\n \n-    private ValidationEvent conflictingNames(ServiceShape shape, String descriptor, Map<String, List<ShapeId>> dupes) {\n-        return error(shape, String.format(\n-                \"All %s contained within a service hierarchy must have case-insensitively unique names regardless of \"\n-                + \"their namespaces. The following %s were found in this service to have conflicting names: %s\",\n-                descriptor, descriptor, dupes));\n+    private ValidationEvent conflictingNames(Severity severity, ServiceShape shape, Shape subject, Shape other) {\n+        // Whether it's a should or a must based on the severity.\n+        String declaration = severity == Severity.DANGER || severity == Severity.ERROR ? \"must\" : \"should\";\n+\n+        return ValidationEvent.builder()\n+                .eventId(getName())\n+                .severity(severity)\n+                .shape(subject)\n+                .message(String.format(\n+                        \"Shape name `%s` conflicts with `%s` in the `%s` service closure. Shapes in the closure \"", "originalCommit": "7b6bfe86bdcf8ffa01e85d99ba394e4daf32fc95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f664b8225d84f45c5aa1ac63a7c25826bb03ecda", "url": "https://github.com/awslabs/smithy/commit/f664b8225d84f45c5aa1ac63a7c25826bb03ecda", "message": "Add service closure name conflict validation\n\nThis commit validates and standardizes the behavior that has existed for\nmany years in AWS SDKs: requiring that shapes in the closure of a\nservice are case-insensitively unique regardless of their namespaces\n(with some exceptions for simple types and lists/sets). This change\nensures that SDK code gen does not need to persist the namespaces in\ntheir generated code, and that they can create their own\nnamespaced/siloed copies of shapes for each service (removing the need\nto publish and pull in dependencies on shared types).", "committedDate": "2020-03-31T19:48:00Z", "type": "commit"}, {"oid": "f664b8225d84f45c5aa1ac63a7c25826bb03ecda", "url": "https://github.com/awslabs/smithy/commit/f664b8225d84f45c5aa1ac63a7c25826bb03ecda", "message": "Add service closure name conflict validation\n\nThis commit validates and standardizes the behavior that has existed for\nmany years in AWS SDKs: requiring that shapes in the closure of a\nservice are case-insensitively unique regardless of their namespaces\n(with some exceptions for simple types and lists/sets). This change\nensures that SDK code gen does not need to persist the namespaces in\ntheir generated code, and that they can create their own\nnamespaced/siloed copies of shapes for each service (removing the need\nto publish and pull in dependencies on shared types).", "committedDate": "2020-03-31T19:48:00Z", "type": "forcePushed"}]}