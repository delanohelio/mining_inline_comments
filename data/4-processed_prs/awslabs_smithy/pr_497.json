{"pr_number": 497, "pr_title": "Refactor the spec to better explain the semantic model", "pr_createdAt": "2020-07-14T22:02:17Z", "pr_url": "https://github.com/awslabs/smithy/pull/497", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY3MzUxNA==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r454673514", "bodyText": "I consider this a bug since it's at odds with how literally every other value is resolved to a shape ID. There were two instances that used this in the prelude that were fixed. I did not see any other cases that would be affected by this in models that I sampled.", "author": "mtdowling", "createdAt": "2020-07-14T22:07:06Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/traits/TraitDefinition.java", "diffHunk": "@@ -158,12 +157,6 @@ public Builder selector(Selector selector) {\n \n         public Builder addConflict(String trait) {\n             Objects.requireNonNull(trait);\n-\n-            // Use absolute trait names.\n-            if (!trait.contains(\"#\")) {", "originalCommit": "bd819fc1d22fb627141f6a09a187940ad27c81d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMzIzOQ==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r454703239", "bodyText": "The title seems very vague, it's not clear which \"model\" you mean without qualification in the title.\n\nChange \"Smithy overview\" to \"Smithy framework\", which matches the figure caption\nChange \"Semantic model\" to \"The semantic model\"", "author": "johnstonskj", "createdAt": "2020-07-14T23:31:02Z", "path": "docs/source/1.0/spec/core/model.rst", "diffHunk": "@@ -1,223 +1,431 @@\n-.. _shapes:\n+.. _smithy-model:\n \n-======\n-Shapes\n-======\n+============\n+Smithy model", "originalCommit": "bd819fc1d22fb627141f6a09a187940ad27c81d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxNDY0NA==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r454714644", "bodyText": "The title seems very vague, it's not clear which \"model\" you mean without qualification in the title.\n\nHow about \"Smithy overview\"?", "author": "mtdowling", "createdAt": "2020-07-15T00:08:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMzIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5NTI0Mg==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455295242", "bodyText": "I kind of like calling this \"The Smithy model\" still, and making the first sentence something like:\n\nThe Smithy model describes the Smithy semantic model and the files used to create it. Smithy models are used to describe services and data structures.", "author": "mtdowling", "createdAt": "2020-07-15T19:37:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMzIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1MzEwOA==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455853108", "bodyText": "I dislike the overloading, but I can live with it", "author": "johnstonskj", "createdAt": "2020-07-16T14:59:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMzIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMzkzMA==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r454703930", "bodyText": "I would move away from using SVG, use PNG and consistent scaling as the changes in font size are distracting.", "author": "johnstonskj", "createdAt": "2020-07-14T23:33:12Z", "path": "docs/source/1.0/spec/core/model.rst", "diffHunk": "@@ -1,223 +1,431 @@\n-.. _shapes:\n+.. _smithy-model:\n \n-======\n-Shapes\n-======\n+============\n+Smithy model\n+============\n \n-*Shapes* are named data definitions that describe the structure of an API.\n-Shapes have a *type* that represents the type of values that a shape\n-represents. Types like ``string``, ``structure``, and ``operation`` represent\n-the kinds of shapes that can be used in a model, while shapes like\n-``MyString``, ``MyStructure``, and ``MyOperation`` define a referenceable\n-instance of a type.\n+This is the specification of Smithy, an interface definition language and set\n+of tools used to build clients, servers, and other kinds of artifacts through\n+model transformations. This specification is at version |release|.\n \n .. contents:: Table of contents\n     :depth: 1\n     :local:\n     :backlinks: none\n \n \n--------------\n-Shape section\n--------------\n-\n-The shape section of the IDL is used to define shapes and apply traits to\n-shapes. It comes after any :token:`control statements <control_section>` and\n-:token:`metadata statements <metadata_section>`.\n-\n-.. productionlist:: smithy\n-    shape_section :[`namespace_statement` [`use_section`] [`shape_statements`]]\n-\n-\n-.. _namespaces:\n-\n-Namespaces\n-==========\n+---------------------------------\n+Conventions used in this document\n+---------------------------------\n \n-Shapes are defined inside a :dfn:`namespace`. A namespace is mechanism for\n-logically grouping shapes in a way that makes them reusable alongside other\n-models without naming conflicts.\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n+\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n+document are to be interpreted as described in :rfc:`2119`.\n \n-.. _namespace-statement:\n+This specification makes use of the Augmented Backus-Naur Form (ABNF)\n+:rfc:`5234` notation, including the *core rules* defined in Appendix B\n+of that document.\n \n-Shapes can only be defined if a namespace is declared, and only a single\n-namespace can appear in an IDL model file.\n+Readers are invited to report technical errors and ambiguities in this\n+specification to the Smithy GitHub repository at https://github.com/awslabs/smithy.\n+This specification is open source, so contributions are welcome.\n \n-.. productionlist:: smithy\n-    namespace_statement :\"namespace\" `ws` `namespace` `br`\n+.. rubric:: Examples\n \n-The following example defines a string shape named ``MyString`` in the\n-``smithy.example`` namespace:\n+Unless declared otherwise, example Smithy models given in this specification\n+are written using the :ref:`Smithy interface definition language (IDL) <idl>`\n+syntax. Complementary :ref:`JSON AST <json-ast>` examples are provided\n+alongside Smithy IDL examples where appropriate. For example:\n \n .. tabs::\n \n     .. code-tab:: smithy\n \n+        $version: \"1.0\"\n+\n+        metadata foo = \"bar\"\n+\n         namespace smithy.example\n \n-        string MyString\n+        use smithy.other.namespace#MyString\n+\n+        structure MyStructure {\n+            @required\n+            foo: MyString\n+        }\n \n     .. code-tab:: json\n \n         {\n             \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"bar\"\n+            },\n             \"shapes\": {\n-                \"smithy.example#MyString\": {\n-                    \"type\": \"string\"\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.other.namespace#MyString\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n                 }\n             }\n         }\n \n \n-.. _use-statement:\n+.. _smithy-overview:\n+\n+---------------\n+Smithy overview\n+---------------\n+\n+Smithy is a framework that consists of a semantic model, file formats used to\n+define a model, and a build process used to validate models and facilitate\n+model transformations.\n+\n+.. figure:: images/smithy-overview.svg", "originalCommit": "bd819fc1d22fb627141f6a09a187940ad27c81d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcyMTc1OA==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r454721758", "bodyText": "With a little styling, text doesn't look bad...", "author": "mtdowling", "createdAt": "2020-07-15T00:34:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMzkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwMDIxOQ==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r454800219", "bodyText": "Updated to use text with some nice styling (via a custom Sphinx directive, no less!)", "author": "mtdowling", "createdAt": "2020-07-15T05:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMzkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNDg2Nw==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r454704867", "bodyText": "Outdent this, it seems odd to have a figure inside the bulleted list", "author": "johnstonskj", "createdAt": "2020-07-14T23:36:05Z", "path": "docs/source/1.0/spec/core/model.rst", "diffHunk": "@@ -1,223 +1,431 @@\n-.. _shapes:\n+.. _smithy-model:\n \n-======\n-Shapes\n-======\n+============\n+Smithy model\n+============\n \n-*Shapes* are named data definitions that describe the structure of an API.\n-Shapes have a *type* that represents the type of values that a shape\n-represents. Types like ``string``, ``structure``, and ``operation`` represent\n-the kinds of shapes that can be used in a model, while shapes like\n-``MyString``, ``MyStructure``, and ``MyOperation`` define a referenceable\n-instance of a type.\n+This is the specification of Smithy, an interface definition language and set\n+of tools used to build clients, servers, and other kinds of artifacts through\n+model transformations. This specification is at version |release|.\n \n .. contents:: Table of contents\n     :depth: 1\n     :local:\n     :backlinks: none\n \n \n--------------\n-Shape section\n--------------\n-\n-The shape section of the IDL is used to define shapes and apply traits to\n-shapes. It comes after any :token:`control statements <control_section>` and\n-:token:`metadata statements <metadata_section>`.\n-\n-.. productionlist:: smithy\n-    shape_section :[`namespace_statement` [`use_section`] [`shape_statements`]]\n-\n-\n-.. _namespaces:\n-\n-Namespaces\n-==========\n+---------------------------------\n+Conventions used in this document\n+---------------------------------\n \n-Shapes are defined inside a :dfn:`namespace`. A namespace is mechanism for\n-logically grouping shapes in a way that makes them reusable alongside other\n-models without naming conflicts.\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n+\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n+document are to be interpreted as described in :rfc:`2119`.\n \n-.. _namespace-statement:\n+This specification makes use of the Augmented Backus-Naur Form (ABNF)\n+:rfc:`5234` notation, including the *core rules* defined in Appendix B\n+of that document.\n \n-Shapes can only be defined if a namespace is declared, and only a single\n-namespace can appear in an IDL model file.\n+Readers are invited to report technical errors and ambiguities in this\n+specification to the Smithy GitHub repository at https://github.com/awslabs/smithy.\n+This specification is open source, so contributions are welcome.\n \n-.. productionlist:: smithy\n-    namespace_statement :\"namespace\" `ws` `namespace` `br`\n+.. rubric:: Examples\n \n-The following example defines a string shape named ``MyString`` in the\n-``smithy.example`` namespace:\n+Unless declared otherwise, example Smithy models given in this specification\n+are written using the :ref:`Smithy interface definition language (IDL) <idl>`\n+syntax. Complementary :ref:`JSON AST <json-ast>` examples are provided\n+alongside Smithy IDL examples where appropriate. For example:\n \n .. tabs::\n \n     .. code-tab:: smithy\n \n+        $version: \"1.0\"\n+\n+        metadata foo = \"bar\"\n+\n         namespace smithy.example\n \n-        string MyString\n+        use smithy.other.namespace#MyString\n+\n+        structure MyStructure {\n+            @required\n+            foo: MyString\n+        }\n \n     .. code-tab:: json\n \n         {\n             \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"bar\"\n+            },\n             \"shapes\": {\n-                \"smithy.example#MyString\": {\n-                    \"type\": \"string\"\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.other.namespace#MyString\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n                 }\n             }\n         }\n \n \n-.. _use-statement:\n+.. _smithy-overview:\n+\n+---------------\n+Smithy overview\n+---------------\n+\n+Smithy is a framework that consists of a semantic model, file formats used to\n+define a model, and a build process used to validate models and facilitate\n+model transformations.\n+\n+.. figure:: images/smithy-overview.svg\n+   :name: figure-1.1\n+   :width: 100%\n+   :alt: Smithy framework concepts\n+\n+   **Figure 1.1**: Smithy framework concepts\n+\n+Semantic model\n+    The in-memory model used by tools. The :ref:`semantic model <semantic-model>`\n+    may be serialized into one or more model file representations.\n+Model File\n+    A file on the file system, in a particular representation. The model files\n+    that make up a semantic model MAY be split across multiple files to\n+    improve readability or modularity, and those files are not required to\n+    use the same representation.\n+Representation\n+    A particular model file format such as the Smithy IDL or JSON AST.\n+    Representations are loaded into the semantic model by mapping the\n+    representation to concepts in the semantic model.\n+\n+    * The :ref:`Smithy IDL <idl>` is a human-readable format that aims to\n+      streamline authoring and reading models.\n+    * The :ref:`JSON AST <json-ast>` aims to provide a more machine-readable\n+      format to easily share models across language implementations and better\n+      integrate with JSON-based ecosystems.\n+Model transformation\n+    The process of converting input model files into output artifacts.\n+    Generated artifacts can be other Smithy models (an endogenous\n+    transformation), other model formats (an exogenous transformation),\n+    code, documentation, etc.\n+\n+    .. figure:: images/smithy-transformations.svg", "originalCommit": "bd819fc1d22fb627141f6a09a187940ad27c81d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxMDE2MQ==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r454710161", "bodyText": "Yeah, I'll dedent and give this it's own dedicated section following this one.", "author": "mtdowling", "createdAt": "2020-07-14T23:52:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNDg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNTI5NA==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r454705294", "bodyText": "Oops, this has bigInteger twice, no bigDecimal", "author": "johnstonskj", "createdAt": "2020-07-14T23:37:29Z", "path": "docs/source/1.0/spec/core/model.rst", "diffHunk": "@@ -1,223 +1,431 @@\n-.. _shapes:\n+.. _smithy-model:\n \n-======\n-Shapes\n-======\n+============\n+Smithy model\n+============\n \n-*Shapes* are named data definitions that describe the structure of an API.\n-Shapes have a *type* that represents the type of values that a shape\n-represents. Types like ``string``, ``structure``, and ``operation`` represent\n-the kinds of shapes that can be used in a model, while shapes like\n-``MyString``, ``MyStructure``, and ``MyOperation`` define a referenceable\n-instance of a type.\n+This is the specification of Smithy, an interface definition language and set\n+of tools used to build clients, servers, and other kinds of artifacts through\n+model transformations. This specification is at version |release|.\n \n .. contents:: Table of contents\n     :depth: 1\n     :local:\n     :backlinks: none\n \n \n--------------\n-Shape section\n--------------\n-\n-The shape section of the IDL is used to define shapes and apply traits to\n-shapes. It comes after any :token:`control statements <control_section>` and\n-:token:`metadata statements <metadata_section>`.\n-\n-.. productionlist:: smithy\n-    shape_section :[`namespace_statement` [`use_section`] [`shape_statements`]]\n-\n-\n-.. _namespaces:\n-\n-Namespaces\n-==========\n+---------------------------------\n+Conventions used in this document\n+---------------------------------\n \n-Shapes are defined inside a :dfn:`namespace`. A namespace is mechanism for\n-logically grouping shapes in a way that makes them reusable alongside other\n-models without naming conflicts.\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n+\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n+document are to be interpreted as described in :rfc:`2119`.\n \n-.. _namespace-statement:\n+This specification makes use of the Augmented Backus-Naur Form (ABNF)\n+:rfc:`5234` notation, including the *core rules* defined in Appendix B\n+of that document.\n \n-Shapes can only be defined if a namespace is declared, and only a single\n-namespace can appear in an IDL model file.\n+Readers are invited to report technical errors and ambiguities in this\n+specification to the Smithy GitHub repository at https://github.com/awslabs/smithy.\n+This specification is open source, so contributions are welcome.\n \n-.. productionlist:: smithy\n-    namespace_statement :\"namespace\" `ws` `namespace` `br`\n+.. rubric:: Examples\n \n-The following example defines a string shape named ``MyString`` in the\n-``smithy.example`` namespace:\n+Unless declared otherwise, example Smithy models given in this specification\n+are written using the :ref:`Smithy interface definition language (IDL) <idl>`\n+syntax. Complementary :ref:`JSON AST <json-ast>` examples are provided\n+alongside Smithy IDL examples where appropriate. For example:\n \n .. tabs::\n \n     .. code-tab:: smithy\n \n+        $version: \"1.0\"\n+\n+        metadata foo = \"bar\"\n+\n         namespace smithy.example\n \n-        string MyString\n+        use smithy.other.namespace#MyString\n+\n+        structure MyStructure {\n+            @required\n+            foo: MyString\n+        }\n \n     .. code-tab:: json\n \n         {\n             \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"bar\"\n+            },\n             \"shapes\": {\n-                \"smithy.example#MyString\": {\n-                    \"type\": \"string\"\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.other.namespace#MyString\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n                 }\n             }\n         }\n \n \n-.. _use-statement:\n+.. _smithy-overview:\n+\n+---------------\n+Smithy overview\n+---------------\n+\n+Smithy is a framework that consists of a semantic model, file formats used to\n+define a model, and a build process used to validate models and facilitate\n+model transformations.\n+\n+.. figure:: images/smithy-overview.svg\n+   :name: figure-1.1\n+   :width: 100%\n+   :alt: Smithy framework concepts\n+\n+   **Figure 1.1**: Smithy framework concepts\n+\n+Semantic model\n+    The in-memory model used by tools. The :ref:`semantic model <semantic-model>`\n+    may be serialized into one or more model file representations.\n+Model File\n+    A file on the file system, in a particular representation. The model files\n+    that make up a semantic model MAY be split across multiple files to\n+    improve readability or modularity, and those files are not required to\n+    use the same representation.\n+Representation\n+    A particular model file format such as the Smithy IDL or JSON AST.\n+    Representations are loaded into the semantic model by mapping the\n+    representation to concepts in the semantic model.\n+\n+    * The :ref:`Smithy IDL <idl>` is a human-readable format that aims to\n+      streamline authoring and reading models.\n+    * The :ref:`JSON AST <json-ast>` aims to provide a more machine-readable\n+      format to easily share models across language implementations and better\n+      integrate with JSON-based ecosystems.\n+Model transformation\n+    The process of converting input model files into output artifacts.\n+    Generated artifacts can be other Smithy models (an endogenous\n+    transformation), other model formats (an exogenous transformation),\n+    code, documentation, etc.\n+\n+    .. figure:: images/smithy-transformations.svg\n+       :name: figure-1.2\n+       :width: 100%\n+       :alt: Smithy model transformations\n+\n+       **Figure 1.2**: Smithy model transformations\n+\n+\n+.. _semantic-model:\n+\n+--------------\n+Semantic model\n+--------------\n+\n+Smithy's *semantic model* is an in-memory model used by tools. It is\n+independent of any particular serialized representation. The semantic\n+model contains metadata and a graph of :ref:`shapes <shapes>`\n+connected by :ref:`shape IDs <shape-id>`.\n+\n+.. figure:: images/smithy-semantic-model.svg\n+   :name: figure-1.3\n+   :width: 100%\n+   :alt: Smithy semantic model\n+\n+   **Figure 1.3**: Smithy semantic model\n+\n+Shape\n+    Shapes are named data definitions that describe the structure of an API.\n+    Shapes are referenced and connected by :ref:`shape IDs <shape-id>`.\n+    Relationships between shapes are formed by :ref:`members <member>` that\n+    target other shapes, properties of shapes like the ``input`` and\n+    ``output`` properties of an :ref:`operation <operation>`, and\n+    :ref:`applied traits <applying-traits>` that attach a trait to a shape.\n+Shape ID\n+    A :ref:`shape ID <shape-id>` is used to identify shapes defined in a\n+    model. For example, ``smithy.example#MyShape``,\n+    ``smithy.example#Foo$bar``, and ``Baz`` are all different kinds of shape\n+    IDs.\n+Trait\n+    :ref:`Traits <traits>` are specialized shapes that form the basis of\n+    Smithy's meta-model. Traits are applied to shapes to associate metadata\n+    to a shape. They are typically used by tools to influence validation,\n+    serialization, and code generation.\n+Applied trait\n+    An applied trait is an instance of a trait applied to a shape, configured\n+    using a :ref:`node value <node-value>`.\n+Model metadata\n+    Metadata is a schema-less extensibility mechanism used to associate\n+    metadata to an entire model. For example, metadata is used to define\n+    :ref:`validators <validator-definition>` and model-wide\n+    :ref:`suppressions <suppression-definition>`. Metadata is defined\n+    using an ``object`` :ref:`node value <node-value>`.\n+Prelude\n+    The :ref:`prelude <prelude>` defines various simple shapes and every\n+    trait defined in the core specification. All Smithy models automatically\n+    include the prelude.\n+\n+\n+.. _model-files:\n+\n+-----------\n+Model files\n+-----------\n+\n+Smithy models MAY be divided into multiple files so that they are easier to\n+maintain and evolve. One or more model files can be assembled (or merged)\n+together to form a semantic model. The model files that form a semantic model\n+are not required to all be defined in the same representation; some models can\n+be defined using the IDL and others can be defined using the JSON AST.\n+\n+Model files do not explicitly include other model files; this responsibility\n+is left to tooling to ensure that all necessary model files are merged\n+together to form a valid semantic model.\n \n-Referring to shapes\n+.. _merging-models:\n+\n+Merging model files\n ===================\n \n-The *use section* of the IDL is used to import shapes into the current\n-namespace so that they can be referred to using a relative shape.\n+Implementations MUST take the following steps to merge models together to load\n+the semantic model:\n \n-.. productionlist:: smithy\n-    use_section   :*(`use_statement`)\n-    use_statement :\"use\" `ws` `absolute_root_shape_id` `br`\n+#. Duplicate shape IDs, if found, MUST cause the model merge to fail.\n+   See :ref:`shape-id-conflicts` for more information.\n+#. Merge any conflicting applied traits using\n+   :ref:`trait conflict resolution  <trait-conflict-resolution>`.\n+#. Merge the metadata objects of both models using the steps defined\n+   in :ref:`merging-metadata`.\n+\n+\n+.. _merging-metadata:\n+\n+Merging metadata\n+----------------\n \n-The following example imports ``smithy.example#Foo`` and\n-``smithy.example#Baz`` so that they can be referred to by\n-:ref:`relative shape IDs <relative-shape-id>`:\n+When a conflict occurs between top-level metadata key-value pairs,\n+metadata is merged using the following logic:\n+\n+1. If a metadata key is only present in one model, then the entry is valid\n+   and added to the merged model.\n+2. If both models contain the same key and both values are arrays, then\n+   the entry is valid; the values of both arrays are concatenated into a\n+   single array and added to the merged model.\n+3. If both models contain the same key and both values are exactly equal,\n+   then the conflict is ignored and the value is added to the merged model.\n+4. If both models contain the same key and the values do not both map to\n+   arrays, then the key is invalid and there is a metadata conflict error.\n+\n+Given the following two Smithy models:\n \n .. code-block:: smithy\n+    :caption: model-a.smithy\n \n-    namespace smithy.hello\n+    metadata \"foo\" = [\"baz\", \"bar\"]\n+    metadata \"qux\" = \"test\"\n+    metadata \"validConflict\" = \"hi!\"\n \n-    use smithy.example#Foo\n-    use smithy.example#Baz\n+.. code-block:: smithy\n+    :caption: model-b.smithy\n \n-    map MyMap {\n-        // Resolves to smithy.example#Foo\n-        key: Foo,\n-        // Resolves to smithy.example#Baz\n-        value: Baz,\n-    }\n+    metadata \"foo\" = [\"lorem\", \"ipsum\"]\n+    metadata \"lorem\" = \"ipsum\"\n+    metadata \"validConflict\" = \"hi!\"\n \n-A use statement can import :ref:`traits <traits>` too. The following example\n-imports the ``smithy.example#test`` and ``smithy.example#anotherTrait``\n-traits so that they can be applied using relative shape IDs:\n+Merging ``model-a.smithy`` and ``model-b.smithy`` produces the following\n+model:\n \n .. code-block:: smithy\n \n-    namespace smithy.hello\n+    metadata \"foo\" = [\"baz\", \"bar\", \"lorem\", \"ipsum\"]\n+    metadata \"qux\" = \"test\"\n+    metadata \"lorem\" = \"ipsum\"\n+    metadata \"validConflict\" = \"hi!\"\n \n-    use smithy.example#test\n-    use smithy.example#anotherTrait\n \n-    @test // <-- Resolves to smithy.example#test\n-    string MyString\n+.. _node-value:\n \n-.. rubric:: Validation\n+-----------\n+Node values\n+-----------\n \n-#. A shape cannot be defined in a file with the same name as one of the\n-   shapes imported with a ``use`` statement.\n-#. Shapes IDs with members names cannot be imported with a use statement.\n+Node values are JSON-like values used in the following places in the\n+semantic model:\n \n+* **metadata**: Metadata is defined as a node value object.\n+* **applied trait**: The value of a trait applied to a shape is defined\n+  using a node value.\n \n-.. _relative-shape-id:\n+.. figure:: images/smithy-model-values.svg\n+   :name: figure-1.4\n+   :width: 100%\n+   :alt: Node value types\n \n-Relative shape ID resolution\n-----------------------------\n+   **Figure 1.4**: Node value types\n \n-In the Smithy IDL, relative shape IDs are resolved using the following process:\n+The following example defines metadata using a node value:\n \n-#. If a :token:`use_statement` has imported a shape with the same name,\n-   the shape ID resolves to the imported shape ID.\n-#. If a shape is defined in the same namespace as the shape with the same name,\n-   the namespace of the shape resolves to the *current namespace*.\n-#. If a shape is defined in the :ref:`prelude <prelude>` with the same name,\n-   the namespace resolves to ``smithy.api``.\n-#. If a relative shape ID does not satisfy one of the above cases, the shape\n-   ID is invalid, and the namespace is inherited from the *current namespace*.\n+.. tabs::\n \n-The following example Smithy model contains comments above each member of\n-the shape named ``MyStructure`` that describes the shape the member resolves\n-to.\n+    .. code-tab:: smithy\n \n-.. code-block:: smithy\n+        metadata foo = \"hello\"\n \n-    namespace smithy.example\n+    .. code-tab:: json\n \n-    use foo.baz#Bar\n-\n-    string MyString\n-\n-    structure MyStructure {\n-        // Resolves to smithy.example#MyString\n-        // There is a shape named MyString defined in the same namespace.\n-        a: MyString,\n-\n-        // Resolves to smithy.example#MyString\n-        // Absolute shape IDs do not perform namespace resolution.\n-        b: smithy.example#MyString,\n-\n-        // Resolves to foo.baz#Bar\n-        // The \"use foo.baz#Bar\" statement imported the Bar symbol,\n-        // allowing the shape to be referenced using a relative shape ID.\n-        c: Bar,\n-\n-        // Resolves to foo.baz#Bar\n-        // Absolute shape IDs do not perform namespace resolution.\n-        d: foo.baz#Bar,\n-\n-        // Resolves to foo.baz#MyString\n-        // Absolute shape IDs do not perform namespace resolution.\n-        e: foo.baz#MyString,\n-\n-        // Resolves to smithy.api#String\n-        // No shape named String was imported through a use statement\n-        // the smithy.example namespace does not contain a shape named\n-        // String, and the prelude model contains a shape named String.\n-        f: String,\n-\n-        // Resolves to smithy.example#MyBoolean.\n-        // There is a shape named MyBoolean defined in the same namespace.\n-        // Forward references are supported both within the same file and\n-        // across multiple files.\n-        g: MyBoolean,\n-\n-        // Invalid. A shape by this name has not been imported through a\n-        // use statement, a shape by this name does not exist in the\n-        // current namespace, and a shape by this name does not exist in\n-        // the prelude model.\n-        h: InvalidShape,\n-    }\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"hello\"\n+            }\n+        }\n \n-    boolean MyBoolean\n+The following example defines a trait using a node value:\n \n+.. tabs::\n \n----------------\n-Defining shapes\n----------------\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @length(min: 1, max: 10)\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#length\": {\n+                            \"min\": 1,\n+                            \"max\": 10\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+Node value types\n+================\n+\n+Node values have the same data model as JSON; they consist of the following\n+kinds of values:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 30 70\n+\n+    * - Type\n+      - Description\n+    * - null\n+      - The lack of a value\n+    * - string\n+      - A UTF-8 string\n+    * - number\n+      - A double precision floating point number\n+    * - boolean\n+      - A Boolean, true or false value\n+    * - array\n+      - A list of heterogeneous node values\n+    * - object\n+      - A map of string keys to heterogeneous node values\n+\n+.. rubric:: Shape IDs, text blocks, et al.\n \n-Shape statements are used to define shapes.\n+There is no specific node value type for shape IDs, text blocks, or\n+other higher-level features of the IDL; these values are stored and\n+treated in the semantic model as simply opaque strings, and their\n+validation happens before the creation of the model.\n+\n+\n+.. _shapes:\n+\n+------\n+Shapes\n+------\n+\n+Smithy models are made up of shapes. Shapes come in three kinds: simple,\n+aggregate, and service. A simple shape defines atomic or primitive values\n+such as ``integer`` and ``string``. Aggregate shapes have members such as\n+a list of strings or an ``Address`` structure. Service shapes have specific\n+semantics, unlike the very generic simple and aggregate shapes, as they\n+represent either a service, a resource managed by a service, or operations\n+on services and resources.\n+\n+Shapes are visualized using the following UML diagram:\n+\n+.. figure:: images/smithy-model-shapes.svg", "originalCommit": "bd819fc1d22fb627141f6a09a187940ad27c81d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4d344f2a860974cb571bcd301bbf8d3e4d9601ba", "url": "https://github.com/awslabs/smithy/commit/4d344f2a860974cb571bcd301bbf8d3e4d9601ba", "message": "Replace SVGs with plain-text\n\nThis looks pretty exactly like what I'd want formatted SVGs to look\nlike. I created a custom RST directive called \"text-figure\" that works\njust like a figure, but the contents is literal text. Using a normal\ncode-block could work too, but unfortunately, the caption appears above\nthe diagram rather than below (which is pretty uncommon in technical\nwriting).", "committedDate": "2020-07-15T07:27:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA5MjAzMw==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455092033", "bodyText": "Try and reduce some of the horizontal spacing, for me I end up having a scroll bar to see the far right-hand side", "author": "johnstonskj", "createdAt": "2020-07-15T14:24:23Z", "path": "docs/source/1.0/spec/core/model.rst", "diffHunk": "@@ -366,14 +430,54 @@ semantics, unlike the very generic simple and aggregate shapes, as they\n represent either a service, a resource managed by a service, or operations\n on services and resources.\n \n-Shapes are visualized using the following UML diagram:\n-\n-.. figure:: images/smithy-model-shapes.svg\n-   :name: figure-1.5\n-   :width: 100%\n-   :alt: Smithy model shape types\n-\n-   **Figure 1.5**: Smithy model shape types\n+Shapes are visualized using the following diagram:\n+\n+.. text-figure::\n+    :caption: **Figure 1.5**: Smithy shapes\n+    :name: figure-1.5\n+\n+                                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                              members \u2571\u2502 \u00ababstract\u00bb  \u2502\n+                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502    Shape    \u2502\n+                             \u2502        \u2572\u2502             \u2502\n+                             \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                             \u2502                \u25b3\n+                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                  \u2502          \u2502                \u2502                     \u2502\n+          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+          \u2502  \u00ababstract\u00bb   \u2502  \u2502container\u2502 \u00ababstract\u00bb  \u2502       \u2502 \u00ababstract\u00bb  \u2502\n+          \u2502    Simple     \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502  Aggregate  \u2502       \u2502   Service   \u2502\n+          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                  \u25b3                     \u25b3                     \u25b3\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502blob      \u2502\u2500\u2500\u253c\u2500\u2500\u2502boolean  \u2502        \u251c\u2500\u2500\u2500\u2500\u2502    List    \u2502   \u2502    \u2502         Service         \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502    \u2502member      \u2502   \u2502    \u2502version                  \u2502\n+    \u2502document  \u2502\u2500\u2500\u253c\u2500\u2500\u2502string   \u2502        \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u251c\u2500\u2500\u2500\u2500\u2502operations: [Operation]? \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502    \u2502resources: [Resource]?   \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u251c\u2500\u2500\u2500\u2500\u2502    Set     \u2502   \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2502byte      \u2502\u2500\u2500\u253c\u2500\u2500\u2502short    \u2502        \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502    \u2502member      \u2502   \u2502    \u2502        Operation        \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+    \u2502integer   \u2502\u2500\u2500\u253c\u2500\u2500\u2502long     \u2502        \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502    \u2502input: Structure?        \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u251c\u2500\u2500\u2500\u2500\u2502    Map     \u2502   \u251c\u2500\u2500\u2500\u2500\u2502output: Structure?       \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502    \u2502errors: [Structure]?     \u2502\n+    \u2502float     \u2502\u2500\u2500\u253c\u2500\u2500\u2502double   \u2502        \u2502    \u2502key         \u2502   \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502    \u2502value       \u2502   \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502    \u2502        Resource         \u2502\n+    \u2502bigDecimal\u2502\u2500\u2500\u253c\u2500\u2500\u2502timestamp\u2502        \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u251c\u2500\u2500\u2500\u2500\u2502 Structure  \u2502   \u2502    \u2502identifiers?             \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502                     \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502    \u2502create: Operation?       \u2502\n+    \u2502bigInteger\u2502\u2500\u2500\u2518                     \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502    \u2502put: Operation?          \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                        \u2514\u2500\u2500\u2500\u2500\u2502   Union    \u2502   \u2502    \u2502read: Operation?         \u2502\n+                                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2502update: Operation?       \u2502\n+                                                                   \u2502delete: Operation?       \u2502\n+                                                                   \u2502list: : Operation?       \u2502\n+                                                                   \u2502operations: [Operation]? \u2502\n+                                                                   \u2502collectionOperations:    \u2502\n+                                                                   \u2502    [Operation]?         \u2502\n+                                                                   \u2502resources: [Resource]?   \u2502\n+                                                                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "originalCommit": "4d344f2a860974cb571bcd301bbf8d3e4d9601ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE2MjQwNA==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455162404", "bodyText": "Other metadata refs were removed, was it intentional to migrate this?", "author": "kstich", "createdAt": "2020-07-15T16:02:25Z", "path": "docs/source/1.0/spec/core/json-ast.rst", "diffHunk": "@@ -44,7 +42,7 @@ properties:\n         Smithy specification (e.g., \"|release|\").\n     * - metadata\n       - object\n-      - Defines all of the :ref:`metadata <metadata>` about the model\n+      - Defines all of the :ref:`metadata <semantic-model>` about the model", "originalCommit": "918566b6b96ae3e14f50dae5097b6c15625d8c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MzA2Nw==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455293067", "bodyText": "Eh, I think I should probably add that section back now that you bring it up.", "author": "mtdowling", "createdAt": "2020-07-15T19:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE2MjQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIwMDg1Ng==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455200856", "bodyText": "s/is/is a", "author": "kstich", "createdAt": "2020-07-15T17:06:16Z", "path": "docs/source/1.0/spec/core/model.rst", "diffHunk": "@@ -0,0 +1,2705 @@\n+.. _smithy-model:\n+\n+============\n+Smithy model\n+============\n+\n+This is the specification of Smithy, an interface definition language and set\n+of tools used to build clients, servers, and other kinds of artifacts through\n+model transformations. This specification is at version |release|.\n+\n+.. contents:: Table of contents\n+    :depth: 1\n+    :local:\n+    :backlinks: none\n+\n+\n+---------------------------------\n+Conventions used in this document\n+---------------------------------\n+\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n+\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n+document are to be interpreted as described in :rfc:`2119`.\n+\n+This specification makes use of the Augmented Backus-Naur Form (ABNF)\n+:rfc:`5234` notation, including the *core rules* defined in Appendix B\n+of that document.\n+\n+Readers are invited to report technical errors and ambiguities in this\n+specification to the Smithy GitHub repository at https://github.com/awslabs/smithy.\n+This specification is open source, so contributions are welcome.\n+\n+.. rubric:: Examples\n+\n+Unless declared otherwise, example Smithy models given in this specification\n+are written using the :ref:`Smithy interface definition language (IDL) <idl>`\n+syntax. Complementary :ref:`JSON AST <json-ast>` examples are provided\n+alongside Smithy IDL examples where appropriate. For example:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1.0\"\n+\n+        metadata foo = \"bar\"\n+\n+        namespace smithy.example\n+\n+        use smithy.other.namespace#MyString\n+\n+        structure MyStructure {\n+            @required\n+            foo: MyString\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"bar\"\n+            },\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.other.namespace#MyString\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _smithy-framework:\n+\n+----------------\n+Smithy framework\n+----------------\n+\n+Smithy is a framework that consists of a semantic model, file formats used to\n+define a model, and a build process used to validate models and facilitate\n+model transformations.\n+\n+.. text-figure::\n+    :caption: **Figure 1.1**: Smithy framework concepts\n+    :name: figure-1.1\n+\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 part of          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    \u2502                \u2502\u2572                \u2571\u2502                \u2502\n+                    \u2502 Semantic Model \u2502\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502   Model File   \u2502\n+                    \u2502                \u2502\u2571                \u2572\u2502                \u2502\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                               split into       \u2572\u2502\u2571\n+                                                                 \u25cb\n+                                                                 \u2502\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                           \u253c\n+                    \u2502JSON AST (.json)\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502         \u2502                \u2502\n+                                              \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b7\u2502 Representation \u2502\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502         \u2502                \u2502\n+                    \u2502 IDL (.smithy)  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+Semantic model\n+    The in-memory model used by tools. The :ref:`semantic model <semantic-model>`\n+    may be serialized into one or more model file representations.\n+Model File\n+    A file on the file system, in a particular representation. The model files\n+    that make up a semantic model MAY be split across multiple files to\n+    improve readability or modularity, and those files are not required to\n+    use the same representation.\n+Representation\n+    A particular model file format such as the Smithy IDL or JSON AST.\n+    Representations are loaded into the semantic model by mapping the\n+    representation to concepts in the semantic model.\n+\n+    * The :ref:`Smithy IDL <idl>` is a human-readable format that aims to\n+      streamline authoring and reading models.\n+    * The :ref:`JSON AST <json-ast>` aims to provide a more machine-readable\n+      format to easily share models across language implementations and better\n+      integrate with JSON-based ecosystems.\n+\n+\n+Model transformations\n+=====================\n+\n+The build process mentioned above performs a number of model transformations.\n+A :dfn:`model transformation` is the process of converting input model files\n+into output artifacts. Generated artifacts can be other Smithy models\n+(an endogenous transformation), other model formats (an exogenous\n+transformation), code, documentation, etc.\n+\n+.. text-figure::\n+    :caption: **Figure 1.2**: Smithy model transformations\n+    :name: figure-1.2\n+\n+           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+           \u2502               \u2502\u2572           \u2502               \u2502           \u2571\u2502               \u2502\n+           \u2502Semantic Model \u2502\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502Transformation \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502   Artifact    \u2502\n+           \u2502               \u2502\u2571           \u2502               \u2502           \u2572\u2502               \u2502\n+           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                                \u25b3\n+                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                   \u2502                            \u2502                            \u2502\n+           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+           \u2502Model to Model \u2502            \u2502   Model to    \u2502            \u2502  Artifact to  \u2502\n+           \u2502Transformation \u2502            \u2502   Artifact    \u2502            \u2502     Model     \u2502\n+           \u2502               \u2502            \u2502Transformation \u2502            \u2502Transformation \u2502\n+           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+\n+.. _semantic-model:\n+\n+------------------\n+The semantic model\n+------------------\n+\n+Smithy's *semantic model* is an in-memory model used by tools. It is\n+independent of any particular serialized representation. The semantic\n+model contains metadata and a graph of :ref:`shapes <shapes>`\n+connected by :ref:`shape IDs <shape-id>`.\n+\n+.. text-figure::\n+    :caption: **Figure 1.3**: The semantic model\n+    :name: figure-1.3\n+\n+                                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                                          \u2502Semantic Model \u2502\u2572\n+                                          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                                          \u2502metadata?      \u2502\u2571         \u2502\n+                                          \u2502               \u2502          \u2502\n+                                          \u2502               \u2502          \u2502\n+                                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n+                                                  \u253c     \u253c prelude    \u2502\n+                                                  \u2502     \u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                                  \u25cb\n+                                           shapes\u2571\u2502\u2572\n+        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+        \u2502 Applied Trait \u2502\u2572          shape \u2502  \u00ababstract\u00bb   \u2502\n+        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502     Shape     \u2502            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+        \u2502               \u2502\u2571                \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524            \u2502    ShapeID    \u2502\n+        \u2502               \u2502                 \u2502               \u2502            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+        \u2502               \u2502\u2572     applied-to \u2502               \u2502         id \u2502namespace      \u2502\n+        \u2502               \u2502\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502               \u2502\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502shape_name     \u2502\n+        \u2502               \u2502\u2571traits          \u2502               \u2502            \u2502member_name?   \u2502\n+        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+Shape\n+    Shapes are named data definitions that describe the structure of an API.\n+    Shapes are referenced and connected by :ref:`shape IDs <shape-id>`.\n+    Relationships between shapes are formed by :ref:`members <member>` that\n+    target other shapes, properties of shapes like the ``input`` and\n+    ``output`` properties of an :ref:`operation <operation>`, and\n+    :ref:`applied traits <applying-traits>` that attach a trait to a shape.\n+Shape ID\n+    A :ref:`shape ID <shape-id>` is used to identify shapes defined in a\n+    model. For example, ``smithy.example#MyShape``,\n+    ``smithy.example#Foo$bar``, and ``Baz`` are all different kinds of shape\n+    IDs.\n+Trait\n+    :ref:`Traits <traits>` are specialized shapes that form the basis of\n+    Smithy's meta-model. Traits are applied to shapes to associate metadata\n+    to a shape. They are typically used by tools to influence validation,\n+    serialization, and code generation.\n+Applied trait\n+    An applied trait is an instance of a trait applied to a shape, configured\n+    using a :ref:`node value <node-value>`.\n+Model metadata\n+    Metadata is a schema-less extensibility mechanism used to associate\n+    metadata to an entire model. For example, metadata is used to define\n+    :ref:`validators <validator-definition>` and model-wide\n+    :ref:`suppressions <suppression-definition>`. Metadata is defined\n+    using an ``object`` :ref:`node value <node-value>`.\n+Prelude\n+    The :ref:`prelude <prelude>` defines various simple shapes and every\n+    trait defined in the core specification. All Smithy models automatically\n+    include the prelude.\n+\n+\n+.. _model-files:\n+\n+-----------\n+Model files\n+-----------\n+\n+Smithy models MAY be divided into multiple files so that they are easier to\n+maintain and evolve. One or more model files can be assembled (or merged)\n+together to form a semantic model. The model files that form a semantic model\n+are not required to all be defined in the same representation; some models can\n+be defined using the IDL and others can be defined using the JSON AST.\n+\n+Model files do not explicitly include other model files; this responsibility\n+is left to tooling to ensure that all necessary model files are merged\n+together to form a valid semantic model.\n+\n+.. _merging-models:\n+\n+Merging model files\n+===================\n+\n+Implementations MUST take the following steps to merge models together to load\n+the semantic model:\n+\n+#. Duplicate shape IDs, if found, MUST cause the model merge to fail.\n+   See :ref:`shape-id-conflicts` for more information.\n+#. Merge any conflicting applied traits using\n+   :ref:`trait conflict resolution  <trait-conflict-resolution>`.\n+#. Merge the metadata objects of both models using the steps defined\n+   in :ref:`merging-metadata`.\n+\n+\n+.. _merging-metadata:\n+\n+Merging metadata\n+----------------\n+\n+When a conflict occurs between top-level metadata key-value pairs,\n+metadata is merged using the following logic:\n+\n+1. If a metadata key is only present in one model, then the entry is valid\n+   and added to the merged model.\n+2. If both models contain the same key and both values are arrays, then\n+   the entry is valid; the values of both arrays are concatenated into a\n+   single array and added to the merged model.\n+3. If both models contain the same key and both values are exactly equal,\n+   then the conflict is ignored and the value is added to the merged model.\n+4. If both models contain the same key and the values do not both map to\n+   arrays, then the key is invalid and there is a metadata conflict error.\n+\n+Given the following two Smithy models:\n+\n+.. code-block:: smithy\n+    :caption: model-a.smithy\n+\n+    metadata \"foo\" = [\"baz\", \"bar\"]\n+    metadata \"qux\" = \"test\"\n+    metadata \"validConflict\" = \"hi!\"\n+\n+.. code-block:: smithy\n+    :caption: model-b.smithy\n+\n+    metadata \"foo\" = [\"lorem\", \"ipsum\"]\n+    metadata \"lorem\" = \"ipsum\"\n+    metadata \"validConflict\" = \"hi!\"\n+\n+Merging ``model-a.smithy`` and ``model-b.smithy`` produces the following\n+model:\n+\n+.. code-block:: smithy\n+\n+    metadata \"foo\" = [\"baz\", \"bar\", \"lorem\", \"ipsum\"]\n+    metadata \"qux\" = \"test\"\n+    metadata \"lorem\" = \"ipsum\"\n+    metadata \"validConflict\" = \"hi!\"\n+\n+\n+.. _node-value:\n+\n+-----------\n+Node values\n+-----------\n+\n+Node values are JSON-like values used in the following places in the\n+semantic model:\n+\n+* **metadata**: Metadata is defined as a node value object.\n+* **applied trait**: The value of a trait applied to a shape is defined\n+  using a node value.\n+\n+.. text-figure::\n+    :caption: **Figure 1.4**: Node value types\n+    :name: figure-1.4\n+\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 Semantic Model  \u2502                     \u2502Applied Trait\u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+      \u2502                                            \u2502\n+      \u2502                                            \u2502\n+      \u2502                                            \u253c nodeValue\n+      \u2502                                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+      \u2502                                     \u2502 \u00ababstract\u00bb  \u2502\n+      \u2502                                     \u2502    Value    \u2502\n+      \u2502metadata                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+      \u2502                                            \u25b3\n+      \u25cb      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+      \u253c      \u2502                   \u2502                 \u2502               \u2502               \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502     Object      \u2502 \u2502      Array      \u2502 \u2502   Number    \u2502 \u2502   Boolean   \u2502 \u2502   String    \u2502\n+    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2502members:         \u2502 \u2502members: [Value] \u2502\n+    \u2502  [String, Value]\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+The following example defines metadata using a node value:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        metadata foo = \"hello\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"hello\"\n+            }\n+        }\n+\n+The following example defines a trait using a node value:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @length(min: 1, max: 10)\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#length\": {\n+                            \"min\": 1,\n+                            \"max\": 10\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+Node value types\n+================\n+\n+Node values have the same data model as JSON; they consist of the following\n+kinds of values:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 30 70\n+\n+    * - Type\n+      - Description\n+    * - null\n+      - The lack of a value\n+    * - string\n+      - A UTF-8 string\n+    * - number\n+      - A double precision floating point number\n+    * - boolean\n+      - A Boolean, true or false value\n+    * - array\n+      - A list of heterogeneous node values\n+    * - object\n+      - A map of string keys to heterogeneous node values\n+\n+.. rubric:: Shape IDs, text blocks, et al.\n+\n+There is no specific node value type for shape IDs, text blocks, or\n+other higher-level features of the IDL; these values are stored and\n+treated in the semantic model as simply opaque strings, and their\n+validation happens before the creation of the model.\n+\n+\n+.. _shapes:\n+\n+------\n+Shapes\n+------\n+\n+Smithy models are made up of shapes. Shapes come in three kinds: simple,\n+aggregate, and service. A simple shape defines atomic or primitive values\n+such as ``integer`` and ``string``. Aggregate shapes have members such as\n+a list of strings or an ``Address`` structure. Service shapes have specific\n+semantics, unlike the very generic simple and aggregate shapes, as they\n+represent either a service, a resource managed by a service, or operations\n+on services and resources.\n+\n+Shapes are visualized using the following diagram:\n+\n+.. text-figure::\n+    :caption: **Figure 1.5**: Smithy shapes\n+    :name: figure-1.5\n+\n+                                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                             members \u2571\u2502 \u00ababstract\u00bb  \u2502\n+                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502    Shape    \u2502\n+                            \u2502        \u2572\u2502             \u2502\n+                            \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                            \u2502                \u25b3\n+                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                  \u2502         \u2502                \u2502                    \u2502\n+          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+          \u2502  \u00ababstract\u00bb   \u2502 \u2502container\u2502 \u00ababstract\u00bb  \u2502      \u2502 \u00ababstract\u00bb  \u2502\n+          \u2502    Simple     \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502  Aggregate  \u2502      \u2502   Service   \u2502\n+          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                  \u25b3                    \u25b3                    \u25b3\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502blob      \u2502\u2500\u2500\u253c\u2500\u2500\u2502boolean   \u2502      \u251c\u2500\u2500\u2500\u2500\u2502    List    \u2502  \u2502    \u2502         Service         \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u2502member      \u2502  \u2502    \u2502version                  \u2502\n+    \u2502document  \u2502\u2500\u2500\u253c\u2500\u2500\u2502string    \u2502      \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u251c\u2500\u2500\u2500\u2500\u2502operations: [Operation]? \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502resources: [Resource]?   \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502                    \u251c\u2500\u2500\u2500\u2500\u2502    Set     \u2502  \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2502timestamp \u2502\u2500\u2500\u2524                    \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502                    \u2502    \u2502member      \u2502  \u2502    \u2502        Operation        \u2502\n+                  \u2502                    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502input: Structure?        \u2502\n+          \u2502  \u00ababstract\u00bb   \u2502            \u251c\u2500\u2500\u2500\u2500\u2502    Map     \u2502  \u251c\u2500\u2500\u2500\u2500\u2502output: Structure?       \u2502\n+          \u2502    Number     \u2502            \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    \u2502errors: [Structure]?     \u2502\n+          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502    \u2502key         \u2502  \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                  \u25b3                    \u2502    \u2502value       \u2502  \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502        Resource         \u2502\n+    \u2502byte      \u2502\u2500\u2500\u253c\u2500\u2500\u2502short     \u2502      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u251c\u2500\u2500\u2500\u2500\u2502 Structure  \u2502  \u2502    \u2502identifiers?             \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502create: Operation?       \u2502\n+    \u2502integer   \u2502\u2500\u2500\u253c\u2500\u2500\u2502long      \u2502      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502put: Operation?          \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2502   Union    \u2502  \u2502    \u2502read: Operation?         \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2502update: Operation?       \u2502\n+    \u2502float     \u2502\u2500\u2500\u253c\u2500\u2500\u2502double    \u2502                                \u2502delete: Operation?       \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2502list: : Operation?       \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                \u2502operations: [Operation]? \u2502\n+    \u2502bigInteger\u2502\u2500\u2500\u2534\u2500\u2500\u2502bigDecimal\u2502                                \u2502collectionOperations:    \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2502    [Operation]?         \u2502\n+                                                                 \u2502resources: [Resource]?   \u2502\n+                                                                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+\n+.. _shape-id:\n+\n+Shape ID\n+========\n+\n+All shapes have an assigned shape ID. A :dfn:`shape ID` is used to refer to\n+shapes in the model. Shape IDs adhere to the following syntax:\n+\n+.. code-block:: none\n+\n+    com.foo.baz#ShapeName$memberName\n+    \\_________/ \\_______/ \\________/\n+         |          |          |\n+     Namespace  Shape name  Member name\n+\n+Namespace\n+    A namespace is mechanism for logically grouping shapes in a way", "originalCommit": "ab2e617e464b006292aef001fb460b490077de09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIwNjY0NA==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455206644", "bodyText": "s/content, or data/content, data", "author": "kstich", "createdAt": "2020-07-15T17:15:32Z", "path": "docs/source/1.0/spec/core/model.rst", "diffHunk": "@@ -0,0 +1,2705 @@\n+.. _smithy-model:\n+\n+============\n+Smithy model\n+============\n+\n+This is the specification of Smithy, an interface definition language and set\n+of tools used to build clients, servers, and other kinds of artifacts through\n+model transformations. This specification is at version |release|.\n+\n+.. contents:: Table of contents\n+    :depth: 1\n+    :local:\n+    :backlinks: none\n+\n+\n+---------------------------------\n+Conventions used in this document\n+---------------------------------\n+\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n+\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n+document are to be interpreted as described in :rfc:`2119`.\n+\n+This specification makes use of the Augmented Backus-Naur Form (ABNF)\n+:rfc:`5234` notation, including the *core rules* defined in Appendix B\n+of that document.\n+\n+Readers are invited to report technical errors and ambiguities in this\n+specification to the Smithy GitHub repository at https://github.com/awslabs/smithy.\n+This specification is open source, so contributions are welcome.\n+\n+.. rubric:: Examples\n+\n+Unless declared otherwise, example Smithy models given in this specification\n+are written using the :ref:`Smithy interface definition language (IDL) <idl>`\n+syntax. Complementary :ref:`JSON AST <json-ast>` examples are provided\n+alongside Smithy IDL examples where appropriate. For example:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1.0\"\n+\n+        metadata foo = \"bar\"\n+\n+        namespace smithy.example\n+\n+        use smithy.other.namespace#MyString\n+\n+        structure MyStructure {\n+            @required\n+            foo: MyString\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"bar\"\n+            },\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.other.namespace#MyString\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _smithy-framework:\n+\n+----------------\n+Smithy framework\n+----------------\n+\n+Smithy is a framework that consists of a semantic model, file formats used to\n+define a model, and a build process used to validate models and facilitate\n+model transformations.\n+\n+.. text-figure::\n+    :caption: **Figure 1.1**: Smithy framework concepts\n+    :name: figure-1.1\n+\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 part of          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    \u2502                \u2502\u2572                \u2571\u2502                \u2502\n+                    \u2502 Semantic Model \u2502\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502   Model File   \u2502\n+                    \u2502                \u2502\u2571                \u2572\u2502                \u2502\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                               split into       \u2572\u2502\u2571\n+                                                                 \u25cb\n+                                                                 \u2502\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                           \u253c\n+                    \u2502JSON AST (.json)\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502         \u2502                \u2502\n+                                              \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b7\u2502 Representation \u2502\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502         \u2502                \u2502\n+                    \u2502 IDL (.smithy)  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+Semantic model\n+    The in-memory model used by tools. The :ref:`semantic model <semantic-model>`\n+    may be serialized into one or more model file representations.\n+Model File\n+    A file on the file system, in a particular representation. The model files\n+    that make up a semantic model MAY be split across multiple files to\n+    improve readability or modularity, and those files are not required to\n+    use the same representation.\n+Representation\n+    A particular model file format such as the Smithy IDL or JSON AST.\n+    Representations are loaded into the semantic model by mapping the\n+    representation to concepts in the semantic model.\n+\n+    * The :ref:`Smithy IDL <idl>` is a human-readable format that aims to\n+      streamline authoring and reading models.\n+    * The :ref:`JSON AST <json-ast>` aims to provide a more machine-readable\n+      format to easily share models across language implementations and better\n+      integrate with JSON-based ecosystems.\n+\n+\n+Model transformations\n+=====================\n+\n+The build process mentioned above performs a number of model transformations.\n+A :dfn:`model transformation` is the process of converting input model files\n+into output artifacts. Generated artifacts can be other Smithy models\n+(an endogenous transformation), other model formats (an exogenous\n+transformation), code, documentation, etc.\n+\n+.. text-figure::\n+    :caption: **Figure 1.2**: Smithy model transformations\n+    :name: figure-1.2\n+\n+           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+           \u2502               \u2502\u2572           \u2502               \u2502           \u2571\u2502               \u2502\n+           \u2502Semantic Model \u2502\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502Transformation \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502   Artifact    \u2502\n+           \u2502               \u2502\u2571           \u2502               \u2502           \u2572\u2502               \u2502\n+           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                                \u25b3\n+                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                   \u2502                            \u2502                            \u2502\n+           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+           \u2502Model to Model \u2502            \u2502   Model to    \u2502            \u2502  Artifact to  \u2502\n+           \u2502Transformation \u2502            \u2502   Artifact    \u2502            \u2502     Model     \u2502\n+           \u2502               \u2502            \u2502Transformation \u2502            \u2502Transformation \u2502\n+           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+\n+.. _semantic-model:\n+\n+------------------\n+The semantic model\n+------------------\n+\n+Smithy's *semantic model* is an in-memory model used by tools. It is\n+independent of any particular serialized representation. The semantic\n+model contains metadata and a graph of :ref:`shapes <shapes>`\n+connected by :ref:`shape IDs <shape-id>`.\n+\n+.. text-figure::\n+    :caption: **Figure 1.3**: The semantic model\n+    :name: figure-1.3\n+\n+                                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                                          \u2502Semantic Model \u2502\u2572\n+                                          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                                          \u2502metadata?      \u2502\u2571         \u2502\n+                                          \u2502               \u2502          \u2502\n+                                          \u2502               \u2502          \u2502\n+                                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n+                                                  \u253c     \u253c prelude    \u2502\n+                                                  \u2502     \u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                                  \u25cb\n+                                           shapes\u2571\u2502\u2572\n+        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+        \u2502 Applied Trait \u2502\u2572          shape \u2502  \u00ababstract\u00bb   \u2502\n+        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502     Shape     \u2502            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+        \u2502               \u2502\u2571                \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524            \u2502    ShapeID    \u2502\n+        \u2502               \u2502                 \u2502               \u2502            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+        \u2502               \u2502\u2572     applied-to \u2502               \u2502         id \u2502namespace      \u2502\n+        \u2502               \u2502\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502               \u2502\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502shape_name     \u2502\n+        \u2502               \u2502\u2571traits          \u2502               \u2502            \u2502member_name?   \u2502\n+        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+Shape\n+    Shapes are named data definitions that describe the structure of an API.\n+    Shapes are referenced and connected by :ref:`shape IDs <shape-id>`.\n+    Relationships between shapes are formed by :ref:`members <member>` that\n+    target other shapes, properties of shapes like the ``input`` and\n+    ``output`` properties of an :ref:`operation <operation>`, and\n+    :ref:`applied traits <applying-traits>` that attach a trait to a shape.\n+Shape ID\n+    A :ref:`shape ID <shape-id>` is used to identify shapes defined in a\n+    model. For example, ``smithy.example#MyShape``,\n+    ``smithy.example#Foo$bar``, and ``Baz`` are all different kinds of shape\n+    IDs.\n+Trait\n+    :ref:`Traits <traits>` are specialized shapes that form the basis of\n+    Smithy's meta-model. Traits are applied to shapes to associate metadata\n+    to a shape. They are typically used by tools to influence validation,\n+    serialization, and code generation.\n+Applied trait\n+    An applied trait is an instance of a trait applied to a shape, configured\n+    using a :ref:`node value <node-value>`.\n+Model metadata\n+    Metadata is a schema-less extensibility mechanism used to associate\n+    metadata to an entire model. For example, metadata is used to define\n+    :ref:`validators <validator-definition>` and model-wide\n+    :ref:`suppressions <suppression-definition>`. Metadata is defined\n+    using an ``object`` :ref:`node value <node-value>`.\n+Prelude\n+    The :ref:`prelude <prelude>` defines various simple shapes and every\n+    trait defined in the core specification. All Smithy models automatically\n+    include the prelude.\n+\n+\n+.. _model-files:\n+\n+-----------\n+Model files\n+-----------\n+\n+Smithy models MAY be divided into multiple files so that they are easier to\n+maintain and evolve. One or more model files can be assembled (or merged)\n+together to form a semantic model. The model files that form a semantic model\n+are not required to all be defined in the same representation; some models can\n+be defined using the IDL and others can be defined using the JSON AST.\n+\n+Model files do not explicitly include other model files; this responsibility\n+is left to tooling to ensure that all necessary model files are merged\n+together to form a valid semantic model.\n+\n+.. _merging-models:\n+\n+Merging model files\n+===================\n+\n+Implementations MUST take the following steps to merge models together to load\n+the semantic model:\n+\n+#. Duplicate shape IDs, if found, MUST cause the model merge to fail.\n+   See :ref:`shape-id-conflicts` for more information.\n+#. Merge any conflicting applied traits using\n+   :ref:`trait conflict resolution  <trait-conflict-resolution>`.\n+#. Merge the metadata objects of both models using the steps defined\n+   in :ref:`merging-metadata`.\n+\n+\n+.. _merging-metadata:\n+\n+Merging metadata\n+----------------\n+\n+When a conflict occurs between top-level metadata key-value pairs,\n+metadata is merged using the following logic:\n+\n+1. If a metadata key is only present in one model, then the entry is valid\n+   and added to the merged model.\n+2. If both models contain the same key and both values are arrays, then\n+   the entry is valid; the values of both arrays are concatenated into a\n+   single array and added to the merged model.\n+3. If both models contain the same key and both values are exactly equal,\n+   then the conflict is ignored and the value is added to the merged model.\n+4. If both models contain the same key and the values do not both map to\n+   arrays, then the key is invalid and there is a metadata conflict error.\n+\n+Given the following two Smithy models:\n+\n+.. code-block:: smithy\n+    :caption: model-a.smithy\n+\n+    metadata \"foo\" = [\"baz\", \"bar\"]\n+    metadata \"qux\" = \"test\"\n+    metadata \"validConflict\" = \"hi!\"\n+\n+.. code-block:: smithy\n+    :caption: model-b.smithy\n+\n+    metadata \"foo\" = [\"lorem\", \"ipsum\"]\n+    metadata \"lorem\" = \"ipsum\"\n+    metadata \"validConflict\" = \"hi!\"\n+\n+Merging ``model-a.smithy`` and ``model-b.smithy`` produces the following\n+model:\n+\n+.. code-block:: smithy\n+\n+    metadata \"foo\" = [\"baz\", \"bar\", \"lorem\", \"ipsum\"]\n+    metadata \"qux\" = \"test\"\n+    metadata \"lorem\" = \"ipsum\"\n+    metadata \"validConflict\" = \"hi!\"\n+\n+\n+.. _node-value:\n+\n+-----------\n+Node values\n+-----------\n+\n+Node values are JSON-like values used in the following places in the\n+semantic model:\n+\n+* **metadata**: Metadata is defined as a node value object.\n+* **applied trait**: The value of a trait applied to a shape is defined\n+  using a node value.\n+\n+.. text-figure::\n+    :caption: **Figure 1.4**: Node value types\n+    :name: figure-1.4\n+\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 Semantic Model  \u2502                     \u2502Applied Trait\u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+      \u2502                                            \u2502\n+      \u2502                                            \u2502\n+      \u2502                                            \u253c nodeValue\n+      \u2502                                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+      \u2502                                     \u2502 \u00ababstract\u00bb  \u2502\n+      \u2502                                     \u2502    Value    \u2502\n+      \u2502metadata                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+      \u2502                                            \u25b3\n+      \u25cb      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+      \u253c      \u2502                   \u2502                 \u2502               \u2502               \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502     Object      \u2502 \u2502      Array      \u2502 \u2502   Number    \u2502 \u2502   Boolean   \u2502 \u2502   String    \u2502\n+    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2502members:         \u2502 \u2502members: [Value] \u2502\n+    \u2502  [String, Value]\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+The following example defines metadata using a node value:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        metadata foo = \"hello\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"hello\"\n+            }\n+        }\n+\n+The following example defines a trait using a node value:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @length(min: 1, max: 10)\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#length\": {\n+                            \"min\": 1,\n+                            \"max\": 10\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+Node value types\n+================\n+\n+Node values have the same data model as JSON; they consist of the following\n+kinds of values:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 30 70\n+\n+    * - Type\n+      - Description\n+    * - null\n+      - The lack of a value\n+    * - string\n+      - A UTF-8 string\n+    * - number\n+      - A double precision floating point number\n+    * - boolean\n+      - A Boolean, true or false value\n+    * - array\n+      - A list of heterogeneous node values\n+    * - object\n+      - A map of string keys to heterogeneous node values\n+\n+.. rubric:: Shape IDs, text blocks, et al.\n+\n+There is no specific node value type for shape IDs, text blocks, or\n+other higher-level features of the IDL; these values are stored and\n+treated in the semantic model as simply opaque strings, and their\n+validation happens before the creation of the model.\n+\n+\n+.. _shapes:\n+\n+------\n+Shapes\n+------\n+\n+Smithy models are made up of shapes. Shapes come in three kinds: simple,\n+aggregate, and service. A simple shape defines atomic or primitive values\n+such as ``integer`` and ``string``. Aggregate shapes have members such as\n+a list of strings or an ``Address`` structure. Service shapes have specific\n+semantics, unlike the very generic simple and aggregate shapes, as they\n+represent either a service, a resource managed by a service, or operations\n+on services and resources.\n+\n+Shapes are visualized using the following diagram:\n+\n+.. text-figure::\n+    :caption: **Figure 1.5**: Smithy shapes\n+    :name: figure-1.5\n+\n+                                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                             members \u2571\u2502 \u00ababstract\u00bb  \u2502\n+                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502    Shape    \u2502\n+                            \u2502        \u2572\u2502             \u2502\n+                            \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                            \u2502                \u25b3\n+                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                  \u2502         \u2502                \u2502                    \u2502\n+          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+          \u2502  \u00ababstract\u00bb   \u2502 \u2502container\u2502 \u00ababstract\u00bb  \u2502      \u2502 \u00ababstract\u00bb  \u2502\n+          \u2502    Simple     \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502  Aggregate  \u2502      \u2502   Service   \u2502\n+          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                  \u25b3                    \u25b3                    \u25b3\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502blob      \u2502\u2500\u2500\u253c\u2500\u2500\u2502boolean   \u2502      \u251c\u2500\u2500\u2500\u2500\u2502    List    \u2502  \u2502    \u2502         Service         \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u2502member      \u2502  \u2502    \u2502version                  \u2502\n+    \u2502document  \u2502\u2500\u2500\u253c\u2500\u2500\u2502string    \u2502      \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u251c\u2500\u2500\u2500\u2500\u2502operations: [Operation]? \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502resources: [Resource]?   \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502                    \u251c\u2500\u2500\u2500\u2500\u2502    Set     \u2502  \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2502timestamp \u2502\u2500\u2500\u2524                    \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502                    \u2502    \u2502member      \u2502  \u2502    \u2502        Operation        \u2502\n+                  \u2502                    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502input: Structure?        \u2502\n+          \u2502  \u00ababstract\u00bb   \u2502            \u251c\u2500\u2500\u2500\u2500\u2502    Map     \u2502  \u251c\u2500\u2500\u2500\u2500\u2502output: Structure?       \u2502\n+          \u2502    Number     \u2502            \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    \u2502errors: [Structure]?     \u2502\n+          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502    \u2502key         \u2502  \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                  \u25b3                    \u2502    \u2502value       \u2502  \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502        Resource         \u2502\n+    \u2502byte      \u2502\u2500\u2500\u253c\u2500\u2500\u2502short     \u2502      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u251c\u2500\u2500\u2500\u2500\u2502 Structure  \u2502  \u2502    \u2502identifiers?             \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502create: Operation?       \u2502\n+    \u2502integer   \u2502\u2500\u2500\u253c\u2500\u2500\u2502long      \u2502      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502put: Operation?          \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2502   Union    \u2502  \u2502    \u2502read: Operation?         \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2502update: Operation?       \u2502\n+    \u2502float     \u2502\u2500\u2500\u253c\u2500\u2500\u2502double    \u2502                                \u2502delete: Operation?       \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2502list: : Operation?       \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                \u2502operations: [Operation]? \u2502\n+    \u2502bigInteger\u2502\u2500\u2500\u2534\u2500\u2500\u2502bigDecimal\u2502                                \u2502collectionOperations:    \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2502    [Operation]?         \u2502\n+                                                                 \u2502resources: [Resource]?   \u2502\n+                                                                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+\n+.. _shape-id:\n+\n+Shape ID\n+========\n+\n+All shapes have an assigned shape ID. A :dfn:`shape ID` is used to refer to\n+shapes in the model. Shape IDs adhere to the following syntax:\n+\n+.. code-block:: none\n+\n+    com.foo.baz#ShapeName$memberName\n+    \\_________/ \\_______/ \\________/\n+         |          |          |\n+     Namespace  Shape name  Member name\n+\n+Namespace\n+    A namespace is mechanism for logically grouping shapes in a way\n+    that makes them reusable alongside other models without naming\n+    conflicts. A semantic model MAY contain shapes defined across multiple\n+    namespaces. The IDL representation supports zero or one namespace per\n+    model file, while the JSON AST representation supports zero or more\n+    namespaces per model file.\n+Absolute shape ID\n+    An :dfn:`absolute shape ID` starts with a :token:`namespace` name,\n+    followed by \"``#``\", followed by a *relative shape ID*. All shape\n+    IDs in the semantic model MUST be absolute.\n+    For example, ``smithy.example#Foo`` and ``smithy.example#Foo$bar``\n+    are absolute shape IDs.\n+Relative shape ID\n+    A :dfn:`relative shape ID` contains a :token:`shape name <identifier>`\n+    and an optional :token:`member name <identifier>`. The shape name and\n+    member name are separated by the \"``$``\" symbol if a member name is\n+    present. For example, ``Foo`` and ``Foo$bar`` are relative shape IDs.\n+Root shape ID\n+    A :dfn:`root shape ID` is a shape ID that does not contain a member.\n+    For example, ``smithy.example#Foo`` and ``Foo`` are root shape IDs.\n+\n+.. rubric:: Shape ID ABNF\n+\n+Shape IDs are formally defined by the following ABNF:\n+\n+.. productionlist:: smithy\n+    shape_id               :`root_shape_id` [`shape_id_member`]\n+    root_shape_id          :`absolute_root_shape_id` / `identifier`\n+    absolute_root_shape_id :`namespace` \"#\" `identifier`\n+    namespace              :`identifier` *(\".\" `identifier`)\n+    identifier             :(ALPHA / \"_\") *(ALPHA / DIGIT / \"_\")\n+    shape_id_member        :\"$\" `identifier`\n+\n+.. rubric:: Best practices for defining shape names\n+\n+Consumers of a Smithy model MAY choose to inflect shape names, structure\n+member names, and other facets of a Smithy model in order to expose a more\n+idiomatic experience to particular programming languages. In order to make this\n+easier for consumers of a model, model authors SHOULD utilize a strict form of\n+PascalCase in which only the first letter of acronyms, abbreviations, and\n+initialisms are capitalized.\n+\n+===========   ===============\n+Recommended   Not recommended\n+===========   ===============\n+UserId        UserID\n+ResourceArn   ResourceARN\n+IoChannel     IOChannel\n+HtmlEntity    HTMLEntity\n+HtmlEntity    HTML_Entity\n+===========   ===============\n+\n+\n+.. _shape-id-conflicts:\n+\n+Shape ID conflicts\n+==================\n+\n+While shape ID references within the semantic model are case-sensitive, no\n+two shapes in the semantic model can have the same case-insensitive shape ID.\n+This restriction makes it easier to use Smithy models for code generation in\n+programming languages that do not support case-sensitive identifiers or that\n+perform some kind of normalization on generated identifiers (for example,\n+a Python code generator might convert all member names to lower snake case).\n+To illustrate, ``com.Foo#baz`` and ``com.foo#BAZ`` are not allowed in the\n+same semantic model. This restriction also extends to member names:\n+``com.foo#Baz$bar`` and ``com.foo#Baz$BAR`` are in conflict.\n+\n+\n+.. _simple-types:\n+\n+-------------\n+Simple shapes\n+-------------\n+\n+*Simple types* are types that do not contain nested types or shape references.\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 90\n+\n+    * - Type\n+      - Description\n+    * - blob\n+      - Uninterpreted binary data\n+    * - boolean\n+      - Boolean value type\n+    * - string\n+      - UTF-8 encoded string\n+    * - byte\n+      - 8-bit signed integer ranging from -128 to 127 (inclusive)\n+    * - short\n+      - 16-bit signed integer ranging from -32,768 to 32,767 (inclusive)\n+    * - integer\n+      - 32-bit signed integer ranging from -2^31 to (2^31)-1 (inclusive)\n+    * - long\n+      - 64-bit signed integer ranging from -2^63 to (2^63)-1 (inclusive)\n+    * - float\n+      - Single precision IEEE-754 floating point number\n+    * - double\n+      - Double precision IEEE-754 floating point number\n+    * - bigInteger\n+      - Arbitrarily large signed integer\n+    * - bigDecimal\n+      - Arbitrary precision signed decimal number\n+    * - timestamp\n+      - Represents an instant in time with no UTC offset or timezone. The\n+        serialization of a timestamp is an implementation detail that is\n+        determined by a :ref:`protocol <protocolDefinition-trait>` and\n+        MUST NOT have any effect on the types exposed by tooling to\n+        represent a timestamp value.\n+    * - document\n+      - Represents a protocol-agnostic untyped value used to represent open\n+        content, or data with no fixed schema, data that can't be modeled", "originalCommit": "ab2e617e464b006292aef001fb460b490077de09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5NTYyNQ==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455295625", "bodyText": "The current sentence is a little long and confusing. I'll take the content from a separate PR I submitted about document types.", "author": "mtdowling", "createdAt": "2020-07-15T19:38:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIwNjY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIxMjM3NQ==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455212375", "bodyText": "The previous text used plurals to indicate that maps can contain multiple key value pairs, but that is now lost.", "author": "kstich", "createdAt": "2020-07-15T17:24:17Z", "path": "docs/source/1.0/spec/core/model.rst", "diffHunk": "@@ -0,0 +1,2705 @@\n+.. _smithy-model:\n+\n+============\n+Smithy model\n+============\n+\n+This is the specification of Smithy, an interface definition language and set\n+of tools used to build clients, servers, and other kinds of artifacts through\n+model transformations. This specification is at version |release|.\n+\n+.. contents:: Table of contents\n+    :depth: 1\n+    :local:\n+    :backlinks: none\n+\n+\n+---------------------------------\n+Conventions used in this document\n+---------------------------------\n+\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n+\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n+document are to be interpreted as described in :rfc:`2119`.\n+\n+This specification makes use of the Augmented Backus-Naur Form (ABNF)\n+:rfc:`5234` notation, including the *core rules* defined in Appendix B\n+of that document.\n+\n+Readers are invited to report technical errors and ambiguities in this\n+specification to the Smithy GitHub repository at https://github.com/awslabs/smithy.\n+This specification is open source, so contributions are welcome.\n+\n+.. rubric:: Examples\n+\n+Unless declared otherwise, example Smithy models given in this specification\n+are written using the :ref:`Smithy interface definition language (IDL) <idl>`\n+syntax. Complementary :ref:`JSON AST <json-ast>` examples are provided\n+alongside Smithy IDL examples where appropriate. For example:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1.0\"\n+\n+        metadata foo = \"bar\"\n+\n+        namespace smithy.example\n+\n+        use smithy.other.namespace#MyString\n+\n+        structure MyStructure {\n+            @required\n+            foo: MyString\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"bar\"\n+            },\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.other.namespace#MyString\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _smithy-framework:\n+\n+----------------\n+Smithy framework\n+----------------\n+\n+Smithy is a framework that consists of a semantic model, file formats used to\n+define a model, and a build process used to validate models and facilitate\n+model transformations.\n+\n+.. text-figure::\n+    :caption: **Figure 1.1**: Smithy framework concepts\n+    :name: figure-1.1\n+\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 part of          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    \u2502                \u2502\u2572                \u2571\u2502                \u2502\n+                    \u2502 Semantic Model \u2502\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502   Model File   \u2502\n+                    \u2502                \u2502\u2571                \u2572\u2502                \u2502\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                               split into       \u2572\u2502\u2571\n+                                                                 \u25cb\n+                                                                 \u2502\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                           \u253c\n+                    \u2502JSON AST (.json)\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502         \u2502                \u2502\n+                                              \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b7\u2502 Representation \u2502\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502         \u2502                \u2502\n+                    \u2502 IDL (.smithy)  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+Semantic model\n+    The in-memory model used by tools. The :ref:`semantic model <semantic-model>`\n+    may be serialized into one or more model file representations.\n+Model File\n+    A file on the file system, in a particular representation. The model files\n+    that make up a semantic model MAY be split across multiple files to\n+    improve readability or modularity, and those files are not required to\n+    use the same representation.\n+Representation\n+    A particular model file format such as the Smithy IDL or JSON AST.\n+    Representations are loaded into the semantic model by mapping the\n+    representation to concepts in the semantic model.\n+\n+    * The :ref:`Smithy IDL <idl>` is a human-readable format that aims to\n+      streamline authoring and reading models.\n+    * The :ref:`JSON AST <json-ast>` aims to provide a more machine-readable\n+      format to easily share models across language implementations and better\n+      integrate with JSON-based ecosystems.\n+\n+\n+Model transformations\n+=====================\n+\n+The build process mentioned above performs a number of model transformations.\n+A :dfn:`model transformation` is the process of converting input model files\n+into output artifacts. Generated artifacts can be other Smithy models\n+(an endogenous transformation), other model formats (an exogenous\n+transformation), code, documentation, etc.\n+\n+.. text-figure::\n+    :caption: **Figure 1.2**: Smithy model transformations\n+    :name: figure-1.2\n+\n+           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+           \u2502               \u2502\u2572           \u2502               \u2502           \u2571\u2502               \u2502\n+           \u2502Semantic Model \u2502\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502Transformation \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502   Artifact    \u2502\n+           \u2502               \u2502\u2571           \u2502               \u2502           \u2572\u2502               \u2502\n+           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                                \u25b3\n+                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                   \u2502                            \u2502                            \u2502\n+           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+           \u2502Model to Model \u2502            \u2502   Model to    \u2502            \u2502  Artifact to  \u2502\n+           \u2502Transformation \u2502            \u2502   Artifact    \u2502            \u2502     Model     \u2502\n+           \u2502               \u2502            \u2502Transformation \u2502            \u2502Transformation \u2502\n+           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+\n+.. _semantic-model:\n+\n+------------------\n+The semantic model\n+------------------\n+\n+Smithy's *semantic model* is an in-memory model used by tools. It is\n+independent of any particular serialized representation. The semantic\n+model contains metadata and a graph of :ref:`shapes <shapes>`\n+connected by :ref:`shape IDs <shape-id>`.\n+\n+.. text-figure::\n+    :caption: **Figure 1.3**: The semantic model\n+    :name: figure-1.3\n+\n+                                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                                          \u2502Semantic Model \u2502\u2572\n+                                          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                                          \u2502metadata?      \u2502\u2571         \u2502\n+                                          \u2502               \u2502          \u2502\n+                                          \u2502               \u2502          \u2502\n+                                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n+                                                  \u253c     \u253c prelude    \u2502\n+                                                  \u2502     \u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                                  \u25cb\n+                                           shapes\u2571\u2502\u2572\n+        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+        \u2502 Applied Trait \u2502\u2572          shape \u2502  \u00ababstract\u00bb   \u2502\n+        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502     Shape     \u2502            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+        \u2502               \u2502\u2571                \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524            \u2502    ShapeID    \u2502\n+        \u2502               \u2502                 \u2502               \u2502            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+        \u2502               \u2502\u2572     applied-to \u2502               \u2502         id \u2502namespace      \u2502\n+        \u2502               \u2502\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502               \u2502\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502shape_name     \u2502\n+        \u2502               \u2502\u2571traits          \u2502               \u2502            \u2502member_name?   \u2502\n+        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+Shape\n+    Shapes are named data definitions that describe the structure of an API.\n+    Shapes are referenced and connected by :ref:`shape IDs <shape-id>`.\n+    Relationships between shapes are formed by :ref:`members <member>` that\n+    target other shapes, properties of shapes like the ``input`` and\n+    ``output`` properties of an :ref:`operation <operation>`, and\n+    :ref:`applied traits <applying-traits>` that attach a trait to a shape.\n+Shape ID\n+    A :ref:`shape ID <shape-id>` is used to identify shapes defined in a\n+    model. For example, ``smithy.example#MyShape``,\n+    ``smithy.example#Foo$bar``, and ``Baz`` are all different kinds of shape\n+    IDs.\n+Trait\n+    :ref:`Traits <traits>` are specialized shapes that form the basis of\n+    Smithy's meta-model. Traits are applied to shapes to associate metadata\n+    to a shape. They are typically used by tools to influence validation,\n+    serialization, and code generation.\n+Applied trait\n+    An applied trait is an instance of a trait applied to a shape, configured\n+    using a :ref:`node value <node-value>`.\n+Model metadata\n+    Metadata is a schema-less extensibility mechanism used to associate\n+    metadata to an entire model. For example, metadata is used to define\n+    :ref:`validators <validator-definition>` and model-wide\n+    :ref:`suppressions <suppression-definition>`. Metadata is defined\n+    using an ``object`` :ref:`node value <node-value>`.\n+Prelude\n+    The :ref:`prelude <prelude>` defines various simple shapes and every\n+    trait defined in the core specification. All Smithy models automatically\n+    include the prelude.\n+\n+\n+.. _model-files:\n+\n+-----------\n+Model files\n+-----------\n+\n+Smithy models MAY be divided into multiple files so that they are easier to\n+maintain and evolve. One or more model files can be assembled (or merged)\n+together to form a semantic model. The model files that form a semantic model\n+are not required to all be defined in the same representation; some models can\n+be defined using the IDL and others can be defined using the JSON AST.\n+\n+Model files do not explicitly include other model files; this responsibility\n+is left to tooling to ensure that all necessary model files are merged\n+together to form a valid semantic model.\n+\n+.. _merging-models:\n+\n+Merging model files\n+===================\n+\n+Implementations MUST take the following steps to merge models together to load\n+the semantic model:\n+\n+#. Duplicate shape IDs, if found, MUST cause the model merge to fail.\n+   See :ref:`shape-id-conflicts` for more information.\n+#. Merge any conflicting applied traits using\n+   :ref:`trait conflict resolution  <trait-conflict-resolution>`.\n+#. Merge the metadata objects of both models using the steps defined\n+   in :ref:`merging-metadata`.\n+\n+\n+.. _merging-metadata:\n+\n+Merging metadata\n+----------------\n+\n+When a conflict occurs between top-level metadata key-value pairs,\n+metadata is merged using the following logic:\n+\n+1. If a metadata key is only present in one model, then the entry is valid\n+   and added to the merged model.\n+2. If both models contain the same key and both values are arrays, then\n+   the entry is valid; the values of both arrays are concatenated into a\n+   single array and added to the merged model.\n+3. If both models contain the same key and both values are exactly equal,\n+   then the conflict is ignored and the value is added to the merged model.\n+4. If both models contain the same key and the values do not both map to\n+   arrays, then the key is invalid and there is a metadata conflict error.\n+\n+Given the following two Smithy models:\n+\n+.. code-block:: smithy\n+    :caption: model-a.smithy\n+\n+    metadata \"foo\" = [\"baz\", \"bar\"]\n+    metadata \"qux\" = \"test\"\n+    metadata \"validConflict\" = \"hi!\"\n+\n+.. code-block:: smithy\n+    :caption: model-b.smithy\n+\n+    metadata \"foo\" = [\"lorem\", \"ipsum\"]\n+    metadata \"lorem\" = \"ipsum\"\n+    metadata \"validConflict\" = \"hi!\"\n+\n+Merging ``model-a.smithy`` and ``model-b.smithy`` produces the following\n+model:\n+\n+.. code-block:: smithy\n+\n+    metadata \"foo\" = [\"baz\", \"bar\", \"lorem\", \"ipsum\"]\n+    metadata \"qux\" = \"test\"\n+    metadata \"lorem\" = \"ipsum\"\n+    metadata \"validConflict\" = \"hi!\"\n+\n+\n+.. _node-value:\n+\n+-----------\n+Node values\n+-----------\n+\n+Node values are JSON-like values used in the following places in the\n+semantic model:\n+\n+* **metadata**: Metadata is defined as a node value object.\n+* **applied trait**: The value of a trait applied to a shape is defined\n+  using a node value.\n+\n+.. text-figure::\n+    :caption: **Figure 1.4**: Node value types\n+    :name: figure-1.4\n+\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 Semantic Model  \u2502                     \u2502Applied Trait\u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+      \u2502                                            \u2502\n+      \u2502                                            \u2502\n+      \u2502                                            \u253c nodeValue\n+      \u2502                                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+      \u2502                                     \u2502 \u00ababstract\u00bb  \u2502\n+      \u2502                                     \u2502    Value    \u2502\n+      \u2502metadata                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+      \u2502                                            \u25b3\n+      \u25cb      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+      \u253c      \u2502                   \u2502                 \u2502               \u2502               \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502     Object      \u2502 \u2502      Array      \u2502 \u2502   Number    \u2502 \u2502   Boolean   \u2502 \u2502   String    \u2502\n+    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2502members:         \u2502 \u2502members: [Value] \u2502\n+    \u2502  [String, Value]\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+The following example defines metadata using a node value:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        metadata foo = \"hello\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"hello\"\n+            }\n+        }\n+\n+The following example defines a trait using a node value:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @length(min: 1, max: 10)\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#length\": {\n+                            \"min\": 1,\n+                            \"max\": 10\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+Node value types\n+================\n+\n+Node values have the same data model as JSON; they consist of the following\n+kinds of values:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 30 70\n+\n+    * - Type\n+      - Description\n+    * - null\n+      - The lack of a value\n+    * - string\n+      - A UTF-8 string\n+    * - number\n+      - A double precision floating point number\n+    * - boolean\n+      - A Boolean, true or false value\n+    * - array\n+      - A list of heterogeneous node values\n+    * - object\n+      - A map of string keys to heterogeneous node values\n+\n+.. rubric:: Shape IDs, text blocks, et al.\n+\n+There is no specific node value type for shape IDs, text blocks, or\n+other higher-level features of the IDL; these values are stored and\n+treated in the semantic model as simply opaque strings, and their\n+validation happens before the creation of the model.\n+\n+\n+.. _shapes:\n+\n+------\n+Shapes\n+------\n+\n+Smithy models are made up of shapes. Shapes come in three kinds: simple,\n+aggregate, and service. A simple shape defines atomic or primitive values\n+such as ``integer`` and ``string``. Aggregate shapes have members such as\n+a list of strings or an ``Address`` structure. Service shapes have specific\n+semantics, unlike the very generic simple and aggregate shapes, as they\n+represent either a service, a resource managed by a service, or operations\n+on services and resources.\n+\n+Shapes are visualized using the following diagram:\n+\n+.. text-figure::\n+    :caption: **Figure 1.5**: Smithy shapes\n+    :name: figure-1.5\n+\n+                                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                             members \u2571\u2502 \u00ababstract\u00bb  \u2502\n+                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502    Shape    \u2502\n+                            \u2502        \u2572\u2502             \u2502\n+                            \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                            \u2502                \u25b3\n+                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                  \u2502         \u2502                \u2502                    \u2502\n+          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+          \u2502  \u00ababstract\u00bb   \u2502 \u2502container\u2502 \u00ababstract\u00bb  \u2502      \u2502 \u00ababstract\u00bb  \u2502\n+          \u2502    Simple     \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502  Aggregate  \u2502      \u2502   Service   \u2502\n+          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                  \u25b3                    \u25b3                    \u25b3\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502blob      \u2502\u2500\u2500\u253c\u2500\u2500\u2502boolean   \u2502      \u251c\u2500\u2500\u2500\u2500\u2502    List    \u2502  \u2502    \u2502         Service         \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u2502member      \u2502  \u2502    \u2502version                  \u2502\n+    \u2502document  \u2502\u2500\u2500\u253c\u2500\u2500\u2502string    \u2502      \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u251c\u2500\u2500\u2500\u2500\u2502operations: [Operation]? \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502resources: [Resource]?   \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502                    \u251c\u2500\u2500\u2500\u2500\u2502    Set     \u2502  \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2502timestamp \u2502\u2500\u2500\u2524                    \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502                    \u2502    \u2502member      \u2502  \u2502    \u2502        Operation        \u2502\n+                  \u2502                    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502input: Structure?        \u2502\n+          \u2502  \u00ababstract\u00bb   \u2502            \u251c\u2500\u2500\u2500\u2500\u2502    Map     \u2502  \u251c\u2500\u2500\u2500\u2500\u2502output: Structure?       \u2502\n+          \u2502    Number     \u2502            \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    \u2502errors: [Structure]?     \u2502\n+          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502    \u2502key         \u2502  \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                  \u25b3                    \u2502    \u2502value       \u2502  \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502        Resource         \u2502\n+    \u2502byte      \u2502\u2500\u2500\u253c\u2500\u2500\u2502short     \u2502      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u251c\u2500\u2500\u2500\u2500\u2502 Structure  \u2502  \u2502    \u2502identifiers?             \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502create: Operation?       \u2502\n+    \u2502integer   \u2502\u2500\u2500\u253c\u2500\u2500\u2502long      \u2502      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502put: Operation?          \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2502   Union    \u2502  \u2502    \u2502read: Operation?         \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2502update: Operation?       \u2502\n+    \u2502float     \u2502\u2500\u2500\u253c\u2500\u2500\u2502double    \u2502                                \u2502delete: Operation?       \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2502list: : Operation?       \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                \u2502operations: [Operation]? \u2502\n+    \u2502bigInteger\u2502\u2500\u2500\u2534\u2500\u2500\u2502bigDecimal\u2502                                \u2502collectionOperations:    \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2502    [Operation]?         \u2502\n+                                                                 \u2502resources: [Resource]?   \u2502\n+                                                                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+\n+.. _shape-id:\n+\n+Shape ID\n+========\n+\n+All shapes have an assigned shape ID. A :dfn:`shape ID` is used to refer to\n+shapes in the model. Shape IDs adhere to the following syntax:\n+\n+.. code-block:: none\n+\n+    com.foo.baz#ShapeName$memberName\n+    \\_________/ \\_______/ \\________/\n+         |          |          |\n+     Namespace  Shape name  Member name\n+\n+Namespace\n+    A namespace is mechanism for logically grouping shapes in a way\n+    that makes them reusable alongside other models without naming\n+    conflicts. A semantic model MAY contain shapes defined across multiple\n+    namespaces. The IDL representation supports zero or one namespace per\n+    model file, while the JSON AST representation supports zero or more\n+    namespaces per model file.\n+Absolute shape ID\n+    An :dfn:`absolute shape ID` starts with a :token:`namespace` name,\n+    followed by \"``#``\", followed by a *relative shape ID*. All shape\n+    IDs in the semantic model MUST be absolute.\n+    For example, ``smithy.example#Foo`` and ``smithy.example#Foo$bar``\n+    are absolute shape IDs.\n+Relative shape ID\n+    A :dfn:`relative shape ID` contains a :token:`shape name <identifier>`\n+    and an optional :token:`member name <identifier>`. The shape name and\n+    member name are separated by the \"``$``\" symbol if a member name is\n+    present. For example, ``Foo`` and ``Foo$bar`` are relative shape IDs.\n+Root shape ID\n+    A :dfn:`root shape ID` is a shape ID that does not contain a member.\n+    For example, ``smithy.example#Foo`` and ``Foo`` are root shape IDs.\n+\n+.. rubric:: Shape ID ABNF\n+\n+Shape IDs are formally defined by the following ABNF:\n+\n+.. productionlist:: smithy\n+    shape_id               :`root_shape_id` [`shape_id_member`]\n+    root_shape_id          :`absolute_root_shape_id` / `identifier`\n+    absolute_root_shape_id :`namespace` \"#\" `identifier`\n+    namespace              :`identifier` *(\".\" `identifier`)\n+    identifier             :(ALPHA / \"_\") *(ALPHA / DIGIT / \"_\")\n+    shape_id_member        :\"$\" `identifier`\n+\n+.. rubric:: Best practices for defining shape names\n+\n+Consumers of a Smithy model MAY choose to inflect shape names, structure\n+member names, and other facets of a Smithy model in order to expose a more\n+idiomatic experience to particular programming languages. In order to make this\n+easier for consumers of a model, model authors SHOULD utilize a strict form of\n+PascalCase in which only the first letter of acronyms, abbreviations, and\n+initialisms are capitalized.\n+\n+===========   ===============\n+Recommended   Not recommended\n+===========   ===============\n+UserId        UserID\n+ResourceArn   ResourceARN\n+IoChannel     IOChannel\n+HtmlEntity    HTMLEntity\n+HtmlEntity    HTML_Entity\n+===========   ===============\n+\n+\n+.. _shape-id-conflicts:\n+\n+Shape ID conflicts\n+==================\n+\n+While shape ID references within the semantic model are case-sensitive, no\n+two shapes in the semantic model can have the same case-insensitive shape ID.\n+This restriction makes it easier to use Smithy models for code generation in\n+programming languages that do not support case-sensitive identifiers or that\n+perform some kind of normalization on generated identifiers (for example,\n+a Python code generator might convert all member names to lower snake case).\n+To illustrate, ``com.Foo#baz`` and ``com.foo#BAZ`` are not allowed in the\n+same semantic model. This restriction also extends to member names:\n+``com.foo#Baz$bar`` and ``com.foo#Baz$BAR`` are in conflict.\n+\n+\n+.. _simple-types:\n+\n+-------------\n+Simple shapes\n+-------------\n+\n+*Simple types* are types that do not contain nested types or shape references.\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 90\n+\n+    * - Type\n+      - Description\n+    * - blob\n+      - Uninterpreted binary data\n+    * - boolean\n+      - Boolean value type\n+    * - string\n+      - UTF-8 encoded string\n+    * - byte\n+      - 8-bit signed integer ranging from -128 to 127 (inclusive)\n+    * - short\n+      - 16-bit signed integer ranging from -32,768 to 32,767 (inclusive)\n+    * - integer\n+      - 32-bit signed integer ranging from -2^31 to (2^31)-1 (inclusive)\n+    * - long\n+      - 64-bit signed integer ranging from -2^63 to (2^63)-1 (inclusive)\n+    * - float\n+      - Single precision IEEE-754 floating point number\n+    * - double\n+      - Double precision IEEE-754 floating point number\n+    * - bigInteger\n+      - Arbitrarily large signed integer\n+    * - bigDecimal\n+      - Arbitrary precision signed decimal number\n+    * - timestamp\n+      - Represents an instant in time with no UTC offset or timezone. The\n+        serialization of a timestamp is an implementation detail that is\n+        determined by a :ref:`protocol <protocolDefinition-trait>` and\n+        MUST NOT have any effect on the types exposed by tooling to\n+        represent a timestamp value.\n+    * - document\n+      - Represents a protocol-agnostic untyped value used to represent open\n+        content, or data with no fixed schema, data that can't be modeled\n+        using rigid types, or data that has a schema that evolves outside\n+        of the purview of a service. The serialization format of a document\n+        is an implementation detail of a protocol and MUST NOT have any\n+        effect on the types exposed by tooling to represent a document value.\n+\n+Simple shapes are defined in the IDL using a :ref:`simple_shape_statement <idl-simple>`.\n+\n+.. note::\n+\n+    The :ref:`prelude model <prelude>` contains pre-defined shapes for every\n+    simple type.\n+\n+.. rubric:: Simple shape examples\n+\n+The following example defines a shape for each simple type in the\n+``smithy.example`` namespace.\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        blob Blob\n+        boolean Boolean\n+        string String\n+        byte Byte\n+        short Short\n+        integer Integer\n+        long Long\n+        float Float\n+        double Double\n+        bigInteger BigInteger\n+        bigDecimal BigDecimal\n+        timestamp Timestamp\n+        document Document\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#Blob\": {\n+                    \"type\": \"blob\"\n+                },\n+                \"smithy.example#Boolean\": {\n+                    \"type\": \"boolean\"\n+                },\n+                \"smithy.example#String\": {\n+                    \"type\": \"string\"\n+                },\n+                \"smithy.example#Byte\": {\n+                    \"type\": \"byte\"\n+                },\n+                \"smithy.example#Short\": {\n+                    \"type\": \"short\"\n+                },\n+                \"smithy.example#Integer\": {\n+                    \"type\": \"integer\"\n+                },\n+                \"smithy.example#Long\": {\n+                    \"type\": \"long\"\n+                },\n+                \"smithy.example#Float\": {\n+                    \"type\": \"float\"\n+                },\n+                \"smithy.example#Double\": {\n+                    \"type\": \"double\"\n+                },\n+                \"smithy.example#BigInteger\": {\n+                    \"type\": \"bigInteger\"\n+                },\n+                \"smithy.example#BigDecimal\": {\n+                    \"type\": \"bigDecimal\"\n+                },\n+                \"smithy.example#Timestamp\": {\n+                    \"type\": \"timestamp\"\n+                },\n+                \"smithy.example#Document\": {\n+                    \"type\": \"document\"\n+                }\n+            }\n+        }\n+\n+.. note::\n+\n+    When defining shapes in the IDL, a namespace MUST first be declared.\n+\n+\n+.. _aggregate-types:\n+\n+----------------\n+Aggregate shapes\n+----------------\n+\n+Aggregate types define shapes that are composed of other shapes. Aggregate shapes\n+reference other shapes using :ref:`members <member>`.\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 90\n+\n+    * - Type\n+      - Description\n+    * - :ref:`member`\n+      - Defined in aggregate shapes to reference other shapes\n+    * - :ref:`list`\n+      - Ordered collection of homogeneous values\n+    * - :ref:`set`\n+      - Unordered collection of unique homogeneous values\n+    * - :ref:`map`\n+      - Map data structure that maps string keys to homogeneous values\n+    * - :ref:`structure`\n+      - Fixed set of named heterogeneous members\n+    * - :ref:`union`\n+      - Tagged union data structure that can take on one of several\n+        different, but fixed, types\n+\n+\n+.. _member:\n+\n+Member\n+======\n+\n+:dfn:`Members` are defined in aggregate shapes to reference other shapes using\n+a :ref:`shape ID <shape-id>`. The shape referenced by a member is called its\n+\"target\". A member MUST NOT target a :ref:`trait <trait-shapes>`, ``operation``,\n+``resource``, ``service``, or ``member``.\n+\n+\n+.. _list:\n+\n+List\n+====\n+\n+The :dfn:`list` type represents an ordered homogeneous collection of values.\n+A list shape requires a single member named ``member``. Lists are defined\n+in the IDL using a :ref:`list_statement <idl-list>`.\n+\n+The following example defines a list with a string member from the\n+:ref:`prelude <prelude>`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        list MyList {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {\n+                    \"type\": \"list\",\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+.. rubric:: List member shape ID\n+\n+The shape ID of the member of a list is the list shape ID followed by\n+``$member``. For example, the shape ID of the list member in the above\n+example is ``smithy.example#MyList$member``.\n+\n+\n+.. _set:\n+\n+Set\n+===\n+\n+The :dfn:`set` type represents an unordered collection of unique homogeneous\n+values. A set shape requires a single member named ``member``.\n+Sets are defined in the IDL using a :ref:`set_statement <idl-set>`.\n+\n+The following example defines a set of strings:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        set StringSet {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#StringSet\": {\n+                    \"type\": \"set\",\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+.. rubric:: Set member shape ID\n+\n+The shape ID of the member of a set is the set shape ID followed by\n+``$member``. For example, the shape ID of the set member in the above\n+example is ``smithy.example#StringSet$member``.\n+\n+.. rubric:: Language support for sets\n+\n+Not all programming languages support set data structures. Such languages\n+SHOULD represent sets as a custom set data structure that can interpret value\n+hash codes and equality, or alternatively, store the values of a set data\n+structure in a list and rely on validation to ensure uniqueness.\n+\n+\n+.. _map:\n+\n+Map\n+===\n+\n+The :dfn:`map` type represents a map data structure that maps a", "originalCommit": "ab2e617e464b006292aef001fb460b490077de09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIxNDI4Nw==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455214287", "bodyText": "Seems deliberate since it's different from the previous spec, but the previous examples in the aggregate types section don't have traits.", "author": "kstich", "createdAt": "2020-07-15T17:27:22Z", "path": "docs/source/1.0/spec/core/model.rst", "diffHunk": "@@ -0,0 +1,2705 @@\n+.. _smithy-model:\n+\n+============\n+Smithy model\n+============\n+\n+This is the specification of Smithy, an interface definition language and set\n+of tools used to build clients, servers, and other kinds of artifacts through\n+model transformations. This specification is at version |release|.\n+\n+.. contents:: Table of contents\n+    :depth: 1\n+    :local:\n+    :backlinks: none\n+\n+\n+---------------------------------\n+Conventions used in this document\n+---------------------------------\n+\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n+\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n+document are to be interpreted as described in :rfc:`2119`.\n+\n+This specification makes use of the Augmented Backus-Naur Form (ABNF)\n+:rfc:`5234` notation, including the *core rules* defined in Appendix B\n+of that document.\n+\n+Readers are invited to report technical errors and ambiguities in this\n+specification to the Smithy GitHub repository at https://github.com/awslabs/smithy.\n+This specification is open source, so contributions are welcome.\n+\n+.. rubric:: Examples\n+\n+Unless declared otherwise, example Smithy models given in this specification\n+are written using the :ref:`Smithy interface definition language (IDL) <idl>`\n+syntax. Complementary :ref:`JSON AST <json-ast>` examples are provided\n+alongside Smithy IDL examples where appropriate. For example:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1.0\"\n+\n+        metadata foo = \"bar\"\n+\n+        namespace smithy.example\n+\n+        use smithy.other.namespace#MyString\n+\n+        structure MyStructure {\n+            @required\n+            foo: MyString\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"bar\"\n+            },\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.other.namespace#MyString\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _smithy-framework:\n+\n+----------------\n+Smithy framework\n+----------------\n+\n+Smithy is a framework that consists of a semantic model, file formats used to\n+define a model, and a build process used to validate models and facilitate\n+model transformations.\n+\n+.. text-figure::\n+    :caption: **Figure 1.1**: Smithy framework concepts\n+    :name: figure-1.1\n+\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 part of          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    \u2502                \u2502\u2572                \u2571\u2502                \u2502\n+                    \u2502 Semantic Model \u2502\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502   Model File   \u2502\n+                    \u2502                \u2502\u2571                \u2572\u2502                \u2502\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                               split into       \u2572\u2502\u2571\n+                                                                 \u25cb\n+                                                                 \u2502\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                           \u253c\n+                    \u2502JSON AST (.json)\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502         \u2502                \u2502\n+                                              \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b7\u2502 Representation \u2502\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502         \u2502                \u2502\n+                    \u2502 IDL (.smithy)  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+Semantic model\n+    The in-memory model used by tools. The :ref:`semantic model <semantic-model>`\n+    may be serialized into one or more model file representations.\n+Model File\n+    A file on the file system, in a particular representation. The model files\n+    that make up a semantic model MAY be split across multiple files to\n+    improve readability or modularity, and those files are not required to\n+    use the same representation.\n+Representation\n+    A particular model file format such as the Smithy IDL or JSON AST.\n+    Representations are loaded into the semantic model by mapping the\n+    representation to concepts in the semantic model.\n+\n+    * The :ref:`Smithy IDL <idl>` is a human-readable format that aims to\n+      streamline authoring and reading models.\n+    * The :ref:`JSON AST <json-ast>` aims to provide a more machine-readable\n+      format to easily share models across language implementations and better\n+      integrate with JSON-based ecosystems.\n+\n+\n+Model transformations\n+=====================\n+\n+The build process mentioned above performs a number of model transformations.\n+A :dfn:`model transformation` is the process of converting input model files\n+into output artifacts. Generated artifacts can be other Smithy models\n+(an endogenous transformation), other model formats (an exogenous\n+transformation), code, documentation, etc.\n+\n+.. text-figure::\n+    :caption: **Figure 1.2**: Smithy model transformations\n+    :name: figure-1.2\n+\n+           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+           \u2502               \u2502\u2572           \u2502               \u2502           \u2571\u2502               \u2502\n+           \u2502Semantic Model \u2502\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502Transformation \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502   Artifact    \u2502\n+           \u2502               \u2502\u2571           \u2502               \u2502           \u2572\u2502               \u2502\n+           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                                \u25b3\n+                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                   \u2502                            \u2502                            \u2502\n+           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+           \u2502Model to Model \u2502            \u2502   Model to    \u2502            \u2502  Artifact to  \u2502\n+           \u2502Transformation \u2502            \u2502   Artifact    \u2502            \u2502     Model     \u2502\n+           \u2502               \u2502            \u2502Transformation \u2502            \u2502Transformation \u2502\n+           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+\n+.. _semantic-model:\n+\n+------------------\n+The semantic model\n+------------------\n+\n+Smithy's *semantic model* is an in-memory model used by tools. It is\n+independent of any particular serialized representation. The semantic\n+model contains metadata and a graph of :ref:`shapes <shapes>`\n+connected by :ref:`shape IDs <shape-id>`.\n+\n+.. text-figure::\n+    :caption: **Figure 1.3**: The semantic model\n+    :name: figure-1.3\n+\n+                                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                                          \u2502Semantic Model \u2502\u2572\n+                                          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                                          \u2502metadata?      \u2502\u2571         \u2502\n+                                          \u2502               \u2502          \u2502\n+                                          \u2502               \u2502          \u2502\n+                                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n+                                                  \u253c     \u253c prelude    \u2502\n+                                                  \u2502     \u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                                  \u25cb\n+                                           shapes\u2571\u2502\u2572\n+        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+        \u2502 Applied Trait \u2502\u2572          shape \u2502  \u00ababstract\u00bb   \u2502\n+        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502     Shape     \u2502            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+        \u2502               \u2502\u2571                \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524            \u2502    ShapeID    \u2502\n+        \u2502               \u2502                 \u2502               \u2502            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+        \u2502               \u2502\u2572     applied-to \u2502               \u2502         id \u2502namespace      \u2502\n+        \u2502               \u2502\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502               \u2502\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502shape_name     \u2502\n+        \u2502               \u2502\u2571traits          \u2502               \u2502            \u2502member_name?   \u2502\n+        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+Shape\n+    Shapes are named data definitions that describe the structure of an API.\n+    Shapes are referenced and connected by :ref:`shape IDs <shape-id>`.\n+    Relationships between shapes are formed by :ref:`members <member>` that\n+    target other shapes, properties of shapes like the ``input`` and\n+    ``output`` properties of an :ref:`operation <operation>`, and\n+    :ref:`applied traits <applying-traits>` that attach a trait to a shape.\n+Shape ID\n+    A :ref:`shape ID <shape-id>` is used to identify shapes defined in a\n+    model. For example, ``smithy.example#MyShape``,\n+    ``smithy.example#Foo$bar``, and ``Baz`` are all different kinds of shape\n+    IDs.\n+Trait\n+    :ref:`Traits <traits>` are specialized shapes that form the basis of\n+    Smithy's meta-model. Traits are applied to shapes to associate metadata\n+    to a shape. They are typically used by tools to influence validation,\n+    serialization, and code generation.\n+Applied trait\n+    An applied trait is an instance of a trait applied to a shape, configured\n+    using a :ref:`node value <node-value>`.\n+Model metadata\n+    Metadata is a schema-less extensibility mechanism used to associate\n+    metadata to an entire model. For example, metadata is used to define\n+    :ref:`validators <validator-definition>` and model-wide\n+    :ref:`suppressions <suppression-definition>`. Metadata is defined\n+    using an ``object`` :ref:`node value <node-value>`.\n+Prelude\n+    The :ref:`prelude <prelude>` defines various simple shapes and every\n+    trait defined in the core specification. All Smithy models automatically\n+    include the prelude.\n+\n+\n+.. _model-files:\n+\n+-----------\n+Model files\n+-----------\n+\n+Smithy models MAY be divided into multiple files so that they are easier to\n+maintain and evolve. One or more model files can be assembled (or merged)\n+together to form a semantic model. The model files that form a semantic model\n+are not required to all be defined in the same representation; some models can\n+be defined using the IDL and others can be defined using the JSON AST.\n+\n+Model files do not explicitly include other model files; this responsibility\n+is left to tooling to ensure that all necessary model files are merged\n+together to form a valid semantic model.\n+\n+.. _merging-models:\n+\n+Merging model files\n+===================\n+\n+Implementations MUST take the following steps to merge models together to load\n+the semantic model:\n+\n+#. Duplicate shape IDs, if found, MUST cause the model merge to fail.\n+   See :ref:`shape-id-conflicts` for more information.\n+#. Merge any conflicting applied traits using\n+   :ref:`trait conflict resolution  <trait-conflict-resolution>`.\n+#. Merge the metadata objects of both models using the steps defined\n+   in :ref:`merging-metadata`.\n+\n+\n+.. _merging-metadata:\n+\n+Merging metadata\n+----------------\n+\n+When a conflict occurs between top-level metadata key-value pairs,\n+metadata is merged using the following logic:\n+\n+1. If a metadata key is only present in one model, then the entry is valid\n+   and added to the merged model.\n+2. If both models contain the same key and both values are arrays, then\n+   the entry is valid; the values of both arrays are concatenated into a\n+   single array and added to the merged model.\n+3. If both models contain the same key and both values are exactly equal,\n+   then the conflict is ignored and the value is added to the merged model.\n+4. If both models contain the same key and the values do not both map to\n+   arrays, then the key is invalid and there is a metadata conflict error.\n+\n+Given the following two Smithy models:\n+\n+.. code-block:: smithy\n+    :caption: model-a.smithy\n+\n+    metadata \"foo\" = [\"baz\", \"bar\"]\n+    metadata \"qux\" = \"test\"\n+    metadata \"validConflict\" = \"hi!\"\n+\n+.. code-block:: smithy\n+    :caption: model-b.smithy\n+\n+    metadata \"foo\" = [\"lorem\", \"ipsum\"]\n+    metadata \"lorem\" = \"ipsum\"\n+    metadata \"validConflict\" = \"hi!\"\n+\n+Merging ``model-a.smithy`` and ``model-b.smithy`` produces the following\n+model:\n+\n+.. code-block:: smithy\n+\n+    metadata \"foo\" = [\"baz\", \"bar\", \"lorem\", \"ipsum\"]\n+    metadata \"qux\" = \"test\"\n+    metadata \"lorem\" = \"ipsum\"\n+    metadata \"validConflict\" = \"hi!\"\n+\n+\n+.. _node-value:\n+\n+-----------\n+Node values\n+-----------\n+\n+Node values are JSON-like values used in the following places in the\n+semantic model:\n+\n+* **metadata**: Metadata is defined as a node value object.\n+* **applied trait**: The value of a trait applied to a shape is defined\n+  using a node value.\n+\n+.. text-figure::\n+    :caption: **Figure 1.4**: Node value types\n+    :name: figure-1.4\n+\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 Semantic Model  \u2502                     \u2502Applied Trait\u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+      \u2502                                            \u2502\n+      \u2502                                            \u2502\n+      \u2502                                            \u253c nodeValue\n+      \u2502                                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+      \u2502                                     \u2502 \u00ababstract\u00bb  \u2502\n+      \u2502                                     \u2502    Value    \u2502\n+      \u2502metadata                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+      \u2502                                            \u25b3\n+      \u25cb      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+      \u253c      \u2502                   \u2502                 \u2502               \u2502               \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502     Object      \u2502 \u2502      Array      \u2502 \u2502   Number    \u2502 \u2502   Boolean   \u2502 \u2502   String    \u2502\n+    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2502members:         \u2502 \u2502members: [Value] \u2502\n+    \u2502  [String, Value]\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+The following example defines metadata using a node value:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        metadata foo = \"hello\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"hello\"\n+            }\n+        }\n+\n+The following example defines a trait using a node value:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @length(min: 1, max: 10)\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#length\": {\n+                            \"min\": 1,\n+                            \"max\": 10\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+Node value types\n+================\n+\n+Node values have the same data model as JSON; they consist of the following\n+kinds of values:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 30 70\n+\n+    * - Type\n+      - Description\n+    * - null\n+      - The lack of a value\n+    * - string\n+      - A UTF-8 string\n+    * - number\n+      - A double precision floating point number\n+    * - boolean\n+      - A Boolean, true or false value\n+    * - array\n+      - A list of heterogeneous node values\n+    * - object\n+      - A map of string keys to heterogeneous node values\n+\n+.. rubric:: Shape IDs, text blocks, et al.\n+\n+There is no specific node value type for shape IDs, text blocks, or\n+other higher-level features of the IDL; these values are stored and\n+treated in the semantic model as simply opaque strings, and their\n+validation happens before the creation of the model.\n+\n+\n+.. _shapes:\n+\n+------\n+Shapes\n+------\n+\n+Smithy models are made up of shapes. Shapes come in three kinds: simple,\n+aggregate, and service. A simple shape defines atomic or primitive values\n+such as ``integer`` and ``string``. Aggregate shapes have members such as\n+a list of strings or an ``Address`` structure. Service shapes have specific\n+semantics, unlike the very generic simple and aggregate shapes, as they\n+represent either a service, a resource managed by a service, or operations\n+on services and resources.\n+\n+Shapes are visualized using the following diagram:\n+\n+.. text-figure::\n+    :caption: **Figure 1.5**: Smithy shapes\n+    :name: figure-1.5\n+\n+                                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                             members \u2571\u2502 \u00ababstract\u00bb  \u2502\n+                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502    Shape    \u2502\n+                            \u2502        \u2572\u2502             \u2502\n+                            \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                            \u2502                \u25b3\n+                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                  \u2502         \u2502                \u2502                    \u2502\n+          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+          \u2502  \u00ababstract\u00bb   \u2502 \u2502container\u2502 \u00ababstract\u00bb  \u2502      \u2502 \u00ababstract\u00bb  \u2502\n+          \u2502    Simple     \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502  Aggregate  \u2502      \u2502   Service   \u2502\n+          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                  \u25b3                    \u25b3                    \u25b3\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502blob      \u2502\u2500\u2500\u253c\u2500\u2500\u2502boolean   \u2502      \u251c\u2500\u2500\u2500\u2500\u2502    List    \u2502  \u2502    \u2502         Service         \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u2502member      \u2502  \u2502    \u2502version                  \u2502\n+    \u2502document  \u2502\u2500\u2500\u253c\u2500\u2500\u2502string    \u2502      \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u251c\u2500\u2500\u2500\u2500\u2502operations: [Operation]? \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502resources: [Resource]?   \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502                    \u251c\u2500\u2500\u2500\u2500\u2502    Set     \u2502  \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2502timestamp \u2502\u2500\u2500\u2524                    \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502                    \u2502    \u2502member      \u2502  \u2502    \u2502        Operation        \u2502\n+                  \u2502                    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502input: Structure?        \u2502\n+          \u2502  \u00ababstract\u00bb   \u2502            \u251c\u2500\u2500\u2500\u2500\u2502    Map     \u2502  \u251c\u2500\u2500\u2500\u2500\u2502output: Structure?       \u2502\n+          \u2502    Number     \u2502            \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    \u2502errors: [Structure]?     \u2502\n+          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502    \u2502key         \u2502  \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                  \u25b3                    \u2502    \u2502value       \u2502  \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502        Resource         \u2502\n+    \u2502byte      \u2502\u2500\u2500\u253c\u2500\u2500\u2502short     \u2502      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u251c\u2500\u2500\u2500\u2500\u2502 Structure  \u2502  \u2502    \u2502identifiers?             \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502create: Operation?       \u2502\n+    \u2502integer   \u2502\u2500\u2500\u253c\u2500\u2500\u2502long      \u2502      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502put: Operation?          \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2502   Union    \u2502  \u2502    \u2502read: Operation?         \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2502update: Operation?       \u2502\n+    \u2502float     \u2502\u2500\u2500\u253c\u2500\u2500\u2502double    \u2502                                \u2502delete: Operation?       \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2502list: : Operation?       \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                \u2502operations: [Operation]? \u2502\n+    \u2502bigInteger\u2502\u2500\u2500\u2534\u2500\u2500\u2502bigDecimal\u2502                                \u2502collectionOperations:    \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2502    [Operation]?         \u2502\n+                                                                 \u2502resources: [Resource]?   \u2502\n+                                                                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+\n+.. _shape-id:\n+\n+Shape ID\n+========\n+\n+All shapes have an assigned shape ID. A :dfn:`shape ID` is used to refer to\n+shapes in the model. Shape IDs adhere to the following syntax:\n+\n+.. code-block:: none\n+\n+    com.foo.baz#ShapeName$memberName\n+    \\_________/ \\_______/ \\________/\n+         |          |          |\n+     Namespace  Shape name  Member name\n+\n+Namespace\n+    A namespace is mechanism for logically grouping shapes in a way\n+    that makes them reusable alongside other models without naming\n+    conflicts. A semantic model MAY contain shapes defined across multiple\n+    namespaces. The IDL representation supports zero or one namespace per\n+    model file, while the JSON AST representation supports zero or more\n+    namespaces per model file.\n+Absolute shape ID\n+    An :dfn:`absolute shape ID` starts with a :token:`namespace` name,\n+    followed by \"``#``\", followed by a *relative shape ID*. All shape\n+    IDs in the semantic model MUST be absolute.\n+    For example, ``smithy.example#Foo`` and ``smithy.example#Foo$bar``\n+    are absolute shape IDs.\n+Relative shape ID\n+    A :dfn:`relative shape ID` contains a :token:`shape name <identifier>`\n+    and an optional :token:`member name <identifier>`. The shape name and\n+    member name are separated by the \"``$``\" symbol if a member name is\n+    present. For example, ``Foo`` and ``Foo$bar`` are relative shape IDs.\n+Root shape ID\n+    A :dfn:`root shape ID` is a shape ID that does not contain a member.\n+    For example, ``smithy.example#Foo`` and ``Foo`` are root shape IDs.\n+\n+.. rubric:: Shape ID ABNF\n+\n+Shape IDs are formally defined by the following ABNF:\n+\n+.. productionlist:: smithy\n+    shape_id               :`root_shape_id` [`shape_id_member`]\n+    root_shape_id          :`absolute_root_shape_id` / `identifier`\n+    absolute_root_shape_id :`namespace` \"#\" `identifier`\n+    namespace              :`identifier` *(\".\" `identifier`)\n+    identifier             :(ALPHA / \"_\") *(ALPHA / DIGIT / \"_\")\n+    shape_id_member        :\"$\" `identifier`\n+\n+.. rubric:: Best practices for defining shape names\n+\n+Consumers of a Smithy model MAY choose to inflect shape names, structure\n+member names, and other facets of a Smithy model in order to expose a more\n+idiomatic experience to particular programming languages. In order to make this\n+easier for consumers of a model, model authors SHOULD utilize a strict form of\n+PascalCase in which only the first letter of acronyms, abbreviations, and\n+initialisms are capitalized.\n+\n+===========   ===============\n+Recommended   Not recommended\n+===========   ===============\n+UserId        UserID\n+ResourceArn   ResourceARN\n+IoChannel     IOChannel\n+HtmlEntity    HTMLEntity\n+HtmlEntity    HTML_Entity\n+===========   ===============\n+\n+\n+.. _shape-id-conflicts:\n+\n+Shape ID conflicts\n+==================\n+\n+While shape ID references within the semantic model are case-sensitive, no\n+two shapes in the semantic model can have the same case-insensitive shape ID.\n+This restriction makes it easier to use Smithy models for code generation in\n+programming languages that do not support case-sensitive identifiers or that\n+perform some kind of normalization on generated identifiers (for example,\n+a Python code generator might convert all member names to lower snake case).\n+To illustrate, ``com.Foo#baz`` and ``com.foo#BAZ`` are not allowed in the\n+same semantic model. This restriction also extends to member names:\n+``com.foo#Baz$bar`` and ``com.foo#Baz$BAR`` are in conflict.\n+\n+\n+.. _simple-types:\n+\n+-------------\n+Simple shapes\n+-------------\n+\n+*Simple types* are types that do not contain nested types or shape references.\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 90\n+\n+    * - Type\n+      - Description\n+    * - blob\n+      - Uninterpreted binary data\n+    * - boolean\n+      - Boolean value type\n+    * - string\n+      - UTF-8 encoded string\n+    * - byte\n+      - 8-bit signed integer ranging from -128 to 127 (inclusive)\n+    * - short\n+      - 16-bit signed integer ranging from -32,768 to 32,767 (inclusive)\n+    * - integer\n+      - 32-bit signed integer ranging from -2^31 to (2^31)-1 (inclusive)\n+    * - long\n+      - 64-bit signed integer ranging from -2^63 to (2^63)-1 (inclusive)\n+    * - float\n+      - Single precision IEEE-754 floating point number\n+    * - double\n+      - Double precision IEEE-754 floating point number\n+    * - bigInteger\n+      - Arbitrarily large signed integer\n+    * - bigDecimal\n+      - Arbitrary precision signed decimal number\n+    * - timestamp\n+      - Represents an instant in time with no UTC offset or timezone. The\n+        serialization of a timestamp is an implementation detail that is\n+        determined by a :ref:`protocol <protocolDefinition-trait>` and\n+        MUST NOT have any effect on the types exposed by tooling to\n+        represent a timestamp value.\n+    * - document\n+      - Represents a protocol-agnostic untyped value used to represent open\n+        content, or data with no fixed schema, data that can't be modeled\n+        using rigid types, or data that has a schema that evolves outside\n+        of the purview of a service. The serialization format of a document\n+        is an implementation detail of a protocol and MUST NOT have any\n+        effect on the types exposed by tooling to represent a document value.\n+\n+Simple shapes are defined in the IDL using a :ref:`simple_shape_statement <idl-simple>`.\n+\n+.. note::\n+\n+    The :ref:`prelude model <prelude>` contains pre-defined shapes for every\n+    simple type.\n+\n+.. rubric:: Simple shape examples\n+\n+The following example defines a shape for each simple type in the\n+``smithy.example`` namespace.\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        blob Blob\n+        boolean Boolean\n+        string String\n+        byte Byte\n+        short Short\n+        integer Integer\n+        long Long\n+        float Float\n+        double Double\n+        bigInteger BigInteger\n+        bigDecimal BigDecimal\n+        timestamp Timestamp\n+        document Document\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#Blob\": {\n+                    \"type\": \"blob\"\n+                },\n+                \"smithy.example#Boolean\": {\n+                    \"type\": \"boolean\"\n+                },\n+                \"smithy.example#String\": {\n+                    \"type\": \"string\"\n+                },\n+                \"smithy.example#Byte\": {\n+                    \"type\": \"byte\"\n+                },\n+                \"smithy.example#Short\": {\n+                    \"type\": \"short\"\n+                },\n+                \"smithy.example#Integer\": {\n+                    \"type\": \"integer\"\n+                },\n+                \"smithy.example#Long\": {\n+                    \"type\": \"long\"\n+                },\n+                \"smithy.example#Float\": {\n+                    \"type\": \"float\"\n+                },\n+                \"smithy.example#Double\": {\n+                    \"type\": \"double\"\n+                },\n+                \"smithy.example#BigInteger\": {\n+                    \"type\": \"bigInteger\"\n+                },\n+                \"smithy.example#BigDecimal\": {\n+                    \"type\": \"bigDecimal\"\n+                },\n+                \"smithy.example#Timestamp\": {\n+                    \"type\": \"timestamp\"\n+                },\n+                \"smithy.example#Document\": {\n+                    \"type\": \"document\"\n+                }\n+            }\n+        }\n+\n+.. note::\n+\n+    When defining shapes in the IDL, a namespace MUST first be declared.\n+\n+\n+.. _aggregate-types:\n+\n+----------------\n+Aggregate shapes\n+----------------\n+\n+Aggregate types define shapes that are composed of other shapes. Aggregate shapes\n+reference other shapes using :ref:`members <member>`.\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 90\n+\n+    * - Type\n+      - Description\n+    * - :ref:`member`\n+      - Defined in aggregate shapes to reference other shapes\n+    * - :ref:`list`\n+      - Ordered collection of homogeneous values\n+    * - :ref:`set`\n+      - Unordered collection of unique homogeneous values\n+    * - :ref:`map`\n+      - Map data structure that maps string keys to homogeneous values\n+    * - :ref:`structure`\n+      - Fixed set of named heterogeneous members\n+    * - :ref:`union`\n+      - Tagged union data structure that can take on one of several\n+        different, but fixed, types\n+\n+\n+.. _member:\n+\n+Member\n+======\n+\n+:dfn:`Members` are defined in aggregate shapes to reference other shapes using\n+a :ref:`shape ID <shape-id>`. The shape referenced by a member is called its\n+\"target\". A member MUST NOT target a :ref:`trait <trait-shapes>`, ``operation``,\n+``resource``, ``service``, or ``member``.\n+\n+\n+.. _list:\n+\n+List\n+====\n+\n+The :dfn:`list` type represents an ordered homogeneous collection of values.\n+A list shape requires a single member named ``member``. Lists are defined\n+in the IDL using a :ref:`list_statement <idl-list>`.\n+\n+The following example defines a list with a string member from the\n+:ref:`prelude <prelude>`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        list MyList {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {\n+                    \"type\": \"list\",\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+.. rubric:: List member shape ID\n+\n+The shape ID of the member of a list is the list shape ID followed by\n+``$member``. For example, the shape ID of the list member in the above\n+example is ``smithy.example#MyList$member``.\n+\n+\n+.. _set:\n+\n+Set\n+===\n+\n+The :dfn:`set` type represents an unordered collection of unique homogeneous\n+values. A set shape requires a single member named ``member``.\n+Sets are defined in the IDL using a :ref:`set_statement <idl-set>`.\n+\n+The following example defines a set of strings:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        set StringSet {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#StringSet\": {\n+                    \"type\": \"set\",\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+.. rubric:: Set member shape ID\n+\n+The shape ID of the member of a set is the set shape ID followed by\n+``$member``. For example, the shape ID of the set member in the above\n+example is ``smithy.example#StringSet$member``.\n+\n+.. rubric:: Language support for sets\n+\n+Not all programming languages support set data structures. Such languages\n+SHOULD represent sets as a custom set data structure that can interpret value\n+hash codes and equality, or alternatively, store the values of a set data\n+structure in a list and rely on validation to ensure uniqueness.\n+\n+\n+.. _map:\n+\n+Map\n+===\n+\n+The :dfn:`map` type represents a map data structure that maps a\n+``string`` key to a homogeneous value. A map requires a member named ``key``\n+that MUST target a ``string`` shape and a member named ``value``.\n+Maps are defined in the IDL using a :ref:`map_statement <idl-map>`.\n+\n+The following example defines a map of strings to integers:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        map IntegerMap {\n+            key: String,\n+            value: Integer\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#IntegerMap\": {\n+                    \"type\": \"map\",\n+                    \"key\": {\n+                        \"target\": \"smithy.api#String\"\n+                    },\n+                    \"value\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+.. rubric:: Map member shape IDs\n+\n+The shape ID of the ``key`` member of a map is the map shape ID followed by\n+``$key``, and the shape ID of the ``value`` member is the map shape ID\n+followed by ``$value``. For example, the shape ID of the ``key`` member in\n+the above map is ``smithy.example#IntegerMap$key``, and the ``value``\n+member is ``smithy.example#IntegerMap$value``.\n+\n+\n+.. _structure:\n+\n+Structure\n+=========\n+\n+The :dfn:`structure` type represents a fixed set of named, unordered,\n+heterogeneous values. A structure shape contains a set of named members, and\n+each member name maps to exactly one :ref:`member <member>` definition.\n+Structures are defined in the IDL using a\n+:ref:`structure_statement <idl-structure>`.\n+\n+The following example defines a structure with two members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        structure MyStructure {\n+            foo: String,\n+\n+            @required", "originalCommit": "ab2e617e464b006292aef001fb460b490077de09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMwMDAwOA==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455300008", "bodyText": "Since it's going to be very common, I wanted this example to have a trait. I'll add a link to traits.", "author": "mtdowling", "createdAt": "2020-07-15T19:46:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIxNDI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNDgyMg==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455224822", "bodyText": "Shape IDs elsewhere use \"identify\" or \"reference\", should \"targets\" be swapped out for one of those since that's used for members?\n\nA :ref:shape ID <shape-id> is used to identify shapes defined in a model.\n\nThis would need to be updated for all the service types.", "author": "kstich", "createdAt": "2020-07-15T17:37:21Z", "path": "docs/source/1.0/spec/core/model.rst", "diffHunk": "@@ -0,0 +1,2705 @@\n+.. _smithy-model:\n+\n+============\n+Smithy model\n+============\n+\n+This is the specification of Smithy, an interface definition language and set\n+of tools used to build clients, servers, and other kinds of artifacts through\n+model transformations. This specification is at version |release|.\n+\n+.. contents:: Table of contents\n+    :depth: 1\n+    :local:\n+    :backlinks: none\n+\n+\n+---------------------------------\n+Conventions used in this document\n+---------------------------------\n+\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n+\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n+document are to be interpreted as described in :rfc:`2119`.\n+\n+This specification makes use of the Augmented Backus-Naur Form (ABNF)\n+:rfc:`5234` notation, including the *core rules* defined in Appendix B\n+of that document.\n+\n+Readers are invited to report technical errors and ambiguities in this\n+specification to the Smithy GitHub repository at https://github.com/awslabs/smithy.\n+This specification is open source, so contributions are welcome.\n+\n+.. rubric:: Examples\n+\n+Unless declared otherwise, example Smithy models given in this specification\n+are written using the :ref:`Smithy interface definition language (IDL) <idl>`\n+syntax. Complementary :ref:`JSON AST <json-ast>` examples are provided\n+alongside Smithy IDL examples where appropriate. For example:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1.0\"\n+\n+        metadata foo = \"bar\"\n+\n+        namespace smithy.example\n+\n+        use smithy.other.namespace#MyString\n+\n+        structure MyStructure {\n+            @required\n+            foo: MyString\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"bar\"\n+            },\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.other.namespace#MyString\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _smithy-framework:\n+\n+----------------\n+Smithy framework\n+----------------\n+\n+Smithy is a framework that consists of a semantic model, file formats used to\n+define a model, and a build process used to validate models and facilitate\n+model transformations.\n+\n+.. text-figure::\n+    :caption: **Figure 1.1**: Smithy framework concepts\n+    :name: figure-1.1\n+\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 part of          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    \u2502                \u2502\u2572                \u2571\u2502                \u2502\n+                    \u2502 Semantic Model \u2502\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502   Model File   \u2502\n+                    \u2502                \u2502\u2571                \u2572\u2502                \u2502\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                               split into       \u2572\u2502\u2571\n+                                                                 \u25cb\n+                                                                 \u2502\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                           \u253c\n+                    \u2502JSON AST (.json)\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502         \u2502                \u2502\n+                                              \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b7\u2502 Representation \u2502\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502         \u2502                \u2502\n+                    \u2502 IDL (.smithy)  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+Semantic model\n+    The in-memory model used by tools. The :ref:`semantic model <semantic-model>`\n+    may be serialized into one or more model file representations.\n+Model File\n+    A file on the file system, in a particular representation. The model files\n+    that make up a semantic model MAY be split across multiple files to\n+    improve readability or modularity, and those files are not required to\n+    use the same representation.\n+Representation\n+    A particular model file format such as the Smithy IDL or JSON AST.\n+    Representations are loaded into the semantic model by mapping the\n+    representation to concepts in the semantic model.\n+\n+    * The :ref:`Smithy IDL <idl>` is a human-readable format that aims to\n+      streamline authoring and reading models.\n+    * The :ref:`JSON AST <json-ast>` aims to provide a more machine-readable\n+      format to easily share models across language implementations and better\n+      integrate with JSON-based ecosystems.\n+\n+\n+Model transformations\n+=====================\n+\n+The build process mentioned above performs a number of model transformations.\n+A :dfn:`model transformation` is the process of converting input model files\n+into output artifacts. Generated artifacts can be other Smithy models\n+(an endogenous transformation), other model formats (an exogenous\n+transformation), code, documentation, etc.\n+\n+.. text-figure::\n+    :caption: **Figure 1.2**: Smithy model transformations\n+    :name: figure-1.2\n+\n+           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+           \u2502               \u2502\u2572           \u2502               \u2502           \u2571\u2502               \u2502\n+           \u2502Semantic Model \u2502\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502Transformation \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502   Artifact    \u2502\n+           \u2502               \u2502\u2571           \u2502               \u2502           \u2572\u2502               \u2502\n+           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                                \u25b3\n+                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                   \u2502                            \u2502                            \u2502\n+           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+           \u2502Model to Model \u2502            \u2502   Model to    \u2502            \u2502  Artifact to  \u2502\n+           \u2502Transformation \u2502            \u2502   Artifact    \u2502            \u2502     Model     \u2502\n+           \u2502               \u2502            \u2502Transformation \u2502            \u2502Transformation \u2502\n+           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+\n+.. _semantic-model:\n+\n+------------------\n+The semantic model\n+------------------\n+\n+Smithy's *semantic model* is an in-memory model used by tools. It is\n+independent of any particular serialized representation. The semantic\n+model contains metadata and a graph of :ref:`shapes <shapes>`\n+connected by :ref:`shape IDs <shape-id>`.\n+\n+.. text-figure::\n+    :caption: **Figure 1.3**: The semantic model\n+    :name: figure-1.3\n+\n+                                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                                          \u2502Semantic Model \u2502\u2572\n+                                          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                                          \u2502metadata?      \u2502\u2571         \u2502\n+                                          \u2502               \u2502          \u2502\n+                                          \u2502               \u2502          \u2502\n+                                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n+                                                  \u253c     \u253c prelude    \u2502\n+                                                  \u2502     \u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                                  \u25cb\n+                                           shapes\u2571\u2502\u2572\n+        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+        \u2502 Applied Trait \u2502\u2572          shape \u2502  \u00ababstract\u00bb   \u2502\n+        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502     Shape     \u2502            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+        \u2502               \u2502\u2571                \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524            \u2502    ShapeID    \u2502\n+        \u2502               \u2502                 \u2502               \u2502            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+        \u2502               \u2502\u2572     applied-to \u2502               \u2502         id \u2502namespace      \u2502\n+        \u2502               \u2502\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502               \u2502\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502shape_name     \u2502\n+        \u2502               \u2502\u2571traits          \u2502               \u2502            \u2502member_name?   \u2502\n+        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+Shape\n+    Shapes are named data definitions that describe the structure of an API.\n+    Shapes are referenced and connected by :ref:`shape IDs <shape-id>`.\n+    Relationships between shapes are formed by :ref:`members <member>` that\n+    target other shapes, properties of shapes like the ``input`` and\n+    ``output`` properties of an :ref:`operation <operation>`, and\n+    :ref:`applied traits <applying-traits>` that attach a trait to a shape.\n+Shape ID\n+    A :ref:`shape ID <shape-id>` is used to identify shapes defined in a\n+    model. For example, ``smithy.example#MyShape``,\n+    ``smithy.example#Foo$bar``, and ``Baz`` are all different kinds of shape\n+    IDs.\n+Trait\n+    :ref:`Traits <traits>` are specialized shapes that form the basis of\n+    Smithy's meta-model. Traits are applied to shapes to associate metadata\n+    to a shape. They are typically used by tools to influence validation,\n+    serialization, and code generation.\n+Applied trait\n+    An applied trait is an instance of a trait applied to a shape, configured\n+    using a :ref:`node value <node-value>`.\n+Model metadata\n+    Metadata is a schema-less extensibility mechanism used to associate\n+    metadata to an entire model. For example, metadata is used to define\n+    :ref:`validators <validator-definition>` and model-wide\n+    :ref:`suppressions <suppression-definition>`. Metadata is defined\n+    using an ``object`` :ref:`node value <node-value>`.\n+Prelude\n+    The :ref:`prelude <prelude>` defines various simple shapes and every\n+    trait defined in the core specification. All Smithy models automatically\n+    include the prelude.\n+\n+\n+.. _model-files:\n+\n+-----------\n+Model files\n+-----------\n+\n+Smithy models MAY be divided into multiple files so that they are easier to\n+maintain and evolve. One or more model files can be assembled (or merged)\n+together to form a semantic model. The model files that form a semantic model\n+are not required to all be defined in the same representation; some models can\n+be defined using the IDL and others can be defined using the JSON AST.\n+\n+Model files do not explicitly include other model files; this responsibility\n+is left to tooling to ensure that all necessary model files are merged\n+together to form a valid semantic model.\n+\n+.. _merging-models:\n+\n+Merging model files\n+===================\n+\n+Implementations MUST take the following steps to merge models together to load\n+the semantic model:\n+\n+#. Duplicate shape IDs, if found, MUST cause the model merge to fail.\n+   See :ref:`shape-id-conflicts` for more information.\n+#. Merge any conflicting applied traits using\n+   :ref:`trait conflict resolution  <trait-conflict-resolution>`.\n+#. Merge the metadata objects of both models using the steps defined\n+   in :ref:`merging-metadata`.\n+\n+\n+.. _merging-metadata:\n+\n+Merging metadata\n+----------------\n+\n+When a conflict occurs between top-level metadata key-value pairs,\n+metadata is merged using the following logic:\n+\n+1. If a metadata key is only present in one model, then the entry is valid\n+   and added to the merged model.\n+2. If both models contain the same key and both values are arrays, then\n+   the entry is valid; the values of both arrays are concatenated into a\n+   single array and added to the merged model.\n+3. If both models contain the same key and both values are exactly equal,\n+   then the conflict is ignored and the value is added to the merged model.\n+4. If both models contain the same key and the values do not both map to\n+   arrays, then the key is invalid and there is a metadata conflict error.\n+\n+Given the following two Smithy models:\n+\n+.. code-block:: smithy\n+    :caption: model-a.smithy\n+\n+    metadata \"foo\" = [\"baz\", \"bar\"]\n+    metadata \"qux\" = \"test\"\n+    metadata \"validConflict\" = \"hi!\"\n+\n+.. code-block:: smithy\n+    :caption: model-b.smithy\n+\n+    metadata \"foo\" = [\"lorem\", \"ipsum\"]\n+    metadata \"lorem\" = \"ipsum\"\n+    metadata \"validConflict\" = \"hi!\"\n+\n+Merging ``model-a.smithy`` and ``model-b.smithy`` produces the following\n+model:\n+\n+.. code-block:: smithy\n+\n+    metadata \"foo\" = [\"baz\", \"bar\", \"lorem\", \"ipsum\"]\n+    metadata \"qux\" = \"test\"\n+    metadata \"lorem\" = \"ipsum\"\n+    metadata \"validConflict\" = \"hi!\"\n+\n+\n+.. _node-value:\n+\n+-----------\n+Node values\n+-----------\n+\n+Node values are JSON-like values used in the following places in the\n+semantic model:\n+\n+* **metadata**: Metadata is defined as a node value object.\n+* **applied trait**: The value of a trait applied to a shape is defined\n+  using a node value.\n+\n+.. text-figure::\n+    :caption: **Figure 1.4**: Node value types\n+    :name: figure-1.4\n+\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 Semantic Model  \u2502                     \u2502Applied Trait\u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+      \u2502                                            \u2502\n+      \u2502                                            \u2502\n+      \u2502                                            \u253c nodeValue\n+      \u2502                                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+      \u2502                                     \u2502 \u00ababstract\u00bb  \u2502\n+      \u2502                                     \u2502    Value    \u2502\n+      \u2502metadata                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+      \u2502                                            \u25b3\n+      \u25cb      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+      \u253c      \u2502                   \u2502                 \u2502               \u2502               \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502     Object      \u2502 \u2502      Array      \u2502 \u2502   Number    \u2502 \u2502   Boolean   \u2502 \u2502   String    \u2502\n+    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2502members:         \u2502 \u2502members: [Value] \u2502\n+    \u2502  [String, Value]\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+The following example defines metadata using a node value:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        metadata foo = \"hello\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"hello\"\n+            }\n+        }\n+\n+The following example defines a trait using a node value:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @length(min: 1, max: 10)\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#length\": {\n+                            \"min\": 1,\n+                            \"max\": 10\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+Node value types\n+================\n+\n+Node values have the same data model as JSON; they consist of the following\n+kinds of values:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 30 70\n+\n+    * - Type\n+      - Description\n+    * - null\n+      - The lack of a value\n+    * - string\n+      - A UTF-8 string\n+    * - number\n+      - A double precision floating point number\n+    * - boolean\n+      - A Boolean, true or false value\n+    * - array\n+      - A list of heterogeneous node values\n+    * - object\n+      - A map of string keys to heterogeneous node values\n+\n+.. rubric:: Shape IDs, text blocks, et al.\n+\n+There is no specific node value type for shape IDs, text blocks, or\n+other higher-level features of the IDL; these values are stored and\n+treated in the semantic model as simply opaque strings, and their\n+validation happens before the creation of the model.\n+\n+\n+.. _shapes:\n+\n+------\n+Shapes\n+------\n+\n+Smithy models are made up of shapes. Shapes come in three kinds: simple,\n+aggregate, and service. A simple shape defines atomic or primitive values\n+such as ``integer`` and ``string``. Aggregate shapes have members such as\n+a list of strings or an ``Address`` structure. Service shapes have specific\n+semantics, unlike the very generic simple and aggregate shapes, as they\n+represent either a service, a resource managed by a service, or operations\n+on services and resources.\n+\n+Shapes are visualized using the following diagram:\n+\n+.. text-figure::\n+    :caption: **Figure 1.5**: Smithy shapes\n+    :name: figure-1.5\n+\n+                                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                             members \u2571\u2502 \u00ababstract\u00bb  \u2502\n+                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502    Shape    \u2502\n+                            \u2502        \u2572\u2502             \u2502\n+                            \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                            \u2502                \u25b3\n+                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                  \u2502         \u2502                \u2502                    \u2502\n+          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+          \u2502  \u00ababstract\u00bb   \u2502 \u2502container\u2502 \u00ababstract\u00bb  \u2502      \u2502 \u00ababstract\u00bb  \u2502\n+          \u2502    Simple     \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502  Aggregate  \u2502      \u2502   Service   \u2502\n+          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                  \u25b3                    \u25b3                    \u25b3\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502blob      \u2502\u2500\u2500\u253c\u2500\u2500\u2502boolean   \u2502      \u251c\u2500\u2500\u2500\u2500\u2502    List    \u2502  \u2502    \u2502         Service         \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u2502member      \u2502  \u2502    \u2502version                  \u2502\n+    \u2502document  \u2502\u2500\u2500\u253c\u2500\u2500\u2502string    \u2502      \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u251c\u2500\u2500\u2500\u2500\u2502operations: [Operation]? \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502resources: [Resource]?   \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502                    \u251c\u2500\u2500\u2500\u2500\u2502    Set     \u2502  \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2502timestamp \u2502\u2500\u2500\u2524                    \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502                    \u2502    \u2502member      \u2502  \u2502    \u2502        Operation        \u2502\n+                  \u2502                    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502input: Structure?        \u2502\n+          \u2502  \u00ababstract\u00bb   \u2502            \u251c\u2500\u2500\u2500\u2500\u2502    Map     \u2502  \u251c\u2500\u2500\u2500\u2500\u2502output: Structure?       \u2502\n+          \u2502    Number     \u2502            \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    \u2502errors: [Structure]?     \u2502\n+          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502    \u2502key         \u2502  \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                  \u25b3                    \u2502    \u2502value       \u2502  \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502        Resource         \u2502\n+    \u2502byte      \u2502\u2500\u2500\u253c\u2500\u2500\u2502short     \u2502      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u251c\u2500\u2500\u2500\u2500\u2502 Structure  \u2502  \u2502    \u2502identifiers?             \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502create: Operation?       \u2502\n+    \u2502integer   \u2502\u2500\u2500\u253c\u2500\u2500\u2502long      \u2502      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502put: Operation?          \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2502   Union    \u2502  \u2502    \u2502read: Operation?         \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2502update: Operation?       \u2502\n+    \u2502float     \u2502\u2500\u2500\u253c\u2500\u2500\u2502double    \u2502                                \u2502delete: Operation?       \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2502list: : Operation?       \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                \u2502operations: [Operation]? \u2502\n+    \u2502bigInteger\u2502\u2500\u2500\u2534\u2500\u2500\u2502bigDecimal\u2502                                \u2502collectionOperations:    \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2502    [Operation]?         \u2502\n+                                                                 \u2502resources: [Resource]?   \u2502\n+                                                                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+\n+.. _shape-id:\n+\n+Shape ID\n+========\n+\n+All shapes have an assigned shape ID. A :dfn:`shape ID` is used to refer to\n+shapes in the model. Shape IDs adhere to the following syntax:\n+\n+.. code-block:: none\n+\n+    com.foo.baz#ShapeName$memberName\n+    \\_________/ \\_______/ \\________/\n+         |          |          |\n+     Namespace  Shape name  Member name\n+\n+Namespace\n+    A namespace is mechanism for logically grouping shapes in a way\n+    that makes them reusable alongside other models without naming\n+    conflicts. A semantic model MAY contain shapes defined across multiple\n+    namespaces. The IDL representation supports zero or one namespace per\n+    model file, while the JSON AST representation supports zero or more\n+    namespaces per model file.\n+Absolute shape ID\n+    An :dfn:`absolute shape ID` starts with a :token:`namespace` name,\n+    followed by \"``#``\", followed by a *relative shape ID*. All shape\n+    IDs in the semantic model MUST be absolute.\n+    For example, ``smithy.example#Foo`` and ``smithy.example#Foo$bar``\n+    are absolute shape IDs.\n+Relative shape ID\n+    A :dfn:`relative shape ID` contains a :token:`shape name <identifier>`\n+    and an optional :token:`member name <identifier>`. The shape name and\n+    member name are separated by the \"``$``\" symbol if a member name is\n+    present. For example, ``Foo`` and ``Foo$bar`` are relative shape IDs.\n+Root shape ID\n+    A :dfn:`root shape ID` is a shape ID that does not contain a member.\n+    For example, ``smithy.example#Foo`` and ``Foo`` are root shape IDs.\n+\n+.. rubric:: Shape ID ABNF\n+\n+Shape IDs are formally defined by the following ABNF:\n+\n+.. productionlist:: smithy\n+    shape_id               :`root_shape_id` [`shape_id_member`]\n+    root_shape_id          :`absolute_root_shape_id` / `identifier`\n+    absolute_root_shape_id :`namespace` \"#\" `identifier`\n+    namespace              :`identifier` *(\".\" `identifier`)\n+    identifier             :(ALPHA / \"_\") *(ALPHA / DIGIT / \"_\")\n+    shape_id_member        :\"$\" `identifier`\n+\n+.. rubric:: Best practices for defining shape names\n+\n+Consumers of a Smithy model MAY choose to inflect shape names, structure\n+member names, and other facets of a Smithy model in order to expose a more\n+idiomatic experience to particular programming languages. In order to make this\n+easier for consumers of a model, model authors SHOULD utilize a strict form of\n+PascalCase in which only the first letter of acronyms, abbreviations, and\n+initialisms are capitalized.\n+\n+===========   ===============\n+Recommended   Not recommended\n+===========   ===============\n+UserId        UserID\n+ResourceArn   ResourceARN\n+IoChannel     IOChannel\n+HtmlEntity    HTMLEntity\n+HtmlEntity    HTML_Entity\n+===========   ===============\n+\n+\n+.. _shape-id-conflicts:\n+\n+Shape ID conflicts\n+==================\n+\n+While shape ID references within the semantic model are case-sensitive, no\n+two shapes in the semantic model can have the same case-insensitive shape ID.\n+This restriction makes it easier to use Smithy models for code generation in\n+programming languages that do not support case-sensitive identifiers or that\n+perform some kind of normalization on generated identifiers (for example,\n+a Python code generator might convert all member names to lower snake case).\n+To illustrate, ``com.Foo#baz`` and ``com.foo#BAZ`` are not allowed in the\n+same semantic model. This restriction also extends to member names:\n+``com.foo#Baz$bar`` and ``com.foo#Baz$BAR`` are in conflict.\n+\n+\n+.. _simple-types:\n+\n+-------------\n+Simple shapes\n+-------------\n+\n+*Simple types* are types that do not contain nested types or shape references.\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 90\n+\n+    * - Type\n+      - Description\n+    * - blob\n+      - Uninterpreted binary data\n+    * - boolean\n+      - Boolean value type\n+    * - string\n+      - UTF-8 encoded string\n+    * - byte\n+      - 8-bit signed integer ranging from -128 to 127 (inclusive)\n+    * - short\n+      - 16-bit signed integer ranging from -32,768 to 32,767 (inclusive)\n+    * - integer\n+      - 32-bit signed integer ranging from -2^31 to (2^31)-1 (inclusive)\n+    * - long\n+      - 64-bit signed integer ranging from -2^63 to (2^63)-1 (inclusive)\n+    * - float\n+      - Single precision IEEE-754 floating point number\n+    * - double\n+      - Double precision IEEE-754 floating point number\n+    * - bigInteger\n+      - Arbitrarily large signed integer\n+    * - bigDecimal\n+      - Arbitrary precision signed decimal number\n+    * - timestamp\n+      - Represents an instant in time with no UTC offset or timezone. The\n+        serialization of a timestamp is an implementation detail that is\n+        determined by a :ref:`protocol <protocolDefinition-trait>` and\n+        MUST NOT have any effect on the types exposed by tooling to\n+        represent a timestamp value.\n+    * - document\n+      - Represents a protocol-agnostic untyped value used to represent open\n+        content, or data with no fixed schema, data that can't be modeled\n+        using rigid types, or data that has a schema that evolves outside\n+        of the purview of a service. The serialization format of a document\n+        is an implementation detail of a protocol and MUST NOT have any\n+        effect on the types exposed by tooling to represent a document value.\n+\n+Simple shapes are defined in the IDL using a :ref:`simple_shape_statement <idl-simple>`.\n+\n+.. note::\n+\n+    The :ref:`prelude model <prelude>` contains pre-defined shapes for every\n+    simple type.\n+\n+.. rubric:: Simple shape examples\n+\n+The following example defines a shape for each simple type in the\n+``smithy.example`` namespace.\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        blob Blob\n+        boolean Boolean\n+        string String\n+        byte Byte\n+        short Short\n+        integer Integer\n+        long Long\n+        float Float\n+        double Double\n+        bigInteger BigInteger\n+        bigDecimal BigDecimal\n+        timestamp Timestamp\n+        document Document\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#Blob\": {\n+                    \"type\": \"blob\"\n+                },\n+                \"smithy.example#Boolean\": {\n+                    \"type\": \"boolean\"\n+                },\n+                \"smithy.example#String\": {\n+                    \"type\": \"string\"\n+                },\n+                \"smithy.example#Byte\": {\n+                    \"type\": \"byte\"\n+                },\n+                \"smithy.example#Short\": {\n+                    \"type\": \"short\"\n+                },\n+                \"smithy.example#Integer\": {\n+                    \"type\": \"integer\"\n+                },\n+                \"smithy.example#Long\": {\n+                    \"type\": \"long\"\n+                },\n+                \"smithy.example#Float\": {\n+                    \"type\": \"float\"\n+                },\n+                \"smithy.example#Double\": {\n+                    \"type\": \"double\"\n+                },\n+                \"smithy.example#BigInteger\": {\n+                    \"type\": \"bigInteger\"\n+                },\n+                \"smithy.example#BigDecimal\": {\n+                    \"type\": \"bigDecimal\"\n+                },\n+                \"smithy.example#Timestamp\": {\n+                    \"type\": \"timestamp\"\n+                },\n+                \"smithy.example#Document\": {\n+                    \"type\": \"document\"\n+                }\n+            }\n+        }\n+\n+.. note::\n+\n+    When defining shapes in the IDL, a namespace MUST first be declared.\n+\n+\n+.. _aggregate-types:\n+\n+----------------\n+Aggregate shapes\n+----------------\n+\n+Aggregate types define shapes that are composed of other shapes. Aggregate shapes\n+reference other shapes using :ref:`members <member>`.\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 90\n+\n+    * - Type\n+      - Description\n+    * - :ref:`member`\n+      - Defined in aggregate shapes to reference other shapes\n+    * - :ref:`list`\n+      - Ordered collection of homogeneous values\n+    * - :ref:`set`\n+      - Unordered collection of unique homogeneous values\n+    * - :ref:`map`\n+      - Map data structure that maps string keys to homogeneous values\n+    * - :ref:`structure`\n+      - Fixed set of named heterogeneous members\n+    * - :ref:`union`\n+      - Tagged union data structure that can take on one of several\n+        different, but fixed, types\n+\n+\n+.. _member:\n+\n+Member\n+======\n+\n+:dfn:`Members` are defined in aggregate shapes to reference other shapes using\n+a :ref:`shape ID <shape-id>`. The shape referenced by a member is called its\n+\"target\". A member MUST NOT target a :ref:`trait <trait-shapes>`, ``operation``,\n+``resource``, ``service``, or ``member``.\n+\n+\n+.. _list:\n+\n+List\n+====\n+\n+The :dfn:`list` type represents an ordered homogeneous collection of values.\n+A list shape requires a single member named ``member``. Lists are defined\n+in the IDL using a :ref:`list_statement <idl-list>`.\n+\n+The following example defines a list with a string member from the\n+:ref:`prelude <prelude>`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        list MyList {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {\n+                    \"type\": \"list\",\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+.. rubric:: List member shape ID\n+\n+The shape ID of the member of a list is the list shape ID followed by\n+``$member``. For example, the shape ID of the list member in the above\n+example is ``smithy.example#MyList$member``.\n+\n+\n+.. _set:\n+\n+Set\n+===\n+\n+The :dfn:`set` type represents an unordered collection of unique homogeneous\n+values. A set shape requires a single member named ``member``.\n+Sets are defined in the IDL using a :ref:`set_statement <idl-set>`.\n+\n+The following example defines a set of strings:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        set StringSet {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#StringSet\": {\n+                    \"type\": \"set\",\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+.. rubric:: Set member shape ID\n+\n+The shape ID of the member of a set is the set shape ID followed by\n+``$member``. For example, the shape ID of the set member in the above\n+example is ``smithy.example#StringSet$member``.\n+\n+.. rubric:: Language support for sets\n+\n+Not all programming languages support set data structures. Such languages\n+SHOULD represent sets as a custom set data structure that can interpret value\n+hash codes and equality, or alternatively, store the values of a set data\n+structure in a list and rely on validation to ensure uniqueness.\n+\n+\n+.. _map:\n+\n+Map\n+===\n+\n+The :dfn:`map` type represents a map data structure that maps a\n+``string`` key to a homogeneous value. A map requires a member named ``key``\n+that MUST target a ``string`` shape and a member named ``value``.\n+Maps are defined in the IDL using a :ref:`map_statement <idl-map>`.\n+\n+The following example defines a map of strings to integers:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        map IntegerMap {\n+            key: String,\n+            value: Integer\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#IntegerMap\": {\n+                    \"type\": \"map\",\n+                    \"key\": {\n+                        \"target\": \"smithy.api#String\"\n+                    },\n+                    \"value\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+.. rubric:: Map member shape IDs\n+\n+The shape ID of the ``key`` member of a map is the map shape ID followed by\n+``$key``, and the shape ID of the ``value`` member is the map shape ID\n+followed by ``$value``. For example, the shape ID of the ``key`` member in\n+the above map is ``smithy.example#IntegerMap$key``, and the ``value``\n+member is ``smithy.example#IntegerMap$value``.\n+\n+\n+.. _structure:\n+\n+Structure\n+=========\n+\n+The :dfn:`structure` type represents a fixed set of named, unordered,\n+heterogeneous values. A structure shape contains a set of named members, and\n+each member name maps to exactly one :ref:`member <member>` definition.\n+Structures are defined in the IDL using a\n+:ref:`structure_statement <idl-structure>`.\n+\n+The following example defines a structure with two members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        structure MyStructure {\n+            foo: String,\n+\n+            @required\n+            baz: Integer,\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.api#String\"\n+                        },\n+                        \"baz\": {\n+                            \"target\": \"smithy.api#Integer\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+.. rubric:: Adding new members\n+\n+New members added to existing structures SHOULD be added to the end of the\n+structure. This ensures that programming languages that require a specific\n+data structure layout or alignment for code generated from Smithy models are\n+able to maintain backward compatibility.\n+\n+.. rubric:: Structure member shape IDs\n+\n+The shape ID of a member of a structure is the structure shape ID, followed\n+by \"#\", followed by the member name, For example, the shape ID of the \"foo\"\n+member in the above example is ``smithy.example#MyStructure$foo``.\n+\n+\n+.. _union:\n+\n+Union\n+=====\n+\n+The union type represents a `tagged union data structure`_ that can take\n+on several different, but fixed, types. Unions function similarly to\n+structures except that only one member can be used at any one time. A union\n+shape MUST contain one or more named :ref:`members <member>`. Unions are\n+defined in the IDL using a :ref:`union_statement <idl-union>`.\n+\n+The following example defines a union shape with several members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        union MyUnion {\n+            i32: Integer,\n+\n+            stringA: String,\n+\n+            @sensitive\n+            stringB: String,\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyUnion\": {\n+                    \"type\": \"union\",\n+                    \"members\": {\n+                        \"i32\": {\n+                            \"target\": \"smithy.api#Integer\"\n+                        },\n+                        \"stringA\": {\n+                            \"target\": \"smithy.api#String\"\n+                        },\n+                        \"stringB\": {\n+                            \"target\": \"smithy.api#String\",\n+                            \"traits\": {\n+                                \"smithy.api#sensitive\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+.. rubric:: Adding new members\n+\n+New members added to existing unions SHOULD be added to the end of the\n+union. This ensures that programming languages that require a specific\n+data structure layout or alignment for code generated from Smithy models are\n+able to maintain backward compatibility.\n+\n+.. rubric:: Union member shape IDs\n+\n+The shape ID of a member of a union is the union shape ID, followed\n+by \"#\", followed by the member name. For example, the shape ID of the \"i32\"\n+member in the above example is ``smithy.example#MyUnion$i32``.\n+\n+\n+.. _default-values:\n+\n+Default values\n+==============\n+\n+The values provided for :ref:`members <member>` are either always present\n+and set to a default value when necessary or *boxed*, meaning a value is\n+optionally present with no default value. Members are considered boxed if\n+the member is marked with the :ref:`box-trait` or the shape targeted by the\n+member is marked with the box trait. Members that target strings, timestamps,\n+and aggregate shapes are always considered boxed and have no default values.\n+\n+- The default value of a ``byte``, ``short``, ``integer``, ``long``,\n+  ``float``, and ``double`` shape that is not boxed is zero.\n+- The default value of a ``boolean`` shape that is not boxed is ``false``.\n+- All other shapes are always considered boxed and have no default value.\n+\n+\n+Recursive shape definitions\n+===========================\n+\n+Smithy allows for recursive shape definitions with the following constraint:\n+the member of a list, set, or map cannot directly or transitively target its\n+containing shape unless one or more members in the path from the container\n+back to itself targets a structure or union shape. This ensures that shapes\n+that are typically impossible to define in various programming languages are\n+not defined in Smithy models (for example, you can't define a recursive list\n+in Java ``List<List<List....``).\n+\n+The following recursive shape definition is **valid**:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        list ValidList {\n+            member: IntermediateStructure\n+        }\n+\n+        structure IntermediateStructure {\n+            foo: ValidList\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#ValidList\": {\n+                    \"type\": \"list\",\n+                    \"member\": {\n+                        \"target\": \"smithy.example#IntermediateStructure\"\n+                    }\n+                },\n+                \"smithy.example#IntermediateStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.example#ValidList\"\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+The following recursive shape definition is **invalid**:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        list RecursiveList {\n+            member: RecursiveList\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#RecursiveList\": {\n+                    \"type\": \"list\",\n+                    \"member\": {\n+                        \"target\": \"smithy.example#RecursiveList\"\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _service-types:\n+\n+--------------\n+Service shapes\n+--------------\n+\n+*Service types* have specific semantics and define services, resources,\n+and operations.\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 90\n+\n+    * - Type\n+      - Description\n+    * - :ref:`service <service>`\n+      - Entry point of an API that aggregates resources and operations together\n+    * - :ref:`operation <operation>`\n+      - Represents the input, output, and errors of an API operation\n+    * - :ref:`resource <resource>`\n+      - Entity with an identity that has a set of operations\n+\n+..  _service:\n+\n+Service\n+=======\n+\n+A :dfn:`service` is the entry point of an API that aggregates resources and\n+operations together. The :ref:`resources <resource>` and\n+:ref:`operations <operation>` of an API are bound within the closure of a\n+service. A service is defined in the IDL using a\n+:ref:`service_statement <idl-service>`.\n+\n+The service shape supports the following properties:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 10 80\n+\n+    * - Property\n+      - Type\n+      - Description\n+    * - version\n+      - ``string``\n+      - **Required**. Defines the version of the service. The version can be\n+        provided in any format (e.g., ``2017-02-11``, ``2.0``, etc).\n+    * - :ref:`operations <service-operations>`\n+      - [``string``]\n+      - Binds a set of ``operation`` shapes to the service. Each\n+        element in the given list MUST be a valid :ref:`shape ID <shape-id>`\n+        that targets an :ref:`operation <operation>` shape.", "originalCommit": "ab2e617e464b006292aef001fb460b490077de09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxOTExNQ==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455319115", "bodyText": "I made a pass at moving more things to be \"target\". I think of the concept of targeting shapes using an ID as \"references\" but specific instances of a reference and the object of a reference the \"target\".", "author": "mtdowling", "createdAt": "2020-07-15T20:22:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNDgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzUwNA==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455227504", "bodyText": "A tiny part of me feels like this section should be ordered operations, resources, then services to build up to the fully aggregated service shape. Putting that down here for discussion, even if the ordering stays the same in the end.", "author": "kstich", "createdAt": "2020-07-15T17:41:10Z", "path": "docs/source/1.0/spec/core/model.rst", "diffHunk": "@@ -0,0 +1,2705 @@\n+.. _smithy-model:\n+\n+============\n+Smithy model\n+============\n+\n+This is the specification of Smithy, an interface definition language and set\n+of tools used to build clients, servers, and other kinds of artifacts through\n+model transformations. This specification is at version |release|.\n+\n+.. contents:: Table of contents\n+    :depth: 1\n+    :local:\n+    :backlinks: none\n+\n+\n+---------------------------------\n+Conventions used in this document\n+---------------------------------\n+\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n+\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n+document are to be interpreted as described in :rfc:`2119`.\n+\n+This specification makes use of the Augmented Backus-Naur Form (ABNF)\n+:rfc:`5234` notation, including the *core rules* defined in Appendix B\n+of that document.\n+\n+Readers are invited to report technical errors and ambiguities in this\n+specification to the Smithy GitHub repository at https://github.com/awslabs/smithy.\n+This specification is open source, so contributions are welcome.\n+\n+.. rubric:: Examples\n+\n+Unless declared otherwise, example Smithy models given in this specification\n+are written using the :ref:`Smithy interface definition language (IDL) <idl>`\n+syntax. Complementary :ref:`JSON AST <json-ast>` examples are provided\n+alongside Smithy IDL examples where appropriate. For example:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1.0\"\n+\n+        metadata foo = \"bar\"\n+\n+        namespace smithy.example\n+\n+        use smithy.other.namespace#MyString\n+\n+        structure MyStructure {\n+            @required\n+            foo: MyString\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"bar\"\n+            },\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.other.namespace#MyString\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _smithy-framework:\n+\n+----------------\n+Smithy framework\n+----------------\n+\n+Smithy is a framework that consists of a semantic model, file formats used to\n+define a model, and a build process used to validate models and facilitate\n+model transformations.\n+\n+.. text-figure::\n+    :caption: **Figure 1.1**: Smithy framework concepts\n+    :name: figure-1.1\n+\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 part of          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    \u2502                \u2502\u2572                \u2571\u2502                \u2502\n+                    \u2502 Semantic Model \u2502\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502   Model File   \u2502\n+                    \u2502                \u2502\u2571                \u2572\u2502                \u2502\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                               split into       \u2572\u2502\u2571\n+                                                                 \u25cb\n+                                                                 \u2502\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                           \u253c\n+                    \u2502JSON AST (.json)\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502         \u2502                \u2502\n+                                              \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b7\u2502 Representation \u2502\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502         \u2502                \u2502\n+                    \u2502 IDL (.smithy)  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+Semantic model\n+    The in-memory model used by tools. The :ref:`semantic model <semantic-model>`\n+    may be serialized into one or more model file representations.\n+Model File\n+    A file on the file system, in a particular representation. The model files\n+    that make up a semantic model MAY be split across multiple files to\n+    improve readability or modularity, and those files are not required to\n+    use the same representation.\n+Representation\n+    A particular model file format such as the Smithy IDL or JSON AST.\n+    Representations are loaded into the semantic model by mapping the\n+    representation to concepts in the semantic model.\n+\n+    * The :ref:`Smithy IDL <idl>` is a human-readable format that aims to\n+      streamline authoring and reading models.\n+    * The :ref:`JSON AST <json-ast>` aims to provide a more machine-readable\n+      format to easily share models across language implementations and better\n+      integrate with JSON-based ecosystems.\n+\n+\n+Model transformations\n+=====================\n+\n+The build process mentioned above performs a number of model transformations.\n+A :dfn:`model transformation` is the process of converting input model files\n+into output artifacts. Generated artifacts can be other Smithy models\n+(an endogenous transformation), other model formats (an exogenous\n+transformation), code, documentation, etc.\n+\n+.. text-figure::\n+    :caption: **Figure 1.2**: Smithy model transformations\n+    :name: figure-1.2\n+\n+           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+           \u2502               \u2502\u2572           \u2502               \u2502           \u2571\u2502               \u2502\n+           \u2502Semantic Model \u2502\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502Transformation \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502   Artifact    \u2502\n+           \u2502               \u2502\u2571           \u2502               \u2502           \u2572\u2502               \u2502\n+           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                                \u25b3\n+                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                   \u2502                            \u2502                            \u2502\n+           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+           \u2502Model to Model \u2502            \u2502   Model to    \u2502            \u2502  Artifact to  \u2502\n+           \u2502Transformation \u2502            \u2502   Artifact    \u2502            \u2502     Model     \u2502\n+           \u2502               \u2502            \u2502Transformation \u2502            \u2502Transformation \u2502\n+           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+\n+.. _semantic-model:\n+\n+------------------\n+The semantic model\n+------------------\n+\n+Smithy's *semantic model* is an in-memory model used by tools. It is\n+independent of any particular serialized representation. The semantic\n+model contains metadata and a graph of :ref:`shapes <shapes>`\n+connected by :ref:`shape IDs <shape-id>`.\n+\n+.. text-figure::\n+    :caption: **Figure 1.3**: The semantic model\n+    :name: figure-1.3\n+\n+                                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                                          \u2502Semantic Model \u2502\u2572\n+                                          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                                          \u2502metadata?      \u2502\u2571         \u2502\n+                                          \u2502               \u2502          \u2502\n+                                          \u2502               \u2502          \u2502\n+                                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n+                                                  \u253c     \u253c prelude    \u2502\n+                                                  \u2502     \u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                                  \u25cb\n+                                           shapes\u2571\u2502\u2572\n+        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+        \u2502 Applied Trait \u2502\u2572          shape \u2502  \u00ababstract\u00bb   \u2502\n+        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502     Shape     \u2502            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+        \u2502               \u2502\u2571                \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524            \u2502    ShapeID    \u2502\n+        \u2502               \u2502                 \u2502               \u2502            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+        \u2502               \u2502\u2572     applied-to \u2502               \u2502         id \u2502namespace      \u2502\n+        \u2502               \u2502\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502               \u2502\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502shape_name     \u2502\n+        \u2502               \u2502\u2571traits          \u2502               \u2502            \u2502member_name?   \u2502\n+        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+Shape\n+    Shapes are named data definitions that describe the structure of an API.\n+    Shapes are referenced and connected by :ref:`shape IDs <shape-id>`.\n+    Relationships between shapes are formed by :ref:`members <member>` that\n+    target other shapes, properties of shapes like the ``input`` and\n+    ``output`` properties of an :ref:`operation <operation>`, and\n+    :ref:`applied traits <applying-traits>` that attach a trait to a shape.\n+Shape ID\n+    A :ref:`shape ID <shape-id>` is used to identify shapes defined in a\n+    model. For example, ``smithy.example#MyShape``,\n+    ``smithy.example#Foo$bar``, and ``Baz`` are all different kinds of shape\n+    IDs.\n+Trait\n+    :ref:`Traits <traits>` are specialized shapes that form the basis of\n+    Smithy's meta-model. Traits are applied to shapes to associate metadata\n+    to a shape. They are typically used by tools to influence validation,\n+    serialization, and code generation.\n+Applied trait\n+    An applied trait is an instance of a trait applied to a shape, configured\n+    using a :ref:`node value <node-value>`.\n+Model metadata\n+    Metadata is a schema-less extensibility mechanism used to associate\n+    metadata to an entire model. For example, metadata is used to define\n+    :ref:`validators <validator-definition>` and model-wide\n+    :ref:`suppressions <suppression-definition>`. Metadata is defined\n+    using an ``object`` :ref:`node value <node-value>`.\n+Prelude\n+    The :ref:`prelude <prelude>` defines various simple shapes and every\n+    trait defined in the core specification. All Smithy models automatically\n+    include the prelude.\n+\n+\n+.. _model-files:\n+\n+-----------\n+Model files\n+-----------\n+\n+Smithy models MAY be divided into multiple files so that they are easier to\n+maintain and evolve. One or more model files can be assembled (or merged)\n+together to form a semantic model. The model files that form a semantic model\n+are not required to all be defined in the same representation; some models can\n+be defined using the IDL and others can be defined using the JSON AST.\n+\n+Model files do not explicitly include other model files; this responsibility\n+is left to tooling to ensure that all necessary model files are merged\n+together to form a valid semantic model.\n+\n+.. _merging-models:\n+\n+Merging model files\n+===================\n+\n+Implementations MUST take the following steps to merge models together to load\n+the semantic model:\n+\n+#. Duplicate shape IDs, if found, MUST cause the model merge to fail.\n+   See :ref:`shape-id-conflicts` for more information.\n+#. Merge any conflicting applied traits using\n+   :ref:`trait conflict resolution  <trait-conflict-resolution>`.\n+#. Merge the metadata objects of both models using the steps defined\n+   in :ref:`merging-metadata`.\n+\n+\n+.. _merging-metadata:\n+\n+Merging metadata\n+----------------\n+\n+When a conflict occurs between top-level metadata key-value pairs,\n+metadata is merged using the following logic:\n+\n+1. If a metadata key is only present in one model, then the entry is valid\n+   and added to the merged model.\n+2. If both models contain the same key and both values are arrays, then\n+   the entry is valid; the values of both arrays are concatenated into a\n+   single array and added to the merged model.\n+3. If both models contain the same key and both values are exactly equal,\n+   then the conflict is ignored and the value is added to the merged model.\n+4. If both models contain the same key and the values do not both map to\n+   arrays, then the key is invalid and there is a metadata conflict error.\n+\n+Given the following two Smithy models:\n+\n+.. code-block:: smithy\n+    :caption: model-a.smithy\n+\n+    metadata \"foo\" = [\"baz\", \"bar\"]\n+    metadata \"qux\" = \"test\"\n+    metadata \"validConflict\" = \"hi!\"\n+\n+.. code-block:: smithy\n+    :caption: model-b.smithy\n+\n+    metadata \"foo\" = [\"lorem\", \"ipsum\"]\n+    metadata \"lorem\" = \"ipsum\"\n+    metadata \"validConflict\" = \"hi!\"\n+\n+Merging ``model-a.smithy`` and ``model-b.smithy`` produces the following\n+model:\n+\n+.. code-block:: smithy\n+\n+    metadata \"foo\" = [\"baz\", \"bar\", \"lorem\", \"ipsum\"]\n+    metadata \"qux\" = \"test\"\n+    metadata \"lorem\" = \"ipsum\"\n+    metadata \"validConflict\" = \"hi!\"\n+\n+\n+.. _node-value:\n+\n+-----------\n+Node values\n+-----------\n+\n+Node values are JSON-like values used in the following places in the\n+semantic model:\n+\n+* **metadata**: Metadata is defined as a node value object.\n+* **applied trait**: The value of a trait applied to a shape is defined\n+  using a node value.\n+\n+.. text-figure::\n+    :caption: **Figure 1.4**: Node value types\n+    :name: figure-1.4\n+\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 Semantic Model  \u2502                     \u2502Applied Trait\u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+      \u2502                                            \u2502\n+      \u2502                                            \u2502\n+      \u2502                                            \u253c nodeValue\n+      \u2502                                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+      \u2502                                     \u2502 \u00ababstract\u00bb  \u2502\n+      \u2502                                     \u2502    Value    \u2502\n+      \u2502metadata                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+      \u2502                                            \u25b3\n+      \u25cb      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+      \u253c      \u2502                   \u2502                 \u2502               \u2502               \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502     Object      \u2502 \u2502      Array      \u2502 \u2502   Number    \u2502 \u2502   Boolean   \u2502 \u2502   String    \u2502\n+    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2502members:         \u2502 \u2502members: [Value] \u2502\n+    \u2502  [String, Value]\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+The following example defines metadata using a node value:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        metadata foo = \"hello\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"hello\"\n+            }\n+        }\n+\n+The following example defines a trait using a node value:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @length(min: 1, max: 10)\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#length\": {\n+                            \"min\": 1,\n+                            \"max\": 10\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+Node value types\n+================\n+\n+Node values have the same data model as JSON; they consist of the following\n+kinds of values:\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 30 70\n+\n+    * - Type\n+      - Description\n+    * - null\n+      - The lack of a value\n+    * - string\n+      - A UTF-8 string\n+    * - number\n+      - A double precision floating point number\n+    * - boolean\n+      - A Boolean, true or false value\n+    * - array\n+      - A list of heterogeneous node values\n+    * - object\n+      - A map of string keys to heterogeneous node values\n+\n+.. rubric:: Shape IDs, text blocks, et al.\n+\n+There is no specific node value type for shape IDs, text blocks, or\n+other higher-level features of the IDL; these values are stored and\n+treated in the semantic model as simply opaque strings, and their\n+validation happens before the creation of the model.\n+\n+\n+.. _shapes:\n+\n+------\n+Shapes\n+------\n+\n+Smithy models are made up of shapes. Shapes come in three kinds: simple,\n+aggregate, and service. A simple shape defines atomic or primitive values\n+such as ``integer`` and ``string``. Aggregate shapes have members such as\n+a list of strings or an ``Address`` structure. Service shapes have specific\n+semantics, unlike the very generic simple and aggregate shapes, as they\n+represent either a service, a resource managed by a service, or operations\n+on services and resources.\n+\n+Shapes are visualized using the following diagram:\n+\n+.. text-figure::\n+    :caption: **Figure 1.5**: Smithy shapes\n+    :name: figure-1.5\n+\n+                                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                             members \u2571\u2502 \u00ababstract\u00bb  \u2502\n+                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502    Shape    \u2502\n+                            \u2502        \u2572\u2502             \u2502\n+                            \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                            \u2502                \u25b3\n+                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                  \u2502         \u2502                \u2502                    \u2502\n+          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+          \u2502  \u00ababstract\u00bb   \u2502 \u2502container\u2502 \u00ababstract\u00bb  \u2502      \u2502 \u00ababstract\u00bb  \u2502\n+          \u2502    Simple     \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502  Aggregate  \u2502      \u2502   Service   \u2502\n+          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                  \u25b3                    \u25b3                    \u25b3\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502blob      \u2502\u2500\u2500\u253c\u2500\u2500\u2502boolean   \u2502      \u251c\u2500\u2500\u2500\u2500\u2502    List    \u2502  \u2502    \u2502         Service         \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u2502member      \u2502  \u2502    \u2502version                  \u2502\n+    \u2502document  \u2502\u2500\u2500\u253c\u2500\u2500\u2502string    \u2502      \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u251c\u2500\u2500\u2500\u2500\u2502operations: [Operation]? \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502resources: [Resource]?   \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502                    \u251c\u2500\u2500\u2500\u2500\u2502    Set     \u2502  \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    \u2502timestamp \u2502\u2500\u2500\u2524                    \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502                    \u2502    \u2502member      \u2502  \u2502    \u2502        Operation        \u2502\n+                  \u2502                    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502input: Structure?        \u2502\n+          \u2502  \u00ababstract\u00bb   \u2502            \u251c\u2500\u2500\u2500\u2500\u2502    Map     \u2502  \u251c\u2500\u2500\u2500\u2500\u2502output: Structure?       \u2502\n+          \u2502    Number     \u2502            \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    \u2502errors: [Structure]?     \u2502\n+          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502    \u2502key         \u2502  \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                  \u25b3                    \u2502    \u2502value       \u2502  \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502        Resource         \u2502\n+    \u2502byte      \u2502\u2500\u2500\u253c\u2500\u2500\u2502short     \u2502      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u251c\u2500\u2500\u2500\u2500\u2502 Structure  \u2502  \u2502    \u2502identifiers?             \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502create: Operation?       \u2502\n+    \u2502integer   \u2502\u2500\u2500\u253c\u2500\u2500\u2502long      \u2502      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502put: Operation?          \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2502   Union    \u2502  \u2502    \u2502read: Operation?         \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2502update: Operation?       \u2502\n+    \u2502float     \u2502\u2500\u2500\u253c\u2500\u2500\u2502double    \u2502                                \u2502delete: Operation?       \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2502list: : Operation?       \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                \u2502operations: [Operation]? \u2502\n+    \u2502bigInteger\u2502\u2500\u2500\u2534\u2500\u2500\u2502bigDecimal\u2502                                \u2502collectionOperations:    \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2502    [Operation]?         \u2502\n+                                                                 \u2502resources: [Resource]?   \u2502\n+                                                                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+\n+.. _shape-id:\n+\n+Shape ID\n+========\n+\n+All shapes have an assigned shape ID. A :dfn:`shape ID` is used to refer to\n+shapes in the model. Shape IDs adhere to the following syntax:\n+\n+.. code-block:: none\n+\n+    com.foo.baz#ShapeName$memberName\n+    \\_________/ \\_______/ \\________/\n+         |          |          |\n+     Namespace  Shape name  Member name\n+\n+Namespace\n+    A namespace is mechanism for logically grouping shapes in a way\n+    that makes them reusable alongside other models without naming\n+    conflicts. A semantic model MAY contain shapes defined across multiple\n+    namespaces. The IDL representation supports zero or one namespace per\n+    model file, while the JSON AST representation supports zero or more\n+    namespaces per model file.\n+Absolute shape ID\n+    An :dfn:`absolute shape ID` starts with a :token:`namespace` name,\n+    followed by \"``#``\", followed by a *relative shape ID*. All shape\n+    IDs in the semantic model MUST be absolute.\n+    For example, ``smithy.example#Foo`` and ``smithy.example#Foo$bar``\n+    are absolute shape IDs.\n+Relative shape ID\n+    A :dfn:`relative shape ID` contains a :token:`shape name <identifier>`\n+    and an optional :token:`member name <identifier>`. The shape name and\n+    member name are separated by the \"``$``\" symbol if a member name is\n+    present. For example, ``Foo`` and ``Foo$bar`` are relative shape IDs.\n+Root shape ID\n+    A :dfn:`root shape ID` is a shape ID that does not contain a member.\n+    For example, ``smithy.example#Foo`` and ``Foo`` are root shape IDs.\n+\n+.. rubric:: Shape ID ABNF\n+\n+Shape IDs are formally defined by the following ABNF:\n+\n+.. productionlist:: smithy\n+    shape_id               :`root_shape_id` [`shape_id_member`]\n+    root_shape_id          :`absolute_root_shape_id` / `identifier`\n+    absolute_root_shape_id :`namespace` \"#\" `identifier`\n+    namespace              :`identifier` *(\".\" `identifier`)\n+    identifier             :(ALPHA / \"_\") *(ALPHA / DIGIT / \"_\")\n+    shape_id_member        :\"$\" `identifier`\n+\n+.. rubric:: Best practices for defining shape names\n+\n+Consumers of a Smithy model MAY choose to inflect shape names, structure\n+member names, and other facets of a Smithy model in order to expose a more\n+idiomatic experience to particular programming languages. In order to make this\n+easier for consumers of a model, model authors SHOULD utilize a strict form of\n+PascalCase in which only the first letter of acronyms, abbreviations, and\n+initialisms are capitalized.\n+\n+===========   ===============\n+Recommended   Not recommended\n+===========   ===============\n+UserId        UserID\n+ResourceArn   ResourceARN\n+IoChannel     IOChannel\n+HtmlEntity    HTMLEntity\n+HtmlEntity    HTML_Entity\n+===========   ===============\n+\n+\n+.. _shape-id-conflicts:\n+\n+Shape ID conflicts\n+==================\n+\n+While shape ID references within the semantic model are case-sensitive, no\n+two shapes in the semantic model can have the same case-insensitive shape ID.\n+This restriction makes it easier to use Smithy models for code generation in\n+programming languages that do not support case-sensitive identifiers or that\n+perform some kind of normalization on generated identifiers (for example,\n+a Python code generator might convert all member names to lower snake case).\n+To illustrate, ``com.Foo#baz`` and ``com.foo#BAZ`` are not allowed in the\n+same semantic model. This restriction also extends to member names:\n+``com.foo#Baz$bar`` and ``com.foo#Baz$BAR`` are in conflict.\n+\n+\n+.. _simple-types:\n+\n+-------------\n+Simple shapes\n+-------------\n+\n+*Simple types* are types that do not contain nested types or shape references.\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 90\n+\n+    * - Type\n+      - Description\n+    * - blob\n+      - Uninterpreted binary data\n+    * - boolean\n+      - Boolean value type\n+    * - string\n+      - UTF-8 encoded string\n+    * - byte\n+      - 8-bit signed integer ranging from -128 to 127 (inclusive)\n+    * - short\n+      - 16-bit signed integer ranging from -32,768 to 32,767 (inclusive)\n+    * - integer\n+      - 32-bit signed integer ranging from -2^31 to (2^31)-1 (inclusive)\n+    * - long\n+      - 64-bit signed integer ranging from -2^63 to (2^63)-1 (inclusive)\n+    * - float\n+      - Single precision IEEE-754 floating point number\n+    * - double\n+      - Double precision IEEE-754 floating point number\n+    * - bigInteger\n+      - Arbitrarily large signed integer\n+    * - bigDecimal\n+      - Arbitrary precision signed decimal number\n+    * - timestamp\n+      - Represents an instant in time with no UTC offset or timezone. The\n+        serialization of a timestamp is an implementation detail that is\n+        determined by a :ref:`protocol <protocolDefinition-trait>` and\n+        MUST NOT have any effect on the types exposed by tooling to\n+        represent a timestamp value.\n+    * - document\n+      - Represents a protocol-agnostic untyped value used to represent open\n+        content, or data with no fixed schema, data that can't be modeled\n+        using rigid types, or data that has a schema that evolves outside\n+        of the purview of a service. The serialization format of a document\n+        is an implementation detail of a protocol and MUST NOT have any\n+        effect on the types exposed by tooling to represent a document value.\n+\n+Simple shapes are defined in the IDL using a :ref:`simple_shape_statement <idl-simple>`.\n+\n+.. note::\n+\n+    The :ref:`prelude model <prelude>` contains pre-defined shapes for every\n+    simple type.\n+\n+.. rubric:: Simple shape examples\n+\n+The following example defines a shape for each simple type in the\n+``smithy.example`` namespace.\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        blob Blob\n+        boolean Boolean\n+        string String\n+        byte Byte\n+        short Short\n+        integer Integer\n+        long Long\n+        float Float\n+        double Double\n+        bigInteger BigInteger\n+        bigDecimal BigDecimal\n+        timestamp Timestamp\n+        document Document\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#Blob\": {\n+                    \"type\": \"blob\"\n+                },\n+                \"smithy.example#Boolean\": {\n+                    \"type\": \"boolean\"\n+                },\n+                \"smithy.example#String\": {\n+                    \"type\": \"string\"\n+                },\n+                \"smithy.example#Byte\": {\n+                    \"type\": \"byte\"\n+                },\n+                \"smithy.example#Short\": {\n+                    \"type\": \"short\"\n+                },\n+                \"smithy.example#Integer\": {\n+                    \"type\": \"integer\"\n+                },\n+                \"smithy.example#Long\": {\n+                    \"type\": \"long\"\n+                },\n+                \"smithy.example#Float\": {\n+                    \"type\": \"float\"\n+                },\n+                \"smithy.example#Double\": {\n+                    \"type\": \"double\"\n+                },\n+                \"smithy.example#BigInteger\": {\n+                    \"type\": \"bigInteger\"\n+                },\n+                \"smithy.example#BigDecimal\": {\n+                    \"type\": \"bigDecimal\"\n+                },\n+                \"smithy.example#Timestamp\": {\n+                    \"type\": \"timestamp\"\n+                },\n+                \"smithy.example#Document\": {\n+                    \"type\": \"document\"\n+                }\n+            }\n+        }\n+\n+.. note::\n+\n+    When defining shapes in the IDL, a namespace MUST first be declared.\n+\n+\n+.. _aggregate-types:\n+\n+----------------\n+Aggregate shapes\n+----------------\n+\n+Aggregate types define shapes that are composed of other shapes. Aggregate shapes\n+reference other shapes using :ref:`members <member>`.\n+\n+.. list-table::\n+    :header-rows: 1\n+    :widths: 10 90\n+\n+    * - Type\n+      - Description\n+    * - :ref:`member`\n+      - Defined in aggregate shapes to reference other shapes\n+    * - :ref:`list`\n+      - Ordered collection of homogeneous values\n+    * - :ref:`set`\n+      - Unordered collection of unique homogeneous values\n+    * - :ref:`map`\n+      - Map data structure that maps string keys to homogeneous values\n+    * - :ref:`structure`\n+      - Fixed set of named heterogeneous members\n+    * - :ref:`union`\n+      - Tagged union data structure that can take on one of several\n+        different, but fixed, types\n+\n+\n+.. _member:\n+\n+Member\n+======\n+\n+:dfn:`Members` are defined in aggregate shapes to reference other shapes using\n+a :ref:`shape ID <shape-id>`. The shape referenced by a member is called its\n+\"target\". A member MUST NOT target a :ref:`trait <trait-shapes>`, ``operation``,\n+``resource``, ``service``, or ``member``.\n+\n+\n+.. _list:\n+\n+List\n+====\n+\n+The :dfn:`list` type represents an ordered homogeneous collection of values.\n+A list shape requires a single member named ``member``. Lists are defined\n+in the IDL using a :ref:`list_statement <idl-list>`.\n+\n+The following example defines a list with a string member from the\n+:ref:`prelude <prelude>`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        list MyList {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {\n+                    \"type\": \"list\",\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+.. rubric:: List member shape ID\n+\n+The shape ID of the member of a list is the list shape ID followed by\n+``$member``. For example, the shape ID of the list member in the above\n+example is ``smithy.example#MyList$member``.\n+\n+\n+.. _set:\n+\n+Set\n+===\n+\n+The :dfn:`set` type represents an unordered collection of unique homogeneous\n+values. A set shape requires a single member named ``member``.\n+Sets are defined in the IDL using a :ref:`set_statement <idl-set>`.\n+\n+The following example defines a set of strings:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        set StringSet {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#StringSet\": {\n+                    \"type\": \"set\",\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+.. rubric:: Set member shape ID\n+\n+The shape ID of the member of a set is the set shape ID followed by\n+``$member``. For example, the shape ID of the set member in the above\n+example is ``smithy.example#StringSet$member``.\n+\n+.. rubric:: Language support for sets\n+\n+Not all programming languages support set data structures. Such languages\n+SHOULD represent sets as a custom set data structure that can interpret value\n+hash codes and equality, or alternatively, store the values of a set data\n+structure in a list and rely on validation to ensure uniqueness.\n+\n+\n+.. _map:\n+\n+Map\n+===\n+\n+The :dfn:`map` type represents a map data structure that maps a\n+``string`` key to a homogeneous value. A map requires a member named ``key``\n+that MUST target a ``string`` shape and a member named ``value``.\n+Maps are defined in the IDL using a :ref:`map_statement <idl-map>`.\n+\n+The following example defines a map of strings to integers:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        map IntegerMap {\n+            key: String,\n+            value: Integer\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#IntegerMap\": {\n+                    \"type\": \"map\",\n+                    \"key\": {\n+                        \"target\": \"smithy.api#String\"\n+                    },\n+                    \"value\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+.. rubric:: Map member shape IDs\n+\n+The shape ID of the ``key`` member of a map is the map shape ID followed by\n+``$key``, and the shape ID of the ``value`` member is the map shape ID\n+followed by ``$value``. For example, the shape ID of the ``key`` member in\n+the above map is ``smithy.example#IntegerMap$key``, and the ``value``\n+member is ``smithy.example#IntegerMap$value``.\n+\n+\n+.. _structure:\n+\n+Structure\n+=========\n+\n+The :dfn:`structure` type represents a fixed set of named, unordered,\n+heterogeneous values. A structure shape contains a set of named members, and\n+each member name maps to exactly one :ref:`member <member>` definition.\n+Structures are defined in the IDL using a\n+:ref:`structure_statement <idl-structure>`.\n+\n+The following example defines a structure with two members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        structure MyStructure {\n+            foo: String,\n+\n+            @required\n+            baz: Integer,\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.api#String\"\n+                        },\n+                        \"baz\": {\n+                            \"target\": \"smithy.api#Integer\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+.. rubric:: Adding new members\n+\n+New members added to existing structures SHOULD be added to the end of the\n+structure. This ensures that programming languages that require a specific\n+data structure layout or alignment for code generated from Smithy models are\n+able to maintain backward compatibility.\n+\n+.. rubric:: Structure member shape IDs\n+\n+The shape ID of a member of a structure is the structure shape ID, followed\n+by \"#\", followed by the member name, For example, the shape ID of the \"foo\"\n+member in the above example is ``smithy.example#MyStructure$foo``.\n+\n+\n+.. _union:\n+\n+Union\n+=====\n+\n+The union type represents a `tagged union data structure`_ that can take\n+on several different, but fixed, types. Unions function similarly to\n+structures except that only one member can be used at any one time. A union\n+shape MUST contain one or more named :ref:`members <member>`. Unions are\n+defined in the IDL using a :ref:`union_statement <idl-union>`.\n+\n+The following example defines a union shape with several members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        union MyUnion {\n+            i32: Integer,\n+\n+            stringA: String,\n+\n+            @sensitive\n+            stringB: String,\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyUnion\": {\n+                    \"type\": \"union\",\n+                    \"members\": {\n+                        \"i32\": {\n+                            \"target\": \"smithy.api#Integer\"\n+                        },\n+                        \"stringA\": {\n+                            \"target\": \"smithy.api#String\"\n+                        },\n+                        \"stringB\": {\n+                            \"target\": \"smithy.api#String\",\n+                            \"traits\": {\n+                                \"smithy.api#sensitive\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+.. rubric:: Adding new members\n+\n+New members added to existing unions SHOULD be added to the end of the\n+union. This ensures that programming languages that require a specific\n+data structure layout or alignment for code generated from Smithy models are\n+able to maintain backward compatibility.\n+\n+.. rubric:: Union member shape IDs\n+\n+The shape ID of a member of a union is the union shape ID, followed\n+by \"#\", followed by the member name. For example, the shape ID of the \"i32\"\n+member in the above example is ``smithy.example#MyUnion$i32``.\n+\n+\n+.. _default-values:\n+\n+Default values\n+==============\n+\n+The values provided for :ref:`members <member>` are either always present\n+and set to a default value when necessary or *boxed*, meaning a value is\n+optionally present with no default value. Members are considered boxed if\n+the member is marked with the :ref:`box-trait` or the shape targeted by the\n+member is marked with the box trait. Members that target strings, timestamps,\n+and aggregate shapes are always considered boxed and have no default values.\n+\n+- The default value of a ``byte``, ``short``, ``integer``, ``long``,\n+  ``float``, and ``double`` shape that is not boxed is zero.\n+- The default value of a ``boolean`` shape that is not boxed is ``false``.\n+- All other shapes are always considered boxed and have no default value.\n+\n+\n+Recursive shape definitions\n+===========================\n+\n+Smithy allows for recursive shape definitions with the following constraint:\n+the member of a list, set, or map cannot directly or transitively target its\n+containing shape unless one or more members in the path from the container\n+back to itself targets a structure or union shape. This ensures that shapes\n+that are typically impossible to define in various programming languages are\n+not defined in Smithy models (for example, you can't define a recursive list\n+in Java ``List<List<List....``).\n+\n+The following recursive shape definition is **valid**:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        list ValidList {\n+            member: IntermediateStructure\n+        }\n+\n+        structure IntermediateStructure {\n+            foo: ValidList\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#ValidList\": {\n+                    \"type\": \"list\",\n+                    \"member\": {\n+                        \"target\": \"smithy.example#IntermediateStructure\"\n+                    }\n+                },\n+                \"smithy.example#IntermediateStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.example#ValidList\"\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+The following recursive shape definition is **invalid**:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        list RecursiveList {\n+            member: RecursiveList\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#RecursiveList\": {\n+                    \"type\": \"list\",\n+                    \"member\": {\n+                        \"target\": \"smithy.example#RecursiveList\"\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _service-types:\n+\n+--------------\n+Service shapes\n+--------------\n+\n+*Service types* have specific semantics and define services, resources,", "originalCommit": "ab2e617e464b006292aef001fb460b490077de09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxOTcxMg==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455319712", "bodyText": "IMO, service coming first makes sense because it's described as the \"starting point\". It's the most abstract thing you need to know before drilling into its components.", "author": "mtdowling", "createdAt": "2020-07-15T20:23:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3ODQ3OQ==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455278479", "bodyText": "Missing a \"type\".", "author": "kstich", "createdAt": "2020-07-15T19:06:42Z", "path": "docs/source/1.0/spec/core/idl.rst", "diffHunk": "@@ -0,0 +1,1886 @@\n+.. _idl:\n+\n+==========\n+Smithy IDL\n+==========\n+\n+Smithy models are defined using either the Smithy interface definition language\n+(IDL) or the :ref:`JSON abstract syntax tree <json-ast>` (AST). This document\n+defines the ABNF_ grammar and syntax for defining models with the Smithy IDL.\n+\n+.. contents:: Table of contents\n+    :depth: 1\n+    :local:\n+    :backlinks: none\n+\n+\n+-------------------\n+Smithy IDL overview\n+-------------------\n+\n+The Smithy IDL is made up of 3, ordered sections, each of which is optional:\n+\n+1. **Control section**; defines parser directives like which version of the\n+   IDL to use.\n+2. **Metadata section**; applies metadata to the entire model.\n+3. **Shape section**; where shapes and traits are defined. A namespace MUST\n+   be defined before any shapes or traits can be defined.\n+   :token:`use_statement`\\s can be defined after a namespace and before shapes\n+   or traits to refer to shapes in other namespaces using a shorter name.\n+\n+The following example defines a model file with each section:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+            // (1) Control section\n+            $version: \"1.0\"\n+\n+            // (2) Metadata section\n+            metadata foo = \"bar\"\n+\n+            // (3) Shape section\n+            namespace smithy.example\n+\n+            use smithy.other.namespace#MyString\n+\n+            structure MyStructure {\n+                @required\n+                foo: MyString\n+            }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"bar\"\n+            },\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.other.namespace#MyString\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+-------------\n+Lexical notes\n+-------------\n+\n+Smithy models MUST be encoded using UTF-8 and SHOULD use Unix style\n+line endings (``\\n``). The Smithy ABNF is whitespace sensitive.\n+\n+\n+.. _smithy-idl-abnf:\n+\n+---------------\n+Smithy IDL ABNF\n+---------------\n+\n+The Smithy IDL is defined by the following ABNF:\n+\n+.. productionlist:: smithy\n+    idl:`ws` `control_section` `metadata_section` `shape_section`\n+\n+.. rubric:: Whitespace\n+\n+.. productionlist:: smithy\n+    ws      :*(`sp` / `newline` / `comment`) ; whitespace\n+    sp      :*(%x20  / %x09) ; \" \" and \\t\n+    br      :`sp` (`comment` / `newline`) `sp` ; break\n+    newline :%x0A / %x0D.0A ; \\n and \\r\\n\n+\n+.. rubric:: Comments\n+\n+.. productionlist:: smithy\n+    comment: `documentation_comment` / `comment`\n+    documentation_comment:\"///\" *`not_newline` `br`\n+    line_comment: \"//\" *`not_newline` `newline`\n+    not_newline: %x09 / %x20-10FFFF ; Any character except newline\n+\n+.. rubric:: Control\n+\n+.. productionlist:: smithy\n+    control_section   :*(`control_statement`)\n+    control_statement :\"$\" `ws` `node_object_key` `ws` \":\" `ws` `node_value` `br`\n+\n+.. rubric:: Metadata\n+\n+.. productionlist:: smithy\n+    metadata_section   :*(`metadata_statement`)\n+    metadata_statement :\"metadata\" `ws` `node_object_key` `ws` \"=\" `ws` `node_value` `br`\n+\n+.. rubric:: Node values\n+\n+.. productionlist:: smithy\n+    node_value :`node_array`\n+               :/ `node_object`\n+               :/ `number`\n+               :/ `node_keywords`\n+               :/ `node_string_value`\n+    node_array          :`empty_node_array` / `populated_node_array`\n+    empty_node_array    :\"[\" `ws` \"]\"\n+    populated_node_array:\"[\" `ws` `node_value` `ws`\n+                        :       *(`comma` `node_value` `ws`)\n+                        :       `trailing_comma` \"]\"\n+    trailing_comma      :[`comma`]\n+    comma               :\",\" `ws`\n+    node_object          :`empty_node_object` / `populated_node_object`\n+    empty_node_object    :\"{\" `ws` \"}\"\n+    populated_node_object:\"{\" `ws` `node_object_kvp` `ws`\n+                         :       *(`comma` `node_object_kvp` `ws`)\n+                         :       `trailing_comma` \"}\"\n+    node_object_kvp      :`node_object_key` `ws` \":\" `ws` `node_value`\n+    node_object_key      :`quoted_text` / `identifier`\n+    number              :[`minus`] `int` [`frac`] [`exp`]\n+    decimal_point       :%x2E ; .\n+    digit1_9            :%x31-39 ; 1-9\n+    e                   :%x65 / %x45 ; e E\n+    exp                 :`e` [`minus` / `plus`] 1*DIGIT\n+    frac                :`decimal_point` 1*DIGIT\n+    int                 :`zero` / (`digit1_9` *DIGIT)\n+    minus               :%x2D ; -\n+    plus                :%x2B ; +\n+    zero                :%x30 ; 0\n+    node_keywords: \"true\" / \"false\" / \"null\"\n+    node_string_value   :`shape_id` / `text_block` / `quoted_text`\n+    quoted_text         :DQUOTE *`quoted_char` DQUOTE\n+    quoted_char         :%x20-21        ; space - \"!\"\n+                        :/ %x23-5B        ; \"#\" - \"[\"\n+                        :/ %x5D-10FFFF    ; \"]\"+\n+                        :/ `escaped_char`\n+                        :/ `preserved_double`\n+    escaped_char        :`escape` (`escape` / \"'\" / DQUOTE / \"b\" / \"f\" / \"n\" / \"r\" / \"t\" / \"/\" / `unicode_escape`)\n+    unicode_escape      :\"u\" `hex` `hex` `hex` `hex`\n+    hex                 : DIGIT / %x41-46 / %x61-66\n+    preserved_double    :`escape` (%x20-21 / %x23-5B / %x5D-10FFFF)\n+    escape              :%x5C ; backslash\n+    text_block          :`three_dquotes` `br` *`quoted_char` `three_dquotes`\n+    three_dquotes       :DQUOTE DQUOTE DQUOTE\n+\n+.. rubric:: Shapes\n+\n+.. productionlist:: smithy\n+    shape_section :[`namespace_statement` [`use_section`] [`shape_statements`]]\n+    namespace_statement :\"namespace\" `ws` `namespace` `br`\n+    use_section   :*(`use_statement`)\n+    use_statement :\"use\" `ws` `absolute_root_shape_id` `br`\n+    shape_statements             :*(`shape_statement` / `apply_statement`)\n+    shape_statement              :`trait_statements` `shape_body` `br`\n+    shape_body                   :`simple_shape_statement`\n+                                 :/ `list_statement`\n+                                 :/ `set_statement`\n+                                 :/ `map_statement`\n+                                 :/ `structure_statement`\n+                                 :/ `union_statement`\n+                                 :/ `service_statement`\n+                                 :/ `operation_statement`\n+                                 :/ `resource_statement`\n+    simple_shape_statement :`simple_type_name` `ws` `identifier`\n+    simple_type_name       :\"blob\" / \"boolean\" / \"document\" / \"string\"\n+                           :/ \"byte\" / \"short\" / \"integer\" / \"long\"\n+                           :/ \"float\" / \"double\" / \"bigInteger\"\n+                           :/ \"bigDecimal\" / \"timestamp\"\n+    shape_members           :`empty_shape_members` / `populated_shape_members`\n+    empty_shape_members     :\"{\" `ws` \"}\"\n+    populated_shape_members :\"{\" `ws` `shape_member_kvp`\n+                            :  *(`comma` `shape_member_kvp` `ws`) `trailing_comma` \"}\"\n+    shape_member_kvp        :`trait_statements` `identifier` `ws` \":\" `ws` `shape_id`\n+    list_statement :\"list\" `ws` `identifier` `ws` `shape_members`\n+    set_statement :\"set\" `ws` `identifier` `ws` `shape_members`\n+    map_statement :\"map\" `ws` `identifier` `ws` `shape_members`\n+    structure_statement     :\"structure\" `ws` `identifier` `ws` `shape_members`\n+    union_statement :\"union\" `ws` `identifier` `ws` `shape_members`\n+    service_statement :\"service\" `ws` `identifier` `ws` `node_object`\n+    operation_statement :\"operation\" `ws` `identifier` `ws` `node_object`\n+    resource_statement :\"resource\" `ws` `identifier` `ws` `node_object`\n+\n+.. rubric:: Traits\n+\n+.. productionlist:: smithy\n+    trait_statements    : *(`ws` `trait`) `ws`\n+    trait               :\"@\" `shape_id` [`trait_body`]\n+    trait_body          :\"(\" `ws` `trait_body_value` `ws` \")\"\n+    trait_body_value    :`trait_structure` / `node_value`\n+    trait_structure     :`trait_structure_kvp` *(`ws` `comma` `trait_structure_kvp`)\n+    trait_structure_kvp :`node_object_key` `ws` \":\" `ws` `node_value`\n+    apply_statement :\"apply\" `ws` `shape_id` `ws` `trait` `br`\n+\n+\n+.. _comments:\n+\n+--------\n+Comments\n+--------\n+\n+A :token:`comment <comment>` can appear at any place between tokens where\n+whitespace (:token:`ws`) can appear. Comments in Smithy are defined using two\n+forward slashes followed by any character. A newline terminates a comment.\n+\n+.. code-block:: smithy\n+\n+    // This is a comment\n+    namespace com.foo // This is also a comment\n+\n+    // Another comment\n+    string MyString\n+\n+.. note::\n+\n+    Three forward slashes can be used to define the documentation of a shape\n+    using a special :ref:`documentation comment <documentation-comment>`.\n+\n+\n+.. _control-statement:\n+\n+---------------\n+Control section\n+---------------\n+\n+The :token:`control section <control_section>` of a model contains\n+:token:`control statements <control_statement>` that apply parser directives\n+to a *specific IDL file*. Because control statements influence parsing, they\n+MUST appear at the beginning of a file before any other statements and have\n+no effect on the :ref:`semantic model <semantic-model>`\n+\n+The :ref:`version <smithy-version>` statement is currently the only control\n+statement defined in the Smithy IDL. Implementations MUST ignore unknown\n+control statements.\n+\n+\n+.. _smithy-version:\n+\n+Version statement\n+=================\n+\n+The Smithy specification is versioned using a ``major`` . ``minor``\n+versioning scheme. A version requirement is specified for a model file using\n+the ``$version`` control statement. When no version number is specified in\n+the IDL, an implementation SHOULD assume that the model can be loaded.\n+Because this can lead to unexpected parsing errors, models SHOULD always\n+include a version.\n+\n+The value provided in a version control statement is a string that MUST\n+adhere to the following ABNF:\n+\n+.. productionlist:: smithy\n+    version_string :1*DIGIT [ \".\" 1*DIGIT ]\n+\n+The following example sets the version to ``1``, meaning that tooling MUST\n+support a version greater than or equal to ``1.0`` and less than ``2.0``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1\"\n+        }\n+\n+A minor version SHOULD be provided when a model depends on a feature released\n+in a minor update of the specification. The following example sets the\n+version requirement of a file to ``1.1``, meaning that tooling MUST support a\n+version greater than or equal to ``1.1`` and less than ``2.0``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1.1\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.1\"\n+        }\n+\n+.. rubric:: Version compatibility\n+\n+A single version statement can appear in a model file, but different versions\n+MAY be encountered when merging multiple model files together. Multiple\n+versions are supported if and only if all of the version statements are\n+supported by the tool loading the models.\n+\n+\n+.. _metadata-section:\n+\n+----------------\n+Metadata section\n+----------------\n+\n+The :token:`metadata section <metadata_section>` is used to apply untyped\n+metadata to the entire model. A :token:`metadata_statement` consists of the\n+metadata key to set, followed by ``=``, followed by the\n+:token:`node value <node_value>` to assign to the key.\n+\n+The following example defines metadata in the model:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        metadata greeting = \"hello\"\n+        metadata \"stringList\" = [\"a\", \"b\", \"c\"]\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"greeting\": \"hello\",\n+                \"stringList\": [\"a\", \"b\", \"c\"]\n+            }\n+        }\n+\n+\n+-------------\n+Shape section\n+-------------\n+\n+The :token:`shape section <shape_section>` of the IDL is used to define\n+shapes and apply traits to shapes.\n+\n+\n+.. _namespaces:\n+\n+Namespaces\n+==========\n+\n+Shapes can only be defined after a namespace is declared. A namespace is\n+declared using a :token:`namespace statement <namespace_statement>`. Only\n+one namespace can appear per file.\n+\n+The following example defines a string shape named ``MyString`` in the\n+``smithy.example`` namespace:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\"\n+                }\n+            }\n+        }\n+\n+\n+.. _use-statement:\n+\n+Referring to shapes\n+===================\n+\n+The :token:`use section <use_section>` of the IDL is used to import shapes\n+into the current namespace so that they can be referred to using a\n+:ref:`relative shape ID <relative-shape-id>`. The :token:`use_statement <use_statement>`\\s\n+that make up this section have no effect on the :ref:`semantic model <semantic-model>`.\n+\n+The following example uses ``smithy.example#Foo`` and ``smithy.example#Baz``\n+so that they can be referred to using only ``Foo`` and ``Baz``.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.hello\n+\n+    use smithy.example#Foo\n+    use smithy.example#Baz\n+\n+    map MyMap {\n+        // Resolves to smithy.example#Foo\n+        key: Foo,\n+        // Resolves to smithy.example#Baz\n+        value: Baz,\n+    }\n+\n+A use statement can refer to :ref:`traits <traits>` too. The following example\n+uses the ``smithy.example#test`` and ``smithy.example#anotherTrait``\n+traits so that they can be applied using relative shape IDs:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.hello\n+\n+    use smithy.example#test\n+    use smithy.example#anotherTrait\n+\n+    @test // <-- Resolves to smithy.example#test\n+    string MyString\n+\n+.. rubric:: Use statement validation\n+\n+#. A shape cannot be defined in a file with the same name as one of the\n+   shapes imported with a ``use`` statement.\n+#. Shapes IDs with members names cannot be imported with a use statement.\n+\n+\n+.. _relative-shape-id:\n+\n+Relative shape ID resolution\n+----------------------------\n+\n+Relative shape IDs are resolved using the following process:\n+\n+#. If a :token:`use_statement` has imported a shape with the same name,\n+   the shape ID resolves to the imported shape ID.\n+#. If a shape is defined in the same namespace as the shape with the same name,\n+   the namespace of the shape resolves to the *current namespace*.\n+#. If a shape is defined in the :ref:`prelude <prelude>` with the same name,\n+   the namespace resolves to ``smithy.api``.\n+#. If a relative shape ID does not satisfy one of the above cases, the shape\n+   ID is invalid, and the namespace is inherited from the *current namespace*.\n+\n+The following example Smithy model contains comments above each member of\n+the shape named ``MyStructure`` that describes the shape the member resolves\n+to.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    use foo.baz#Bar\n+\n+    string MyString\n+\n+    structure MyStructure {\n+        // Resolves to smithy.example#MyString\n+        // There is a shape named MyString defined in the same namespace.\n+        a: MyString,\n+\n+        // Resolves to smithy.example#MyString\n+        // Absolute shape IDs do not perform namespace resolution.\n+        b: smithy.example#MyString,\n+\n+        // Resolves to foo.baz#Bar\n+        // The \"use foo.baz#Bar\" statement imported the Bar symbol,\n+        // allowing the shape to be referenced using a relative shape ID.\n+        c: Bar,\n+\n+        // Resolves to smithy.api#String\n+        // No shape named String was imported through a use statement\n+        // the smithy.example namespace does not contain a shape named\n+        // String, and the prelude model contains a shape named String.\n+        d: String,\n+\n+        // Resolves to smithy.example#MyBoolean.\n+        // There is a shape named MyBoolean defined in the same namespace.\n+        // Forward references are supported both within the same file and\n+        // across multiple files.\n+        e: MyBoolean,\n+\n+        // Resolves to smithy.example#InvalidShape. A shape by this name has\n+        // not been imported through a use statement, a shape by this name\n+        // does not exist in the current namespace, and a shape by this name\n+        // does not exist in the prelude model.\n+        f: InvalidShape,\n+    }\n+\n+    boolean MyBoolean\n+\n+\n+.. _syntactic-shape-ids:\n+\n+Syntactic shape IDs\n+-------------------\n+\n+Unquoted string values that are not object keys in the Smithy IDL are\n+considered lexical shape IDs and are resolved to absolute shape IDs using the\n+process defined in :ref:`relative-shape-id`.\n+\n+The following model defines a list that references a string shape defined\n+in another namespace.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    use smithy.other#MyString\n+\n+    list MyList {\n+        member: MyString\n+    }\n+\n+The above model is equivalent to the following JSON AST model:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"shapes\": {\n+            \"smithy.example#MyList\": {\n+                \"type\": \"list\",\n+                \"members\": {\n+                    \"target\": \"smithy.other#MyString\"\n+                }\n+            }\n+        }\n+    }\n+\n+.. rubric:: Use quotes for literal strings\n+\n+Values that are not meant to be shape IDs MUST be quoted. The following\n+model is syntactically valid but semantically incorrect because\n+it resolves the value of the :ref:`error-trait` to the shape ID\n+``\"smithy.example#client\"`` rather than using the string literal value of\n+``\"client\"``:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    @error(client) // <-- This MUST be \"client\"\n+    structure Error\n+\n+    string client\n+\n+The above example is equivalent to the following incorrect JSON AST:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"shapes\": {\n+            \"smithy.example#Error\": {\n+                \"type\": \"structure\",\n+                \"traits\": {\n+                    \"smithy.api#error\": \"smithy.example#client\"\n+                }\n+            },\n+            \"smithy.example#client\": {\n+                \"type\": \"string\"\n+            }\n+        }\n+    }\n+\n+.. rubric:: Object keys\n+\n+Object keys are not treated as shape IDs. The following example defines a\n+:ref:`metadata <metadata-section>` object, and when loaded into the\n+:ref:`semantic model <semantic-model>`, the object key ``String`` remains\n+the same literal string value of ``String`` while the value is treated as\n+a shape ID and resolves to the string literal ``\"smithy.api#String\"``.\n+\n+.. code-block:: smithy\n+\n+    metadata foo = {\n+        String: String,\n+    }\n+\n+The above example is equivalent to the following JSON AST:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"metadata\": {\n+            \"String\": \"smithy.api#String\"\n+        }\n+    }\n+\n+.. rubric:: Semantic model\n+\n+Syntactic shape IDs are syntactic sugar for defining fully-qualified\n+shape IDs inside of strings, and this difference is inconsequential in the\n+:ref:`semantic model <semantic-model>`. A syntactic shape ID SHOULD be\n+resolved to a string that contains a fully-qualified shape ID when parsing\n+the model.\n+\n+\n+Defining shapes\n+===============\n+\n+Shapes are defined using a :token:`shape_statement`.\n+\n+\n+.. _idl-simple:\n+\n+Simple shapes\n+-------------\n+\n+:ref:`Simple shapes <simple-types>` are defined using a\n+:token:`simple_shape_statement`.\n+\n+The following example defines a ``string`` shape:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#String\": {\n+                    \"type\": \"string\"\n+                }\n+            }\n+        }\n+\n+The following example defines an ``integer`` shape with a :ref:`range-trait`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @range(min: 0, max: 1000)\n+        integer MaxResults\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MaxResults\": {\n+                    \"type\": \"integer\",\n+                    \"traits\": {\n+                        \"smithy.api#range\": {\n+                            \"min\": 0,\n+                            \"max\": 100\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-list:\n+\n+List shapes\n+-----------\n+\n+A :ref:`list <list>` shape is defined using a :token:`list_statement`.\n+\n+The following example defines a list with a string member from the\n+:ref:`prelude <prelude>`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        list MyList {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to the list shape and its member:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @length(min: 3, max: 10)\n+        list MyList {\n+            @length(min: 1, max: 100)\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {\n+                    \"member\": {", "originalCommit": "ab2e617e464b006292aef001fb460b490077de09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3ODU4MA==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455278580", "bodyText": "Missing a \"type\".", "author": "kstich", "createdAt": "2020-07-15T19:06:55Z", "path": "docs/source/1.0/spec/core/idl.rst", "diffHunk": "@@ -0,0 +1,1886 @@\n+.. _idl:\n+\n+==========\n+Smithy IDL\n+==========\n+\n+Smithy models are defined using either the Smithy interface definition language\n+(IDL) or the :ref:`JSON abstract syntax tree <json-ast>` (AST). This document\n+defines the ABNF_ grammar and syntax for defining models with the Smithy IDL.\n+\n+.. contents:: Table of contents\n+    :depth: 1\n+    :local:\n+    :backlinks: none\n+\n+\n+-------------------\n+Smithy IDL overview\n+-------------------\n+\n+The Smithy IDL is made up of 3, ordered sections, each of which is optional:\n+\n+1. **Control section**; defines parser directives like which version of the\n+   IDL to use.\n+2. **Metadata section**; applies metadata to the entire model.\n+3. **Shape section**; where shapes and traits are defined. A namespace MUST\n+   be defined before any shapes or traits can be defined.\n+   :token:`use_statement`\\s can be defined after a namespace and before shapes\n+   or traits to refer to shapes in other namespaces using a shorter name.\n+\n+The following example defines a model file with each section:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+            // (1) Control section\n+            $version: \"1.0\"\n+\n+            // (2) Metadata section\n+            metadata foo = \"bar\"\n+\n+            // (3) Shape section\n+            namespace smithy.example\n+\n+            use smithy.other.namespace#MyString\n+\n+            structure MyStructure {\n+                @required\n+                foo: MyString\n+            }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"bar\"\n+            },\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.other.namespace#MyString\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+-------------\n+Lexical notes\n+-------------\n+\n+Smithy models MUST be encoded using UTF-8 and SHOULD use Unix style\n+line endings (``\\n``). The Smithy ABNF is whitespace sensitive.\n+\n+\n+.. _smithy-idl-abnf:\n+\n+---------------\n+Smithy IDL ABNF\n+---------------\n+\n+The Smithy IDL is defined by the following ABNF:\n+\n+.. productionlist:: smithy\n+    idl:`ws` `control_section` `metadata_section` `shape_section`\n+\n+.. rubric:: Whitespace\n+\n+.. productionlist:: smithy\n+    ws      :*(`sp` / `newline` / `comment`) ; whitespace\n+    sp      :*(%x20  / %x09) ; \" \" and \\t\n+    br      :`sp` (`comment` / `newline`) `sp` ; break\n+    newline :%x0A / %x0D.0A ; \\n and \\r\\n\n+\n+.. rubric:: Comments\n+\n+.. productionlist:: smithy\n+    comment: `documentation_comment` / `comment`\n+    documentation_comment:\"///\" *`not_newline` `br`\n+    line_comment: \"//\" *`not_newline` `newline`\n+    not_newline: %x09 / %x20-10FFFF ; Any character except newline\n+\n+.. rubric:: Control\n+\n+.. productionlist:: smithy\n+    control_section   :*(`control_statement`)\n+    control_statement :\"$\" `ws` `node_object_key` `ws` \":\" `ws` `node_value` `br`\n+\n+.. rubric:: Metadata\n+\n+.. productionlist:: smithy\n+    metadata_section   :*(`metadata_statement`)\n+    metadata_statement :\"metadata\" `ws` `node_object_key` `ws` \"=\" `ws` `node_value` `br`\n+\n+.. rubric:: Node values\n+\n+.. productionlist:: smithy\n+    node_value :`node_array`\n+               :/ `node_object`\n+               :/ `number`\n+               :/ `node_keywords`\n+               :/ `node_string_value`\n+    node_array          :`empty_node_array` / `populated_node_array`\n+    empty_node_array    :\"[\" `ws` \"]\"\n+    populated_node_array:\"[\" `ws` `node_value` `ws`\n+                        :       *(`comma` `node_value` `ws`)\n+                        :       `trailing_comma` \"]\"\n+    trailing_comma      :[`comma`]\n+    comma               :\",\" `ws`\n+    node_object          :`empty_node_object` / `populated_node_object`\n+    empty_node_object    :\"{\" `ws` \"}\"\n+    populated_node_object:\"{\" `ws` `node_object_kvp` `ws`\n+                         :       *(`comma` `node_object_kvp` `ws`)\n+                         :       `trailing_comma` \"}\"\n+    node_object_kvp      :`node_object_key` `ws` \":\" `ws` `node_value`\n+    node_object_key      :`quoted_text` / `identifier`\n+    number              :[`minus`] `int` [`frac`] [`exp`]\n+    decimal_point       :%x2E ; .\n+    digit1_9            :%x31-39 ; 1-9\n+    e                   :%x65 / %x45 ; e E\n+    exp                 :`e` [`minus` / `plus`] 1*DIGIT\n+    frac                :`decimal_point` 1*DIGIT\n+    int                 :`zero` / (`digit1_9` *DIGIT)\n+    minus               :%x2D ; -\n+    plus                :%x2B ; +\n+    zero                :%x30 ; 0\n+    node_keywords: \"true\" / \"false\" / \"null\"\n+    node_string_value   :`shape_id` / `text_block` / `quoted_text`\n+    quoted_text         :DQUOTE *`quoted_char` DQUOTE\n+    quoted_char         :%x20-21        ; space - \"!\"\n+                        :/ %x23-5B        ; \"#\" - \"[\"\n+                        :/ %x5D-10FFFF    ; \"]\"+\n+                        :/ `escaped_char`\n+                        :/ `preserved_double`\n+    escaped_char        :`escape` (`escape` / \"'\" / DQUOTE / \"b\" / \"f\" / \"n\" / \"r\" / \"t\" / \"/\" / `unicode_escape`)\n+    unicode_escape      :\"u\" `hex` `hex` `hex` `hex`\n+    hex                 : DIGIT / %x41-46 / %x61-66\n+    preserved_double    :`escape` (%x20-21 / %x23-5B / %x5D-10FFFF)\n+    escape              :%x5C ; backslash\n+    text_block          :`three_dquotes` `br` *`quoted_char` `three_dquotes`\n+    three_dquotes       :DQUOTE DQUOTE DQUOTE\n+\n+.. rubric:: Shapes\n+\n+.. productionlist:: smithy\n+    shape_section :[`namespace_statement` [`use_section`] [`shape_statements`]]\n+    namespace_statement :\"namespace\" `ws` `namespace` `br`\n+    use_section   :*(`use_statement`)\n+    use_statement :\"use\" `ws` `absolute_root_shape_id` `br`\n+    shape_statements             :*(`shape_statement` / `apply_statement`)\n+    shape_statement              :`trait_statements` `shape_body` `br`\n+    shape_body                   :`simple_shape_statement`\n+                                 :/ `list_statement`\n+                                 :/ `set_statement`\n+                                 :/ `map_statement`\n+                                 :/ `structure_statement`\n+                                 :/ `union_statement`\n+                                 :/ `service_statement`\n+                                 :/ `operation_statement`\n+                                 :/ `resource_statement`\n+    simple_shape_statement :`simple_type_name` `ws` `identifier`\n+    simple_type_name       :\"blob\" / \"boolean\" / \"document\" / \"string\"\n+                           :/ \"byte\" / \"short\" / \"integer\" / \"long\"\n+                           :/ \"float\" / \"double\" / \"bigInteger\"\n+                           :/ \"bigDecimal\" / \"timestamp\"\n+    shape_members           :`empty_shape_members` / `populated_shape_members`\n+    empty_shape_members     :\"{\" `ws` \"}\"\n+    populated_shape_members :\"{\" `ws` `shape_member_kvp`\n+                            :  *(`comma` `shape_member_kvp` `ws`) `trailing_comma` \"}\"\n+    shape_member_kvp        :`trait_statements` `identifier` `ws` \":\" `ws` `shape_id`\n+    list_statement :\"list\" `ws` `identifier` `ws` `shape_members`\n+    set_statement :\"set\" `ws` `identifier` `ws` `shape_members`\n+    map_statement :\"map\" `ws` `identifier` `ws` `shape_members`\n+    structure_statement     :\"structure\" `ws` `identifier` `ws` `shape_members`\n+    union_statement :\"union\" `ws` `identifier` `ws` `shape_members`\n+    service_statement :\"service\" `ws` `identifier` `ws` `node_object`\n+    operation_statement :\"operation\" `ws` `identifier` `ws` `node_object`\n+    resource_statement :\"resource\" `ws` `identifier` `ws` `node_object`\n+\n+.. rubric:: Traits\n+\n+.. productionlist:: smithy\n+    trait_statements    : *(`ws` `trait`) `ws`\n+    trait               :\"@\" `shape_id` [`trait_body`]\n+    trait_body          :\"(\" `ws` `trait_body_value` `ws` \")\"\n+    trait_body_value    :`trait_structure` / `node_value`\n+    trait_structure     :`trait_structure_kvp` *(`ws` `comma` `trait_structure_kvp`)\n+    trait_structure_kvp :`node_object_key` `ws` \":\" `ws` `node_value`\n+    apply_statement :\"apply\" `ws` `shape_id` `ws` `trait` `br`\n+\n+\n+.. _comments:\n+\n+--------\n+Comments\n+--------\n+\n+A :token:`comment <comment>` can appear at any place between tokens where\n+whitespace (:token:`ws`) can appear. Comments in Smithy are defined using two\n+forward slashes followed by any character. A newline terminates a comment.\n+\n+.. code-block:: smithy\n+\n+    // This is a comment\n+    namespace com.foo // This is also a comment\n+\n+    // Another comment\n+    string MyString\n+\n+.. note::\n+\n+    Three forward slashes can be used to define the documentation of a shape\n+    using a special :ref:`documentation comment <documentation-comment>`.\n+\n+\n+.. _control-statement:\n+\n+---------------\n+Control section\n+---------------\n+\n+The :token:`control section <control_section>` of a model contains\n+:token:`control statements <control_statement>` that apply parser directives\n+to a *specific IDL file*. Because control statements influence parsing, they\n+MUST appear at the beginning of a file before any other statements and have\n+no effect on the :ref:`semantic model <semantic-model>`\n+\n+The :ref:`version <smithy-version>` statement is currently the only control\n+statement defined in the Smithy IDL. Implementations MUST ignore unknown\n+control statements.\n+\n+\n+.. _smithy-version:\n+\n+Version statement\n+=================\n+\n+The Smithy specification is versioned using a ``major`` . ``minor``\n+versioning scheme. A version requirement is specified for a model file using\n+the ``$version`` control statement. When no version number is specified in\n+the IDL, an implementation SHOULD assume that the model can be loaded.\n+Because this can lead to unexpected parsing errors, models SHOULD always\n+include a version.\n+\n+The value provided in a version control statement is a string that MUST\n+adhere to the following ABNF:\n+\n+.. productionlist:: smithy\n+    version_string :1*DIGIT [ \".\" 1*DIGIT ]\n+\n+The following example sets the version to ``1``, meaning that tooling MUST\n+support a version greater than or equal to ``1.0`` and less than ``2.0``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1\"\n+        }\n+\n+A minor version SHOULD be provided when a model depends on a feature released\n+in a minor update of the specification. The following example sets the\n+version requirement of a file to ``1.1``, meaning that tooling MUST support a\n+version greater than or equal to ``1.1`` and less than ``2.0``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1.1\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.1\"\n+        }\n+\n+.. rubric:: Version compatibility\n+\n+A single version statement can appear in a model file, but different versions\n+MAY be encountered when merging multiple model files together. Multiple\n+versions are supported if and only if all of the version statements are\n+supported by the tool loading the models.\n+\n+\n+.. _metadata-section:\n+\n+----------------\n+Metadata section\n+----------------\n+\n+The :token:`metadata section <metadata_section>` is used to apply untyped\n+metadata to the entire model. A :token:`metadata_statement` consists of the\n+metadata key to set, followed by ``=``, followed by the\n+:token:`node value <node_value>` to assign to the key.\n+\n+The following example defines metadata in the model:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        metadata greeting = \"hello\"\n+        metadata \"stringList\" = [\"a\", \"b\", \"c\"]\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"greeting\": \"hello\",\n+                \"stringList\": [\"a\", \"b\", \"c\"]\n+            }\n+        }\n+\n+\n+-------------\n+Shape section\n+-------------\n+\n+The :token:`shape section <shape_section>` of the IDL is used to define\n+shapes and apply traits to shapes.\n+\n+\n+.. _namespaces:\n+\n+Namespaces\n+==========\n+\n+Shapes can only be defined after a namespace is declared. A namespace is\n+declared using a :token:`namespace statement <namespace_statement>`. Only\n+one namespace can appear per file.\n+\n+The following example defines a string shape named ``MyString`` in the\n+``smithy.example`` namespace:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\"\n+                }\n+            }\n+        }\n+\n+\n+.. _use-statement:\n+\n+Referring to shapes\n+===================\n+\n+The :token:`use section <use_section>` of the IDL is used to import shapes\n+into the current namespace so that they can be referred to using a\n+:ref:`relative shape ID <relative-shape-id>`. The :token:`use_statement <use_statement>`\\s\n+that make up this section have no effect on the :ref:`semantic model <semantic-model>`.\n+\n+The following example uses ``smithy.example#Foo`` and ``smithy.example#Baz``\n+so that they can be referred to using only ``Foo`` and ``Baz``.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.hello\n+\n+    use smithy.example#Foo\n+    use smithy.example#Baz\n+\n+    map MyMap {\n+        // Resolves to smithy.example#Foo\n+        key: Foo,\n+        // Resolves to smithy.example#Baz\n+        value: Baz,\n+    }\n+\n+A use statement can refer to :ref:`traits <traits>` too. The following example\n+uses the ``smithy.example#test`` and ``smithy.example#anotherTrait``\n+traits so that they can be applied using relative shape IDs:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.hello\n+\n+    use smithy.example#test\n+    use smithy.example#anotherTrait\n+\n+    @test // <-- Resolves to smithy.example#test\n+    string MyString\n+\n+.. rubric:: Use statement validation\n+\n+#. A shape cannot be defined in a file with the same name as one of the\n+   shapes imported with a ``use`` statement.\n+#. Shapes IDs with members names cannot be imported with a use statement.\n+\n+\n+.. _relative-shape-id:\n+\n+Relative shape ID resolution\n+----------------------------\n+\n+Relative shape IDs are resolved using the following process:\n+\n+#. If a :token:`use_statement` has imported a shape with the same name,\n+   the shape ID resolves to the imported shape ID.\n+#. If a shape is defined in the same namespace as the shape with the same name,\n+   the namespace of the shape resolves to the *current namespace*.\n+#. If a shape is defined in the :ref:`prelude <prelude>` with the same name,\n+   the namespace resolves to ``smithy.api``.\n+#. If a relative shape ID does not satisfy one of the above cases, the shape\n+   ID is invalid, and the namespace is inherited from the *current namespace*.\n+\n+The following example Smithy model contains comments above each member of\n+the shape named ``MyStructure`` that describes the shape the member resolves\n+to.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    use foo.baz#Bar\n+\n+    string MyString\n+\n+    structure MyStructure {\n+        // Resolves to smithy.example#MyString\n+        // There is a shape named MyString defined in the same namespace.\n+        a: MyString,\n+\n+        // Resolves to smithy.example#MyString\n+        // Absolute shape IDs do not perform namespace resolution.\n+        b: smithy.example#MyString,\n+\n+        // Resolves to foo.baz#Bar\n+        // The \"use foo.baz#Bar\" statement imported the Bar symbol,\n+        // allowing the shape to be referenced using a relative shape ID.\n+        c: Bar,\n+\n+        // Resolves to smithy.api#String\n+        // No shape named String was imported through a use statement\n+        // the smithy.example namespace does not contain a shape named\n+        // String, and the prelude model contains a shape named String.\n+        d: String,\n+\n+        // Resolves to smithy.example#MyBoolean.\n+        // There is a shape named MyBoolean defined in the same namespace.\n+        // Forward references are supported both within the same file and\n+        // across multiple files.\n+        e: MyBoolean,\n+\n+        // Resolves to smithy.example#InvalidShape. A shape by this name has\n+        // not been imported through a use statement, a shape by this name\n+        // does not exist in the current namespace, and a shape by this name\n+        // does not exist in the prelude model.\n+        f: InvalidShape,\n+    }\n+\n+    boolean MyBoolean\n+\n+\n+.. _syntactic-shape-ids:\n+\n+Syntactic shape IDs\n+-------------------\n+\n+Unquoted string values that are not object keys in the Smithy IDL are\n+considered lexical shape IDs and are resolved to absolute shape IDs using the\n+process defined in :ref:`relative-shape-id`.\n+\n+The following model defines a list that references a string shape defined\n+in another namespace.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    use smithy.other#MyString\n+\n+    list MyList {\n+        member: MyString\n+    }\n+\n+The above model is equivalent to the following JSON AST model:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"shapes\": {\n+            \"smithy.example#MyList\": {\n+                \"type\": \"list\",\n+                \"members\": {\n+                    \"target\": \"smithy.other#MyString\"\n+                }\n+            }\n+        }\n+    }\n+\n+.. rubric:: Use quotes for literal strings\n+\n+Values that are not meant to be shape IDs MUST be quoted. The following\n+model is syntactically valid but semantically incorrect because\n+it resolves the value of the :ref:`error-trait` to the shape ID\n+``\"smithy.example#client\"`` rather than using the string literal value of\n+``\"client\"``:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    @error(client) // <-- This MUST be \"client\"\n+    structure Error\n+\n+    string client\n+\n+The above example is equivalent to the following incorrect JSON AST:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"shapes\": {\n+            \"smithy.example#Error\": {\n+                \"type\": \"structure\",\n+                \"traits\": {\n+                    \"smithy.api#error\": \"smithy.example#client\"\n+                }\n+            },\n+            \"smithy.example#client\": {\n+                \"type\": \"string\"\n+            }\n+        }\n+    }\n+\n+.. rubric:: Object keys\n+\n+Object keys are not treated as shape IDs. The following example defines a\n+:ref:`metadata <metadata-section>` object, and when loaded into the\n+:ref:`semantic model <semantic-model>`, the object key ``String`` remains\n+the same literal string value of ``String`` while the value is treated as\n+a shape ID and resolves to the string literal ``\"smithy.api#String\"``.\n+\n+.. code-block:: smithy\n+\n+    metadata foo = {\n+        String: String,\n+    }\n+\n+The above example is equivalent to the following JSON AST:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"metadata\": {\n+            \"String\": \"smithy.api#String\"\n+        }\n+    }\n+\n+.. rubric:: Semantic model\n+\n+Syntactic shape IDs are syntactic sugar for defining fully-qualified\n+shape IDs inside of strings, and this difference is inconsequential in the\n+:ref:`semantic model <semantic-model>`. A syntactic shape ID SHOULD be\n+resolved to a string that contains a fully-qualified shape ID when parsing\n+the model.\n+\n+\n+Defining shapes\n+===============\n+\n+Shapes are defined using a :token:`shape_statement`.\n+\n+\n+.. _idl-simple:\n+\n+Simple shapes\n+-------------\n+\n+:ref:`Simple shapes <simple-types>` are defined using a\n+:token:`simple_shape_statement`.\n+\n+The following example defines a ``string`` shape:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#String\": {\n+                    \"type\": \"string\"\n+                }\n+            }\n+        }\n+\n+The following example defines an ``integer`` shape with a :ref:`range-trait`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @range(min: 0, max: 1000)\n+        integer MaxResults\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MaxResults\": {\n+                    \"type\": \"integer\",\n+                    \"traits\": {\n+                        \"smithy.api#range\": {\n+                            \"min\": 0,\n+                            \"max\": 100\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-list:\n+\n+List shapes\n+-----------\n+\n+A :ref:`list <list>` shape is defined using a :token:`list_statement`.\n+\n+The following example defines a list with a string member from the\n+:ref:`prelude <prelude>`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        list MyList {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to the list shape and its member:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @length(min: 3, max: 10)\n+        list MyList {\n+            @length(min: 1, max: 100)\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\",\n+                        \"traits\": {\n+                            \"smithy.api#length\": {\n+                                \"min\": 1,\n+                                \"max\": 100\n+                            }\n+                        }\n+                    },\n+                    \"traits\": {\n+                        \"smithy.api#length\": {\n+                            \"min\": 3,\n+                            \"max\": 10\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-set:\n+\n+Set shapes\n+----------\n+\n+A :ref:`set <set>` set shape is defined using a :token:`set_statement`.\n+\n+The following example defines a set of strings:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        set StringSet {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#StringSet\": {\n+                    \"member\": {", "originalCommit": "ab2e617e464b006292aef001fb460b490077de09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3ODYzMg==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455278632", "bodyText": "Missing a \"type\".", "author": "kstich", "createdAt": "2020-07-15T19:07:01Z", "path": "docs/source/1.0/spec/core/idl.rst", "diffHunk": "@@ -0,0 +1,1886 @@\n+.. _idl:\n+\n+==========\n+Smithy IDL\n+==========\n+\n+Smithy models are defined using either the Smithy interface definition language\n+(IDL) or the :ref:`JSON abstract syntax tree <json-ast>` (AST). This document\n+defines the ABNF_ grammar and syntax for defining models with the Smithy IDL.\n+\n+.. contents:: Table of contents\n+    :depth: 1\n+    :local:\n+    :backlinks: none\n+\n+\n+-------------------\n+Smithy IDL overview\n+-------------------\n+\n+The Smithy IDL is made up of 3, ordered sections, each of which is optional:\n+\n+1. **Control section**; defines parser directives like which version of the\n+   IDL to use.\n+2. **Metadata section**; applies metadata to the entire model.\n+3. **Shape section**; where shapes and traits are defined. A namespace MUST\n+   be defined before any shapes or traits can be defined.\n+   :token:`use_statement`\\s can be defined after a namespace and before shapes\n+   or traits to refer to shapes in other namespaces using a shorter name.\n+\n+The following example defines a model file with each section:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+            // (1) Control section\n+            $version: \"1.0\"\n+\n+            // (2) Metadata section\n+            metadata foo = \"bar\"\n+\n+            // (3) Shape section\n+            namespace smithy.example\n+\n+            use smithy.other.namespace#MyString\n+\n+            structure MyStructure {\n+                @required\n+                foo: MyString\n+            }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"bar\"\n+            },\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.other.namespace#MyString\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+-------------\n+Lexical notes\n+-------------\n+\n+Smithy models MUST be encoded using UTF-8 and SHOULD use Unix style\n+line endings (``\\n``). The Smithy ABNF is whitespace sensitive.\n+\n+\n+.. _smithy-idl-abnf:\n+\n+---------------\n+Smithy IDL ABNF\n+---------------\n+\n+The Smithy IDL is defined by the following ABNF:\n+\n+.. productionlist:: smithy\n+    idl:`ws` `control_section` `metadata_section` `shape_section`\n+\n+.. rubric:: Whitespace\n+\n+.. productionlist:: smithy\n+    ws      :*(`sp` / `newline` / `comment`) ; whitespace\n+    sp      :*(%x20  / %x09) ; \" \" and \\t\n+    br      :`sp` (`comment` / `newline`) `sp` ; break\n+    newline :%x0A / %x0D.0A ; \\n and \\r\\n\n+\n+.. rubric:: Comments\n+\n+.. productionlist:: smithy\n+    comment: `documentation_comment` / `comment`\n+    documentation_comment:\"///\" *`not_newline` `br`\n+    line_comment: \"//\" *`not_newline` `newline`\n+    not_newline: %x09 / %x20-10FFFF ; Any character except newline\n+\n+.. rubric:: Control\n+\n+.. productionlist:: smithy\n+    control_section   :*(`control_statement`)\n+    control_statement :\"$\" `ws` `node_object_key` `ws` \":\" `ws` `node_value` `br`\n+\n+.. rubric:: Metadata\n+\n+.. productionlist:: smithy\n+    metadata_section   :*(`metadata_statement`)\n+    metadata_statement :\"metadata\" `ws` `node_object_key` `ws` \"=\" `ws` `node_value` `br`\n+\n+.. rubric:: Node values\n+\n+.. productionlist:: smithy\n+    node_value :`node_array`\n+               :/ `node_object`\n+               :/ `number`\n+               :/ `node_keywords`\n+               :/ `node_string_value`\n+    node_array          :`empty_node_array` / `populated_node_array`\n+    empty_node_array    :\"[\" `ws` \"]\"\n+    populated_node_array:\"[\" `ws` `node_value` `ws`\n+                        :       *(`comma` `node_value` `ws`)\n+                        :       `trailing_comma` \"]\"\n+    trailing_comma      :[`comma`]\n+    comma               :\",\" `ws`\n+    node_object          :`empty_node_object` / `populated_node_object`\n+    empty_node_object    :\"{\" `ws` \"}\"\n+    populated_node_object:\"{\" `ws` `node_object_kvp` `ws`\n+                         :       *(`comma` `node_object_kvp` `ws`)\n+                         :       `trailing_comma` \"}\"\n+    node_object_kvp      :`node_object_key` `ws` \":\" `ws` `node_value`\n+    node_object_key      :`quoted_text` / `identifier`\n+    number              :[`minus`] `int` [`frac`] [`exp`]\n+    decimal_point       :%x2E ; .\n+    digit1_9            :%x31-39 ; 1-9\n+    e                   :%x65 / %x45 ; e E\n+    exp                 :`e` [`minus` / `plus`] 1*DIGIT\n+    frac                :`decimal_point` 1*DIGIT\n+    int                 :`zero` / (`digit1_9` *DIGIT)\n+    minus               :%x2D ; -\n+    plus                :%x2B ; +\n+    zero                :%x30 ; 0\n+    node_keywords: \"true\" / \"false\" / \"null\"\n+    node_string_value   :`shape_id` / `text_block` / `quoted_text`\n+    quoted_text         :DQUOTE *`quoted_char` DQUOTE\n+    quoted_char         :%x20-21        ; space - \"!\"\n+                        :/ %x23-5B        ; \"#\" - \"[\"\n+                        :/ %x5D-10FFFF    ; \"]\"+\n+                        :/ `escaped_char`\n+                        :/ `preserved_double`\n+    escaped_char        :`escape` (`escape` / \"'\" / DQUOTE / \"b\" / \"f\" / \"n\" / \"r\" / \"t\" / \"/\" / `unicode_escape`)\n+    unicode_escape      :\"u\" `hex` `hex` `hex` `hex`\n+    hex                 : DIGIT / %x41-46 / %x61-66\n+    preserved_double    :`escape` (%x20-21 / %x23-5B / %x5D-10FFFF)\n+    escape              :%x5C ; backslash\n+    text_block          :`three_dquotes` `br` *`quoted_char` `three_dquotes`\n+    three_dquotes       :DQUOTE DQUOTE DQUOTE\n+\n+.. rubric:: Shapes\n+\n+.. productionlist:: smithy\n+    shape_section :[`namespace_statement` [`use_section`] [`shape_statements`]]\n+    namespace_statement :\"namespace\" `ws` `namespace` `br`\n+    use_section   :*(`use_statement`)\n+    use_statement :\"use\" `ws` `absolute_root_shape_id` `br`\n+    shape_statements             :*(`shape_statement` / `apply_statement`)\n+    shape_statement              :`trait_statements` `shape_body` `br`\n+    shape_body                   :`simple_shape_statement`\n+                                 :/ `list_statement`\n+                                 :/ `set_statement`\n+                                 :/ `map_statement`\n+                                 :/ `structure_statement`\n+                                 :/ `union_statement`\n+                                 :/ `service_statement`\n+                                 :/ `operation_statement`\n+                                 :/ `resource_statement`\n+    simple_shape_statement :`simple_type_name` `ws` `identifier`\n+    simple_type_name       :\"blob\" / \"boolean\" / \"document\" / \"string\"\n+                           :/ \"byte\" / \"short\" / \"integer\" / \"long\"\n+                           :/ \"float\" / \"double\" / \"bigInteger\"\n+                           :/ \"bigDecimal\" / \"timestamp\"\n+    shape_members           :`empty_shape_members` / `populated_shape_members`\n+    empty_shape_members     :\"{\" `ws` \"}\"\n+    populated_shape_members :\"{\" `ws` `shape_member_kvp`\n+                            :  *(`comma` `shape_member_kvp` `ws`) `trailing_comma` \"}\"\n+    shape_member_kvp        :`trait_statements` `identifier` `ws` \":\" `ws` `shape_id`\n+    list_statement :\"list\" `ws` `identifier` `ws` `shape_members`\n+    set_statement :\"set\" `ws` `identifier` `ws` `shape_members`\n+    map_statement :\"map\" `ws` `identifier` `ws` `shape_members`\n+    structure_statement     :\"structure\" `ws` `identifier` `ws` `shape_members`\n+    union_statement :\"union\" `ws` `identifier` `ws` `shape_members`\n+    service_statement :\"service\" `ws` `identifier` `ws` `node_object`\n+    operation_statement :\"operation\" `ws` `identifier` `ws` `node_object`\n+    resource_statement :\"resource\" `ws` `identifier` `ws` `node_object`\n+\n+.. rubric:: Traits\n+\n+.. productionlist:: smithy\n+    trait_statements    : *(`ws` `trait`) `ws`\n+    trait               :\"@\" `shape_id` [`trait_body`]\n+    trait_body          :\"(\" `ws` `trait_body_value` `ws` \")\"\n+    trait_body_value    :`trait_structure` / `node_value`\n+    trait_structure     :`trait_structure_kvp` *(`ws` `comma` `trait_structure_kvp`)\n+    trait_structure_kvp :`node_object_key` `ws` \":\" `ws` `node_value`\n+    apply_statement :\"apply\" `ws` `shape_id` `ws` `trait` `br`\n+\n+\n+.. _comments:\n+\n+--------\n+Comments\n+--------\n+\n+A :token:`comment <comment>` can appear at any place between tokens where\n+whitespace (:token:`ws`) can appear. Comments in Smithy are defined using two\n+forward slashes followed by any character. A newline terminates a comment.\n+\n+.. code-block:: smithy\n+\n+    // This is a comment\n+    namespace com.foo // This is also a comment\n+\n+    // Another comment\n+    string MyString\n+\n+.. note::\n+\n+    Three forward slashes can be used to define the documentation of a shape\n+    using a special :ref:`documentation comment <documentation-comment>`.\n+\n+\n+.. _control-statement:\n+\n+---------------\n+Control section\n+---------------\n+\n+The :token:`control section <control_section>` of a model contains\n+:token:`control statements <control_statement>` that apply parser directives\n+to a *specific IDL file*. Because control statements influence parsing, they\n+MUST appear at the beginning of a file before any other statements and have\n+no effect on the :ref:`semantic model <semantic-model>`\n+\n+The :ref:`version <smithy-version>` statement is currently the only control\n+statement defined in the Smithy IDL. Implementations MUST ignore unknown\n+control statements.\n+\n+\n+.. _smithy-version:\n+\n+Version statement\n+=================\n+\n+The Smithy specification is versioned using a ``major`` . ``minor``\n+versioning scheme. A version requirement is specified for a model file using\n+the ``$version`` control statement. When no version number is specified in\n+the IDL, an implementation SHOULD assume that the model can be loaded.\n+Because this can lead to unexpected parsing errors, models SHOULD always\n+include a version.\n+\n+The value provided in a version control statement is a string that MUST\n+adhere to the following ABNF:\n+\n+.. productionlist:: smithy\n+    version_string :1*DIGIT [ \".\" 1*DIGIT ]\n+\n+The following example sets the version to ``1``, meaning that tooling MUST\n+support a version greater than or equal to ``1.0`` and less than ``2.0``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1\"\n+        }\n+\n+A minor version SHOULD be provided when a model depends on a feature released\n+in a minor update of the specification. The following example sets the\n+version requirement of a file to ``1.1``, meaning that tooling MUST support a\n+version greater than or equal to ``1.1`` and less than ``2.0``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1.1\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.1\"\n+        }\n+\n+.. rubric:: Version compatibility\n+\n+A single version statement can appear in a model file, but different versions\n+MAY be encountered when merging multiple model files together. Multiple\n+versions are supported if and only if all of the version statements are\n+supported by the tool loading the models.\n+\n+\n+.. _metadata-section:\n+\n+----------------\n+Metadata section\n+----------------\n+\n+The :token:`metadata section <metadata_section>` is used to apply untyped\n+metadata to the entire model. A :token:`metadata_statement` consists of the\n+metadata key to set, followed by ``=``, followed by the\n+:token:`node value <node_value>` to assign to the key.\n+\n+The following example defines metadata in the model:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        metadata greeting = \"hello\"\n+        metadata \"stringList\" = [\"a\", \"b\", \"c\"]\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"greeting\": \"hello\",\n+                \"stringList\": [\"a\", \"b\", \"c\"]\n+            }\n+        }\n+\n+\n+-------------\n+Shape section\n+-------------\n+\n+The :token:`shape section <shape_section>` of the IDL is used to define\n+shapes and apply traits to shapes.\n+\n+\n+.. _namespaces:\n+\n+Namespaces\n+==========\n+\n+Shapes can only be defined after a namespace is declared. A namespace is\n+declared using a :token:`namespace statement <namespace_statement>`. Only\n+one namespace can appear per file.\n+\n+The following example defines a string shape named ``MyString`` in the\n+``smithy.example`` namespace:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\"\n+                }\n+            }\n+        }\n+\n+\n+.. _use-statement:\n+\n+Referring to shapes\n+===================\n+\n+The :token:`use section <use_section>` of the IDL is used to import shapes\n+into the current namespace so that they can be referred to using a\n+:ref:`relative shape ID <relative-shape-id>`. The :token:`use_statement <use_statement>`\\s\n+that make up this section have no effect on the :ref:`semantic model <semantic-model>`.\n+\n+The following example uses ``smithy.example#Foo`` and ``smithy.example#Baz``\n+so that they can be referred to using only ``Foo`` and ``Baz``.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.hello\n+\n+    use smithy.example#Foo\n+    use smithy.example#Baz\n+\n+    map MyMap {\n+        // Resolves to smithy.example#Foo\n+        key: Foo,\n+        // Resolves to smithy.example#Baz\n+        value: Baz,\n+    }\n+\n+A use statement can refer to :ref:`traits <traits>` too. The following example\n+uses the ``smithy.example#test`` and ``smithy.example#anotherTrait``\n+traits so that they can be applied using relative shape IDs:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.hello\n+\n+    use smithy.example#test\n+    use smithy.example#anotherTrait\n+\n+    @test // <-- Resolves to smithy.example#test\n+    string MyString\n+\n+.. rubric:: Use statement validation\n+\n+#. A shape cannot be defined in a file with the same name as one of the\n+   shapes imported with a ``use`` statement.\n+#. Shapes IDs with members names cannot be imported with a use statement.\n+\n+\n+.. _relative-shape-id:\n+\n+Relative shape ID resolution\n+----------------------------\n+\n+Relative shape IDs are resolved using the following process:\n+\n+#. If a :token:`use_statement` has imported a shape with the same name,\n+   the shape ID resolves to the imported shape ID.\n+#. If a shape is defined in the same namespace as the shape with the same name,\n+   the namespace of the shape resolves to the *current namespace*.\n+#. If a shape is defined in the :ref:`prelude <prelude>` with the same name,\n+   the namespace resolves to ``smithy.api``.\n+#. If a relative shape ID does not satisfy one of the above cases, the shape\n+   ID is invalid, and the namespace is inherited from the *current namespace*.\n+\n+The following example Smithy model contains comments above each member of\n+the shape named ``MyStructure`` that describes the shape the member resolves\n+to.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    use foo.baz#Bar\n+\n+    string MyString\n+\n+    structure MyStructure {\n+        // Resolves to smithy.example#MyString\n+        // There is a shape named MyString defined in the same namespace.\n+        a: MyString,\n+\n+        // Resolves to smithy.example#MyString\n+        // Absolute shape IDs do not perform namespace resolution.\n+        b: smithy.example#MyString,\n+\n+        // Resolves to foo.baz#Bar\n+        // The \"use foo.baz#Bar\" statement imported the Bar symbol,\n+        // allowing the shape to be referenced using a relative shape ID.\n+        c: Bar,\n+\n+        // Resolves to smithy.api#String\n+        // No shape named String was imported through a use statement\n+        // the smithy.example namespace does not contain a shape named\n+        // String, and the prelude model contains a shape named String.\n+        d: String,\n+\n+        // Resolves to smithy.example#MyBoolean.\n+        // There is a shape named MyBoolean defined in the same namespace.\n+        // Forward references are supported both within the same file and\n+        // across multiple files.\n+        e: MyBoolean,\n+\n+        // Resolves to smithy.example#InvalidShape. A shape by this name has\n+        // not been imported through a use statement, a shape by this name\n+        // does not exist in the current namespace, and a shape by this name\n+        // does not exist in the prelude model.\n+        f: InvalidShape,\n+    }\n+\n+    boolean MyBoolean\n+\n+\n+.. _syntactic-shape-ids:\n+\n+Syntactic shape IDs\n+-------------------\n+\n+Unquoted string values that are not object keys in the Smithy IDL are\n+considered lexical shape IDs and are resolved to absolute shape IDs using the\n+process defined in :ref:`relative-shape-id`.\n+\n+The following model defines a list that references a string shape defined\n+in another namespace.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    use smithy.other#MyString\n+\n+    list MyList {\n+        member: MyString\n+    }\n+\n+The above model is equivalent to the following JSON AST model:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"shapes\": {\n+            \"smithy.example#MyList\": {\n+                \"type\": \"list\",\n+                \"members\": {\n+                    \"target\": \"smithy.other#MyString\"\n+                }\n+            }\n+        }\n+    }\n+\n+.. rubric:: Use quotes for literal strings\n+\n+Values that are not meant to be shape IDs MUST be quoted. The following\n+model is syntactically valid but semantically incorrect because\n+it resolves the value of the :ref:`error-trait` to the shape ID\n+``\"smithy.example#client\"`` rather than using the string literal value of\n+``\"client\"``:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    @error(client) // <-- This MUST be \"client\"\n+    structure Error\n+\n+    string client\n+\n+The above example is equivalent to the following incorrect JSON AST:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"shapes\": {\n+            \"smithy.example#Error\": {\n+                \"type\": \"structure\",\n+                \"traits\": {\n+                    \"smithy.api#error\": \"smithy.example#client\"\n+                }\n+            },\n+            \"smithy.example#client\": {\n+                \"type\": \"string\"\n+            }\n+        }\n+    }\n+\n+.. rubric:: Object keys\n+\n+Object keys are not treated as shape IDs. The following example defines a\n+:ref:`metadata <metadata-section>` object, and when loaded into the\n+:ref:`semantic model <semantic-model>`, the object key ``String`` remains\n+the same literal string value of ``String`` while the value is treated as\n+a shape ID and resolves to the string literal ``\"smithy.api#String\"``.\n+\n+.. code-block:: smithy\n+\n+    metadata foo = {\n+        String: String,\n+    }\n+\n+The above example is equivalent to the following JSON AST:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"metadata\": {\n+            \"String\": \"smithy.api#String\"\n+        }\n+    }\n+\n+.. rubric:: Semantic model\n+\n+Syntactic shape IDs are syntactic sugar for defining fully-qualified\n+shape IDs inside of strings, and this difference is inconsequential in the\n+:ref:`semantic model <semantic-model>`. A syntactic shape ID SHOULD be\n+resolved to a string that contains a fully-qualified shape ID when parsing\n+the model.\n+\n+\n+Defining shapes\n+===============\n+\n+Shapes are defined using a :token:`shape_statement`.\n+\n+\n+.. _idl-simple:\n+\n+Simple shapes\n+-------------\n+\n+:ref:`Simple shapes <simple-types>` are defined using a\n+:token:`simple_shape_statement`.\n+\n+The following example defines a ``string`` shape:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#String\": {\n+                    \"type\": \"string\"\n+                }\n+            }\n+        }\n+\n+The following example defines an ``integer`` shape with a :ref:`range-trait`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @range(min: 0, max: 1000)\n+        integer MaxResults\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MaxResults\": {\n+                    \"type\": \"integer\",\n+                    \"traits\": {\n+                        \"smithy.api#range\": {\n+                            \"min\": 0,\n+                            \"max\": 100\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-list:\n+\n+List shapes\n+-----------\n+\n+A :ref:`list <list>` shape is defined using a :token:`list_statement`.\n+\n+The following example defines a list with a string member from the\n+:ref:`prelude <prelude>`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        list MyList {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to the list shape and its member:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @length(min: 3, max: 10)\n+        list MyList {\n+            @length(min: 1, max: 100)\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\",\n+                        \"traits\": {\n+                            \"smithy.api#length\": {\n+                                \"min\": 1,\n+                                \"max\": 100\n+                            }\n+                        }\n+                    },\n+                    \"traits\": {\n+                        \"smithy.api#length\": {\n+                            \"min\": 3,\n+                            \"max\": 10\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-set:\n+\n+Set shapes\n+----------\n+\n+A :ref:`set <set>` set shape is defined using a :token:`set_statement`.\n+\n+The following example defines a set of strings:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        set StringSet {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#StringSet\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to the set shape and its members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @deprecated\n+        set StringSet {\n+            @sensitive\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#StringSet\": {\n+                    \"member\": {", "originalCommit": "ab2e617e464b006292aef001fb460b490077de09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3ODc5NQ==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455278795", "bodyText": "Missing a \"type\".", "author": "kstich", "createdAt": "2020-07-15T19:07:15Z", "path": "docs/source/1.0/spec/core/idl.rst", "diffHunk": "@@ -0,0 +1,1886 @@\n+.. _idl:\n+\n+==========\n+Smithy IDL\n+==========\n+\n+Smithy models are defined using either the Smithy interface definition language\n+(IDL) or the :ref:`JSON abstract syntax tree <json-ast>` (AST). This document\n+defines the ABNF_ grammar and syntax for defining models with the Smithy IDL.\n+\n+.. contents:: Table of contents\n+    :depth: 1\n+    :local:\n+    :backlinks: none\n+\n+\n+-------------------\n+Smithy IDL overview\n+-------------------\n+\n+The Smithy IDL is made up of 3, ordered sections, each of which is optional:\n+\n+1. **Control section**; defines parser directives like which version of the\n+   IDL to use.\n+2. **Metadata section**; applies metadata to the entire model.\n+3. **Shape section**; where shapes and traits are defined. A namespace MUST\n+   be defined before any shapes or traits can be defined.\n+   :token:`use_statement`\\s can be defined after a namespace and before shapes\n+   or traits to refer to shapes in other namespaces using a shorter name.\n+\n+The following example defines a model file with each section:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+            // (1) Control section\n+            $version: \"1.0\"\n+\n+            // (2) Metadata section\n+            metadata foo = \"bar\"\n+\n+            // (3) Shape section\n+            namespace smithy.example\n+\n+            use smithy.other.namespace#MyString\n+\n+            structure MyStructure {\n+                @required\n+                foo: MyString\n+            }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"bar\"\n+            },\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.other.namespace#MyString\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+-------------\n+Lexical notes\n+-------------\n+\n+Smithy models MUST be encoded using UTF-8 and SHOULD use Unix style\n+line endings (``\\n``). The Smithy ABNF is whitespace sensitive.\n+\n+\n+.. _smithy-idl-abnf:\n+\n+---------------\n+Smithy IDL ABNF\n+---------------\n+\n+The Smithy IDL is defined by the following ABNF:\n+\n+.. productionlist:: smithy\n+    idl:`ws` `control_section` `metadata_section` `shape_section`\n+\n+.. rubric:: Whitespace\n+\n+.. productionlist:: smithy\n+    ws      :*(`sp` / `newline` / `comment`) ; whitespace\n+    sp      :*(%x20  / %x09) ; \" \" and \\t\n+    br      :`sp` (`comment` / `newline`) `sp` ; break\n+    newline :%x0A / %x0D.0A ; \\n and \\r\\n\n+\n+.. rubric:: Comments\n+\n+.. productionlist:: smithy\n+    comment: `documentation_comment` / `comment`\n+    documentation_comment:\"///\" *`not_newline` `br`\n+    line_comment: \"//\" *`not_newline` `newline`\n+    not_newline: %x09 / %x20-10FFFF ; Any character except newline\n+\n+.. rubric:: Control\n+\n+.. productionlist:: smithy\n+    control_section   :*(`control_statement`)\n+    control_statement :\"$\" `ws` `node_object_key` `ws` \":\" `ws` `node_value` `br`\n+\n+.. rubric:: Metadata\n+\n+.. productionlist:: smithy\n+    metadata_section   :*(`metadata_statement`)\n+    metadata_statement :\"metadata\" `ws` `node_object_key` `ws` \"=\" `ws` `node_value` `br`\n+\n+.. rubric:: Node values\n+\n+.. productionlist:: smithy\n+    node_value :`node_array`\n+               :/ `node_object`\n+               :/ `number`\n+               :/ `node_keywords`\n+               :/ `node_string_value`\n+    node_array          :`empty_node_array` / `populated_node_array`\n+    empty_node_array    :\"[\" `ws` \"]\"\n+    populated_node_array:\"[\" `ws` `node_value` `ws`\n+                        :       *(`comma` `node_value` `ws`)\n+                        :       `trailing_comma` \"]\"\n+    trailing_comma      :[`comma`]\n+    comma               :\",\" `ws`\n+    node_object          :`empty_node_object` / `populated_node_object`\n+    empty_node_object    :\"{\" `ws` \"}\"\n+    populated_node_object:\"{\" `ws` `node_object_kvp` `ws`\n+                         :       *(`comma` `node_object_kvp` `ws`)\n+                         :       `trailing_comma` \"}\"\n+    node_object_kvp      :`node_object_key` `ws` \":\" `ws` `node_value`\n+    node_object_key      :`quoted_text` / `identifier`\n+    number              :[`minus`] `int` [`frac`] [`exp`]\n+    decimal_point       :%x2E ; .\n+    digit1_9            :%x31-39 ; 1-9\n+    e                   :%x65 / %x45 ; e E\n+    exp                 :`e` [`minus` / `plus`] 1*DIGIT\n+    frac                :`decimal_point` 1*DIGIT\n+    int                 :`zero` / (`digit1_9` *DIGIT)\n+    minus               :%x2D ; -\n+    plus                :%x2B ; +\n+    zero                :%x30 ; 0\n+    node_keywords: \"true\" / \"false\" / \"null\"\n+    node_string_value   :`shape_id` / `text_block` / `quoted_text`\n+    quoted_text         :DQUOTE *`quoted_char` DQUOTE\n+    quoted_char         :%x20-21        ; space - \"!\"\n+                        :/ %x23-5B        ; \"#\" - \"[\"\n+                        :/ %x5D-10FFFF    ; \"]\"+\n+                        :/ `escaped_char`\n+                        :/ `preserved_double`\n+    escaped_char        :`escape` (`escape` / \"'\" / DQUOTE / \"b\" / \"f\" / \"n\" / \"r\" / \"t\" / \"/\" / `unicode_escape`)\n+    unicode_escape      :\"u\" `hex` `hex` `hex` `hex`\n+    hex                 : DIGIT / %x41-46 / %x61-66\n+    preserved_double    :`escape` (%x20-21 / %x23-5B / %x5D-10FFFF)\n+    escape              :%x5C ; backslash\n+    text_block          :`three_dquotes` `br` *`quoted_char` `three_dquotes`\n+    three_dquotes       :DQUOTE DQUOTE DQUOTE\n+\n+.. rubric:: Shapes\n+\n+.. productionlist:: smithy\n+    shape_section :[`namespace_statement` [`use_section`] [`shape_statements`]]\n+    namespace_statement :\"namespace\" `ws` `namespace` `br`\n+    use_section   :*(`use_statement`)\n+    use_statement :\"use\" `ws` `absolute_root_shape_id` `br`\n+    shape_statements             :*(`shape_statement` / `apply_statement`)\n+    shape_statement              :`trait_statements` `shape_body` `br`\n+    shape_body                   :`simple_shape_statement`\n+                                 :/ `list_statement`\n+                                 :/ `set_statement`\n+                                 :/ `map_statement`\n+                                 :/ `structure_statement`\n+                                 :/ `union_statement`\n+                                 :/ `service_statement`\n+                                 :/ `operation_statement`\n+                                 :/ `resource_statement`\n+    simple_shape_statement :`simple_type_name` `ws` `identifier`\n+    simple_type_name       :\"blob\" / \"boolean\" / \"document\" / \"string\"\n+                           :/ \"byte\" / \"short\" / \"integer\" / \"long\"\n+                           :/ \"float\" / \"double\" / \"bigInteger\"\n+                           :/ \"bigDecimal\" / \"timestamp\"\n+    shape_members           :`empty_shape_members` / `populated_shape_members`\n+    empty_shape_members     :\"{\" `ws` \"}\"\n+    populated_shape_members :\"{\" `ws` `shape_member_kvp`\n+                            :  *(`comma` `shape_member_kvp` `ws`) `trailing_comma` \"}\"\n+    shape_member_kvp        :`trait_statements` `identifier` `ws` \":\" `ws` `shape_id`\n+    list_statement :\"list\" `ws` `identifier` `ws` `shape_members`\n+    set_statement :\"set\" `ws` `identifier` `ws` `shape_members`\n+    map_statement :\"map\" `ws` `identifier` `ws` `shape_members`\n+    structure_statement     :\"structure\" `ws` `identifier` `ws` `shape_members`\n+    union_statement :\"union\" `ws` `identifier` `ws` `shape_members`\n+    service_statement :\"service\" `ws` `identifier` `ws` `node_object`\n+    operation_statement :\"operation\" `ws` `identifier` `ws` `node_object`\n+    resource_statement :\"resource\" `ws` `identifier` `ws` `node_object`\n+\n+.. rubric:: Traits\n+\n+.. productionlist:: smithy\n+    trait_statements    : *(`ws` `trait`) `ws`\n+    trait               :\"@\" `shape_id` [`trait_body`]\n+    trait_body          :\"(\" `ws` `trait_body_value` `ws` \")\"\n+    trait_body_value    :`trait_structure` / `node_value`\n+    trait_structure     :`trait_structure_kvp` *(`ws` `comma` `trait_structure_kvp`)\n+    trait_structure_kvp :`node_object_key` `ws` \":\" `ws` `node_value`\n+    apply_statement :\"apply\" `ws` `shape_id` `ws` `trait` `br`\n+\n+\n+.. _comments:\n+\n+--------\n+Comments\n+--------\n+\n+A :token:`comment <comment>` can appear at any place between tokens where\n+whitespace (:token:`ws`) can appear. Comments in Smithy are defined using two\n+forward slashes followed by any character. A newline terminates a comment.\n+\n+.. code-block:: smithy\n+\n+    // This is a comment\n+    namespace com.foo // This is also a comment\n+\n+    // Another comment\n+    string MyString\n+\n+.. note::\n+\n+    Three forward slashes can be used to define the documentation of a shape\n+    using a special :ref:`documentation comment <documentation-comment>`.\n+\n+\n+.. _control-statement:\n+\n+---------------\n+Control section\n+---------------\n+\n+The :token:`control section <control_section>` of a model contains\n+:token:`control statements <control_statement>` that apply parser directives\n+to a *specific IDL file*. Because control statements influence parsing, they\n+MUST appear at the beginning of a file before any other statements and have\n+no effect on the :ref:`semantic model <semantic-model>`\n+\n+The :ref:`version <smithy-version>` statement is currently the only control\n+statement defined in the Smithy IDL. Implementations MUST ignore unknown\n+control statements.\n+\n+\n+.. _smithy-version:\n+\n+Version statement\n+=================\n+\n+The Smithy specification is versioned using a ``major`` . ``minor``\n+versioning scheme. A version requirement is specified for a model file using\n+the ``$version`` control statement. When no version number is specified in\n+the IDL, an implementation SHOULD assume that the model can be loaded.\n+Because this can lead to unexpected parsing errors, models SHOULD always\n+include a version.\n+\n+The value provided in a version control statement is a string that MUST\n+adhere to the following ABNF:\n+\n+.. productionlist:: smithy\n+    version_string :1*DIGIT [ \".\" 1*DIGIT ]\n+\n+The following example sets the version to ``1``, meaning that tooling MUST\n+support a version greater than or equal to ``1.0`` and less than ``2.0``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1\"\n+        }\n+\n+A minor version SHOULD be provided when a model depends on a feature released\n+in a minor update of the specification. The following example sets the\n+version requirement of a file to ``1.1``, meaning that tooling MUST support a\n+version greater than or equal to ``1.1`` and less than ``2.0``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1.1\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.1\"\n+        }\n+\n+.. rubric:: Version compatibility\n+\n+A single version statement can appear in a model file, but different versions\n+MAY be encountered when merging multiple model files together. Multiple\n+versions are supported if and only if all of the version statements are\n+supported by the tool loading the models.\n+\n+\n+.. _metadata-section:\n+\n+----------------\n+Metadata section\n+----------------\n+\n+The :token:`metadata section <metadata_section>` is used to apply untyped\n+metadata to the entire model. A :token:`metadata_statement` consists of the\n+metadata key to set, followed by ``=``, followed by the\n+:token:`node value <node_value>` to assign to the key.\n+\n+The following example defines metadata in the model:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        metadata greeting = \"hello\"\n+        metadata \"stringList\" = [\"a\", \"b\", \"c\"]\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"greeting\": \"hello\",\n+                \"stringList\": [\"a\", \"b\", \"c\"]\n+            }\n+        }\n+\n+\n+-------------\n+Shape section\n+-------------\n+\n+The :token:`shape section <shape_section>` of the IDL is used to define\n+shapes and apply traits to shapes.\n+\n+\n+.. _namespaces:\n+\n+Namespaces\n+==========\n+\n+Shapes can only be defined after a namespace is declared. A namespace is\n+declared using a :token:`namespace statement <namespace_statement>`. Only\n+one namespace can appear per file.\n+\n+The following example defines a string shape named ``MyString`` in the\n+``smithy.example`` namespace:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\"\n+                }\n+            }\n+        }\n+\n+\n+.. _use-statement:\n+\n+Referring to shapes\n+===================\n+\n+The :token:`use section <use_section>` of the IDL is used to import shapes\n+into the current namespace so that they can be referred to using a\n+:ref:`relative shape ID <relative-shape-id>`. The :token:`use_statement <use_statement>`\\s\n+that make up this section have no effect on the :ref:`semantic model <semantic-model>`.\n+\n+The following example uses ``smithy.example#Foo`` and ``smithy.example#Baz``\n+so that they can be referred to using only ``Foo`` and ``Baz``.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.hello\n+\n+    use smithy.example#Foo\n+    use smithy.example#Baz\n+\n+    map MyMap {\n+        // Resolves to smithy.example#Foo\n+        key: Foo,\n+        // Resolves to smithy.example#Baz\n+        value: Baz,\n+    }\n+\n+A use statement can refer to :ref:`traits <traits>` too. The following example\n+uses the ``smithy.example#test`` and ``smithy.example#anotherTrait``\n+traits so that they can be applied using relative shape IDs:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.hello\n+\n+    use smithy.example#test\n+    use smithy.example#anotherTrait\n+\n+    @test // <-- Resolves to smithy.example#test\n+    string MyString\n+\n+.. rubric:: Use statement validation\n+\n+#. A shape cannot be defined in a file with the same name as one of the\n+   shapes imported with a ``use`` statement.\n+#. Shapes IDs with members names cannot be imported with a use statement.\n+\n+\n+.. _relative-shape-id:\n+\n+Relative shape ID resolution\n+----------------------------\n+\n+Relative shape IDs are resolved using the following process:\n+\n+#. If a :token:`use_statement` has imported a shape with the same name,\n+   the shape ID resolves to the imported shape ID.\n+#. If a shape is defined in the same namespace as the shape with the same name,\n+   the namespace of the shape resolves to the *current namespace*.\n+#. If a shape is defined in the :ref:`prelude <prelude>` with the same name,\n+   the namespace resolves to ``smithy.api``.\n+#. If a relative shape ID does not satisfy one of the above cases, the shape\n+   ID is invalid, and the namespace is inherited from the *current namespace*.\n+\n+The following example Smithy model contains comments above each member of\n+the shape named ``MyStructure`` that describes the shape the member resolves\n+to.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    use foo.baz#Bar\n+\n+    string MyString\n+\n+    structure MyStructure {\n+        // Resolves to smithy.example#MyString\n+        // There is a shape named MyString defined in the same namespace.\n+        a: MyString,\n+\n+        // Resolves to smithy.example#MyString\n+        // Absolute shape IDs do not perform namespace resolution.\n+        b: smithy.example#MyString,\n+\n+        // Resolves to foo.baz#Bar\n+        // The \"use foo.baz#Bar\" statement imported the Bar symbol,\n+        // allowing the shape to be referenced using a relative shape ID.\n+        c: Bar,\n+\n+        // Resolves to smithy.api#String\n+        // No shape named String was imported through a use statement\n+        // the smithy.example namespace does not contain a shape named\n+        // String, and the prelude model contains a shape named String.\n+        d: String,\n+\n+        // Resolves to smithy.example#MyBoolean.\n+        // There is a shape named MyBoolean defined in the same namespace.\n+        // Forward references are supported both within the same file and\n+        // across multiple files.\n+        e: MyBoolean,\n+\n+        // Resolves to smithy.example#InvalidShape. A shape by this name has\n+        // not been imported through a use statement, a shape by this name\n+        // does not exist in the current namespace, and a shape by this name\n+        // does not exist in the prelude model.\n+        f: InvalidShape,\n+    }\n+\n+    boolean MyBoolean\n+\n+\n+.. _syntactic-shape-ids:\n+\n+Syntactic shape IDs\n+-------------------\n+\n+Unquoted string values that are not object keys in the Smithy IDL are\n+considered lexical shape IDs and are resolved to absolute shape IDs using the\n+process defined in :ref:`relative-shape-id`.\n+\n+The following model defines a list that references a string shape defined\n+in another namespace.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    use smithy.other#MyString\n+\n+    list MyList {\n+        member: MyString\n+    }\n+\n+The above model is equivalent to the following JSON AST model:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"shapes\": {\n+            \"smithy.example#MyList\": {\n+                \"type\": \"list\",\n+                \"members\": {\n+                    \"target\": \"smithy.other#MyString\"\n+                }\n+            }\n+        }\n+    }\n+\n+.. rubric:: Use quotes for literal strings\n+\n+Values that are not meant to be shape IDs MUST be quoted. The following\n+model is syntactically valid but semantically incorrect because\n+it resolves the value of the :ref:`error-trait` to the shape ID\n+``\"smithy.example#client\"`` rather than using the string literal value of\n+``\"client\"``:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    @error(client) // <-- This MUST be \"client\"\n+    structure Error\n+\n+    string client\n+\n+The above example is equivalent to the following incorrect JSON AST:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"shapes\": {\n+            \"smithy.example#Error\": {\n+                \"type\": \"structure\",\n+                \"traits\": {\n+                    \"smithy.api#error\": \"smithy.example#client\"\n+                }\n+            },\n+            \"smithy.example#client\": {\n+                \"type\": \"string\"\n+            }\n+        }\n+    }\n+\n+.. rubric:: Object keys\n+\n+Object keys are not treated as shape IDs. The following example defines a\n+:ref:`metadata <metadata-section>` object, and when loaded into the\n+:ref:`semantic model <semantic-model>`, the object key ``String`` remains\n+the same literal string value of ``String`` while the value is treated as\n+a shape ID and resolves to the string literal ``\"smithy.api#String\"``.\n+\n+.. code-block:: smithy\n+\n+    metadata foo = {\n+        String: String,\n+    }\n+\n+The above example is equivalent to the following JSON AST:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"metadata\": {\n+            \"String\": \"smithy.api#String\"\n+        }\n+    }\n+\n+.. rubric:: Semantic model\n+\n+Syntactic shape IDs are syntactic sugar for defining fully-qualified\n+shape IDs inside of strings, and this difference is inconsequential in the\n+:ref:`semantic model <semantic-model>`. A syntactic shape ID SHOULD be\n+resolved to a string that contains a fully-qualified shape ID when parsing\n+the model.\n+\n+\n+Defining shapes\n+===============\n+\n+Shapes are defined using a :token:`shape_statement`.\n+\n+\n+.. _idl-simple:\n+\n+Simple shapes\n+-------------\n+\n+:ref:`Simple shapes <simple-types>` are defined using a\n+:token:`simple_shape_statement`.\n+\n+The following example defines a ``string`` shape:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#String\": {\n+                    \"type\": \"string\"\n+                }\n+            }\n+        }\n+\n+The following example defines an ``integer`` shape with a :ref:`range-trait`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @range(min: 0, max: 1000)\n+        integer MaxResults\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MaxResults\": {\n+                    \"type\": \"integer\",\n+                    \"traits\": {\n+                        \"smithy.api#range\": {\n+                            \"min\": 0,\n+                            \"max\": 100\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-list:\n+\n+List shapes\n+-----------\n+\n+A :ref:`list <list>` shape is defined using a :token:`list_statement`.\n+\n+The following example defines a list with a string member from the\n+:ref:`prelude <prelude>`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        list MyList {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to the list shape and its member:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @length(min: 3, max: 10)\n+        list MyList {\n+            @length(min: 1, max: 100)\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\",\n+                        \"traits\": {\n+                            \"smithy.api#length\": {\n+                                \"min\": 1,\n+                                \"max\": 100\n+                            }\n+                        }\n+                    },\n+                    \"traits\": {\n+                        \"smithy.api#length\": {\n+                            \"min\": 3,\n+                            \"max\": 10\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-set:\n+\n+Set shapes\n+----------\n+\n+A :ref:`set <set>` set shape is defined using a :token:`set_statement`.\n+\n+The following example defines a set of strings:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        set StringSet {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#StringSet\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to the set shape and its members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @deprecated\n+        set StringSet {\n+            @sensitive\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#StringSet\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    },\n+                    \"traits\": {\n+                        \"smithy.api#deprecated\": {}\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-map:\n+\n+Map shapes\n+----------\n+\n+A :ref:`map <map>` shape is defined using a :token:`map_statement`.\n+\n+The following example defines a map of strings to integers:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        map IntegerMap {\n+            key: String,\n+            value: Integer\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#IntegerMap\": {\n+                    \"key\": {", "originalCommit": "ab2e617e464b006292aef001fb460b490077de09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3OTM1MA==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455279350", "bodyText": "Missing a \"type\".", "author": "kstich", "createdAt": "2020-07-15T19:08:15Z", "path": "docs/source/1.0/spec/core/idl.rst", "diffHunk": "@@ -0,0 +1,1886 @@\n+.. _idl:\n+\n+==========\n+Smithy IDL\n+==========\n+\n+Smithy models are defined using either the Smithy interface definition language\n+(IDL) or the :ref:`JSON abstract syntax tree <json-ast>` (AST). This document\n+defines the ABNF_ grammar and syntax for defining models with the Smithy IDL.\n+\n+.. contents:: Table of contents\n+    :depth: 1\n+    :local:\n+    :backlinks: none\n+\n+\n+-------------------\n+Smithy IDL overview\n+-------------------\n+\n+The Smithy IDL is made up of 3, ordered sections, each of which is optional:\n+\n+1. **Control section**; defines parser directives like which version of the\n+   IDL to use.\n+2. **Metadata section**; applies metadata to the entire model.\n+3. **Shape section**; where shapes and traits are defined. A namespace MUST\n+   be defined before any shapes or traits can be defined.\n+   :token:`use_statement`\\s can be defined after a namespace and before shapes\n+   or traits to refer to shapes in other namespaces using a shorter name.\n+\n+The following example defines a model file with each section:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+            // (1) Control section\n+            $version: \"1.0\"\n+\n+            // (2) Metadata section\n+            metadata foo = \"bar\"\n+\n+            // (3) Shape section\n+            namespace smithy.example\n+\n+            use smithy.other.namespace#MyString\n+\n+            structure MyStructure {\n+                @required\n+                foo: MyString\n+            }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"bar\"\n+            },\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.other.namespace#MyString\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+-------------\n+Lexical notes\n+-------------\n+\n+Smithy models MUST be encoded using UTF-8 and SHOULD use Unix style\n+line endings (``\\n``). The Smithy ABNF is whitespace sensitive.\n+\n+\n+.. _smithy-idl-abnf:\n+\n+---------------\n+Smithy IDL ABNF\n+---------------\n+\n+The Smithy IDL is defined by the following ABNF:\n+\n+.. productionlist:: smithy\n+    idl:`ws` `control_section` `metadata_section` `shape_section`\n+\n+.. rubric:: Whitespace\n+\n+.. productionlist:: smithy\n+    ws      :*(`sp` / `newline` / `comment`) ; whitespace\n+    sp      :*(%x20  / %x09) ; \" \" and \\t\n+    br      :`sp` (`comment` / `newline`) `sp` ; break\n+    newline :%x0A / %x0D.0A ; \\n and \\r\\n\n+\n+.. rubric:: Comments\n+\n+.. productionlist:: smithy\n+    comment: `documentation_comment` / `comment`\n+    documentation_comment:\"///\" *`not_newline` `br`\n+    line_comment: \"//\" *`not_newline` `newline`\n+    not_newline: %x09 / %x20-10FFFF ; Any character except newline\n+\n+.. rubric:: Control\n+\n+.. productionlist:: smithy\n+    control_section   :*(`control_statement`)\n+    control_statement :\"$\" `ws` `node_object_key` `ws` \":\" `ws` `node_value` `br`\n+\n+.. rubric:: Metadata\n+\n+.. productionlist:: smithy\n+    metadata_section   :*(`metadata_statement`)\n+    metadata_statement :\"metadata\" `ws` `node_object_key` `ws` \"=\" `ws` `node_value` `br`\n+\n+.. rubric:: Node values\n+\n+.. productionlist:: smithy\n+    node_value :`node_array`\n+               :/ `node_object`\n+               :/ `number`\n+               :/ `node_keywords`\n+               :/ `node_string_value`\n+    node_array          :`empty_node_array` / `populated_node_array`\n+    empty_node_array    :\"[\" `ws` \"]\"\n+    populated_node_array:\"[\" `ws` `node_value` `ws`\n+                        :       *(`comma` `node_value` `ws`)\n+                        :       `trailing_comma` \"]\"\n+    trailing_comma      :[`comma`]\n+    comma               :\",\" `ws`\n+    node_object          :`empty_node_object` / `populated_node_object`\n+    empty_node_object    :\"{\" `ws` \"}\"\n+    populated_node_object:\"{\" `ws` `node_object_kvp` `ws`\n+                         :       *(`comma` `node_object_kvp` `ws`)\n+                         :       `trailing_comma` \"}\"\n+    node_object_kvp      :`node_object_key` `ws` \":\" `ws` `node_value`\n+    node_object_key      :`quoted_text` / `identifier`\n+    number              :[`minus`] `int` [`frac`] [`exp`]\n+    decimal_point       :%x2E ; .\n+    digit1_9            :%x31-39 ; 1-9\n+    e                   :%x65 / %x45 ; e E\n+    exp                 :`e` [`minus` / `plus`] 1*DIGIT\n+    frac                :`decimal_point` 1*DIGIT\n+    int                 :`zero` / (`digit1_9` *DIGIT)\n+    minus               :%x2D ; -\n+    plus                :%x2B ; +\n+    zero                :%x30 ; 0\n+    node_keywords: \"true\" / \"false\" / \"null\"\n+    node_string_value   :`shape_id` / `text_block` / `quoted_text`\n+    quoted_text         :DQUOTE *`quoted_char` DQUOTE\n+    quoted_char         :%x20-21        ; space - \"!\"\n+                        :/ %x23-5B        ; \"#\" - \"[\"\n+                        :/ %x5D-10FFFF    ; \"]\"+\n+                        :/ `escaped_char`\n+                        :/ `preserved_double`\n+    escaped_char        :`escape` (`escape` / \"'\" / DQUOTE / \"b\" / \"f\" / \"n\" / \"r\" / \"t\" / \"/\" / `unicode_escape`)\n+    unicode_escape      :\"u\" `hex` `hex` `hex` `hex`\n+    hex                 : DIGIT / %x41-46 / %x61-66\n+    preserved_double    :`escape` (%x20-21 / %x23-5B / %x5D-10FFFF)\n+    escape              :%x5C ; backslash\n+    text_block          :`three_dquotes` `br` *`quoted_char` `three_dquotes`\n+    three_dquotes       :DQUOTE DQUOTE DQUOTE\n+\n+.. rubric:: Shapes\n+\n+.. productionlist:: smithy\n+    shape_section :[`namespace_statement` [`use_section`] [`shape_statements`]]\n+    namespace_statement :\"namespace\" `ws` `namespace` `br`\n+    use_section   :*(`use_statement`)\n+    use_statement :\"use\" `ws` `absolute_root_shape_id` `br`\n+    shape_statements             :*(`shape_statement` / `apply_statement`)\n+    shape_statement              :`trait_statements` `shape_body` `br`\n+    shape_body                   :`simple_shape_statement`\n+                                 :/ `list_statement`\n+                                 :/ `set_statement`\n+                                 :/ `map_statement`\n+                                 :/ `structure_statement`\n+                                 :/ `union_statement`\n+                                 :/ `service_statement`\n+                                 :/ `operation_statement`\n+                                 :/ `resource_statement`\n+    simple_shape_statement :`simple_type_name` `ws` `identifier`\n+    simple_type_name       :\"blob\" / \"boolean\" / \"document\" / \"string\"\n+                           :/ \"byte\" / \"short\" / \"integer\" / \"long\"\n+                           :/ \"float\" / \"double\" / \"bigInteger\"\n+                           :/ \"bigDecimal\" / \"timestamp\"\n+    shape_members           :`empty_shape_members` / `populated_shape_members`\n+    empty_shape_members     :\"{\" `ws` \"}\"\n+    populated_shape_members :\"{\" `ws` `shape_member_kvp`\n+                            :  *(`comma` `shape_member_kvp` `ws`) `trailing_comma` \"}\"\n+    shape_member_kvp        :`trait_statements` `identifier` `ws` \":\" `ws` `shape_id`\n+    list_statement :\"list\" `ws` `identifier` `ws` `shape_members`\n+    set_statement :\"set\" `ws` `identifier` `ws` `shape_members`\n+    map_statement :\"map\" `ws` `identifier` `ws` `shape_members`\n+    structure_statement     :\"structure\" `ws` `identifier` `ws` `shape_members`\n+    union_statement :\"union\" `ws` `identifier` `ws` `shape_members`\n+    service_statement :\"service\" `ws` `identifier` `ws` `node_object`\n+    operation_statement :\"operation\" `ws` `identifier` `ws` `node_object`\n+    resource_statement :\"resource\" `ws` `identifier` `ws` `node_object`\n+\n+.. rubric:: Traits\n+\n+.. productionlist:: smithy\n+    trait_statements    : *(`ws` `trait`) `ws`\n+    trait               :\"@\" `shape_id` [`trait_body`]\n+    trait_body          :\"(\" `ws` `trait_body_value` `ws` \")\"\n+    trait_body_value    :`trait_structure` / `node_value`\n+    trait_structure     :`trait_structure_kvp` *(`ws` `comma` `trait_structure_kvp`)\n+    trait_structure_kvp :`node_object_key` `ws` \":\" `ws` `node_value`\n+    apply_statement :\"apply\" `ws` `shape_id` `ws` `trait` `br`\n+\n+\n+.. _comments:\n+\n+--------\n+Comments\n+--------\n+\n+A :token:`comment <comment>` can appear at any place between tokens where\n+whitespace (:token:`ws`) can appear. Comments in Smithy are defined using two\n+forward slashes followed by any character. A newline terminates a comment.\n+\n+.. code-block:: smithy\n+\n+    // This is a comment\n+    namespace com.foo // This is also a comment\n+\n+    // Another comment\n+    string MyString\n+\n+.. note::\n+\n+    Three forward slashes can be used to define the documentation of a shape\n+    using a special :ref:`documentation comment <documentation-comment>`.\n+\n+\n+.. _control-statement:\n+\n+---------------\n+Control section\n+---------------\n+\n+The :token:`control section <control_section>` of a model contains\n+:token:`control statements <control_statement>` that apply parser directives\n+to a *specific IDL file*. Because control statements influence parsing, they\n+MUST appear at the beginning of a file before any other statements and have\n+no effect on the :ref:`semantic model <semantic-model>`\n+\n+The :ref:`version <smithy-version>` statement is currently the only control\n+statement defined in the Smithy IDL. Implementations MUST ignore unknown\n+control statements.\n+\n+\n+.. _smithy-version:\n+\n+Version statement\n+=================\n+\n+The Smithy specification is versioned using a ``major`` . ``minor``\n+versioning scheme. A version requirement is specified for a model file using\n+the ``$version`` control statement. When no version number is specified in\n+the IDL, an implementation SHOULD assume that the model can be loaded.\n+Because this can lead to unexpected parsing errors, models SHOULD always\n+include a version.\n+\n+The value provided in a version control statement is a string that MUST\n+adhere to the following ABNF:\n+\n+.. productionlist:: smithy\n+    version_string :1*DIGIT [ \".\" 1*DIGIT ]\n+\n+The following example sets the version to ``1``, meaning that tooling MUST\n+support a version greater than or equal to ``1.0`` and less than ``2.0``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1\"\n+        }\n+\n+A minor version SHOULD be provided when a model depends on a feature released\n+in a minor update of the specification. The following example sets the\n+version requirement of a file to ``1.1``, meaning that tooling MUST support a\n+version greater than or equal to ``1.1`` and less than ``2.0``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1.1\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.1\"\n+        }\n+\n+.. rubric:: Version compatibility\n+\n+A single version statement can appear in a model file, but different versions\n+MAY be encountered when merging multiple model files together. Multiple\n+versions are supported if and only if all of the version statements are\n+supported by the tool loading the models.\n+\n+\n+.. _metadata-section:\n+\n+----------------\n+Metadata section\n+----------------\n+\n+The :token:`metadata section <metadata_section>` is used to apply untyped\n+metadata to the entire model. A :token:`metadata_statement` consists of the\n+metadata key to set, followed by ``=``, followed by the\n+:token:`node value <node_value>` to assign to the key.\n+\n+The following example defines metadata in the model:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        metadata greeting = \"hello\"\n+        metadata \"stringList\" = [\"a\", \"b\", \"c\"]\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"greeting\": \"hello\",\n+                \"stringList\": [\"a\", \"b\", \"c\"]\n+            }\n+        }\n+\n+\n+-------------\n+Shape section\n+-------------\n+\n+The :token:`shape section <shape_section>` of the IDL is used to define\n+shapes and apply traits to shapes.\n+\n+\n+.. _namespaces:\n+\n+Namespaces\n+==========\n+\n+Shapes can only be defined after a namespace is declared. A namespace is\n+declared using a :token:`namespace statement <namespace_statement>`. Only\n+one namespace can appear per file.\n+\n+The following example defines a string shape named ``MyString`` in the\n+``smithy.example`` namespace:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\"\n+                }\n+            }\n+        }\n+\n+\n+.. _use-statement:\n+\n+Referring to shapes\n+===================\n+\n+The :token:`use section <use_section>` of the IDL is used to import shapes\n+into the current namespace so that they can be referred to using a\n+:ref:`relative shape ID <relative-shape-id>`. The :token:`use_statement <use_statement>`\\s\n+that make up this section have no effect on the :ref:`semantic model <semantic-model>`.\n+\n+The following example uses ``smithy.example#Foo`` and ``smithy.example#Baz``\n+so that they can be referred to using only ``Foo`` and ``Baz``.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.hello\n+\n+    use smithy.example#Foo\n+    use smithy.example#Baz\n+\n+    map MyMap {\n+        // Resolves to smithy.example#Foo\n+        key: Foo,\n+        // Resolves to smithy.example#Baz\n+        value: Baz,\n+    }\n+\n+A use statement can refer to :ref:`traits <traits>` too. The following example\n+uses the ``smithy.example#test`` and ``smithy.example#anotherTrait``\n+traits so that they can be applied using relative shape IDs:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.hello\n+\n+    use smithy.example#test\n+    use smithy.example#anotherTrait\n+\n+    @test // <-- Resolves to smithy.example#test\n+    string MyString\n+\n+.. rubric:: Use statement validation\n+\n+#. A shape cannot be defined in a file with the same name as one of the\n+   shapes imported with a ``use`` statement.\n+#. Shapes IDs with members names cannot be imported with a use statement.\n+\n+\n+.. _relative-shape-id:\n+\n+Relative shape ID resolution\n+----------------------------\n+\n+Relative shape IDs are resolved using the following process:\n+\n+#. If a :token:`use_statement` has imported a shape with the same name,\n+   the shape ID resolves to the imported shape ID.\n+#. If a shape is defined in the same namespace as the shape with the same name,\n+   the namespace of the shape resolves to the *current namespace*.\n+#. If a shape is defined in the :ref:`prelude <prelude>` with the same name,\n+   the namespace resolves to ``smithy.api``.\n+#. If a relative shape ID does not satisfy one of the above cases, the shape\n+   ID is invalid, and the namespace is inherited from the *current namespace*.\n+\n+The following example Smithy model contains comments above each member of\n+the shape named ``MyStructure`` that describes the shape the member resolves\n+to.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    use foo.baz#Bar\n+\n+    string MyString\n+\n+    structure MyStructure {\n+        // Resolves to smithy.example#MyString\n+        // There is a shape named MyString defined in the same namespace.\n+        a: MyString,\n+\n+        // Resolves to smithy.example#MyString\n+        // Absolute shape IDs do not perform namespace resolution.\n+        b: smithy.example#MyString,\n+\n+        // Resolves to foo.baz#Bar\n+        // The \"use foo.baz#Bar\" statement imported the Bar symbol,\n+        // allowing the shape to be referenced using a relative shape ID.\n+        c: Bar,\n+\n+        // Resolves to smithy.api#String\n+        // No shape named String was imported through a use statement\n+        // the smithy.example namespace does not contain a shape named\n+        // String, and the prelude model contains a shape named String.\n+        d: String,\n+\n+        // Resolves to smithy.example#MyBoolean.\n+        // There is a shape named MyBoolean defined in the same namespace.\n+        // Forward references are supported both within the same file and\n+        // across multiple files.\n+        e: MyBoolean,\n+\n+        // Resolves to smithy.example#InvalidShape. A shape by this name has\n+        // not been imported through a use statement, a shape by this name\n+        // does not exist in the current namespace, and a shape by this name\n+        // does not exist in the prelude model.\n+        f: InvalidShape,\n+    }\n+\n+    boolean MyBoolean\n+\n+\n+.. _syntactic-shape-ids:\n+\n+Syntactic shape IDs\n+-------------------\n+\n+Unquoted string values that are not object keys in the Smithy IDL are\n+considered lexical shape IDs and are resolved to absolute shape IDs using the\n+process defined in :ref:`relative-shape-id`.\n+\n+The following model defines a list that references a string shape defined\n+in another namespace.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    use smithy.other#MyString\n+\n+    list MyList {\n+        member: MyString\n+    }\n+\n+The above model is equivalent to the following JSON AST model:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"shapes\": {\n+            \"smithy.example#MyList\": {\n+                \"type\": \"list\",\n+                \"members\": {\n+                    \"target\": \"smithy.other#MyString\"\n+                }\n+            }\n+        }\n+    }\n+\n+.. rubric:: Use quotes for literal strings\n+\n+Values that are not meant to be shape IDs MUST be quoted. The following\n+model is syntactically valid but semantically incorrect because\n+it resolves the value of the :ref:`error-trait` to the shape ID\n+``\"smithy.example#client\"`` rather than using the string literal value of\n+``\"client\"``:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    @error(client) // <-- This MUST be \"client\"\n+    structure Error\n+\n+    string client\n+\n+The above example is equivalent to the following incorrect JSON AST:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"shapes\": {\n+            \"smithy.example#Error\": {\n+                \"type\": \"structure\",\n+                \"traits\": {\n+                    \"smithy.api#error\": \"smithy.example#client\"\n+                }\n+            },\n+            \"smithy.example#client\": {\n+                \"type\": \"string\"\n+            }\n+        }\n+    }\n+\n+.. rubric:: Object keys\n+\n+Object keys are not treated as shape IDs. The following example defines a\n+:ref:`metadata <metadata-section>` object, and when loaded into the\n+:ref:`semantic model <semantic-model>`, the object key ``String`` remains\n+the same literal string value of ``String`` while the value is treated as\n+a shape ID and resolves to the string literal ``\"smithy.api#String\"``.\n+\n+.. code-block:: smithy\n+\n+    metadata foo = {\n+        String: String,\n+    }\n+\n+The above example is equivalent to the following JSON AST:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"metadata\": {\n+            \"String\": \"smithy.api#String\"\n+        }\n+    }\n+\n+.. rubric:: Semantic model\n+\n+Syntactic shape IDs are syntactic sugar for defining fully-qualified\n+shape IDs inside of strings, and this difference is inconsequential in the\n+:ref:`semantic model <semantic-model>`. A syntactic shape ID SHOULD be\n+resolved to a string that contains a fully-qualified shape ID when parsing\n+the model.\n+\n+\n+Defining shapes\n+===============\n+\n+Shapes are defined using a :token:`shape_statement`.\n+\n+\n+.. _idl-simple:\n+\n+Simple shapes\n+-------------\n+\n+:ref:`Simple shapes <simple-types>` are defined using a\n+:token:`simple_shape_statement`.\n+\n+The following example defines a ``string`` shape:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#String\": {\n+                    \"type\": \"string\"\n+                }\n+            }\n+        }\n+\n+The following example defines an ``integer`` shape with a :ref:`range-trait`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @range(min: 0, max: 1000)\n+        integer MaxResults\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MaxResults\": {\n+                    \"type\": \"integer\",\n+                    \"traits\": {\n+                        \"smithy.api#range\": {\n+                            \"min\": 0,\n+                            \"max\": 100\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-list:\n+\n+List shapes\n+-----------\n+\n+A :ref:`list <list>` shape is defined using a :token:`list_statement`.\n+\n+The following example defines a list with a string member from the\n+:ref:`prelude <prelude>`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        list MyList {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to the list shape and its member:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @length(min: 3, max: 10)\n+        list MyList {\n+            @length(min: 1, max: 100)\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\",\n+                        \"traits\": {\n+                            \"smithy.api#length\": {\n+                                \"min\": 1,\n+                                \"max\": 100\n+                            }\n+                        }\n+                    },\n+                    \"traits\": {\n+                        \"smithy.api#length\": {\n+                            \"min\": 3,\n+                            \"max\": 10\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-set:\n+\n+Set shapes\n+----------\n+\n+A :ref:`set <set>` set shape is defined using a :token:`set_statement`.\n+\n+The following example defines a set of strings:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        set StringSet {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#StringSet\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to the set shape and its members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @deprecated\n+        set StringSet {\n+            @sensitive\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#StringSet\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    },\n+                    \"traits\": {\n+                        \"smithy.api#deprecated\": {}\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-map:\n+\n+Map shapes\n+----------\n+\n+A :ref:`map <map>` shape is defined using a :token:`map_statement`.\n+\n+The following example defines a map of strings to integers:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        map IntegerMap {\n+            key: String,\n+            value: Integer\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#IntegerMap\": {\n+                    \"key\": {\n+                        \"target\": \"smithy.api#String\"\n+                    },\n+                    \"value\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to the map shape and its members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @length(min: 0, max: 100)\n+        map IntegerMap {\n+            @length(min: 1, max: 10)\n+            key: String,\n+\n+            @sensitive\n+            value: Integer\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#IntegerMap\": {\n+                    \"key\": {", "originalCommit": "ab2e617e464b006292aef001fb460b490077de09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3OTQyNg==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455279426", "bodyText": "Missing a \"type\".", "author": "kstich", "createdAt": "2020-07-15T19:08:25Z", "path": "docs/source/1.0/spec/core/idl.rst", "diffHunk": "@@ -0,0 +1,1886 @@\n+.. _idl:\n+\n+==========\n+Smithy IDL\n+==========\n+\n+Smithy models are defined using either the Smithy interface definition language\n+(IDL) or the :ref:`JSON abstract syntax tree <json-ast>` (AST). This document\n+defines the ABNF_ grammar and syntax for defining models with the Smithy IDL.\n+\n+.. contents:: Table of contents\n+    :depth: 1\n+    :local:\n+    :backlinks: none\n+\n+\n+-------------------\n+Smithy IDL overview\n+-------------------\n+\n+The Smithy IDL is made up of 3, ordered sections, each of which is optional:\n+\n+1. **Control section**; defines parser directives like which version of the\n+   IDL to use.\n+2. **Metadata section**; applies metadata to the entire model.\n+3. **Shape section**; where shapes and traits are defined. A namespace MUST\n+   be defined before any shapes or traits can be defined.\n+   :token:`use_statement`\\s can be defined after a namespace and before shapes\n+   or traits to refer to shapes in other namespaces using a shorter name.\n+\n+The following example defines a model file with each section:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+            // (1) Control section\n+            $version: \"1.0\"\n+\n+            // (2) Metadata section\n+            metadata foo = \"bar\"\n+\n+            // (3) Shape section\n+            namespace smithy.example\n+\n+            use smithy.other.namespace#MyString\n+\n+            structure MyStructure {\n+                @required\n+                foo: MyString\n+            }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"bar\"\n+            },\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.other.namespace#MyString\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+-------------\n+Lexical notes\n+-------------\n+\n+Smithy models MUST be encoded using UTF-8 and SHOULD use Unix style\n+line endings (``\\n``). The Smithy ABNF is whitespace sensitive.\n+\n+\n+.. _smithy-idl-abnf:\n+\n+---------------\n+Smithy IDL ABNF\n+---------------\n+\n+The Smithy IDL is defined by the following ABNF:\n+\n+.. productionlist:: smithy\n+    idl:`ws` `control_section` `metadata_section` `shape_section`\n+\n+.. rubric:: Whitespace\n+\n+.. productionlist:: smithy\n+    ws      :*(`sp` / `newline` / `comment`) ; whitespace\n+    sp      :*(%x20  / %x09) ; \" \" and \\t\n+    br      :`sp` (`comment` / `newline`) `sp` ; break\n+    newline :%x0A / %x0D.0A ; \\n and \\r\\n\n+\n+.. rubric:: Comments\n+\n+.. productionlist:: smithy\n+    comment: `documentation_comment` / `comment`\n+    documentation_comment:\"///\" *`not_newline` `br`\n+    line_comment: \"//\" *`not_newline` `newline`\n+    not_newline: %x09 / %x20-10FFFF ; Any character except newline\n+\n+.. rubric:: Control\n+\n+.. productionlist:: smithy\n+    control_section   :*(`control_statement`)\n+    control_statement :\"$\" `ws` `node_object_key` `ws` \":\" `ws` `node_value` `br`\n+\n+.. rubric:: Metadata\n+\n+.. productionlist:: smithy\n+    metadata_section   :*(`metadata_statement`)\n+    metadata_statement :\"metadata\" `ws` `node_object_key` `ws` \"=\" `ws` `node_value` `br`\n+\n+.. rubric:: Node values\n+\n+.. productionlist:: smithy\n+    node_value :`node_array`\n+               :/ `node_object`\n+               :/ `number`\n+               :/ `node_keywords`\n+               :/ `node_string_value`\n+    node_array          :`empty_node_array` / `populated_node_array`\n+    empty_node_array    :\"[\" `ws` \"]\"\n+    populated_node_array:\"[\" `ws` `node_value` `ws`\n+                        :       *(`comma` `node_value` `ws`)\n+                        :       `trailing_comma` \"]\"\n+    trailing_comma      :[`comma`]\n+    comma               :\",\" `ws`\n+    node_object          :`empty_node_object` / `populated_node_object`\n+    empty_node_object    :\"{\" `ws` \"}\"\n+    populated_node_object:\"{\" `ws` `node_object_kvp` `ws`\n+                         :       *(`comma` `node_object_kvp` `ws`)\n+                         :       `trailing_comma` \"}\"\n+    node_object_kvp      :`node_object_key` `ws` \":\" `ws` `node_value`\n+    node_object_key      :`quoted_text` / `identifier`\n+    number              :[`minus`] `int` [`frac`] [`exp`]\n+    decimal_point       :%x2E ; .\n+    digit1_9            :%x31-39 ; 1-9\n+    e                   :%x65 / %x45 ; e E\n+    exp                 :`e` [`minus` / `plus`] 1*DIGIT\n+    frac                :`decimal_point` 1*DIGIT\n+    int                 :`zero` / (`digit1_9` *DIGIT)\n+    minus               :%x2D ; -\n+    plus                :%x2B ; +\n+    zero                :%x30 ; 0\n+    node_keywords: \"true\" / \"false\" / \"null\"\n+    node_string_value   :`shape_id` / `text_block` / `quoted_text`\n+    quoted_text         :DQUOTE *`quoted_char` DQUOTE\n+    quoted_char         :%x20-21        ; space - \"!\"\n+                        :/ %x23-5B        ; \"#\" - \"[\"\n+                        :/ %x5D-10FFFF    ; \"]\"+\n+                        :/ `escaped_char`\n+                        :/ `preserved_double`\n+    escaped_char        :`escape` (`escape` / \"'\" / DQUOTE / \"b\" / \"f\" / \"n\" / \"r\" / \"t\" / \"/\" / `unicode_escape`)\n+    unicode_escape      :\"u\" `hex` `hex` `hex` `hex`\n+    hex                 : DIGIT / %x41-46 / %x61-66\n+    preserved_double    :`escape` (%x20-21 / %x23-5B / %x5D-10FFFF)\n+    escape              :%x5C ; backslash\n+    text_block          :`three_dquotes` `br` *`quoted_char` `three_dquotes`\n+    three_dquotes       :DQUOTE DQUOTE DQUOTE\n+\n+.. rubric:: Shapes\n+\n+.. productionlist:: smithy\n+    shape_section :[`namespace_statement` [`use_section`] [`shape_statements`]]\n+    namespace_statement :\"namespace\" `ws` `namespace` `br`\n+    use_section   :*(`use_statement`)\n+    use_statement :\"use\" `ws` `absolute_root_shape_id` `br`\n+    shape_statements             :*(`shape_statement` / `apply_statement`)\n+    shape_statement              :`trait_statements` `shape_body` `br`\n+    shape_body                   :`simple_shape_statement`\n+                                 :/ `list_statement`\n+                                 :/ `set_statement`\n+                                 :/ `map_statement`\n+                                 :/ `structure_statement`\n+                                 :/ `union_statement`\n+                                 :/ `service_statement`\n+                                 :/ `operation_statement`\n+                                 :/ `resource_statement`\n+    simple_shape_statement :`simple_type_name` `ws` `identifier`\n+    simple_type_name       :\"blob\" / \"boolean\" / \"document\" / \"string\"\n+                           :/ \"byte\" / \"short\" / \"integer\" / \"long\"\n+                           :/ \"float\" / \"double\" / \"bigInteger\"\n+                           :/ \"bigDecimal\" / \"timestamp\"\n+    shape_members           :`empty_shape_members` / `populated_shape_members`\n+    empty_shape_members     :\"{\" `ws` \"}\"\n+    populated_shape_members :\"{\" `ws` `shape_member_kvp`\n+                            :  *(`comma` `shape_member_kvp` `ws`) `trailing_comma` \"}\"\n+    shape_member_kvp        :`trait_statements` `identifier` `ws` \":\" `ws` `shape_id`\n+    list_statement :\"list\" `ws` `identifier` `ws` `shape_members`\n+    set_statement :\"set\" `ws` `identifier` `ws` `shape_members`\n+    map_statement :\"map\" `ws` `identifier` `ws` `shape_members`\n+    structure_statement     :\"structure\" `ws` `identifier` `ws` `shape_members`\n+    union_statement :\"union\" `ws` `identifier` `ws` `shape_members`\n+    service_statement :\"service\" `ws` `identifier` `ws` `node_object`\n+    operation_statement :\"operation\" `ws` `identifier` `ws` `node_object`\n+    resource_statement :\"resource\" `ws` `identifier` `ws` `node_object`\n+\n+.. rubric:: Traits\n+\n+.. productionlist:: smithy\n+    trait_statements    : *(`ws` `trait`) `ws`\n+    trait               :\"@\" `shape_id` [`trait_body`]\n+    trait_body          :\"(\" `ws` `trait_body_value` `ws` \")\"\n+    trait_body_value    :`trait_structure` / `node_value`\n+    trait_structure     :`trait_structure_kvp` *(`ws` `comma` `trait_structure_kvp`)\n+    trait_structure_kvp :`node_object_key` `ws` \":\" `ws` `node_value`\n+    apply_statement :\"apply\" `ws` `shape_id` `ws` `trait` `br`\n+\n+\n+.. _comments:\n+\n+--------\n+Comments\n+--------\n+\n+A :token:`comment <comment>` can appear at any place between tokens where\n+whitespace (:token:`ws`) can appear. Comments in Smithy are defined using two\n+forward slashes followed by any character. A newline terminates a comment.\n+\n+.. code-block:: smithy\n+\n+    // This is a comment\n+    namespace com.foo // This is also a comment\n+\n+    // Another comment\n+    string MyString\n+\n+.. note::\n+\n+    Three forward slashes can be used to define the documentation of a shape\n+    using a special :ref:`documentation comment <documentation-comment>`.\n+\n+\n+.. _control-statement:\n+\n+---------------\n+Control section\n+---------------\n+\n+The :token:`control section <control_section>` of a model contains\n+:token:`control statements <control_statement>` that apply parser directives\n+to a *specific IDL file*. Because control statements influence parsing, they\n+MUST appear at the beginning of a file before any other statements and have\n+no effect on the :ref:`semantic model <semantic-model>`\n+\n+The :ref:`version <smithy-version>` statement is currently the only control\n+statement defined in the Smithy IDL. Implementations MUST ignore unknown\n+control statements.\n+\n+\n+.. _smithy-version:\n+\n+Version statement\n+=================\n+\n+The Smithy specification is versioned using a ``major`` . ``minor``\n+versioning scheme. A version requirement is specified for a model file using\n+the ``$version`` control statement. When no version number is specified in\n+the IDL, an implementation SHOULD assume that the model can be loaded.\n+Because this can lead to unexpected parsing errors, models SHOULD always\n+include a version.\n+\n+The value provided in a version control statement is a string that MUST\n+adhere to the following ABNF:\n+\n+.. productionlist:: smithy\n+    version_string :1*DIGIT [ \".\" 1*DIGIT ]\n+\n+The following example sets the version to ``1``, meaning that tooling MUST\n+support a version greater than or equal to ``1.0`` and less than ``2.0``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1\"\n+        }\n+\n+A minor version SHOULD be provided when a model depends on a feature released\n+in a minor update of the specification. The following example sets the\n+version requirement of a file to ``1.1``, meaning that tooling MUST support a\n+version greater than or equal to ``1.1`` and less than ``2.0``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1.1\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.1\"\n+        }\n+\n+.. rubric:: Version compatibility\n+\n+A single version statement can appear in a model file, but different versions\n+MAY be encountered when merging multiple model files together. Multiple\n+versions are supported if and only if all of the version statements are\n+supported by the tool loading the models.\n+\n+\n+.. _metadata-section:\n+\n+----------------\n+Metadata section\n+----------------\n+\n+The :token:`metadata section <metadata_section>` is used to apply untyped\n+metadata to the entire model. A :token:`metadata_statement` consists of the\n+metadata key to set, followed by ``=``, followed by the\n+:token:`node value <node_value>` to assign to the key.\n+\n+The following example defines metadata in the model:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        metadata greeting = \"hello\"\n+        metadata \"stringList\" = [\"a\", \"b\", \"c\"]\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"greeting\": \"hello\",\n+                \"stringList\": [\"a\", \"b\", \"c\"]\n+            }\n+        }\n+\n+\n+-------------\n+Shape section\n+-------------\n+\n+The :token:`shape section <shape_section>` of the IDL is used to define\n+shapes and apply traits to shapes.\n+\n+\n+.. _namespaces:\n+\n+Namespaces\n+==========\n+\n+Shapes can only be defined after a namespace is declared. A namespace is\n+declared using a :token:`namespace statement <namespace_statement>`. Only\n+one namespace can appear per file.\n+\n+The following example defines a string shape named ``MyString`` in the\n+``smithy.example`` namespace:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\"\n+                }\n+            }\n+        }\n+\n+\n+.. _use-statement:\n+\n+Referring to shapes\n+===================\n+\n+The :token:`use section <use_section>` of the IDL is used to import shapes\n+into the current namespace so that they can be referred to using a\n+:ref:`relative shape ID <relative-shape-id>`. The :token:`use_statement <use_statement>`\\s\n+that make up this section have no effect on the :ref:`semantic model <semantic-model>`.\n+\n+The following example uses ``smithy.example#Foo`` and ``smithy.example#Baz``\n+so that they can be referred to using only ``Foo`` and ``Baz``.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.hello\n+\n+    use smithy.example#Foo\n+    use smithy.example#Baz\n+\n+    map MyMap {\n+        // Resolves to smithy.example#Foo\n+        key: Foo,\n+        // Resolves to smithy.example#Baz\n+        value: Baz,\n+    }\n+\n+A use statement can refer to :ref:`traits <traits>` too. The following example\n+uses the ``smithy.example#test`` and ``smithy.example#anotherTrait``\n+traits so that they can be applied using relative shape IDs:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.hello\n+\n+    use smithy.example#test\n+    use smithy.example#anotherTrait\n+\n+    @test // <-- Resolves to smithy.example#test\n+    string MyString\n+\n+.. rubric:: Use statement validation\n+\n+#. A shape cannot be defined in a file with the same name as one of the\n+   shapes imported with a ``use`` statement.\n+#. Shapes IDs with members names cannot be imported with a use statement.\n+\n+\n+.. _relative-shape-id:\n+\n+Relative shape ID resolution\n+----------------------------\n+\n+Relative shape IDs are resolved using the following process:\n+\n+#. If a :token:`use_statement` has imported a shape with the same name,\n+   the shape ID resolves to the imported shape ID.\n+#. If a shape is defined in the same namespace as the shape with the same name,\n+   the namespace of the shape resolves to the *current namespace*.\n+#. If a shape is defined in the :ref:`prelude <prelude>` with the same name,\n+   the namespace resolves to ``smithy.api``.\n+#. If a relative shape ID does not satisfy one of the above cases, the shape\n+   ID is invalid, and the namespace is inherited from the *current namespace*.\n+\n+The following example Smithy model contains comments above each member of\n+the shape named ``MyStructure`` that describes the shape the member resolves\n+to.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    use foo.baz#Bar\n+\n+    string MyString\n+\n+    structure MyStructure {\n+        // Resolves to smithy.example#MyString\n+        // There is a shape named MyString defined in the same namespace.\n+        a: MyString,\n+\n+        // Resolves to smithy.example#MyString\n+        // Absolute shape IDs do not perform namespace resolution.\n+        b: smithy.example#MyString,\n+\n+        // Resolves to foo.baz#Bar\n+        // The \"use foo.baz#Bar\" statement imported the Bar symbol,\n+        // allowing the shape to be referenced using a relative shape ID.\n+        c: Bar,\n+\n+        // Resolves to smithy.api#String\n+        // No shape named String was imported through a use statement\n+        // the smithy.example namespace does not contain a shape named\n+        // String, and the prelude model contains a shape named String.\n+        d: String,\n+\n+        // Resolves to smithy.example#MyBoolean.\n+        // There is a shape named MyBoolean defined in the same namespace.\n+        // Forward references are supported both within the same file and\n+        // across multiple files.\n+        e: MyBoolean,\n+\n+        // Resolves to smithy.example#InvalidShape. A shape by this name has\n+        // not been imported through a use statement, a shape by this name\n+        // does not exist in the current namespace, and a shape by this name\n+        // does not exist in the prelude model.\n+        f: InvalidShape,\n+    }\n+\n+    boolean MyBoolean\n+\n+\n+.. _syntactic-shape-ids:\n+\n+Syntactic shape IDs\n+-------------------\n+\n+Unquoted string values that are not object keys in the Smithy IDL are\n+considered lexical shape IDs and are resolved to absolute shape IDs using the\n+process defined in :ref:`relative-shape-id`.\n+\n+The following model defines a list that references a string shape defined\n+in another namespace.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    use smithy.other#MyString\n+\n+    list MyList {\n+        member: MyString\n+    }\n+\n+The above model is equivalent to the following JSON AST model:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"shapes\": {\n+            \"smithy.example#MyList\": {\n+                \"type\": \"list\",\n+                \"members\": {\n+                    \"target\": \"smithy.other#MyString\"\n+                }\n+            }\n+        }\n+    }\n+\n+.. rubric:: Use quotes for literal strings\n+\n+Values that are not meant to be shape IDs MUST be quoted. The following\n+model is syntactically valid but semantically incorrect because\n+it resolves the value of the :ref:`error-trait` to the shape ID\n+``\"smithy.example#client\"`` rather than using the string literal value of\n+``\"client\"``:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    @error(client) // <-- This MUST be \"client\"\n+    structure Error\n+\n+    string client\n+\n+The above example is equivalent to the following incorrect JSON AST:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"shapes\": {\n+            \"smithy.example#Error\": {\n+                \"type\": \"structure\",\n+                \"traits\": {\n+                    \"smithy.api#error\": \"smithy.example#client\"\n+                }\n+            },\n+            \"smithy.example#client\": {\n+                \"type\": \"string\"\n+            }\n+        }\n+    }\n+\n+.. rubric:: Object keys\n+\n+Object keys are not treated as shape IDs. The following example defines a\n+:ref:`metadata <metadata-section>` object, and when loaded into the\n+:ref:`semantic model <semantic-model>`, the object key ``String`` remains\n+the same literal string value of ``String`` while the value is treated as\n+a shape ID and resolves to the string literal ``\"smithy.api#String\"``.\n+\n+.. code-block:: smithy\n+\n+    metadata foo = {\n+        String: String,\n+    }\n+\n+The above example is equivalent to the following JSON AST:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"metadata\": {\n+            \"String\": \"smithy.api#String\"\n+        }\n+    }\n+\n+.. rubric:: Semantic model\n+\n+Syntactic shape IDs are syntactic sugar for defining fully-qualified\n+shape IDs inside of strings, and this difference is inconsequential in the\n+:ref:`semantic model <semantic-model>`. A syntactic shape ID SHOULD be\n+resolved to a string that contains a fully-qualified shape ID when parsing\n+the model.\n+\n+\n+Defining shapes\n+===============\n+\n+Shapes are defined using a :token:`shape_statement`.\n+\n+\n+.. _idl-simple:\n+\n+Simple shapes\n+-------------\n+\n+:ref:`Simple shapes <simple-types>` are defined using a\n+:token:`simple_shape_statement`.\n+\n+The following example defines a ``string`` shape:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#String\": {\n+                    \"type\": \"string\"\n+                }\n+            }\n+        }\n+\n+The following example defines an ``integer`` shape with a :ref:`range-trait`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @range(min: 0, max: 1000)\n+        integer MaxResults\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MaxResults\": {\n+                    \"type\": \"integer\",\n+                    \"traits\": {\n+                        \"smithy.api#range\": {\n+                            \"min\": 0,\n+                            \"max\": 100\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-list:\n+\n+List shapes\n+-----------\n+\n+A :ref:`list <list>` shape is defined using a :token:`list_statement`.\n+\n+The following example defines a list with a string member from the\n+:ref:`prelude <prelude>`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        list MyList {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {", "originalCommit": "ab2e617e464b006292aef001fb460b490077de09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI4NzU3NA==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455287574", "bodyText": "This written definition doesn't include a \":\" for separating keys from their values.", "author": "kstich", "createdAt": "2020-07-15T19:23:24Z", "path": "docs/source/1.0/spec/core/idl.rst", "diffHunk": "@@ -0,0 +1,1886 @@\n+.. _idl:\n+\n+==========\n+Smithy IDL\n+==========\n+\n+Smithy models are defined using either the Smithy interface definition language\n+(IDL) or the :ref:`JSON abstract syntax tree <json-ast>` (AST). This document\n+defines the ABNF_ grammar and syntax for defining models with the Smithy IDL.\n+\n+.. contents:: Table of contents\n+    :depth: 1\n+    :local:\n+    :backlinks: none\n+\n+\n+-------------------\n+Smithy IDL overview\n+-------------------\n+\n+The Smithy IDL is made up of 3, ordered sections, each of which is optional:\n+\n+1. **Control section**; defines parser directives like which version of the\n+   IDL to use.\n+2. **Metadata section**; applies metadata to the entire model.\n+3. **Shape section**; where shapes and traits are defined. A namespace MUST\n+   be defined before any shapes or traits can be defined.\n+   :token:`use_statement`\\s can be defined after a namespace and before shapes\n+   or traits to refer to shapes in other namespaces using a shorter name.\n+\n+The following example defines a model file with each section:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+            // (1) Control section\n+            $version: \"1.0\"\n+\n+            // (2) Metadata section\n+            metadata foo = \"bar\"\n+\n+            // (3) Shape section\n+            namespace smithy.example\n+\n+            use smithy.other.namespace#MyString\n+\n+            structure MyStructure {\n+                @required\n+                foo: MyString\n+            }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"bar\"\n+            },\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.other.namespace#MyString\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+-------------\n+Lexical notes\n+-------------\n+\n+Smithy models MUST be encoded using UTF-8 and SHOULD use Unix style\n+line endings (``\\n``). The Smithy ABNF is whitespace sensitive.\n+\n+\n+.. _smithy-idl-abnf:\n+\n+---------------\n+Smithy IDL ABNF\n+---------------\n+\n+The Smithy IDL is defined by the following ABNF:\n+\n+.. productionlist:: smithy\n+    idl:`ws` `control_section` `metadata_section` `shape_section`\n+\n+.. rubric:: Whitespace\n+\n+.. productionlist:: smithy\n+    ws      :*(`sp` / `newline` / `comment`) ; whitespace\n+    sp      :*(%x20  / %x09) ; \" \" and \\t\n+    br      :`sp` (`comment` / `newline`) `sp` ; break\n+    newline :%x0A / %x0D.0A ; \\n and \\r\\n\n+\n+.. rubric:: Comments\n+\n+.. productionlist:: smithy\n+    comment: `documentation_comment` / `comment`\n+    documentation_comment:\"///\" *`not_newline` `br`\n+    line_comment: \"//\" *`not_newline` `newline`\n+    not_newline: %x09 / %x20-10FFFF ; Any character except newline\n+\n+.. rubric:: Control\n+\n+.. productionlist:: smithy\n+    control_section   :*(`control_statement`)\n+    control_statement :\"$\" `ws` `node_object_key` `ws` \":\" `ws` `node_value` `br`\n+\n+.. rubric:: Metadata\n+\n+.. productionlist:: smithy\n+    metadata_section   :*(`metadata_statement`)\n+    metadata_statement :\"metadata\" `ws` `node_object_key` `ws` \"=\" `ws` `node_value` `br`\n+\n+.. rubric:: Node values\n+\n+.. productionlist:: smithy\n+    node_value :`node_array`\n+               :/ `node_object`\n+               :/ `number`\n+               :/ `node_keywords`\n+               :/ `node_string_value`\n+    node_array          :`empty_node_array` / `populated_node_array`\n+    empty_node_array    :\"[\" `ws` \"]\"\n+    populated_node_array:\"[\" `ws` `node_value` `ws`\n+                        :       *(`comma` `node_value` `ws`)\n+                        :       `trailing_comma` \"]\"\n+    trailing_comma      :[`comma`]\n+    comma               :\",\" `ws`\n+    node_object          :`empty_node_object` / `populated_node_object`\n+    empty_node_object    :\"{\" `ws` \"}\"\n+    populated_node_object:\"{\" `ws` `node_object_kvp` `ws`\n+                         :       *(`comma` `node_object_kvp` `ws`)\n+                         :       `trailing_comma` \"}\"\n+    node_object_kvp      :`node_object_key` `ws` \":\" `ws` `node_value`\n+    node_object_key      :`quoted_text` / `identifier`\n+    number              :[`minus`] `int` [`frac`] [`exp`]\n+    decimal_point       :%x2E ; .\n+    digit1_9            :%x31-39 ; 1-9\n+    e                   :%x65 / %x45 ; e E\n+    exp                 :`e` [`minus` / `plus`] 1*DIGIT\n+    frac                :`decimal_point` 1*DIGIT\n+    int                 :`zero` / (`digit1_9` *DIGIT)\n+    minus               :%x2D ; -\n+    plus                :%x2B ; +\n+    zero                :%x30 ; 0\n+    node_keywords: \"true\" / \"false\" / \"null\"\n+    node_string_value   :`shape_id` / `text_block` / `quoted_text`\n+    quoted_text         :DQUOTE *`quoted_char` DQUOTE\n+    quoted_char         :%x20-21        ; space - \"!\"\n+                        :/ %x23-5B        ; \"#\" - \"[\"\n+                        :/ %x5D-10FFFF    ; \"]\"+\n+                        :/ `escaped_char`\n+                        :/ `preserved_double`\n+    escaped_char        :`escape` (`escape` / \"'\" / DQUOTE / \"b\" / \"f\" / \"n\" / \"r\" / \"t\" / \"/\" / `unicode_escape`)\n+    unicode_escape      :\"u\" `hex` `hex` `hex` `hex`\n+    hex                 : DIGIT / %x41-46 / %x61-66\n+    preserved_double    :`escape` (%x20-21 / %x23-5B / %x5D-10FFFF)\n+    escape              :%x5C ; backslash\n+    text_block          :`three_dquotes` `br` *`quoted_char` `three_dquotes`\n+    three_dquotes       :DQUOTE DQUOTE DQUOTE\n+\n+.. rubric:: Shapes\n+\n+.. productionlist:: smithy\n+    shape_section :[`namespace_statement` [`use_section`] [`shape_statements`]]\n+    namespace_statement :\"namespace\" `ws` `namespace` `br`\n+    use_section   :*(`use_statement`)\n+    use_statement :\"use\" `ws` `absolute_root_shape_id` `br`\n+    shape_statements             :*(`shape_statement` / `apply_statement`)\n+    shape_statement              :`trait_statements` `shape_body` `br`\n+    shape_body                   :`simple_shape_statement`\n+                                 :/ `list_statement`\n+                                 :/ `set_statement`\n+                                 :/ `map_statement`\n+                                 :/ `structure_statement`\n+                                 :/ `union_statement`\n+                                 :/ `service_statement`\n+                                 :/ `operation_statement`\n+                                 :/ `resource_statement`\n+    simple_shape_statement :`simple_type_name` `ws` `identifier`\n+    simple_type_name       :\"blob\" / \"boolean\" / \"document\" / \"string\"\n+                           :/ \"byte\" / \"short\" / \"integer\" / \"long\"\n+                           :/ \"float\" / \"double\" / \"bigInteger\"\n+                           :/ \"bigDecimal\" / \"timestamp\"\n+    shape_members           :`empty_shape_members` / `populated_shape_members`\n+    empty_shape_members     :\"{\" `ws` \"}\"\n+    populated_shape_members :\"{\" `ws` `shape_member_kvp`\n+                            :  *(`comma` `shape_member_kvp` `ws`) `trailing_comma` \"}\"\n+    shape_member_kvp        :`trait_statements` `identifier` `ws` \":\" `ws` `shape_id`\n+    list_statement :\"list\" `ws` `identifier` `ws` `shape_members`\n+    set_statement :\"set\" `ws` `identifier` `ws` `shape_members`\n+    map_statement :\"map\" `ws` `identifier` `ws` `shape_members`\n+    structure_statement     :\"structure\" `ws` `identifier` `ws` `shape_members`\n+    union_statement :\"union\" `ws` `identifier` `ws` `shape_members`\n+    service_statement :\"service\" `ws` `identifier` `ws` `node_object`\n+    operation_statement :\"operation\" `ws` `identifier` `ws` `node_object`\n+    resource_statement :\"resource\" `ws` `identifier` `ws` `node_object`\n+\n+.. rubric:: Traits\n+\n+.. productionlist:: smithy\n+    trait_statements    : *(`ws` `trait`) `ws`\n+    trait               :\"@\" `shape_id` [`trait_body`]\n+    trait_body          :\"(\" `ws` `trait_body_value` `ws` \")\"\n+    trait_body_value    :`trait_structure` / `node_value`\n+    trait_structure     :`trait_structure_kvp` *(`ws` `comma` `trait_structure_kvp`)\n+    trait_structure_kvp :`node_object_key` `ws` \":\" `ws` `node_value`\n+    apply_statement :\"apply\" `ws` `shape_id` `ws` `trait` `br`\n+\n+\n+.. _comments:\n+\n+--------\n+Comments\n+--------\n+\n+A :token:`comment <comment>` can appear at any place between tokens where\n+whitespace (:token:`ws`) can appear. Comments in Smithy are defined using two\n+forward slashes followed by any character. A newline terminates a comment.\n+\n+.. code-block:: smithy\n+\n+    // This is a comment\n+    namespace com.foo // This is also a comment\n+\n+    // Another comment\n+    string MyString\n+\n+.. note::\n+\n+    Three forward slashes can be used to define the documentation of a shape\n+    using a special :ref:`documentation comment <documentation-comment>`.\n+\n+\n+.. _control-statement:\n+\n+---------------\n+Control section\n+---------------\n+\n+The :token:`control section <control_section>` of a model contains\n+:token:`control statements <control_statement>` that apply parser directives\n+to a *specific IDL file*. Because control statements influence parsing, they\n+MUST appear at the beginning of a file before any other statements and have\n+no effect on the :ref:`semantic model <semantic-model>`\n+\n+The :ref:`version <smithy-version>` statement is currently the only control\n+statement defined in the Smithy IDL. Implementations MUST ignore unknown\n+control statements.\n+\n+\n+.. _smithy-version:\n+\n+Version statement\n+=================\n+\n+The Smithy specification is versioned using a ``major`` . ``minor``\n+versioning scheme. A version requirement is specified for a model file using\n+the ``$version`` control statement. When no version number is specified in\n+the IDL, an implementation SHOULD assume that the model can be loaded.\n+Because this can lead to unexpected parsing errors, models SHOULD always\n+include a version.\n+\n+The value provided in a version control statement is a string that MUST\n+adhere to the following ABNF:\n+\n+.. productionlist:: smithy\n+    version_string :1*DIGIT [ \".\" 1*DIGIT ]\n+\n+The following example sets the version to ``1``, meaning that tooling MUST\n+support a version greater than or equal to ``1.0`` and less than ``2.0``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1\"\n+        }\n+\n+A minor version SHOULD be provided when a model depends on a feature released\n+in a minor update of the specification. The following example sets the\n+version requirement of a file to ``1.1``, meaning that tooling MUST support a\n+version greater than or equal to ``1.1`` and less than ``2.0``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1.1\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.1\"\n+        }\n+\n+.. rubric:: Version compatibility\n+\n+A single version statement can appear in a model file, but different versions\n+MAY be encountered when merging multiple model files together. Multiple\n+versions are supported if and only if all of the version statements are\n+supported by the tool loading the models.\n+\n+\n+.. _metadata-section:\n+\n+----------------\n+Metadata section\n+----------------\n+\n+The :token:`metadata section <metadata_section>` is used to apply untyped\n+metadata to the entire model. A :token:`metadata_statement` consists of the\n+metadata key to set, followed by ``=``, followed by the\n+:token:`node value <node_value>` to assign to the key.\n+\n+The following example defines metadata in the model:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        metadata greeting = \"hello\"\n+        metadata \"stringList\" = [\"a\", \"b\", \"c\"]\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"greeting\": \"hello\",\n+                \"stringList\": [\"a\", \"b\", \"c\"]\n+            }\n+        }\n+\n+\n+-------------\n+Shape section\n+-------------\n+\n+The :token:`shape section <shape_section>` of the IDL is used to define\n+shapes and apply traits to shapes.\n+\n+\n+.. _namespaces:\n+\n+Namespaces\n+==========\n+\n+Shapes can only be defined after a namespace is declared. A namespace is\n+declared using a :token:`namespace statement <namespace_statement>`. Only\n+one namespace can appear per file.\n+\n+The following example defines a string shape named ``MyString`` in the\n+``smithy.example`` namespace:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\"\n+                }\n+            }\n+        }\n+\n+\n+.. _use-statement:\n+\n+Referring to shapes\n+===================\n+\n+The :token:`use section <use_section>` of the IDL is used to import shapes\n+into the current namespace so that they can be referred to using a\n+:ref:`relative shape ID <relative-shape-id>`. The :token:`use_statement <use_statement>`\\s\n+that make up this section have no effect on the :ref:`semantic model <semantic-model>`.\n+\n+The following example uses ``smithy.example#Foo`` and ``smithy.example#Baz``\n+so that they can be referred to using only ``Foo`` and ``Baz``.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.hello\n+\n+    use smithy.example#Foo\n+    use smithy.example#Baz\n+\n+    map MyMap {\n+        // Resolves to smithy.example#Foo\n+        key: Foo,\n+        // Resolves to smithy.example#Baz\n+        value: Baz,\n+    }\n+\n+A use statement can refer to :ref:`traits <traits>` too. The following example\n+uses the ``smithy.example#test`` and ``smithy.example#anotherTrait``\n+traits so that they can be applied using relative shape IDs:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.hello\n+\n+    use smithy.example#test\n+    use smithy.example#anotherTrait\n+\n+    @test // <-- Resolves to smithy.example#test\n+    string MyString\n+\n+.. rubric:: Use statement validation\n+\n+#. A shape cannot be defined in a file with the same name as one of the\n+   shapes imported with a ``use`` statement.\n+#. Shapes IDs with members names cannot be imported with a use statement.\n+\n+\n+.. _relative-shape-id:\n+\n+Relative shape ID resolution\n+----------------------------\n+\n+Relative shape IDs are resolved using the following process:\n+\n+#. If a :token:`use_statement` has imported a shape with the same name,\n+   the shape ID resolves to the imported shape ID.\n+#. If a shape is defined in the same namespace as the shape with the same name,\n+   the namespace of the shape resolves to the *current namespace*.\n+#. If a shape is defined in the :ref:`prelude <prelude>` with the same name,\n+   the namespace resolves to ``smithy.api``.\n+#. If a relative shape ID does not satisfy one of the above cases, the shape\n+   ID is invalid, and the namespace is inherited from the *current namespace*.\n+\n+The following example Smithy model contains comments above each member of\n+the shape named ``MyStructure`` that describes the shape the member resolves\n+to.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    use foo.baz#Bar\n+\n+    string MyString\n+\n+    structure MyStructure {\n+        // Resolves to smithy.example#MyString\n+        // There is a shape named MyString defined in the same namespace.\n+        a: MyString,\n+\n+        // Resolves to smithy.example#MyString\n+        // Absolute shape IDs do not perform namespace resolution.\n+        b: smithy.example#MyString,\n+\n+        // Resolves to foo.baz#Bar\n+        // The \"use foo.baz#Bar\" statement imported the Bar symbol,\n+        // allowing the shape to be referenced using a relative shape ID.\n+        c: Bar,\n+\n+        // Resolves to smithy.api#String\n+        // No shape named String was imported through a use statement\n+        // the smithy.example namespace does not contain a shape named\n+        // String, and the prelude model contains a shape named String.\n+        d: String,\n+\n+        // Resolves to smithy.example#MyBoolean.\n+        // There is a shape named MyBoolean defined in the same namespace.\n+        // Forward references are supported both within the same file and\n+        // across multiple files.\n+        e: MyBoolean,\n+\n+        // Resolves to smithy.example#InvalidShape. A shape by this name has\n+        // not been imported through a use statement, a shape by this name\n+        // does not exist in the current namespace, and a shape by this name\n+        // does not exist in the prelude model.\n+        f: InvalidShape,\n+    }\n+\n+    boolean MyBoolean\n+\n+\n+.. _syntactic-shape-ids:\n+\n+Syntactic shape IDs\n+-------------------\n+\n+Unquoted string values that are not object keys in the Smithy IDL are\n+considered lexical shape IDs and are resolved to absolute shape IDs using the\n+process defined in :ref:`relative-shape-id`.\n+\n+The following model defines a list that references a string shape defined\n+in another namespace.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    use smithy.other#MyString\n+\n+    list MyList {\n+        member: MyString\n+    }\n+\n+The above model is equivalent to the following JSON AST model:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"shapes\": {\n+            \"smithy.example#MyList\": {\n+                \"type\": \"list\",\n+                \"members\": {\n+                    \"target\": \"smithy.other#MyString\"\n+                }\n+            }\n+        }\n+    }\n+\n+.. rubric:: Use quotes for literal strings\n+\n+Values that are not meant to be shape IDs MUST be quoted. The following\n+model is syntactically valid but semantically incorrect because\n+it resolves the value of the :ref:`error-trait` to the shape ID\n+``\"smithy.example#client\"`` rather than using the string literal value of\n+``\"client\"``:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    @error(client) // <-- This MUST be \"client\"\n+    structure Error\n+\n+    string client\n+\n+The above example is equivalent to the following incorrect JSON AST:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"shapes\": {\n+            \"smithy.example#Error\": {\n+                \"type\": \"structure\",\n+                \"traits\": {\n+                    \"smithy.api#error\": \"smithy.example#client\"\n+                }\n+            },\n+            \"smithy.example#client\": {\n+                \"type\": \"string\"\n+            }\n+        }\n+    }\n+\n+.. rubric:: Object keys\n+\n+Object keys are not treated as shape IDs. The following example defines a\n+:ref:`metadata <metadata-section>` object, and when loaded into the\n+:ref:`semantic model <semantic-model>`, the object key ``String`` remains\n+the same literal string value of ``String`` while the value is treated as\n+a shape ID and resolves to the string literal ``\"smithy.api#String\"``.\n+\n+.. code-block:: smithy\n+\n+    metadata foo = {\n+        String: String,\n+    }\n+\n+The above example is equivalent to the following JSON AST:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"metadata\": {\n+            \"String\": \"smithy.api#String\"\n+        }\n+    }\n+\n+.. rubric:: Semantic model\n+\n+Syntactic shape IDs are syntactic sugar for defining fully-qualified\n+shape IDs inside of strings, and this difference is inconsequential in the\n+:ref:`semantic model <semantic-model>`. A syntactic shape ID SHOULD be\n+resolved to a string that contains a fully-qualified shape ID when parsing\n+the model.\n+\n+\n+Defining shapes\n+===============\n+\n+Shapes are defined using a :token:`shape_statement`.\n+\n+\n+.. _idl-simple:\n+\n+Simple shapes\n+-------------\n+\n+:ref:`Simple shapes <simple-types>` are defined using a\n+:token:`simple_shape_statement`.\n+\n+The following example defines a ``string`` shape:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#String\": {\n+                    \"type\": \"string\"\n+                }\n+            }\n+        }\n+\n+The following example defines an ``integer`` shape with a :ref:`range-trait`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @range(min: 0, max: 1000)\n+        integer MaxResults\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MaxResults\": {\n+                    \"type\": \"integer\",\n+                    \"traits\": {\n+                        \"smithy.api#range\": {\n+                            \"min\": 0,\n+                            \"max\": 100\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-list:\n+\n+List shapes\n+-----------\n+\n+A :ref:`list <list>` shape is defined using a :token:`list_statement`.\n+\n+The following example defines a list with a string member from the\n+:ref:`prelude <prelude>`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        list MyList {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to the list shape and its member:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @length(min: 3, max: 10)\n+        list MyList {\n+            @length(min: 1, max: 100)\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\",\n+                        \"traits\": {\n+                            \"smithy.api#length\": {\n+                                \"min\": 1,\n+                                \"max\": 100\n+                            }\n+                        }\n+                    },\n+                    \"traits\": {\n+                        \"smithy.api#length\": {\n+                            \"min\": 3,\n+                            \"max\": 10\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-set:\n+\n+Set shapes\n+----------\n+\n+A :ref:`set <set>` set shape is defined using a :token:`set_statement`.\n+\n+The following example defines a set of strings:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        set StringSet {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#StringSet\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to the set shape and its members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @deprecated\n+        set StringSet {\n+            @sensitive\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#StringSet\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    },\n+                    \"traits\": {\n+                        \"smithy.api#deprecated\": {}\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-map:\n+\n+Map shapes\n+----------\n+\n+A :ref:`map <map>` shape is defined using a :token:`map_statement`.\n+\n+The following example defines a map of strings to integers:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        map IntegerMap {\n+            key: String,\n+            value: Integer\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#IntegerMap\": {\n+                    \"key\": {\n+                        \"target\": \"smithy.api#String\"\n+                    },\n+                    \"value\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to the map shape and its members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @length(min: 0, max: 100)\n+        map IntegerMap {\n+            @length(min: 1, max: 10)\n+            key: String,\n+\n+            @sensitive\n+            value: Integer\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#IntegerMap\": {\n+                    \"key\": {\n+                        \"target\": \"smithy.api#String\",\n+                        \"traits\": {\n+                            \"smithy.api#length\": {\n+                                \"min\": 1,\n+                                \"max\": 10\n+                            }\n+                        }\n+                    },\n+                    \"value\": {\n+                        \"target\": \"smithy.api#String\",\n+                        \"traits\": {\n+                            \"smithy.api#sensitive\": {}\n+                        }\n+                    },\n+                    \"traits\": {\n+                        \"smithy.api#length\": {\n+                            \"min\": 0,\n+                            \"max\": 100\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-structure:\n+\n+Structure shapes\n+----------------\n+\n+A :ref:`structure <structure>` shape is defined using a\n+:token:`structure_statement`.\n+\n+The following example defines a structure with two members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        structure MyStructure {\n+            foo: String,\n+            baz: Integer,\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.api#String\"\n+                        },\n+                        \"baz\": {\n+                            \"target\": \"smithy.api#Integer\"\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to structure members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        /// This is MyStructure.\n+        structure MyStructure {\n+            /// This is documentation for `foo`.\n+            @required\n+            foo: String,\n+\n+            /// This is documentation for `baz`.\n+            @deprecated\n+            baz: Integer,\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.api#String\",\n+                            \"traits\": {\n+                                \"smithy.api#documentation\": \"This is documentation for `foo`.\",\n+                                \"smithy.api#required\": {}\n+                            }\n+                        },\n+                        \"baz\": {\n+                            \"target\": \"smithy.api#Integer\",\n+                            \"traits\": {\n+                                \"smithy.api#documentation\": \"This is documentation for `baz`.\",\n+                                \"smithy.api#deprecated\": {}\n+                            }\n+                        }\n+                    },\n+                    \"traits\": {\n+                        \"smithy.api#documentation\": \"This is MyStructure.\"\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-union:\n+\n+Union shapes\n+------------\n+\n+A :ref:`union <union>` shape is defined using a :token:`union_statement`.\n+\n+The following example defines a union shape with several members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        union MyUnion {\n+            i32: Integer,\n+\n+            stringA: String,\n+\n+            @sensitive\n+            stringB: String,\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyUnion\": {\n+                    \"type\": \"union\",\n+                    \"members\": {\n+                        \"i32\": {\n+                            \"target\": \"smithy.api#Integer\"\n+                        },\n+                        \"stringA\": {\n+                            \"target\": \"smithy.api#String\"\n+                        },\n+                        \"stringB\": {\n+                            \"target\": \"smithy.api#String\",\n+                            \"traits\": {\n+                                \"smithy.api#sensitive\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-service:\n+\n+Service shape\n+-------------\n+\n+A service shape is defined using a :token:`service_statement` and the provided\n+:token:`node_object` supports the same properties defined in the\n+:ref:`service specification <service>`.\n+\n+The following example defines a service named ``ModelRepository`` that binds\n+a resource named ``Model`` and an operation named ``PingService``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        service ModelRepository {\n+            version: \"2020-07-13\",\n+            resources: [Model],\n+            operations: [PingService]\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#ModelRepository\": {\n+                    \"type\": \"service\",\n+                    \"resources\": [\n+                        {\n+                            \"target\": \"smithy.example#Model\"\n+                        }\n+                    ],\n+                    \"operations\": [\n+                        {\n+                            \"target\": \"smithy.example#PingService\"\n+                        }\n+                    ]\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-operation:\n+\n+Operation shape\n+---------------\n+\n+An operation shape is defined using an :token:`operation_statement` and the\n+provided :token:`node_object` supports the same properties defined in the\n+:ref:`operation specification <operation>`.\n+\n+The following example defines an operation shape that accepts an input\n+structure named ``Input``, returns an output structure named ``Output``, and\n+can potentially return the ``Unavailable`` or ``BadRequest``\n+:ref:`error structures <error-trait>`.\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        operation PingService {\n+            input: Input,\n+            output: Output,\n+            errors: [Unavailable, BadRequest]\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#PingService\": {\n+                    \"type\": \"operation\",\n+                    \"input\": {\n+                        \"target\": \"smithy.example#Input\"\n+                    },\n+                    \"output\": {\n+                        \"target\": \"smithy.example#Output\"\n+                    },\n+                    \"errors\": [\n+                        {\n+                            \"target\": \"smithy.example#Unavailable\"\n+                        },\n+                        {\n+                            \"target\": \"smithy.example#BadRequest\"\n+                        }\n+                    ]\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-resource:\n+\n+Resource shape\n+--------------\n+\n+A resource shape is defined using a :token:`resource_statement` and the\n+provided :token:`node_object` supports the same properties defined in the\n+:ref:`resource specification <resource>`.\n+\n+The following example defines a resource shape that has a single identifier,\n+and defines a :ref:`read <read-lifecycle>` operation:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        resource Model {\n+            identifiers: {\n+                modelId: String,\n+            },\n+            read: GetModel,\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#Model\": {\n+                    \"type\": \"resource\",\n+                    \"identifiers\": {\n+                        \"modelId\": {\n+                            \"target\": \"smithy.api#String\"\n+                        }\n+                    },\n+                    \"read\": {\n+                        \"target\": \"smithy.example#GetModel\"\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _documentation-comment:\n+\n+Documentation comment\n+=====================\n+\n+:token:`Documentation comments <documentation_comment>` are a special kind of :token:`comment` that provide\n+:ref:`documentation <documentation-trait>` for shapes. A documentation\n+comment is formed when three forward slashes (``\"///\"``) appear as the\n+first non-whitespace characters on a line.\n+\n+Documentation comments are defined using CommonMark_. The text after the\n+forward slashes is considered the contents of the line. If the text starts\n+with a space (\" \"), the leading space is removed from the content.\n+Successive documentation comments are combined together using a newline\n+(\"\\\\n\") to form the documentation of a shape.\n+\n+The following Smithy IDL example,\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    /// This is documentation about a shape.\n+    ///\n+    /// - This is a list\n+    /// - More of the list.\n+    string MyString\n+\n+    /// This is documentation about a trait shape.\n+    ///   More docs here.\n+    @trait\n+    structure myTrait {}\n+\n+is equivalent to the following JSON AST model:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"shapes\": {\n+            \"smithy.example#MyString\": {\n+                \"type\": \"string\",\n+                \"traits\": {\n+                    \"smithy.api#documentation\": \"This is documentation about a shape.\\n\\n- This is a list\\n- More of the list.\"\n+                }\n+            },\n+            \"smithy.example#myTrait\": {\n+                \"type\": \"structure\",\n+                \"traits\": {\n+                    \"smithy.api#trait\": {},\n+                    \"smithy.api#documentation\": \"This is documentation about a trait shapes.\\n  More docs here.\"\n+                }\n+            }\n+        }\n+    }\n+\n+.. rubric:: Placement\n+\n+Documentation comments are only treated as shape documentation when the\n+comment appears immediately before a shape, and documentation comments MUST\n+appear **before** any :ref:`traits <traits>` applied to the shape in order\n+for the documentation to be applied to a shape.\n+\n+The following example applies a documentation trait to the shape because the\n+documentation comment comes before the traits applied to a shape:\n+\n+.. code-block:: smithy\n+\n+    /// A deprecated string.\n+    @deprecated\n+    string MyString\n+\n+Documentation comments can also be applied to members of a shape.\n+\n+.. code-block:: smithy\n+\n+    /// Documentation about the structure.\n+    structure Example {\n+        /// Documentation about the member.\n+        @sensitive\n+        foo: String,\n+    }\n+\n+.. rubric:: Semantic model\n+\n+Documentation comments are syntactic sugar equivalent to applying the\n+:ref:`documentation-trait`, and this difference is inconsequential\n+in the :ref:`semantic model <semantic-model>`.\n+\n+\n+.. _idl-applying-traits:\n+\n+Applying traits\n+===============\n+\n+Trait values immediately preceding a shape definition are applied to the\n+shape. The shape ID of a trait is *resolved* against :token:`use_statement`\\s\n+and the current namespace in exactly the same same way as\n+:ref:`other shape IDs <relative-shape-id>`.\n+\n+The following example applies the :ref:`sensitive-trait` and\n+:ref:`documentation-trait` to ``MyString``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @sensitive\n+        @documentation(\"Contains a string\")\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#documentation\": \"Contains a string\",\n+                        \"smithy.api#sensitive\": {}\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _trait-values:\n+\n+Trait values\n+------------\n+\n+The value that can be provided for a trait depends on its type. A value for a\n+trait is defined by enclosing the value in parenthesis. Trait values can only\n+appear immediately before a shape.\n+\n+The following example applies various traits to a structure shape and its\n+members.\n+\n+.. code-block:: smithy\n+\n+    @documentation(\"An animal in the animal kingdom\")\n+    structure Animal {\n+        @required\n+        name: smithy.api#String,\n+\n+        @length(min: 0)\n+        @tags([\"internal\"])\n+        age: smithy.api#Integer,\n+    }\n+\n+\n+Structure, map, and union trait values\n+--------------------------------------\n+\n+Traits that are a ``structure``, ``union``, or ``map`` are defined using\n+a special syntax that places key-value pairs inside of the trait\n+parenthesis. Wrapping braces, \"{\" and \"}\", are not permitted.\n+\n+.. code-block:: smithy\n+\n+    @structuredTrait(foo: \"bar\", baz: \"bam\")\n+\n+Nested structure, map, and union values are defined using\n+:ref:`node value <node-values>` productions:\n+\n+.. code-block:: smithy\n+\n+    @structuredTrait(\n+        foo: {\n+            bar: \"baz\",\n+            qux: \"true\",\n+        }\n+    )\n+\n+Omitting a value is allowed on ``list``, ``set``, ``map``, and ``structure``\n+traits if the shapes have no ``length`` constraints or ``required`` members.\n+The following applications of the ``foo`` trait are equivalent:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @trait\n+        structure foo {}\n+\n+        @foo\n+        string MyString1\n+\n+        @foo()\n+        string MyString2\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#foo\": {\n+                    \"type\": \"structure\",\n+                    \"traits\": {\n+                        \"smithy.api#trait\": {}\n+                    }\n+                },\n+                \"smithy.example#MyString1\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#foo\": {}\n+                    }\n+                },\n+                \"smithy.example#MyString2\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#foo\": {}\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+List and set trait values\n+-------------------------\n+\n+Traits that are a ``list`` or ``set`` shape are defined inside\n+of brackets (``[``) and (``]``) using a :token:`node_array` production.\n+\n+.. code-block:: smithy\n+\n+    @tags([\"a\", \"b\"])\n+\n+\n+Other trait values\n+------------------\n+\n+All other trait values MUST adhere to the JSON type mappings defined\n+in :ref:`trait-node-values`.\n+\n+The following example defines a string trait value:\n+\n+.. code-block:: smithy\n+\n+    @documentation(\"Hello\")\n+\n+\n+.. _apply-statement:\n+\n+Apply statement\n+---------------\n+\n+Traits can be applied to shapes outside of a shape's definition using an\n+:token:`apply_statement`.\n+\n+The following example applies the :ref:`documentation-trait` and\n+:ref:`length-trait` to the ``smithy.example#MyString`` shape:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        apply MyString @documentation(\"This is my string!\")\n+        apply MyString @length(min: 1, max: 10)\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"apply\",\n+                    \"traits\": {\n+                        \"smithy.api#documentation\": \"This is my string!\",\n+                        \"smithy.api#length\": {\n+                            \"min\": 1,\n+                            \"max\": 10\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to members too:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    apply MyStructure$foo @documentation(\"Structure member documentation\")\n+    apply MyUnion$foo @documentation(\"Union member documentation\")\n+    apply MyList$member @documentation(\"List member documentation\")\n+    apply MySet$member @documentation(\"Set member documentation\")\n+    apply MyMap$key @documentation(\"Map key documentation\")\n+    apply MyMap$value @documentation(\"Map key documentation\")\n+\n+.. seealso::\n+\n+    Refer to :ref:`trait conflict resolution <trait-conflict-resolution>`\n+    for information on how trait conflicts are resolved.\n+\n+.. note::\n+\n+    In the semantic model, applying traits outside of a shape definition is\n+    treated exactly the same as applying the trait inside of a shape\n+    definition.\n+\n+\n+.. _node-values:\n+\n+-----------\n+Node values\n+-----------\n+\n+*Node values* are analogous to JSON values. Node values are used to define\n+:ref:`metadata <semantic-model>` and :ref:`trait values <traits>`.\n+Smithy's node values have many advantages over JSON: comments,\n+unquoted keys, unquoted strings, text blocks, and trailing commas.\n+\n+The following example defines a complex object metadata entry using a\n+node value:\n+\n+.. code-block:: smithy\n+\n+    metadata foo = {\n+        hello: 123,\n+        \"foo\": \"456\",\n+        testing: \"\"\"\n+            Hello!\n+            \"\"\",\n+        an_array: [10.5],\n+        nested-object: {\n+            hello-there$: true\n+        }, // <-- Trailing comma\n+    }\n+\n+.. rubric:: Array node\n+\n+A :token:`node_array` contains zero or more heterogeneous\n+:token:`node_value`\\s. An array node is defined like a JSON array: it is\n+opened with a bracket (``[``), followed by zero or more ``node_value``\\s,\n+each value is separate by a comma (``,``), and closed by a bracket (``]``).\n+A trailing comma is allowed in a node array.\n+\n+The following examples define arrays with zero, one, and two values:\n+\n+* ``[]``\n+* ``[true]``\n+* ``[1, \"hello\",]``\n+\n+.. rubric:: Object node\n+\n+A :token:`node_object` contains zero or more key value pairs of strings\n+(a :token:`node_object_key`) that map to heterogeneous :token:`node_value`\\s.\n+An object node is defined like a JSON object: it is opened with a brace", "originalCommit": "ab2e617e464b006292aef001fb460b490077de09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI4NzkzMA==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455287930", "bodyText": "Should this read as either \"each key value pair\" or \"each value\"?", "author": "kstich", "createdAt": "2020-07-15T19:24:03Z", "path": "docs/source/1.0/spec/core/idl.rst", "diffHunk": "@@ -0,0 +1,1886 @@\n+.. _idl:\n+\n+==========\n+Smithy IDL\n+==========\n+\n+Smithy models are defined using either the Smithy interface definition language\n+(IDL) or the :ref:`JSON abstract syntax tree <json-ast>` (AST). This document\n+defines the ABNF_ grammar and syntax for defining models with the Smithy IDL.\n+\n+.. contents:: Table of contents\n+    :depth: 1\n+    :local:\n+    :backlinks: none\n+\n+\n+-------------------\n+Smithy IDL overview\n+-------------------\n+\n+The Smithy IDL is made up of 3, ordered sections, each of which is optional:\n+\n+1. **Control section**; defines parser directives like which version of the\n+   IDL to use.\n+2. **Metadata section**; applies metadata to the entire model.\n+3. **Shape section**; where shapes and traits are defined. A namespace MUST\n+   be defined before any shapes or traits can be defined.\n+   :token:`use_statement`\\s can be defined after a namespace and before shapes\n+   or traits to refer to shapes in other namespaces using a shorter name.\n+\n+The following example defines a model file with each section:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+            // (1) Control section\n+            $version: \"1.0\"\n+\n+            // (2) Metadata section\n+            metadata foo = \"bar\"\n+\n+            // (3) Shape section\n+            namespace smithy.example\n+\n+            use smithy.other.namespace#MyString\n+\n+            structure MyStructure {\n+                @required\n+                foo: MyString\n+            }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"foo\": \"bar\"\n+            },\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.other.namespace#MyString\",\n+                            \"traits\": {\n+                                \"smithy.api#required\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+-------------\n+Lexical notes\n+-------------\n+\n+Smithy models MUST be encoded using UTF-8 and SHOULD use Unix style\n+line endings (``\\n``). The Smithy ABNF is whitespace sensitive.\n+\n+\n+.. _smithy-idl-abnf:\n+\n+---------------\n+Smithy IDL ABNF\n+---------------\n+\n+The Smithy IDL is defined by the following ABNF:\n+\n+.. productionlist:: smithy\n+    idl:`ws` `control_section` `metadata_section` `shape_section`\n+\n+.. rubric:: Whitespace\n+\n+.. productionlist:: smithy\n+    ws      :*(`sp` / `newline` / `comment`) ; whitespace\n+    sp      :*(%x20  / %x09) ; \" \" and \\t\n+    br      :`sp` (`comment` / `newline`) `sp` ; break\n+    newline :%x0A / %x0D.0A ; \\n and \\r\\n\n+\n+.. rubric:: Comments\n+\n+.. productionlist:: smithy\n+    comment: `documentation_comment` / `comment`\n+    documentation_comment:\"///\" *`not_newline` `br`\n+    line_comment: \"//\" *`not_newline` `newline`\n+    not_newline: %x09 / %x20-10FFFF ; Any character except newline\n+\n+.. rubric:: Control\n+\n+.. productionlist:: smithy\n+    control_section   :*(`control_statement`)\n+    control_statement :\"$\" `ws` `node_object_key` `ws` \":\" `ws` `node_value` `br`\n+\n+.. rubric:: Metadata\n+\n+.. productionlist:: smithy\n+    metadata_section   :*(`metadata_statement`)\n+    metadata_statement :\"metadata\" `ws` `node_object_key` `ws` \"=\" `ws` `node_value` `br`\n+\n+.. rubric:: Node values\n+\n+.. productionlist:: smithy\n+    node_value :`node_array`\n+               :/ `node_object`\n+               :/ `number`\n+               :/ `node_keywords`\n+               :/ `node_string_value`\n+    node_array          :`empty_node_array` / `populated_node_array`\n+    empty_node_array    :\"[\" `ws` \"]\"\n+    populated_node_array:\"[\" `ws` `node_value` `ws`\n+                        :       *(`comma` `node_value` `ws`)\n+                        :       `trailing_comma` \"]\"\n+    trailing_comma      :[`comma`]\n+    comma               :\",\" `ws`\n+    node_object          :`empty_node_object` / `populated_node_object`\n+    empty_node_object    :\"{\" `ws` \"}\"\n+    populated_node_object:\"{\" `ws` `node_object_kvp` `ws`\n+                         :       *(`comma` `node_object_kvp` `ws`)\n+                         :       `trailing_comma` \"}\"\n+    node_object_kvp      :`node_object_key` `ws` \":\" `ws` `node_value`\n+    node_object_key      :`quoted_text` / `identifier`\n+    number              :[`minus`] `int` [`frac`] [`exp`]\n+    decimal_point       :%x2E ; .\n+    digit1_9            :%x31-39 ; 1-9\n+    e                   :%x65 / %x45 ; e E\n+    exp                 :`e` [`minus` / `plus`] 1*DIGIT\n+    frac                :`decimal_point` 1*DIGIT\n+    int                 :`zero` / (`digit1_9` *DIGIT)\n+    minus               :%x2D ; -\n+    plus                :%x2B ; +\n+    zero                :%x30 ; 0\n+    node_keywords: \"true\" / \"false\" / \"null\"\n+    node_string_value   :`shape_id` / `text_block` / `quoted_text`\n+    quoted_text         :DQUOTE *`quoted_char` DQUOTE\n+    quoted_char         :%x20-21        ; space - \"!\"\n+                        :/ %x23-5B        ; \"#\" - \"[\"\n+                        :/ %x5D-10FFFF    ; \"]\"+\n+                        :/ `escaped_char`\n+                        :/ `preserved_double`\n+    escaped_char        :`escape` (`escape` / \"'\" / DQUOTE / \"b\" / \"f\" / \"n\" / \"r\" / \"t\" / \"/\" / `unicode_escape`)\n+    unicode_escape      :\"u\" `hex` `hex` `hex` `hex`\n+    hex                 : DIGIT / %x41-46 / %x61-66\n+    preserved_double    :`escape` (%x20-21 / %x23-5B / %x5D-10FFFF)\n+    escape              :%x5C ; backslash\n+    text_block          :`three_dquotes` `br` *`quoted_char` `three_dquotes`\n+    three_dquotes       :DQUOTE DQUOTE DQUOTE\n+\n+.. rubric:: Shapes\n+\n+.. productionlist:: smithy\n+    shape_section :[`namespace_statement` [`use_section`] [`shape_statements`]]\n+    namespace_statement :\"namespace\" `ws` `namespace` `br`\n+    use_section   :*(`use_statement`)\n+    use_statement :\"use\" `ws` `absolute_root_shape_id` `br`\n+    shape_statements             :*(`shape_statement` / `apply_statement`)\n+    shape_statement              :`trait_statements` `shape_body` `br`\n+    shape_body                   :`simple_shape_statement`\n+                                 :/ `list_statement`\n+                                 :/ `set_statement`\n+                                 :/ `map_statement`\n+                                 :/ `structure_statement`\n+                                 :/ `union_statement`\n+                                 :/ `service_statement`\n+                                 :/ `operation_statement`\n+                                 :/ `resource_statement`\n+    simple_shape_statement :`simple_type_name` `ws` `identifier`\n+    simple_type_name       :\"blob\" / \"boolean\" / \"document\" / \"string\"\n+                           :/ \"byte\" / \"short\" / \"integer\" / \"long\"\n+                           :/ \"float\" / \"double\" / \"bigInteger\"\n+                           :/ \"bigDecimal\" / \"timestamp\"\n+    shape_members           :`empty_shape_members` / `populated_shape_members`\n+    empty_shape_members     :\"{\" `ws` \"}\"\n+    populated_shape_members :\"{\" `ws` `shape_member_kvp`\n+                            :  *(`comma` `shape_member_kvp` `ws`) `trailing_comma` \"}\"\n+    shape_member_kvp        :`trait_statements` `identifier` `ws` \":\" `ws` `shape_id`\n+    list_statement :\"list\" `ws` `identifier` `ws` `shape_members`\n+    set_statement :\"set\" `ws` `identifier` `ws` `shape_members`\n+    map_statement :\"map\" `ws` `identifier` `ws` `shape_members`\n+    structure_statement     :\"structure\" `ws` `identifier` `ws` `shape_members`\n+    union_statement :\"union\" `ws` `identifier` `ws` `shape_members`\n+    service_statement :\"service\" `ws` `identifier` `ws` `node_object`\n+    operation_statement :\"operation\" `ws` `identifier` `ws` `node_object`\n+    resource_statement :\"resource\" `ws` `identifier` `ws` `node_object`\n+\n+.. rubric:: Traits\n+\n+.. productionlist:: smithy\n+    trait_statements    : *(`ws` `trait`) `ws`\n+    trait               :\"@\" `shape_id` [`trait_body`]\n+    trait_body          :\"(\" `ws` `trait_body_value` `ws` \")\"\n+    trait_body_value    :`trait_structure` / `node_value`\n+    trait_structure     :`trait_structure_kvp` *(`ws` `comma` `trait_structure_kvp`)\n+    trait_structure_kvp :`node_object_key` `ws` \":\" `ws` `node_value`\n+    apply_statement :\"apply\" `ws` `shape_id` `ws` `trait` `br`\n+\n+\n+.. _comments:\n+\n+--------\n+Comments\n+--------\n+\n+A :token:`comment <comment>` can appear at any place between tokens where\n+whitespace (:token:`ws`) can appear. Comments in Smithy are defined using two\n+forward slashes followed by any character. A newline terminates a comment.\n+\n+.. code-block:: smithy\n+\n+    // This is a comment\n+    namespace com.foo // This is also a comment\n+\n+    // Another comment\n+    string MyString\n+\n+.. note::\n+\n+    Three forward slashes can be used to define the documentation of a shape\n+    using a special :ref:`documentation comment <documentation-comment>`.\n+\n+\n+.. _control-statement:\n+\n+---------------\n+Control section\n+---------------\n+\n+The :token:`control section <control_section>` of a model contains\n+:token:`control statements <control_statement>` that apply parser directives\n+to a *specific IDL file*. Because control statements influence parsing, they\n+MUST appear at the beginning of a file before any other statements and have\n+no effect on the :ref:`semantic model <semantic-model>`\n+\n+The :ref:`version <smithy-version>` statement is currently the only control\n+statement defined in the Smithy IDL. Implementations MUST ignore unknown\n+control statements.\n+\n+\n+.. _smithy-version:\n+\n+Version statement\n+=================\n+\n+The Smithy specification is versioned using a ``major`` . ``minor``\n+versioning scheme. A version requirement is specified for a model file using\n+the ``$version`` control statement. When no version number is specified in\n+the IDL, an implementation SHOULD assume that the model can be loaded.\n+Because this can lead to unexpected parsing errors, models SHOULD always\n+include a version.\n+\n+The value provided in a version control statement is a string that MUST\n+adhere to the following ABNF:\n+\n+.. productionlist:: smithy\n+    version_string :1*DIGIT [ \".\" 1*DIGIT ]\n+\n+The following example sets the version to ``1``, meaning that tooling MUST\n+support a version greater than or equal to ``1.0`` and less than ``2.0``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1\"\n+        }\n+\n+A minor version SHOULD be provided when a model depends on a feature released\n+in a minor update of the specification. The following example sets the\n+version requirement of a file to ``1.1``, meaning that tooling MUST support a\n+version greater than or equal to ``1.1`` and less than ``2.0``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        $version: \"1.1\"\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.1\"\n+        }\n+\n+.. rubric:: Version compatibility\n+\n+A single version statement can appear in a model file, but different versions\n+MAY be encountered when merging multiple model files together. Multiple\n+versions are supported if and only if all of the version statements are\n+supported by the tool loading the models.\n+\n+\n+.. _metadata-section:\n+\n+----------------\n+Metadata section\n+----------------\n+\n+The :token:`metadata section <metadata_section>` is used to apply untyped\n+metadata to the entire model. A :token:`metadata_statement` consists of the\n+metadata key to set, followed by ``=``, followed by the\n+:token:`node value <node_value>` to assign to the key.\n+\n+The following example defines metadata in the model:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        metadata greeting = \"hello\"\n+        metadata \"stringList\" = [\"a\", \"b\", \"c\"]\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"metadata\": {\n+                \"greeting\": \"hello\",\n+                \"stringList\": [\"a\", \"b\", \"c\"]\n+            }\n+        }\n+\n+\n+-------------\n+Shape section\n+-------------\n+\n+The :token:`shape section <shape_section>` of the IDL is used to define\n+shapes and apply traits to shapes.\n+\n+\n+.. _namespaces:\n+\n+Namespaces\n+==========\n+\n+Shapes can only be defined after a namespace is declared. A namespace is\n+declared using a :token:`namespace statement <namespace_statement>`. Only\n+one namespace can appear per file.\n+\n+The following example defines a string shape named ``MyString`` in the\n+``smithy.example`` namespace:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\"\n+                }\n+            }\n+        }\n+\n+\n+.. _use-statement:\n+\n+Referring to shapes\n+===================\n+\n+The :token:`use section <use_section>` of the IDL is used to import shapes\n+into the current namespace so that they can be referred to using a\n+:ref:`relative shape ID <relative-shape-id>`. The :token:`use_statement <use_statement>`\\s\n+that make up this section have no effect on the :ref:`semantic model <semantic-model>`.\n+\n+The following example uses ``smithy.example#Foo`` and ``smithy.example#Baz``\n+so that they can be referred to using only ``Foo`` and ``Baz``.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.hello\n+\n+    use smithy.example#Foo\n+    use smithy.example#Baz\n+\n+    map MyMap {\n+        // Resolves to smithy.example#Foo\n+        key: Foo,\n+        // Resolves to smithy.example#Baz\n+        value: Baz,\n+    }\n+\n+A use statement can refer to :ref:`traits <traits>` too. The following example\n+uses the ``smithy.example#test`` and ``smithy.example#anotherTrait``\n+traits so that they can be applied using relative shape IDs:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.hello\n+\n+    use smithy.example#test\n+    use smithy.example#anotherTrait\n+\n+    @test // <-- Resolves to smithy.example#test\n+    string MyString\n+\n+.. rubric:: Use statement validation\n+\n+#. A shape cannot be defined in a file with the same name as one of the\n+   shapes imported with a ``use`` statement.\n+#. Shapes IDs with members names cannot be imported with a use statement.\n+\n+\n+.. _relative-shape-id:\n+\n+Relative shape ID resolution\n+----------------------------\n+\n+Relative shape IDs are resolved using the following process:\n+\n+#. If a :token:`use_statement` has imported a shape with the same name,\n+   the shape ID resolves to the imported shape ID.\n+#. If a shape is defined in the same namespace as the shape with the same name,\n+   the namespace of the shape resolves to the *current namespace*.\n+#. If a shape is defined in the :ref:`prelude <prelude>` with the same name,\n+   the namespace resolves to ``smithy.api``.\n+#. If a relative shape ID does not satisfy one of the above cases, the shape\n+   ID is invalid, and the namespace is inherited from the *current namespace*.\n+\n+The following example Smithy model contains comments above each member of\n+the shape named ``MyStructure`` that describes the shape the member resolves\n+to.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    use foo.baz#Bar\n+\n+    string MyString\n+\n+    structure MyStructure {\n+        // Resolves to smithy.example#MyString\n+        // There is a shape named MyString defined in the same namespace.\n+        a: MyString,\n+\n+        // Resolves to smithy.example#MyString\n+        // Absolute shape IDs do not perform namespace resolution.\n+        b: smithy.example#MyString,\n+\n+        // Resolves to foo.baz#Bar\n+        // The \"use foo.baz#Bar\" statement imported the Bar symbol,\n+        // allowing the shape to be referenced using a relative shape ID.\n+        c: Bar,\n+\n+        // Resolves to smithy.api#String\n+        // No shape named String was imported through a use statement\n+        // the smithy.example namespace does not contain a shape named\n+        // String, and the prelude model contains a shape named String.\n+        d: String,\n+\n+        // Resolves to smithy.example#MyBoolean.\n+        // There is a shape named MyBoolean defined in the same namespace.\n+        // Forward references are supported both within the same file and\n+        // across multiple files.\n+        e: MyBoolean,\n+\n+        // Resolves to smithy.example#InvalidShape. A shape by this name has\n+        // not been imported through a use statement, a shape by this name\n+        // does not exist in the current namespace, and a shape by this name\n+        // does not exist in the prelude model.\n+        f: InvalidShape,\n+    }\n+\n+    boolean MyBoolean\n+\n+\n+.. _syntactic-shape-ids:\n+\n+Syntactic shape IDs\n+-------------------\n+\n+Unquoted string values that are not object keys in the Smithy IDL are\n+considered lexical shape IDs and are resolved to absolute shape IDs using the\n+process defined in :ref:`relative-shape-id`.\n+\n+The following model defines a list that references a string shape defined\n+in another namespace.\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    use smithy.other#MyString\n+\n+    list MyList {\n+        member: MyString\n+    }\n+\n+The above model is equivalent to the following JSON AST model:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"shapes\": {\n+            \"smithy.example#MyList\": {\n+                \"type\": \"list\",\n+                \"members\": {\n+                    \"target\": \"smithy.other#MyString\"\n+                }\n+            }\n+        }\n+    }\n+\n+.. rubric:: Use quotes for literal strings\n+\n+Values that are not meant to be shape IDs MUST be quoted. The following\n+model is syntactically valid but semantically incorrect because\n+it resolves the value of the :ref:`error-trait` to the shape ID\n+``\"smithy.example#client\"`` rather than using the string literal value of\n+``\"client\"``:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    @error(client) // <-- This MUST be \"client\"\n+    structure Error\n+\n+    string client\n+\n+The above example is equivalent to the following incorrect JSON AST:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"shapes\": {\n+            \"smithy.example#Error\": {\n+                \"type\": \"structure\",\n+                \"traits\": {\n+                    \"smithy.api#error\": \"smithy.example#client\"\n+                }\n+            },\n+            \"smithy.example#client\": {\n+                \"type\": \"string\"\n+            }\n+        }\n+    }\n+\n+.. rubric:: Object keys\n+\n+Object keys are not treated as shape IDs. The following example defines a\n+:ref:`metadata <metadata-section>` object, and when loaded into the\n+:ref:`semantic model <semantic-model>`, the object key ``String`` remains\n+the same literal string value of ``String`` while the value is treated as\n+a shape ID and resolves to the string literal ``\"smithy.api#String\"``.\n+\n+.. code-block:: smithy\n+\n+    metadata foo = {\n+        String: String,\n+    }\n+\n+The above example is equivalent to the following JSON AST:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"metadata\": {\n+            \"String\": \"smithy.api#String\"\n+        }\n+    }\n+\n+.. rubric:: Semantic model\n+\n+Syntactic shape IDs are syntactic sugar for defining fully-qualified\n+shape IDs inside of strings, and this difference is inconsequential in the\n+:ref:`semantic model <semantic-model>`. A syntactic shape ID SHOULD be\n+resolved to a string that contains a fully-qualified shape ID when parsing\n+the model.\n+\n+\n+Defining shapes\n+===============\n+\n+Shapes are defined using a :token:`shape_statement`.\n+\n+\n+.. _idl-simple:\n+\n+Simple shapes\n+-------------\n+\n+:ref:`Simple shapes <simple-types>` are defined using a\n+:token:`simple_shape_statement`.\n+\n+The following example defines a ``string`` shape:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#String\": {\n+                    \"type\": \"string\"\n+                }\n+            }\n+        }\n+\n+The following example defines an ``integer`` shape with a :ref:`range-trait`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @range(min: 0, max: 1000)\n+        integer MaxResults\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MaxResults\": {\n+                    \"type\": \"integer\",\n+                    \"traits\": {\n+                        \"smithy.api#range\": {\n+                            \"min\": 0,\n+                            \"max\": 100\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-list:\n+\n+List shapes\n+-----------\n+\n+A :ref:`list <list>` shape is defined using a :token:`list_statement`.\n+\n+The following example defines a list with a string member from the\n+:ref:`prelude <prelude>`:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        list MyList {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to the list shape and its member:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @length(min: 3, max: 10)\n+        list MyList {\n+            @length(min: 1, max: 100)\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyList\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\",\n+                        \"traits\": {\n+                            \"smithy.api#length\": {\n+                                \"min\": 1,\n+                                \"max\": 100\n+                            }\n+                        }\n+                    },\n+                    \"traits\": {\n+                        \"smithy.api#length\": {\n+                            \"min\": 3,\n+                            \"max\": 10\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-set:\n+\n+Set shapes\n+----------\n+\n+A :ref:`set <set>` set shape is defined using a :token:`set_statement`.\n+\n+The following example defines a set of strings:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        set StringSet {\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#StringSet\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to the set shape and its members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @deprecated\n+        set StringSet {\n+            @sensitive\n+            member: String\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#StringSet\": {\n+                    \"member\": {\n+                        \"target\": \"smithy.api#String\"\n+                    },\n+                    \"traits\": {\n+                        \"smithy.api#deprecated\": {}\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-map:\n+\n+Map shapes\n+----------\n+\n+A :ref:`map <map>` shape is defined using a :token:`map_statement`.\n+\n+The following example defines a map of strings to integers:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        map IntegerMap {\n+            key: String,\n+            value: Integer\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#IntegerMap\": {\n+                    \"key\": {\n+                        \"target\": \"smithy.api#String\"\n+                    },\n+                    \"value\": {\n+                        \"target\": \"smithy.api#String\"\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to the map shape and its members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @length(min: 0, max: 100)\n+        map IntegerMap {\n+            @length(min: 1, max: 10)\n+            key: String,\n+\n+            @sensitive\n+            value: Integer\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#IntegerMap\": {\n+                    \"key\": {\n+                        \"target\": \"smithy.api#String\",\n+                        \"traits\": {\n+                            \"smithy.api#length\": {\n+                                \"min\": 1,\n+                                \"max\": 10\n+                            }\n+                        }\n+                    },\n+                    \"value\": {\n+                        \"target\": \"smithy.api#String\",\n+                        \"traits\": {\n+                            \"smithy.api#sensitive\": {}\n+                        }\n+                    },\n+                    \"traits\": {\n+                        \"smithy.api#length\": {\n+                            \"min\": 0,\n+                            \"max\": 100\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-structure:\n+\n+Structure shapes\n+----------------\n+\n+A :ref:`structure <structure>` shape is defined using a\n+:token:`structure_statement`.\n+\n+The following example defines a structure with two members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        structure MyStructure {\n+            foo: String,\n+            baz: Integer,\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.api#String\"\n+                        },\n+                        \"baz\": {\n+                            \"target\": \"smithy.api#Integer\"\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to structure members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        /// This is MyStructure.\n+        structure MyStructure {\n+            /// This is documentation for `foo`.\n+            @required\n+            foo: String,\n+\n+            /// This is documentation for `baz`.\n+            @deprecated\n+            baz: Integer,\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyStructure\": {\n+                    \"type\": \"structure\",\n+                    \"members\": {\n+                        \"foo\": {\n+                            \"target\": \"smithy.api#String\",\n+                            \"traits\": {\n+                                \"smithy.api#documentation\": \"This is documentation for `foo`.\",\n+                                \"smithy.api#required\": {}\n+                            }\n+                        },\n+                        \"baz\": {\n+                            \"target\": \"smithy.api#Integer\",\n+                            \"traits\": {\n+                                \"smithy.api#documentation\": \"This is documentation for `baz`.\",\n+                                \"smithy.api#deprecated\": {}\n+                            }\n+                        }\n+                    },\n+                    \"traits\": {\n+                        \"smithy.api#documentation\": \"This is MyStructure.\"\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-union:\n+\n+Union shapes\n+------------\n+\n+A :ref:`union <union>` shape is defined using a :token:`union_statement`.\n+\n+The following example defines a union shape with several members:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        union MyUnion {\n+            i32: Integer,\n+\n+            stringA: String,\n+\n+            @sensitive\n+            stringB: String,\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyUnion\": {\n+                    \"type\": \"union\",\n+                    \"members\": {\n+                        \"i32\": {\n+                            \"target\": \"smithy.api#Integer\"\n+                        },\n+                        \"stringA\": {\n+                            \"target\": \"smithy.api#String\"\n+                        },\n+                        \"stringB\": {\n+                            \"target\": \"smithy.api#String\",\n+                            \"traits\": {\n+                                \"smithy.api#sensitive\": {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-service:\n+\n+Service shape\n+-------------\n+\n+A service shape is defined using a :token:`service_statement` and the provided\n+:token:`node_object` supports the same properties defined in the\n+:ref:`service specification <service>`.\n+\n+The following example defines a service named ``ModelRepository`` that binds\n+a resource named ``Model`` and an operation named ``PingService``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        service ModelRepository {\n+            version: \"2020-07-13\",\n+            resources: [Model],\n+            operations: [PingService]\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#ModelRepository\": {\n+                    \"type\": \"service\",\n+                    \"resources\": [\n+                        {\n+                            \"target\": \"smithy.example#Model\"\n+                        }\n+                    ],\n+                    \"operations\": [\n+                        {\n+                            \"target\": \"smithy.example#PingService\"\n+                        }\n+                    ]\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-operation:\n+\n+Operation shape\n+---------------\n+\n+An operation shape is defined using an :token:`operation_statement` and the\n+provided :token:`node_object` supports the same properties defined in the\n+:ref:`operation specification <operation>`.\n+\n+The following example defines an operation shape that accepts an input\n+structure named ``Input``, returns an output structure named ``Output``, and\n+can potentially return the ``Unavailable`` or ``BadRequest``\n+:ref:`error structures <error-trait>`.\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        operation PingService {\n+            input: Input,\n+            output: Output,\n+            errors: [Unavailable, BadRequest]\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#PingService\": {\n+                    \"type\": \"operation\",\n+                    \"input\": {\n+                        \"target\": \"smithy.example#Input\"\n+                    },\n+                    \"output\": {\n+                        \"target\": \"smithy.example#Output\"\n+                    },\n+                    \"errors\": [\n+                        {\n+                            \"target\": \"smithy.example#Unavailable\"\n+                        },\n+                        {\n+                            \"target\": \"smithy.example#BadRequest\"\n+                        }\n+                    ]\n+                }\n+            }\n+        }\n+\n+\n+.. _idl-resource:\n+\n+Resource shape\n+--------------\n+\n+A resource shape is defined using a :token:`resource_statement` and the\n+provided :token:`node_object` supports the same properties defined in the\n+:ref:`resource specification <resource>`.\n+\n+The following example defines a resource shape that has a single identifier,\n+and defines a :ref:`read <read-lifecycle>` operation:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        resource Model {\n+            identifiers: {\n+                modelId: String,\n+            },\n+            read: GetModel,\n+        }\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#Model\": {\n+                    \"type\": \"resource\",\n+                    \"identifiers\": {\n+                        \"modelId\": {\n+                            \"target\": \"smithy.api#String\"\n+                        }\n+                    },\n+                    \"read\": {\n+                        \"target\": \"smithy.example#GetModel\"\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _documentation-comment:\n+\n+Documentation comment\n+=====================\n+\n+:token:`Documentation comments <documentation_comment>` are a special kind of :token:`comment` that provide\n+:ref:`documentation <documentation-trait>` for shapes. A documentation\n+comment is formed when three forward slashes (``\"///\"``) appear as the\n+first non-whitespace characters on a line.\n+\n+Documentation comments are defined using CommonMark_. The text after the\n+forward slashes is considered the contents of the line. If the text starts\n+with a space (\" \"), the leading space is removed from the content.\n+Successive documentation comments are combined together using a newline\n+(\"\\\\n\") to form the documentation of a shape.\n+\n+The following Smithy IDL example,\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    /// This is documentation about a shape.\n+    ///\n+    /// - This is a list\n+    /// - More of the list.\n+    string MyString\n+\n+    /// This is documentation about a trait shape.\n+    ///   More docs here.\n+    @trait\n+    structure myTrait {}\n+\n+is equivalent to the following JSON AST model:\n+\n+.. code-block:: json\n+\n+    {\n+        \"smithy\": \"1.0\",\n+        \"shapes\": {\n+            \"smithy.example#MyString\": {\n+                \"type\": \"string\",\n+                \"traits\": {\n+                    \"smithy.api#documentation\": \"This is documentation about a shape.\\n\\n- This is a list\\n- More of the list.\"\n+                }\n+            },\n+            \"smithy.example#myTrait\": {\n+                \"type\": \"structure\",\n+                \"traits\": {\n+                    \"smithy.api#trait\": {},\n+                    \"smithy.api#documentation\": \"This is documentation about a trait shapes.\\n  More docs here.\"\n+                }\n+            }\n+        }\n+    }\n+\n+.. rubric:: Placement\n+\n+Documentation comments are only treated as shape documentation when the\n+comment appears immediately before a shape, and documentation comments MUST\n+appear **before** any :ref:`traits <traits>` applied to the shape in order\n+for the documentation to be applied to a shape.\n+\n+The following example applies a documentation trait to the shape because the\n+documentation comment comes before the traits applied to a shape:\n+\n+.. code-block:: smithy\n+\n+    /// A deprecated string.\n+    @deprecated\n+    string MyString\n+\n+Documentation comments can also be applied to members of a shape.\n+\n+.. code-block:: smithy\n+\n+    /// Documentation about the structure.\n+    structure Example {\n+        /// Documentation about the member.\n+        @sensitive\n+        foo: String,\n+    }\n+\n+.. rubric:: Semantic model\n+\n+Documentation comments are syntactic sugar equivalent to applying the\n+:ref:`documentation-trait`, and this difference is inconsequential\n+in the :ref:`semantic model <semantic-model>`.\n+\n+\n+.. _idl-applying-traits:\n+\n+Applying traits\n+===============\n+\n+Trait values immediately preceding a shape definition are applied to the\n+shape. The shape ID of a trait is *resolved* against :token:`use_statement`\\s\n+and the current namespace in exactly the same same way as\n+:ref:`other shape IDs <relative-shape-id>`.\n+\n+The following example applies the :ref:`sensitive-trait` and\n+:ref:`documentation-trait` to ``MyString``:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @sensitive\n+        @documentation(\"Contains a string\")\n+        string MyString\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#documentation\": \"Contains a string\",\n+                        \"smithy.api#sensitive\": {}\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+.. _trait-values:\n+\n+Trait values\n+------------\n+\n+The value that can be provided for a trait depends on its type. A value for a\n+trait is defined by enclosing the value in parenthesis. Trait values can only\n+appear immediately before a shape.\n+\n+The following example applies various traits to a structure shape and its\n+members.\n+\n+.. code-block:: smithy\n+\n+    @documentation(\"An animal in the animal kingdom\")\n+    structure Animal {\n+        @required\n+        name: smithy.api#String,\n+\n+        @length(min: 0)\n+        @tags([\"internal\"])\n+        age: smithy.api#Integer,\n+    }\n+\n+\n+Structure, map, and union trait values\n+--------------------------------------\n+\n+Traits that are a ``structure``, ``union``, or ``map`` are defined using\n+a special syntax that places key-value pairs inside of the trait\n+parenthesis. Wrapping braces, \"{\" and \"}\", are not permitted.\n+\n+.. code-block:: smithy\n+\n+    @structuredTrait(foo: \"bar\", baz: \"bam\")\n+\n+Nested structure, map, and union values are defined using\n+:ref:`node value <node-values>` productions:\n+\n+.. code-block:: smithy\n+\n+    @structuredTrait(\n+        foo: {\n+            bar: \"baz\",\n+            qux: \"true\",\n+        }\n+    )\n+\n+Omitting a value is allowed on ``list``, ``set``, ``map``, and ``structure``\n+traits if the shapes have no ``length`` constraints or ``required`` members.\n+The following applications of the ``foo`` trait are equivalent:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        @trait\n+        structure foo {}\n+\n+        @foo\n+        string MyString1\n+\n+        @foo()\n+        string MyString2\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#foo\": {\n+                    \"type\": \"structure\",\n+                    \"traits\": {\n+                        \"smithy.api#trait\": {}\n+                    }\n+                },\n+                \"smithy.example#MyString1\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#foo\": {}\n+                    }\n+                },\n+                \"smithy.example#MyString2\": {\n+                    \"type\": \"string\",\n+                    \"traits\": {\n+                        \"smithy.api#foo\": {}\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+List and set trait values\n+-------------------------\n+\n+Traits that are a ``list`` or ``set`` shape are defined inside\n+of brackets (``[``) and (``]``) using a :token:`node_array` production.\n+\n+.. code-block:: smithy\n+\n+    @tags([\"a\", \"b\"])\n+\n+\n+Other trait values\n+------------------\n+\n+All other trait values MUST adhere to the JSON type mappings defined\n+in :ref:`trait-node-values`.\n+\n+The following example defines a string trait value:\n+\n+.. code-block:: smithy\n+\n+    @documentation(\"Hello\")\n+\n+\n+.. _apply-statement:\n+\n+Apply statement\n+---------------\n+\n+Traits can be applied to shapes outside of a shape's definition using an\n+:token:`apply_statement`.\n+\n+The following example applies the :ref:`documentation-trait` and\n+:ref:`length-trait` to the ``smithy.example#MyString`` shape:\n+\n+.. tabs::\n+\n+    .. code-tab:: smithy\n+\n+        namespace smithy.example\n+\n+        apply MyString @documentation(\"This is my string!\")\n+        apply MyString @length(min: 1, max: 10)\n+\n+    .. code-tab:: json\n+\n+        {\n+            \"smithy\": \"1.0\",\n+            \"shapes\": {\n+                \"smithy.example#MyString\": {\n+                    \"type\": \"apply\",\n+                    \"traits\": {\n+                        \"smithy.api#documentation\": \"This is my string!\",\n+                        \"smithy.api#length\": {\n+                            \"min\": 1,\n+                            \"max\": 10\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+Traits can be applied to members too:\n+\n+.. code-block:: smithy\n+\n+    namespace smithy.example\n+\n+    apply MyStructure$foo @documentation(\"Structure member documentation\")\n+    apply MyUnion$foo @documentation(\"Union member documentation\")\n+    apply MyList$member @documentation(\"List member documentation\")\n+    apply MySet$member @documentation(\"Set member documentation\")\n+    apply MyMap$key @documentation(\"Map key documentation\")\n+    apply MyMap$value @documentation(\"Map key documentation\")\n+\n+.. seealso::\n+\n+    Refer to :ref:`trait conflict resolution <trait-conflict-resolution>`\n+    for information on how trait conflicts are resolved.\n+\n+.. note::\n+\n+    In the semantic model, applying traits outside of a shape definition is\n+    treated exactly the same as applying the trait inside of a shape\n+    definition.\n+\n+\n+.. _node-values:\n+\n+-----------\n+Node values\n+-----------\n+\n+*Node values* are analogous to JSON values. Node values are used to define\n+:ref:`metadata <semantic-model>` and :ref:`trait values <traits>`.\n+Smithy's node values have many advantages over JSON: comments,\n+unquoted keys, unquoted strings, text blocks, and trailing commas.\n+\n+The following example defines a complex object metadata entry using a\n+node value:\n+\n+.. code-block:: smithy\n+\n+    metadata foo = {\n+        hello: 123,\n+        \"foo\": \"456\",\n+        testing: \"\"\"\n+            Hello!\n+            \"\"\",\n+        an_array: [10.5],\n+        nested-object: {\n+            hello-there$: true\n+        }, // <-- Trailing comma\n+    }\n+\n+.. rubric:: Array node\n+\n+A :token:`node_array` contains zero or more heterogeneous\n+:token:`node_value`\\s. An array node is defined like a JSON array: it is\n+opened with a bracket (``[``), followed by zero or more ``node_value``\\s,\n+each value is separate by a comma (``,``), and closed by a bracket (``]``).\n+A trailing comma is allowed in a node array.\n+\n+The following examples define arrays with zero, one, and two values:\n+\n+* ``[]``\n+* ``[true]``\n+* ``[1, \"hello\",]``\n+\n+.. rubric:: Object node\n+\n+A :token:`node_object` contains zero or more key value pairs of strings\n+(a :token:`node_object_key`) that map to heterogeneous :token:`node_value`\\s.\n+An object node is defined like a JSON object: it is opened with a brace\n+(``{``), followed by zero or more key value pairs, each key value is separate", "originalCommit": "ab2e617e464b006292aef001fb460b490077de09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIxNjI4NA==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455216284", "bodyText": "I like that optimism", "author": "JordonPhillips", "createdAt": "2020-07-15T17:29:17Z", "path": "docs/smithy/__init__.py", "diffHunk": "@@ -51,3 +55,47 @@ def visit_productionlist(self, node):\n             self.body.append('\\n')\n         self.body.append('</pre>\\n')\n         raise nodes.SkipNode\n+\n+\n+# Use .. text-figure to create text diagrams that look like figures.\n+class TextFigure(Directive):\n+\n+    required_arguments = 0\n+    optional_arguments = 2\n+    option_spec = {\n+        'caption': directives.unchanged_required,\n+        'name': directives.unchanged,\n+    }\n+    has_content = True\n+    final_argument_whitespace = False\n+\n+    def run(self):\n+        self.assert_has_content()\n+        text = '\\n'.join(self.content)\n+        literal = nodes.literal_block(text, text)\n+        literal = self.__container_wrapper(literal, self.options.get('caption'))\n+        self.add_name(literal)\n+        literal['classes'].append(\"text-figure\")\n+        return [literal]\n+\n+    # This is a modified version of https://github.com/sphinx-doc/sphinx/blob/3.x/sphinx/directives/code.py\n+    # that places the caption after the text rather than before.\n+    def __container_wrapper(self, literal_node, caption):\n+        container_node = nodes.container('', literal_block=True,\n+                                         classes=['literal-block-wrapper'])\n+        parsed = nodes.Element()\n+        self.state.nested_parse(StringList([caption], source=''),\n+                                self.content_offset, parsed)\n+        if isinstance(parsed[0], nodes.system_message):\n+            msg = __('Invalid caption: %s' % parsed[0].astext())\n+            raise ValueError(msg)\n+        elif isinstance(parsed[0], nodes.Element):\n+            caption_node = nodes.caption(parsed[0].rawsource, '',\n+                                         *parsed[0].children)\n+            caption_node.source = literal_node.source\n+            caption_node.line = literal_node.line\n+            container_node += literal_node\n+            container_node += caption_node\n+            return container_node\n+        else:\n+            raise RuntimeError  # never reached", "originalCommit": "ab2e617e464b006292aef001fb460b490077de09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM2MDM2Nw==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455360367", "bodyText": "Heh, yeah. That was in the original code I based this on.", "author": "mtdowling", "createdAt": "2020-07-15T21:23:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIxNjI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyNjg3Nw==", "url": "https://github.com/awslabs/smithy/pull/497#discussion_r455326877", "bodyText": "Nit: when they're not equal", "author": "JordonPhillips", "createdAt": "2020-07-15T20:37:05Z", "path": "docs/source/1.0/spec/core/model.rst", "diffHunk": "@@ -0,0 +1,2630 @@\n+.. _smithy-model:\n+\n+================\n+The Smithy model\n+================\n+\n+The *Smithy model* describes the Smithy semantic model and the files used to\n+create it. Smithy models are used to describe services and data structures.\n+\n+.. contents:: Table of contents\n+    :depth: 1\n+    :local:\n+    :backlinks: none\n+\n+\n+.. _smithy-overview:\n+\n+----------------\n+Smithy framework\n+----------------\n+\n+Smithy is a framework that consists of a semantic model, file formats used to\n+define a model, and a build process used to validate models and facilitate\n+model transformations.\n+\n+.. text-figure::\n+    :caption: **Figure 1.1**: Smithy framework concepts\n+    :name: figure-1.1\n+\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 part of          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    \u2502                \u2502\u2572                \u2571\u2502                \u2502\n+                    \u2502 Semantic Model \u2502\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u2502   Model File   \u2502\n+                    \u2502                \u2502\u2571                \u2572\u2502                \u2502\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                               split into       \u2572\u2502\u2571\n+                                                                 \u25cb\n+                                                                 \u2502\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                           \u253c\n+                    \u2502JSON AST (.json)\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502         \u2502                \u2502\n+                                              \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b7\u2502 Representation \u2502\n+                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502         \u2502                \u2502\n+                    \u2502 IDL (.smithy)  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+Semantic model\n+    The in-memory model used by tools. The :ref:`semantic model <semantic-model>`\n+    may be serialized into one or more model file representations.\n+Model File\n+    A file on the file system, in a particular representation. The model files\n+    that make up a semantic model MAY be split across multiple files to\n+    improve readability or modularity, and those files are not required to\n+    use the same representation.\n+Representation\n+    A particular model file format such as the Smithy IDL or JSON AST.\n+    Representations are loaded into the semantic model by mapping the\n+    representation to concepts in the semantic model.\n+\n+    * The :ref:`Smithy IDL <idl>` is a human-readable format that aims to\n+      streamline authoring and reading models.\n+    * The :ref:`JSON AST <json-ast>` aims to provide a more machine-readable\n+      format to easily share models across language implementations and better\n+      integrate with JSON-based ecosystems.\n+\n+\n+.. _semantic-model:\n+\n+------------------\n+The semantic model\n+------------------\n+\n+Smithy's *semantic model* is an in-memory model used by tools. It is\n+independent of any particular serialized representation. The semantic\n+model contains :ref:`metadata <metadata>` and a graph of\n+:ref:`shapes <shapes>` connected by :ref:`shape IDs <shape-id>`.\n+\n+.. text-figure::\n+    :caption: **Figure 1.3**: The semantic model\n+    :name: figure-1.3\n+\n+                                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                                          \u2502Semantic Model \u2502\u2572\n+                                          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                                          \u2502metadata?      \u2502\u2571         \u2502\n+                                          \u2502               \u2502          \u2502\n+                                          \u2502               \u2502          \u2502\n+                                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n+                                                  \u253c     \u253c prelude    \u2502\n+                                                  \u2502     \u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                                                  \u25cb\n+                                           shapes\u2571\u2502\u2572\n+        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+        \u2502 Applied Trait \u2502\u2572          shape \u2502  \u00ababstract\u00bb   \u2502\n+        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502     Shape     \u2502            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+        \u2502               \u2502\u2571                \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524            \u2502    ShapeID    \u2502\n+        \u2502               \u2502                 \u2502               \u2502            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+        \u2502               \u2502\u2572     applied-to \u2502               \u2502         id \u2502namespace      \u2502\n+        \u2502               \u2502\u2500\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502               \u2502\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2502shape_name     \u2502\n+        \u2502               \u2502\u2571traits          \u2502               \u2502            \u2502member_name?   \u2502\n+        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+Shape\n+    Shapes are named data definitions that describe the structure of an API.\n+    Shapes are referenced and connected by :ref:`shape IDs <shape-id>`.\n+    Relationships between shapes are formed by :ref:`members <member>` that\n+    target other shapes, properties of shapes like the ``input`` and\n+    ``output`` properties of an :ref:`operation <operation>`, and\n+    :ref:`applied traits <applying-traits>` that attach a trait to a shape.\n+Shape ID\n+    A :ref:`shape ID <shape-id>` is used to identify shapes defined in a\n+    model. For example, ``smithy.example#MyShape``,\n+    ``smithy.example#Foo$bar``, and ``Baz`` are all different kinds of shape\n+    IDs.\n+Trait\n+    :ref:`Traits <traits>` are specialized shapes that form the basis of\n+    Smithy's meta-model. Traits are applied to shapes to associate metadata\n+    to a shape. They are typically used by tools to influence validation,\n+    serialization, and code generation.\n+Applied trait\n+    An applied trait is an instance of a trait applied to a shape, configured\n+    using a :ref:`node value <node-value>`.\n+Model metadata\n+    :ref:`Metadata <metadata>` is a schema-less extensibility mechanism used\n+    to associate metadata to an entire model.\n+Prelude\n+    The :ref:`prelude <prelude>` defines various simple shapes and every\n+    trait defined in the core specification. All Smithy models automatically\n+    include the prelude.\n+\n+\n+.. _model-files:\n+\n+-----------\n+Model files\n+-----------\n+\n+Smithy models MAY be divided into multiple files so that they are easier to\n+maintain and evolve. One or more model files can be assembled (or merged)\n+together to form a semantic model. The model files that form a semantic model\n+are not required to all be defined in the same representation; some models can\n+be defined using the IDL and others can be defined using the JSON AST.\n+\n+Model files do not explicitly include other model files; this responsibility\n+is left to tooling to ensure that all necessary model files are merged\n+together to form a valid semantic model.\n+\n+.. _merging-models:\n+\n+Merging model files\n+===================\n+\n+Implementations MUST take the following steps to merge models together to load\n+the semantic model:\n+\n+#. Duplicate shape IDs, if found, MUST cause the model merge to fail.\n+   See :ref:`shape-id-conflicts` for more information.\n+#. Merge any conflicting applied traits using\n+   :ref:`trait conflict resolution  <trait-conflict-resolution>`.\n+#. Merge the metadata objects of both models using the steps defined\n+   in :ref:`merging-metadata`.\n+\n+\n+.. _metadata:\n+\n+--------\n+Metadata\n+--------\n+\n+Metadata is a schema-less extensibility mechanism used to associate\n+metadata to an entire model. For example, metadata is used to define\n+:ref:`validators <validator-definition>` and model-wide\n+:ref:`suppressions <suppression-definition>`. Metadata is defined\n+using an ``object`` :ref:`node value <node-value>`.\n+\n+\n+.. _merging-metadata:\n+\n+Merging metadata\n+================\n+\n+When a conflict occurs between top-level metadata key-value pairs,\n+metadata is merged using the following logic:\n+\n+1. If a metadata key is only present in one model, then the entry is valid\n+   and added to the merged model.\n+2. If both models contain the same key and both values are arrays, then\n+   the entry is valid; the values of both arrays are concatenated into a\n+   single array and added to the merged model.\n+3. If both models contain the same key and both values are exactly equal,\n+   then the conflict is ignored and the value is added to the merged model.\n+4. If both models contain the same key and the values do not both map to", "originalCommit": "f2dcfb01ad2d4e062325bcbb0680703847bb0ba3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "627e7e97e9a7cced278658dd56006717954c52f0", "url": "https://github.com/awslabs/smithy/commit/627e7e97e9a7cced278658dd56006717954c52f0", "message": "Refactor the spec to better explain the semantic model\n\nThe semantic model is a much more important concept now that we have two\nrepresentations for models (the AST and IDL), and these representations\nare meant to build up the same graph of shapes regardless of their\ndifferent syntactic features. The spec is also now laid out in an easier\nto understand way since it explains the high-level concepts, shapes, and\ntraits before diving into the details of the IDL ABNF.\n\nVarious aspects of the model have been clarified:\n\n* Applying traits externally is the same as applying them inline in the\n  semantic model.\n* Simplifications to the documentation_comment ABNF so that it is now\n  just one of the two kinds of `comment` productions.\n* A broader overview of the model, including transformations.\n* More information on namespaces, including that there can be multiple\n  namespaces loaded into the semantic model.\n* More information on how and why models would be merged together (it's\n  left up to tooling to combine and merge models, but the semantics of\n  merging models are described in the spec).\n* Lots of minor error corrections in the spec.\n* The special behavior around resolving relative shape IDs in the\n  \"conflicts\" property of the `trait` trait have been removed since that\n  is at odds with the rest of the model.\n\nThis commit moves various headings around and removes some pages, but\nredirects are issued when a removed page is visited.\n\nThis commit also ensures that requirements.txt is used for docs.\nSince we're using a github repo for the redirects package, we need to\ninstall it using a special syntax. There some docs around how to pull\nthis off with setup.py, but I couldn't get it to work:\nhttps://python-packaging.readthedocs.io/en/latest/dependencies.html#packages-not-on-pypi", "committedDate": "2020-07-16T00:19:39Z", "type": "commit"}, {"oid": "627e7e97e9a7cced278658dd56006717954c52f0", "url": "https://github.com/awslabs/smithy/commit/627e7e97e9a7cced278658dd56006717954c52f0", "message": "Refactor the spec to better explain the semantic model\n\nThe semantic model is a much more important concept now that we have two\nrepresentations for models (the AST and IDL), and these representations\nare meant to build up the same graph of shapes regardless of their\ndifferent syntactic features. The spec is also now laid out in an easier\nto understand way since it explains the high-level concepts, shapes, and\ntraits before diving into the details of the IDL ABNF.\n\nVarious aspects of the model have been clarified:\n\n* Applying traits externally is the same as applying them inline in the\n  semantic model.\n* Simplifications to the documentation_comment ABNF so that it is now\n  just one of the two kinds of `comment` productions.\n* A broader overview of the model, including transformations.\n* More information on namespaces, including that there can be multiple\n  namespaces loaded into the semantic model.\n* More information on how and why models would be merged together (it's\n  left up to tooling to combine and merge models, but the semantics of\n  merging models are described in the spec).\n* Lots of minor error corrections in the spec.\n* The special behavior around resolving relative shape IDs in the\n  \"conflicts\" property of the `trait` trait have been removed since that\n  is at odds with the rest of the model.\n\nThis commit moves various headings around and removes some pages, but\nredirects are issued when a removed page is visited.\n\nThis commit also ensures that requirements.txt is used for docs.\nSince we're using a github repo for the redirects package, we need to\ninstall it using a special syntax. There some docs around how to pull\nthis off with setup.py, but I couldn't get it to work:\nhttps://python-packaging.readthedocs.io/en/latest/dependencies.html#packages-not-on-pypi", "committedDate": "2020-07-16T00:19:39Z", "type": "forcePushed"}]}