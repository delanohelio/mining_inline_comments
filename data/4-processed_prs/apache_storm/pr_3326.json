{"pr_number": 3326, "pr_title": "[STORM-3692] Handle UID return from Files.getOwner()", "pr_createdAt": "2020-08-28T20:35:40Z", "pr_url": "https://github.com/apache/storm/pull/3326", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE2NzgzMA==", "url": "https://github.com/apache/storm/pull/3326#discussion_r481167830", "bodyText": "Should the last \"uid\" be \"pidUid\"?\nIt is not easy to distinguish \"user\" vs \"pidUser\", \"uid\" vs \"pidUid\". I suggest to change them to be\nactualUser vs expectedUser, actualUid vs expectedUid", "author": "Ethanlm", "createdAt": "2020-09-01T14:12:01Z", "path": "storm-server/src/main/java/org/apache/storm/utils/ServerUtils.java", "diffHunk": "@@ -1217,9 +1199,127 @@ public static boolean areAllProcessesDead(Map<String, Object> conf, String user,\n             }\n         }\n         if (cachedUserToUidMap.containsKey(user)) {\n-            return allDead = !ServerUtils.isAnyProcessAlive(pids, cachedUserToUidMap.get(user));\n+            return !ServerUtils.isAnyProcessAlive(pids, cachedUserToUidMap.get(user));\n         } else {\n-            return allDead = !ServerUtils.isAnyProcessAlive(pids, user);\n+            return !ServerUtils.isAnyProcessAlive(pids, user);\n         }\n     }\n+\n+    /**\n+     * Find if the process is alive using the existence of /proc/&lt;pid&gt; directory\n+     * owned by the supplied user. This is an alternative to \"ps -p pid -u uid\" command\n+     * used in {@link #isAnyPosixProcessAlive(Collection, int)}\n+     *\n+     * <p>\n+     * Processes are tracked using the existence of the directory \"/proc/&lt;pid&gt;\n+     * For each of the supplied PIDs, their PID directory is checked for existence and ownership\n+     * by the specified uid.\n+     * </p>\n+     *\n+     * @param pids Process IDs that need to be monitored for liveness\n+     * @param user the userId that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyPosixProcessPidDirAlive(Collection<Long> pids, String user) throws IOException {\n+        return isAnyPosixProcessPidDirAlive(pids, user, false);\n+    }\n+\n+    /**\n+     * Find if the process is alive using the existence of /proc/&lt;pid&gt; directory\n+     * owned by the supplied user. This is an alternative to \"ps -p pid -u uid\" command\n+     * used in {@link #isAnyPosixProcessAlive(Collection, int)}\n+     *\n+     * <p>\n+     * Processes are tracked using the existence of the directory \"/proc/&lt;pid&gt;\n+     * For each of the supplied PIDs, their PID directory is checked for existence and ownership\n+     * by the specified uid.\n+     * </p>\n+     *\n+     * @param pids Process IDs that need to be monitored for liveness\n+     * @param user the userId that is expected to own that process\n+     * @param mockFileOwnerToUid if true (used for testing), then convert File.owner to UID\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    @VisibleForTesting\n+    public static boolean isAnyPosixProcessPidDirAlive(Collection<Long> pids, String user, boolean mockFileOwnerToUid)\n+            throws IOException {\n+        File procDir = new File(\"/proc\");\n+        if (!procDir.exists()) {\n+            throw new IOException(\"Missing process directory \" + procDir.getAbsolutePath() + \": method not supported on \"\n+                    + \"os.name=\" + System.getProperty(\"os.name\"));\n+        }\n+        for (long pid: pids) {\n+            File pidDir = new File(procDir, String.valueOf(pid));\n+            if (!pidDir.exists()) {\n+                continue;\n+            }\n+            // check if existing process is owned by the specified user, if not, the process is dead\n+            String pidUser;\n+            try {\n+                pidUser = Files.getOwner(pidDir.toPath()).getName();\n+            } catch (NoSuchFileException ex) {\n+                continue; // process died before the user can be checked\n+            }\n+            if (mockFileOwnerToUid) {\n+                // code activated in testing to simulate Files.getOwner returning UID (which sometimes happens in runtime)\n+                if (StringUtils.isNumeric(pidUser)) {\n+                    LOG.info(\"Skip mocking, since owner {} of pidDir {} is already numeric\", pidUser, pidDir);\n+                } else {\n+                    Integer uid = cachedUserToUidMap.get(pidUser);\n+                    if (uid == null) {\n+                        uid = ServerUtils.getUserId(pidUser);\n+                        if (uid < 0) {\n+                            String err = String.format(\"Cannot get UID for %s, while mocking the owner of pidDir %s\",\n+                                    pidUser, pidDir.getAbsolutePath());\n+                            throw new IOException(err);\n+                        }\n+                        cachedUserToUidMap.put(pidUser, uid);\n+                        LOG.info(\"Found UID {} for {}, while mocking the owner of pidDir {}\", uid, pidUser, pidDir);\n+                    } else {\n+                        LOG.info(\"Found cached UID {} for {}, while mocking the owner of pidDir {}\", uid, pidUser, pidDir);\n+                    }\n+                    pidUser = String.valueOf(uid);\n+                }\n+            }\n+            //sometimes uid is returned instead of username - if so, try to convert and compare with uid\n+            if (StringUtils.isNumeric(pidUser)) {\n+                // numeric pidUser - this is UID\n+                LOG.debug(\"Process directory {} owner is uid={}\", pidDir, pidUser);\n+                int pidUid = Integer.parseInt(pidUser);\n+                Integer uid = cachedUserToUidMap.get(user);\n+                if (uid == null) {\n+                    uid = ServerUtils.getUserId(user);\n+                    if (uid < 0) {\n+                        String err = String.format(\"Cannot get uid for %s to compare with owner id=%d of process directory %s\",\n+                                user, pidUid, pidDir.getAbsolutePath());\n+                        throw new IOException(err);\n+                    }\n+                    cachedUserToUidMap.put(user, uid);\n+                }\n+                if (uid == pidUid) {\n+                    LOG.debug(\"Process {} is alive and owned by user {}/{}\", pid, user, uid);\n+                    return true;\n+                } else {\n+                    LOG.info(\"Prior process is dead, since directory {} owner {} is not same as expected user {}/{}, \"\n+                            + \"likely pid {} was reused for a new process for uid {}\", pidDir, pidUser, user, uid, pid, uid);", "originalCommit": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyNjQzNA==", "url": "https://github.com/apache/storm/pull/3326#discussion_r481326434", "bodyText": "renamed variables", "author": "bipinprasad", "createdAt": "2020-09-01T17:52:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE2NzgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzA4MQ==", "url": "https://github.com/apache/storm/pull/3326#discussion_r481173081", "bodyText": "Isn't this already present?\nhttps://github.com/apache/storm/blob/master/storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java#L184", "author": "Ethanlm", "createdAt": "2020-09-01T14:19:28Z", "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "diffHunk": "@@ -162,6 +185,191 @@ public void testGetUserId() throws Exception {\n         int uid1 = ServerUtils.getUserId(null);\n         Path p = Files.createTempFile(\"testGetUser\", \".txt\");\n         int uid2 = ServerUtils.getPathOwnerUid(p.toString());\n+        if (!p.toFile().delete()) {\n+            LOG.warn(\"Could not delete tempoary file {}\", p);\n+        }\n         assertEquals(\"User UID \" + uid1 + \" is not same as file \" + p.toString() + \" owner UID of \" + uid2, uid1, uid2);\n     }\n+\n+    @Test\n+    public void testIsAnyProcessPosixProcessPidDirAlive() throws IOException {", "originalCommit": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2NjE3Ng==", "url": "https://github.com/apache/storm/pull/3326#discussion_r481366176", "bodyText": "Yes. Something is not right. I will do a force push with all changes.", "author": "bipinprasad", "createdAt": "2020-09-01T19:00:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2NzUzOA==", "url": "https://github.com/apache/storm/pull/3326#discussion_r481367538", "bodyText": "You need to rebase on latest master. Then you should be able to see the conflicts/duplicates", "author": "Ethanlm", "createdAt": "2020-09-01T19:02:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzYyNA==", "url": "https://github.com/apache/storm/pull/3326#discussion_r481173624", "bodyText": "this method already exist?", "author": "Ethanlm", "createdAt": "2020-09-01T14:20:10Z", "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "diffHunk": "@@ -162,6 +185,191 @@ public void testGetUserId() throws Exception {\n         int uid1 = ServerUtils.getUserId(null);\n         Path p = Files.createTempFile(\"testGetUser\", \".txt\");\n         int uid2 = ServerUtils.getPathOwnerUid(p.toString());\n+        if (!p.toFile().delete()) {\n+            LOG.warn(\"Could not delete tempoary file {}\", p);\n+        }\n         assertEquals(\"User UID \" + uid1 + \" is not same as file \" + p.toString() + \" owner UID of \" + uid2, uid1, uid2);\n     }\n+\n+    @Test\n+    public void testIsAnyProcessPosixProcessPidDirAlive() throws IOException {\n+        final String testName = \"testIsAnyProcessPosixProcessPidDirAlive\";\n+        List<String> errors = new ArrayList<>();\n+        int maxPidCnt = 5;\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            LOG.info(\"{}: test cannot be run on Windows. Marked as successful\", testName);\n+            return;\n+        }\n+        final Path parentDir = Paths.get(\"/proc\");\n+        if (!parentDir.toFile().exists()) {\n+            LOG.info(\"{}: test cannot be run on system without process directory {}, os.name={}\",\n+                    testName, parentDir, System.getProperty(\"os.name\"));\n+            // check if we can get process id on this Posix system - testing test code, useful on Mac\n+            String cmd = \"/bin/sleep 10\";\n+            if (getPidOfPosixProcess(Runtime.getRuntime().exec(cmd), errors) < 0) {\n+                fail(String.format(\"%s: Cannot obtain process id for executed command \\\"%s\\\"\\n%s\",\n+                        testName, cmd, String.join(\"\\n\\t\", errors)));\n+            }\n+            return;\n+        }\n+        // Create processes and wait for their termination\n+        Set<Long> observables = new HashSet<>();\n+\n+        for (int i = 0 ; i < maxPidCnt ; i++) {\n+            String cmd = \"sleep 2000\";\n+            Process process = Runtime.getRuntime().exec(cmd);\n+            long pid = getPidOfPosixProcess(process, errors);\n+            LOG.info(\"{}: ({}) ran process \\\"{}\\\" with pid={}\", testName, i, cmd, pid);\n+            if (pid < 0) {\n+                String e = String.format(\"%s: (%d) Cannot obtain process id for executed command \\\"%s\\\"\", testName, i, cmd);\n+                errors.add(e);\n+                LOG.error(e);\n+                continue;\n+            }\n+            observables.add(pid);\n+        }\n+        String userName = System.getProperty(\"user.name\");\n+        // now kill processes one by one\n+        List<Long> pidList = new ArrayList<>(observables);\n+        final long processKillIntervalMs = 2000;\n+        for (int i = 0; i < pidList.size(); i++) {\n+            long pid = pidList.get(i);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds before kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            Runtime.getRuntime().exec(\"kill -9 \" + pid);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds after kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            boolean pidDirsAvailable = ServerUtils.isAnyPosixProcessPidDirAlive(observables, userName);\n+            if (i < pidList.size() - 1) {\n+                if (pidDirsAvailable) {\n+                    LOG.info(\"{}: ({}) Found existing process directories before killing last process\", testName, i);\n+                } else {\n+                    String e = String.format(\"%s: (%d) Found no existing process directories before killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                }\n+            } else {\n+                if (pidDirsAvailable) {\n+                    String e = String.format(\"%s: (%d) Found existing process directories after killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                } else {\n+                    LOG.info(\"{}: ({}) Found no existing process directories after killing last process\", testName, i);\n+                }\n+            }\n+        }\n+        if (!errors.isEmpty()) {\n+            fail(String.format(\"There are %d failures in test:\\n\\t%s\", errors.size(), String.join(\"\\n\\t\", errors)));\n+        }\n+    }\n+\n+\n+    /**\n+     * Simulate the production scenario where the owner of the process directory is sometimes returned as the\n+     * UID instead of user. This scenario is simulated by calling\n+     * {@link ServerUtils#isAnyPosixProcessPidDirAlive(Collection, String, boolean)} with the last parameter\n+     * set to true as well as false.\n+     *\n+     * @throws Exception on I/O exception\n+     */\n+    @Test\n+    public void testIsAnyPosixProcessPidDirAliveMockingFileOwnerUid() throws Exception {\n+        File procDir = new File(\"/proc\");\n+        if (!procDir.exists()) {\n+            LOG.info(\"Test testIsAnyPosixProcessPidDirAlive is designed to run on systems with /proc directory only, marking as success\");\n+            return;\n+        }\n+        Collection<Long> pids = getRunningProcessIds();\n+        assertFalse(pids.isEmpty());\n+\n+        for (int i = 0 ; i < 2 ; i++) {\n+            boolean mockFileOwnerToUid = (i % 2 == 0);\n+            // at least one pid will be owned by the current user (doing the testing)\n+            String currentUser = System.getProperty(\"user.name\");\n+            boolean status = ServerUtils.isAnyPosixProcessPidDirAlive(pids, currentUser, mockFileOwnerToUid);\n+            String err = String.format(\"(mockFileOwnerToUid=%s) Expecting user %s to own at least one process\",\n+                    mockFileOwnerToUid, currentUser);\n+            assertTrue(err, status);\n+        }\n+    }\n+\n+    /**\n+     * Make the best effort to obtain the Process ID from the Process object. Thus staying entirely with the JVM.\n+     *\n+     * @param p Process instance returned upon executing {@link Runtime#exec(String)}.\n+     * @param errors Populate errors when PID is a negative number.\n+     * @return positive PID upon success, otherwise negative.\n+     */\n+    private synchronized long getPidOfPosixProcess(Process p, List<String> errors) {\n+        Class<? extends Process> pClass = p.getClass();\n+        String pObjStr = ToStringBuilder.reflectionToString(p, ToStringStyle.SHORT_PREFIX_STYLE);\n+        String pclassName = pClass.getName();\n+        try {\n+            if (pclassName.equals(\"java.lang.UNIXProcess\")) {\n+                Field f = pClass.getDeclaredField(\"pid\");\n+                f.setAccessible(true);\n+                long pid = f.getLong(p);\n+                f.setAccessible(false);\n+                if (pid < 0) {\n+                    errors.add(\"\\t \\\"pid\\\" attribute in Process class \" + pclassName + \" returned -1, process=\" + pObjStr);\n+                }\n+                return pid;\n+            }\n+            for (Field f : pClass.getDeclaredFields()) {\n+                if (!f.getName().equalsIgnoreCase(\"pid\")) {\n+                    continue;\n+                }\n+                LOG.info(\"ServerUtilsTest.getPidOfPosixProcess(): found attribute {}#{}\", pclassName, f.getName());\n+                f.setAccessible(true);\n+                long pid = f.getLong(p);\n+                f.setAccessible(false);\n+                if (pid < 0) {\n+                    errors.add(\"\\t \\\"pid\\\" attribute in Process class \" + pclassName + \" returned -1, process=\" + pObjStr);\n+                }\n+                return pid;\n+            }\n+            // post JDK 9 there should be getPid() - future JDK-11 compatibility only for the sake of Travis test in community\n+            try {\n+                Method m = pClass.getDeclaredMethod(\"getPid\");\n+                LOG.info(\"ServerUtilsTest.getPidOfPosixProcess(): found method {}#getPid()\\n\", pclassName);\n+                long pid = (Long)m.invoke(p);\n+                if (pid < 0) {\n+                    errors.add(\"\\t \\\"getPid()\\\" method in Process class \" + pclassName + \" returned -1, process=\" + pObjStr);\n+                }\n+                return pid;\n+            } catch (SecurityException e) {\n+                errors.add(\"\\t getPid() method in Process class \" + pclassName + \" cannot be called: \" + e.getMessage() + \", process=\" + pObjStr);\n+                return -1;\n+            } catch (NoSuchMethodException e) {\n+                // ignore and try something else\n+            }\n+            errors.add(\"\\t Process class \" + pclassName + \" missing field \\\"pid\\\" and missing method \\\"getPid()\\\", process=\" + pObjStr);\n+            return -1;\n+        } catch (Exception e) {\n+            errors.add(\"\\t Exception in Process class \" + pclassName + \": \" + e.getMessage() + \", process=\" + pObjStr);\n+            e.printStackTrace();\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Sleep for specified milliseconds and return true if sleep was interrupted.\n+     *\n+     * @param milliSeconds number of milliseconds to sleep\n+     * @return true if sleep was interrupted, false otherwise.\n+     */\n+    private boolean sleepInterrupted(long milliSeconds) {", "originalCommit": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MDExNw==", "url": "https://github.com/apache/storm/pull/3326#discussion_r481340117", "bodyText": "I am not aware of any existing method with similar functionality.\nOr did you mean to ask why this is showing up in this pull request, since it should already exist.", "author": "bipinprasad", "createdAt": "2020-09-01T18:16:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2NzE3NA==", "url": "https://github.com/apache/storm/pull/3326#discussion_r481367174", "bodyText": "https://github.com/apache/storm/blob/master/storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java#L324\nThis method already exists in ServerUtilsTest (from your another merged PR)", "author": "Ethanlm", "createdAt": "2020-09-01T19:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzY1Ng==", "url": "https://github.com/apache/storm/pull/3326#discussion_r481173656", "bodyText": "this method already exist?", "author": "Ethanlm", "createdAt": "2020-09-01T14:20:14Z", "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "diffHunk": "@@ -162,6 +185,191 @@ public void testGetUserId() throws Exception {\n         int uid1 = ServerUtils.getUserId(null);\n         Path p = Files.createTempFile(\"testGetUser\", \".txt\");\n         int uid2 = ServerUtils.getPathOwnerUid(p.toString());\n+        if (!p.toFile().delete()) {\n+            LOG.warn(\"Could not delete tempoary file {}\", p);\n+        }\n         assertEquals(\"User UID \" + uid1 + \" is not same as file \" + p.toString() + \" owner UID of \" + uid2, uid1, uid2);\n     }\n+\n+    @Test\n+    public void testIsAnyProcessPosixProcessPidDirAlive() throws IOException {\n+        final String testName = \"testIsAnyProcessPosixProcessPidDirAlive\";\n+        List<String> errors = new ArrayList<>();\n+        int maxPidCnt = 5;\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            LOG.info(\"{}: test cannot be run on Windows. Marked as successful\", testName);\n+            return;\n+        }\n+        final Path parentDir = Paths.get(\"/proc\");\n+        if (!parentDir.toFile().exists()) {\n+            LOG.info(\"{}: test cannot be run on system without process directory {}, os.name={}\",\n+                    testName, parentDir, System.getProperty(\"os.name\"));\n+            // check if we can get process id on this Posix system - testing test code, useful on Mac\n+            String cmd = \"/bin/sleep 10\";\n+            if (getPidOfPosixProcess(Runtime.getRuntime().exec(cmd), errors) < 0) {\n+                fail(String.format(\"%s: Cannot obtain process id for executed command \\\"%s\\\"\\n%s\",\n+                        testName, cmd, String.join(\"\\n\\t\", errors)));\n+            }\n+            return;\n+        }\n+        // Create processes and wait for their termination\n+        Set<Long> observables = new HashSet<>();\n+\n+        for (int i = 0 ; i < maxPidCnt ; i++) {\n+            String cmd = \"sleep 2000\";\n+            Process process = Runtime.getRuntime().exec(cmd);\n+            long pid = getPidOfPosixProcess(process, errors);\n+            LOG.info(\"{}: ({}) ran process \\\"{}\\\" with pid={}\", testName, i, cmd, pid);\n+            if (pid < 0) {\n+                String e = String.format(\"%s: (%d) Cannot obtain process id for executed command \\\"%s\\\"\", testName, i, cmd);\n+                errors.add(e);\n+                LOG.error(e);\n+                continue;\n+            }\n+            observables.add(pid);\n+        }\n+        String userName = System.getProperty(\"user.name\");\n+        // now kill processes one by one\n+        List<Long> pidList = new ArrayList<>(observables);\n+        final long processKillIntervalMs = 2000;\n+        for (int i = 0; i < pidList.size(); i++) {\n+            long pid = pidList.get(i);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds before kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            Runtime.getRuntime().exec(\"kill -9 \" + pid);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds after kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            boolean pidDirsAvailable = ServerUtils.isAnyPosixProcessPidDirAlive(observables, userName);\n+            if (i < pidList.size() - 1) {\n+                if (pidDirsAvailable) {\n+                    LOG.info(\"{}: ({}) Found existing process directories before killing last process\", testName, i);\n+                } else {\n+                    String e = String.format(\"%s: (%d) Found no existing process directories before killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                }\n+            } else {\n+                if (pidDirsAvailable) {\n+                    String e = String.format(\"%s: (%d) Found existing process directories after killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                } else {\n+                    LOG.info(\"{}: ({}) Found no existing process directories after killing last process\", testName, i);\n+                }\n+            }\n+        }\n+        if (!errors.isEmpty()) {\n+            fail(String.format(\"There are %d failures in test:\\n\\t%s\", errors.size(), String.join(\"\\n\\t\", errors)));\n+        }\n+    }\n+\n+\n+    /**\n+     * Simulate the production scenario where the owner of the process directory is sometimes returned as the\n+     * UID instead of user. This scenario is simulated by calling\n+     * {@link ServerUtils#isAnyPosixProcessPidDirAlive(Collection, String, boolean)} with the last parameter\n+     * set to true as well as false.\n+     *\n+     * @throws Exception on I/O exception\n+     */\n+    @Test\n+    public void testIsAnyPosixProcessPidDirAliveMockingFileOwnerUid() throws Exception {\n+        File procDir = new File(\"/proc\");\n+        if (!procDir.exists()) {\n+            LOG.info(\"Test testIsAnyPosixProcessPidDirAlive is designed to run on systems with /proc directory only, marking as success\");\n+            return;\n+        }\n+        Collection<Long> pids = getRunningProcessIds();\n+        assertFalse(pids.isEmpty());\n+\n+        for (int i = 0 ; i < 2 ; i++) {\n+            boolean mockFileOwnerToUid = (i % 2 == 0);\n+            // at least one pid will be owned by the current user (doing the testing)\n+            String currentUser = System.getProperty(\"user.name\");\n+            boolean status = ServerUtils.isAnyPosixProcessPidDirAlive(pids, currentUser, mockFileOwnerToUid);\n+            String err = String.format(\"(mockFileOwnerToUid=%s) Expecting user %s to own at least one process\",\n+                    mockFileOwnerToUid, currentUser);\n+            assertTrue(err, status);\n+        }\n+    }\n+\n+    /**\n+     * Make the best effort to obtain the Process ID from the Process object. Thus staying entirely with the JVM.\n+     *\n+     * @param p Process instance returned upon executing {@link Runtime#exec(String)}.\n+     * @param errors Populate errors when PID is a negative number.\n+     * @return positive PID upon success, otherwise negative.\n+     */\n+    private synchronized long getPidOfPosixProcess(Process p, List<String> errors) {", "originalCommit": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MDA0OA==", "url": "https://github.com/apache/storm/pull/3326#discussion_r481340048", "bodyText": "I am not aware of any existing method with similar functionality.", "author": "bipinprasad", "createdAt": "2020-09-01T18:16:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2NzMxNQ==", "url": "https://github.com/apache/storm/pull/3326#discussion_r481367315", "bodyText": "https://github.com/apache/storm/blob/master/storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java#L266\nThis method already exists in ServerUtilsTest (from your another merged PR)", "author": "Ethanlm", "createdAt": "2020-09-01T19:02:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzgzOQ==", "url": "https://github.com/apache/storm/pull/3326#discussion_r481173839", "bodyText": "nit: more than 1 new line", "author": "Ethanlm", "createdAt": "2020-09-01T14:20:27Z", "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "diffHunk": "@@ -162,6 +185,191 @@ public void testGetUserId() throws Exception {\n         int uid1 = ServerUtils.getUserId(null);\n         Path p = Files.createTempFile(\"testGetUser\", \".txt\");\n         int uid2 = ServerUtils.getPathOwnerUid(p.toString());\n+        if (!p.toFile().delete()) {\n+            LOG.warn(\"Could not delete tempoary file {}\", p);\n+        }\n         assertEquals(\"User UID \" + uid1 + \" is not same as file \" + p.toString() + \" owner UID of \" + uid2, uid1, uid2);\n     }\n+\n+    @Test\n+    public void testIsAnyProcessPosixProcessPidDirAlive() throws IOException {\n+        final String testName = \"testIsAnyProcessPosixProcessPidDirAlive\";\n+        List<String> errors = new ArrayList<>();\n+        int maxPidCnt = 5;\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            LOG.info(\"{}: test cannot be run on Windows. Marked as successful\", testName);\n+            return;\n+        }\n+        final Path parentDir = Paths.get(\"/proc\");\n+        if (!parentDir.toFile().exists()) {\n+            LOG.info(\"{}: test cannot be run on system without process directory {}, os.name={}\",\n+                    testName, parentDir, System.getProperty(\"os.name\"));\n+            // check if we can get process id on this Posix system - testing test code, useful on Mac\n+            String cmd = \"/bin/sleep 10\";\n+            if (getPidOfPosixProcess(Runtime.getRuntime().exec(cmd), errors) < 0) {\n+                fail(String.format(\"%s: Cannot obtain process id for executed command \\\"%s\\\"\\n%s\",\n+                        testName, cmd, String.join(\"\\n\\t\", errors)));\n+            }\n+            return;\n+        }\n+        // Create processes and wait for their termination\n+        Set<Long> observables = new HashSet<>();\n+\n+        for (int i = 0 ; i < maxPidCnt ; i++) {\n+            String cmd = \"sleep 2000\";\n+            Process process = Runtime.getRuntime().exec(cmd);\n+            long pid = getPidOfPosixProcess(process, errors);\n+            LOG.info(\"{}: ({}) ran process \\\"{}\\\" with pid={}\", testName, i, cmd, pid);\n+            if (pid < 0) {\n+                String e = String.format(\"%s: (%d) Cannot obtain process id for executed command \\\"%s\\\"\", testName, i, cmd);\n+                errors.add(e);\n+                LOG.error(e);\n+                continue;\n+            }\n+            observables.add(pid);\n+        }\n+        String userName = System.getProperty(\"user.name\");\n+        // now kill processes one by one\n+        List<Long> pidList = new ArrayList<>(observables);\n+        final long processKillIntervalMs = 2000;\n+        for (int i = 0; i < pidList.size(); i++) {\n+            long pid = pidList.get(i);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds before kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            Runtime.getRuntime().exec(\"kill -9 \" + pid);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds after kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            boolean pidDirsAvailable = ServerUtils.isAnyPosixProcessPidDirAlive(observables, userName);\n+            if (i < pidList.size() - 1) {\n+                if (pidDirsAvailable) {\n+                    LOG.info(\"{}: ({}) Found existing process directories before killing last process\", testName, i);\n+                } else {\n+                    String e = String.format(\"%s: (%d) Found no existing process directories before killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                }\n+            } else {\n+                if (pidDirsAvailable) {\n+                    String e = String.format(\"%s: (%d) Found existing process directories after killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                } else {\n+                    LOG.info(\"{}: ({}) Found no existing process directories after killing last process\", testName, i);\n+                }\n+            }\n+        }\n+        if (!errors.isEmpty()) {\n+            fail(String.format(\"There are %d failures in test:\\n\\t%s\", errors.size(), String.join(\"\\n\\t\", errors)));\n+        }\n+    }\n+\n+", "originalCommit": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyNzgyNw==", "url": "https://github.com/apache/storm/pull/3326#discussion_r481327827", "bodyText": "removed", "author": "bipinprasad", "createdAt": "2020-09-01T17:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3NDI5Ng==", "url": "https://github.com/apache/storm/pull/3326#discussion_r481174296", "bodyText": "I would suggest to use Parameterized Test here.", "author": "Ethanlm", "createdAt": "2020-09-01T14:21:04Z", "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "diffHunk": "@@ -162,6 +185,191 @@ public void testGetUserId() throws Exception {\n         int uid1 = ServerUtils.getUserId(null);\n         Path p = Files.createTempFile(\"testGetUser\", \".txt\");\n         int uid2 = ServerUtils.getPathOwnerUid(p.toString());\n+        if (!p.toFile().delete()) {\n+            LOG.warn(\"Could not delete tempoary file {}\", p);\n+        }\n         assertEquals(\"User UID \" + uid1 + \" is not same as file \" + p.toString() + \" owner UID of \" + uid2, uid1, uid2);\n     }\n+\n+    @Test\n+    public void testIsAnyProcessPosixProcessPidDirAlive() throws IOException {\n+        final String testName = \"testIsAnyProcessPosixProcessPidDirAlive\";\n+        List<String> errors = new ArrayList<>();\n+        int maxPidCnt = 5;\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            LOG.info(\"{}: test cannot be run on Windows. Marked as successful\", testName);\n+            return;\n+        }\n+        final Path parentDir = Paths.get(\"/proc\");\n+        if (!parentDir.toFile().exists()) {\n+            LOG.info(\"{}: test cannot be run on system without process directory {}, os.name={}\",\n+                    testName, parentDir, System.getProperty(\"os.name\"));\n+            // check if we can get process id on this Posix system - testing test code, useful on Mac\n+            String cmd = \"/bin/sleep 10\";\n+            if (getPidOfPosixProcess(Runtime.getRuntime().exec(cmd), errors) < 0) {\n+                fail(String.format(\"%s: Cannot obtain process id for executed command \\\"%s\\\"\\n%s\",\n+                        testName, cmd, String.join(\"\\n\\t\", errors)));\n+            }\n+            return;\n+        }\n+        // Create processes and wait for their termination\n+        Set<Long> observables = new HashSet<>();\n+\n+        for (int i = 0 ; i < maxPidCnt ; i++) {\n+            String cmd = \"sleep 2000\";\n+            Process process = Runtime.getRuntime().exec(cmd);\n+            long pid = getPidOfPosixProcess(process, errors);\n+            LOG.info(\"{}: ({}) ran process \\\"{}\\\" with pid={}\", testName, i, cmd, pid);\n+            if (pid < 0) {\n+                String e = String.format(\"%s: (%d) Cannot obtain process id for executed command \\\"%s\\\"\", testName, i, cmd);\n+                errors.add(e);\n+                LOG.error(e);\n+                continue;\n+            }\n+            observables.add(pid);\n+        }\n+        String userName = System.getProperty(\"user.name\");\n+        // now kill processes one by one\n+        List<Long> pidList = new ArrayList<>(observables);\n+        final long processKillIntervalMs = 2000;\n+        for (int i = 0; i < pidList.size(); i++) {\n+            long pid = pidList.get(i);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds before kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            Runtime.getRuntime().exec(\"kill -9 \" + pid);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds after kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            boolean pidDirsAvailable = ServerUtils.isAnyPosixProcessPidDirAlive(observables, userName);\n+            if (i < pidList.size() - 1) {\n+                if (pidDirsAvailable) {\n+                    LOG.info(\"{}: ({}) Found existing process directories before killing last process\", testName, i);\n+                } else {\n+                    String e = String.format(\"%s: (%d) Found no existing process directories before killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                }\n+            } else {\n+                if (pidDirsAvailable) {\n+                    String e = String.format(\"%s: (%d) Found existing process directories after killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                } else {\n+                    LOG.info(\"{}: ({}) Found no existing process directories after killing last process\", testName, i);\n+                }\n+            }\n+        }\n+        if (!errors.isEmpty()) {\n+            fail(String.format(\"There are %d failures in test:\\n\\t%s\", errors.size(), String.join(\"\\n\\t\", errors)));\n+        }\n+    }\n+\n+\n+    /**\n+     * Simulate the production scenario where the owner of the process directory is sometimes returned as the\n+     * UID instead of user. This scenario is simulated by calling\n+     * {@link ServerUtils#isAnyPosixProcessPidDirAlive(Collection, String, boolean)} with the last parameter\n+     * set to true as well as false.\n+     *\n+     * @throws Exception on I/O exception\n+     */\n+    @Test\n+    public void testIsAnyPosixProcessPidDirAliveMockingFileOwnerUid() throws Exception {\n+        File procDir = new File(\"/proc\");\n+        if (!procDir.exists()) {\n+            LOG.info(\"Test testIsAnyPosixProcessPidDirAlive is designed to run on systems with /proc directory only, marking as success\");\n+            return;\n+        }\n+        Collection<Long> pids = getRunningProcessIds();\n+        assertFalse(pids.isEmpty());\n+\n+        for (int i = 0 ; i < 2 ; i++) {\n+            boolean mockFileOwnerToUid = (i % 2 == 0);", "originalCommit": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2eb307444810c34198eacaf8912ee207b99464cd", "url": "https://github.com/apache/storm/commit/2eb307444810c34198eacaf8912ee207b99464cd", "message": "[STORM-3692] Owner on /proc/pid is sometimes returned as UID instead of username in production. Handle this special case.", "committedDate": "2020-09-01T19:06:10Z", "type": "forcePushed"}, {"oid": "b46291e7510856de2e95886c4f7612f362241e42", "url": "https://github.com/apache/storm/commit/b46291e7510856de2e95886c4f7612f362241e42", "message": "[STORM-3692] Owner on /proc/pid is sometimes returned as UID instead of username in production. Handle this special case.", "committedDate": "2020-09-01T19:37:17Z", "type": "commit"}, {"oid": "b46291e7510856de2e95886c4f7612f362241e42", "url": "https://github.com/apache/storm/commit/b46291e7510856de2e95886c4f7612f362241e42", "message": "[STORM-3692] Owner on /proc/pid is sometimes returned as UID instead of username in production. Handle this special case.", "committedDate": "2020-09-01T19:37:17Z", "type": "forcePushed"}]}