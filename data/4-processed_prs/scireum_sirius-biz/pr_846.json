{"pr_number": 846, "pr_title": "Adds job to extract archives in the VFS", "pr_createdAt": "2020-08-27T13:47:41Z", "pr_url": "https://github.com/scireum/sirius-biz/pull/846", "timeline": [{"oid": "072fc712ae060c81a07f6a0f64bd2d8118ec5624", "url": "https://github.com/scireum/sirius-biz/commit/072fc712ae060c81a07f6a0f64bd2d8118ec5624", "message": "Adds 7z binding and UnzipHelper class.\nFIXES: SIRI-248", "committedDate": "2020-08-27T13:41:03Z", "type": "commit"}, {"oid": "fbff5a3972f357b7836377bb07786c96b33eb00c", "url": "https://github.com/scireum/sirius-biz/commit/fbff5a3972f357b7836377bb07786c96b33eb00c", "message": "Fixes typos", "committedDate": "2020-08-27T13:41:17Z", "type": "commit"}, {"oid": "b9a072635ab27d6a26f00bf5dfc813d3f3d9a9d9", "url": "https://github.com/scireum/sirius-biz/commit/b9a072635ab27d6a26f00bf5dfc813d3f3d9a9d9", "message": "Adds job to extract archives in their underlying vfs.\nFIXES: SIRI-248", "committedDate": "2020-08-27T13:42:16Z", "type": "commit"}, {"oid": "f2640de8c2ddf68d0e9b260ee11f1c5697e2bff1", "url": "https://github.com/scireum/sirius-biz/commit/f2640de8c2ddf68d0e9b260ee11f1c5697e2bff1", "message": "Removes required flag from the boolean parameter as it is inherently required by default (true/false)", "committedDate": "2020-08-27T13:51:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQzOTI4NA==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478439284", "bodyText": "maybe SimpleBatchJobFactory?", "author": "andyHa", "createdAt": "2020-08-27T13:57:15Z", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.batch.BatchJob;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.UnzipHelper;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.nls.NLS;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link UnzipHelper#getSupportedFileExtensions()}.\n+ */\n+public class VirtualFileExtractionJob extends BatchJob {", "originalCommit": "f2640de8c2ddf68d0e9b260ee11f1c5697e2bff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQzOTc1OA==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478439758", "bodyText": "this lambda is waaaay too long", "author": "andyHa", "createdAt": "2020-08-27T13:57:52Z", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.batch.BatchJob;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.UnzipHelper;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.nls.NLS;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link UnzipHelper#getSupportedFileExtensions()}.\n+ */\n+public class VirtualFileExtractionJob extends BatchJob {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static UnzipHelper unzipHelper;\n+\n+    VirtualFileExtractionJob(ProcessContext process) {\n+        super(process);\n+    }\n+\n+    @Override\n+    public void execute() throws Exception {\n+        VirtualFile sourceFile = process.require(VirtualFileExtractionJobFactory.SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory =\n+                VirtualFileExtractionJobFactory.DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting =\n+                process.require(VirtualFileExtractionJobFactory.OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload().ifPresent(fileHandle -> {\n+            File tempFile = fileHandle.getFile();\n+            try {\n+                UnzipHelper.unzip(tempFile,\n+                                  null,\n+                                  (status, data, filePath, filesProcessedSoFar, bytesProcessedSoFar, totalBytes) -> {\n+                                      VirtualFile targetFile =", "originalCommit": "f2640de8c2ddf68d0e9b260ee11f1c5697e2bff1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODkxMjY1NA==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478912654", "bodyText": "Lambda params come from sirius.biz.util.ArchiveHelper.ArchiveExtractCallback#call. Maybe an option would be to instantiate a new instance of an inner class instead of using this lambda?", "author": "bwiedmann", "createdAt": "2020-08-28T08:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQzOTc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ0MDU1MQ==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478440551", "bodyText": "i'd output the progrss just as title and also maybe ratelimit this (TaskContext should have a shouldUpdateTitle or the like)", "author": "andyHa", "createdAt": "2020-08-27T13:58:56Z", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.batch.BatchJob;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.UnzipHelper;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.nls.NLS;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link UnzipHelper#getSupportedFileExtensions()}.\n+ */\n+public class VirtualFileExtractionJob extends BatchJob {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static UnzipHelper unzipHelper;\n+\n+    VirtualFileExtractionJob(ProcessContext process) {\n+        super(process);\n+    }\n+\n+    @Override\n+    public void execute() throws Exception {\n+        VirtualFile sourceFile = process.require(VirtualFileExtractionJobFactory.SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory =\n+                VirtualFileExtractionJobFactory.DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting =\n+                process.require(VirtualFileExtractionJobFactory.OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload().ifPresent(fileHandle -> {\n+            File tempFile = fileHandle.getFile();\n+            try {\n+                UnzipHelper.unzip(tempFile,\n+                                  null,\n+                                  (status, data, filePath, filesProcessedSoFar, bytesProcessedSoFar, totalBytes) -> {\n+                                      VirtualFile targetFile =\n+                                              vfs.resolve(vfs.makePath(targetDirectory.name(), filePath));\n+                                      if (targetFile.exists() && !shouldOverwriteExisting) {\n+                                          process.log(ProcessLog.info()\n+                                                                .withMessage(NLS.fmtr(\n+                                                                        \"VirtualFileExtractionJob.skippingOverwrite\")\n+                                                                                .set(\"targetPath\", targetFile.path())\n+                                                                                .format()));\n+                                          return false;\n+                                      }\n+\n+                                      try {\n+                                          if (targetFile.exists() && shouldOverwriteExisting) {\n+                                              process.log(ProcessLog.info()\n+                                                                    .withMessage(NLS.fmtr(\n+                                                                            \"VirtualFileExtractionJob.extractingFile\")\n+                                                                                    .set(\"filePath\", filePath)\n+                                                                                    .set(\"targetPath\",\n+                                                                                         targetFile.path())\n+                                                                                    .set(\"fileSize\",\n+                                                                                         NLS.formatSize(data.size()))\n+                                                                                    .format()));\n+                                          } else {\n+                                              process.log(ProcessLog.info()\n+                                                                    .withMessage(NLS.fmtr(\n+                                                                            \"VirtualFileExtractionJob.overwritingFile\")\n+                                                                                    .set(\"filePath\", filePath)\n+                                                                                    .set(\"targetPath\",\n+                                                                                         targetFile.path())\n+                                                                                    .set(\"fileSize\",\n+                                                                                         NLS.formatSize(data.size()))\n+                                                                                    .format()));\n+                                          }\n+\n+                                          targetFile.consumeStream(data.openStream(), data.size());\n+                                      } catch (IOException e) {\n+                                          process.handle(e);\n+                                      }\n+\n+                                      process.log(ProcessLog.info()", "originalCommit": "f2640de8c2ddf68d0e9b260ee11f1c5697e2bff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ0MTExMw==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478441113", "bodyText": "private", "author": "andyHa", "createdAt": "2020-08-27T13:59:45Z", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJobFactory.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.JobCategory;\n+import sirius.biz.jobs.batch.BatchJob;\n+import sirius.biz.jobs.batch.DefaultBatchProcessFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.util.UnzipHelper;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Register;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Provides a factory for file extraction.\n+ */\n+@Register\n+public class VirtualFileExtractionJobFactory extends DefaultBatchProcessFactory {\n+\n+    public static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",", "originalCommit": "f2640de8c2ddf68d0e9b260ee11f1c5697e2bff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ0MTY3Mg==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478441672", "bodyText": "s.a. SimpleBatchJobFactory", "author": "andyHa", "createdAt": "2020-08-27T14:00:29Z", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJobFactory.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.JobCategory;\n+import sirius.biz.jobs.batch.BatchJob;\n+import sirius.biz.jobs.batch.DefaultBatchProcessFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.util.UnzipHelper;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Register;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Provides a factory for file extraction.\n+ */\n+@Register\n+public class VirtualFileExtractionJobFactory extends DefaultBatchProcessFactory {", "originalCommit": "f2640de8c2ddf68d0e9b260ee11f1c5697e2bff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ0MjI4NA==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478442284", "bodyText": "document why this can be null and how to handle this..", "author": "andyHa", "createdAt": "2020-08-27T14:01:22Z", "path": "src/main/java/sirius/biz/util/UnzipHelper.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.util;\n+\n+import com.google.common.io.ByteSource;\n+import net.sf.sevenzipjbinding.ArchiveFormat;\n+import net.sf.sevenzipjbinding.ExtractAskMode;\n+import net.sf.sevenzipjbinding.ExtractOperationResult;\n+import net.sf.sevenzipjbinding.IArchiveExtractCallback;\n+import net.sf.sevenzipjbinding.IInArchive;\n+import net.sf.sevenzipjbinding.ISequentialOutStream;\n+import net.sf.sevenzipjbinding.PropID;\n+import net.sf.sevenzipjbinding.SevenZip;\n+import net.sf.sevenzipjbinding.SevenZipException;\n+import net.sf.sevenzipjbinding.SevenZipNativeInitializationException;\n+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;\n+import sirius.kernel.commons.Explain;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.health.Exceptions;\n+import sirius.kernel.nls.NLS;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to handle and unzip archive files like zip, 7z, tar, ...\n+ */\n+public class UnzipHelper {\n+\n+    private UnzipHelper() {\n+    }\n+\n+    /**\n+     * Builds a list of supported file extensions that can be extracted, all lowercased.\n+     *\n+     * @return list of supported file extensions that can be extracted.\n+     */\n+    public static List<String> getSupportedFileExtensions() {\n+        return Collections.unmodifiableList(Arrays.stream(ArchiveFormat.values())\n+                                                  .map(archiveFormat -> archiveFormat.getMethodName().toLowerCase())\n+                                                  .collect(Collectors.toList()));\n+    }\n+\n+    /**\n+     * Checks if the file extension is an archive which can be processed by 7z.\n+     *\n+     * @param fileExtension the extension to check\n+     * @return <tt>true</tt> when archive, <tt>false</tt> otherwise\n+     */\n+    public static boolean isArchiveFile(@Nullable String fileExtension) {\n+        return fileExtension != null && Arrays.stream(ArchiveFormat.values())\n+                                              .map(ArchiveFormat::getMethodName)\n+                                              .anyMatch(fileExtension::equalsIgnoreCase);\n+    }\n+\n+    /**\n+     * iterates over the items of an archive file\n+     *\n+     * @param tmpFile           the archive file\n+     * @param filter            will be called for each archive item. {@code unzipItemCallback} will be only called for\n+     *                          this item if this filter unzipItemCallback\n+     *                          returns true\n+     * @param unzipItemCallback will be called for each archive item until it returns false\n+     * @throws IOException on extraction failure\n+     */\n+    public static void unzip(File tmpFile, Function<String, Boolean> filter, UnzipItemCallback unzipItemCallback)\n+            throws IOException {\n+        try {\n+            initSevenZipLib();\n+        } catch (SevenZipNativeInitializationException e) {\n+            throw new IOException(NLS.fmtr(\"XMLImporter.sevenZipInitFailed\").set(\"details\", e.getMessage()).format());\n+        }\n+\n+        try (RandomAccessFile randomAccessFile = new RandomAccessFile(tmpFile, \"r\")) {\n+            RandomAccessFileInStream inputStream = new RandomAccessFileInStream(randomAccessFile);\n+            try (IInArchive archive = SevenZip.openInArchive(null, inputStream)) {\n+                archive.extract(getCompleteArchiveIndices(archive),\n+                                false,\n+                                new MyExtractCallback(archive, filter, unzipItemCallback));\n+            }\n+        }\n+    }\n+\n+    private static void initSevenZipLib() throws SevenZipNativeInitializationException {\n+        if (SevenZip.getUsedPlatform() == null) {\n+            SevenZip.initSevenZipFromPlatformJAR();\n+        }\n+    }\n+\n+    @Nonnull\n+    private static int[] getCompleteArchiveIndices(@Nonnull IInArchive archive) throws SevenZipException {\n+        // could be done as a one-liner with Guava, but this one is about 10x faster\n+        int[] indices = new int[archive.getNumberOfItems()];\n+        for (int i = 0; i < indices.length; i++) {\n+            indices[i] = i;\n+        }\n+        return indices;\n+    }\n+\n+    /**\n+     * Defines a callback interface used during archive extraction.\n+     */\n+    public interface UnzipItemCallback {\n+\n+        /**\n+         * Defines a method called for each item being extracted from an archive.\n+         *\n+         * @param status              the extract result\n+         * @param data                the raw data being exported\n+         * @param fileName            file name as defined in the archive\n+         * @param filesProcessedSoFar amount of files processed in the progress\n+         * @param bytesProcessedSoFar amount of bytes processed in the progress\n+         * @param totalBytes          total amount of bytes processed in the progress\n+         * @return <tt>true</tt> to continue with extraction or <tt>false</tt> to abort\n+         */\n+        boolean call(ExtractOperationResult status,\n+                     @Nullable ByteSource data,", "originalCommit": "f2640de8c2ddf68d0e9b260ee11f1c5697e2bff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "995dd44600cf36d3f39a1cbaa0383ff425f359dd", "url": "https://github.com/scireum/sirius-biz/commit/995dd44600cf36d3f39a1cbaa0383ff425f359dd", "message": "Collects the overwrite file parameter so it gets visible on the job page", "committedDate": "2020-08-27T14:02:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ0Mzg2OA==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478443868", "bodyText": "also check TaskContext.isActive every now and then?", "author": "andyHa", "createdAt": "2020-08-27T14:03:43Z", "path": "src/main/java/sirius/biz/util/UnzipHelper.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.util;\n+\n+import com.google.common.io.ByteSource;\n+import net.sf.sevenzipjbinding.ArchiveFormat;\n+import net.sf.sevenzipjbinding.ExtractAskMode;\n+import net.sf.sevenzipjbinding.ExtractOperationResult;\n+import net.sf.sevenzipjbinding.IArchiveExtractCallback;\n+import net.sf.sevenzipjbinding.IInArchive;\n+import net.sf.sevenzipjbinding.ISequentialOutStream;\n+import net.sf.sevenzipjbinding.PropID;\n+import net.sf.sevenzipjbinding.SevenZip;\n+import net.sf.sevenzipjbinding.SevenZipException;\n+import net.sf.sevenzipjbinding.SevenZipNativeInitializationException;\n+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;\n+import sirius.kernel.commons.Explain;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.health.Exceptions;\n+import sirius.kernel.nls.NLS;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to handle and unzip archive files like zip, 7z, tar, ...\n+ */\n+public class UnzipHelper {\n+\n+    private UnzipHelper() {\n+    }\n+\n+    /**\n+     * Builds a list of supported file extensions that can be extracted, all lowercased.\n+     *\n+     * @return list of supported file extensions that can be extracted.\n+     */\n+    public static List<String> getSupportedFileExtensions() {\n+        return Collections.unmodifiableList(Arrays.stream(ArchiveFormat.values())\n+                                                  .map(archiveFormat -> archiveFormat.getMethodName().toLowerCase())\n+                                                  .collect(Collectors.toList()));\n+    }\n+\n+    /**\n+     * Checks if the file extension is an archive which can be processed by 7z.\n+     *\n+     * @param fileExtension the extension to check\n+     * @return <tt>true</tt> when archive, <tt>false</tt> otherwise\n+     */\n+    public static boolean isArchiveFile(@Nullable String fileExtension) {\n+        return fileExtension != null && Arrays.stream(ArchiveFormat.values())\n+                                              .map(ArchiveFormat::getMethodName)\n+                                              .anyMatch(fileExtension::equalsIgnoreCase);\n+    }\n+\n+    /**\n+     * iterates over the items of an archive file\n+     *\n+     * @param tmpFile           the archive file\n+     * @param filter            will be called for each archive item. {@code unzipItemCallback} will be only called for\n+     *                          this item if this filter unzipItemCallback\n+     *                          returns true\n+     * @param unzipItemCallback will be called for each archive item until it returns false\n+     * @throws IOException on extraction failure\n+     */\n+    public static void unzip(File tmpFile, Function<String, Boolean> filter, UnzipItemCallback unzipItemCallback)\n+            throws IOException {\n+        try {\n+            initSevenZipLib();\n+        } catch (SevenZipNativeInitializationException e) {\n+            throw new IOException(NLS.fmtr(\"XMLImporter.sevenZipInitFailed\").set(\"details\", e.getMessage()).format());\n+        }\n+\n+        try (RandomAccessFile randomAccessFile = new RandomAccessFile(tmpFile, \"r\")) {\n+            RandomAccessFileInStream inputStream = new RandomAccessFileInStream(randomAccessFile);\n+            try (IInArchive archive = SevenZip.openInArchive(null, inputStream)) {\n+                archive.extract(getCompleteArchiveIndices(archive),\n+                                false,\n+                                new MyExtractCallback(archive, filter, unzipItemCallback));\n+            }\n+        }\n+    }\n+\n+    private static void initSevenZipLib() throws SevenZipNativeInitializationException {\n+        if (SevenZip.getUsedPlatform() == null) {\n+            SevenZip.initSevenZipFromPlatformJAR();\n+        }\n+    }\n+\n+    @Nonnull\n+    private static int[] getCompleteArchiveIndices(@Nonnull IInArchive archive) throws SevenZipException {\n+        // could be done as a one-liner with Guava, but this one is about 10x faster\n+        int[] indices = new int[archive.getNumberOfItems()];\n+        for (int i = 0; i < indices.length; i++) {\n+            indices[i] = i;\n+        }\n+        return indices;\n+    }\n+\n+    /**\n+     * Defines a callback interface used during archive extraction.\n+     */\n+    public interface UnzipItemCallback {\n+\n+        /**\n+         * Defines a method called for each item being extracted from an archive.\n+         *\n+         * @param status              the extract result\n+         * @param data                the raw data being exported\n+         * @param fileName            file name as defined in the archive\n+         * @param filesProcessedSoFar amount of files processed in the progress\n+         * @param bytesProcessedSoFar amount of bytes processed in the progress\n+         * @param totalBytes          total amount of bytes processed in the progress\n+         * @return <tt>true</tt> to continue with extraction or <tt>false</tt> to abort\n+         */\n+        boolean call(ExtractOperationResult status,\n+                     @Nullable ByteSource data,\n+                     String fileName,\n+                     long filesProcessedSoFar,\n+                     long bytesProcessedSoFar,\n+                     long totalBytes);\n+    }\n+\n+    private static class MyExtractCallback implements IArchiveExtractCallback {\n+\n+        private final IInArchive inArchive;\n+        private final Function<String, Boolean> filter;\n+        private final UnzipItemCallback unzipItemCallback;\n+        private ByteArrayOutputStream buffer;\n+        private boolean skipExtraction;\n+        private boolean stop;\n+        private String filePath;\n+        private long filesProcessedSoFar;\n+        private long bytesProcessedSoFar;\n+        private long totalBytes;\n+\n+        MyExtractCallback(IInArchive inArchive, Function<String, Boolean> filter, UnzipItemCallback unzipItemCallback) {\n+            this.inArchive = inArchive;\n+            this.filter = filter;\n+            this.unzipItemCallback = unzipItemCallback;\n+        }\n+\n+        @Override\n+        public ISequentialOutStream getStream(int index, ExtractAskMode extractAskMode) throws SevenZipException {\n+            if (stop || extractAskMode != ExtractAskMode.EXTRACT) {\n+                return null;\n+            }\n+\n+            Boolean isFolder = (Boolean) inArchive.getProperty(index, PropID.IS_FOLDER);\n+            filePath = (String) inArchive.getProperty(index, PropID.PATH);\n+            String fileName = Files.getFilenameAndExtension(filePath);\n+            Integer attributes = (Integer) inArchive.getProperty(index, PropID.ATTRIBUTES);\n+\n+            skipExtraction = false;\n+            if (isFolder != null) {\n+                skipExtraction = isFolder;\n+            }\n+            if (attributes != null) {\n+                skipExtraction |= (attributes & PropID.AttributesBitMask.FILE_ATTRIBUTE_HIDDEN) != 0;\n+            }\n+            if (filePath != null) {\n+                skipExtraction |= filePath.startsWith(\"__MACOSX\");\n+                if (filter != null) {\n+                    skipExtraction |= !filter.apply(filePath);\n+                }\n+            }\n+            if (fileName != null) {\n+                // need to filter hidden files (starting with dot), because some tar implementations create\n+                // hidden index files (ending with xml, too)\n+                skipExtraction |= fileName.startsWith(\".\");\n+            }\n+\n+            if (skipExtraction) {\n+                return null;\n+            }\n+\n+            filePath = fixEncodingProblems(filePath, (String) inArchive.getProperty(index, PropID.HOST_OS));\n+\n+            buffer = new ByteArrayOutputStream();\n+            return data -> {\n+                try {\n+                    buffer.write(data);\n+                    return data.length;\n+                } catch (IOException e) {\n+                    throw new SevenZipException(e);\n+                }\n+            };\n+        }\n+\n+        @Nonnull\n+        private String fixEncodingProblems(String filePath, String hostOS) {\n+            String newFilePath = fixWindowsEncoding(filePath, hostOS);\n+            newFilePath = fixOtherStrangeBug(newFilePath);\n+            return newFilePath;\n+        }\n+\n+        @Nonnull\n+        private String fixWindowsEncoding(@Nonnull String filePath, String hostOS) {\n+            byte[] filePathBytes = filePath.getBytes(StandardCharsets.UTF_8);\n+\n+            if (!\"fat\".equalsIgnoreCase(hostOS)) {\n+                // Windows writes FAT as \"Host OS\" in zip files.\n+                // We expect this behaviour only on zip files that were created on Windows.\n+                return filePath;\n+            }\n+            for (int i = 0; i < filePathBytes.length - 1; i++) {\n+                // Windows saves zip entry file paths in IBM437 Codepage,\n+                // the 7z lib interpretates them as Unicode code points and we retrieve them in UTF-8.\n+                //\n+                // This way\n+                // ... special characters in IBM437 (80..bf) become Control Characters (c2 80..9f)\n+                //     or other special characters (c2 a0..bf) in UTF-8\n+                // ... special characters in IBM437 (c0..ff) become other special characters (c3 80..bf) in UTF-8\n+                //\n+                // We cannot safely distinguish whether special characters are an encoding problem or are there in purpose,\n+                // but we can search for UTF-8 control characters (c2 80..9f) that usually aren't present in file names.\n+                boolean hasEncodingProblem = filePathBytes[i] == (byte) 0xc2\n+                                             && filePathBytes[i + 1] >= (byte) 0x80\n+                                             && filePathBytes[i + 1] <= (byte) 0x9f;\n+                // detect \u00df (IBM437 e1) that comes as \u00e1 (UTF-8 c3 a1)\n+                hasEncodingProblem |= filePathBytes[i] == (byte) 0xc3 && filePathBytes[i + 1] == (byte) 0xa1;\n+\n+                if (hasEncodingProblem) {\n+                    try {\n+                        // the string has an encoding error with very very very high probability, repair it...\n+                        return new String(filePath.getBytes(StandardCharsets.ISO_8859_1), \"IBM437\");\n+                    } catch (UnsupportedEncodingException e) {\n+                        Exceptions.ignore(e);\n+                        break;\n+                    }\n+                }\n+            }\n+            return filePath;\n+        }\n+\n+        @Nonnull\n+        @SuppressWarnings(\"squid:S1067\")\n+        @Explain(\"Reducing operators won't increase code visibility\")\n+        private String fixOtherStrangeBug(@Nonnull String filePath) {\n+            byte[] filePathBytes = filePath.getBytes(StandardCharsets.UTF_8);\n+            for (int i = 0; i < filePathBytes.length - 3; i++) {\n+                // The bug interpretates UTF-8 as ISO-8859-1 (which doubles the number of characters)\n+                // and converts them back to UTF-8.\n+                // This way all possible 2-byte UTF-8 bytes (c0..df 80..bf) become 4 bytes: (c3 80..9f c2 80..bf)\n+                if (filePathBytes[i] == (byte) 0xc3\n+                    && filePathBytes[i + 1] >= (byte) 0x80\n+                    && filePathBytes[i + 1] <= (byte) 0x9f\n+                    && filePathBytes[i + 2] == (byte) 0xc2\n+                    && filePathBytes[i + 3] >= (byte) 0x80\n+                    && filePathBytes[i + 3] <= (byte) 0xbf) {\n+                    // the string has an encoding error with very high probability, repair it...\n+                    return new String(filePath.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8);\n+                }\n+            }\n+            return filePath;\n+        }\n+\n+        @Override\n+        public void prepareOperation(ExtractAskMode extractAskMode) throws SevenZipException {\n+            // do nothing\n+        }\n+\n+        @Override\n+        public void setOperationResult(ExtractOperationResult extractOperationResult) throws SevenZipException {\n+            if (stop || skipExtraction) {", "originalCommit": "f2640de8c2ddf68d0e9b260ee11f1c5697e2bff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUwNDMyMA==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478504320", "bodyText": "IDE missing auto EOF at file end", "author": "idlira", "createdAt": "2020-08-27T15:25:52Z", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.batch.BatchJob;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.UnzipHelper;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.nls.NLS;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link UnzipHelper#getSupportedFileExtensions()}.\n+ */\n+public class VirtualFileExtractionJob extends BatchJob {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static UnzipHelper unzipHelper;\n+\n+    VirtualFileExtractionJob(ProcessContext process) {\n+        super(process);\n+    }\n+\n+    @Override\n+    public void execute() throws Exception {\n+        VirtualFile sourceFile = process.require(VirtualFileExtractionJobFactory.SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory =\n+                VirtualFileExtractionJobFactory.DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting =\n+                process.require(VirtualFileExtractionJobFactory.OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload().ifPresent(fileHandle -> {\n+            File tempFile = fileHandle.getFile();\n+            try {\n+                UnzipHelper.unzip(tempFile,\n+                                  null,\n+                                  (status, data, filePath, filesProcessedSoFar, bytesProcessedSoFar, totalBytes) -> {\n+                                      VirtualFile targetFile =\n+                                              vfs.resolve(vfs.makePath(targetDirectory.name(), filePath));\n+                                      if (targetFile.exists() && !shouldOverwriteExisting) {\n+                                          process.log(ProcessLog.info()\n+                                                                .withMessage(NLS.fmtr(\n+                                                                        \"VirtualFileExtractionJob.skippingOverwrite\")\n+                                                                                .set(\"targetPath\", targetFile.path())\n+                                                                                .format()));\n+                                          return false;\n+                                      }\n+\n+                                      try {\n+                                          if (targetFile.exists() && shouldOverwriteExisting) {\n+                                              process.log(ProcessLog.info()\n+                                                                    .withMessage(NLS.fmtr(\n+                                                                            \"VirtualFileExtractionJob.extractingFile\")\n+                                                                                    .set(\"filePath\", filePath)\n+                                                                                    .set(\"targetPath\",\n+                                                                                         targetFile.path())\n+                                                                                    .set(\"fileSize\",\n+                                                                                         NLS.formatSize(data.size()))\n+                                                                                    .format()));\n+                                          } else {\n+                                              process.log(ProcessLog.info()\n+                                                                    .withMessage(NLS.fmtr(\n+                                                                            \"VirtualFileExtractionJob.overwritingFile\")\n+                                                                                    .set(\"filePath\", filePath)\n+                                                                                    .set(\"targetPath\",\n+                                                                                         targetFile.path())\n+                                                                                    .set(\"fileSize\",\n+                                                                                         NLS.formatSize(data.size()))\n+                                                                                    .format()));\n+                                          }\n+\n+                                          targetFile.consumeStream(data.openStream(), data.size());\n+                                      } catch (IOException e) {\n+                                          process.handle(e);\n+                                      }\n+\n+                                      process.log(ProcessLog.info()\n+                                                            .withMessage(NLS.fmtr(\"VirtualFileExtractionJob.progress\")\n+                                                                            .set(\"status\", status)\n+                                                                            .set(\"filesProcessedSoFar\",\n+                                                                                 filesProcessedSoFar)\n+                                                                            .set(\"dataProcessedSoFar\",\n+                                                                                 NLS.formatSize(bytesProcessedSoFar))\n+                                                                            .set(\"sizeTotal\",\n+                                                                                 NLS.formatSize(totalBytes))\n+                                                                            .format()));\n+                                      return true;\n+                                  });\n+            } catch (IOException e) {\n+                process.handle(e);\n+            } finally {\n+                Files.delete(tempFile);\n+            }\n+        });\n+    }\n+}", "originalCommit": "b9a072635ab27d6a26f00bf5dfc813d3f3d9a9d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUwNTc4OQ==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478505789", "bodyText": "rename to ArchiveHelper?\nsince we handle several archive types and probably want to build archives as well (not only extract)", "author": "idlira", "createdAt": "2020-08-27T15:27:33Z", "path": "src/main/java/sirius/biz/util/UnzipHelper.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.util;\n+\n+import com.google.common.io.ByteSource;\n+import net.sf.sevenzipjbinding.ArchiveFormat;\n+import net.sf.sevenzipjbinding.ExtractAskMode;\n+import net.sf.sevenzipjbinding.ExtractOperationResult;\n+import net.sf.sevenzipjbinding.IArchiveExtractCallback;\n+import net.sf.sevenzipjbinding.IInArchive;\n+import net.sf.sevenzipjbinding.ISequentialOutStream;\n+import net.sf.sevenzipjbinding.PropID;\n+import net.sf.sevenzipjbinding.SevenZip;\n+import net.sf.sevenzipjbinding.SevenZipException;\n+import net.sf.sevenzipjbinding.SevenZipNativeInitializationException;\n+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;\n+import sirius.kernel.commons.Explain;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.health.Exceptions;\n+import sirius.kernel.nls.NLS;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to handle and unzip archive files like zip, 7z, tar, ...\n+ */\n+public class UnzipHelper {", "originalCommit": "072fc712ae060c81a07f6a0f64bd2d8118ec5624", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUwNjIzNA==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478506234", "bodyText": "rename to extract", "author": "idlira", "createdAt": "2020-08-27T15:28:11Z", "path": "src/main/java/sirius/biz/util/UnzipHelper.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.util;\n+\n+import com.google.common.io.ByteSource;\n+import net.sf.sevenzipjbinding.ArchiveFormat;\n+import net.sf.sevenzipjbinding.ExtractAskMode;\n+import net.sf.sevenzipjbinding.ExtractOperationResult;\n+import net.sf.sevenzipjbinding.IArchiveExtractCallback;\n+import net.sf.sevenzipjbinding.IInArchive;\n+import net.sf.sevenzipjbinding.ISequentialOutStream;\n+import net.sf.sevenzipjbinding.PropID;\n+import net.sf.sevenzipjbinding.SevenZip;\n+import net.sf.sevenzipjbinding.SevenZipException;\n+import net.sf.sevenzipjbinding.SevenZipNativeInitializationException;\n+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;\n+import sirius.kernel.commons.Explain;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.health.Exceptions;\n+import sirius.kernel.nls.NLS;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to handle and unzip archive files like zip, 7z, tar, ...\n+ */\n+public class UnzipHelper {\n+\n+    private UnzipHelper() {\n+    }\n+\n+    /**\n+     * Builds a list of supported file extensions that can be extracted, all lowercased.\n+     *\n+     * @return list of supported file extensions that can be extracted.\n+     */\n+    public static List<String> getSupportedFileExtensions() {\n+        return Collections.unmodifiableList(Arrays.stream(ArchiveFormat.values())\n+                                                  .map(archiveFormat -> archiveFormat.getMethodName().toLowerCase())\n+                                                  .collect(Collectors.toList()));\n+    }\n+\n+    /**\n+     * Checks if the file extension is an archive which can be processed by 7z.\n+     *\n+     * @param fileExtension the extension to check\n+     * @return <tt>true</tt> when archive, <tt>false</tt> otherwise\n+     */\n+    public static boolean isArchiveFile(@Nullable String fileExtension) {\n+        return fileExtension != null && Arrays.stream(ArchiveFormat.values())\n+                                              .map(ArchiveFormat::getMethodName)\n+                                              .anyMatch(fileExtension::equalsIgnoreCase);\n+    }\n+\n+    /**\n+     * iterates over the items of an archive file\n+     *\n+     * @param tmpFile           the archive file\n+     * @param filter            will be called for each archive item. {@code unzipItemCallback} will be only called for\n+     *                          this item if this filter unzipItemCallback\n+     *                          returns true\n+     * @param unzipItemCallback will be called for each archive item until it returns false\n+     * @throws IOException on extraction failure\n+     */\n+    public static void unzip(File tmpFile, Function<String, Boolean> filter, UnzipItemCallback unzipItemCallback)", "originalCommit": "072fc712ae060c81a07f6a0f64bd2d8118ec5624", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUwNjkzMw==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478506933", "bodyText": "rename to ArchiveExtractCallback?", "author": "idlira", "createdAt": "2020-08-27T15:29:08Z", "path": "src/main/java/sirius/biz/util/UnzipHelper.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.util;\n+\n+import com.google.common.io.ByteSource;\n+import net.sf.sevenzipjbinding.ArchiveFormat;\n+import net.sf.sevenzipjbinding.ExtractAskMode;\n+import net.sf.sevenzipjbinding.ExtractOperationResult;\n+import net.sf.sevenzipjbinding.IArchiveExtractCallback;\n+import net.sf.sevenzipjbinding.IInArchive;\n+import net.sf.sevenzipjbinding.ISequentialOutStream;\n+import net.sf.sevenzipjbinding.PropID;\n+import net.sf.sevenzipjbinding.SevenZip;\n+import net.sf.sevenzipjbinding.SevenZipException;\n+import net.sf.sevenzipjbinding.SevenZipNativeInitializationException;\n+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;\n+import sirius.kernel.commons.Explain;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.health.Exceptions;\n+import sirius.kernel.nls.NLS;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to handle and unzip archive files like zip, 7z, tar, ...\n+ */\n+public class UnzipHelper {\n+\n+    private UnzipHelper() {\n+    }\n+\n+    /**\n+     * Builds a list of supported file extensions that can be extracted, all lowercased.\n+     *\n+     * @return list of supported file extensions that can be extracted.\n+     */\n+    public static List<String> getSupportedFileExtensions() {\n+        return Collections.unmodifiableList(Arrays.stream(ArchiveFormat.values())\n+                                                  .map(archiveFormat -> archiveFormat.getMethodName().toLowerCase())\n+                                                  .collect(Collectors.toList()));\n+    }\n+\n+    /**\n+     * Checks if the file extension is an archive which can be processed by 7z.\n+     *\n+     * @param fileExtension the extension to check\n+     * @return <tt>true</tt> when archive, <tt>false</tt> otherwise\n+     */\n+    public static boolean isArchiveFile(@Nullable String fileExtension) {\n+        return fileExtension != null && Arrays.stream(ArchiveFormat.values())\n+                                              .map(ArchiveFormat::getMethodName)\n+                                              .anyMatch(fileExtension::equalsIgnoreCase);\n+    }\n+\n+    /**\n+     * iterates over the items of an archive file\n+     *\n+     * @param tmpFile           the archive file\n+     * @param filter            will be called for each archive item. {@code unzipItemCallback} will be only called for\n+     *                          this item if this filter unzipItemCallback\n+     *                          returns true\n+     * @param unzipItemCallback will be called for each archive item until it returns false\n+     * @throws IOException on extraction failure\n+     */\n+    public static void unzip(File tmpFile, Function<String, Boolean> filter, UnzipItemCallback unzipItemCallback)\n+            throws IOException {\n+        try {\n+            initSevenZipLib();\n+        } catch (SevenZipNativeInitializationException e) {\n+            throw new IOException(NLS.fmtr(\"XMLImporter.sevenZipInitFailed\").set(\"details\", e.getMessage()).format());\n+        }\n+\n+        try (RandomAccessFile randomAccessFile = new RandomAccessFile(tmpFile, \"r\")) {\n+            RandomAccessFileInStream inputStream = new RandomAccessFileInStream(randomAccessFile);\n+            try (IInArchive archive = SevenZip.openInArchive(null, inputStream)) {\n+                archive.extract(getCompleteArchiveIndices(archive),\n+                                false,\n+                                new MyExtractCallback(archive, filter, unzipItemCallback));\n+            }\n+        }\n+    }\n+\n+    private static void initSevenZipLib() throws SevenZipNativeInitializationException {\n+        if (SevenZip.getUsedPlatform() == null) {\n+            SevenZip.initSevenZipFromPlatformJAR();\n+        }\n+    }\n+\n+    @Nonnull\n+    private static int[] getCompleteArchiveIndices(@Nonnull IInArchive archive) throws SevenZipException {\n+        // could be done as a one-liner with Guava, but this one is about 10x faster\n+        int[] indices = new int[archive.getNumberOfItems()];\n+        for (int i = 0; i < indices.length; i++) {\n+            indices[i] = i;\n+        }\n+        return indices;\n+    }\n+\n+    /**\n+     * Defines a callback interface used during archive extraction.\n+     */\n+    public interface UnzipItemCallback {", "originalCommit": "072fc712ae060c81a07f6a0f64bd2d8118ec5624", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUwODQ4Mg==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r478508482", "bodyText": "My is a bit \"ugly\"\nperhaps LocalExtractCallback (if resides as inner class)", "author": "idlira", "createdAt": "2020-08-27T15:31:20Z", "path": "src/main/java/sirius/biz/util/UnzipHelper.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.util;\n+\n+import com.google.common.io.ByteSource;\n+import net.sf.sevenzipjbinding.ArchiveFormat;\n+import net.sf.sevenzipjbinding.ExtractAskMode;\n+import net.sf.sevenzipjbinding.ExtractOperationResult;\n+import net.sf.sevenzipjbinding.IArchiveExtractCallback;\n+import net.sf.sevenzipjbinding.IInArchive;\n+import net.sf.sevenzipjbinding.ISequentialOutStream;\n+import net.sf.sevenzipjbinding.PropID;\n+import net.sf.sevenzipjbinding.SevenZip;\n+import net.sf.sevenzipjbinding.SevenZipException;\n+import net.sf.sevenzipjbinding.SevenZipNativeInitializationException;\n+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;\n+import sirius.kernel.commons.Explain;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.health.Exceptions;\n+import sirius.kernel.nls.NLS;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to handle and unzip archive files like zip, 7z, tar, ...\n+ */\n+public class UnzipHelper {\n+\n+    private UnzipHelper() {\n+    }\n+\n+    /**\n+     * Builds a list of supported file extensions that can be extracted, all lowercased.\n+     *\n+     * @return list of supported file extensions that can be extracted.\n+     */\n+    public static List<String> getSupportedFileExtensions() {\n+        return Collections.unmodifiableList(Arrays.stream(ArchiveFormat.values())\n+                                                  .map(archiveFormat -> archiveFormat.getMethodName().toLowerCase())\n+                                                  .collect(Collectors.toList()));\n+    }\n+\n+    /**\n+     * Checks if the file extension is an archive which can be processed by 7z.\n+     *\n+     * @param fileExtension the extension to check\n+     * @return <tt>true</tt> when archive, <tt>false</tt> otherwise\n+     */\n+    public static boolean isArchiveFile(@Nullable String fileExtension) {\n+        return fileExtension != null && Arrays.stream(ArchiveFormat.values())\n+                                              .map(ArchiveFormat::getMethodName)\n+                                              .anyMatch(fileExtension::equalsIgnoreCase);\n+    }\n+\n+    /**\n+     * iterates over the items of an archive file\n+     *\n+     * @param tmpFile           the archive file\n+     * @param filter            will be called for each archive item. {@code unzipItemCallback} will be only called for\n+     *                          this item if this filter unzipItemCallback\n+     *                          returns true\n+     * @param unzipItemCallback will be called for each archive item until it returns false\n+     * @throws IOException on extraction failure\n+     */\n+    public static void unzip(File tmpFile, Function<String, Boolean> filter, UnzipItemCallback unzipItemCallback)\n+            throws IOException {\n+        try {\n+            initSevenZipLib();\n+        } catch (SevenZipNativeInitializationException e) {\n+            throw new IOException(NLS.fmtr(\"XMLImporter.sevenZipInitFailed\").set(\"details\", e.getMessage()).format());\n+        }\n+\n+        try (RandomAccessFile randomAccessFile = new RandomAccessFile(tmpFile, \"r\")) {\n+            RandomAccessFileInStream inputStream = new RandomAccessFileInStream(randomAccessFile);\n+            try (IInArchive archive = SevenZip.openInArchive(null, inputStream)) {\n+                archive.extract(getCompleteArchiveIndices(archive),\n+                                false,\n+                                new MyExtractCallback(archive, filter, unzipItemCallback));\n+            }\n+        }\n+    }\n+\n+    private static void initSevenZipLib() throws SevenZipNativeInitializationException {\n+        if (SevenZip.getUsedPlatform() == null) {\n+            SevenZip.initSevenZipFromPlatformJAR();\n+        }\n+    }\n+\n+    @Nonnull\n+    private static int[] getCompleteArchiveIndices(@Nonnull IInArchive archive) throws SevenZipException {\n+        // could be done as a one-liner with Guava, but this one is about 10x faster\n+        int[] indices = new int[archive.getNumberOfItems()];\n+        for (int i = 0; i < indices.length; i++) {\n+            indices[i] = i;\n+        }\n+        return indices;\n+    }\n+\n+    /**\n+     * Defines a callback interface used during archive extraction.\n+     */\n+    public interface UnzipItemCallback {\n+\n+        /**\n+         * Defines a method called for each item being extracted from an archive.\n+         *\n+         * @param status              the extract result\n+         * @param data                the raw data being exported\n+         * @param fileName            file name as defined in the archive\n+         * @param filesProcessedSoFar amount of files processed in the progress\n+         * @param bytesProcessedSoFar amount of bytes processed in the progress\n+         * @param totalBytes          total amount of bytes processed in the progress\n+         * @return <tt>true</tt> to continue with extraction or <tt>false</tt> to abort\n+         */\n+        boolean call(ExtractOperationResult status,\n+                     @Nullable ByteSource data,\n+                     String fileName,\n+                     long filesProcessedSoFar,\n+                     long bytesProcessedSoFar,\n+                     long totalBytes);\n+    }\n+\n+    private static class MyExtractCallback implements IArchiveExtractCallback {", "originalCommit": "072fc712ae060c81a07f6a0f64bd2d8118ec5624", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6ed5b957a0fd8c0600dad39a1c4884f1b84f5014", "url": "https://github.com/scireum/sirius-biz/commit/6ed5b957a0fd8c0600dad39a1c4884f1b84f5014", "message": "Applies suggestions from code review", "committedDate": "2020-08-28T05:53:30Z", "type": "commit"}, {"oid": "649dff2fc23832027d0cdee40eec7c88621dc54f", "url": "https://github.com/scireum/sirius-biz/commit/649dff2fc23832027d0cdee40eec7c88621dc54f", "message": "Applies suggestions from code review", "committedDate": "2020-08-28T07:58:58Z", "type": "commit"}, {"oid": "b4a6185979dfadf291f5cc0d56d7f0a14f2c0e24", "url": "https://github.com/scireum/sirius-biz/commit/b4a6185979dfadf291f5cc0d56d7f0a14f2c0e24", "message": "Fixes extraction to a given subfolder, corrects logging", "committedDate": "2020-08-28T08:21:34Z", "type": "commit"}, {"oid": "c3e3b868caa31f5e05f3a09141167dca8815619a", "url": "https://github.com/scireum/sirius-biz/commit/c3e3b868caa31f5e05f3a09141167dca8815619a", "message": "Adds active task checks", "committedDate": "2020-08-28T11:41:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkyODg3Mg==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r479928872", "bodyText": "Am Besten ne Funktion raus ziehen", "author": "qw3ry", "createdAt": "2020-08-31T06:47:29Z", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.RateLimit;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;\n+\n+    private static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",\n+                                                                            \"$VirtualFileExtractionJob.sourceParameter\")\n+            .withAcceptedExtensionsList(ArchiveHelper.getSupportedFileExtensions())\n+            .withDescription(\"$VirtualFileExtractionJob.sourceParameter.help\")\n+            .markRequired();\n+\n+    private static final FileOrDirectoryParameter DESTINATION_PARAMETER = new FileOrDirectoryParameter(\n+            \"destinationParameter\",\n+            \"$VirtualFileExtractionJob.destinationParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.destinationParameter.help\");\n+\n+    private static final BooleanParameter OVERWRITE_EXISTING_FILES_PARAMETER = new BooleanParameter(\n+            \"overwriteExistingFilesParameter\",\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter.help\");\n+    private static final String TARGET_PATH = \"targetPath\";\n+\n+    @Override\n+    protected void execute(ProcessContext process) throws Exception {\n+        VirtualFile sourceFile = process.require(SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory = DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting = process.require(OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload()\n+                  .ifPresent(getArchiveExtractCallback(process, shouldOverwriteExisting, targetDirectory));\n+    }\n+\n+    @Nonnull\n+    private Consumer<FileHandle> getArchiveExtractCallback(ProcessContext process,\n+                                                           boolean shouldOverwriteExisting,\n+                                                           VirtualFile targetDirectory) {\n+        return fileHandle -> {\n+            File tempFile = fileHandle.getFile();\n+            if (!TaskContext.get().isActive()) {\n+                Files.delete(tempFile);\n+                return;\n+            }\n+\n+            try {\n+                ArchiveHelper.extract(tempFile,\n+                                      null,\n+                                      (status, data, filePath, filesProcessedSoFar, bytesProcessedSoFar, totalBytes) -> {\n+                                          if (!TaskContext.get().isActive()) {\n+                                              return false;\n+                                          }\n+                                          VirtualFile targetFile =\n+                                                  vfs.resolve(vfs.makePath(targetDirectory.path(), filePath));\n+                                          if (targetFile.exists() && !shouldOverwriteExisting) {\n+                                              process.log(ProcessLog.info()\n+                                                                    .withMessage(NLS.fmtr(\n+                                                                            \"VirtualFileExtractionJob.skippingOverwrite\")\n+                                                                                    .set(TARGET_PATH, targetFile.path())\n+                                                                                    .format()));\n+                                              return false;\n+                                          }\n+\n+                                          uploadFile(process, shouldOverwriteExisting, data, filePath, targetFile);\n+                                          updateState(status, filesProcessedSoFar, bytesProcessedSoFar, totalBytes);\n+\n+                                          return true;\n+                                      });", "originalCommit": "c3e3b868caa31f5e05f3a09141167dca8815619a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEyNjg3Nw==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r480126877", "bodyText": "Stimme mich hierzu mit @andyHa ab, welche M\u00f6glichkeiten hier Sinn machen. Bspw. w\u00e4re ein Consumer denkbar, der optional beim Entpacken \u00fcbergeben werden kann. Das Callback hat aktuell haupts\u00e4chlich Progress-Funktionalit\u00e4t um dem Aufrufer den Status mitteilen zu k\u00f6nnen. Rausziehen der Stoplogik d\u00fcrfte hingegen eher schwierig werden, da diese aktuell ja auch vom Callback mitgehandled wird.", "author": "bwiedmann", "createdAt": "2020-08-31T13:21:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkyODg3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE4MTY5Ng==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r480181696", "bodyText": "kann man die kilometer lambda net einfach in eine funktion rausziehen und bissle zerlegen?", "author": "andyHa", "createdAt": "2020-08-31T14:48:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkyODg3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDIxMjY1Mw==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r480212653", "bodyText": "Wie besprochen zerlegt und sauber als Predicate durchgereicht.", "author": "bwiedmann", "createdAt": "2020-08-31T15:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkyODg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkzMTM2OQ==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r479931369", "bodyText": "Gerne als extra Klasse. Private inner class ist zwar ganz h\u00fcbsch, aber die Datei wird un\u00fcbersichtlich gro\u00df finde ich", "author": "qw3ry", "createdAt": "2020-08-31T06:53:34Z", "path": "src/main/java/sirius/biz/util/ArchiveHelper.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.util;\n+\n+import com.google.common.io.ByteSource;\n+import net.sf.sevenzipjbinding.ArchiveFormat;\n+import net.sf.sevenzipjbinding.ExtractAskMode;\n+import net.sf.sevenzipjbinding.ExtractOperationResult;\n+import net.sf.sevenzipjbinding.IArchiveExtractCallback;\n+import net.sf.sevenzipjbinding.IInArchive;\n+import net.sf.sevenzipjbinding.ISequentialOutStream;\n+import net.sf.sevenzipjbinding.PropID;\n+import net.sf.sevenzipjbinding.SevenZip;\n+import net.sf.sevenzipjbinding.SevenZipException;\n+import net.sf.sevenzipjbinding.SevenZipNativeInitializationException;\n+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Explain;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.health.Exceptions;\n+import sirius.kernel.nls.NLS;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to handle and extract archive files like zip, 7z, tar, ...\n+ * <p>\n+ * For a list of supported formats have a look at {@link ArchiveFormat#values()}.\n+ */\n+public class ArchiveHelper {\n+\n+    private ArchiveHelper() {\n+    }\n+\n+    /**\n+     * Builds a list of supported file extensions that can be extracted, all lowercased.\n+     *\n+     * @return list of supported file extensions that can be extracted.\n+     */\n+    public static List<String> getSupportedFileExtensions() {\n+        return Collections.unmodifiableList(Arrays.stream(ArchiveFormat.values())\n+                                                  .map(archiveFormat -> archiveFormat.getMethodName().toLowerCase())\n+                                                  .collect(Collectors.toList()));\n+    }\n+\n+    /**\n+     * Checks if the file extension is an archive which can be processed by 7z.\n+     *\n+     * @param fileExtension the extension to check\n+     * @return <tt>true</tt> when archive, <tt>false</tt> otherwise\n+     */\n+    public static boolean isArchiveFile(@Nullable String fileExtension) {\n+        return fileExtension != null && Arrays.stream(ArchiveFormat.values())\n+                                              .map(ArchiveFormat::getMethodName)\n+                                              .anyMatch(fileExtension::equalsIgnoreCase);\n+    }\n+\n+    /**\n+     * iterates over the items of an archive file\n+     *\n+     * @param tmpFile                the archive file\n+     * @param filter                 will be called for each archive item. {@code unzipItemCallback} will be only called for this item if this filter unzipItemCallback returns true\n+     * @param archiveExtractCallback will be called for each archive item until it returns false\n+     * @throws IOException on extraction failure\n+     */\n+    public static void extract(File tmpFile,\n+                               Function<String, Boolean> filter,\n+                               ArchiveExtractCallback archiveExtractCallback) throws IOException {\n+        try {\n+            initSevenZipLib();\n+        } catch (SevenZipNativeInitializationException e) {\n+            throw new IOException(NLS.fmtr(\"XMLImporter.sevenZipInitFailed\").set(\"details\", e.getMessage()).format());\n+        }\n+\n+        try (RandomAccessFile randomAccessFile = new RandomAccessFile(tmpFile, \"r\")) {\n+            RandomAccessFileInStream inputStream = new RandomAccessFileInStream(randomAccessFile);\n+            try (IInArchive archive = SevenZip.openInArchive(null, inputStream)) {\n+                archive.extract(getCompleteArchiveIndices(archive),\n+                                false,\n+                                new LocalExtractCallback(archive, filter, archiveExtractCallback));\n+            }\n+        }\n+    }\n+\n+    private static void initSevenZipLib() throws SevenZipNativeInitializationException {\n+        if (SevenZip.getUsedPlatform() == null) {\n+            SevenZip.initSevenZipFromPlatformJAR();\n+        }\n+    }\n+\n+    @Nonnull\n+    private static int[] getCompleteArchiveIndices(@Nonnull IInArchive archive) throws SevenZipException {\n+        // could be done as a one-liner with Guava, but this one is about 10x faster\n+        int[] indices = new int[archive.getNumberOfItems()];\n+        for (int i = 0; i < indices.length; i++) {\n+            indices[i] = i;\n+        }\n+        return indices;\n+    }\n+\n+    /**\n+     * Defines a callback interface used during archive extraction.\n+     */\n+    public interface ArchiveExtractCallback {\n+\n+        /**\n+         * Defines a method called for each item being extracted from an archive.\n+         *\n+         * @param status              the extract result\n+         * @param data                the raw data being exported\n+         * @param fileName            file name as defined in the archive\n+         * @param filesProcessedSoFar amount of files processed in the progress\n+         * @param bytesProcessedSoFar amount of bytes processed in the progress\n+         * @param totalBytes          total amount of bytes processed in the progress\n+         * @return <tt>true</tt> to continue with extraction or <tt>false</tt> to abort\n+         */\n+        boolean call(ExtractOperationResult status,\n+                     @Nullable ByteSource data,\n+                     String fileName,\n+                     long filesProcessedSoFar,\n+                     long bytesProcessedSoFar,\n+                     long totalBytes);\n+    }\n+\n+    private static class LocalExtractCallback implements IArchiveExtractCallback {", "originalCommit": "c3e3b868caa31f5e05f3a09141167dca8815619a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk3ODk5MA==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r479978990", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    TaskContext tc = TaskContext.get();\n          \n          \n            \n                    RateLimit stateUpdateLimiter = tc.shouldUpdateState();\n          \n          \n            \n                    if (stateUpdateLimiter.check()) {\n          \n          \n            \n                        tc.setState(NLS.fmtr(\"VirtualFileExtractionJob.progress\")\n          \n          \n            \n                    TaskContext context = TaskContext.get();\n          \n          \n            \n                    RateLimit stateUpdateLimiter = context.shouldUpdateState();\n          \n          \n            \n                    if (stateUpdateLimiter.check()) {\n          \n          \n            \n                        context.setState(NLS.fmtr(\"VirtualFileExtractionJob.progress\")", "author": "sabieber", "createdAt": "2020-08-31T08:32:49Z", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.RateLimit;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;\n+\n+    private static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",\n+                                                                            \"$VirtualFileExtractionJob.sourceParameter\")\n+            .withAcceptedExtensionsList(ArchiveHelper.getSupportedFileExtensions())\n+            .withDescription(\"$VirtualFileExtractionJob.sourceParameter.help\")\n+            .markRequired();\n+\n+    private static final FileOrDirectoryParameter DESTINATION_PARAMETER = new FileOrDirectoryParameter(\n+            \"destinationParameter\",\n+            \"$VirtualFileExtractionJob.destinationParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.destinationParameter.help\");\n+\n+    private static final BooleanParameter OVERWRITE_EXISTING_FILES_PARAMETER = new BooleanParameter(\n+            \"overwriteExistingFilesParameter\",\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter.help\");\n+    private static final String TARGET_PATH = \"targetPath\";\n+\n+    @Override\n+    protected void execute(ProcessContext process) throws Exception {\n+        VirtualFile sourceFile = process.require(SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory = DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting = process.require(OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload()\n+                  .ifPresent(getArchiveExtractCallback(process, shouldOverwriteExisting, targetDirectory));\n+    }\n+\n+    @Nonnull\n+    private Consumer<FileHandle> getArchiveExtractCallback(ProcessContext process,\n+                                                           boolean shouldOverwriteExisting,\n+                                                           VirtualFile targetDirectory) {\n+        return fileHandle -> {\n+            File tempFile = fileHandle.getFile();\n+            if (!TaskContext.get().isActive()) {\n+                Files.delete(tempFile);\n+                return;\n+            }\n+\n+            try {\n+                ArchiveHelper.extract(tempFile,\n+                                      null,\n+                                      (status, data, filePath, filesProcessedSoFar, bytesProcessedSoFar, totalBytes) -> {\n+                                          if (!TaskContext.get().isActive()) {\n+                                              return false;\n+                                          }\n+                                          VirtualFile targetFile =\n+                                                  vfs.resolve(vfs.makePath(targetDirectory.path(), filePath));\n+                                          if (targetFile.exists() && !shouldOverwriteExisting) {\n+                                              process.log(ProcessLog.info()\n+                                                                    .withMessage(NLS.fmtr(\n+                                                                            \"VirtualFileExtractionJob.skippingOverwrite\")\n+                                                                                    .set(TARGET_PATH, targetFile.path())\n+                                                                                    .format()));\n+                                              return false;\n+                                          }\n+\n+                                          uploadFile(process, shouldOverwriteExisting, data, filePath, targetFile);\n+                                          updateState(status, filesProcessedSoFar, bytesProcessedSoFar, totalBytes);\n+\n+                                          return true;\n+                                      });\n+            } catch (IOException e) {\n+                process.handle(e);\n+            } finally {\n+                Files.delete(tempFile);\n+            }\n+        };\n+    }\n+\n+    private void uploadFile(ProcessContext process,\n+                            boolean shouldOverwriteExisting,\n+                            com.google.common.io.ByteSource data,\n+                            String filePath,\n+                            VirtualFile targetFile) {\n+        try {\n+            if (targetFile.exists() && shouldOverwriteExisting) {\n+                process.log(ProcessLog.info()\n+                                      .withMessage(NLS.fmtr(\"VirtualFileExtractionJob.overwritingFile\")\n+                                                      .set(\"filePath\", filePath)\n+                                                      .set(TARGET_PATH, targetFile.path())\n+                                                      .set(\"fileSize\", NLS.formatSize(data.size()))\n+                                                      .format()));\n+            } else {\n+                process.log(ProcessLog.info()\n+                                      .withMessage(NLS.fmtr(\"VirtualFileExtractionJob.extractingFile\")\n+                                                      .set(\"filePath\", filePath)\n+                                                      .set(TARGET_PATH, targetFile.path())\n+                                                      .set(\"fileSize\", NLS.formatSize(data.size()))\n+                                                      .format()));\n+            }\n+\n+            try (InputStream inputStream = data.openStream()) {\n+                targetFile.consumeStream(inputStream, data.size());\n+            }\n+        } catch (IOException e) {\n+            process.handle(e);\n+        }\n+    }\n+\n+    private void updateState(net.sf.sevenzipjbinding.ExtractOperationResult status,\n+                             long filesProcessedSoFar,\n+                             long bytesProcessedSoFar,\n+                             long totalBytes) {\n+        TaskContext tc = TaskContext.get();\n+        RateLimit stateUpdateLimiter = tc.shouldUpdateState();\n+        if (stateUpdateLimiter.check()) {\n+            tc.setState(NLS.fmtr(\"VirtualFileExtractionJob.progress\")", "originalCommit": "c3e3b868caa31f5e05f3a09141167dca8815619a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk3OTYzNg==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r479979636", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * iterates over the items of an archive file\n          \n          \n            \n                 * Iterates over the items of an archive file.", "author": "sabieber", "createdAt": "2020-08-31T08:34:04Z", "path": "src/main/java/sirius/biz/util/ArchiveHelper.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.util;\n+\n+import com.google.common.io.ByteSource;\n+import net.sf.sevenzipjbinding.ArchiveFormat;\n+import net.sf.sevenzipjbinding.ExtractAskMode;\n+import net.sf.sevenzipjbinding.ExtractOperationResult;\n+import net.sf.sevenzipjbinding.IArchiveExtractCallback;\n+import net.sf.sevenzipjbinding.IInArchive;\n+import net.sf.sevenzipjbinding.ISequentialOutStream;\n+import net.sf.sevenzipjbinding.PropID;\n+import net.sf.sevenzipjbinding.SevenZip;\n+import net.sf.sevenzipjbinding.SevenZipException;\n+import net.sf.sevenzipjbinding.SevenZipNativeInitializationException;\n+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Explain;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.health.Exceptions;\n+import sirius.kernel.nls.NLS;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to handle and extract archive files like zip, 7z, tar, ...\n+ * <p>\n+ * For a list of supported formats have a look at {@link ArchiveFormat#values()}.\n+ */\n+public class ArchiveHelper {\n+\n+    private ArchiveHelper() {\n+    }\n+\n+    /**\n+     * Builds a list of supported file extensions that can be extracted, all lowercased.\n+     *\n+     * @return list of supported file extensions that can be extracted.\n+     */\n+    public static List<String> getSupportedFileExtensions() {\n+        return Collections.unmodifiableList(Arrays.stream(ArchiveFormat.values())\n+                                                  .map(archiveFormat -> archiveFormat.getMethodName().toLowerCase())\n+                                                  .collect(Collectors.toList()));\n+    }\n+\n+    /**\n+     * Checks if the file extension is an archive which can be processed by 7z.\n+     *\n+     * @param fileExtension the extension to check\n+     * @return <tt>true</tt> when archive, <tt>false</tt> otherwise\n+     */\n+    public static boolean isArchiveFile(@Nullable String fileExtension) {\n+        return fileExtension != null && Arrays.stream(ArchiveFormat.values())\n+                                              .map(ArchiveFormat::getMethodName)\n+                                              .anyMatch(fileExtension::equalsIgnoreCase);\n+    }\n+\n+    /**\n+     * iterates over the items of an archive file", "originalCommit": "c3e3b868caa31f5e05f3a09141167dca8815619a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fbd7029a557bbb29f231aed5489b1be4085312bc", "url": "https://github.com/scireum/sirius-biz/commit/fbd7029a557bbb29f231aed5489b1be4085312bc", "message": "Applies suggestions from code review", "committedDate": "2020-08-31T11:58:42Z", "type": "commit"}, {"oid": "1b124ae06889225189c4e985c2b9e00fe63b0356", "url": "https://github.com/scireum/sirius-biz/commit/1b124ae06889225189c4e985c2b9e00fe63b0356", "message": "Uses a predicate for extraction progress and stop handling", "committedDate": "2020-08-31T15:29:46Z", "type": "commit"}, {"oid": "a812fb41ddb4b0836d44419e3b8d6c5b96aa59a0", "url": "https://github.com/scireum/sirius-biz/commit/a812fb41ddb4b0836d44419e3b8d6c5b96aa59a0", "message": "Ensures updateState is called in every case, even when a file already exists. The progress stats the processed files inside the archive being extracted, so this status info should be fine to print out.", "committedDate": "2020-08-31T15:51:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDIyNzY2NA==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r480227664", "bodyText": "Rename to just getFilesProcessed?\nis a progress, I guess \"soFar\" is somewhat redundant...", "author": "idlira", "createdAt": "2020-08-31T15:58:35Z", "path": "src/main/java/sirius/biz/util/ArchiveHelper.java", "diffHunk": "@@ -103,4 +106,64 @@ private static void initSevenZipLib() throws SevenZipNativeInitializationExcepti\n         return indices;\n     }\n \n+    /**\n+     * Provides a progress of a extraction process.\n+     */\n+    public static class ExtractionProgress {\n+\n+        private final ExtractOperationResult extractOperationResult;\n+        private final ByteSource data;\n+        private final String filePath;\n+        private final long filesProcessedSoFar;\n+        private final long bytesProcessedSoFar;\n+        private final long totalBytes;\n+\n+        /**\n+         * Creates a new instance for progress status updates.\n+         *\n+         * @param extractOperationResult the extraction result of the current file\n+         * @param data                   the data of the extracted file\n+         * @param filePath               the temp file path to the extracted file on disk\n+         * @param filesProcessedSoFar    the number of files processed so far\n+         * @param bytesProcessedSoFar    the number of bytes processed so far\n+         * @param totalBytes             the number of total bytes the archive has\n+         */\n+        public ExtractionProgress(ExtractOperationResult extractOperationResult,\n+                                  ByteSource data,\n+                                  String filePath,\n+                                  long filesProcessedSoFar,\n+                                  long bytesProcessedSoFar,\n+                                  long totalBytes) {\n+            this.extractOperationResult = extractOperationResult;\n+            this.data = data;\n+            this.filePath = filePath;\n+            this.filesProcessedSoFar = filesProcessedSoFar;\n+            this.bytesProcessedSoFar = bytesProcessedSoFar;\n+            this.totalBytes = totalBytes;\n+        }\n+\n+        public ExtractOperationResult getExtractOperationResult() {\n+            return extractOperationResult;\n+        }\n+\n+        public ByteSource getData() {\n+            return data;\n+        }\n+\n+        public String getFilePath() {\n+            return filePath;\n+        }\n+\n+        public long getFilesProcessedSoFar() {", "originalCommit": "1b124ae06889225189c4e985c2b9e00fe63b0356", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDIyNzczNQ==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r480227735", "bodyText": "Rename to just getBytesProcessed?\nis a progress, I guess \"soFar\" is somewhat redundant...", "author": "idlira", "createdAt": "2020-08-31T15:58:41Z", "path": "src/main/java/sirius/biz/util/ArchiveHelper.java", "diffHunk": "@@ -103,4 +106,64 @@ private static void initSevenZipLib() throws SevenZipNativeInitializationExcepti\n         return indices;\n     }\n \n+    /**\n+     * Provides a progress of a extraction process.\n+     */\n+    public static class ExtractionProgress {\n+\n+        private final ExtractOperationResult extractOperationResult;\n+        private final ByteSource data;\n+        private final String filePath;\n+        private final long filesProcessedSoFar;\n+        private final long bytesProcessedSoFar;\n+        private final long totalBytes;\n+\n+        /**\n+         * Creates a new instance for progress status updates.\n+         *\n+         * @param extractOperationResult the extraction result of the current file\n+         * @param data                   the data of the extracted file\n+         * @param filePath               the temp file path to the extracted file on disk\n+         * @param filesProcessedSoFar    the number of files processed so far\n+         * @param bytesProcessedSoFar    the number of bytes processed so far\n+         * @param totalBytes             the number of total bytes the archive has\n+         */\n+        public ExtractionProgress(ExtractOperationResult extractOperationResult,\n+                                  ByteSource data,\n+                                  String filePath,\n+                                  long filesProcessedSoFar,\n+                                  long bytesProcessedSoFar,\n+                                  long totalBytes) {\n+            this.extractOperationResult = extractOperationResult;\n+            this.data = data;\n+            this.filePath = filePath;\n+            this.filesProcessedSoFar = filesProcessedSoFar;\n+            this.bytesProcessedSoFar = bytesProcessedSoFar;\n+            this.totalBytes = totalBytes;\n+        }\n+\n+        public ExtractOperationResult getExtractOperationResult() {\n+            return extractOperationResult;\n+        }\n+\n+        public ByteSource getData() {\n+            return data;\n+        }\n+\n+        public String getFilePath() {\n+            return filePath;\n+        }\n+\n+        public long getFilesProcessedSoFar() {\n+            return filesProcessedSoFar;\n+        }\n+\n+        public long getBytesProcessedSoFar() {", "originalCommit": "1b124ae06889225189c4e985c2b9e00fe63b0356", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "349d329a7e66926cda521ebb298cb10c3af0de29", "url": "https://github.com/scireum/sirius-biz/commit/349d329a7e66926cda521ebb298cb10c3af0de29", "message": "Renames progress getters as suggested by @idlira", "committedDate": "2020-09-01T04:27:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3Mzc2OQ==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r481173769", "bodyText": "no need for static here - @register is above..", "author": "andyHa", "createdAt": "2020-09-01T14:20:22Z", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import com.google.common.io.ByteSource;\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;", "originalCommit": "349d329a7e66926cda521ebb298cb10c3af0de29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3Mzg1Ng==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r481173856", "bodyText": "s.a.", "author": "andyHa", "createdAt": "2020-09-01T14:20:29Z", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import com.google.common.io.ByteSource;\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;", "originalCommit": "349d329a7e66926cda521ebb298cb10c3af0de29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3NDU4MQ==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r481174581", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    sourceFile.tryDownload().ifPresent(handleArchiveExtraction(process, shouldOverwriteExisting, targetDirectory));\n          \n          \n            \n                    sourceFile.tryDownload().ifPresent(handle -> handleArchiveExtraction(process, handle, shouldOverwriteExisting, targetDirectory));", "author": "andyHa", "createdAt": "2020-09-01T14:21:26Z", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import com.google.common.io.ByteSource;\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;\n+\n+    private static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",\n+                                                                            \"$VirtualFileExtractionJob.sourceParameter\")\n+            .withAcceptedExtensionsList(ArchiveHelper.getSupportedFileExtensions())\n+            .withDescription(\"$VirtualFileExtractionJob.sourceParameter.help\")\n+            .markRequired();\n+\n+    private static final FileOrDirectoryParameter DESTINATION_PARAMETER = new FileOrDirectoryParameter(\n+            \"destinationParameter\",\n+            \"$VirtualFileExtractionJob.destinationParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.destinationParameter.help\");\n+\n+    private static final BooleanParameter OVERWRITE_EXISTING_FILES_PARAMETER = new BooleanParameter(\n+            \"overwriteExistingFilesParameter\",\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter.help\");\n+    private static final String TARGET_PATH = \"targetPath\";\n+\n+    @Override\n+    protected void execute(ProcessContext process) throws Exception {\n+        VirtualFile sourceFile = process.require(SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory = DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting = process.require(OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload().ifPresent(handleArchiveExtraction(process, shouldOverwriteExisting, targetDirectory));", "originalCommit": "349d329a7e66926cda521ebb298cb10c3af0de29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3NDk5Mg==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r481174992", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Consumer<FileHandle> handleArchiveExtraction(ProcessContext process,\n          \n          \n            \n                private void handleArchiveExtraction(ProcessContext process, FileHandle fileHandle,", "author": "andyHa", "createdAt": "2020-09-01T14:21:56Z", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import com.google.common.io.ByteSource;\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;\n+\n+    private static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",\n+                                                                            \"$VirtualFileExtractionJob.sourceParameter\")\n+            .withAcceptedExtensionsList(ArchiveHelper.getSupportedFileExtensions())\n+            .withDescription(\"$VirtualFileExtractionJob.sourceParameter.help\")\n+            .markRequired();\n+\n+    private static final FileOrDirectoryParameter DESTINATION_PARAMETER = new FileOrDirectoryParameter(\n+            \"destinationParameter\",\n+            \"$VirtualFileExtractionJob.destinationParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.destinationParameter.help\");\n+\n+    private static final BooleanParameter OVERWRITE_EXISTING_FILES_PARAMETER = new BooleanParameter(\n+            \"overwriteExistingFilesParameter\",\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter.help\");\n+    private static final String TARGET_PATH = \"targetPath\";\n+\n+    @Override\n+    protected void execute(ProcessContext process) throws Exception {\n+        VirtualFile sourceFile = process.require(SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory = DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting = process.require(OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload().ifPresent(handleArchiveExtraction(process, shouldOverwriteExisting, targetDirectory));\n+    }\n+\n+    @Nonnull\n+    private Consumer<FileHandle> handleArchiveExtraction(ProcessContext process,", "originalCommit": "349d329a7e66926cda521ebb298cb10c3af0de29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3NTA3MA==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r481175070", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return fileHandle -> {", "author": "andyHa", "createdAt": "2020-09-01T14:22:04Z", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import com.google.common.io.ByteSource;\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;\n+\n+    private static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",\n+                                                                            \"$VirtualFileExtractionJob.sourceParameter\")\n+            .withAcceptedExtensionsList(ArchiveHelper.getSupportedFileExtensions())\n+            .withDescription(\"$VirtualFileExtractionJob.sourceParameter.help\")\n+            .markRequired();\n+\n+    private static final FileOrDirectoryParameter DESTINATION_PARAMETER = new FileOrDirectoryParameter(\n+            \"destinationParameter\",\n+            \"$VirtualFileExtractionJob.destinationParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.destinationParameter.help\");\n+\n+    private static final BooleanParameter OVERWRITE_EXISTING_FILES_PARAMETER = new BooleanParameter(\n+            \"overwriteExistingFilesParameter\",\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter.help\");\n+    private static final String TARGET_PATH = \"targetPath\";\n+\n+    @Override\n+    protected void execute(ProcessContext process) throws Exception {\n+        VirtualFile sourceFile = process.require(SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory = DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting = process.require(OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload().ifPresent(handleArchiveExtraction(process, shouldOverwriteExisting, targetDirectory));\n+    }\n+\n+    @Nonnull\n+    private Consumer<FileHandle> handleArchiveExtraction(ProcessContext process,\n+                                                         boolean shouldOverwriteExisting,\n+                                                         VirtualFile targetDirectory) {\n+        return fileHandle -> {", "originalCommit": "349d329a7e66926cda521ebb298cb10c3af0de29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3NTE4OQ==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r481175189", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    };", "author": "andyHa", "createdAt": "2020-09-01T14:22:15Z", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import com.google.common.io.ByteSource;\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;\n+\n+    private static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",\n+                                                                            \"$VirtualFileExtractionJob.sourceParameter\")\n+            .withAcceptedExtensionsList(ArchiveHelper.getSupportedFileExtensions())\n+            .withDescription(\"$VirtualFileExtractionJob.sourceParameter.help\")\n+            .markRequired();\n+\n+    private static final FileOrDirectoryParameter DESTINATION_PARAMETER = new FileOrDirectoryParameter(\n+            \"destinationParameter\",\n+            \"$VirtualFileExtractionJob.destinationParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.destinationParameter.help\");\n+\n+    private static final BooleanParameter OVERWRITE_EXISTING_FILES_PARAMETER = new BooleanParameter(\n+            \"overwriteExistingFilesParameter\",\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter.help\");\n+    private static final String TARGET_PATH = \"targetPath\";\n+\n+    @Override\n+    protected void execute(ProcessContext process) throws Exception {\n+        VirtualFile sourceFile = process.require(SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory = DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting = process.require(OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload().ifPresent(handleArchiveExtraction(process, shouldOverwriteExisting, targetDirectory));\n+    }\n+\n+    @Nonnull\n+    private Consumer<FileHandle> handleArchiveExtraction(ProcessContext process,\n+                                                         boolean shouldOverwriteExisting,\n+                                                         VirtualFile targetDirectory) {\n+        return fileHandle -> {\n+            File tempFile = fileHandle.getFile();\n+            if (!TaskContext.get().isActive()) {\n+                Files.delete(tempFile);\n+                return;\n+            }\n+\n+            try {\n+                ArchiveHelper.extract(tempFile,\n+                                      null,\n+                                      handleFileInArchive(process, shouldOverwriteExisting, targetDirectory));\n+            } catch (IOException e) {\n+                process.handle(e);\n+            } finally {\n+                Files.delete(tempFile);\n+            }\n+        };", "originalCommit": "349d329a7e66926cda521ebb298cb10c3af0de29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3NTYxOA==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r481175618", "bodyText": "bulid closure at call site instead of returning one (s.a.)", "author": "andyHa", "createdAt": "2020-09-01T14:22:47Z", "path": "src/main/java/sirius/biz/jobs/batch/file/VirtualFileExtractionJob.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.jobs.batch.file;\n+\n+import com.google.common.io.ByteSource;\n+import sirius.biz.jobs.batch.SimpleBatchProcessJobFactory;\n+import sirius.biz.jobs.params.BooleanParameter;\n+import sirius.biz.jobs.params.Parameter;\n+import sirius.biz.process.PersistencePeriod;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.process.logs.ProcessLog;\n+import sirius.biz.storage.layer1.FileHandle;\n+import sirius.biz.storage.layer3.FileOrDirectoryParameter;\n+import sirius.biz.storage.layer3.FileParameter;\n+import sirius.biz.storage.layer3.MutableVirtualFile;\n+import sirius.biz.storage.layer3.VirtualFile;\n+import sirius.biz.storage.layer3.VirtualFileSystem;\n+import sirius.biz.util.ArchiveHelper;\n+import sirius.kernel.async.TaskContext;\n+import sirius.kernel.commons.Files;\n+import sirius.kernel.commons.Strings;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.di.std.Register;\n+import sirius.kernel.nls.NLS;\n+import sirius.web.http.QueryString;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Provides a job able to extract archives from the {@link VirtualFileSystem}. The following file extensions are supported: {@link ArchiveHelper#getSupportedFileExtensions()}.\n+ */\n+@Register\n+public class VirtualFileExtractionJob extends SimpleBatchProcessJobFactory {\n+\n+    @Part\n+    private static VirtualFileSystem vfs;\n+\n+    @Part\n+    private static ArchiveHelper archiveHelper;\n+\n+    private static final FileParameter SOURCE_PARAMETER = new FileParameter(\"sourceParameter\",\n+                                                                            \"$VirtualFileExtractionJob.sourceParameter\")\n+            .withAcceptedExtensionsList(ArchiveHelper.getSupportedFileExtensions())\n+            .withDescription(\"$VirtualFileExtractionJob.sourceParameter.help\")\n+            .markRequired();\n+\n+    private static final FileOrDirectoryParameter DESTINATION_PARAMETER = new FileOrDirectoryParameter(\n+            \"destinationParameter\",\n+            \"$VirtualFileExtractionJob.destinationParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.destinationParameter.help\");\n+\n+    private static final BooleanParameter OVERWRITE_EXISTING_FILES_PARAMETER = new BooleanParameter(\n+            \"overwriteExistingFilesParameter\",\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter\").withDescription(\n+            \"$VirtualFileExtractionJob.overwriteExistingFilesParameter.help\");\n+    private static final String TARGET_PATH = \"targetPath\";\n+\n+    @Override\n+    protected void execute(ProcessContext process) throws Exception {\n+        VirtualFile sourceFile = process.require(SOURCE_PARAMETER);\n+        Optional<VirtualFile> destinationDirectory = DESTINATION_PARAMETER.get(process.getContext());\n+        boolean shouldOverwriteExisting = process.require(OVERWRITE_EXISTING_FILES_PARAMETER);\n+\n+        // by default we'll use the files directory to extract to\n+        final VirtualFile targetDirectory =\n+                destinationDirectory.orElseGet(() -> vfs.resolve(sourceFile.parent().path()));\n+\n+        sourceFile.tryDownload().ifPresent(handleArchiveExtraction(process, shouldOverwriteExisting, targetDirectory));\n+    }\n+\n+    @Nonnull\n+    private Consumer<FileHandle> handleArchiveExtraction(ProcessContext process,\n+                                                         boolean shouldOverwriteExisting,\n+                                                         VirtualFile targetDirectory) {\n+        return fileHandle -> {\n+            File tempFile = fileHandle.getFile();\n+            if (!TaskContext.get().isActive()) {\n+                Files.delete(tempFile);\n+                return;\n+            }\n+\n+            try {\n+                ArchiveHelper.extract(tempFile,\n+                                      null,\n+                                      handleFileInArchive(process, shouldOverwriteExisting, targetDirectory));\n+            } catch (IOException e) {\n+                process.handle(e);\n+            } finally {\n+                Files.delete(tempFile);\n+            }\n+        };\n+    }\n+\n+    @Nonnull\n+    private Predicate<ArchiveHelper.ExtractionProgress> handleFileInArchive(ProcessContext process,", "originalCommit": "349d329a7e66926cda521ebb298cb10c3af0de29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3Njg4NQ==", "url": "https://github.com/scireum/sirius-biz/pull/846#discussion_r481176885", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static void extract(File tmpFile,\n          \n          \n            \n                public static void extract(File archiveFile,", "author": "andyHa", "createdAt": "2020-09-01T14:24:25Z", "path": "src/main/java/sirius/biz/util/ArchiveHelper.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.util;\n+\n+import com.google.common.io.ByteSource;\n+import net.sf.sevenzipjbinding.ArchiveFormat;\n+import net.sf.sevenzipjbinding.ExtractOperationResult;\n+import net.sf.sevenzipjbinding.IInArchive;\n+import net.sf.sevenzipjbinding.SevenZip;\n+import net.sf.sevenzipjbinding.SevenZipException;\n+import net.sf.sevenzipjbinding.SevenZipNativeInitializationException;\n+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;\n+import sirius.kernel.nls.NLS;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to handle and extract archive files like zip, 7z, tar, ...\n+ * <p>\n+ * For a list of supported formats have a look at {@link ArchiveFormat#values()}.\n+ */\n+public class ArchiveHelper {\n+\n+    private ArchiveHelper() {\n+    }\n+\n+    /**\n+     * Builds a list of supported file extensions that can be extracted, all lowercased.\n+     *\n+     * @return list of supported file extensions that can be extracted.\n+     */\n+    public static List<String> getSupportedFileExtensions() {\n+        return Collections.unmodifiableList(Arrays.stream(ArchiveFormat.values())\n+                                                  .map(archiveFormat -> archiveFormat.getMethodName().toLowerCase())\n+                                                  .collect(Collectors.toList()));\n+    }\n+\n+    /**\n+     * Checks if the file extension is an archive which can be processed by 7z.\n+     *\n+     * @param fileExtension the extension to check\n+     * @return <tt>true</tt> when archive, <tt>false</tt> otherwise\n+     */\n+    public static boolean isArchiveFile(@Nullable String fileExtension) {\n+        return fileExtension != null && Arrays.stream(ArchiveFormat.values())\n+                                              .map(ArchiveFormat::getMethodName)\n+                                              .anyMatch(fileExtension::equalsIgnoreCase);\n+    }\n+\n+    /**\n+     * Iterates over the items of an archive file\n+     *\n+     * @param tmpFile                 the archive file\n+     * @param filter                  will be called for each archive item. {@code unzipItemCallback} will be only called for this item if this filter unzipItemCallback returns true\n+     * @param progressAndStopProvider will be called for each archive item until it returns false\n+     * @throws IOException on extraction failure\n+     */\n+    public static void extract(File tmpFile,", "originalCommit": "349d329a7e66926cda521ebb298cb10c3af0de29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fb2c8bfe71a779ab3ff4dc967c2b287dee8842d7", "url": "https://github.com/scireum/sirius-biz/commit/fb2c8bfe71a779ab3ff4dc967c2b287dee8842d7", "message": "Builds closure at call site instead of returning one", "committedDate": "2020-09-01T14:31:39Z", "type": "commit"}, {"oid": "8b0f7137eb9d21f1565ba9cabb695a1f6b050874", "url": "https://github.com/scireum/sirius-biz/commit/8b0f7137eb9d21f1565ba9cabb695a1f6b050874", "message": "Provides better param naming", "committedDate": "2020-09-01T14:33:28Z", "type": "commit"}]}