{"pr_number": 65921, "pr_title": "Stop Copying Large Byte Arrays from Transport Messages", "pr_createdAt": "2020-12-06T18:52:31Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65921", "timeline": [{"oid": "6762a3ead2a8f7cc7cf3a02d892e04aff35cb90d", "url": "https://github.com/elastic/elasticsearch/commit/6762a3ead2a8f7cc7cf3a02d892e04aff35cb90d", "message": "Stop Copying Large Byte Arrays from Transport Messages\n\nWe were copying any byte arrays we would read streams that are backed by\na `BytesReference`. This would mean copying e.g. 500k chunks during\nfile based recovery, large chunks during CCR file copy, or many MB when\nreceiving a large cluster state for the first time.\n\nThis PR adds the ability to read shared bytes from streams that support it,\nadds reference counting to transport messages that make use of these bytes\nand makes use of the new functionality in recovery, CCR and CS publication.\n\nThis should reduce memory usage by all 3 adjusted transport APIs significantly\nand could be extended to other very large messages that currently get copied\nduring deserialization like e.g. bulk requests.", "committedDate": "2020-12-06T18:13:17Z", "type": "commit"}, {"oid": "b5d3b01c67462d4a6dccc372a4b03ebfe1a355b0", "url": "https://github.com/elastic/elasticsearch/commit/b5d3b01c67462d4a6dccc372a4b03ebfe1a355b0", "message": "shorter", "committedDate": "2020-12-06T18:52:14Z", "type": "commit"}, {"oid": "cdc3b672f758ee8ef4e6645723c8790ed13e8668", "url": "https://github.com/elastic/elasticsearch/commit/cdc3b672f758ee8ef4e6645723c8790ed13e8668", "message": "Merge remote-tracking branch 'elastic/master' into just-stop-copying", "committedDate": "2020-12-07T00:38:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE3MDU2MA==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r537170560", "bodyText": "Inlined this so that the reference count handling is all in one place and it's \"clear\" that there's no path to leaking a request (except for some corner cases where the threadPool is shutting down but we have that issue with all kinds of ref counted things and its only relevant for tests).", "author": "original-brownbear", "createdAt": "2020-12-07T01:15:12Z", "path": "server/src/main/java/org/elasticsearch/transport/InboundHandler.java", "diffHunk": "@@ -193,23 +194,58 @@ private void messageReceived(TcpChannel channel, InboundMessage message, long st\n                     final RequestHandlerRegistry<T> reg = requestHandlers.getHandler(action);\n                     assert reg != null;\n                     final T request = reg.newRequest(stream);\n-                    request.remoteAddress(new TransportAddress(channel.getRemoteAddress()));\n-                    // in case we throw an exception, i.e. when the limit is hit, we don't want to verify\n-                    final int nextByte = stream.read();\n-                    // calling read() is useful to make sure the message is fully read, even if there some kind of EOS marker\n-                    if (nextByte != -1) {\n-                        throw new IllegalStateException(\"Message not fully read (request) for requestId [\" + requestId + \"], action [\"\n-                            + action + \"], available [\" + stream.available() + \"]; resetting\");\n-                    }\n-                    final String executor = reg.getExecutor();\n-                    if (ThreadPool.Names.SAME.equals(executor)) {\n-                        try {\n-                            reg.processMessageReceived(request, transportChannel);\n-                        } catch (Exception e) {\n-                            sendErrorResponse(reg.getAction(), transportChannel, e);\n+                    try {\n+                        request.remoteAddress(new TransportAddress(channel.getRemoteAddress()));\n+                        // in case we throw an exception, i.e. when the limit is hit, we don't want to verify\n+                        final int nextByte = stream.read();\n+                        // calling read() is useful to make sure the message is fully read, even if there some kind of EOS marker\n+                        if (nextByte != -1) {\n+                            throw new IllegalStateException(\"Message not fully read (request) for requestId [\" + requestId + \"], action [\"\n+                                + action + \"], available [\" + stream.available() + \"]; resetting\");\n                         }\n-                    } else {\n-                        threadPool.executor(executor).execute(new RequestHandler<>(reg, request, transportChannel));\n+                        final String executor = reg.getExecutor();\n+                        if (ThreadPool.Names.SAME.equals(executor)) {\n+                            try {\n+                                reg.processMessageReceived(request, transportChannel);\n+                            } catch (Exception e) {\n+                                sendErrorResponse(reg.getAction(), transportChannel, e);\n+                            }\n+                        } else {\n+                            boolean success = false;\n+                            if (request instanceof RefCounted) {\n+                                ((RefCounted) request).incRef();\n+                            }\n+                            try {\n+                                threadPool.executor(executor).execute(new AbstractRunnable() {", "originalCommit": "b5d3b01c67462d4a6dccc372a4b03ebfe1a355b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "73e7de56c10b3e291e5072967864e9f8f5f9f792", "url": "https://github.com/elastic/elasticsearch/commit/73e7de56c10b3e291e5072967864e9f8f5f9f792", "message": "docs and less noise", "committedDate": "2020-12-07T01:17:55Z", "type": "commit"}, {"oid": "8f49cf97e9e3b0c5cfbd79595f54afc30295c2f6", "url": "https://github.com/elastic/elasticsearch/commit/8f49cf97e9e3b0c5cfbd79595f54afc30295c2f6", "message": "Merge remote-tracking branch 'elastic/master' into just-stop-copying", "committedDate": "2020-12-17T11:26:58Z", "type": "commit"}, {"oid": "1dc5bf34125cb7ff3e978e6873dff707ce979525", "url": "https://github.com/elastic/elasticsearch/commit/1dc5bf34125cb7ff3e978e6873dff707ce979525", "message": "Merge remote-tracking branch 'origin/just-stop-copying' into just-stop-copying", "committedDate": "2020-12-17T11:27:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0NjI5MA==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551246290", "bodyText": "Alternative name suggestion:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public ReleasableBytesReference readUnsafeBytesReference() throws IOException {\n          \n          \n            \n                public ReleasableBytesReference readReleasableBytesReference() throws IOException {\n          \n      \n    \n    \n  \n\nMethods that return a ReleasableBytesReference should pretty much all have the expectation that the caller takes responsibility for releasing it later, so I don't think this is as unsafe as the proposed name indicates.", "author": "DaveCTurner", "createdAt": "2021-01-04T10:54:42Z", "path": "server/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java", "diffHunk": "@@ -129,14 +130,23 @@ public void setVersion(Version version) {\n     public abstract void readBytes(byte[] b, int offset, int len) throws IOException;\n \n     /**\n-     * Reads a bytes reference from this stream, might hold an actual reference to the underlying\n-     * bytes of the stream.\n+     * Reads a bytes reference from this stream, copying any bytes read to a new {@code byte[]}. Use {@link #readUnsafeBytesReference()}\n+     * when reading large bytes references where possible top avoid needless allocations and copying.\n      */\n     public BytesReference readBytesReference() throws IOException {\n         int length = readArraySize();\n         return readBytesReference(length);\n     }\n \n+    /**\n+     * Reads a releasable bytes reference from this stream. Unlike {@link #readBytesReference()} the returned bytes reference may reference\n+     * bytes in a pooled buffer and must be explicitly released via {@link ReleasableBytesReference#close()} once no longer used.\n+     * Prefer this method over {@link #readBytesReference()} when reading large bytes references to avoid allocations and copying.\n+     */\n+    public ReleasableBytesReference readUnsafeBytesReference() throws IOException {", "originalCommit": "1dc5bf34125cb7ff3e978e6873dff707ce979525", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1NzQ5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551257496", "bodyText": "Would it be so bad to have TransportMessage implements RefCounted - I think it'll catch someone out in future. At least let's add Javadoc somewhere saying that subclasses that implement RefCounted are released by the transport service.", "author": "DaveCTurner", "createdAt": "2021-01-04T11:18:44Z", "path": "libs/core/src/main/java/org/elasticsearch/common/util/concurrent/RefCounted.java", "diffHunk": "@@ -65,4 +65,15 @@\n      * @return returns {@code true} if the ref count dropped to 0 as a result of calling this method\n      */\n     boolean decRef();\n+\n+    /**\n+     * Decrement the ref count on the given {@code object} by one if it is a {@link RefCounted}\n+     *\n+     * @param object object to decrement ref count for if it is a {@link RefCounted}\n+     */\n+    static void decRef(Object object) {", "originalCommit": "1dc5bf34125cb7ff3e978e6873dff707ce979525", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg2NjMxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551866311", "bodyText": "I went with TransportMessage implements RefCounted after all. I initially didn't like the idea of doing that because it felt dirty to force overriding either none or all 3 methods from RefCounted when creating a ref-counted message ... but in hindsight that's still a lot better than implicitly releasing via the interface type check :)", "author": "original-brownbear", "createdAt": "2021-01-05T11:10:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1NzQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1ODkwMg==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551258902", "bodyText": "Maybe avoid the casting?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            final ReleasableBytesReference result = ((ReleasableBytesReference) bytesReference).retainedSlice(offset(), len);\n          \n          \n            \n                            final ReleasableBytesReference result = ReleasableBytesReference.this.retainedSlice(offset(), len);", "author": "DaveCTurner", "createdAt": "2021-01-04T11:21:51Z", "path": "server/src/main/java/org/elasticsearch/common/bytes/ReleasableBytesReference.java", "diffHunk": "@@ -104,26 +121,41 @@ public long ramBytesUsed() {\n \n     @Override\n     public StreamInput streamInput() throws IOException {\n-        return delegate.streamInput();\n+        assert refCount() > 0;\n+        return new BytesReferenceStreamInput(this) {\n+            @Override\n+            public ReleasableBytesReference readUnsafeBytesReference() throws IOException {\n+                final int len = readArraySize();\n+                // instead of reading the bytes from a stream we just create a slice of the underlying bytes\n+                final ReleasableBytesReference result = ((ReleasableBytesReference) bytesReference).retainedSlice(offset(), len);", "originalCommit": "1dc5bf34125cb7ff3e978e6873dff707ce979525", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg1NTI5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551855297", "bodyText": "++", "author": "original-brownbear", "createdAt": "2021-01-05T10:48:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1ODkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1OTgyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551259821", "bodyText": "The chunk is already closed here, seems wrong to be accessing it still. Can we close it after the synchronised block?", "author": "DaveCTurner", "createdAt": "2021-01-04T11:23:53Z", "path": "server/src/main/java/org/elasticsearch/indices/recovery/MultiFileWriter.java", "diffHunk": "@@ -210,7 +216,9 @@ void writeChunk(FileChunk newChunk) throws IOException {\n                     }\n                     pendingChunks.remove();\n                 }\n-                innerWriteFileChunk(chunk.md, chunk.position, chunk.content, chunk.lastChunk);\n+                try (chunk) {\n+                    innerWriteFileChunk(chunk.md, chunk.position, chunk.content, chunk.lastChunk);\n+                }\n                 synchronized (this) {\n                     assert lastPosition == chunk.position : \"last_position \" + lastPosition + \" != chunk_position \" + chunk.position;\n                     lastPosition += chunk.content.length();", "originalCommit": "1dc5bf34125cb7ff3e978e6873dff707ce979525", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg1NTYxMw==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551855613", "bodyText": "++ that was a little dirty, I made it close later now as suggested", "author": "original-brownbear", "createdAt": "2021-01-05T10:49:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1OTgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MjMyMw==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551262323", "bodyText": "I think we would leak these if a recovery fails: MultiFileWriter#closeInternal simply drops its FileChunkWriter objects on the floor.", "author": "DaveCTurner", "createdAt": "2021-01-04T11:29:18Z", "path": "server/src/main/java/org/elasticsearch/indices/recovery/MultiFileWriter.java", "diffHunk": "@@ -179,17 +180,22 @@ public void renameAllTempFiles() throws IOException {\n         store.renameTempFilesSafe(tempFileNames);\n     }\n \n-    static final class FileChunk {\n+    private static final class FileChunk implements Releasable {", "originalCommit": "1dc5bf34125cb7ff3e978e6873dff707ce979525", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg2NTQ1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551865459", "bodyText": "Right thanks for catching this! I pushed 19517e4 which I think should be fine since we never get into a state where we don't have a writing thread running but pending chunks in the queue.", "author": "original-brownbear", "createdAt": "2021-01-05T11:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MjMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwMzA4MA==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551903080", "bodyText": "I don't follow the reasoning here. A recovery can fail for reasons external to writeFile(), e.g. the target node leaves the cluster and the shard is reassigned elsewhere.", "author": "DaveCTurner", "createdAt": "2021-01-05T12:31:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MjMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwODY1OA==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551908658", "bodyText": "The reasoning is this:\nWe increment the ref count for the bytes when we create the FileChunk which we then pass directly to writeChunk No matter what happens externally one of two things can happen as a result in writeChunk. Either we put the chunk in the queue to drain or we write it out right away.\nIf we write it out right away then that will just fail and the reference will be decremented. If we put it in the queue, then whatever thread that is currently doing the writing will fail during its current write and as a result drain the queue and release all the chunks that way.\n=> since we always have a thread doing work in org.elasticsearch.indices.recovery.MultiFileWriter.FileChunkWriter#writeChunk we can be sure to never fail to release a queued chunk if we drain on exceptions.", "author": "original-brownbear", "createdAt": "2021-01-05T12:43:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MjMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkyNjI1MA==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551926250", "bodyText": "We discussed this in another channel: the missing piece was that we sometimes receive these chunks out-of-order and may never fill in a gap if the chunk gets lost and then the recovery fails.", "author": "DaveCTurner", "createdAt": "2021-01-05T13:19:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MjMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMzY0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r552103649", "bodyText": "Alright I pushed da56e83 here now, should be good for another review :) Thanks!", "author": "original-brownbear", "createdAt": "2021-01-05T18:08:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MjMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2NDUxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551264515", "bodyText": "content is actually already a ReleasableBytesReference (in prod code at least)", "author": "DaveCTurner", "createdAt": "2021-01-04T11:34:19Z", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryFileChunkRequest.java", "diffHunk": "@@ -64,7 +66,7 @@ public RecoveryFileChunkRequest(long recoveryId, final long requestSeqNo, ShardI\n         this.shardId = shardId;\n         this.metadata = metadata;\n         this.position = position;\n-        this.content = content;\n+        this.content = ReleasableBytesReference.wrap(content);", "originalCommit": "1dc5bf34125cb7ff3e978e6873dff707ce979525", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg1NTc2MA==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551855760", "bodyText": "right + neat :) made use of that now", "author": "original-brownbear", "createdAt": "2021-01-05T10:49:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2NDUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3MDAyOA==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551270028", "bodyText": "I think this means the comment above (\"This is currently safe to do ...\") isn't needed any more. I mean it's still safe to do, but not for the reason it gives any more.", "author": "DaveCTurner", "createdAt": "2021-01-04T11:46:51Z", "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/repositories/GetCcrRestoreFileChunkAction.java", "diffHunk": "@@ -72,27 +73,27 @@ protected void doExecute(Task task, GetCcrRestoreFileChunkRequest request,\n         }\n     }\n \n-    public static class GetCcrRestoreFileChunkResponse extends ActionResponse {\n+    public static class GetCcrRestoreFileChunkResponse extends ActionResponse implements RefCounted {", "originalCommit": "1dc5bf34125cb7ff3e978e6873dff707ce979525", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg1NTk0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551855941", "bodyText": "++ Removed the comment", "author": "original-brownbear", "createdAt": "2021-01-05T10:49:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3MDAyOA=="}], "type": "inlineReview"}, {"oid": "153d4a8211cf785cd38ac80d4d10c7dc90211d2a", "url": "https://github.com/elastic/elasticsearch/commit/153d4a8211cf785cd38ac80d4d10c7dc90211d2a", "message": "Merge remote-tracking branch 'elastic/master' into just-stop-copying", "committedDate": "2021-01-05T07:23:41Z", "type": "commit"}, {"oid": "9f55f6c1cff21d3a898d369842689ee68318eed1", "url": "https://github.com/elastic/elasticsearch/commit/9f55f6c1cff21d3a898d369842689ee68318eed1", "message": "CR: comments round 1", "committedDate": "2021-01-05T10:12:58Z", "type": "commit"}, {"oid": "766abf7e1f5e7f5ea949897597a7da8b02c11b64", "url": "https://github.com/elastic/elasticsearch/commit/766abf7e1f5e7f5ea949897597a7da8b02c11b64", "message": "Merge remote-tracking branch 'elastic/master' into just-stop-copying", "committedDate": "2021-01-05T10:13:39Z", "type": "commit"}, {"oid": "19517e4b2b46f2568f077efb6aab1c851978d944", "url": "https://github.com/elastic/elasticsearch/commit/19517e4b2b46f2568f077efb6aab1c851978d944", "message": "CR: ensure pending chunks are released every time", "committedDate": "2021-01-05T11:06:08Z", "type": "commit"}, {"oid": "ed8df1a141387de04af50d89a21b4bda06bb9106", "url": "https://github.com/elastic/elasticsearch/commit/ed8df1a141387de04af50d89a21b4bda06bb9106", "message": "Merge remote-tracking branch 'elastic/master' into just-stop-copying", "committedDate": "2021-01-05T15:16:32Z", "type": "commit"}, {"oid": "da56e8355ece729bd40c8828da8722b8f93409c9", "url": "https://github.com/elastic/elasticsearch/commit/da56e8355ece729bd40c8828da8722b8f93409c9", "message": "CR: release pending chunks safely", "committedDate": "2021-01-05T16:24:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyMzk5MA==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r552423990", "bodyText": "All worked out pretty nicely here \ud83d\udc4d", "author": "DaveCTurner", "createdAt": "2021-01-06T08:04:36Z", "path": "server/src/main/java/org/elasticsearch/indices/recovery/MultiFileWriter.java", "diffHunk": "@@ -152,6 +158,7 @@ public void close() {\n \n     @Override\n     protected void closeInternal() {\n+        Releasables.close(fileChunkWriters.values());", "originalCommit": "da56e8355ece729bd40c8828da8722b8f93409c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}