{"pr_number": 64201, "pr_title": "Add CacheFile#fsync() method to ensure cached data are written on disk", "pr_createdAt": "2020-10-27T10:41:30Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/64201", "timeline": [{"oid": "314212ba6f368d50d9989659708641e8ed4987de", "url": "https://github.com/elastic/elasticsearch/commit/314212ba6f368d50d9989659708641e8ed4987de", "message": "Add CacheFile#fsync() method to ensure cached data are written on disk", "committedDate": "2020-10-27T10:33:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU4Mjg0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r512582842", "bodyText": "This method is intended to be called periodically by a task that will fsync all cache files of a given shard before fsyncing the parent directory.", "author": "tlrx", "createdAt": "2020-10-27T10:42:26Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -398,4 +406,52 @@ private FileChannelReference acquireFileChannelReference() {\n         ensureOpen();\n         return tracker.getAbsentRangeWithin(start, end);\n     }\n+\n+    // used in tests\n+    boolean isFSynced() {\n+        return fsynced.get();\n+    }\n+\n+    /**\n+     * Ensure that all ranges of data written to the cache file are written to the storage device that contains it. This method returns the\n+     * list of all successfully written ranges of data since the creation of the cache file.\n+     *\n+     * @return the list of ranges of data available in cache at the time this method is invoked\n+     * @throws IOException                       if the cache file failed to be fsync\n+     * @throws AlreadyClosedException            if the cache file is evicted\n+     * @throws java.nio.file.NoSuchFileException if the cache file does not exist\n+     */\n+    public List<Tuple<Long, Long>> fsync() throws IOException {\n+        ensureOpen();\n+        if (refCounter.tryIncRef()) {\n+            try {\n+                // Capture the completed ranges before fsyncing; ranges that are completed after this point won't be considered as\n+                // persisted on disk by the caller of this method, even if they are fully written to disk at the time the file\n+                // fsync is effectively executed\n+                final List<Tuple<Long, Long>> completedRanges = tracker.getCompletedRanges();\n+                assert completedRanges != null;\n+\n+                if (fsynced.compareAndSet(false, true)) {\n+                    boolean success = false;\n+                    try {\n+                        // check again if the file is evicted before doing expensive I/O\n+                        ensureOpen();\n+                        IOUtils.fsync(file, false); // TODO don't forget to fsync parent directory", "originalCommit": "314212ba6f368d50d9989659708641e8ed4987de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYxNjgwMA==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r512616800", "bodyText": "I wonder, can't we just call force on the file channel that we already have open if we have one and avoid fsync if we don't have one by fsyncing before closing the channel (would have to enhance acquireFileChannelReference to return null in case there's no eviction listeners on the current instance I guess)? No need to get a new file descriptor here maybe is there?", "author": "original-brownbear", "createdAt": "2020-10-27T11:35:01Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -398,4 +406,52 @@ private FileChannelReference acquireFileChannelReference() {\n         ensureOpen();\n         return tracker.getAbsentRangeWithin(start, end);\n     }\n+\n+    // used in tests\n+    boolean isFSynced() {\n+        return fsynced.get();\n+    }\n+\n+    /**\n+     * Ensure that all ranges of data written to the cache file are written to the storage device that contains it. This method returns the\n+     * list of all successfully written ranges of data since the creation of the cache file.\n+     *\n+     * @return the list of ranges of data available in cache at the time this method is invoked\n+     * @throws IOException                       if the cache file failed to be fsync\n+     * @throws AlreadyClosedException            if the cache file is evicted\n+     * @throws java.nio.file.NoSuchFileException if the cache file does not exist\n+     */\n+    public List<Tuple<Long, Long>> fsync() throws IOException {\n+        ensureOpen();\n+        if (refCounter.tryIncRef()) {\n+            try {\n+                // Capture the completed ranges before fsyncing; ranges that are completed after this point won't be considered as\n+                // persisted on disk by the caller of this method, even if they are fully written to disk at the time the file\n+                // fsync is effectively executed\n+                final List<Tuple<Long, Long>> completedRanges = tracker.getCompletedRanges();\n+                assert completedRanges != null;\n+\n+                if (fsynced.compareAndSet(false, true)) {\n+                    boolean success = false;\n+                    try {\n+                        // check again if the file is evicted before doing expensive I/O\n+                        ensureOpen();\n+                        IOUtils.fsync(file, false); // TODO don't forget to fsync parent directory", "originalCommit": "314212ba6f368d50d9989659708641e8ed4987de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY2NTc4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r512665789", "bodyText": "Yes, I also thought about borrowing the current file channel if we have one but I found that it added more complexity (mostly in incref/decref the file channel another time) to save a file descriptor that would be quickly released.\nI can maybe give it another try by implementing something that use the file channel if there's one or use IOUtils.fsync() otherwise. Deferring the fsync at closing time does not seem the right thing to do as we don't want to fsync everytime a chunk is written but instead control when cache files are fsynced.", "author": "tlrx", "createdAt": "2020-10-27T12:52:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYxNjgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY0ODAyOA==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r512648028", "bodyText": "Might be better to set this false as early as possible (i.e. directly after the write to the file) to reduce contention statistically speaking? (since fsync and write will always be blocking each other anyway even if we do use multiple FileChannel instances I think).", "author": "original-brownbear", "createdAt": "2020-10-27T12:23:40Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -305,6 +312,7 @@ protected void doRun() throws Exception {\n                             reference.decRef();\n                         }\n                         gap.onCompletion();\n+                        fsynced.set(false);", "originalCommit": "314212ba6f368d50d9989659708641e8ed4987de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY1ODcxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r512658711", "bodyText": "I like that fsynced not only indicate that something was written to the file but that ranges are also updated - although it is not a requirement. I'm not sure if it makes a big difference but I can move this earlier.", "author": "tlrx", "createdAt": "2020-10-27T12:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY0ODAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY2Mzg5NA==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r512663894", "bodyText": "Ah that's a good point :)", "author": "original-brownbear", "createdAt": "2020-10-27T12:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY0ODAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQwODQxOA==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r513408418", "bodyText": "I think there is an assumption of only ever going here in one thread, since otherwise we risk a concurrent thread seeing the completedRanges. I think that is fair, but perhaps for safety we should either lock the entire method or assert something to capture this?", "author": "henningandersen", "createdAt": "2020-10-28T12:38:39Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -398,4 +406,52 @@ private FileChannelReference acquireFileChannelReference() {\n         ensureOpen();\n         return tracker.getAbsentRangeWithin(start, end);\n     }\n+\n+    // used in tests\n+    boolean isFSynced() {\n+        return fsynced.get();\n+    }\n+\n+    /**\n+     * Ensure that all ranges of data written to the cache file are written to the storage device that contains it. This method returns the\n+     * list of all successfully written ranges of data since the creation of the cache file.\n+     *\n+     * @return the list of ranges of data available in cache at the time this method is invoked\n+     * @throws IOException                       if the cache file failed to be fsync\n+     * @throws AlreadyClosedException            if the cache file is evicted\n+     * @throws java.nio.file.NoSuchFileException if the cache file does not exist\n+     */\n+    public List<Tuple<Long, Long>> fsync() throws IOException {\n+        ensureOpen();\n+        if (refCounter.tryIncRef()) {\n+            try {\n+                // Capture the completed ranges before fsyncing; ranges that are completed after this point won't be considered as\n+                // persisted on disk by the caller of this method, even if they are fully written to disk at the time the file\n+                // fsync is effectively executed\n+                final List<Tuple<Long, Long>> completedRanges = tracker.getCompletedRanges();\n+                assert completedRanges != null;\n+\n+                if (fsynced.compareAndSet(false, true)) {", "originalCommit": "314212ba6f368d50d9989659708641e8ed4987de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzMjE5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r515932191", "bodyText": "I think this is OK, but your comment and your suggestion about returning an empty set of ranges if the cache file got evicted made me change a bit the semantic of this new fsync method.\nI pushed d55278e which makes the method return a non-empty set of completed ranges only if the cache file was actually fsynced on disk; otherwise it returns an empty collection. This should address the case of concurrent threads and also simplify the logic to know if new ranges of data were effectively synchronized on disk or not.", "author": "tlrx", "createdAt": "2020-11-02T12:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQwODQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQwODg1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r513408852", "bodyText": "This also fsync's the metadata of the file. I think that is unnecessary?", "author": "henningandersen", "createdAt": "2020-10-28T12:39:23Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -398,4 +406,52 @@ private FileChannelReference acquireFileChannelReference() {\n         ensureOpen();\n         return tracker.getAbsentRangeWithin(start, end);\n     }\n+\n+    // used in tests\n+    boolean isFSynced() {\n+        return fsynced.get();\n+    }\n+\n+    /**\n+     * Ensure that all ranges of data written to the cache file are written to the storage device that contains it. This method returns the\n+     * list of all successfully written ranges of data since the creation of the cache file.\n+     *\n+     * @return the list of ranges of data available in cache at the time this method is invoked\n+     * @throws IOException                       if the cache file failed to be fsync\n+     * @throws AlreadyClosedException            if the cache file is evicted\n+     * @throws java.nio.file.NoSuchFileException if the cache file does not exist\n+     */\n+    public List<Tuple<Long, Long>> fsync() throws IOException {\n+        ensureOpen();\n+        if (refCounter.tryIncRef()) {\n+            try {\n+                // Capture the completed ranges before fsyncing; ranges that are completed after this point won't be considered as\n+                // persisted on disk by the caller of this method, even if they are fully written to disk at the time the file\n+                // fsync is effectively executed\n+                final List<Tuple<Long, Long>> completedRanges = tracker.getCompletedRanges();\n+                assert completedRanges != null;\n+\n+                if (fsynced.compareAndSet(false, true)) {\n+                    boolean success = false;\n+                    try {\n+                        // check again if the file is evicted before doing expensive I/O\n+                        ensureOpen();\n+                        IOUtils.fsync(file, false); // TODO don't forget to fsync parent directory", "originalCommit": "314212ba6f368d50d9989659708641e8ed4987de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzMjI1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r515932252", "bodyText": "Agreed - it is an extra I/O that we don't need. I pushed 6eea900", "author": "tlrx", "createdAt": "2020-11-02T12:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQwODg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQxNzU3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r513417579", "bodyText": "I think counting the file as not fsync'ed when just created could lead to fsync'ing the empty file - which I think is unnecessary? We care mostly about the data, not the files.", "author": "henningandersen", "createdAt": "2020-10-28T12:53:42Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/CacheFileTests.java", "diffHunk": "@@ -171,6 +196,151 @@ public void testConcurrentAccess() throws Exception {\n         }\n     }\n \n+    public void testFSyncOnNonExistentFile() {\n+        try (FSyncTrackingFileSystemProvider fileSystem = setupFSyncCountingFileSystem()) {\n+            final CacheFile cacheFile = new CacheFile(\"test\", randomNonNegativeLong(), fileSystem.resolve(\"test\"));\n+            expectThrows(NoSuchFileException.class, cacheFile::fsync);\n+        }\n+    }\n+\n+    public void testFSync() throws Exception {\n+        try (FSyncTrackingFileSystemProvider fileSystem = setupFSyncCountingFileSystem()) {\n+            final CacheFile cacheFile = new CacheFile(\"test\", randomLongBetween(100, 1000), fileSystem.resolve(\"test\"));\n+            assertFalse(cacheFile.isFSynced());", "originalCommit": "314212ba6f368d50d9989659708641e8ed4987de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzMjI3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r515932276", "bodyText": "Right - I pushed 2f8b0e7", "author": "tlrx", "createdAt": "2020-11-02T12:16:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQxNzU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyMDQ0NA==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r513420444", "bodyText": "Would be good to also verify multiple populateAndRead calls within one fsync?", "author": "henningandersen", "createdAt": "2020-10-28T12:58:00Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/CacheFileTests.java", "diffHunk": "@@ -171,6 +196,151 @@ public void testConcurrentAccess() throws Exception {\n         }\n     }\n \n+    public void testFSyncOnNonExistentFile() {\n+        try (FSyncTrackingFileSystemProvider fileSystem = setupFSyncCountingFileSystem()) {\n+            final CacheFile cacheFile = new CacheFile(\"test\", randomNonNegativeLong(), fileSystem.resolve(\"test\"));\n+            expectThrows(NoSuchFileException.class, cacheFile::fsync);\n+        }\n+    }\n+\n+    public void testFSync() throws Exception {\n+        try (FSyncTrackingFileSystemProvider fileSystem = setupFSyncCountingFileSystem()) {\n+            final CacheFile cacheFile = new CacheFile(\"test\", randomLongBetween(100, 1000), fileSystem.resolve(\"test\"));\n+            assertFalse(cacheFile.isFSynced());\n+\n+            final TestEvictionListener listener = new TestEvictionListener();\n+            cacheFile.acquire(listener);\n+\n+            List<Tuple<Long, Long>> completedRanges = cacheFile.fsync();\n+            assertNumberOfFSyncs(cacheFile.getFile(), equalTo(1L));\n+            assertThat(completedRanges, hasSize(0));\n+            assertTrue(cacheFile.isFSynced());\n+\n+            final TestThreadPool threadPool = new TestThreadPool(getTestName());\n+            try {\n+                final Set<Tuple<Long, Long>> expectedCompletedRanges = new TreeSet<>(Comparator.comparingLong(Tuple::v1));\n+\n+                for (long i = 0L; i < between(1, 10); i++) {\n+                    if (randomBoolean()) {\n+                        final long position = i * 10L; // simplify the test by completing small non-contiguous ranges\n+                        final Tuple<Long, Long> range = Tuple.tuple(position, position + 1L);\n+                        cacheFile.populateAndRead(", "originalCommit": "314212ba6f368d50d9989659708641e8ed4987de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzMjMwOA==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r515932308", "bodyText": "Sure, I randomized this in the test now.", "author": "tlrx", "createdAt": "2020-11-02T12:16:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyMDQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyNDg1OA==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r513424858", "bodyText": "Should this return a SortedSet instead to signal the expected order verified by the test, as well as uniqueness?", "author": "henningandersen", "createdAt": "2020-10-28T13:04:56Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -398,4 +406,52 @@ private FileChannelReference acquireFileChannelReference() {\n         ensureOpen();\n         return tracker.getAbsentRangeWithin(start, end);\n     }\n+\n+    // used in tests\n+    boolean isFSynced() {\n+        return fsynced.get();\n+    }\n+\n+    /**\n+     * Ensure that all ranges of data written to the cache file are written to the storage device that contains it. This method returns the\n+     * list of all successfully written ranges of data since the creation of the cache file.\n+     *\n+     * @return the list of ranges of data available in cache at the time this method is invoked\n+     * @throws IOException                       if the cache file failed to be fsync\n+     * @throws AlreadyClosedException            if the cache file is evicted\n+     * @throws java.nio.file.NoSuchFileException if the cache file does not exist\n+     */\n+    public List<Tuple<Long, Long>> fsync() throws IOException {", "originalCommit": "314212ba6f368d50d9989659708641e8ed4987de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzMjMzNg==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r515932336", "bodyText": "This is a good suggestion, thanks. I pushed 7b3590e", "author": "tlrx", "createdAt": "2020-11-02T12:16:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyNDg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyNjE0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r513426141", "bodyText": "This can definitely be handled in a follow-up instead when you start using it. But it might be more appropriate to just return the empty set of ranges in this case, since we essentially having nothing cached for it, rather than have to exception handle in the fsync'er thread?", "author": "henningandersen", "createdAt": "2020-10-28T13:06:51Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/CacheFileTests.java", "diffHunk": "@@ -171,6 +196,151 @@ public void testConcurrentAccess() throws Exception {\n         }\n     }\n \n+    public void testFSyncOnNonExistentFile() {\n+        try (FSyncTrackingFileSystemProvider fileSystem = setupFSyncCountingFileSystem()) {\n+            final CacheFile cacheFile = new CacheFile(\"test\", randomNonNegativeLong(), fileSystem.resolve(\"test\"));\n+            expectThrows(NoSuchFileException.class, cacheFile::fsync);\n+        }\n+    }\n+\n+    public void testFSync() throws Exception {\n+        try (FSyncTrackingFileSystemProvider fileSystem = setupFSyncCountingFileSystem()) {\n+            final CacheFile cacheFile = new CacheFile(\"test\", randomLongBetween(100, 1000), fileSystem.resolve(\"test\"));\n+            assertFalse(cacheFile.isFSynced());\n+\n+            final TestEvictionListener listener = new TestEvictionListener();\n+            cacheFile.acquire(listener);\n+\n+            List<Tuple<Long, Long>> completedRanges = cacheFile.fsync();\n+            assertNumberOfFSyncs(cacheFile.getFile(), equalTo(1L));\n+            assertThat(completedRanges, hasSize(0));\n+            assertTrue(cacheFile.isFSynced());\n+\n+            final TestThreadPool threadPool = new TestThreadPool(getTestName());\n+            try {\n+                final Set<Tuple<Long, Long>> expectedCompletedRanges = new TreeSet<>(Comparator.comparingLong(Tuple::v1));\n+\n+                for (long i = 0L; i < between(1, 10); i++) {\n+                    if (randomBoolean()) {\n+                        final long position = i * 10L; // simplify the test by completing small non-contiguous ranges\n+                        final Tuple<Long, Long> range = Tuple.tuple(position, position + 1L);\n+                        cacheFile.populateAndRead(\n+                            range,\n+                            range,\n+                            channel -> Math.toIntExact(range.v2() - range.v1()),\n+                            (channel, from, to, progressUpdater) -> progressUpdater.accept(to),\n+                            threadPool.generic()\n+                        );\n+\n+                        waitForGenericThreadPool(threadPool, expectedCompletedRanges.size() + 1L);\n+                        assertTrue(expectedCompletedRanges.add(range));\n+                        assertFalse(cacheFile.isFSynced());\n+                    }\n+\n+                    completedRanges = cacheFile.fsync();\n+                    assertNumberOfFSyncs(cacheFile.getFile(), equalTo(1L + expectedCompletedRanges.size()));\n+                    assertThat(completedRanges.size(), equalTo(expectedCompletedRanges.size()));\n+                    assertTrue(cacheFile.isFSynced());\n+                }\n+\n+                assertArrayEquals(cacheFile.fsync().toArray(Tuple[]::new), expectedCompletedRanges.toArray(Tuple[]::new));\n+            } finally {\n+                cacheFile.release(listener);\n+                terminate(threadPool);\n+            }\n+        }\n+    }\n+\n+    public void testFSyncOnEvictedFile() throws Exception {\n+        try (FSyncTrackingFileSystemProvider fileSystem = setupFSyncCountingFileSystem()) {\n+            final CacheFile cacheFile = new CacheFile(\"test\", randomNonNegativeLong(), fileSystem.resolve(\"test\"));\n+            assertFalse(cacheFile.isFSynced());\n+\n+            final TestEvictionListener listener = new TestEvictionListener();\n+            cacheFile.acquire(listener);\n+\n+            final TestThreadPool threadPool = new TestThreadPool(getTestName());\n+            try {\n+                final boolean completeRangeBeforeEviction = randomBoolean();\n+                if (completeRangeBeforeEviction) {\n+                    final long start = randomLongBetween(0L, Math.max(0L, cacheFile.getLength() - 1L));\n+                    final long end = randomLongBetween(start, cacheFile.getLength());\n+                    final Tuple<Long, Long> range = Tuple.tuple(start, end);\n+                    cacheFile.populateAndRead(\n+                        range,\n+                        range,\n+                        channel -> Math.toIntExact(end - start),\n+                        (channel, from, to, progressUpdater) -> progressUpdater.accept(to),\n+                        threadPool.generic()\n+                    );\n+\n+                    waitForGenericThreadPool(threadPool, 1L);\n+                    assertFalse(cacheFile.isFSynced());\n+\n+                    final List<Tuple<Long, Long>> completedRanges = cacheFile.fsync();\n+                    assertNumberOfFSyncs(cacheFile.getFile(), equalTo(1L));\n+                    assertThat(completedRanges, hasSize(1));\n+                    assertTrue(cacheFile.isFSynced());\n+                }\n+\n+                cacheFile.startEviction();\n+                expectThrows(AlreadyClosedException.class, cacheFile::fsync);", "originalCommit": "314212ba6f368d50d9989659708641e8ed4987de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzMjU4MA==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r515932580", "bodyText": "I agree. In case of an evicted file the method will now return an empty collection. See #64201 (comment)", "author": "tlrx", "createdAt": "2020-11-02T12:16:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyNjE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzMDczNQ==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r513430735", "bodyText": "I wonder if this is necessary, since there is no waiting above?", "author": "henningandersen", "createdAt": "2020-10-28T13:13:42Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -398,4 +406,52 @@ private FileChannelReference acquireFileChannelReference() {\n         ensureOpen();\n         return tracker.getAbsentRangeWithin(start, end);\n     }\n+\n+    // used in tests\n+    boolean isFSynced() {\n+        return fsynced.get();\n+    }\n+\n+    /**\n+     * Ensure that all ranges of data written to the cache file are written to the storage device that contains it. This method returns the\n+     * list of all successfully written ranges of data since the creation of the cache file.\n+     *\n+     * @return the list of ranges of data available in cache at the time this method is invoked\n+     * @throws IOException                       if the cache file failed to be fsync\n+     * @throws AlreadyClosedException            if the cache file is evicted\n+     * @throws java.nio.file.NoSuchFileException if the cache file does not exist\n+     */\n+    public List<Tuple<Long, Long>> fsync() throws IOException {\n+        ensureOpen();\n+        if (refCounter.tryIncRef()) {\n+            try {\n+                // Capture the completed ranges before fsyncing; ranges that are completed after this point won't be considered as\n+                // persisted on disk by the caller of this method, even if they are fully written to disk at the time the file\n+                // fsync is effectively executed\n+                final List<Tuple<Long, Long>> completedRanges = tracker.getCompletedRanges();\n+                assert completedRanges != null;\n+\n+                if (fsynced.compareAndSet(false, true)) {\n+                    boolean success = false;\n+                    try {\n+                        // check again if the file is evicted before doing expensive I/O", "originalCommit": "314212ba6f368d50d9989659708641e8ed4987de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzMjY2OA==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r515932668", "bodyText": "I removed it.", "author": "tlrx", "createdAt": "2020-11-02T12:17:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzMDczNQ=="}], "type": "inlineReview"}, {"oid": "6eea9006cc32def270240126785637afad5a3720", "url": "https://github.com/elastic/elasticsearch/commit/6eea9006cc32def270240126785637afad5a3720", "message": "fsynced no metadata", "committedDate": "2020-11-02T10:14:26Z", "type": "commit"}, {"oid": "2f8b0e71553feb8c3e6212b4abf0f9ba25c08b22", "url": "https://github.com/elastic/elasticsearch/commit/2f8b0e71553feb8c3e6212b4abf0f9ba25c08b22", "message": "fsynced at creation time", "committedDate": "2020-11-02T10:15:13Z", "type": "commit"}, {"oid": "7b3590edaa921b328efb5bd5c97162f9795b1c55", "url": "https://github.com/elastic/elasticsearch/commit/7b3590edaa921b328efb5bd5c97162f9795b1c55", "message": "sorted set", "committedDate": "2020-11-02T10:25:10Z", "type": "commit"}, {"oid": "d55278ebf5c6f6ccac3e7af06f3124700215a347", "url": "https://github.com/elastic/elasticsearch/commit/d55278ebf5c6f6ccac3e7af06f3124700215a347", "message": "feedback", "committedDate": "2020-11-02T12:11:08Z", "type": "commit"}, {"oid": "8f5d13b63718c425dbe72e58e0663e1e801df5d7", "url": "https://github.com/elastic/elasticsearch/commit/8f5d13b63718c425dbe72e58e0663e1e801df5d7", "message": "Merge branch 'master' into add-cache-file-fsync", "committedDate": "2020-11-02T12:53:41Z", "type": "commit"}, {"oid": "f0c3cbeaba8a51ed27910f0659053fe2950c8a8a", "url": "https://github.com/elastic/elasticsearch/commit/f0c3cbeaba8a51ed27910f0659053fe2950c8a8a", "message": "Merge branch 'master' into add-cache-file-fsync", "committedDate": "2020-11-03T07:32:02Z", "type": "commit"}, {"oid": "0d43e5b87144aaed017e43d745d2541620d3550c", "url": "https://github.com/elastic/elasticsearch/commit/0d43e5b87144aaed017e43d745d2541620d3550c", "message": "Merge branch 'master' into add-cache-file-fsync", "committedDate": "2020-11-03T10:13:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYxNzMxMw==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r516617313", "bodyText": "I wonder if calling this needsFsync (and reverting the boolean) would be slightly more intuitive?\nWith the current name, a reader would be inclined to think the boolean is only true when the file is fsync'ed, but this is not true (it is also still true while writing and completing the gap).", "author": "henningandersen", "createdAt": "2020-11-03T12:04:20Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -67,6 +70,14 @@ protected void closeInternal() {\n \n     private final Set<EvictionListener> listeners = new HashSet<>();\n \n+    /**\n+     * Indicates whether the cache file has been synchronized with the storage device that contains it, since the last time data\n+     * were written in cache (or since the creation of the file if no cached data have been written yet). An empty cache file is\n+     * considered as fsynced (the initialization value is {@code true}) when it is created; and writing new data to the cache file\n+     * will toggle the flag to {@code false}.\n+     **/\n+    private final AtomicBoolean fsynced = new AtomicBoolean(true);", "originalCommit": "0d43e5b87144aaed017e43d745d2541620d3550c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY1MTgwNw==", "url": "https://github.com/elastic/elasticsearch/pull/64201#discussion_r516651807", "bodyText": "Thanks, it makes sense. I pushed d8fdaaa2aab25e78033906f2fa8c956a6e340441.", "author": "tlrx", "createdAt": "2020-11-03T13:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYxNzMxMw=="}], "type": "inlineReview"}, {"oid": "d8fdaaa2aab25e78033906f2fa8c956a6e340441", "url": "https://github.com/elastic/elasticsearch/commit/d8fdaaa2aab25e78033906f2fa8c956a6e340441", "message": "needsFsync", "committedDate": "2020-11-03T13:05:19Z", "type": "commit"}]}