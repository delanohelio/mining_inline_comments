{"pr_number": 62640, "pr_title": "Prioritise recovery of system index shards", "pr_createdAt": "2020-09-18T15:12:05Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62640", "timeline": [{"oid": "445bf67671b01f5f640c313be5c8d27dc3f69aea", "url": "https://github.com/elastic/elasticsearch/commit/445bf67671b01f5f640c313be5c8d27dc3f69aea", "message": "Prioritise recovery of system index shards\n\nCloses #61660. When ordering shard for recovery, ensure system index\nshards are ordered first.", "committedDate": "2020-09-18T15:08:41Z", "type": "commit"}, {"oid": "15d2b69b51533b8f77418e8836eb8dfae8bf1461", "url": "https://github.com/elastic/elasticsearch/commit/15d2b69b51533b8f77418e8836eb8dfae8bf1461", "message": "Checkstyle", "committedDate": "2020-09-18T15:47:30Z", "type": "commit"}, {"oid": "67f7711bb3644be1ed2fdd936e6122e6cc392094", "url": "https://github.com/elastic/elasticsearch/commit/67f7711bb3644be1ed2fdd936e6122e6cc392094", "message": "Merge branch 'master' into 61660-prioritize-recovery-of-system-indices", "committedDate": "2020-09-22T09:08:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMDQ3MA==", "url": "https://github.com/elastic/elasticsearch/pull/62640#discussion_r492600470", "bodyText": "nit: since i can span to 99 using a prefix like \"idx_\" makes more sense", "author": "tlrx", "createdAt": "2020-09-22T09:35:27Z", "path": "server/src/test/java/org/elasticsearch/gateway/PriorityComparatorTests.java", "diffHunk": "@@ -106,75 +147,102 @@ protected Settings getIndexSettings(Index index) {\n     public void testPriorityComparatorSort() {\n         RoutingNodes.UnassignedShards shards = new RoutingNodes.UnassignedShards(mock(RoutingNodes.class));\n         int numIndices = randomIntBetween(3, 99);\n-        IndexMeta[] indices = new IndexMeta[numIndices];\n-        final Map<String, IndexMeta> map = new HashMap<>();\n+        IndexMetadata[] indices = new IndexMetadata[numIndices];\n+        final Map<String, IndexMetadata> map = new HashMap<>();\n \n         for (int i = 0; i < indices.length; i++) {\n+            int priority = 0;\n+            int creationDate = 0;\n+            boolean isSystem = false;\n+\n             if (frequently()) {\n-                indices[i] = new IndexMeta(\"idx_2015_04_\" + String.format(Locale.ROOT, \"%02d\", i), randomIntBetween(1, 1000),\n-                    randomIntBetween(1, 10000));\n-            } else { // sometimes just use defaults\n-                indices[i] = new IndexMeta(\"idx_2015_04_\" +  String.format(Locale.ROOT, \"%02d\", i));\n+                priority = randomIntBetween(1, 1000);\n+                creationDate = randomIntBetween(1, 10000);\n             }\n-            map.put(indices[i].name, indices[i]);\n+            if (rarely()) {\n+                isSystem = true;\n+            }\n+            // else sometimes just use the defaults\n+\n+            indices[i] = IndexMetadata.builder(\"idx_2015_04_\" + String.format(Locale.ROOT, \"%02d\", i))", "originalCommit": "67f7711bb3644be1ed2fdd936e6122e6cc392094", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYyNjA2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62640#discussion_r492626069", "bodyText": "Are you suggesting just \"idx_\" + i?\nI'm not sure what the best thing to do here is. The comparator class just does a compareTo on the index names, so in a sense it doesn't matter what index names we use, so long as the result is sorted the way we expect. However, the intention of the sort is that newer indices, according to dates in the index names, are sorted first. So I wonder if it's worth preserving a date-like pattern in the index names for that reason? What do you think?", "author": "pugnascotia", "createdAt": "2020-09-22T10:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMDQ3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0MDg1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62640#discussion_r492640857", "bodyText": "I think that we should test what the code is effectively doing, ie alphabetically sorting by index names. Applying this to index names that contain a date is sort of a workaround as most of the time SETTING_CREATION_DATE should be present. Prioritizing index-0002 over index-0001 is also a thing.", "author": "tlrx", "createdAt": "2020-09-22T10:50:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMDQ3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0NDY5MA==", "url": "https://github.com/elastic/elasticsearch/pull/62640#discussion_r492644690", "bodyText": "I swapped it for just \"idx_%04d\". Any better?", "author": "pugnascotia", "createdAt": "2020-09-22T10:57:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMDQ3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0NjY1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62640#discussion_r492646659", "bodyText": "Thanks!", "author": "tlrx", "createdAt": "2020-09-22T11:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMDQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNDIwOA==", "url": "https://github.com/elastic/elasticsearch/pull/62640#discussion_r492604208", "bodyText": "Maybe\nassertThat(\"system mismatch, expected:\" + currentMeta.isSystem() + \" after \" + prevMeta.isSystem(),\nBoolean.compare(prevMeta.isSystem(), currentMeta.isSystem()), greaterThanOrEqualTo(0));", "author": "tlrx", "createdAt": "2020-09-22T09:41:45Z", "path": "server/src/test/java/org/elasticsearch/gateway/PriorityComparatorTests.java", "diffHunk": "@@ -106,75 +147,102 @@ protected Settings getIndexSettings(Index index) {\n     public void testPriorityComparatorSort() {\n         RoutingNodes.UnassignedShards shards = new RoutingNodes.UnassignedShards(mock(RoutingNodes.class));\n         int numIndices = randomIntBetween(3, 99);\n-        IndexMeta[] indices = new IndexMeta[numIndices];\n-        final Map<String, IndexMeta> map = new HashMap<>();\n+        IndexMetadata[] indices = new IndexMetadata[numIndices];\n+        final Map<String, IndexMetadata> map = new HashMap<>();\n \n         for (int i = 0; i < indices.length; i++) {\n+            int priority = 0;\n+            int creationDate = 0;\n+            boolean isSystem = false;\n+\n             if (frequently()) {\n-                indices[i] = new IndexMeta(\"idx_2015_04_\" + String.format(Locale.ROOT, \"%02d\", i), randomIntBetween(1, 1000),\n-                    randomIntBetween(1, 10000));\n-            } else { // sometimes just use defaults\n-                indices[i] = new IndexMeta(\"idx_2015_04_\" +  String.format(Locale.ROOT, \"%02d\", i));\n+                priority = randomIntBetween(1, 1000);\n+                creationDate = randomIntBetween(1, 10000);\n             }\n-            map.put(indices[i].name, indices[i]);\n+            if (rarely()) {\n+                isSystem = true;\n+            }\n+            // else sometimes just use the defaults\n+\n+            indices[i] = IndexMetadata.builder(\"idx_2015_04_\" + String.format(Locale.ROOT, \"%02d\", i))\n+                .system(isSystem)\n+                .settings(buildSettings(creationDate, priority))\n+                .build();\n+\n+            map.put(indices[i].getIndex().getName(), indices[i]);\n         }\n         int numShards = randomIntBetween(10, 100);\n         for (int i = 0; i < numShards; i++) {\n-            IndexMeta indexMeta = randomFrom(indices);\n-            shards.add(TestShardRouting.newShardRouting(indexMeta.name, randomIntBetween(1, 5), null, null,\n+            IndexMetadata indexMeta = randomFrom(indices);\n+            shards.add(TestShardRouting.newShardRouting(indexMeta.getIndex().getName(), randomIntBetween(1, 5), null, null,\n                     randomBoolean(), ShardRoutingState.UNASSIGNED, new UnassignedInfo(randomFrom(UnassignedInfo.Reason.values()),\n                     \"foobar\")));\n         }\n         shards.sort(new PriorityComparator() {\n             @Override\n-            protected Settings getIndexSettings(Index index) {\n-                IndexMeta indexMeta = map.get(index.getName());\n-                return indexMeta.settings;\n+            protected IndexMetadata getMetadata(Index index) {\n+                return map.get(index.getName());\n             }\n         });\n         ShardRouting previous = null;\n         for (ShardRouting routing : shards) {\n             if (previous != null) {\n-                IndexMeta prevMeta = map.get(previous.getIndexName());\n-                IndexMeta currentMeta = map.get(routing.getIndexName());\n-                if (prevMeta.priority == currentMeta.priority) {\n-                    if (prevMeta.creationDate == currentMeta.creationDate) {\n-                        if (prevMeta.name.equals(currentMeta.name) == false) {\n-                            assertTrue(\"indexName mismatch, expected:\" + currentMeta.name + \" after \" + prevMeta.name + \" \" +\n-                                prevMeta.name.compareTo(currentMeta.name), prevMeta.name.compareTo(currentMeta.name) > 0);\n+                IndexMetadata prevMeta = map.get(previous.getIndexName());\n+                IndexMetadata currentMeta = map.get(routing.getIndexName());\n+\n+                if (prevMeta.isSystem() == currentMeta.isSystem()) {\n+                    final int prevPriority = prevMeta.getSettings().getAsInt(IndexMetadata.SETTING_PRIORITY, -1);\n+                    final int currentPriority = currentMeta.getSettings().getAsInt(IndexMetadata.SETTING_PRIORITY, -1);\n+\n+                    if (prevPriority == currentPriority) {\n+                        final int prevCreationDate = prevMeta.getSettings().getAsInt(IndexMetadata.SETTING_CREATION_DATE, -1);\n+                        final int currentCreationDate = currentMeta.getSettings().getAsInt(IndexMetadata.SETTING_CREATION_DATE, -1);\n+\n+                        if (prevCreationDate == currentCreationDate) {\n+                            final String prevName = prevMeta.getIndex().getName();\n+                            final String currentName = currentMeta.getIndex().getName();\n+\n+                            if (prevName.equals(currentName) == false) {\n+                                assertTrue(\n+                                    \"indexName mismatch, expected:\"\n+                                        + currentName\n+                                        + \" after \"\n+                                        + prevName\n+                                        + \" \"\n+                                        + prevName.compareTo(currentName),\n+                                    prevName.compareTo(currentName) > 0\n+                                );\n+                            }\n+                        } else {\n+                            assertTrue(\n+                                \"creationDate mismatch, expected:\" + currentCreationDate + \" after \" + prevCreationDate,\n+                                prevCreationDate > currentCreationDate\n+                            );\n                         }\n                     } else {\n-                        assertTrue(\"creationDate mismatch, expected:\" + currentMeta.creationDate + \" after \" + prevMeta.creationDate,\n-                            prevMeta.creationDate > currentMeta.creationDate);\n+                        assertTrue(\n+                            \"priority mismatch, expected:\" + currentPriority + \" after \" + prevPriority,\n+                            prevPriority > currentPriority\n+                        );\n                     }\n                 } else {\n-                    assertTrue(\"priority mismatch, expected:\" +  currentMeta.priority + \" after \" + prevMeta.priority,\n-                        prevMeta.priority > currentMeta.priority);\n+                    assertTrue(", "originalCommit": "67f7711bb3644be1ed2fdd936e6122e6cc392094", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0MDg2OA==", "url": "https://github.com/elastic/elasticsearch/pull/62640#discussion_r492640868", "bodyText": "I changed it to a modified version of your suggestion, using greaterThan(). I also changed the other assertions for consistency.", "author": "pugnascotia", "createdAt": "2020-09-22T10:50:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNDIwOA=="}], "type": "inlineReview"}, {"oid": "1906210360d39afb1cf42d24228f474f7229d16f", "url": "https://github.com/elastic/elasticsearch/commit/1906210360d39afb1cf42d24228f474f7229d16f", "message": "Test tweaks", "committedDate": "2020-09-22T10:50:15Z", "type": "commit"}, {"oid": "e7f3082441de956d41ce455909ac5e5f82e443fb", "url": "https://github.com/elastic/elasticsearch/commit/e7f3082441de956d41ce455909ac5e5f82e443fb", "message": "Drop date part of index name in PriorityComparatorTests", "committedDate": "2020-09-22T10:56:31Z", "type": "commit"}]}