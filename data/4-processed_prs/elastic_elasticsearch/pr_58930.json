{"pr_number": 58930, "pr_title": "Histogram integration on Histogram field type", "pr_createdAt": "2020-07-02T14:58:08Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58930", "timeline": [{"oid": "92e31203972ee2316cccb62c6172a37032f1a3bd", "url": "https://github.com/elastic/elasticsearch/commit/92e31203972ee2316cccb62c6172a37032f1a3bd", "message": "Started implementation (WIP - broken build)", "committedDate": "2020-06-17T09:19:08Z", "type": "commit"}, {"oid": "d4eada540a616f013a3ace81b80b62e10c8c2321", "url": "https://github.com/elastic/elasticsearch/commit/d4eada540a616f013a3ace81b80b62e10c8c2321", "message": "Merge branch 'master' into histo_histo_agg", "committedDate": "2020-07-02T08:06:36Z", "type": "commit"}, {"oid": "3c11cd9f50fc913cdc342157504c54cfd0780937", "url": "https://github.com/elastic/elasticsearch/commit/3c11cd9f50fc913cdc342157504c54cfd0780937", "message": "Rolled back changes in HistoBackedAvgAggregator", "committedDate": "2020-07-02T08:17:46Z", "type": "commit"}, {"oid": "cb56b39e77ca8d33511a6b90c05a38018e8cb310", "url": "https://github.com/elastic/elasticsearch/commit/cb56b39e77ca8d33511a6b90c05a38018e8cb310", "message": "Moved HistoBackedHistogramAggregator to its own package.\n\nChanged class visibility for the rest of the aggregations", "committedDate": "2020-07-02T14:52:33Z", "type": "commit"}, {"oid": "5e8464178a9011d0b51b11977a11c983be8509bd", "url": "https://github.com/elastic/elasticsearch/commit/5e8464178a9011d0b51b11977a11c983be8509bd", "message": "Added unit test for HistoBackedHistogramAggregator", "committedDate": "2020-07-02T14:52:57Z", "type": "commit"}, {"oid": "9f8e89ba081889ee0edebe8b3b50299bee086e17", "url": "https://github.com/elastic/elasticsearch/commit/9f8e89ba081889ee0edebe8b3b50299bee086e17", "message": "Implemented histo agg", "committedDate": "2020-07-03T14:30:07Z", "type": "commit"}, {"oid": "51ba48d44f3b49aeaf5e070b5d842effb35e52c1", "url": "https://github.com/elastic/elasticsearch/commit/51ba48d44f3b49aeaf5e070b5d842effb35e52c1", "message": "Completed implementation and added tests", "committedDate": "2020-07-03T18:13:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3NTQ4OA==", "url": "https://github.com/elastic/elasticsearch/pull/58930#discussion_r449675488", "bodyText": "Is this the correct place to disallow sub-aggregations?", "author": "csoulios", "createdAt": "2020-07-03T18:15:27Z", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/aggregations/bucket/histogram/HistoBackedHistogramAggregator.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.analytics.aggregations.bucket.histogram;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.index.fielddata.HistogramValue;\n+import org.elasticsearch.index.fielddata.HistogramValues;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.AggregatorFactories;\n+import org.elasticsearch.search.aggregations.BucketOrder;\n+import org.elasticsearch.search.aggregations.LeafBucketCollector;\n+import org.elasticsearch.search.aggregations.LeafBucketCollectorBase;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AbstractHistogramAggregator;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;\n+import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.xpack.analytics.aggregations.support.HistogramValuesSource;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+public class HistoBackedHistogramAggregator extends AbstractHistogramAggregator {\n+\n+    private final HistogramValuesSource.Histogram valuesSource;\n+\n+    public HistoBackedHistogramAggregator(\n+        String name,\n+        AggregatorFactories factories,\n+        double interval,\n+        double offset,\n+        BucketOrder order,\n+        boolean keyed,\n+        long minDocCount,\n+        double minBound,\n+        double maxBound,\n+        ValuesSourceConfig valuesSourceConfig,\n+        SearchContext context,\n+        Aggregator parent,\n+        boolean collectsFromSingleBucket,\n+        Map<String, Object> metadata) throws IOException {\n+        super(name, factories, interval, offset, order, keyed, minDocCount, minBound, maxBound,\n+            valuesSourceConfig.format(), context, parent, collectsFromSingleBucket, metadata);\n+\n+        // TODO: Stop using null here\n+        this.valuesSource = valuesSourceConfig.hasValues() ? (HistogramValuesSource.Histogram) valuesSourceConfig.getValuesSource() : null;\n+\n+        // Sub aggregations are not allowed when running histogram agg over histograms\n+        if (subAggregators().length > 0) {", "originalCommit": "51ba48d44f3b49aeaf5e070b5d842effb35e52c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU1NDE5OA==", "url": "https://github.com/elastic/elasticsearch/pull/58930#discussion_r451554198", "bodyText": "Yeah, I think this is probably the best location since we don't have access to the factory from the plugin", "author": "polyfractal", "createdAt": "2020-07-08T13:43:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3NTQ4OA=="}], "type": "inlineReview"}, {"oid": "fd787dbdd9ff983acb21044a8fc1bc868a3a26eb", "url": "https://github.com/elastic/elasticsearch/commit/fd787dbdd9ff983acb21044a8fc1bc868a3a26eb", "message": "Fix broken tests", "committedDate": "2020-07-06T16:08:33Z", "type": "commit"}, {"oid": "cc3163ca6ba4ed510247d5ecf9c0987cb45b6bee", "url": "https://github.com/elastic/elasticsearch/commit/cc3163ca6ba4ed510247d5ecf9c0987cb45b6bee", "message": "Added docs", "committedDate": "2020-07-06T17:05:04Z", "type": "commit"}, {"oid": "0bee2101ca37058f994e929f82b593c673cf92dc", "url": "https://github.com/elastic/elasticsearch/commit/0bee2101ca37058f994e929f82b593c673cf92dc", "message": "Merge branch 'master' into histo_histo_agg", "committedDate": "2020-07-06T18:02:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM5MzIyNg==", "url": "https://github.com/elastic/elasticsearch/pull/58930#discussion_r450393226", "bodyText": "Perhaps we need to improve wording here. This is a subtle concept and we must be as clear as possible on the message", "author": "csoulios", "createdAt": "2020-07-06T18:05:03Z", "path": "docs/reference/aggregations/bucket/histogram-aggregation.asciidoc", "diffHunk": "@@ -286,3 +286,92 @@ POST /sales/_search?size=0\n // TEST[setup:sales]\n \n <1> Documents without a value in the `quantity` field will fall into the same bucket as documents that have the value `0`.\n+\n+[[search-aggregations-bucket-histogram-aggregation-histogram-fields]]\n+==== Histogram fields\n+\n+Running a histogram aggregation over histogram fields computes the total number of counts for each interval.\n+\n+For example, for the following index that stores pre-aggregated histograms with latency metrics (in milliseconds) for different networks:\n+\n+[source,console]\n+--------------------------------------------------\n+PUT metrics_index/_doc/1\n+{\n+  \"network.name\" : \"net-1\",\n+  \"latency_histo\" : {\n+      \"values\" : [1, 3, 8, 12, 15],\n+      \"counts\" : [3, 7, 23, 12, 6]\n+   }\n+}\n+\n+PUT metrics_index/_doc/2\n+{\n+  \"network.name\" : \"net-2\",\n+  \"latency_histo\" : {\n+      \"values\" : [1, 6, 8, 12, 14],\n+      \"counts\" : [8, 17, 8, 7, 6]\n+   }\n+}\n+\n+POST /metrics_index/_search?size=0\n+{\n+    \"aggs\" : {\n+        \"latency_buckets\" : {\n+            \"histogram\" : {\n+                \"field\" : \"latency_histo\",\n+                \"interval\" : 5\n+            }\n+        }\n+    }\n+}\n+--------------------------------------------------\n+\n+\n+The `histogram` aggregation will sum the counts of each interval computed based on the `values` and\n+return the following output:\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+    ...\n+    \"aggregations\": {\n+        \"prices\" : {\n+            \"buckets\": [\n+                {\n+                    \"key\": 0.0,\n+                    \"doc_count\": 18\n+                },\n+                {\n+                    \"key\": 5.0,\n+                    \"doc_count\": 48\n+                },\n+                {\n+                    \"key\": 10.0,\n+                    \"doc_count\": 25\n+                },\n+                {\n+                    \"key\": 15.0,\n+                    \"doc_count\": 6\n+                }\n+            ]\n+        }\n+    }\n+}\n+--------------------------------------------------\n+// TESTRESPONSE[skip:test not setup]\n+\n+[IMPORTANT]\n+========\n+Histogram aggregation is a bucket aggregation, which partitions documents into buckets rather than calculating metrics over fields like\n+metrics aggregations do. Each bucket represents a collection of documents which sub-aggregations can run on.\n+On the other hand, a histogram field is a pre-aggregated field representing multiple values inside a single field:\n+buckets of numerical data and a count of items/documents for each bucket. This mismatch between the histogram aggregations expected input\n+(expecting raw documents) and the histogram field (that provides summary information) limits the outcome of the aggregation\n+to only the doc counts for each bucket.\n+\n+\n+**Consequently, when executing a histogram aggregation over a histogram field, no sub-aggregations are supported.**\n+========", "originalCommit": "cc3163ca6ba4ed510247d5ecf9c0987cb45b6bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9dd94e15047e3f3288ece53326623d0b0cdd3de7", "url": "https://github.com/elastic/elasticsearch/commit/9dd94e15047e3f3288ece53326623d0b0cdd3de7", "message": "Added yml integration test", "committedDate": "2020-07-07T12:21:43Z", "type": "commit"}, {"oid": "142279ba62094bdabb5e47935e8a95730f304290", "url": "https://github.com/elastic/elasticsearch/commit/142279ba62094bdabb5e47935e8a95730f304290", "message": "Merge branch 'master' into histo_histo_agg", "committedDate": "2020-07-07T12:23:01Z", "type": "commit"}, {"oid": "79023f33e5a5bd7d2de9bce1e6409b373002bfe7", "url": "https://github.com/elastic/elasticsearch/commit/79023f33e5a5bd7d2de9bce1e6409b373002bfe7", "message": "Minor documentation changes", "committedDate": "2020-07-07T12:49:00Z", "type": "commit"}, {"oid": "bce6a8f2305dcf2ad25160013c8c98ea1e711be2", "url": "https://github.com/elastic/elasticsearch/commit/bce6a8f2305dcf2ad25160013c8c98ea1e711be2", "message": "Fixed breaking changes from master", "committedDate": "2020-07-07T13:05:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI0MTQ3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58930#discussion_r452241477", "bodyText": "I think rather than iterating count times, we can lookup the bucketOrd once, call collectExistingBucket() / collectBucket() as appropriate, and then finally call incrementBucketDocCount() with count-1.  That way we don't have to keep re-adding to the same ord just to increment the count, and should be a bit faster I think.", "author": "polyfractal", "createdAt": "2020-07-09T14:02:56Z", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/aggregations/bucket/histogram/HistoBackedHistogramAggregator.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.analytics.aggregations.bucket.histogram;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.index.fielddata.HistogramValue;\n+import org.elasticsearch.index.fielddata.HistogramValues;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.AggregatorFactories;\n+import org.elasticsearch.search.aggregations.BucketOrder;\n+import org.elasticsearch.search.aggregations.CardinalityUpperBound;\n+import org.elasticsearch.search.aggregations.LeafBucketCollector;\n+import org.elasticsearch.search.aggregations.LeafBucketCollectorBase;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AbstractHistogramAggregator;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;\n+import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.xpack.analytics.aggregations.support.HistogramValuesSource;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+public class HistoBackedHistogramAggregator extends AbstractHistogramAggregator {\n+\n+    private final HistogramValuesSource.Histogram valuesSource;\n+\n+    public HistoBackedHistogramAggregator(\n+        String name,\n+        AggregatorFactories factories,\n+        double interval,\n+        double offset,\n+        BucketOrder order,\n+        boolean keyed,\n+        long minDocCount,\n+        double minBound,\n+        double maxBound,\n+        ValuesSourceConfig valuesSourceConfig,\n+        SearchContext context,\n+        Aggregator parent,\n+        CardinalityUpperBound cardinalityUpperBound,\n+        Map<String, Object> metadata) throws IOException {\n+        super(name, factories, interval, offset, order, keyed, minDocCount, minBound, maxBound,\n+            valuesSourceConfig.format(), context, parent, cardinalityUpperBound, metadata);\n+\n+        // TODO: Stop using null here\n+        this.valuesSource = valuesSourceConfig.hasValues() ? (HistogramValuesSource.Histogram) valuesSourceConfig.getValuesSource() : null;\n+\n+        // Sub aggregations are not allowed when running histogram agg over histograms\n+        if (subAggregators().length > 0) {\n+            throw new IllegalArgumentException(\"Histogram aggregation on histogram fields does not support sub-aggregations\");\n+        }\n+    }\n+\n+    @Override\n+    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx,\n+            final LeafBucketCollector sub) throws IOException {\n+        if (valuesSource == null) {\n+            return LeafBucketCollector.NO_OP_COLLECTOR;\n+        }\n+\n+        final HistogramValues values = valuesSource.getHistogramValues(ctx);\n+        return new LeafBucketCollectorBase(sub, values) {\n+            @Override\n+            public void collect(int doc, long owningBucketOrd) throws IOException {\n+                if (values.advanceExact(doc)) {\n+                    final HistogramValue sketch = values.histogram();\n+\n+                    double previousKey = Double.NEGATIVE_INFINITY;\n+                    while (sketch.next()) {\n+                        final double value = sketch.value();\n+                        final int count = sketch.count();\n+\n+                        double key = Math.floor((value - offset) / interval);\n+                        assert key >= previousKey;\n+                        for (int i = 0; i < count; ++i) {", "originalCommit": "bce6a8f2305dcf2ad25160013c8c98ea1e711be2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI0Mzg2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58930#discussion_r452243867", "bodyText": "I thought about it some more and can't think of a better/clearer way to express this concept... so \ud83d\udc4d and maybe we can tweak it later if we think of a better way.  I think it's clear what the limitations are so I'm not too concerned.", "author": "polyfractal", "createdAt": "2020-07-09T14:06:25Z", "path": "docs/reference/aggregations/bucket/histogram-aggregation.asciidoc", "diffHunk": "@@ -286,3 +286,93 @@ POST /sales/_search?size=0\n // TEST[setup:sales]\n \n <1> Documents without a value in the `quantity` field will fall into the same bucket as documents that have the value `0`.\n+\n+[[search-aggregations-bucket-histogram-aggregation-histogram-fields]]\n+==== Histogram fields\n+\n+Running a histogram aggregation over histogram fields computes the total number of counts for each interval.\n+\n+For example, executing a histogram aggregation against the following index that stores pre-aggregated histograms\n+with latency metrics (in milliseconds) for different networks:\n+\n+[source,console]\n+--------------------------------------------------\n+PUT metrics_index/_doc/1\n+{\n+  \"network.name\" : \"net-1\",\n+  \"latency_histo\" : {\n+      \"values\" : [1, 3, 8, 12, 15],\n+      \"counts\" : [3, 7, 23, 12, 6]\n+   }\n+}\n+\n+PUT metrics_index/_doc/2\n+{\n+  \"network.name\" : \"net-2\",\n+  \"latency_histo\" : {\n+      \"values\" : [1, 6, 8, 12, 14],\n+      \"counts\" : [8, 17, 8, 7, 6]\n+   }\n+}\n+\n+POST /metrics_index/_search?size=0\n+{\n+    \"aggs\" : {\n+        \"latency_buckets\" : {\n+            \"histogram\" : {\n+                \"field\" : \"latency_histo\",\n+                \"interval\" : 5\n+            }\n+        }\n+    }\n+}\n+--------------------------------------------------\n+\n+\n+The `histogram` aggregation will sum the counts of each interval computed based on the `values` and\n+return the following output:\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+    ...\n+    \"aggregations\": {\n+        \"prices\" : {\n+            \"buckets\": [\n+                {\n+                    \"key\": 0.0,\n+                    \"doc_count\": 18\n+                },\n+                {\n+                    \"key\": 5.0,\n+                    \"doc_count\": 48\n+                },\n+                {\n+                    \"key\": 10.0,\n+                    \"doc_count\": 25\n+                },\n+                {\n+                    \"key\": 15.0,\n+                    \"doc_count\": 6\n+                }\n+            ]\n+        }\n+    }\n+}\n+--------------------------------------------------\n+// TESTRESPONSE[skip:test not setup]\n+\n+[IMPORTANT]\n+========\n+Histogram aggregation is a bucket aggregation, which partitions documents into buckets rather than calculating metrics over fields like", "originalCommit": "bce6a8f2305dcf2ad25160013c8c98ea1e711be2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e08597fc5355ee506229c6125f101ec80a9b4c38", "url": "https://github.com/elastic/elasticsearch/commit/e08597fc5355ee506229c6125f101ec80a9b4c38", "message": "Simplified the way docs are counted", "committedDate": "2020-07-13T10:13:34Z", "type": "commit"}, {"oid": "4f554a97603dcfeae6d5564538712637d0847bfd", "url": "https://github.com/elastic/elasticsearch/commit/4f554a97603dcfeae6d5564538712637d0847bfd", "message": "Merge branch 'master' into histo_histo_agg", "committedDate": "2020-07-13T11:53:12Z", "type": "commit"}]}