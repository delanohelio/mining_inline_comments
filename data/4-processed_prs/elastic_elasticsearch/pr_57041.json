{"pr_number": 57041, "pr_title": "Fix delete_expired_data/nightly maintenance when many model snapshots need deleting", "pr_createdAt": "2020-05-21T13:39:26Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/57041", "timeline": [{"oid": "e5becf81fd4e3d66b2a53680fd8145594b220eba", "url": "https://github.com/elastic/elasticsearch/commit/e5becf81fd4e3d66b2a53680fd8145594b220eba", "message": "Extract time extractor method", "committedDate": "2020-05-21T11:37:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY2MDk5OA==", "url": "https://github.com/elastic/elasticsearch/pull/57041#discussion_r428660998", "bodyText": "nit: indenting is out by 1 space by the look of it", "author": "droberts195", "createdAt": "2020-05-21T13:46:22Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/extractor/TimeField.java", "diffHunk": "@@ -44,23 +45,7 @@ public Method getMethod() {\n             return value;\n         }\n         if (value[0] instanceof String) { // doc_value field with the epoch_millis format\n-            // Since nanosecond support was added epoch_millis timestamps may have a fractional component.\n-            // We discard this, taking just whole milliseconds.  Arguably it would be better to retain the\n-            // precision here and let the downstream component decide whether it wants the accuracy, but\n-            // that makes it hard to pass around the value as a number.  The double type doesn't have\n-            // enough digits of accuracy, and obviously long cannot store the fraction.  BigDecimal would\n-            // work, but that isn't supported by the JSON parser if the number gets round-tripped through\n-            // JSON.  So String is really the only format that could be used, but the ML consumers of time\n-            // are expecting a number.\n-            String strVal0 = (String) value[0];\n-            int dotPos = strVal0.indexOf('.');\n-            if (dotPos == -1) {\n-                value[0] = Long.parseLong(strVal0);\n-            } else if (dotPos > 0) {\n-                value[0] = Long.parseLong(strVal0.substring(0, dotPos));\n-            } else {\n-                value[0] = 0L;\n-            }\n+           value[0] = TimeUtils.parseToEpochMs((String)value[0]);", "originalCommit": "8a7366d39ac86746467cd167e1ba95ceba994202", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY2MjAyMA==", "url": "https://github.com/elastic/elasticsearch/pull/57041#discussion_r428662020", "bodyText": "Would it be better to return long?  In the case where the caller wants Long it can be boxed just as efficiently on the caller's side.  And if the caller wants long then there's no boxing and unboxing.", "author": "droberts195", "createdAt": "2020-05-21T13:48:11Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/common/time/TimeUtils.java", "diffHunk": "@@ -46,6 +46,37 @@ public static Instant parseTimeFieldToInstant(XContentParser parser, String fiel\n             \"unexpected token [\" + parser.currentToken() + \"] for [\" + fieldName + \"]\");\n     }\n \n+    /**\n+     * Safely parses a string epoch representation to a Long\n+     *\n+     * Commonly this function is used for parsing Date fields from doc values\n+     * requested with the format \"epoch_millis\".\n+     *\n+     * Since nanosecond support was added epoch_millis timestamps may have a fractional component.\n+     * We discard this, taking just whole milliseconds.  Arguably it would be better to retain the\n+     * precision here and let the downstream component decide whether it wants the accuracy, but\n+     * that makes it hard to pass around the value as a number.  The double type doesn't have\n+     * enough digits of accuracy, and obviously long cannot store the fraction.  BigDecimal would\n+     * work, but that isn't supported by the JSON parser if the number gets round-tripped through\n+     * JSON.  So String is really the only format that could be used, but the consumers of time\n+     * are expecting a number.\n+     *\n+     * @param epoch The\n+     * @return The epoch value.\n+     */\n+    public static Long parseToEpochMs(String epoch) {", "originalCommit": "8a7366d39ac86746467cd167e1ba95ceba994202", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY2NDEyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/57041#discussion_r428664121", "bodyText": "Maybe we should log an error here, as I don't think this should never happen unless a document is corrupt.  So if it does happen it would be useful to know about when debugging why results haven't been deleted.", "author": "droberts195", "createdAt": "2020-05-21T13:51:38Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/retention/ExpiredModelSnapshotsRemover.java", "diffHunk": "@@ -175,19 +191,28 @@ protected void removeDataBefore(\n             public void onResponse(SearchResponse searchResponse) {\n                 long nextToKeepMs = deleteAllBeforeMs;\n                 try {\n-                    List<ModelSnapshot> modelSnapshots = new ArrayList<>();\n+                    List<JobSnapshotId> snapshotIds = new ArrayList<>();\n                     for (SearchHit hit : searchResponse.getHits()) {\n-                        ModelSnapshot modelSnapshot = ModelSnapshot.fromJson(hit.getSourceRef());\n-                        long timestampMs = modelSnapshot.getTimestamp().getTime();\n+                        String timestamp = stringFieldValueOrNull(hit, ModelSnapshot.TIMESTAMP.getPreferredName());\n+                        if (timestamp == null) {\n+                            continue;", "originalCommit": "8a7366d39ac86746467cd167e1ba95ceba994202", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY2NDYwNg==", "url": "https://github.com/elastic/elasticsearch/pull/57041#discussion_r428664606", "bodyText": "Could use long instead of Long and avoid unboxing in the loop.", "author": "droberts195", "createdAt": "2020-05-21T13:52:28Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/retention/ExpiredModelSnapshotsRemover.java", "diffHunk": "@@ -175,19 +191,28 @@ protected void removeDataBefore(\n             public void onResponse(SearchResponse searchResponse) {\n                 long nextToKeepMs = deleteAllBeforeMs;\n                 try {\n-                    List<ModelSnapshot> modelSnapshots = new ArrayList<>();\n+                    List<JobSnapshotId> snapshotIds = new ArrayList<>();\n                     for (SearchHit hit : searchResponse.getHits()) {\n-                        ModelSnapshot modelSnapshot = ModelSnapshot.fromJson(hit.getSourceRef());\n-                        long timestampMs = modelSnapshot.getTimestamp().getTime();\n+                        String timestamp = stringFieldValueOrNull(hit, ModelSnapshot.TIMESTAMP.getPreferredName());\n+                        if (timestamp == null) {\n+                            continue;\n+                        }\n+                        Long timestampMs = TimeUtils.parseToEpochMs(timestamp);", "originalCommit": "8a7366d39ac86746467cd167e1ba95ceba994202", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY2NjgyMg==", "url": "https://github.com/elastic/elasticsearch/pull/57041#discussion_r428666822", "bodyText": "Alternatively, you could get rid of epochMs and use return statement in each of 3 if branches.", "author": "przemekwitek", "createdAt": "2020-05-21T13:56:02Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/common/time/TimeUtils.java", "diffHunk": "@@ -46,6 +46,37 @@ public static Instant parseTimeFieldToInstant(XContentParser parser, String fiel\n             \"unexpected token [\" + parser.currentToken() + \"] for [\" + fieldName + \"]\");\n     }\n \n+    /**\n+     * Safely parses a string epoch representation to a Long\n+     *\n+     * Commonly this function is used for parsing Date fields from doc values\n+     * requested with the format \"epoch_millis\".\n+     *\n+     * Since nanosecond support was added epoch_millis timestamps may have a fractional component.\n+     * We discard this, taking just whole milliseconds.  Arguably it would be better to retain the\n+     * precision here and let the downstream component decide whether it wants the accuracy, but\n+     * that makes it hard to pass around the value as a number.  The double type doesn't have\n+     * enough digits of accuracy, and obviously long cannot store the fraction.  BigDecimal would\n+     * work, but that isn't supported by the JSON parser if the number gets round-tripped through\n+     * JSON.  So String is really the only format that could be used, but the consumers of time\n+     * are expecting a number.\n+     *\n+     * @param epoch The\n+     * @return The epoch value.\n+     */\n+    public static Long parseToEpochMs(String epoch) {\n+        int dotPos = epoch.indexOf('.');\n+        long epochMs = 0L;", "originalCommit": "8a7366d39ac86746467cd167e1ba95ceba994202", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODczMTU0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/57041#discussion_r428731547", "bodyText": "Yes that does read better", "author": "davidkyle", "createdAt": "2020-05-21T15:34:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY2NjgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY2NzU0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/57041#discussion_r428667541", "bodyText": "Please write sth here.", "author": "przemekwitek", "createdAt": "2020-05-21T13:57:14Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/common/time/TimeUtils.java", "diffHunk": "@@ -46,6 +46,37 @@ public static Instant parseTimeFieldToInstant(XContentParser parser, String fiel\n             \"unexpected token [\" + parser.currentToken() + \"] for [\" + fieldName + \"]\");\n     }\n \n+    /**\n+     * Safely parses a string epoch representation to a Long\n+     *\n+     * Commonly this function is used for parsing Date fields from doc values\n+     * requested with the format \"epoch_millis\".\n+     *\n+     * Since nanosecond support was added epoch_millis timestamps may have a fractional component.\n+     * We discard this, taking just whole milliseconds.  Arguably it would be better to retain the\n+     * precision here and let the downstream component decide whether it wants the accuracy, but\n+     * that makes it hard to pass around the value as a number.  The double type doesn't have\n+     * enough digits of accuracy, and obviously long cannot store the fraction.  BigDecimal would\n+     * work, but that isn't supported by the JSON parser if the number gets round-tripped through\n+     * JSON.  So String is really the only format that could be used, but the consumers of time\n+     * are expecting a number.\n+     *\n+     * @param epoch The", "originalCommit": "8a7366d39ac86746467cd167e1ba95ceba994202", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODczMTQzMw==", "url": "https://github.com/elastic/elasticsearch/pull/57041#discussion_r428731433", "bodyText": "\ud83d\ude04", "author": "davidkyle", "createdAt": "2020-05-21T15:34:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY2NzU0MQ=="}], "type": "inlineReview"}, {"oid": "a69f90a74e3ccf042ac5a1a8eafe7dab8ec4e88a", "url": "https://github.com/elastic/elasticsearch/commit/a69f90a74e3ccf042ac5a1a8eafe7dab8ec4e88a", "message": "Don't get source", "committedDate": "2020-05-21T15:29:44Z", "type": "commit"}, {"oid": "a69f90a74e3ccf042ac5a1a8eafe7dab8ec4e88a", "url": "https://github.com/elastic/elasticsearch/commit/a69f90a74e3ccf042ac5a1a8eafe7dab8ec4e88a", "message": "Don't get source", "committedDate": "2020-05-21T15:29:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc1MDA2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/57041#discussion_r428750063", "bodyText": "Will removing this make:\n         if (hits.getTotalHits().value > MAX_FORECASTS) {\n             LOGGER.info(\"More than [{}] forecasts were found. This run will only delete [{}] of them\", MAX_FORECASTS, MAX_FORECASTS);\n         }\n\nless useful?  (Around line 141/145.)", "author": "droberts195", "createdAt": "2020-05-21T15:58:31Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/retention/ExpiredForecastsRemover.java", "diffHunk": "@@ -84,7 +78,11 @@ public void remove(float requestsPerSec, ActionListener<Boolean> listener, Suppl\n                 .filter(QueryBuilders.termQuery(Result.RESULT_TYPE.getPreferredName(), ForecastRequestStats.RESULT_TYPE_VALUE))\n                 .filter(QueryBuilders.existsQuery(ForecastRequestStats.EXPIRY_TIME.getPreferredName())));\n         source.size(MAX_FORECASTS);\n-        source.trackTotalHits(true);", "originalCommit": "a69f90a74e3ccf042ac5a1a8eafe7dab8ec4e88a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc1NTE4NA==", "url": "https://github.com/elastic/elasticsearch/pull/57041#discussion_r428755184", "bodyText": "Good spot I couldn't see where it was checked so removed it.\nThe benefit of setting trackTotalHits(true) as the only purpose is to log this message saying there are more forecasts to be deleted later. However, in the interest of making this change as small as possible I've reverted this line", "author": "davidkyle", "createdAt": "2020-05-21T16:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc1MDA2Mw=="}], "type": "inlineReview"}, {"oid": "60936c0b2bf9225e207e1e16ebd8b0ad0999e045", "url": "https://github.com/elastic/elasticsearch/commit/60936c0b2bf9225e207e1e16ebd8b0ad0999e045", "message": "Revert to tracking total hits", "committedDate": "2020-05-21T16:03:52Z", "type": "commit"}]}