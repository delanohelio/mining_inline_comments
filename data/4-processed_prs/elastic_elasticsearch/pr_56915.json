{"pr_number": 56915, "pr_title": "Move merge compatibility logic from MappedFieldType to FieldMapper", "pr_createdAt": "2020-05-18T14:36:52Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/56915", "timeline": [{"oid": "a49d77cac5b5e20165d12804da783cbcc6e3d201", "url": "https://github.com/elastic/elasticsearch/commit/a49d77cac5b5e20165d12804da783cbcc6e3d201", "message": "Move merge compatibility logic from MappedFieldType to FieldMapper", "committedDate": "2020-05-18T14:25:50Z", "type": "commit"}, {"oid": "a1e8418b4cb6e8cb8660556895d4ae2c7d5f1975", "url": "https://github.com/elastic/elasticsearch/commit/a1e8418b4cb6e8cb8660556895d4ae2c7d5f1975", "message": "checkstyle", "committedDate": "2020-05-18T14:56:27Z", "type": "commit"}, {"oid": "941c15b0af63f74e2e9de711b8821d8a1783792c", "url": "https://github.com/elastic/elasticsearch/commit/941c15b0af63f74e2e9de711b8821d8a1783792c", "message": "Exception types in parent-join", "committedDate": "2020-05-18T15:08:32Z", "type": "commit"}, {"oid": "41e79d504ea764a9e94c1787cf7e0ad49c27e0b8", "url": "https://github.com/elastic/elasticsearch/commit/41e79d504ea764a9e94c1787cf7e0ad49c27e0b8", "message": "icu error message", "committedDate": "2020-05-18T15:31:25Z", "type": "commit"}, {"oid": "b7da9e8b0bf444a243d988c51ddfc33ffcc1d8d9", "url": "https://github.com/elastic/elasticsearch/commit/b7da9e8b0bf444a243d988c51ddfc33ffcc1d8d9", "message": "better icu_collation_keyword update tests", "committedDate": "2020-05-18T15:45:20Z", "type": "commit"}, {"oid": "0b0852bc495721393ad3ef04f971f9128e41b1ff", "url": "https://github.com/elastic/elasticsearch/commit/0b0852bc495721393ad3ef04f971f9128e41b1ff", "message": "compare types using contentType, not class", "committedDate": "2020-05-18T17:50:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc4NTA2NA==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r426785064", "bodyText": "It seems like we could reuse the existing test classes MockFieldMapper and FakeFieldType here.", "author": "jtibshirani", "createdAt": "2020-05-18T17:28:18Z", "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/FieldMapperTestCase.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.analysis.standard.StandardAnalyzer;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.similarities.BM25Similarity;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.analysis.AnalyzerScope;\n+import org.elasticsearch.index.analysis.NamedAnalyzer;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.similarity.SimilarityProvider;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+\n+import static org.hamcrest.Matchers.containsString;\n+\n+public abstract class FieldMapperTestCase<T extends FieldMapper.Builder<?>> extends ESSingleNodeTestCase {\n+\n+    protected final Settings SETTINGS = Settings.builder()\n+        .put(\"index.version.created\", Version.CURRENT)\n+        .build();\n+\n+    private final class Modifier {\n+        final String property;\n+        final boolean updateable;\n+        final BiConsumer<T, T> modifier;\n+\n+        Modifier(String property, boolean updateable, BiConsumer<T, T> modifier) {\n+            this.property = property;\n+            this.updateable = updateable;\n+            this.modifier = modifier;\n+        }\n+\n+        void apply(T first, T second) {\n+            modifier.accept(first, second);\n+        }\n+    }\n+\n+    private Modifier booleanModifier(String name, boolean updateable, BiConsumer<T, Boolean> method) {\n+        return new Modifier(name, updateable, (a, b) -> {\n+            method.accept(a, true);\n+            method.accept(b, false);\n+        });\n+    }\n+\n+    private Object dummyNullValue = \"dummyvalue\";\n+\n+    /** Sets the null value used by the modifier for null value testing. This should be set in an @Before method. */\n+    protected void setDummyNullValue(Object value) {\n+        dummyNullValue = value;\n+    }\n+\n+    protected boolean supportsDocValues() {\n+        return true;\n+    }\n+\n+    protected boolean supportsStore() {\n+        return true;\n+    }\n+\n+    private final List<Modifier> modifiers = new ArrayList<>(Arrays.asList(\n+        new Modifier(\"analyzer\", false, (a, b) -> {\n+            a.indexAnalyzer(new NamedAnalyzer(\"a\", AnalyzerScope.INDEX, new StandardAnalyzer()));\n+            a.indexAnalyzer(new NamedAnalyzer(\"b\", AnalyzerScope.INDEX, new StandardAnalyzer()));\n+        }),\n+        new Modifier(\"boost\", true, (a, b) -> {\n+           a.fieldType().setBoost(1.1f);\n+           b.fieldType().setBoost(1.2f);\n+        }),\n+        new Modifier(\"doc_values\", supportsDocValues() == false, (a, b) -> {\n+            if (supportsDocValues()) {\n+                a.docValues(true);\n+                b.docValues(false);\n+            }\n+        }),\n+        booleanModifier(\"eager_global_ordinals\", true, (a, t) -> a.fieldType().setEagerGlobalOrdinals(t)),\n+        booleanModifier(\"norms\", false, FieldMapper.Builder::omitNorms),\n+        new Modifier(\"null_value\", true, (a, b) -> {\n+            a.fieldType().setNullValue(dummyNullValue);\n+        }),\n+        new Modifier(\"search_analyzer\", true, (a, b) -> {\n+            a.searchAnalyzer(new NamedAnalyzer(\"a\", AnalyzerScope.INDEX, new StandardAnalyzer()));\n+            a.searchAnalyzer(new NamedAnalyzer(\"b\", AnalyzerScope.INDEX, new StandardAnalyzer()));\n+        }),\n+        new Modifier(\"search_quote_analyzer\", true, (a, b) -> {\n+            a.searchQuoteAnalyzer(new NamedAnalyzer(\"a\", AnalyzerScope.INDEX, new StandardAnalyzer()));\n+            a.searchQuoteAnalyzer(new NamedAnalyzer(\"b\", AnalyzerScope.INDEX, new StandardAnalyzer()));\n+        }),\n+        new Modifier(\"similarity\", false, (a, b) -> {\n+            a.similarity(new SimilarityProvider(\"a\", new BM25Similarity()));\n+            b.similarity(new SimilarityProvider(\"b\", new BM25Similarity()));\n+        }),\n+        new Modifier(\"store\", supportsStore() == false, (a, b) -> {\n+            if (supportsStore()) {\n+                a.store(true);\n+                b.store(false);\n+            }\n+        }),\n+        new Modifier(\"term_vector\", false, (a, b) -> {\n+            a.storeTermVectors(true);\n+            b.storeTermVectors(false);\n+        }),\n+        new Modifier(\"term_vector_positions\", false, (a, b) -> {\n+            a.storeTermVectors(true);\n+            b.storeTermVectors(true);\n+            a.storeTermVectorPositions(true);\n+            b.storeTermVectorPositions(false);\n+        }),\n+        new Modifier(\"term_vector_payloads\", false, (a, b) -> {\n+            a.storeTermVectors(true);\n+            b.storeTermVectors(true);\n+            a.storeTermVectorPositions(true);\n+            b.storeTermVectorPositions(true);\n+            a.storeTermVectorPayloads(true);\n+            b.storeTermVectorPayloads(false);\n+        }),\n+        new Modifier(\"term_vector_offsets\", false, (a, b) -> {\n+            a.storeTermVectors(true);\n+            b.storeTermVectors(true);\n+            a.storeTermVectorPositions(true);\n+            b.storeTermVectorPositions(true);\n+            a.storeTermVectorOffsets(true);\n+            b.storeTermVectorOffsets(false);\n+        })\n+    ));\n+\n+    /**\n+     * Add type-specific modifiers for consistency checking.\n+     *\n+     * This should be called in a {@code @Before} method\n+     */\n+    protected void addModifier(String property, boolean updateable, BiConsumer<T, T> method) {\n+        modifiers.add(new Modifier(property, updateable, method));\n+    }\n+\n+    /**\n+     * Add type-specific modifiers for consistency checking.\n+     *\n+     * This should be called in a {@code @Before} method\n+     */\n+    protected void addBooleanModifier(String property, boolean updateable, BiConsumer<T, Boolean> method) {\n+        modifiers.add(new Modifier(property, updateable, (a, b) -> {\n+            method.accept(a, true);\n+            method.accept(b, false);\n+        }));\n+    }\n+\n+    protected abstract T newBuilder();\n+\n+    private static class BogusFieldType extends MappedFieldType {", "originalCommit": "b7da9e8b0bf444a243d988c51ddfc33ffcc1d8d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgxODQyNg==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r426818426", "bodyText": "++", "author": "romseygeek", "createdAt": "2020-05-18T18:31:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc4NTA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc4ODczNQ==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r426788735", "bodyText": "It looks like this test was lost in the refactor. Do we have plans to replace it or make it no longer necessary?", "author": "jtibshirani", "createdAt": "2020-05-18T17:35:09Z", "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/FieldTypeTestCase.java", "diffHunk": "@@ -283,92 +95,6 @@ public void testEquals() {\n         assertEquals(ft1, ft2); // symmetric\n         assertEquals(ft2, ft1);\n         assertEquals(ft1.hashCode(), ft2.hashCode());\n-\n-        for (Modifier modifier : modifiers) {\n-            ft1 = createNamedDefaultFieldType();\n-            ft2 = createNamedDefaultFieldType();\n-            modifier.modify(ft2);\n-            assertFieldTypeNotEquals(modifier.property, ft1, ft2);\n-            assertNotEquals(\"hash code for modified property \" + modifier.property, ft1.hashCode(), ft2.hashCode());\n-            // modify the same property and they are equal again\n-            modifier.modify(ft1);\n-            assertFieldTypeEquals(modifier.property, ft1, ft2);\n-            assertEquals(\"hash code for modified property \" + modifier.property, ft1.hashCode(), ft2.hashCode());\n-        }\n-    }\n-\n-    public void testFreeze() {", "originalCommit": "b7da9e8b0bf444a243d988c51ddfc33ffcc1d8d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgxODY4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r426818686", "bodyText": "The next step will be to decouple FieldType and MappedFieldType entirely, so there won't need to be a freeze() method here at all.", "author": "romseygeek", "createdAt": "2020-05-18T18:32:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc4ODczNQ=="}], "type": "inlineReview"}, {"oid": "b59cedc67df4610186583e930ccfbdefc9efc3c8", "url": "https://github.com/elastic/elasticsearch/commit/b59cedc67df4610186583e930ccfbdefc9efc3c8", "message": "test; feedback", "committedDate": "2020-05-18T18:30:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxNTUyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r426915529", "bodyText": "To me the error message \"mapper [foo] cannot be changed from type [long] to [double]\" is a lot clearer, we could prefer that original wording.\nOn a related note, it looks like MappedFieldType#checkTypeName is now unused and can be removed.", "author": "jtibshirani", "createdAt": "2020-05-18T21:58:49Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/UpdateMappingTests.java", "diffHunk": "@@ -101,19 +101,13 @@ public void testConflictSameType() throws Exception {\n                 .startObject(\"properties\").startObject(\"foo\").field(\"type\", \"double\").endObject()\n                 .endObject().endObject().endObject();\n \n-        try {\n-            mapperService.merge(\"type\", new CompressedXContent(Strings.toString(update)), MapperService.MergeReason.MAPPING_UPDATE);\n-            fail();\n-        } catch (IllegalArgumentException e) {\n-            assertThat(e.getMessage(), containsString(\"mapper [foo] cannot be changed from type [long] to [double]\"));\n-        }\n+        IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () ->\n+            mapperService.merge(\"type\", new CompressedXContent(Strings.toString(update)), MapperService.MergeReason.MAPPING_UPDATE));\n+        assertThat(e.getMessage(), containsString(\"mapper [foo] of different type, current_type [long], merged_type [double]\"));", "originalCommit": "b59cedc67df4610186583e930ccfbdefc9efc3c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIzMjIwOA==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427232208", "bodyText": "++", "author": "romseygeek", "createdAt": "2020-05-19T11:34:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxNTUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxODMwNw==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r426918307", "bodyText": "I just noticed we've lost test coverage for the equals method, which is used in FieldTypeLookup. This is too bad, I wonder if we could we keep these modifiers around or switch to using EqualsHashCodeTestUtils#checkEqualsAndHashCode.", "author": "jtibshirani", "createdAt": "2020-05-18T22:06:17Z", "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/FieldTypeTestCase.java", "diffHunk": "@@ -283,92 +95,6 @@ public void testEquals() {\n         assertEquals(ft1, ft2); // symmetric\n         assertEquals(ft2, ft1);\n         assertEquals(ft1.hashCode(), ft2.hashCode());\n-\n-        for (Modifier modifier : modifiers) {\n-            ft1 = createNamedDefaultFieldType();\n-            ft2 = createNamedDefaultFieldType();\n-            modifier.modify(ft2);\n-            assertFieldTypeNotEquals(modifier.property, ft1, ft2);", "originalCommit": "b59cedc67df4610186583e930ccfbdefc9efc3c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIzMjk5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427232997", "bodyText": "With luck we'll be able to simplify a lot of the MapperService lookup stuff once things have been rearranged, but for now I agree we still need these tests.  I've modified FieldTypeTestCase to allow testing of subtypes with modifiers, using EqualsHashCodeTestUtils.", "author": "romseygeek", "createdAt": "2020-05-19T11:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxODMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyOTMzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r426929335", "bodyText": "I think this could just be FIeldMapper toMerge = new MockFieldMapper(\"bogus\") ?", "author": "jtibshirani", "createdAt": "2020-05-18T22:37:12Z", "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/FieldMapperTestCase.java", "diffHunk": "@@ -203,8 +179,8 @@ public void testMergeConflicts() {\n         }\n         {\n             FieldMapper mapper = (FieldMapper) newBuilder().build(context);\n-            FieldMapper toMerge = new FieldMapper(\"bogus\", new BogusFieldType(), new BogusFieldType(),\n-                SETTINGS, FieldMapper.MultiFields.empty(), FieldMapper.CopyTo.empty()) {\n+            FieldMapper toMerge = new FieldMapper(\"bogus\", new MockFieldMapper.FakeFieldType(),", "originalCommit": "b59cedc67df4610186583e930ccfbdefc9efc3c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIzMjI4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427232287", "bodyText": "It could, thanks!", "author": "romseygeek", "createdAt": "2020-05-19T11:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyOTMzNQ=="}], "type": "inlineReview"}, {"oid": "eae93a9c5010ba237560ea76a79a336b4d85f7a2", "url": "https://github.com/elastic/elasticsearch/commit/eae93a9c5010ba237560ea76a79a336b4d85f7a2", "message": "Equas/hashcode tests for MappedFieldType", "committedDate": "2020-05-19T11:33:41Z", "type": "commit"}, {"oid": "4ce12a660362c5ed62472b3dbe1c2c6d70ba3c4e", "url": "https://github.com/elastic/elasticsearch/commit/4ce12a660362c5ed62472b3dbe1c2c6d70ba3c4e", "message": "mapping message", "committedDate": "2020-05-19T11:46:06Z", "type": "commit"}, {"oid": "e03d4e0fb7c3f4350ad6b231de4ab3522f59fef6", "url": "https://github.com/elastic/elasticsearch/commit/e03d4e0fb7c3f4350ad6b231de4ab3522f59fef6", "message": "test; jobmanager pattern match", "committedDate": "2020-05-19T13:05:43Z", "type": "commit"}, {"oid": "e9fb0d595794c78ef67a85474a371470abaaecf3", "url": "https://github.com/elastic/elasticsearch/commit/e9fb0d595794c78ef67a85474a371470abaaecf3", "message": "Simplify merging methods", "committedDate": "2020-05-19T13:40:45Z", "type": "commit"}, {"oid": "ed92cd198c36a935da7ccf0b1cd3533dc6099472", "url": "https://github.com/elastic/elasticsearch/commit/ed92cd198c36a935da7ccf0b1cd3533dc6099472", "message": "rawtypes", "committedDate": "2020-05-19T13:59:23Z", "type": "commit"}, {"oid": "a9cf7d5ba648e1806c32ffc3ceac3c76ddd0f98b", "url": "https://github.com/elastic/elasticsearch/commit/a9cf7d5ba648e1806c32ffc3ceac3c76ddd0f98b", "message": "Merge remote-tracking branch 'origin/master' into mapper/merge-checks", "committedDate": "2020-05-19T13:59:40Z", "type": "commit"}, {"oid": "ee7c14a7d8ab018dcd96743d380e89d5154585ec", "url": "https://github.com/elastic/elasticsearch/commit/ee7c14a7d8ab018dcd96743d380e89d5154585ec", "message": "oops", "committedDate": "2020-05-19T14:33:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzOTMxMw==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427439313", "bodyText": "Should this test have been deleted?", "author": "jtibshirani", "createdAt": "2020-05-19T16:32:31Z", "path": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldTypeTests.java", "diffHunk": "@@ -1,30 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.spatial.index.mapper;\n-\n-import org.elasticsearch.common.geo.builders.ShapeBuilder;\n-import org.elasticsearch.index.mapper.FieldTypeTestCase;\n-import org.elasticsearch.index.mapper.MappedFieldType;\n-import org.junit.Before;\n-\n-public class GeoShapeWithDocValuesFieldTypeTests extends FieldTypeTestCase {", "originalCommit": "ee7c14a7d8ab018dcd96743d380e89d5154585ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3Mjg3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427472875", "bodyText": "It should not!  Have restored it.", "author": "romseygeek", "createdAt": "2020-05-19T17:25:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzOTMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MDU2OA==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427440568", "bodyText": "Great that this is abstract, I like how it encourages implementors to think through what can be updated vs. not.", "author": "jtibshirani", "createdAt": "2020-05-19T16:34:10Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -334,32 +334,88 @@ protected FieldMapper clone() {\n     }\n \n     @Override\n-    public FieldMapper merge(Mapper mergeWith) {\n+    public final FieldMapper merge(Mapper mergeWith) {\n         FieldMapper merged = clone();\n-        merged.doMerge(mergeWith);\n+        List<String> conflicts = new ArrayList<>();\n+        if (mergeWith instanceof FieldMapper == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + fieldType.name() + \"] cannot be changed from type [\"\n+            + contentType() + \"] to [\" + mergeWith.getClass().getSimpleName() + \"]\");\n+        }\n+        merged.mergeSharedOptions((FieldMapper)mergeWith, conflicts);\n+        if (conflicts.isEmpty() == false) {\n+            throw new IllegalArgumentException(\"Mapper for [\" + name() +\n+                \"] conflicts with existing mapping:\\n\" + conflicts.toString());\n+        }\n         return merged;\n     }\n \n-    /**\n-     * Merge changes coming from {@code mergeWith} in place.\n-     */\n-    protected void doMerge(Mapper mergeWith) {\n-        if (!this.getClass().equals(mergeWith.getClass())) {\n-            String mergedType = mergeWith.getClass().getSimpleName();\n-            if (mergeWith instanceof FieldMapper) {\n-                mergedType = ((FieldMapper) mergeWith).contentType();\n+    private void mergeSharedOptions(FieldMapper mergeWith, List<String> conflicts) {\n+\n+        if (Objects.equals(this.contentType(), mergeWith.contentType()) == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + fieldType().name() + \"] cannot be changed from type [\" + contentType()\n+                + \"] to [\" + mergeWith.contentType() + \"]\");\n+        }\n+\n+        MappedFieldType other = mergeWith.fieldType;\n+\n+        boolean indexed =  fieldType.indexOptions() != IndexOptions.NONE;\n+        boolean mergeWithIndexed = other.indexOptions() != IndexOptions.NONE;\n+        // TODO: should be validating if index options go \"up\" (but \"down\" is ok)\n+        if (indexed != mergeWithIndexed) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [index] values\");\n+        }\n+        if (fieldType.stored() != other.stored()) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [store] values\");\n+        }\n+        if (fieldType.hasDocValues() != other.hasDocValues()) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [doc_values] values\");\n+        }\n+        if (fieldType.omitNorms() && !other.omitNorms()) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [norms] values, cannot change from disable to enabled\");\n+        }\n+        if (fieldType.storeTermVectors() != other.storeTermVectors()) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [store_term_vector] values\");\n+        }\n+        if (fieldType.storeTermVectorOffsets() != other.storeTermVectorOffsets()) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [store_term_vector_offsets] values\");\n+        }\n+        if (fieldType.storeTermVectorPositions() != other.storeTermVectorPositions()) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [store_term_vector_positions] values\");\n+        }\n+        if (fieldType.storeTermVectorPayloads() != other.storeTermVectorPayloads()) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [store_term_vector_payloads] values\");\n+        }\n+\n+        // null and \"default\"-named index analyzers both mean the default is used\n+        if (fieldType.indexAnalyzer() == null || \"default\".equals(fieldType.indexAnalyzer().name())) {\n+            if (other.indexAnalyzer() != null && \"default\".equals(other.indexAnalyzer().name()) == false) {\n+                conflicts.add(\"mapper [\" + name() + \"] has different [analyzer]\");\n             }\n-            throw new IllegalArgumentException(\"mapper [\" + fieldType().name() + \"] of different type, current_type [\" + contentType()\n-                + \"], merged_type [\" + mergedType + \"]\");\n+        } else if (other.indexAnalyzer() == null || \"default\".equals(other.indexAnalyzer().name())) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [analyzer]\");\n+        } else if (fieldType.indexAnalyzer().name().equals(other.indexAnalyzer().name()) == false) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [analyzer]\");\n+        }\n+\n+        if (Objects.equals(fieldType.similarity(), other.similarity()) == false) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [similarity]\");\n         }\n-        FieldMapper fieldMergeWith = (FieldMapper) mergeWith;\n-        multiFields = multiFields.merge(fieldMergeWith.multiFields);\n \n-        // apply changeable values\n-        this.fieldType = fieldMergeWith.fieldType;\n-        this.copyTo = fieldMergeWith.copyTo;\n+        mergeOptions(mergeWith, conflicts);\n+\n+        if (conflicts.isEmpty()) {\n+            multiFields = multiFields.merge(mergeWith.multiFields);\n+            // apply changeable values\n+            this.fieldType = mergeWith.fieldType;\n+            this.copyTo = mergeWith.copyTo;\n+        }\n     }\n \n+    /**\n+     * Merge type-specific options and check for incompatible settings in mappings to be merged\n+     */\n+    protected abstract void mergeOptions(FieldMapper other, List<String> conflicts);", "originalCommit": "ee7c14a7d8ab018dcd96743d380e89d5154585ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MzY0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427443647", "bodyText": "Small comment, calling mergeOptions directly from here could be nice:\nFieldMapper fieldMapper = (FieldMapper) mergeWith;\nmerged.mergeSharedOptions(fieldMapper, conflicts);\nmerged.mergeOptions(fieldMapper, conflicts);", "author": "jtibshirani", "createdAt": "2020-05-19T16:39:07Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -334,32 +334,88 @@ protected FieldMapper clone() {\n     }\n \n     @Override\n-    public FieldMapper merge(Mapper mergeWith) {\n+    public final FieldMapper merge(Mapper mergeWith) {\n         FieldMapper merged = clone();\n-        merged.doMerge(mergeWith);\n+        List<String> conflicts = new ArrayList<>();\n+        if (mergeWith instanceof FieldMapper == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + fieldType.name() + \"] cannot be changed from type [\"\n+            + contentType() + \"] to [\" + mergeWith.getClass().getSimpleName() + \"]\");\n+        }\n+        merged.mergeSharedOptions((FieldMapper)mergeWith, conflicts);", "originalCommit": "ee7c14a7d8ab018dcd96743d380e89d5154585ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MzA1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427473056", "bodyText": "++, I've rearranged things here.", "author": "romseygeek", "createdAt": "2020-05-19T17:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MzY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NDQ0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427444446", "bodyText": "I think we dropped this modifier accidentally.", "author": "jtibshirani", "createdAt": "2020-05-19T16:40:21Z", "path": "modules/mapper-extras/src/test/java/org/elasticsearch/index/mapper/ScaledFloatFieldTypeTests.java", "diffHunk": "@@ -51,22 +50,6 @@ protected MappedFieldType createDefaultFieldType() {\n         return ft;\n     }\n \n-    @Before\n-    public void setupProperties() {", "originalCommit": "ee7c14a7d8ab018dcd96743d380e89d5154585ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MTQ4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427471486", "bodyText": "scaling_factor can't be updated, so we'd never be in a position when FieldTypeLookup would be comparing and old and new types with different scaling factors.", "author": "romseygeek", "createdAt": "2020-05-19T17:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NDQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NTI5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427445293", "bodyText": "Should this have been deleted?", "author": "jtibshirani", "createdAt": "2020-05-19T16:41:40Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/CompletionFieldTypeTests.java", "diffHunk": "@@ -1,59 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.elasticsearch.index.mapper;\n-\n-import org.elasticsearch.search.suggest.completion.context.ContextBuilder;\n-import org.elasticsearch.search.suggest.completion.context.ContextMappings;\n-import org.junit.Before;\n-\n-import java.util.Arrays;\n-\n-public class CompletionFieldTypeTests extends FieldTypeTestCase {", "originalCommit": "ee7c14a7d8ab018dcd96743d380e89d5154585ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MjQ5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427472492", "bodyText": "Again, none of these values can be updated in a merge, so we don't need an equality check.", "author": "romseygeek", "createdAt": "2020-05-19T17:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NTI5Mw=="}], "type": "inlineReview"}, {"oid": "7e58b1aac992f96b3b9ed749361cb8267ec84883", "url": "https://github.com/elastic/elasticsearch/commit/7e58b1aac992f96b3b9ed749361cb8267ec84883", "message": "feedback", "committedDate": "2020-05-19T17:25:04Z", "type": "commit"}, {"oid": "056482ab397530f85a364747c48690578221d6f3", "url": "https://github.com/elastic/elasticsearch/commit/056482ab397530f85a364747c48690578221d6f3", "message": "Do sub-mapper checks before replacing fieldtype", "committedDate": "2020-05-19T18:42:36Z", "type": "commit"}, {"oid": "5a1770a2e8d128f82dc9df66f3aa9318790b4243", "url": "https://github.com/elastic/elasticsearch/commit/5a1770a2e8d128f82dc9df66f3aa9318790b4243", "message": "sigh", "committedDate": "2020-05-19T19:14:04Z", "type": "commit"}, {"oid": "53dd899f18dd2a2ea7fbefc5c8ae5cd493303b74", "url": "https://github.com/elastic/elasticsearch/commit/53dd899f18dd2a2ea7fbefc5c8ae5cd493303b74", "message": "Merge remote-tracking branch 'origin/master' into mapper/merge-checks", "committedDate": "2020-05-19T19:40:30Z", "type": "commit"}]}