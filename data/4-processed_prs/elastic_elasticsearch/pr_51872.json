{"pr_number": 51872, "pr_title": "EQL: Add field resolution and verification", "pr_createdAt": "2020-02-04T16:01:47Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51872", "timeline": [{"oid": "14893bf26f0f739118284184f790c31a86f5b4a7", "url": "https://github.com/elastic/elasticsearch/commit/14893bf26f0f739118284184f790c31a86f5b4a7", "message": "EQL: Add field resolution and verification\n\nAdd basic field resolution inside the Analyzer and a basic Verifier to\ncheck for any unresolved fields", "committedDate": "2020-02-04T16:02:54Z", "type": "commit"}, {"oid": "14893bf26f0f739118284184f790c31a86f5b4a7", "url": "https://github.com/elastic/elasticsearch/commit/14893bf26f0f739118284184f790c31a86f5b4a7", "message": "EQL: Add field resolution and verification\n\nAdd basic field resolution inside the Analyzer and a basic Verifier to\ncheck for any unresolved fields", "committedDate": "2020-02-04T16:02:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc2ODQ5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51872#discussion_r374768492", "bodyText": "There will be a separate PR to externalize this to QL so it can be shared across SQL and EQL.", "author": "costin", "createdAt": "2020-02-04T16:11:09Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -42,4 +50,56 @@ private LogicalPlan verify(LogicalPlan plan) {\n         }\n         return plan;\n     }\n-}\n+\n+    private static class ResolveRefs extends AnalyzeRule<LogicalPlan> {\n+\n+        @Override\n+        protected LogicalPlan rule(LogicalPlan plan) {\n+            // if the children are not resolved, there's no way the node can be resolved\n+            if (!plan.childrenResolved()) {\n+                return plan;\n+            }\n+\n+            // okay, there's a chance so let's get started\n+            if (log.isTraceEnabled()) {\n+                log.trace(\"Attempting to resolve {}\", plan.nodeString());\n+            }\n+\n+            return plan.transformExpressionsUp(e -> {\n+                if (e instanceof UnresolvedAttribute) {\n+                    UnresolvedAttribute u = (UnresolvedAttribute) e;\n+                    List<Attribute> childrenOutput = new ArrayList<>();\n+                    for (LogicalPlan child : plan.children()) {\n+                        childrenOutput.addAll(child.output());\n+                    }\n+                    NamedExpression named = resolveAgainstList(u, childrenOutput);\n+                    // if resolved, return it; otherwise keep it in place to be resolved later\n+                    if (named != null) {\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"Resolved {} to {}\", u, named);\n+                        }\n+                        return named;\n+                    }\n+                }\n+                return e;\n+            });\n+        }\n+    }\n+\n+    abstract static class AnalyzeRule<SubPlan extends LogicalPlan> extends Rule<SubPlan, LogicalPlan> {", "originalCommit": "14893bf26f0f739118284184f790c31a86f5b4a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc2OTQ2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51872#discussion_r374769461", "bodyText": "I changed this since the data sample from existing EQL documentation uses event_type. If the default field should be changed, that is best addressed separately:\n\nfigure out what's the impact on backwards compatibility (ECS schema) and existing data\nupdate datasets\nupdate code (last).", "author": "costin", "createdAt": "2020-02-04T16:12:43Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LogicalPlanBuilder.java", "diffHunk": "@@ -11,20 +11,16 @@\n import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n import org.elasticsearch.xpack.ql.expression.predicate.logical.And;\n import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n-import org.elasticsearch.xpack.ql.index.EsIndex;\n-import org.elasticsearch.xpack.ql.plan.logical.EsRelation;\n import org.elasticsearch.xpack.ql.plan.logical.Filter;\n import org.elasticsearch.xpack.ql.plan.logical.LogicalPlan;\n+import org.elasticsearch.xpack.ql.plan.logical.UnresolvedRelation;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n \n-import static java.util.Collections.emptyMap;\n-\n public abstract class LogicalPlanBuilder extends ExpressionBuilder {\n \n     // TODO: these need to be made configurable\n-    private static final String EVENT_TYPE = \"event.category\";\n-    private static final EsIndex esIndex = new EsIndex(\"<not-specified>\", emptyMap());\n+    private static final String EVENT_TYPE = \"event_type\";", "originalCommit": "14893bf26f0f739118284184f790c31a86f5b4a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5NTk3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51872#discussion_r374795971", "bodyText": "was assuming that the data will be in ECS format\n    \"user\": {\n        \"group\": {}\n    },\n    \"host\": {\n        \"os\": {\n            \"platform\": \"windows\",\n            \"name\": \"Windows\"\n        },\n        \"ip\": \"127.0.0.1\",\n        \"hostname\": \"localhost\",\n        \"name\": \"localhost\"\n    },\n    \"event\": {\n        \"module\": \"endgame\",\n        \"dataset\": \"esensor\",\n        \"action\": \"already_running\",\n        \"category\": \"process\",\n        \"kind\": \"event\"\n    }, \n\nthus the event.category for EVENT_TYPE", "author": "aleksmaus", "createdAt": "2020-02-04T16:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc2OTQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwNDQ5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51872#discussion_r374804496", "bodyText": "\ud83d\udc4d", "author": "rw-access", "createdAt": "2020-02-04T17:09:47Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LogicalPlanBuilder.java", "diffHunk": "@@ -43,6 +39,6 @@ public LogicalPlan visitEventQuery(EqlBaseParser.EventQueryContext ctx) {\n \n         }\n \n-        return new Filter(source(ctx), new EsRelation(Source.EMPTY, esIndex, false), condition);\n+        return new Filter(source(ctx), new UnresolvedRelation(Source.EMPTY, null, \"\", false, \"\"), condition);", "originalCommit": "14893bf26f0f739118284184f790c31a86f5b4a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwNTQ2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51872#discussion_r374805467", "bodyText": "why does source() need to be checked here, but isn't in some of the other hashCode and equals functions?", "author": "rw-access", "createdAt": "2020-02-04T17:11:32Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/plan/logical/UnresolvedRelation.java", "diffHunk": "@@ -89,11 +89,11 @@ public boolean equals(Object obj) {\n         }\n \n         UnresolvedRelation other = (UnresolvedRelation) obj;\n-        return source().equals(other.source())\n-            && table.equals(other.table)\n+        return Objects.equals(source(), other.source())", "originalCommit": "14893bf26f0f739118284184f790c31a86f5b4a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgyOTg1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51872#discussion_r374829855", "bodyText": "It's an inconsistency - the source isn't relevant. Likely for UnresolvedRelation was added since a table or index declaration is not common and thus, its source was considered relevant.\nThe change above was added to avoid a NPE caused by a null (vs an empty) location.", "author": "costin", "createdAt": "2020-02-04T17:58:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwNTQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwNzAxOA==", "url": "https://github.com/elastic/elasticsearch/pull/51872#discussion_r374807018", "bodyText": "We may have to come back and clarify \"quotes\" in this message for #51443", "author": "rw-access", "createdAt": "2020-02-04T17:14:17Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/AnalysisUtils.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.analysis;\n+\n+import org.elasticsearch.xpack.ql.expression.Attribute;\n+import org.elasticsearch.xpack.ql.expression.FieldAttribute;\n+import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.type.InvalidMappedField;\n+import org.elasticsearch.xpack.ql.type.UnsupportedEsField;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+public final class AnalysisUtils {\n+\n+    private AnalysisUtils() {}\n+\n+    //\n+    // Shared methods around the analyzer rules\n+    //\n+    static Attribute resolveAgainstList(UnresolvedAttribute u, Collection<Attribute> attrList) {\n+        return resolveAgainstList(u, attrList, false);\n+    }\n+\n+    static Attribute resolveAgainstList(UnresolvedAttribute u, Collection<Attribute> attrList, boolean allowCompound) {\n+        List<Attribute> matches = new ArrayList<>();\n+\n+        // first take into account the qualified version\n+        boolean qualified = u.qualifier() != null;\n+\n+        for (Attribute attribute : attrList) {\n+            if (!attribute.synthetic()) {\n+                boolean match = qualified ? Objects.equals(u.qualifiedName(), attribute.qualifiedName()) :\n+                // if the field is unqualified\n+                // first check the names directly\n+                        (Objects.equals(u.name(), attribute.name())\n+                                // but also if the qualifier might not be quoted and if there's any ambiguity with nested fields\n+                                || Objects.equals(u.name(), attribute.qualifiedName()));\n+                if (match) {\n+                    matches.add(attribute.withLocation(u.source()));\n+                }\n+            }\n+        }\n+\n+        // none found\n+        if (matches.isEmpty()) {\n+            return null;\n+        }\n+\n+        if (matches.size() == 1) {\n+            return handleSpecialFields(u, matches.get(0), allowCompound);\n+        }\n+\n+        return u.withUnresolvedMessage(\n+                \"Reference [\" + u.qualifiedName() + \"] is ambiguous (to disambiguate use quotes or qualifiers); matches any of \"", "originalCommit": "14893bf26f0f739118284184f790c31a86f5b4a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}