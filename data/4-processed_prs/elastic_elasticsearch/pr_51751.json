{"pr_number": 51751, "pr_title": "Update persistent state document in the index the document belongs to", "pr_createdAt": "2020-01-31T15:49:24Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51751", "timeline": [{"oid": "889df4f6fc65734da4f34d91b6f44c227f3b4bcd", "url": "https://github.com/elastic/elasticsearch/commit/889df4f6fc65734da4f34d91b6f44c227f3b4bcd", "message": "Update persistent state document in the index the document belongs to", "committedDate": "2020-01-31T15:49:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU1NjE2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51751#discussion_r373556161", "bodyText": "This looks like a dangerous change.  Previously if the C++ wrote nothing but whitespace it was silently ignored.  Now it will cause the state processor to throw an exception and never process any subsequent state.\nI think the behaviour should be changed back to what it was for the pure whitespace case.  It's fine to throw an exception if a bulk metadata JSON object is invalid.  But if it's not present at all then I think we should maintain the previous behaviour of treating it as a no-op.  Otherwise a very careful audit of the C++ code will be required to find what situations it might write blank state.", "author": "droberts195", "createdAt": "2020-01-31T16:05:09Z", "path": "x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/process/IndexingStateProcessorTests.java", "diffHunk": "@@ -56,54 +64,92 @@\n \n     private IndexingStateProcessor stateProcessor;\n     private ResultsPersisterService resultsPersisterService;\n+    private SearchResponse searchResponse;\n \n     @Before\n     public void initialize() {\n+        searchResponse = mock(SearchResponse.class);\n+        when(searchResponse.status()).thenReturn(RestStatus.OK);\n         resultsPersisterService = mock(ResultsPersisterService.class);\n+        doReturn(searchResponse).when(resultsPersisterService).searchWithRetry(any(SearchRequest.class), any(), any(), any());\n+        doReturn(mock(BulkResponse.class)).when(resultsPersisterService).bulkIndexWithRetry(any(BulkRequest.class), any(), any(), any());\n         AnomalyDetectionAuditor auditor = mock(AnomalyDetectionAuditor.class);\n         stateProcessor = spy(new IndexingStateProcessor(JOB_ID, resultsPersisterService, auditor));\n-        when(resultsPersisterService.bulkIndexWithRetry(any(BulkRequest.class), any(), any(), any())).thenReturn(mock(BulkResponse.class));\n-        ThreadPool threadPool = mock(ThreadPool.class);\n-        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n     }\n \n     @After\n     public void verifyNoMoreClientInteractions() {\n-        Mockito.verifyNoMoreInteractions(resultsPersisterService);\n+        verifyNoMoreInteractions(resultsPersisterService);\n     }\n \n-    public void testStateRead() throws IOException {\n+    public void testExtractDocId() throws IOException {\n+        assertThat(IndexingStateProcessor.extractDocId(new BytesArray(STATE_SAMPLE.getBytes(StandardCharsets.UTF_8))), equalTo(\"1\"));\n+    }\n+\n+    private void testStateRead(SearchHits searchHits, String expectedIndexOrAlias) throws IOException {\n+        when(searchResponse.getHits()).thenReturn(searchHits);\n+\n         ByteArrayInputStream stream = new ByteArrayInputStream(STATE_SAMPLE.getBytes(StandardCharsets.UTF_8));\n         stateProcessor.process(stream);\n         ArgumentCaptor<BytesReference> bytesRefCaptor = ArgumentCaptor.forClass(BytesReference.class);\n-        verify(stateProcessor, times(3)).persist(bytesRefCaptor.capture());\n+        verify(stateProcessor, times(3)).persist(eq(expectedIndexOrAlias), bytesRefCaptor.capture());\n \n         String[] threeStates = STATE_SAMPLE.split(\"\\0\");\n         List<BytesReference> capturedBytes = bytesRefCaptor.getAllValues();\n         assertEquals(threeStates[0], capturedBytes.get(0).utf8ToString());\n         assertEquals(threeStates[1], capturedBytes.get(1).utf8ToString());\n         assertEquals(threeStates[2], capturedBytes.get(2).utf8ToString());\n+        verify(resultsPersisterService, times(3)).searchWithRetry(any(SearchRequest.class), any(), any(), any());\n         verify(resultsPersisterService, times(3)).bulkIndexWithRetry(any(BulkRequest.class), any(), any(), any());\n     }\n \n+    public void testStateRead_StateDocumentCreated() throws IOException {\n+        testStateRead(SearchHits.empty(), \".ml-state-write\");\n+    }\n+\n+    public void testStateRead_StateDocumentUpdated() throws IOException {\n+        testStateRead(\n+            new SearchHits(new SearchHit[]{ SearchHit.createFromMap(Map.of(\"_index\", \".ml-state-dummy\")) }, null, 0.0f),\n+            \".ml-state-dummy\");\n+    }\n+\n     public void testStateReadGivenConsecutiveZeroBytes() throws IOException {\n         String zeroBytes = \"\\0\\0\\0\\0\\0\\0\";\n         ByteArrayInputStream stream = new ByteArrayInputStream(zeroBytes.getBytes(StandardCharsets.UTF_8));\n \n         stateProcessor.process(stream);\n \n-        verify(stateProcessor, never()).persist(any());\n-        Mockito.verifyNoMoreInteractions(resultsPersisterService);\n+        verify(stateProcessor, never()).persist(any(), any());\n     }\n \n     public void testStateReadGivenConsecutiveSpacesFollowedByZeroByte() throws IOException {\n-        String zeroBytes = \"        \\n\\0\";\n-        ByteArrayInputStream stream = new ByteArrayInputStream(zeroBytes.getBytes(StandardCharsets.UTF_8));\n+        String bytes = \"        \\n\\0\";\n+        ByteArrayInputStream stream = new ByteArrayInputStream(bytes.getBytes(StandardCharsets.UTF_8));\n \n-        stateProcessor.process(stream);\n+        Exception e = expectThrows(IllegalStateException.class, () -> stateProcessor.process(stream));", "originalCommit": "889df4f6fc65734da4f34d91b6f44c227f3b4bcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk4Njk2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51751#discussion_r373986961", "bodyText": "Good finding, done.\nPlease note that I'm now skipping leading blank lines just in case the actual request body is present after those blank lines.", "author": "przemekwitek", "createdAt": "2020-02-03T09:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU1NjE2MQ=="}], "type": "inlineReview"}, {"oid": "9095369cc4f29aec9ecfcf666a12e16889c27cd0", "url": "https://github.com/elastic/elasticsearch/commit/9095369cc4f29aec9ecfcf666a12e16889c27cd0", "message": "Apply review comment", "committedDate": "2020-02-03T09:05:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5NzE1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51751#discussion_r373997152", "bodyText": "Note that isBlank was first added in Java 11 so for the backport you'll need to do this differently.", "author": "droberts195", "createdAt": "2020-02-03T09:30:29Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/process/IndexingStateProcessor.java", "diffHunk": "@@ -117,12 +138,62 @@ void persist(BytesReference bytes) throws IOException {\n     }\n \n     private static int findNextZeroByte(BytesReference bytesRef, int searchFrom, int splitFrom) {\n-        for (int i = Math.max(searchFrom, splitFrom); i < bytesRef.length(); ++i) {\n-            if (bytesRef.get(i) == 0) {\n-                return i;\n+        return bytesRef.indexOf((byte)0, Math.max(searchFrom, splitFrom));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static String extractDocId(BytesReference bytesRef) throws IOException {\n+        String firstNonBlankLine = extractFirstNonBlankLine(bytesRef);\n+        if (firstNonBlankLine == null) {\n+            return null;\n+        }\n+        try (XContentParser parser =\n+                 JsonXContent.jsonXContent.createParser(\n+                     NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, firstNonBlankLine)) {\n+            Map<String, Object> map = parser.map();\n+            if ((map.get(\"index\") instanceof Map) == false) {\n+                throw new IllegalStateException(\"Could not extract \\\"index\\\" field out of [\" + firstNonBlankLine + \"]\");\n             }\n+            map = (Map<String, Object>)map.get(\"index\");\n+            if ((map.get(\"_id\") instanceof String) == false) {\n+                throw new IllegalStateException(\"Could not extract \\\"index._id\\\" field out of [\" + firstNonBlankLine + \"]\");\n+            }\n+            return (String)map.get(\"_id\");\n         }\n-        return -1;\n+    }\n+\n+    private static String extractFirstNonBlankLine(BytesReference bytesRef) {\n+        for (int searchFrom = 0; searchFrom < bytesRef.length();) {\n+            int newLineMarkerIndex = bytesRef.indexOf((byte) '\\n', searchFrom);\n+            int searchTo = newLineMarkerIndex != -1 ? newLineMarkerIndex : bytesRef.length();\n+            String line = bytesRef.slice(searchFrom, searchTo - searchFrom).utf8ToString();\n+            if (line.isBlank() == false) {", "originalCommit": "9095369cc4f29aec9ecfcf666a12e16889c27cd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAwNDQ0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51751#discussion_r377004443", "bodyText": "I've the isBlank call to searching directly for space characters (' ').\nTo your knowledge, is space (' ') the only blank character that can occur?", "author": "przemekwitek", "createdAt": "2020-02-10T11:22:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5NzE1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAzMjI3MA==", "url": "https://github.com/elastic/elasticsearch/pull/51751#discussion_r377032270", "bodyText": "Yes, I'm pretty sure space is the only blank character that could occur (except for \\n of course, but that's consumed by the line breaking).", "author": "droberts195", "createdAt": "2020-02-10T12:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5NzE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDAwMDI5OA==", "url": "https://github.com/elastic/elasticsearch/pull/51751#discussion_r374000298", "bodyText": "Please can you add a comment here explaining why we have to do this.  Today everyone in the team understands what an \"appropriate\" index is, but it won't be so obvious 2 years from now.\nKey points:\n\nSome types of state, for example data frame analytics state and categorizer state, are written multiple times with the same document ID\nOther types of state, for example anomaly detector state, are written with new document IDs each time\nThe code needs to work correctly when the state index is rolling over\nThe approach of having duplicate IDs in different state indices is tricky when we deliberately have no mappings on the state index, as we cannot sort and filter in a search\nThe state documents are large, so having dead documents with duplicate IDs is not ideal from a disk usage perspective either\n\nPossibly this could go in the top level class Javadoc comment and this method's comment could just say \"for what is meant by appropriate see the class documentation\".", "author": "droberts195", "createdAt": "2020-02-03T09:37:20Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/process/IndexingStateProcessor.java", "diffHunk": "@@ -98,11 +110,20 @@ private BytesReference splitAndPersist(BytesReference bytesRef, int searchFrom)\n         return bytesRef.slice(splitFrom, bytesRef.length() - splitFrom);\n     }\n \n-    void persist(BytesReference bytes) throws IOException {\n-        BulkRequest bulkRequest = new BulkRequest();\n-        bulkRequest.add(bytes, AnomalyDetectorsIndex.jobStateIndexWriteAlias(), XContentType.JSON);\n+    void findAppropriateIndexAndPersist(BytesReference bytes) throws IOException {", "originalCommit": "9095369cc4f29aec9ecfcf666a12e16889c27cd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAwNjI1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51751#discussion_r377006255", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-02-10T11:26:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDAwMDI5OA=="}], "type": "inlineReview"}, {"oid": "304f344a6056bae6c6680ec0c5c7f31ca4fd10b6", "url": "https://github.com/elastic/elasticsearch/commit/304f344a6056bae6c6680ec0c5c7f31ca4fd10b6", "message": "Update persistent state document in the index the document belongs to", "committedDate": "2020-02-10T10:15:03Z", "type": "commit"}, {"oid": "873af34ff6251d79e9c3375cbb7fc1e0e931d60d", "url": "https://github.com/elastic/elasticsearch/commit/873af34ff6251d79e9c3375cbb7fc1e0e931d60d", "message": "Apply review comment", "committedDate": "2020-02-10T10:15:04Z", "type": "commit"}, {"oid": "8a97833d65f90cfbf263f0e96bca1f15da66357e", "url": "https://github.com/elastic/elasticsearch/commit/8a97833d65f90cfbf263f0e96bca1f15da66357e", "message": "Apply review comments.", "committedDate": "2020-02-10T12:21:34Z", "type": "commit"}, {"oid": "8a97833d65f90cfbf263f0e96bca1f15da66357e", "url": "https://github.com/elastic/elasticsearch/commit/8a97833d65f90cfbf263f0e96bca1f15da66357e", "message": "Apply review comments.", "committedDate": "2020-02-10T12:21:34Z", "type": "forcePushed"}]}