{"pr_number": 53793, "pr_title": "Try to save memory on aggregations", "pr_createdAt": "2020-03-19T13:18:56Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53793", "timeline": [{"oid": "39d604cff634a2f92206f0c4a9be264a4a73e7aa", "url": "https://github.com/elastic/elasticsearch/commit/39d604cff634a2f92206f0c4a9be264a4a73e7aa", "message": "Try to save memory on aggregations\n\nThis delays deserializing the aggregation response try until *right*\nbefore we merge the objects.", "committedDate": "2020-03-19T12:25:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA1MDk0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395050941", "bodyText": "We're only using this for InternalAggregations, but it is a heck of a lot simpler to test if it is generic.", "author": "nik9000", "createdAt": "2020-03-19T14:06:49Z", "path": "server/src/main/java/org/elasticsearch/common/io/stream/DelayableWriteable.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.io.stream;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.bytes.BytesReference;\n+\n+import java.io.IOException;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A holder for {@link Writeable}s that can delays reading the underlying\n+ * {@linkplain Writeable} when it is read from a remote node.\n+ */\n+public abstract class DelayableWriteable<T extends Writeable> implements Supplier<T>, Writeable {", "originalCommit": "39d604cff634a2f92206f0c4a9be264a4a73e7aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8cddcab12893bf65530a33f4e59c89cc89bdbfdb", "url": "https://github.com/elastic/elasticsearch/commit/8cddcab12893bf65530a33f4e59c89cc89bdbfdb", "message": "Fix request cache", "committedDate": "2020-03-19T14:27:48Z", "type": "commit"}, {"oid": "04dba53ec8c645086e8d2de1cf0f139764931197", "url": "https://github.com/elastic/elasticsearch/commit/04dba53ec8c645086e8d2de1cf0f139764931197", "message": "Merge branch 'master' into agg_await_deserialization", "committedDate": "2020-03-19T14:28:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzIyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395307225", "bodyText": "should we nullify the rest of the array to make the reduced aggs eligible for gc ?", "author": "jimczi", "createdAt": "2020-03-19T20:41:03Z", "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -665,10 +671,11 @@ private synchronized void consumeInternal(QuerySearchResult querySearchResult) {\n             if (querySearchResult.isNull() == false) {\n                 if (index == bufferSize) {\n                     if (hasAggs) {\n-                        ReduceContext reduceContext = aggReduceContextBuilder.forPartialReduction();\n-                        InternalAggregations reducedAggs = InternalAggregations.topLevelReduce(Arrays.asList(aggsBuffer), reduceContext);\n+                        InternalAggregations reducedAggs = InternalAggregations.topLevelReduce(\n+                                Arrays.stream(aggsBuffer).map(Supplier::get).collect(toList()),\n+                                aggReduceContextBuilder.forPartialReduction());\n                         Arrays.fill(aggsBuffer, null);\n-                        aggsBuffer[0] = reducedAggs;\n+                        aggsBuffer[0] = () -> reducedAggs;", "originalCommit": "04dba53ec8c645086e8d2de1cf0f139764931197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxODIwNw==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395318207", "bodyText": "++", "author": "nik9000", "createdAt": "2020-03-19T21:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY1ODY5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395658695", "bodyText": "Actually the line right above does that.", "author": "nik9000", "createdAt": "2020-03-20T14:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3Mjc3MA==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395672770", "bodyText": "Right but we keep the serialized + deserialized form until after the partial reduce. We can try to release the serialized form early with:\n List<InternalAggregations> toReduce = Arrays.stream(aggsBuffer).map(Supplier::get).collect(toList());\n Arrays.fill(aggsBuffer, null);\n InternalAggregaions reducedAggs = InternalAggregations.topLevelReduce(toReduce, aggReduceContextBuilder.forPartialReduction());\n aggsBuffer[0] = () -> reducedAggs;\n\nOr we can nullify the serialized form when the supplier is called like discussed below.", "author": "jimczi", "createdAt": "2020-03-20T14:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MjcyMw==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395762723", "bodyText": "Right! I noticed that right after I sent this. I'm playing with nulling the cell in the array as soon as I call get. That feels a little safer than nulling the bytes.", "author": "nik9000", "createdAt": "2020-03-20T16:45:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzIyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzk5NA==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395307994", "bodyText": "Should we nullify the bytes ref before returning the deserialized aggs ? We could also protect against multiple calls by keeping the deserialized aggs internally on the first call ?", "author": "jimczi", "createdAt": "2020-03-19T20:42:40Z", "path": "server/src/main/java/org/elasticsearch/common/io/stream/DelayableWriteable.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.io.stream;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.bytes.BytesReference;\n+\n+import java.io.IOException;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A holder for {@link Writeable}s that can delays reading the underlying\n+ * {@linkplain Writeable} when it is read from a remote node.\n+ */\n+public abstract class DelayableWriteable<T extends Writeable> implements Supplier<T>, Writeable {\n+    /**\n+     * Build a {@linkplain DelayableWriteable} that wraps an existing object\n+     * but is serialized so that deserializing it can be delayed.\n+     */\n+    public static <T extends Writeable> DelayableWriteable<T> referencing(T reference) {\n+        return new Referencing<>(reference);\n+    }\n+    /**\n+     * Build a {@linkplain DelayableWriteable} that copies a buffer from\n+     * the provided {@linkplain StreamInput} and deserializes the buffer\n+     * when {@link Supplier#get()} is called.\n+     */\n+    public static <T extends Writeable> DelayableWriteable<T> delayed(Writeable.Reader<T> reader, StreamInput in) throws IOException {\n+        return new Delayed<>(reader, in);\n+    }\n+\n+    private DelayableWriteable() {}\n+\n+    public abstract boolean isDelayed();\n+\n+    private static class Referencing<T extends Writeable> extends DelayableWriteable<T> {\n+        private T reference;\n+\n+        Referencing(T reference) {\n+            this.reference = reference;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            try (BytesStreamOutput buffer = new BytesStreamOutput()) {\n+                reference.writeTo(buffer);\n+                out.writeBytesReference(buffer.bytes());\n+            }\n+        }\n+\n+        @Override\n+        public T get() {\n+            return reference;\n+        }\n+\n+        @Override\n+        public boolean isDelayed() {\n+            return false;\n+        }\n+    }\n+\n+    private static class Delayed<T extends Writeable> extends DelayableWriteable<T> {\n+        private final Writeable.Reader<T> reader;\n+        private final Version remoteVersion;\n+        private final BytesReference serialized;\n+        private final NamedWriteableRegistry registry;\n+\n+        Delayed(Writeable.Reader<T> reader, StreamInput in) throws IOException {\n+            this.reader = reader;\n+            remoteVersion = in.getVersion();\n+            serialized = in.readBytesReference();\n+            registry = in.namedWriteableRegistry();\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            if (out.getVersion() == remoteVersion) {\n+                /*\n+                 * If the version *does* line up we can just copy the bytes\n+                 * which is good because this is how shard request caching\n+                 * works.\n+                 */\n+                out.writeBytesReference(serialized);\n+            } else {\n+                /*\n+                 * If the version doesn't line up then we have to deserialize\n+                 * into the Writeable and re-serialize it against the new\n+                 * output stream so it can apply any backwards compatibility\n+                 * differences in the wire protocol. This ain't efficient but\n+                 * it should be quite rare.\n+                 */\n+                referencing(get()).writeTo(out);\n+            }\n+        }\n+\n+        @Override\n+        public T get() {\n+            try {\n+                try (StreamInput in = registry == null ?\n+                        serialized.streamInput() : new NamedWriteableAwareStreamInput(serialized.streamInput(), registry)) {\n+                    in.setVersion(remoteVersion);\n+                    return reader.read(in);", "originalCommit": "04dba53ec8c645086e8d2de1cf0f139764931197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxMjEyNA==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395312124", "bodyText": "I'm worried about race conditions with that. The way it is it is fairly simple the look at and say \"there are no race conditions.\" I think nulifying the other references would be good enough from a GC perspective. Do you?", "author": "nik9000", "createdAt": "2020-03-19T20:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxNTUzMA==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395315530", "bodyText": "yep nullifying the reference should be enough but it would be better if we can nullify after each deserialization. Otherwise you'd need to keep the deserialized aggs and their bytes representation during the entire partial reduce which defeats the purpose of saving memories here ?", "author": "jimczi", "createdAt": "2020-03-19T20:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwOTQwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395309409", "bodyText": "we can maybe get the aggs once if the remote node is in a version before v8 (instead of calling get here and below to get the pipeline aggs) ?", "author": "jimczi", "createdAt": "2020-03-19T20:45:30Z", "path": "server/src/main/java/org/elasticsearch/search/query/QuerySearchResult.java", "diffHunk": "@@ -366,7 +371,11 @@ public void writeToNoId(StreamOutput out) throws IOException {\n             out.writeBoolean(false);\n         } else {\n             out.writeBoolean(true);\n-            aggregations.writeTo(out);\n+            if (out.getVersion().before(Version.V_8_0_0)) {\n+                aggregations.get().writeTo(out);", "originalCommit": "04dba53ec8c645086e8d2de1cf0f139764931197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0NDQwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r396444405", "bodyText": "@nik9000 ? should we avoid the double deserialization if we need the pipeline aggs below ?", "author": "jimczi", "createdAt": "2020-03-23T13:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwOTQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1MDAyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r396450025", "bodyText": "Darn it. I twisted the other side around but missed this comment. Of course!", "author": "nik9000", "createdAt": "2020-03-23T13:29:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwOTQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1MTUzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r396451539", "bodyText": "Mostly these are going to be the \"referencing\" ones anyway. But I'll turn it around.", "author": "nik9000", "createdAt": "2020-03-23T13:31:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwOTQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxMDQ1OA==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395310458", "bodyText": "Can you add a comment here to explain why we use a delayable writable ?", "author": "jimczi", "createdAt": "2020-03-19T20:47:39Z", "path": "server/src/main/java/org/elasticsearch/search/query/QuerySearchResult.java", "diffHunk": "@@ -54,7 +55,7 @@\n     private TotalHits totalHits;\n     private float maxScore = Float.NaN;\n     private DocValueFormat[] sortValueFormats;\n-    private InternalAggregations aggregations;", "originalCommit": "04dba53ec8c645086e8d2de1cf0f139764931197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxMjMxNg==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395312316", "bodyText": "++", "author": "nik9000", "createdAt": "2020-03-19T20:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxMDQ1OA=="}], "type": "inlineReview"}, {"oid": "6921c8ca514d26fb94b97f1e02bd69c4264f30c1", "url": "https://github.com/elastic/elasticsearch/commit/6921c8ca514d26fb94b97f1e02bd69c4264f30c1", "message": "Explain", "committedDate": "2020-03-19T22:18:44Z", "type": "commit"}, {"oid": "76b077db6cf90e12147eefd38110ad78616aa59a", "url": "https://github.com/elastic/elasticsearch/commit/76b077db6cf90e12147eefd38110ad78616aa59a", "message": "Rework read", "committedDate": "2020-03-19T22:54:43Z", "type": "commit"}, {"oid": "eb37343d15675e1941a240befc21a85d356694ea", "url": "https://github.com/elastic/elasticsearch/commit/eb37343d15675e1941a240befc21a85d356694ea", "message": "clear asap", "committedDate": "2020-03-20T20:02:40Z", "type": "commit"}, {"oid": "80e31ad697584c9126a0e55b061fb9a5d5b91b9f", "url": "https://github.com/elastic/elasticsearch/commit/80e31ad697584c9126a0e55b061fb9a5d5b91b9f", "message": "Checkstyle", "committedDate": "2020-03-20T20:10:10Z", "type": "commit"}, {"oid": "c6162ff446abe15844130d23e7f74f8e3f241018", "url": "https://github.com/elastic/elasticsearch/commit/c6162ff446abe15844130d23e7f74f8e3f241018", "message": "Twist", "committedDate": "2020-03-23T13:32:50Z", "type": "commit"}]}