{"pr_number": 51894, "pr_title": "SQL: Fix ORDER BY on aggregates and GROUPed BY fields", "pr_createdAt": "2020-02-04T22:29:47Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51894", "timeline": [{"oid": "b49a23ce56483f7199be7cb2641910915036c741", "url": "https://github.com/elastic/elasticsearch/commit/b49a23ce56483f7199be7cb2641910915036c741", "message": "SQL: Fix ORDER BY on aggregates and GROUPed BY fields\n\nPreviously, in the in-memory sorting module\n`LocalAggregationSorterListener` only the aggregate functions where used\n(grabbed by the `sortingColumns`). As a consequence, if the ORDER BY\nwas also using columns of the GROUP BY clause, (especially in the case\nof higher priority - before the aggregate functions) wrong results were\nproduced. E.g.:\n```\nSELECT gender, MAX(salary) AS max FROM test_emp\nGROUP BY gender\nORDER BY gender, max\n```\n\nAdd all columns of the ORDER BY to the `sortingColumns` so that the\n`LocalAggregationSorterListener` can use the correct comparators in\nthe underlying PriorityQueue used to implement the in-memory sorting.\n\nFixes: #50355", "committedDate": "2020-02-04T22:25:12Z", "type": "commit"}, {"oid": "a68c6ded5058e7a77824ab0cabb35155db027a8b", "url": "https://github.com/elastic/elasticsearch/commit/a68c6ded5058e7a77824ab0cabb35155db027a8b", "message": "Merge remote-tracking branch 'upstream/master' into fix-50355", "committedDate": "2020-02-05T00:13:12Z", "type": "commit"}, {"oid": "90cb862906c76bb26f78862da76f6fe0471bc853", "url": "https://github.com/elastic/elasticsearch/commit/90cb862906c76bb26f78862da76f6fe0471bc853", "message": "make field private", "committedDate": "2020-02-05T12:00:51Z", "type": "commit"}, {"oid": "ab0c62787068fbf465e051b9e425447c24bda026", "url": "https://github.com/elastic/elasticsearch/commit/ab0c62787068fbf465e051b9e425447c24bda026", "message": "Merge remote-tracking branch 'upstream/master' into fix-50355", "committedDate": "2020-02-05T12:00:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxMjE1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51894#discussion_r375212152", "bodyText": "Why not breaking early, if there's the first AggregateSort found?", "author": "astefan", "createdAt": "2020-02-05T11:52:59Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/container/QueryContainer.java", "diffHunk": "@@ -134,45 +133,39 @@ public QueryContainer(Query query,\n             return emptyList();\n         }\n \n-        List<Tuple<Integer, Comparator>> sortingColumns = new ArrayList<>(sort.size());\n-\n-        boolean aggSort = false;\n         for (Sort s : sort) {\n-            Tuple<Integer, Comparator> tuple = new Tuple<>(Integer.valueOf(-1), null);\n-            \n             if (s instanceof AggregateSort) {\n-                AggregateSort as = (AggregateSort) s;\n-                // find the relevant column of each aggregate function\n-                AggregateFunction af = as.agg();\n-\n-                aggSort = true;\n-                int atIndex = -1;\n-                String id = Expressions.id(af);\n-\n-                for (int i = 0; i < fields.size(); i++) {\n-                    Tuple<FieldExtraction, String> field = fields.get(i);\n-                    if (field.v2().equals(id)) {\n-                        atIndex = i;\n-                        break;\n-                    }\n-                }\n-                if (atIndex == -1) {\n-                    throw new SqlIllegalArgumentException(\"Cannot find backing column for ordering aggregation [{}]\", s);\n-                }\n-                // assemble a comparator for it\n-                Comparator comp = s.direction() == Sort.Direction.ASC ? Comparator.naturalOrder() : Comparator.reverseOrder();\n-                comp = s.missing() == Sort.Missing.FIRST ? Comparator.nullsFirst(comp) : Comparator.nullsLast(comp);\n-\n-                tuple = new Tuple<>(Integer.valueOf(atIndex), comp);\n+                customSort = Boolean.TRUE;", "originalCommit": "a68c6ded5058e7a77824ab0cabb35155db027a8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxODcwMA==", "url": "https://github.com/elastic/elasticsearch/pull/51894#discussion_r375218700", "bodyText": "We cannot break after the first AggregateSort. Maybe we could break after the last AggregateSort.\nIf we have:\nSELECT f1, f2, f3, MAX(f4) as max, MIN(f5) as min\nFROM test\nGROUP BY f1, f2, f3\nORDER BY f1, max, f2, min, f3\n\nwe cannot break after max, we could break after min.\nI'd rather leave the fix as is and introduce this optimisation in a separate PR where it's properly tested that it works.\n(Needs some carefully chosen data set to test this ordering case)", "author": "matriv", "createdAt": "2020-02-05T12:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxMjE1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIyMDA3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51894#discussion_r375220075", "bodyText": "I don't understand. That's a simple loop that, when finds an AggregateSort, will set customSort to TRUE. It doesn't really matter what's after in the list of sorts because it doesn't change the value of customSort.\nAlso, I meant breaking from inside the loop not from the method...", "author": "astefan", "createdAt": "2020-02-05T12:12:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxMjE1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIyMDgxMA==", "url": "https://github.com/elastic/elasticsearch/pull/51894#discussion_r375220810", "bodyText": "Sorry, misunderstood you there, sure we should break once the 1st is found.", "author": "matriv", "createdAt": "2020-02-05T12:13:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxMjE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxMjYwOA==", "url": "https://github.com/elastic/elasticsearch/pull/51894#discussion_r375212608", "bodyText": "atIndex == -1", "author": "astefan", "createdAt": "2020-02-05T11:54:05Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/container/QueryContainer.java", "diffHunk": "@@ -134,45 +133,39 @@ public QueryContainer(Query query,\n             return emptyList();\n         }\n \n-        List<Tuple<Integer, Comparator>> sortingColumns = new ArrayList<>(sort.size());\n-\n-        boolean aggSort = false;\n         for (Sort s : sort) {\n-            Tuple<Integer, Comparator> tuple = new Tuple<>(Integer.valueOf(-1), null);\n-            \n             if (s instanceof AggregateSort) {\n-                AggregateSort as = (AggregateSort) s;\n-                // find the relevant column of each aggregate function\n-                AggregateFunction af = as.agg();\n-\n-                aggSort = true;\n-                int atIndex = -1;\n-                String id = Expressions.id(af);\n-\n-                for (int i = 0; i < fields.size(); i++) {\n-                    Tuple<FieldExtraction, String> field = fields.get(i);\n-                    if (field.v2().equals(id)) {\n-                        atIndex = i;\n-                        break;\n-                    }\n-                }\n-                if (atIndex == -1) {\n-                    throw new SqlIllegalArgumentException(\"Cannot find backing column for ordering aggregation [{}]\", s);\n-                }\n-                // assemble a comparator for it\n-                Comparator comp = s.direction() == Sort.Direction.ASC ? Comparator.naturalOrder() : Comparator.reverseOrder();\n-                comp = s.missing() == Sort.Missing.FIRST ? Comparator.nullsFirst(comp) : Comparator.nullsLast(comp);\n-\n-                tuple = new Tuple<>(Integer.valueOf(atIndex), comp);\n+                customSort = Boolean.TRUE;\n             }\n-            sortingColumns.add(tuple);\n         }\n-        \n+\n+        // If no custom sort is used break early\n         if (customSort == null) {\n-            customSort = Boolean.valueOf(aggSort);\n+            customSort = Boolean.FALSE;\n+            return emptyList();\n         }\n \n-        return aggSort ? sortingColumns : emptyList();\n+        List<Tuple<Integer, Comparator>> sortingColumns = new ArrayList<>(sort.size());\n+        for (Sort s: sort) {\n+            int atIndex = -1;\n+            for (int i = 0; i < fields.size(); i++) {\n+                Tuple<FieldExtraction, String> field = fields.get(i);\n+                if (field.v2().equals(s.id())) {\n+                    atIndex = i;\n+                    break;\n+                }\n+            }\n+            if (atIndex==-1) {", "originalCommit": "a68c6ded5058e7a77824ab0cabb35155db027a8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxNjY5NA==", "url": "https://github.com/elastic/elasticsearch/pull/51894#discussion_r375216694", "bodyText": "Somehow I broke the formatting :(", "author": "matriv", "createdAt": "2020-02-05T12:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxMjYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxMjc1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51894#discussion_r375212757", "bodyText": "Comparator comp = s.direction() == Sort.Direction.ASC ? Comparator.naturalOrder() : Comparator.reverseOrder();", "author": "astefan", "createdAt": "2020-02-05T11:54:27Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/container/QueryContainer.java", "diffHunk": "@@ -134,45 +133,39 @@ public QueryContainer(Query query,\n             return emptyList();\n         }\n \n-        List<Tuple<Integer, Comparator>> sortingColumns = new ArrayList<>(sort.size());\n-\n-        boolean aggSort = false;\n         for (Sort s : sort) {\n-            Tuple<Integer, Comparator> tuple = new Tuple<>(Integer.valueOf(-1), null);\n-            \n             if (s instanceof AggregateSort) {\n-                AggregateSort as = (AggregateSort) s;\n-                // find the relevant column of each aggregate function\n-                AggregateFunction af = as.agg();\n-\n-                aggSort = true;\n-                int atIndex = -1;\n-                String id = Expressions.id(af);\n-\n-                for (int i = 0; i < fields.size(); i++) {\n-                    Tuple<FieldExtraction, String> field = fields.get(i);\n-                    if (field.v2().equals(id)) {\n-                        atIndex = i;\n-                        break;\n-                    }\n-                }\n-                if (atIndex == -1) {\n-                    throw new SqlIllegalArgumentException(\"Cannot find backing column for ordering aggregation [{}]\", s);\n-                }\n-                // assemble a comparator for it\n-                Comparator comp = s.direction() == Sort.Direction.ASC ? Comparator.naturalOrder() : Comparator.reverseOrder();\n-                comp = s.missing() == Sort.Missing.FIRST ? Comparator.nullsFirst(comp) : Comparator.nullsLast(comp);\n-\n-                tuple = new Tuple<>(Integer.valueOf(atIndex), comp);\n+                customSort = Boolean.TRUE;\n             }\n-            sortingColumns.add(tuple);\n         }\n-        \n+\n+        // If no custom sort is used break early\n         if (customSort == null) {\n-            customSort = Boolean.valueOf(aggSort);\n+            customSort = Boolean.FALSE;\n+            return emptyList();\n         }\n \n-        return aggSort ? sortingColumns : emptyList();\n+        List<Tuple<Integer, Comparator>> sortingColumns = new ArrayList<>(sort.size());\n+        for (Sort s: sort) {\n+            int atIndex = -1;\n+            for (int i = 0; i < fields.size(); i++) {\n+                Tuple<FieldExtraction, String> field = fields.get(i);\n+                if (field.v2().equals(s.id())) {\n+                    atIndex = i;\n+                    break;\n+                }\n+            }\n+            if (atIndex==-1) {\n+                throw new SqlIllegalArgumentException(\"Cannot find backing column for ordering aggregation [{}]\", s);\n+            }\n+            // assemble a comparator for it\n+            Comparator comp = s.direction()==Sort.Direction.ASC ? Comparator.naturalOrder():Comparator.reverseOrder();", "originalCommit": "a68c6ded5058e7a77824ab0cabb35155db027a8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxMjg1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51894#discussion_r375212852", "bodyText": "comp = s.missing() == Sort.Missing.FIRST ? Comparator.nullsFirst(comp) : Comparator.nullsLast(comp);", "author": "astefan", "createdAt": "2020-02-05T11:54:41Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/container/QueryContainer.java", "diffHunk": "@@ -134,45 +133,39 @@ public QueryContainer(Query query,\n             return emptyList();\n         }\n \n-        List<Tuple<Integer, Comparator>> sortingColumns = new ArrayList<>(sort.size());\n-\n-        boolean aggSort = false;\n         for (Sort s : sort) {\n-            Tuple<Integer, Comparator> tuple = new Tuple<>(Integer.valueOf(-1), null);\n-            \n             if (s instanceof AggregateSort) {\n-                AggregateSort as = (AggregateSort) s;\n-                // find the relevant column of each aggregate function\n-                AggregateFunction af = as.agg();\n-\n-                aggSort = true;\n-                int atIndex = -1;\n-                String id = Expressions.id(af);\n-\n-                for (int i = 0; i < fields.size(); i++) {\n-                    Tuple<FieldExtraction, String> field = fields.get(i);\n-                    if (field.v2().equals(id)) {\n-                        atIndex = i;\n-                        break;\n-                    }\n-                }\n-                if (atIndex == -1) {\n-                    throw new SqlIllegalArgumentException(\"Cannot find backing column for ordering aggregation [{}]\", s);\n-                }\n-                // assemble a comparator for it\n-                Comparator comp = s.direction() == Sort.Direction.ASC ? Comparator.naturalOrder() : Comparator.reverseOrder();\n-                comp = s.missing() == Sort.Missing.FIRST ? Comparator.nullsFirst(comp) : Comparator.nullsLast(comp);\n-\n-                tuple = new Tuple<>(Integer.valueOf(atIndex), comp);\n+                customSort = Boolean.TRUE;\n             }\n-            sortingColumns.add(tuple);\n         }\n-        \n+\n+        // If no custom sort is used break early\n         if (customSort == null) {\n-            customSort = Boolean.valueOf(aggSort);\n+            customSort = Boolean.FALSE;\n+            return emptyList();\n         }\n \n-        return aggSort ? sortingColumns : emptyList();\n+        List<Tuple<Integer, Comparator>> sortingColumns = new ArrayList<>(sort.size());\n+        for (Sort s: sort) {\n+            int atIndex = -1;\n+            for (int i = 0; i < fields.size(); i++) {\n+                Tuple<FieldExtraction, String> field = fields.get(i);\n+                if (field.v2().equals(s.id())) {\n+                    atIndex = i;\n+                    break;\n+                }\n+            }\n+            if (atIndex==-1) {\n+                throw new SqlIllegalArgumentException(\"Cannot find backing column for ordering aggregation [{}]\", s);\n+            }\n+            // assemble a comparator for it\n+            Comparator comp = s.direction()==Sort.Direction.ASC ? Comparator.naturalOrder():Comparator.reverseOrder();\n+            comp = s.missing()==Sort.Missing.FIRST ? Comparator.nullsFirst(comp):Comparator.nullsLast(comp);", "originalCommit": "a68c6ded5058e7a77824ab0cabb35155db027a8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxNDk3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51894#discussion_r375214977", "bodyText": "Did you explore the idea of having the id as part of Sort, as I'm seeing a lot of repeated code? (skimming through this PR's changes, the id seems to be introduced in all classes inheriting Sort). I am probably missing something that prevents this approach to be used, would love to hear the reasons.", "author": "astefan", "createdAt": "2020-02-05T12:00:06Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/container/ScoreSort.java", "diffHunk": "@@ -8,13 +8,22 @@\n import java.util.Objects;\n \n public class ScoreSort extends Sort {\n-    public ScoreSort(Direction direction, Missing missing) {\n+\n+    final String id;", "originalCommit": "a68c6ded5058e7a77824ab0cabb35155db027a8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxOTUzNw==", "url": "https://github.com/elastic/elasticsearch/pull/51894#discussion_r375219537", "bodyText": "I decided not to, because 2 classes the AttributeSort and AggregateSort can extract the id from their attribute variables. On the other hand 3 classes need to store it, I just chose the 1st approach with forcing to implement the public String id() getter.", "author": "matriv", "createdAt": "2020-02-05T12:10:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxNDk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIyNDk1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51894#discussion_r375224956", "bodyText": "I would have done it differently. I feel like id and id() should belong to the same base class - Sort, with the help of an additional constructor (that receives the id as an argument). Sort would have also provided a default implementation for id() (to return the id) and the other classes would have overriden the default implementation of id() where appropriate. Also, these \"special\" cases classes would have called the aforementioned freshly added constructor in Sort.\nThe main bothering aspect for me is that there is a required id()  method in Sort, but the id itself (that could be related to this id() method) lives in the inheriting classes.\nYou can leave it as is, I just wanted to point out something that doesn't feel right to me.", "author": "astefan", "createdAt": "2020-02-05T12:23:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxNDk3Nw=="}], "type": "inlineReview"}, {"oid": "9d25c93fda2f51bf9b343e8ced01ab724a18c47d", "url": "https://github.com/elastic/elasticsearch/commit/9d25c93fda2f51bf9b343e8ced01ab724a18c47d", "message": "fix formatting", "committedDate": "2020-02-05T12:12:02Z", "type": "commit"}, {"oid": "aaf2bd3805852294ebfc8be12a613b4f44c82776", "url": "https://github.com/elastic/elasticsearch/commit/aaf2bd3805852294ebfc8be12a613b4f44c82776", "message": "break from loop once custom sort is recognized", "committedDate": "2020-02-05T12:14:47Z", "type": "commit"}, {"oid": "a1ec293d57854afa1cdf46cac39d3a78549e0b12", "url": "https://github.com/elastic/elasticsearch/commit/a1ec293d57854afa1cdf46cac39d3a78549e0b12", "message": "change approach - add more tests", "committedDate": "2020-02-11T18:07:02Z", "type": "commit"}, {"oid": "65a1ca34bee5b9f4ee16d6bf4ad08cf04897dcb0", "url": "https://github.com/elastic/elasticsearch/commit/65a1ca34bee5b9f4ee16d6bf4ad08cf04897dcb0", "message": "Merge remote-tracking branch 'upstream/master' into fix-50355", "committedDate": "2020-02-11T18:07:19Z", "type": "commit"}, {"oid": "46b9700ef80131a3cc88022991c6c9983d294ca9", "url": "https://github.com/elastic/elasticsearch/commit/46b9700ef80131a3cc88022991c6c9983d294ca9", "message": "revert changes to untouched files", "committedDate": "2020-02-11T18:10:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg3MDA0OA==", "url": "https://github.com/elastic/elasticsearch/pull/51894#discussion_r377870048", "bodyText": "Nit: or else -> else or otherwise", "author": "costin", "createdAt": "2020-02-11T20:07:38Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/execution/search/Querier.java", "diffHunk": "@@ -594,36 +594,51 @@ public final void onFailure(Exception ex) {\n             this.sortingColumns = sortingColumns;\n         }\n \n-        // compare row based on the received attribute sort\n-        // if a sort item is not in the list, it is assumed the sorting happened in ES\n-        // and the results are left as is (by using the row ordering), otherwise it is sorted based on the given criteria.\n-        //\n-        // Take for example ORDER BY a, x, b, y\n-        // a, b - are sorted in ES\n-        // x, y - need to be sorted client-side\n-        // sorting on x kicks in, only if the values for a are equal.\n-\n+        /**\n+         * Compare row based on the received attribute sort\n+         * <ul>\n+         *     <li>\n+         *         If a tuple in {@code sortingColumns} has a null comparator, it is assumed the sorting\n+         *         happened in ES and the results are left as is (by using the row ordering), otherwise it is\n+         *         sorted based on the given criteria.\n+         *     </li>\n+         *     <li>\n+         *         If no tuple exists in {@code sortingColumns} for an output column, it means this column\n+         *         is not included at all in the ORDER BY\n+         *     </li>\n+         *</ul>\n+         *\n+         * Take for example ORDER BY a, x, b, y\n+         * a, b - are sorted in ES\n+         * x, y - need to be sorted client-side\n+         * sorting on x kicks in only if the values for a are equal.\n+         * sorting on y kicks in only if the values for a, x and b are all equal\n+         *\n+         */\n         // thanks to @jpountz for the row ordering idea as a way to preserve ordering\n         @SuppressWarnings(\"unchecked\")\n         @Override\n         protected boolean lessThan(Tuple<List<?>, Integer> l, Tuple<List<?>, Integer> r) {\n             for (Tuple<Integer, Comparator> tuple : sortingColumns) {\n-                int i = tuple.v1().intValue();\n+                int columnIdx = tuple.v1().intValue();\n                 Comparator comparator = tuple.v2();\n \n-                Object vl = l.v1().get(i);\n-                Object vr = r.v1().get(i);\n+                // Get the values for left and right rows at the current column index\n+                Object vl = l.v1().get(columnIdx);\n+                Object vr = r.v1().get(columnIdx);\n                 if (comparator != null) {\n                     int result = comparator.compare(vl, vr);\n-                    // if things are equals, move to the next comparator\n+                    // if things are not equal: return the comparison result,\n+                    // or else: move to the next comparator to solve the tie.", "originalCommit": "46b9700ef80131a3cc88022991c6c9983d294ca9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "637a9f9591542e9bb23a1d443550b104e43bec41", "url": "https://github.com/elastic/elasticsearch/commit/637a9f9591542e9bb23a1d443550b104e43bec41", "message": "Address comment", "committedDate": "2020-02-11T20:13:56Z", "type": "commit"}]}