{"pr_number": 54610, "pr_title": "Implement transport circuit breaking in aggregator", "pr_createdAt": "2020-04-01T20:35:46Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/54610", "timeline": [{"oid": "749c957e84c8deeb19da88a87f97188521e6fb77", "url": "https://github.com/elastic/elasticsearch/commit/749c957e84c8deeb19da88a87f97188521e6fb77", "message": "Chnages", "committedDate": "2020-03-31T19:06:33Z", "type": "commit"}, {"oid": "1de985cde68028801235010a705805b586e2a79b", "url": "https://github.com/elastic/elasticsearch/commit/1de985cde68028801235010a705805b586e2a79b", "message": "WIP", "committedDate": "2020-03-31T22:55:31Z", "type": "commit"}, {"oid": "03cd11835bdb2ea33a3a9c96cf97f9594a93e334", "url": "https://github.com/elastic/elasticsearch/commit/03cd11835bdb2ea33a3a9c96cf97f9594a93e334", "message": "WIP", "committedDate": "2020-04-01T02:54:12Z", "type": "commit"}, {"oid": "e2d10b9927c6c2d0930dd322d5789e9039c00b5d", "url": "https://github.com/elastic/elasticsearch/commit/e2d10b9927c6c2d0930dd322d5789e9039c00b5d", "message": "WIP", "committedDate": "2020-04-01T15:51:31Z", "type": "commit"}, {"oid": "555d5a8eb0e25e059a8a60d50f6760dd4e502c45", "url": "https://github.com/elastic/elasticsearch/commit/555d5a8eb0e25e059a8a60d50f6760dd4e502c45", "message": "Chnages", "committedDate": "2020-04-01T18:46:39Z", "type": "commit"}, {"oid": "7dcc09c21908ab2d099e1cb6b9ea2cf04827740e", "url": "https://github.com/elastic/elasticsearch/commit/7dcc09c21908ab2d099e1cb6b9ea2cf04827740e", "message": "Changes", "committedDate": "2020-04-01T20:31:28Z", "type": "commit"}, {"oid": "e94d17af5be0a4a0b516a2382eaf834361bc6a65", "url": "https://github.com/elastic/elasticsearch/commit/e94d17af5be0a4a0b516a2382eaf834361bc6a65", "message": "Fix issue", "committedDate": "2020-04-01T22:13:58Z", "type": "commit"}, {"oid": "fcd0ce7897e01c316e1f980c3c0a830eb832e7de", "url": "https://github.com/elastic/elasticsearch/commit/fcd0ce7897e01c316e1f980c3c0a830eb832e7de", "message": "Fix", "committedDate": "2020-04-01T23:30:07Z", "type": "commit"}, {"oid": "10c44a4f8e044aaae5683b3f62368f58da7dcb28", "url": "https://github.com/elastic/elasticsearch/commit/10c44a4f8e044aaae5683b3f62368f58da7dcb28", "message": "Merge remote-tracking branch 'upstream/master' into circuit_breaking_inside_pipeline", "committedDate": "2020-04-01T23:30:34Z", "type": "commit"}, {"oid": "fe39a308f7163e2d4af96602ad4af3be4742c0e9", "url": "https://github.com/elastic/elasticsearch/commit/fe39a308f7163e2d4af96602ad4af3be4742c0e9", "message": "Merge remote-tracking branch 'upstream/master' into circuit_breaking_inside_pipeline", "committedDate": "2020-04-02T19:09:36Z", "type": "commit"}, {"oid": "901d63ed7dcf7b98bad8328b4102305831a4a149", "url": "https://github.com/elastic/elasticsearch/commit/901d63ed7dcf7b98bad8328b4102305831a4a149", "message": "Merge remote-tracking branch 'upstream/master' into circuit_breaking_inside_pipeline", "committedDate": "2020-04-02T22:19:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwODA4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402808087", "bodyText": "make this package-visible and add comment that this is only to be used for tests?", "author": "ywelsch", "createdAt": "2020-04-03T08:02:50Z", "path": "server/src/main/java/org/elasticsearch/transport/InboundAggregator.java", "diffHunk": "@@ -27,44 +29,68 @@\n \n import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n \n public class InboundAggregator implements Releasable {\n \n+    private final Supplier<CircuitBreaker> circuitBreaker;\n+    private final Predicate<String> requestCanTripBreaker;\n+\n     private ReleasableBytesReference firstContent;\n     private ArrayList<ReleasableBytesReference> contentAggregation;\n     private Header currentHeader;\n+    private Exception aggregationException;\n+    private boolean canTripBreaker = true;\n     private boolean isClosed = false;\n \n+    public InboundAggregator(Supplier<CircuitBreaker> circuitBreaker,\n+                             Function<String, RequestHandlerRegistry<TransportRequest>> registryFunction) {\n+        this(circuitBreaker, (Predicate<String>) actionName -> {\n+            final RequestHandlerRegistry<TransportRequest> reg = registryFunction.apply(actionName);\n+            if (reg == null) {\n+                throw new ActionNotFoundTransportException(actionName);\n+            } else {\n+                return reg.canTripCircuitBreaker();\n+            }\n+        });\n+\n+    }\n+\n+    public InboundAggregator(Supplier<CircuitBreaker> circuitBreaker, Predicate<String> requestCanTripBreaker) {", "originalCommit": "901d63ed7dcf7b98bad8328b4102305831a4a149", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxMTMzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402811339", "bodyText": "can we add assert firstContent != null before this line?", "author": "ywelsch", "createdAt": "2020-04-03T08:06:37Z", "path": "server/src/main/java/org/elasticsearch/transport/InboundAggregator.java", "diffHunk": "@@ -27,44 +29,68 @@\n \n import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n \n public class InboundAggregator implements Releasable {\n \n+    private final Supplier<CircuitBreaker> circuitBreaker;\n+    private final Predicate<String> requestCanTripBreaker;\n+\n     private ReleasableBytesReference firstContent;\n     private ArrayList<ReleasableBytesReference> contentAggregation;\n     private Header currentHeader;\n+    private Exception aggregationException;\n+    private boolean canTripBreaker = true;\n     private boolean isClosed = false;\n \n+    public InboundAggregator(Supplier<CircuitBreaker> circuitBreaker,\n+                             Function<String, RequestHandlerRegistry<TransportRequest>> registryFunction) {\n+        this(circuitBreaker, (Predicate<String>) actionName -> {\n+            final RequestHandlerRegistry<TransportRequest> reg = registryFunction.apply(actionName);\n+            if (reg == null) {\n+                throw new ActionNotFoundTransportException(actionName);\n+            } else {\n+                return reg.canTripCircuitBreaker();\n+            }\n+        });\n+\n+    }\n+\n+    public InboundAggregator(Supplier<CircuitBreaker> circuitBreaker, Predicate<String> requestCanTripBreaker) {\n+        this.circuitBreaker = circuitBreaker;\n+        this.requestCanTripBreaker = requestCanTripBreaker;\n+    }\n+\n     public void headerReceived(Header header) {\n         ensureOpen();\n         assert isAggregating() == false;\n         assert firstContent == null && contentAggregation == null;\n         currentHeader = header;\n+        if (currentHeader.isRequest() && currentHeader.needsToReadVariableHeader() == false) {\n+            initializeRequestState();\n+        }\n     }\n \n     public void aggregate(ReleasableBytesReference content) {\n         ensureOpen();\n         assert isAggregating();\n-        if (isFirstContent()) {\n-            firstContent = content.retain();\n-        } else {\n-            if (contentAggregation == null) {\n-                contentAggregation = new ArrayList<>(4);\n-                contentAggregation.add(firstContent);\n-                firstContent = null;\n+        if (isShortCircuited() == false) {\n+            if (isFirstContent()) {\n+                firstContent = content.retain();\n+            } else {\n+                if (contentAggregation == null) {\n+                    contentAggregation = new ArrayList<>(4);\n+                    contentAggregation.add(firstContent);", "originalCommit": "901d63ed7dcf7b98bad8328b4102305831a4a149", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxNjU2MA==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402816560", "bodyText": "I wonder if we should assert that this method is not called anymore after close has been called", "author": "ywelsch", "createdAt": "2020-04-03T08:12:29Z", "path": "server/src/main/java/org/elasticsearch/transport/InboundAggregator.java", "diffHunk": "@@ -108,23 +156,84 @@ public void close() {\n     }\n \n     private void closeCurrentAggregation() {\n+        releaseContent();\n+        resetCurrentAggregation();\n+    }\n+\n+    private void releaseContent() {\n         if (contentAggregation == null) {\n             Releasables.close(firstContent);\n         } else {\n             Releasables.close(contentAggregation);\n         }\n-        resetCurrentAggregation();\n     }\n \n     private void resetCurrentAggregation() {\n         firstContent = null;\n         contentAggregation = null;\n         currentHeader = null;\n+        aggregationException = null;\n+        canTripBreaker = true;\n     }\n \n     private void ensureOpen() {\n         if (isClosed) {\n             throw new IllegalStateException(\"Aggregator is already closed\");\n         }\n     }\n+\n+    private void initializeRequestState() {\n+        assert currentHeader.needsToReadVariableHeader() == false;\n+        assert currentHeader.isRequest();\n+        if (currentHeader.isHandshake()) {\n+            canTripBreaker = false;\n+            return;\n+        }\n+\n+        final String actionName = currentHeader.getActionName();\n+        try {\n+            canTripBreaker = requestCanTripBreaker.test(actionName);\n+        } catch (ActionNotFoundTransportException e) {\n+            shortCircuit(new ActionNotFoundTransportException(actionName));\n+        }\n+    }\n+\n+    private void checkBreaker(final Header header, final int contentLength, final BreakerControl breakerControl) {\n+        if (header.isRequest() == false) {\n+            return;\n+        }\n+        assert header.needsToReadVariableHeader() == false;\n+\n+        if (canTripBreaker) {\n+            try {\n+                circuitBreaker.get().addEstimateBytesAndMaybeBreak(contentLength, \"<transport_request>\");\n+                breakerControl.incrementReservedBytes(contentLength);\n+            } catch (CircuitBreakingException e) {\n+                shortCircuit(e);\n+            }\n+        } else {\n+            circuitBreaker.get().addWithoutBreaking(contentLength);\n+            breakerControl.incrementReservedBytes(contentLength);\n+        }\n+    }\n+\n+    private static class BreakerControl implements Releasable {\n+\n+        private final Supplier<CircuitBreaker> circuitBreaker;\n+        private final AtomicInteger bytesToRelease = new AtomicInteger(0);\n+\n+        private BreakerControl(Supplier<CircuitBreaker> circuitBreaker) {\n+            this.circuitBreaker = circuitBreaker;\n+        }\n+\n+        private void incrementReservedBytes(int delta) {\n+            bytesToRelease.getAndAdd(delta);", "originalCommit": "901d63ed7dcf7b98bad8328b4102305831a4a149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk3MjcwNg==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402972706", "bodyText": "Also, we should assert right now that this method is only called once.", "author": "ywelsch", "createdAt": "2020-04-03T12:34:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxNjU2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIwNzYwNg==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r403207606", "bodyText": "I made a change and renamed the method to set.", "author": "tbrooks8", "createdAt": "2020-04-03T18:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxNjU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgyMTc4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402821789", "bodyText": "i would love it if we could add more information here than just <transport_request>. We potentially have action name and more available here", "author": "ywelsch", "createdAt": "2020-04-03T08:18:37Z", "path": "server/src/main/java/org/elasticsearch/transport/InboundAggregator.java", "diffHunk": "@@ -108,23 +156,84 @@ public void close() {\n     }\n \n     private void closeCurrentAggregation() {\n+        releaseContent();\n+        resetCurrentAggregation();\n+    }\n+\n+    private void releaseContent() {\n         if (contentAggregation == null) {\n             Releasables.close(firstContent);\n         } else {\n             Releasables.close(contentAggregation);\n         }\n-        resetCurrentAggregation();\n     }\n \n     private void resetCurrentAggregation() {\n         firstContent = null;\n         contentAggregation = null;\n         currentHeader = null;\n+        aggregationException = null;\n+        canTripBreaker = true;\n     }\n \n     private void ensureOpen() {\n         if (isClosed) {\n             throw new IllegalStateException(\"Aggregator is already closed\");\n         }\n     }\n+\n+    private void initializeRequestState() {\n+        assert currentHeader.needsToReadVariableHeader() == false;\n+        assert currentHeader.isRequest();\n+        if (currentHeader.isHandshake()) {\n+            canTripBreaker = false;\n+            return;\n+        }\n+\n+        final String actionName = currentHeader.getActionName();\n+        try {\n+            canTripBreaker = requestCanTripBreaker.test(actionName);\n+        } catch (ActionNotFoundTransportException e) {\n+            shortCircuit(new ActionNotFoundTransportException(actionName));\n+        }\n+    }\n+\n+    private void checkBreaker(final Header header, final int contentLength, final BreakerControl breakerControl) {\n+        if (header.isRequest() == false) {\n+            return;\n+        }\n+        assert header.needsToReadVariableHeader() == false;\n+\n+        if (canTripBreaker) {\n+            try {\n+                circuitBreaker.get().addEstimateBytesAndMaybeBreak(contentLength, \"<transport_request>\");", "originalCommit": "901d63ed7dcf7b98bad8328b4102305831a4a149", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk4MzIzMg==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402983232", "bodyText": "why are you not storing the original exception here?", "author": "ywelsch", "createdAt": "2020-04-03T12:53:09Z", "path": "server/src/main/java/org/elasticsearch/transport/InboundAggregator.java", "diffHunk": "@@ -108,23 +156,84 @@ public void close() {\n     }\n \n     private void closeCurrentAggregation() {\n+        releaseContent();\n+        resetCurrentAggregation();\n+    }\n+\n+    private void releaseContent() {\n         if (contentAggregation == null) {\n             Releasables.close(firstContent);\n         } else {\n             Releasables.close(contentAggregation);\n         }\n-        resetCurrentAggregation();\n     }\n \n     private void resetCurrentAggregation() {\n         firstContent = null;\n         contentAggregation = null;\n         currentHeader = null;\n+        aggregationException = null;\n+        canTripBreaker = true;\n     }\n \n     private void ensureOpen() {\n         if (isClosed) {\n             throw new IllegalStateException(\"Aggregator is already closed\");\n         }\n     }\n+\n+    private void initializeRequestState() {\n+        assert currentHeader.needsToReadVariableHeader() == false;\n+        assert currentHeader.isRequest();\n+        if (currentHeader.isHandshake()) {\n+            canTripBreaker = false;\n+            return;\n+        }\n+\n+        final String actionName = currentHeader.getActionName();\n+        try {\n+            canTripBreaker = requestCanTripBreaker.test(actionName);\n+        } catch (ActionNotFoundTransportException e) {\n+            shortCircuit(new ActionNotFoundTransportException(actionName));", "originalCommit": "901d63ed7dcf7b98bad8328b4102305831a4a149", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk4NjYwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402986601", "bodyText": "you've moved this out of the try block. Some implementations of this can throw an exception though. I think we need to handle those.", "author": "ywelsch", "createdAt": "2020-04-03T12:58:41Z", "path": "server/src/main/java/org/elasticsearch/transport/InboundHandler.java", "diffHunk": "@@ -147,54 +144,59 @@ private void messageReceived(InboundMessage message, TcpChannel channel) throws\n         }\n     }\n \n-    private <T extends TransportRequest> void handleRequest(TcpChannel channel, Header header, StreamInput stream, int messageLengthBytes) {\n+    private <T extends TransportRequest> void handleRequest(TcpChannel channel, Header header, InboundMessage message) throws IOException {\n         final String action = header.getActionName();\n         final long requestId = header.getRequestId();\n         final Version version = header.getVersion();\n-        TransportChannel transportChannel = null;\n-        try {\n-            messageListener.onRequestReceived(requestId, action);\n-            if (header.isHandshake()) {\n-                handshaker.handleHandshake(version, channel, requestId, stream);\n-            } else {\n-                final RequestHandlerRegistry<T> reg = getRequestHandler(action);\n-                if (reg == null) {\n-                    throw new ActionNotFoundTransportException(action);\n-                }\n-                CircuitBreaker breaker = circuitBreakerService.getBreaker(CircuitBreaker.IN_FLIGHT_REQUESTS);\n-                if (reg.canTripCircuitBreaker()) {\n-                    breaker.addEstimateBytesAndMaybeBreak(messageLengthBytes, \"<transport_request>\");\n+        messageListener.onRequestReceived(requestId, action);", "originalCommit": "901d63ed7dcf7b98bad8328b4102305831a4a149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxODcxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r403218715", "bodyText": "My answer here is related to:\nIf a request is received before a node is accepting requests, an\nexception is logged and the channel is closed. Currently we respond with\nan exception. But this is dangerous as we cannot negotiate a version.\n\nand #54610 (comment). There is only one usage of this listener and it happens at a place where it is not safe to response with the exception.\nWe can theoretically respond with an exception after the version handshake message. So I can call the listeners in different places if you would like.", "author": "tbrooks8", "createdAt": "2020-04-03T18:21:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk4NjYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk4NzgwMA==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402987800", "bodyText": "should we catch Exception here? We probably never want to bubble anything up here", "author": "ywelsch", "createdAt": "2020-04-03T13:00:46Z", "path": "server/src/main/java/org/elasticsearch/transport/InboundHandler.java", "diffHunk": "@@ -147,54 +144,59 @@ private void messageReceived(InboundMessage message, TcpChannel channel) throws\n         }\n     }\n \n-    private <T extends TransportRequest> void handleRequest(TcpChannel channel, Header header, StreamInput stream, int messageLengthBytes) {\n+    private <T extends TransportRequest> void handleRequest(TcpChannel channel, Header header, InboundMessage message) throws IOException {\n         final String action = header.getActionName();\n         final long requestId = header.getRequestId();\n         final Version version = header.getVersion();\n-        TransportChannel transportChannel = null;\n-        try {\n-            messageListener.onRequestReceived(requestId, action);\n-            if (header.isHandshake()) {\n-                handshaker.handleHandshake(version, channel, requestId, stream);\n-            } else {\n-                final RequestHandlerRegistry<T> reg = getRequestHandler(action);\n-                if (reg == null) {\n-                    throw new ActionNotFoundTransportException(action);\n-                }\n-                CircuitBreaker breaker = circuitBreakerService.getBreaker(CircuitBreaker.IN_FLIGHT_REQUESTS);\n-                if (reg.canTripCircuitBreaker()) {\n-                    breaker.addEstimateBytesAndMaybeBreak(messageLengthBytes, \"<transport_request>\");\n+        messageListener.onRequestReceived(requestId, action);\n+        if (message.isShortCircuit()) {\n+            final TransportChannel transportChannel = new TcpTransportChannel(outboundHandler, channel, action, requestId, version,\n+                header.isCompressed(), message.takeBreakerReleaseControl());\n+            sendErrorResponse(action, transportChannel, message.getException());\n+        } else {\n+            final StreamInput stream = namedWriteableStream(message.openOrGetStreamInput());\n+            assertRemoteVersion(stream, header.getVersion());\n+            TransportChannel transportChannel = null;\n+            try {\n+                if (header.isHandshake()) {\n+                    // TODO: Modify the handshaker to use the TcpTransportChannl. This should be\n+                    //  straightforward now that handshakes contribute to circuit breaking.\n+                    handshaker.handleHandshake(version, channel, requestId, stream);\n                 } else {\n-                    breaker.addWithoutBreaking(messageLengthBytes);\n+                    transportChannel = new TcpTransportChannel(outboundHandler, channel, action, requestId, version, header.isCompressed(),\n+                        message.takeBreakerReleaseControl());\n+                    final RequestHandlerRegistry<T> reg = getRequestHandler(action);\n+                    assert reg != null;\n+                    final T request = reg.newRequest(stream);\n+                    request.remoteAddress(new TransportAddress(channel.getRemoteAddress()));\n+                    // in case we throw an exception, i.e. when the limit is hit, we don't want to verify\n+                    final int nextByte = stream.read();\n+                    // calling read() is useful to make sure the message is fully read, even if there some kind of EOS marker\n+                    if (nextByte != -1) {\n+                        throw new IllegalStateException(\"Message not fully read (request) for requestId [\" + requestId + \"], action [\"\n+                            + action + \"], available [\" + stream.available() + \"]; resetting\");\n+                    }\n+                    threadPool.executor(reg.getExecutor()).execute(new RequestHandler<>(reg, request, transportChannel));\n                 }\n-                transportChannel = new TcpTransportChannel(outboundHandler, channel, action, requestId, version,\n-                    circuitBreakerService, messageLengthBytes, header.isCompressed());\n-                final T request = reg.newRequest(stream);\n-                request.remoteAddress(new TransportAddress(channel.getRemoteAddress()));\n-                // in case we throw an exception, i.e. when the limit is hit, we don't want to verify\n-                final int nextByte = stream.read();\n-                // calling read() is useful to make sure the message is fully read, even if there some kind of EOS marker\n-                if (nextByte != -1) {\n-                    throw new IllegalStateException(\"Message not fully read (request) for requestId [\" + requestId + \"], action [\" + action\n-                        + \"], available [\" + stream.available() + \"]; resetting\");\n+            } catch (Exception e) {\n+                if (transportChannel == null) {\n+                    transportChannel = new TcpTransportChannel(outboundHandler, channel, action, requestId, version, header.isCompressed(),\n+                        message.takeBreakerReleaseControl());\n                 }\n-                threadPool.executor(reg.getExecutor()).execute(new RequestHandler<>(reg, request, transportChannel));\n-            }\n-        } catch (Exception e) {\n-            // the circuit breaker tripped\n-            if (transportChannel == null) {\n-                transportChannel = new TcpTransportChannel(outboundHandler, channel, action, requestId, version,\n-                    circuitBreakerService, 0, header.isCompressed());\n-            }\n-            try {\n-                transportChannel.sendResponse(e);\n-            } catch (IOException inner) {\n-                inner.addSuppressed(e);\n-                logger.warn(() -> new ParameterizedMessage(\"Failed to send error message back to client for action [{}]\", action), inner);\n+                sendErrorResponse(action, transportChannel, e);\n             }\n         }\n     }\n \n+    private static void sendErrorResponse(String actionName, TransportChannel transportChannel, Exception e) {\n+        try {\n+            transportChannel.sendResponse(e);\n+        } catch (IOException inner) {", "originalCommit": "901d63ed7dcf7b98bad8328b4102305831a4a149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNDk3MA==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r403214970", "bodyText": "I did not make this change. I think even the practice of catching IOException here is bad and will need to be addressed in a follow up. We DO want exceptions like this to be bubbled up.\nIf we cannot send a response we need to kill the channel. Bubbled up exceptions will kill channels.\nEssentially, quite a bit of this exception handling in InboundHandler I think has issues but is beyond the scope of my current PR.\n\n\nUnless we can successfully send a handshake response, we should not catch and handle errors during version handshakes. Doing that leads to things like this (#54337). Errors during handshakes should be logged at a high level and kill the channel.\n\n\nUnknown network errors that prevent a response like the one you are referencing here should not be caught and handled. They should be bubbled up, logged, and the channel killed to send some level of notification to the other node.\n\n\nThese issues are beyond the scope of my PR. But I intend to address them in a follow-up.", "author": "tbrooks8", "createdAt": "2020-04-03T18:17:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk4NzgwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1MjQ1NA==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r403252454", "bodyText": "I actually did make this change, since it looks like we were catching Exception before when this happened at the application layer. But were only catching IOException for things before the application layer. But I do think this still needs to be ironed out to ensure that a failure to send a response, does not leave us hanging.", "author": "tbrooks8", "createdAt": "2020-04-03T19:06:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk4NzgwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2NDczNQ==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r403264735", "bodyText": "I did a little more clean-up around here. I still think we need a follow-up dedicated to exception handling. But I tried to maintain consistent behavior while moving the correct direction.", "author": "tbrooks8", "createdAt": "2020-04-03T19:29:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk4NzgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk5MDI1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402990251", "bodyText": "I think we should protect against double-closing here, given how important it is to this correctly.", "author": "ywelsch", "createdAt": "2020-04-03T13:05:08Z", "path": "server/src/main/java/org/elasticsearch/transport/InboundAggregator.java", "diffHunk": "@@ -108,23 +156,84 @@ public void close() {\n     }\n \n     private void closeCurrentAggregation() {\n+        releaseContent();\n+        resetCurrentAggregation();\n+    }\n+\n+    private void releaseContent() {\n         if (contentAggregation == null) {\n             Releasables.close(firstContent);\n         } else {\n             Releasables.close(contentAggregation);\n         }\n-        resetCurrentAggregation();\n     }\n \n     private void resetCurrentAggregation() {\n         firstContent = null;\n         contentAggregation = null;\n         currentHeader = null;\n+        aggregationException = null;\n+        canTripBreaker = true;\n     }\n \n     private void ensureOpen() {\n         if (isClosed) {\n             throw new IllegalStateException(\"Aggregator is already closed\");\n         }\n     }\n+\n+    private void initializeRequestState() {\n+        assert currentHeader.needsToReadVariableHeader() == false;\n+        assert currentHeader.isRequest();\n+        if (currentHeader.isHandshake()) {\n+            canTripBreaker = false;\n+            return;\n+        }\n+\n+        final String actionName = currentHeader.getActionName();\n+        try {\n+            canTripBreaker = requestCanTripBreaker.test(actionName);\n+        } catch (ActionNotFoundTransportException e) {\n+            shortCircuit(new ActionNotFoundTransportException(actionName));\n+        }\n+    }\n+\n+    private void checkBreaker(final Header header, final int contentLength, final BreakerControl breakerControl) {\n+        if (header.isRequest() == false) {\n+            return;\n+        }\n+        assert header.needsToReadVariableHeader() == false;\n+\n+        if (canTripBreaker) {\n+            try {\n+                circuitBreaker.get().addEstimateBytesAndMaybeBreak(contentLength, \"<transport_request>\");\n+                breakerControl.incrementReservedBytes(contentLength);\n+            } catch (CircuitBreakingException e) {\n+                shortCircuit(e);\n+            }\n+        } else {\n+            circuitBreaker.get().addWithoutBreaking(contentLength);\n+            breakerControl.incrementReservedBytes(contentLength);\n+        }\n+    }\n+\n+    private static class BreakerControl implements Releasable {\n+\n+        private final Supplier<CircuitBreaker> circuitBreaker;\n+        private final AtomicInteger bytesToRelease = new AtomicInteger(0);\n+\n+        private BreakerControl(Supplier<CircuitBreaker> circuitBreaker) {\n+            this.circuitBreaker = circuitBreaker;\n+        }\n+\n+        private void incrementReservedBytes(int delta) {\n+            bytesToRelease.getAndAdd(delta);\n+        }\n+\n+        @Override\n+        public void close() {\n+            final int toRelease = bytesToRelease.getAndSet(0);", "originalCommit": "901d63ed7dcf7b98bad8328b4102305831a4a149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIwNjc0OA==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r403206748", "bodyText": "I made a change.", "author": "tbrooks8", "createdAt": "2020-04-03T18:07:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk5MDI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk5Mzk0OA==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402993948", "bodyText": "when do we expect this to happen? should we assert false here?", "author": "ywelsch", "createdAt": "2020-04-03T13:11:25Z", "path": "server/src/main/java/org/elasticsearch/transport/InboundPipeline.java", "diffHunk": "@@ -74,6 +75,18 @@ public void close() {\n     }\n \n     public void handleBytes(TcpChannel channel, ReleasableBytesReference reference) throws IOException {\n+        if (uncaughtException != null) {\n+            throw new IllegalStateException(\"Pipeline state corrupted by uncaught exception\", uncaughtException);", "originalCommit": "901d63ed7dcf7b98bad8328b4102305831a4a149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNjgzNA==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r403216834", "bodyText": "Theoretically this could happen I think on the HTTP on transport error. But with all of the async handling involved here I thought it was appropriate to add a IllegalStateException, but not strict enough to add an assertion as we are very dependent on the different implements (Mock, Nio, and Netty) for the channel close path.", "author": "tbrooks8", "createdAt": "2020-04-03T18:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk5Mzk0OA=="}], "type": "inlineReview"}, {"oid": "299feebcf8cc2bc81f01b7ed84164a671e0ee3d4", "url": "https://github.com/elastic/elasticsearch/commit/299feebcf8cc2bc81f01b7ed84164a671e0ee3d4", "message": "Merge remote-tracking branch 'upstream/master' into circuit_breaking_inside_pipeline", "committedDate": "2020-04-03T16:08:24Z", "type": "commit"}, {"oid": "ac8b0f3e47b7bb6c43750d3a3a029d26de1c6c50", "url": "https://github.com/elastic/elasticsearch/commit/ac8b0f3e47b7bb6c43750d3a3a029d26de1c6c50", "message": "Delete comment", "committedDate": "2020-04-03T16:12:18Z", "type": "commit"}, {"oid": "13f62856b7a2097691af72596fcc5e2969d61b85", "url": "https://github.com/elastic/elasticsearch/commit/13f62856b7a2097691af72596fcc5e2969d61b85", "message": "Changes", "committedDate": "2020-04-03T18:09:53Z", "type": "commit"}, {"oid": "f8cbb2e08ccb12bae6ca650c337aaad1e114fdcd", "url": "https://github.com/elastic/elasticsearch/commit/f8cbb2e08ccb12bae6ca650c337aaad1e114fdcd", "message": "Change", "committedDate": "2020-04-03T19:04:35Z", "type": "commit"}, {"oid": "6283366f0dd171ec6814c56d6f9eddd7c3c30278", "url": "https://github.com/elastic/elasticsearch/commit/6283366f0dd171ec6814c56d6f9eddd7c3c30278", "message": "Cleanup exception handling", "committedDate": "2020-04-03T19:29:01Z", "type": "commit"}, {"oid": "21bbda9298ad9b0b9339bde53794346b1e28604e", "url": "https://github.com/elastic/elasticsearch/commit/21bbda9298ad9b0b9339bde53794346b1e28604e", "message": "Whitespace", "committedDate": "2020-04-03T19:33:12Z", "type": "commit"}, {"oid": "3f2a32cd687cdad6a204ce424e45e665d146d270", "url": "https://github.com/elastic/elasticsearch/commit/3f2a32cd687cdad6a204ce424e45e665d146d270", "message": "Merge remote-tracking branch 'upstream/master' into circuit_breaking_inside_pipeline", "committedDate": "2020-04-03T19:46:10Z", "type": "commit"}, {"oid": "3c7ae75c32026ed1c64a9b3a7ecd550b7db08097", "url": "https://github.com/elastic/elasticsearch/commit/3c7ae75c32026ed1c64a9b3a7ecd550b7db08097", "message": "Change", "committedDate": "2020-04-03T19:50:55Z", "type": "commit"}, {"oid": "17f42a3f460e1c335a9df257cd4156bc29d2dd09", "url": "https://github.com/elastic/elasticsearch/commit/17f42a3f460e1c335a9df257cd4156bc29d2dd09", "message": "Merge remote-tracking branch 'upstream/master' into circuit_breaking_inside_pipeline", "committedDate": "2020-04-03T21:49:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkwMTcyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r403901721", "bodyText": "If TransportHandshaker.handleHandshake throws an exception (e.g. IllegalStateException), that is no longer bubbled up back to the node that initiated the handshake. I'm not sure what this change of behavior entails, but would suggest backing it out of this PR.", "author": "ywelsch", "createdAt": "2020-04-06T08:07:15Z", "path": "server/src/main/java/org/elasticsearch/transport/InboundHandler.java", "diffHunk": "@@ -147,54 +145,57 @@ private void messageReceived(InboundMessage message, TcpChannel channel) throws\n         }\n     }\n \n-    private <T extends TransportRequest> void handleRequest(TcpChannel channel, Header header, StreamInput stream, int messageLengthBytes) {\n+    private <T extends TransportRequest> void handleRequest(TcpChannel channel, Header header, InboundMessage message) throws IOException {\n         final String action = header.getActionName();\n         final long requestId = header.getRequestId();\n         final Version version = header.getVersion();\n-        TransportChannel transportChannel = null;\n-        try {\n+        if (header.isHandshake()) {\n             messageListener.onRequestReceived(requestId, action);\n-            if (header.isHandshake()) {\n-                // Handshakes are not currently circuit broken\n-                transportChannel = new TcpTransportChannel(outboundHandler, channel, action, requestId, version,\n-                    circuitBreakerService, 0, header.isCompressed(), header.isHandshake());\n+            // Cannot short circuit handshakes\n+            assert message.isShortCircuit() == false;\n+            final StreamInput stream = namedWriteableStream(message.openOrGetStreamInput());\n+            assertRemoteVersion(stream, header.getVersion());\n+            try (Releasable breakerRelease = message.takeBreakerReleaseControl()) {\n+                final TransportChannel transportChannel = new TcpTransportChannel(outboundHandler, channel, action, requestId, version,\n+                    header.isCompressed(), header.isHandshake(), () -> {});\n                 handshaker.handleHandshake(transportChannel, requestId, stream);", "originalCommit": "17f42a3f460e1c335a9df257cd4156bc29d2dd09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIwMTk1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r404201955", "bodyText": "Made this change.", "author": "tbrooks8", "createdAt": "2020-04-06T15:54:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkwMTcyMQ=="}], "type": "inlineReview"}, {"oid": "d972a6272e519277e795431b5f880e58eed238dc", "url": "https://github.com/elastic/elasticsearch/commit/d972a6272e519277e795431b5f880e58eed238dc", "message": "Changes", "committedDate": "2020-04-06T15:54:08Z", "type": "commit"}, {"oid": "5f5fb0fe4c2e11a7f6074642264b0efa8f44c5b3", "url": "https://github.com/elastic/elasticsearch/commit/5f5fb0fe4c2e11a7f6074642264b0efa8f44c5b3", "message": "Merge remote-tracking branch 'upstream/master' into circuit_breaking_inside_pipeline", "committedDate": "2020-04-06T17:00:30Z", "type": "commit"}, {"oid": "c300562a5f736505ae185aa4f2f47a08071950cb", "url": "https://github.com/elastic/elasticsearch/commit/c300562a5f736505ae185aa4f2f47a08071950cb", "message": "Merge remote-tracking branch 'upstream/master' into circuit_breaking_inside_pipeline", "committedDate": "2020-04-06T17:44:21Z", "type": "commit"}]}