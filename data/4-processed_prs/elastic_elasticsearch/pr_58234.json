{"pr_number": 58234, "pr_title": "Improved ExtensiblePlugin", "pr_createdAt": "2020-06-17T10:05:48Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58234", "timeline": [{"oid": "9af357b83200305a178bb48eb9cc7c257c1fdc62", "url": "https://github.com/elastic/elasticsearch/commit/9af357b83200305a178bb48eb9cc7c257c1fdc62", "message": "Improved ExtensiblePlugin\n\nRather than let ExtensiblePlugins know extending plugins' classloaders,\nwe now pass along an explicit ExtensionLoader that loads the extensions\nasked for. Extensions constructed that way can optionally receive their\nown Plugin instance in the constructor.", "committedDate": "2020-06-17T09:58:06Z", "type": "commit"}, {"oid": "cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd", "url": "https://github.com/elastic/elasticsearch/commit/cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd", "message": "Fix Security.java", "committedDate": "2020-06-17T11:04:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2MTExNQ==", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r442561115", "bodyText": "We have a utility method for this instanceof pattern, filterPlugins. I think it would also be clearer to use a normal for loop rather than forEach?", "author": "rjernst", "createdAt": "2020-06-18T23:55:06Z", "path": "server/src/main/java/org/elasticsearch/plugins/PluginsService.java", "diffHunk": "@@ -426,17 +429,66 @@ private static void addSortedBundle(Bundle bundle, Map<String, Bundle> bundles,\n         Map<String, Plugin> loaded = new HashMap<>();\n         Map<String, Set<URL>> transitiveUrls = new HashMap<>();\n         List<Bundle> sortedBundles = sortBundles(bundles);\n-\n         for (Bundle bundle : sortedBundles) {\n             checkBundleJarHell(JarHell.parseClassPath(), bundle, transitiveUrls);\n \n             final Plugin plugin = loadBundle(bundle, loaded);\n             plugins.add(new Tuple<>(bundle.plugin, plugin));\n         }\n \n+        loadExtensions(plugins);\n         return Collections.unmodifiableList(plugins);\n     }\n \n+    // package-private for test visibility\n+    static void loadExtensions(List<Tuple<PluginInfo, Plugin>> plugins) {\n+        Map<String, List<Plugin>> extendingPlugins = plugins.stream()\n+            .flatMap(t -> t.v1().getExtendedPlugins().stream().map(extendedPlugin -> Tuple.tuple(extendedPlugin, t.v2())))\n+            .collect(Collectors.groupingBy(Tuple::v1, Collectors.mapping(Tuple::v2, Collectors.toList())));\n+        plugins.stream().filter(t -> t.v2() instanceof ExtensiblePlugin).forEach(t -> loadExtensionsForPlugin((ExtensiblePlugin) t.v2(),", "originalCommit": "cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE2MjQ3OA==", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r444162478", "bodyText": "I changed this into a for loop instead, but were unable to use filterPlugins, since:\n\nIt operates on the full list of plugins, which includes test plugins.\nIt returns plugins, thus I loose the name of the module/bundle, which seems like the most natural key to use for the map above.", "author": "henningandersen", "createdAt": "2020-06-23T11:47:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2MTExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2MjgwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r442562805", "bodyText": "This could just be created in loadExtensions, no need to create a new one for each individual plugin? AFAICT it always operates on the same stream of plugins passed in.", "author": "rjernst", "createdAt": "2020-06-19T00:01:22Z", "path": "server/src/main/java/org/elasticsearch/plugins/PluginsService.java", "diffHunk": "@@ -426,17 +429,66 @@ private static void addSortedBundle(Bundle bundle, Map<String, Bundle> bundles,\n         Map<String, Plugin> loaded = new HashMap<>();\n         Map<String, Set<URL>> transitiveUrls = new HashMap<>();\n         List<Bundle> sortedBundles = sortBundles(bundles);\n-\n         for (Bundle bundle : sortedBundles) {\n             checkBundleJarHell(JarHell.parseClassPath(), bundle, transitiveUrls);\n \n             final Plugin plugin = loadBundle(bundle, loaded);\n             plugins.add(new Tuple<>(bundle.plugin, plugin));\n         }\n \n+        loadExtensions(plugins);\n         return Collections.unmodifiableList(plugins);\n     }\n \n+    // package-private for test visibility\n+    static void loadExtensions(List<Tuple<PluginInfo, Plugin>> plugins) {\n+        Map<String, List<Plugin>> extendingPlugins = plugins.stream()\n+            .flatMap(t -> t.v1().getExtendedPlugins().stream().map(extendedPlugin -> Tuple.tuple(extendedPlugin, t.v2())))\n+            .collect(Collectors.groupingBy(Tuple::v1, Collectors.mapping(Tuple::v2, Collectors.toList())));\n+        plugins.stream().filter(t -> t.v2() instanceof ExtensiblePlugin).forEach(t -> loadExtensionsForPlugin((ExtensiblePlugin) t.v2(),\n+            extendingPlugins.getOrDefault(t.v1().getName(), List.of())));\n+    }\n+\n+    private static void loadExtensionsForPlugin(ExtensiblePlugin extensiblePlugin, List<Plugin> extendingPlugins) {\n+        ExtensiblePlugin.ExtensionLoader extensionLoader = new ExtensiblePlugin.ExtensionLoader() {", "originalCommit": "cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY1NTM1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r443655357", "bodyText": "The set of plugins passed in are only those extending the plugin that we load extensions for. This ensures that a plugin cannot ask for extensions that it does not own. Like ML asking for all autoscaling-deciders, which would succeed if the list of plugins was every plugin extending some other plugins. Also, the runtime would be slightly worse I think, since we would also be searching for extensions in unrelated modules.", "author": "henningandersen", "createdAt": "2020-06-22T15:45:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2MjgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0NzA1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r444347059", "bodyText": "Thanks for the explanation. I missed the lookup in calling of this method, thinking the extendingPlugins in the calling function (a map) was the same as extendingPlugins here (the value from that map, a list). Maybe consider changing the variable name to clarify they are different.", "author": "rjernst", "createdAt": "2020-06-23T16:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2MjgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2MzY4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r442563687", "bodyText": "Why a stream? It seems to lend itself to longer lines, but not easier to read code in this case, especially in the implementation below", "author": "rjernst", "createdAt": "2020-06-19T00:04:38Z", "path": "server/src/main/java/org/elasticsearch/plugins/ExtensiblePlugin.java", "diffHunk": "@@ -27,8 +29,22 @@\n  */\n public interface ExtensiblePlugin {\n \n+    interface ExtensionLoader {\n+        /**\n+         * Load extensions of the type from all extending plugins. The concrete extensions must have either a no-arg constructor\n+         * or a single-arg constructor accepting the specific plugin class.\n+         * @param extensionPointType the extension point type\n+         * @param <T> extension point type\n+         * @return stream of all implementing extensions.\n+         */\n+        <T> Stream<T> loadExtensions(Class<T> extensionPointType);", "originalCommit": "cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE2MzEyMg==", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r444163122", "bodyText": "I changed it to a List. Stream is nice though, since its contract is read-only and read-once - and still easy to use (unlike Iterable and Iterator).", "author": "henningandersen", "createdAt": "2020-06-23T11:49:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2MzY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2MzkzMA==", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r442563930", "bodyText": "I think we should lookup constructors just like in loadPlugin, rather than using exceptions as control flow here. The suppressed exception in the case we use the zero arg constructor would be especially confusing.", "author": "rjernst", "createdAt": "2020-06-19T00:05:42Z", "path": "server/src/main/java/org/elasticsearch/plugins/PluginsService.java", "diffHunk": "@@ -426,17 +429,66 @@ private static void addSortedBundle(Bundle bundle, Map<String, Bundle> bundles,\n         Map<String, Plugin> loaded = new HashMap<>();\n         Map<String, Set<URL>> transitiveUrls = new HashMap<>();\n         List<Bundle> sortedBundles = sortBundles(bundles);\n-\n         for (Bundle bundle : sortedBundles) {\n             checkBundleJarHell(JarHell.parseClassPath(), bundle, transitiveUrls);\n \n             final Plugin plugin = loadBundle(bundle, loaded);\n             plugins.add(new Tuple<>(bundle.plugin, plugin));\n         }\n \n+        loadExtensions(plugins);\n         return Collections.unmodifiableList(plugins);\n     }\n \n+    // package-private for test visibility\n+    static void loadExtensions(List<Tuple<PluginInfo, Plugin>> plugins) {\n+        Map<String, List<Plugin>> extendingPlugins = plugins.stream()\n+            .flatMap(t -> t.v1().getExtendedPlugins().stream().map(extendedPlugin -> Tuple.tuple(extendedPlugin, t.v2())))\n+            .collect(Collectors.groupingBy(Tuple::v1, Collectors.mapping(Tuple::v2, Collectors.toList())));\n+        plugins.stream().filter(t -> t.v2() instanceof ExtensiblePlugin).forEach(t -> loadExtensionsForPlugin((ExtensiblePlugin) t.v2(),\n+            extendingPlugins.getOrDefault(t.v1().getName(), List.of())));\n+    }\n+\n+    private static void loadExtensionsForPlugin(ExtensiblePlugin extensiblePlugin, List<Plugin> extendingPlugins) {\n+        ExtensiblePlugin.ExtensionLoader extensionLoader = new ExtensiblePlugin.ExtensionLoader() {\n+            @Override\n+            public <T> Stream<T> loadExtensions(Class<T> extensionPointType) {\n+                return extendingPlugins.stream().flatMap(plugin -> createExtensions(extensionPointType, plugin));\n+            }\n+        };\n+\n+        extensiblePlugin.loadExtensions(extensionLoader);\n+    }\n+\n+    private static <T> Stream<? extends T> createExtensions(Class<T> extensionPointType, Plugin plugin) {\n+        SPIClassIterator<T> classIterator = SPIClassIterator.get(extensionPointType, plugin.getClass().getClassLoader());\n+        List<T> extensions = new ArrayList<>();\n+        while (classIterator.hasNext()) {\n+            Class<? extends T> extensionClass = classIterator.next();\n+            extensions.add(createExtension(extensionClass, plugin, extensionPointType));\n+        }\n+        return extensions.stream();\n+    }\n+\n+    private static <T> T createExtension(Class<? extends T> extensionClass, Plugin plugin, Class<T> extensionPointType) {\n+        try {\n+            try {\n+                return extensionClass.getConstructor(plugin.getClass()).newInstance(plugin);\n+            } catch (NoSuchMethodException e) {", "originalCommit": "cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2NDU2NA==", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r442564564", "bodyText": "When can this happen?", "author": "rjernst", "createdAt": "2020-06-19T00:08:14Z", "path": "server/src/main/java/org/elasticsearch/plugins/PluginsService.java", "diffHunk": "@@ -509,12 +561,13 @@ private Plugin loadBundle(Bundle bundle, Map<String, Plugin> loaded) {\n \n         // reload SPI with any new services from the plugin\n         reloadLuceneSPI(loader);\n-        for (String extendedPluginName : bundle.plugin.getExtendedPlugins()) {\n-            // note: already asserted above that extended plugins are loaded and extensible\n-            ExtensiblePlugin.class.cast(loaded.get(extendedPluginName)).reloadSPI(loader);\n-        }\n \n         Class<? extends Plugin> pluginClass = loadPluginClass(bundle.plugin.getClassname(), loader);\n+        if (loader != pluginClass.getClassLoader()) {", "originalCommit": "cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAxNDUzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r444014531", "bodyText": "It is not so much that it could happen, I hope not. But we rely on this now in createExtensions:\nhttps://github.com/elastic/elasticsearch/pull/58234/files#diff-40d98239fea26b07396b5032b95e396fR464\nwhich is why I introduced this check which seems intuitively correct? And it is not obvious to me that we explicit guard against pointing to a plugin from a different module elsewhere?", "author": "henningandersen", "createdAt": "2020-06-23T07:23:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2NDU2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM2MTAwMA==", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r444361000", "bodyText": "I understand now. Could we possibly have a test for this case?", "author": "rjernst", "createdAt": "2020-06-23T16:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2NDU2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMyNjE0MA==", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r445326140", "bodyText": "Turned out not too difficult, added a test here: eec9b68", "author": "henningandersen", "createdAt": "2020-06-25T06:06:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2NDU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2NDgwNA==", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r442564804", "bodyText": "Can we have some tests for the error cases? For example, no valid ctor exists, or we fail when calling the ctor?", "author": "rjernst", "createdAt": "2020-06-19T00:09:16Z", "path": "server/src/test/java/org/elasticsearch/plugins/PluginsServiceTests.java", "diffHunk": "@@ -690,4 +695,54 @@ public void testExistingMandatoryInstalledPlugin() throws IOException {\n                         .build();\n         newPluginsService(settings);\n     }\n+\n+    public void testExtensiblePlugin() {\n+        TestExtensiblePlugin extensiblePlugin = new TestExtensiblePlugin();\n+        PluginsService.loadExtensions(List.of(\n+            Tuple.tuple(new PluginInfo(\"extensible\", null, null, null, null, null, List.of(), false), extensiblePlugin)\n+        ));\n+\n+        assertThat(extensiblePlugin.extensions, notNullValue());\n+        assertThat(extensiblePlugin.extensions, hasSize(0));\n+\n+        extensiblePlugin = new TestExtensiblePlugin();\n+        TestPlugin testPlugin = new TestPlugin();\n+        PluginsService.loadExtensions(List.of(\n+            Tuple.tuple(new PluginInfo(\"extensible\", null, null, null, null, null, List.of(), false), extensiblePlugin),\n+            Tuple.tuple(new PluginInfo(\"test\", null, null, null, null, null, List.of(\"extensible\"), false), testPlugin)\n+        ));\n+\n+        assertThat(extensiblePlugin.extensions, notNullValue());\n+        assertThat(extensiblePlugin.extensions, hasSize(2));\n+        assertThat(extensiblePlugin.extensions.get(0), instanceOf(TestExtension1.class));\n+        assertThat(extensiblePlugin.extensions.get(1), instanceOf(TestExtension2.class));\n+        assertThat(((TestExtension2) extensiblePlugin.extensions.get(1)).plugin, sameInstance(testPlugin));\n+    }\n+", "originalCommit": "cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "58e39e75e8334f49346a3ff2d7cab21afcefb06f", "url": "https://github.com/elastic/elasticsearch/commit/58e39e75e8334f49346a3ff2d7cab21afcefb06f", "message": "Nicer errors on bad constructors.", "committedDate": "2020-06-23T08:59:06Z", "type": "commit"}, {"oid": "a261f6c599e0a048d11617f8cb985fa5968fda6a", "url": "https://github.com/elastic/elasticsearch/commit/a261f6c599e0a048d11617f8cb985fa5968fda6a", "message": "Verify exception in constructor.", "committedDate": "2020-06-23T09:16:59Z", "type": "commit"}, {"oid": "91eb29697b5b9d4df658a52f90b1d364d8ba50f7", "url": "https://github.com/elastic/elasticsearch/commit/91eb29697b5b9d4df658a52f90b1d364d8ba50f7", "message": "Remove some stream usages.", "committedDate": "2020-06-23T10:02:21Z", "type": "commit"}, {"oid": "4e6e55b9c21a01b946ec95f8f7b224ad7f4859fe", "url": "https://github.com/elastic/elasticsearch/commit/4e6e55b9c21a01b946ec95f8f7b224ad7f4859fe", "message": "Merge branch 'master' into enhance_extensible_plugin", "committedDate": "2020-06-23T11:51:04Z", "type": "commit"}, {"oid": "377fb10d500aba60826e25b0bffef727ce9fe468", "url": "https://github.com/elastic/elasticsearch/commit/377fb10d500aba60826e25b0bffef727ce9fe468", "message": "Rename variable to avoid confusion", "committedDate": "2020-06-25T05:41:03Z", "type": "commit"}, {"oid": "eec9b68203ba9748543d2b4f5709dc19a2accc61", "url": "https://github.com/elastic/elasticsearch/commit/eec9b68203ba9748543d2b4f5709dc19a2accc61", "message": "Add test case\n\nAdded test case for defining a plugin using a Plugin class from the\nparent class loader.", "committedDate": "2020-06-25T06:03:25Z", "type": "commit"}, {"oid": "82b977d21d22bb05632aa5c6bff85201a0065b21", "url": "https://github.com/elastic/elasticsearch/commit/82b977d21d22bb05632aa5c6bff85201a0065b21", "message": "Merge remote-tracking branch 'origin/master' into enhance_extensible_plugin", "committedDate": "2020-06-25T06:03:53Z", "type": "commit"}, {"oid": "8817fe475fabd2df569c311dd43775afb2a0f270", "url": "https://github.com/elastic/elasticsearch/commit/8817fe475fabd2df569c311dd43775afb2a0f270", "message": "Merge branch 'master' into enhance_extensible_plugin", "committedDate": "2020-06-25T08:14:02Z", "type": "commit"}]}