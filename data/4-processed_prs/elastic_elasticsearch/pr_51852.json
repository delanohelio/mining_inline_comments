{"pr_number": 51852, "pr_title": "Shortcut query phase using the results of other shards", "pr_createdAt": "2020-02-04T10:07:33Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51852", "timeline": [{"oid": "28fa23b8cb69dc2e78d6aaf491d08d47b1164e43", "url": "https://github.com/elastic/elasticsearch/commit/28fa23b8cb69dc2e78d6aaf491d08d47b1164e43", "message": "Always rewrite search shard request outside of the search thread pool\n\nThis change ensures that the rewrite of the shard request is executed in the network thread or in the refresh listener\nwhen waiting for an active shard. This allows queries that rewrite to match_no_docs to bypass the search thread pool\nentirely even if the can_match phase was skipped (pre_filter_shard_size > number of shards). Coordinating nodes\ndon't have the ability to create empty responses so this change also ensures that at least one shard creates a full empty\nresponse while the other can return null ones. This is needed since creating true empty responses on shards require to create\nconcrete aggregators which would be too costly to build on a network thread. We should move this functionality to aggregation\nbuilders in a follow up but that would be a much bigger change.\nThis change is also important for #49601 since we want to add the ability to use the result of other shards to rewrite the request\nof subsequent ones. For instance if the first M shards have their top N computed, the top worst document in the global queue can be pass\nto subsequent shards that can then rewrite to match_no_docs if they can guarantee that they don't have any document better than the provided\none.", "committedDate": "2020-01-30T21:52:08Z", "type": "commit"}, {"oid": "534b5525ed54f1e4efbe6267bb154b9be578a6f7", "url": "https://github.com/elastic/elasticsearch/commit/534b5525ed54f1e4efbe6267bb154b9be578a6f7", "message": "add serialization test", "committedDate": "2020-01-30T22:03:28Z", "type": "commit"}, {"oid": "c02f352fe574de396eef1c89f98de74314a35133", "url": "https://github.com/elastic/elasticsearch/commit/c02f352fe574de396eef1c89f98de74314a35133", "message": "iter", "committedDate": "2020-01-30T22:40:32Z", "type": "commit"}, {"oid": "010ec08d4c01c55b49a5584e6ee2b57d5b67a180", "url": "https://github.com/elastic/elasticsearch/commit/010ec08d4c01c55b49a5584e6ee2b57d5b67a180", "message": "Merge branch 'master' into rewrite_shard_request_no_rejection", "committedDate": "2020-01-30T22:41:02Z", "type": "commit"}, {"oid": "f5684ecfc7c42588d167d0eec759f9f6f6a1ceb9", "url": "https://github.com/elastic/elasticsearch/commit/f5684ecfc7c42588d167d0eec759f9f6f6a1ceb9", "message": "fix bwc issue", "committedDate": "2020-01-30T23:35:04Z", "type": "commit"}, {"oid": "0acf244b16fc4a7e9bbfeb64160b71d1ae1a7535", "url": "https://github.com/elastic/elasticsearch/commit/0acf244b16fc4a7e9bbfeb64160b71d1ae1a7535", "message": "address review", "committedDate": "2020-02-03T10:17:08Z", "type": "commit"}, {"oid": "6016fa43c844868940c1cf4f5b8572ab69093d52", "url": "https://github.com/elastic/elasticsearch/commit/6016fa43c844868940c1cf4f5b8572ab69093d52", "message": "adapt test", "committedDate": "2020-02-03T10:49:40Z", "type": "commit"}, {"oid": "a0581270a25c6a11182a5eae9ec2cdeec39e2a07", "url": "https://github.com/elastic/elasticsearch/commit/a0581270a25c6a11182a5eae9ec2cdeec39e2a07", "message": "fix test", "committedDate": "2020-02-03T10:52:09Z", "type": "commit"}, {"oid": "8534ed25df43ced97d8ff983caaaec115f6d0ea6", "url": "https://github.com/elastic/elasticsearch/commit/8534ed25df43ced97d8ff983caaaec115f6d0ea6", "message": "fix topNSize when size is reset to 0", "committedDate": "2020-02-03T14:24:37Z", "type": "commit"}, {"oid": "27cdf19dfe2c98cd9939cb15f1cab7b34a6e5254", "url": "https://github.com/elastic/elasticsearch/commit/27cdf19dfe2c98cd9939cb15f1cab7b34a6e5254", "message": "add more comments", "committedDate": "2020-02-03T19:44:59Z", "type": "commit"}, {"oid": "a313d1d002930b1f3cc93c925ec7c4607997870e", "url": "https://github.com/elastic/elasticsearch/commit/a313d1d002930b1f3cc93c925ec7c4607997870e", "message": "Merge branch 'master' into rewrite_shard_request_no_rejection", "committedDate": "2020-02-03T19:45:23Z", "type": "commit"}, {"oid": "662972cf2de9b2ad36077b886c4930c8d2a08468", "url": "https://github.com/elastic/elasticsearch/commit/662972cf2de9b2ad36077b886c4930c8d2a08468", "message": "more review", "committedDate": "2020-02-03T20:36:16Z", "type": "commit"}, {"oid": "76e90a231f3d4ac4475425e0326792f845b2b4ac", "url": "https://github.com/elastic/elasticsearch/commit/76e90a231f3d4ac4475425e0326792f845b2b4ac", "message": "initial commit", "committedDate": "2020-02-03T20:38:39Z", "type": "commit"}, {"oid": "7eb98fbd56e69aa90abc1aae0022adae493700d4", "url": "https://github.com/elastic/elasticsearch/commit/7eb98fbd56e69aa90abc1aae0022adae493700d4", "message": "Merge branch 'master' into distributed_time_sort", "committedDate": "2020-02-03T20:38:42Z", "type": "commit"}, {"oid": "ac0451ca0a9f124e6567128a24450025050725a2", "url": "https://github.com/elastic/elasticsearch/commit/ac0451ca0a9f124e6567128a24450025050725a2", "message": "iter", "committedDate": "2020-02-03T22:25:00Z", "type": "commit"}, {"oid": "d0ae6587a970699e73ece42db6a4f2c378b8b1b6", "url": "https://github.com/elastic/elasticsearch/commit/d0ae6587a970699e73ece42db6a4f2c378b8b1b6", "message": "iter", "committedDate": "2020-02-04T08:14:52Z", "type": "commit"}, {"oid": "c6747e6f0a895509ac1677a2d10be21b13fa96ad", "url": "https://github.com/elastic/elasticsearch/commit/c6747e6f0a895509ac1677a2d10be21b13fa96ad", "message": "Merge branch 'rewrite_shard_request_no_rejection' into distributed_time_sort", "committedDate": "2020-02-04T08:17:26Z", "type": "commit"}, {"oid": "30b3bcb19c8f23baf30b3b5db2da261612f8fe78", "url": "https://github.com/elastic/elasticsearch/commit/30b3bcb19c8f23baf30b3b5db2da261612f8fe78", "message": "iter2", "committedDate": "2020-02-04T09:40:31Z", "type": "commit"}, {"oid": "961c2cd4aa0547272e1e50fda213de90e5f81754", "url": "https://github.com/elastic/elasticsearch/commit/961c2cd4aa0547272e1e50fda213de90e5f81754", "message": "remove unrelated change", "committedDate": "2020-02-04T10:39:34Z", "type": "commit"}, {"oid": "d04a16d605b25c47739ededb18366a802764d45a", "url": "https://github.com/elastic/elasticsearch/commit/d04a16d605b25c47739ededb18366a802764d45a", "message": "Merge branch 'master' into distributed_time_sort", "committedDate": "2020-02-06T08:27:31Z", "type": "commit"}, {"oid": "af204212f937a19f9b92df50034a59e76fdaa06a", "url": "https://github.com/elastic/elasticsearch/commit/af204212f937a19f9b92df50034a59e76fdaa06a", "message": "fix last merge", "committedDate": "2020-02-06T08:40:23Z", "type": "commit"}, {"oid": "291f7427ea7d4d96b0c36857366a15956934a9aa", "url": "https://github.com/elastic/elasticsearch/commit/291f7427ea7d4d96b0c36857366a15956934a9aa", "message": "fix rest test", "committedDate": "2020-02-06T11:07:13Z", "type": "commit"}, {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310", "url": "https://github.com/elastic/elasticsearch/commit/71876e4253d3bac8f2acab736aaa74ba35edf310", "message": "another fix", "committedDate": "2020-02-06T11:57:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzEzOTEzNg==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r377139136", "bodyText": "Not relevant to this PR, but In future, do we want to rewrite  also requests without sort ( e.g. a keyword search) that can be shortcut?", "author": "mayya-sharipova", "createdAt": "2020-02-10T15:38:16Z", "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +85,38 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest rewriteShardRequest(ShardSearchRequest request) {", "originalCommit": "71876e4253d3bac8f2acab736aaa74ba35edf310", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk3Mjg2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r384972869", "bodyText": "I am not sure I follow. Are you talking of handling queries sorted by _score ? We can probably propagate the global min competitive score up to the query collector so that wouldn't require any rewrite.", "author": "jimczi", "createdAt": "2020-02-27T08:23:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzEzOTEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE0MTk5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r377141997", "bodyText": "we can use this.topDocsSize  that we have already pre-calculated.", "author": "mayya-sharipova", "createdAt": "2020-02-10T15:42:21Z", "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +85,38 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest rewriteShardRequest(ShardSearchRequest request) {\n+        TopDocs topDocs = topDocsSupplier.get();\n+        if (topDocs != null && topDocs instanceof TopFieldDocs) {\n+            SearchSourceBuilder source = request.source();\n+            int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO :\n+                source.trackTotalHitsUpTo();\n+            if (topDocs.totalHits.value >= trackTotalHits) {\n+                SearchSourceBuilder newSource = source.shallowCopy();\n+                newSource.trackTotalHits(false);\n+                if (topDocs.scoreDocs.length >= topDocsSize) {\n+                    FieldDoc bottomDoc = (FieldDoc) topDocs.scoreDocs[topDocs.scoreDocs.length-1];\n+                    request.setRawBottomSortValues(bottomDoc.fields);\n+                }\n+                request.source(newSource);\n+            }\n+        }\n+        return request;\n+    }\n+\n+    private Supplier<TopDocs> getBufferTopDocsSupplier(SearchRequest request,\n+                                                       SearchPhaseResults<SearchPhaseResult> searchPhaseResults) {\n+        if (searchPhaseResults instanceof SearchPhaseController.QueryPhaseResultConsumer == false) {\n+            return () -> null;\n+        }\n+        int size = getTopDocsSize(request);", "originalCommit": "71876e4253d3bac8f2acab736aaa74ba35edf310", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIyNjk5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r377226997", "bodyText": "I wondering about the case where there was not a reduction, and topDocsBuffer[0] contains a result of any of the first X shards (X is currently 512 by default).   In this case the bottom doc of this shard may not be the best competitive doc.  If we have several topDocs available, should we inspect all of them to find the most competitive doc?", "author": "mayya-sharipova", "createdAt": "2020-02-10T18:05:49Z", "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -683,6 +683,15 @@ private synchronized void consumeInternal(QuerySearchResult querySearchResult) {\n             processedShards[querySearchResult.getShardIndex()] = querySearchResult.getSearchShardTarget();\n         }\n \n+        public TopDocs getBufferTopDocs() {\n+            if (hasTopDocs) {\n+                synchronized (this) {\n+                    return topDocsBuffer[0];", "originalCommit": "71876e4253d3bac8f2acab736aaa74ba35edf310", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTExMDk4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385110989", "bodyText": "It's correct since any top hits that contains the requested size can be used but I agree that checking all top hits no matter what the buffer size could yield significant improvements. I was expecting to lower the batched_reduce_size by default in # so that this won't make a big difference but there are some discussions regarding the impact of setting this to a low value so making the change that you propose would make this decision less important for this optim. We also expect that this optimization will be really effective when the sort values are not randomly distributed so we could just check the worst hit of each shard and keep the minimum one which can be done linearly. I'll work on the change.", "author": "jimczi", "createdAt": "2020-02-27T13:01:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIyNjk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0MTcxMw==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385741713", "bodyText": "I pushed bf8ebde", "author": "jimczi", "createdAt": "2020-02-28T14:59:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIyNjk5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI0Mjc3NA==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r377242774", "bodyText": "should we instead sum all values from totalHits.value from all topDocs in QueryPhaseResultConsumer#topDocsBuffer?", "author": "mayya-sharipova", "createdAt": "2020-02-10T18:37:31Z", "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +85,38 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest rewriteShardRequest(ShardSearchRequest request) {\n+        TopDocs topDocs = topDocsSupplier.get();\n+        if (topDocs != null && topDocs instanceof TopFieldDocs) {\n+            SearchSourceBuilder source = request.source();\n+            int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO :\n+                source.trackTotalHitsUpTo();\n+            if (topDocs.totalHits.value >= trackTotalHits) {", "originalCommit": "71876e4253d3bac8f2acab736aaa74ba35edf310", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTExMTAzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385111035", "bodyText": "++, that will converge more quickly to the provided trackTotalHits.", "author": "jimczi", "createdAt": "2020-02-27T13:01:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI0Mjc3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0MTc2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385741763", "bodyText": "I pushed bf8ebde", "author": "jimczi", "createdAt": "2020-02-28T14:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI0Mjc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI0NDU4MA==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r377244580", "bodyText": "I am wondering if instead TRACK_TOTAL_HITS_DISABLED we can instead have a condition describing that we have already collected enough total hits?", "author": "mayya-sharipova", "createdAt": "2020-02-10T18:41:05Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ShardSearchRequest.java", "diffHunk": "@@ -343,6 +367,25 @@ public String getDescription() {\n         public Rewriteable rewrite(QueryRewriteContext ctx) throws IOException {\n             SearchSourceBuilder newSource = request.source() == null ? null : Rewriteable.rewrite(request.source(), ctx);\n             AliasFilter newAliasFilter = Rewriteable.rewrite(request.getAliasFilter(), ctx);\n+\n+            QueryShardContext shardContext = ctx.convertToShardContext();\n+            FieldSortBuilder primarySort = FieldSortBuilder.getPrimaryFieldSortOrNull(newSource);\n+            // checks if the bottom sort values are guaranteed to be more competitive than all the documents\n+            // contained in the shard\n+            if (shardContext != null\n+                    && primarySort != null\n+                    && primarySort.isBottomSortWithinShard(shardContext, request.getRawBottomSortValues()) == false) {\n+                newSource = newSource.shallowCopy();\n+                if (newSource.trackTotalHitsUpTo() == TRACK_TOTAL_HITS_DISABLED", "originalCommit": "71876e4253d3bac8f2acab736aaa74ba35edf310", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTExMTY0NA==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385111644", "bodyText": "Sorry I am not following. Are you suggesting that we need another boolean ?", "author": "jimczi", "createdAt": "2020-02-27T13:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI0NDU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxOTQ5NA==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385819494", "bodyText": "Sorry, you are already doing that in SearchQueryThenFetchAsyncAction", "author": "mayya-sharipova", "createdAt": "2020-02-28T17:17:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI0NDU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI1OTI1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r377259256", "bodyText": "I am wondering if we send MatchNoneQueryBuilder() request to a shard, or size =0 for a request containing query part, can we say that we skipped this shard?", "author": "mayya-sharipova", "createdAt": "2020-02-10T19:08:43Z", "path": "rest-api-spec/src/main/resources/rest-api-spec/test/search/140_pre_filter_search_shards.yml", "diffHunk": "@@ -180,5 +178,47 @@ setup:\n   - match: { _shards.successful: 3 }\n   - match: { _shards.skipped : 0 }\n   - match: { _shards.failed: 0 }\n-  - match: { hits.total: 0 }\n+  - match: { hits.total.value: 0 }\n   - length: { aggregations.idx_terms.buckets: 0 }\n+\n+  # check field sort is correct when skipping query phase\n+  - do:\n+      search:\n+        # ensure that one shard can return empty response\n+        max_concurrent_shard_requests: 1\n+        pre_filter_shard_size: 1\n+        body:\n+          \"size\": 1\n+          \"track_total_hits\": 1\n+          \"sort\": [{ \"created_at\": \"desc\"}]\n+\n+  - match: { _shards.total: 3 }\n+  - match: { _shards.successful: 3 }\n+  - match: { _shards.skipped: 0 }", "originalCommit": "71876e4253d3bac8f2acab736aaa74ba35edf310", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTExMjczMQ==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385112731", "bodyText": "I have mixed feelings about this one. It would provide a valuable feedback for users since rewriting to MatchNoneQueryBuilder means that we can avoid the search threadpool but that information should be materialized for users with fast response time too. It will also make the counter non-deterministic so I wonder how much confusion this would bring.", "author": "jimczi", "createdAt": "2020-02-27T13:05:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI1OTI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY1NjI1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385656251", "bodyText": "I see, makes sense to keep it as it now.", "author": "mayya-sharipova", "createdAt": "2020-02-28T11:55:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI1OTI1Ng=="}], "type": "inlineReview"}, {"oid": "b8aa0e2f42e46d7e9fb9ceeea98ffc9302709c49", "url": "https://github.com/elastic/elasticsearch/commit/b8aa0e2f42e46d7e9fb9ceeea98ffc9302709c49", "message": "Merge branch 'master' into distributed_time_sort", "committedDate": "2020-02-24T11:12:59Z", "type": "commit"}, {"oid": "db4b44f855942177e4052c26ad46e2c486907f92", "url": "https://github.com/elastic/elasticsearch/commit/db4b44f855942177e4052c26ad46e2c486907f92", "message": "address review", "committedDate": "2020-02-24T11:19:45Z", "type": "commit"}, {"oid": "bd927bd48fe359c2d80c43abf778260f768740f4", "url": "https://github.com/elastic/elasticsearch/commit/bd927bd48fe359c2d80c43abf778260f768740f4", "message": "adapt serialization version before backport", "committedDate": "2020-02-24T11:54:07Z", "type": "commit"}, {"oid": "bf8ebde8430f12d9698f72e8d3ca54e61070993a", "url": "https://github.com/elastic/elasticsearch/commit/bf8ebde8430f12d9698f72e8d3ca54e61070993a", "message": "address review", "committedDate": "2020-02-28T14:57:47Z", "type": "commit"}, {"oid": "30173b6b6adea46e899b29099f8cc15136739abe", "url": "https://github.com/elastic/elasticsearch/commit/30173b6b6adea46e899b29099f8cc15136739abe", "message": "Merge branch 'master' into distributed_time_sort", "committedDate": "2020-02-28T14:58:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4MDAxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385780015", "bodyText": "should it be fieldComparator.compareValues(bestBottom, cand.fields[0]).... ?", "author": "mayya-sharipova", "createdAt": "2020-02-28T16:04:00Z", "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +89,67 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest buildShardSearchRequestInternal(SearchShardIterator shardIt) {\n+        ShardSearchRequest request = super.buildShardSearchRequest(shardIt);\n+        if (resultConsumer == null) {\n+            return request;\n+        }\n+        List<TopFieldDocs> topDocsList = resultConsumer.getRemainingTopDocs().stream()\n+            .filter(obj -> obj instanceof TopFieldDocs)\n+            .map(obj -> (TopFieldDocs) obj)\n+            .collect(Collectors.toList());\n+        if (topDocsList.isEmpty()) {\n+            return request;\n+        }\n+        SearchSourceBuilder source = request.source();\n+        int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO : source.trackTotalHitsUpTo();\n+        long totalHits = -1;\n+        FieldDoc bestBottom = null;\n+        SortField primarySort = topDocsList.get(0).fields[0];\n+        FieldComparator fieldComparator = primarySort.getComparator(1, 0);\n+        int reverseMul = primarySort.getReverse() ? -1 : 1;\n+        // we don't want to perform a costly merge to find the best bottom field doc so\n+        // we just check pick the best bottom document among the available buffer. This\n+        // means that we don't have the true-best bottom but this avoids running a partial\n+        // merge too often.\n+        for (TopFieldDocs topDocs : topDocsList) {\n+            totalHits += topDocs.totalHits.value;\n+            if (topDocs.scoreDocs.length == topDocsSize) {\n+                FieldDoc cand = (FieldDoc) topDocs.scoreDocs[topDocsSize-1];\n+                if (bestBottom == null ||\n+                        fieldComparator.compareValues(cand.fields[0], cand.fields[0]) * reverseMul > 0) {", "originalCommit": "30173b6b6adea46e899b29099f8cc15136739abe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4NjY2OA==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385786668", "bodyText": "Gloups, thanks. I renamed before pushing, this should be correct now.", "author": "jimczi", "createdAt": "2020-02-28T16:16:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4MDAxNQ=="}], "type": "inlineReview"}, {"oid": "2e198658bf44e2245e159d2735c96c1c13cd4bc6", "url": "https://github.com/elastic/elasticsearch/commit/2e198658bf44e2245e159d2735c96c1c13cd4bc6", "message": "fix comparator", "committedDate": "2020-02-28T16:12:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4NTIyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385785221", "bodyText": "It is not clear for me why a default value for totalHits  is -1?", "author": "mayya-sharipova", "createdAt": "2020-02-28T16:13:41Z", "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +89,67 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest buildShardSearchRequestInternal(SearchShardIterator shardIt) {\n+        ShardSearchRequest request = super.buildShardSearchRequest(shardIt);\n+        if (resultConsumer == null) {\n+            return request;\n+        }\n+        List<TopFieldDocs> topDocsList = resultConsumer.getRemainingTopDocs().stream()\n+            .filter(obj -> obj instanceof TopFieldDocs)\n+            .map(obj -> (TopFieldDocs) obj)\n+            .collect(Collectors.toList());\n+        if (topDocsList.isEmpty()) {\n+            return request;\n+        }\n+        SearchSourceBuilder source = request.source();\n+        int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO : source.trackTotalHitsUpTo();\n+        long totalHits = -1;", "originalCommit": "30173b6b6adea46e899b29099f8cc15136739abe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4NjgzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385786831", "bodyText": "It should be 0, thanks. I pushed 8eae737", "author": "jimczi", "createdAt": "2020-02-28T16:16:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4NTIyMQ=="}], "type": "inlineReview"}, {"oid": "8eae737035abbf59b39194d364d68cb7a33d9fae", "url": "https://github.com/elastic/elasticsearch/commit/8eae737035abbf59b39194d364d68cb7a33d9fae", "message": "fix topdocs size", "committedDate": "2020-02-28T16:15:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0MTY5MA==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385841690", "bodyText": "Is there a reason why we pass have pass an array of bottom sort values, but we use only 1st element? Should we pass only the 1st element  \u2013 Object[] rawBottomSortValue?", "author": "mayya-sharipova", "createdAt": "2020-02-28T18:03:44Z", "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "diffHunk": "@@ -351,6 +352,41 @@ public SortFieldAndFormat build(QueryShardContext context) throws IOException {\n         return new SortFieldAndFormat(field, fieldType.docValueFormat(null, null));\n     }\n \n+    public boolean canRewriteToMatchNone() {\n+        return nestedSort == null && (missing == null || \"_last\".equals(missing));\n+    }\n+\n+    /**\n+     * Returns whether all values of the given {@link QueryShardContext#getIndexReader()} are within the\n+     * primary sort value provided in the <code>rawBottomSortValues</code>.\n+     */\n+    public boolean isBottomSortWithinShard(QueryShardContext context, Object[] rawBottomSortValues) {", "originalCommit": "8eae737035abbf59b39194d364d68cb7a33d9fae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ea5727ecd17230c45c7600a4a369b41b8d5f2567", "url": "https://github.com/elastic/elasticsearch/commit/ea5727ecd17230c45c7600a4a369b41b8d5f2567", "message": "Merge branch 'master' into distributed_time_sort", "committedDate": "2020-03-02T11:30:20Z", "type": "commit"}, {"oid": "f50ec90eaf3e66fbdc20c028190c7e20df1cdd8f", "url": "https://github.com/elastic/elasticsearch/commit/f50ec90eaf3e66fbdc20c028190c7e20df1cdd8f", "message": "iter", "committedDate": "2020-03-03T12:22:33Z", "type": "commit"}, {"oid": "ee2591fc62b10f0b353a606bbfc7e3c19b21d624", "url": "https://github.com/elastic/elasticsearch/commit/ee2591fc62b10f0b353a606bbfc7e3c19b21d624", "message": "Merge branch 'master' into distributed_time_sort", "committedDate": "2020-03-03T12:22:56Z", "type": "commit"}, {"oid": "4ec6a6caee3981475f0b8b3bf9da3815d19b2c86", "url": "https://github.com/elastic/elasticsearch/commit/4ec6a6caee3981475f0b8b3bf9da3815d19b2c86", "message": "fix final merge when some shard responses have their size artifically rewrote to 0", "committedDate": "2020-03-03T16:47:43Z", "type": "commit"}, {"oid": "09bfb098a2e21f2e435f6318929e04bda9808eaf", "url": "https://github.com/elastic/elasticsearch/commit/09bfb098a2e21f2e435f6318929e04bda9808eaf", "message": "check style", "committedDate": "2020-03-03T17:07:08Z", "type": "commit"}, {"oid": "5e268c6bf5ba52c844871f1f488a3dcf4a1d74e3", "url": "https://github.com/elastic/elasticsearch/commit/5e268c6bf5ba52c844871f1f488a3dcf4a1d74e3", "message": "return topfielddocs if the shard search request rewrites the size to 0", "committedDate": "2020-03-03T19:44:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcwMzgyMg==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r387703822", "bodyText": "Previously using fieldComparator.compareValues looks to be faster than using TopFieldDocs.merge (as TopFieldDocs.merge doing a lot of stuff that we don't really need),  especially considering that mergeTopDocs is a synchronized function, and we want to be quite fast.", "author": "mayya-sharipova", "createdAt": "2020-03-04T14:32:56Z", "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -85,71 +88,59 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n         progressListener.notifyQueryFailure(shardIndex, exc);\n     }\n \n+    @Override\n+    protected void onShardResult(SearchPhaseResult result, SearchShardIterator shardIt) {\n+        mergeTopDocs(result.queryResult());\n+        super.onShardResult(result, shardIt);\n+    }\n+\n     @Override\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n \n-    ShardSearchRequest buildShardSearchRequestInternal(SearchShardIterator shardIt) {\n-        ShardSearchRequest request = super.buildShardSearchRequest(shardIt);\n-        if (resultConsumer == null) {\n-            return request;\n+    private synchronized void mergeTopDocs(QuerySearchResult result) {\n+        if (result.isNull()\n+                || hasPrimaryFieldSort == false\n+                || result.topDocs().topDocs instanceof TopFieldDocs == false) {\n+            return;\n         }\n-        List<TopFieldDocs> topDocsList = resultConsumer.getRemainingTopDocs().stream()\n-            .filter(obj -> obj instanceof TopFieldDocs)\n-            .map(obj -> (TopFieldDocs) obj)\n-            .collect(Collectors.toList());\n-        if (topDocsList.isEmpty()) {\n-            return request;\n+        // merge the current best bottom field doc with the new query result\n+        TopFieldDocs topDocs = (TopFieldDocs) result.topDocs().topDocs;\n+        final ScoreDoc[] bottomDocs;\n+        if (topDocs.scoreDocs.length == topDocsSize) {\n+            FieldDoc bottom = (FieldDoc) topDocs.scoreDocs[topDocsSize - 1];\n+            bottomDocs = new FieldDoc[] { new FieldDoc(bottom.doc, bottom.score, bottom.fields, result.getShardIndex()) };\n+            bottomDocs[0].shardIndex = result.getShardIndex();\n+        } else {\n+            bottomDocs = new ScoreDoc[0];\n         }\n-        SearchSourceBuilder source = request.source();\n-        int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO : source.trackTotalHitsUpTo();\n-        long totalHits = 0;\n-        FieldDoc bestBottom = null;\n-        SortField primarySort = topDocsList.get(0).fields[0];\n-        FieldComparator fieldComparator = primarySort.getComparator(1, 0);\n-        int reverseMul = primarySort.getReverse() ? -1 : 1;\n-        // we don't want to perform a costly merge to find the best bottom field doc so\n-        // we just check pick the best bottom document among the available buffer. This\n-        // means that we don't have the true-best bottom but this avoids running a partial\n-        // merge too often.\n-        for (TopFieldDocs topDocs : topDocsList) {\n-            totalHits += topDocs.totalHits.value;\n-            if (topDocs.scoreDocs.length == topDocsSize) {\n-                FieldDoc cand = (FieldDoc) topDocs.scoreDocs[topDocsSize-1];\n-                if (bestBottom == null ||\n-                        fieldComparator.compareValues(cand.fields[0], bestBottom.fields[0]) * reverseMul < 0) {\n-                    bestBottom = cand;\n-                }\n-            }\n+        TopFieldDocs toMerge = new TopFieldDocs(topDocs.totalHits, bottomDocs, topDocs.fields);\n+        if (bottomTopDocs == null) {\n+            bottomTopDocs = toMerge;\n+        } else {\n+            final Sort sort = new Sort(bottomTopDocs.fields);\n+            bottomTopDocs = TopFieldDocs.merge(sort, 0, 1, new TopFieldDocs[]{bottomTopDocs, toMerge}, false);", "originalCommit": "f50ec90eaf3e66fbdc20c028190c7e20df1cdd8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b", "url": "https://github.com/elastic/elasticsearch/commit/2307e73ce5c4500609a22c9bbba6162a9028407b", "message": "Merge branch 'master' into distributed_time_sort", "committedDate": "2020-03-06T09:37:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NjI3OA==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r388846278", "bodyText": "I don't think we should ignore errors here, what if this left bottomTopDocs in an inconsistent state?", "author": "jpountz", "createdAt": "2020-03-06T11:13:22Z", "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -49,27 +66,85 @@\n                 executor, request, listener, shardsIts, timeProvider, clusterStateVersion, task,\n                 searchPhaseController.newSearchPhaseResults(task.getProgressListener(), request, shardsIts.size()),\n                 request.getMaxConcurrentShardRequests(), clusters);\n+        this.topDocsSize = getTopDocsSize(request);\n+        this.trackTotalHitsUpTo = request.resolveTrackTotalHitsUpTo();\n+        this.hasPrimaryFieldSort = FieldSortBuilder.hasPrimaryFieldSort(request.source());\n         this.searchPhaseController = searchPhaseController;\n         this.progressListener = task.getProgressListener();\n-        final SearchProgressListener progressListener = task.getProgressListener();\n         final SearchSourceBuilder sourceBuilder = request.source();\n         progressListener.notifyListShards(progressListener.searchShards(this.shardsIts),\n             sourceBuilder == null || sourceBuilder.size() != 0);\n     }\n \n     protected void executePhaseOnShard(final SearchShardIterator shardIt, final ShardRouting shard,\n                                        final SearchActionListener<SearchPhaseResult> listener) {\n+\n+        ShardSearchRequest request = rewriteShardSearchRequest(super.buildShardSearchRequest(shardIt));\n         getSearchTransport().sendExecuteQuery(getConnection(shardIt.getClusterAlias(), shard.currentNodeId()),\n-            buildShardSearchRequest(shardIt), getTask(), listener);\n+            request, getTask(), listener);\n     }\n \n     @Override\n     protected void onShardGroupFailure(int shardIndex, Exception exc) {\n         progressListener.notifyQueryFailure(shardIndex, exc);\n     }\n \n+    @Override\n+    protected void onShardResult(SearchPhaseResult result, SearchShardIterator shardIt) {\n+        try {\n+            QuerySearchResult queryResult = result.queryResult();\n+            if (queryResult.isNull() == false\n+                    && hasPrimaryFieldSort\n+                    && queryResult.topDocs().topDocs instanceof TopFieldDocs) {\n+                mergeTopDocs((TopFieldDocs) result.queryResult().topDocs().topDocs, result.getShardIndex());\n+            }\n+        } catch (Exception exc) {\n+            getLogger().error(\"Failed to merge response\", exc);", "originalCommit": "2307e73ce5c4500609a22c9bbba6162a9028407b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4Mjc1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r389782753", "bodyText": "Agreed, this was a leftover from a debug session ;).", "author": "jimczi", "createdAt": "2020-03-09T15:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NjI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NzIzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r388847231", "bodyText": "is this assertion right? I'm not seeing where we make sure to only call this method on sorted requests.", "author": "jpountz", "createdAt": "2020-03-06T11:15:50Z", "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -49,27 +66,85 @@\n                 executor, request, listener, shardsIts, timeProvider, clusterStateVersion, task,\n                 searchPhaseController.newSearchPhaseResults(task.getProgressListener(), request, shardsIts.size()),\n                 request.getMaxConcurrentShardRequests(), clusters);\n+        this.topDocsSize = getTopDocsSize(request);\n+        this.trackTotalHitsUpTo = request.resolveTrackTotalHitsUpTo();\n+        this.hasPrimaryFieldSort = FieldSortBuilder.hasPrimaryFieldSort(request.source());\n         this.searchPhaseController = searchPhaseController;\n         this.progressListener = task.getProgressListener();\n-        final SearchProgressListener progressListener = task.getProgressListener();\n         final SearchSourceBuilder sourceBuilder = request.source();\n         progressListener.notifyListShards(progressListener.searchShards(this.shardsIts),\n             sourceBuilder == null || sourceBuilder.size() != 0);\n     }\n \n     protected void executePhaseOnShard(final SearchShardIterator shardIt, final ShardRouting shard,\n                                        final SearchActionListener<SearchPhaseResult> listener) {\n+\n+        ShardSearchRequest request = rewriteShardSearchRequest(super.buildShardSearchRequest(shardIt));\n         getSearchTransport().sendExecuteQuery(getConnection(shardIt.getClusterAlias(), shard.currentNodeId()),\n-            buildShardSearchRequest(shardIt), getTask(), listener);\n+            request, getTask(), listener);\n     }\n \n     @Override\n     protected void onShardGroupFailure(int shardIndex, Exception exc) {\n         progressListener.notifyQueryFailure(shardIndex, exc);\n     }\n \n+    @Override\n+    protected void onShardResult(SearchPhaseResult result, SearchShardIterator shardIt) {\n+        try {\n+            QuerySearchResult queryResult = result.queryResult();\n+            if (queryResult.isNull() == false\n+                    && hasPrimaryFieldSort\n+                    && queryResult.topDocs().topDocs instanceof TopFieldDocs) {\n+                mergeTopDocs((TopFieldDocs) result.queryResult().topDocs().topDocs, result.getShardIndex());\n+            }\n+        } catch (Exception exc) {\n+            getLogger().error(\"Failed to merge response\", exc);\n+        }\n+        super.onShardResult(result, shardIt);\n+    }\n+\n     @Override\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    // merge the current best bottom field doc with the new query result\n+    private synchronized void mergeTopDocs(TopFieldDocs topDocs, int shardIndex) {\n+        final ScoreDoc[] bottomDocs;\n+        if (topDocs.scoreDocs.length == topDocsSize) {\n+            FieldDoc bottom = (FieldDoc) topDocs.scoreDocs[topDocsSize - 1];\n+            bottomDocs = new FieldDoc[] { new FieldDoc(bottom.doc, bottom.score, bottom.fields, shardIndex) };\n+        } else {\n+            bottomDocs = new ScoreDoc[0];\n+        }\n+        TopFieldDocs toMerge = new TopFieldDocs(topDocs.totalHits, bottomDocs, topDocs.fields);\n+        if (bottomTopDocs == null) {\n+            bottomTopDocs = toMerge;\n+        } else {\n+            final Sort sort = new Sort(bottomTopDocs.fields);\n+            bottomTopDocs = TopFieldDocs.merge(sort, 0, 1, new TopFieldDocs[]{ bottomTopDocs, toMerge }, false);\n+        }\n+    }\n+\n+    ShardSearchRequest rewriteShardSearchRequest(ShardSearchRequest request) {\n+        final TopFieldDocs current = bottomTopDocs;\n+        if (current == null) {\n+            return request;\n+        }\n+\n+        // disable tracking total hits if we already reached the required estimation.\n+        if (trackTotalHitsUpTo != SearchContext.TRACK_TOTAL_HITS_ACCURATE\n+                && current.totalHits.value >= trackTotalHitsUpTo\n+                && current.totalHits.relation == GREATER_THAN_OR_EQUAL_TO) {\n+            assert request.source() != null : \"source should contain a primary sort field\";", "originalCommit": "2307e73ce5c4500609a22c9bbba6162a9028407b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0Nzg0OA==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r388847848", "bodyText": "maybe rename to currentBottomTopDocs to make the below logic easier to read?", "author": "jpountz", "createdAt": "2020-03-06T11:17:24Z", "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -49,27 +66,85 @@\n                 executor, request, listener, shardsIts, timeProvider, clusterStateVersion, task,\n                 searchPhaseController.newSearchPhaseResults(task.getProgressListener(), request, shardsIts.size()),\n                 request.getMaxConcurrentShardRequests(), clusters);\n+        this.topDocsSize = getTopDocsSize(request);\n+        this.trackTotalHitsUpTo = request.resolveTrackTotalHitsUpTo();\n+        this.hasPrimaryFieldSort = FieldSortBuilder.hasPrimaryFieldSort(request.source());\n         this.searchPhaseController = searchPhaseController;\n         this.progressListener = task.getProgressListener();\n-        final SearchProgressListener progressListener = task.getProgressListener();\n         final SearchSourceBuilder sourceBuilder = request.source();\n         progressListener.notifyListShards(progressListener.searchShards(this.shardsIts),\n             sourceBuilder == null || sourceBuilder.size() != 0);\n     }\n \n     protected void executePhaseOnShard(final SearchShardIterator shardIt, final ShardRouting shard,\n                                        final SearchActionListener<SearchPhaseResult> listener) {\n+\n+        ShardSearchRequest request = rewriteShardSearchRequest(super.buildShardSearchRequest(shardIt));\n         getSearchTransport().sendExecuteQuery(getConnection(shardIt.getClusterAlias(), shard.currentNodeId()),\n-            buildShardSearchRequest(shardIt), getTask(), listener);\n+            request, getTask(), listener);\n     }\n \n     @Override\n     protected void onShardGroupFailure(int shardIndex, Exception exc) {\n         progressListener.notifyQueryFailure(shardIndex, exc);\n     }\n \n+    @Override\n+    protected void onShardResult(SearchPhaseResult result, SearchShardIterator shardIt) {\n+        try {\n+            QuerySearchResult queryResult = result.queryResult();\n+            if (queryResult.isNull() == false\n+                    && hasPrimaryFieldSort\n+                    && queryResult.topDocs().topDocs instanceof TopFieldDocs) {\n+                mergeTopDocs((TopFieldDocs) result.queryResult().topDocs().topDocs, result.getShardIndex());\n+            }\n+        } catch (Exception exc) {\n+            getLogger().error(\"Failed to merge response\", exc);\n+        }\n+        super.onShardResult(result, shardIt);\n+    }\n+\n     @Override\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    // merge the current best bottom field doc with the new query result\n+    private synchronized void mergeTopDocs(TopFieldDocs topDocs, int shardIndex) {\n+        final ScoreDoc[] bottomDocs;\n+        if (topDocs.scoreDocs.length == topDocsSize) {\n+            FieldDoc bottom = (FieldDoc) topDocs.scoreDocs[topDocsSize - 1];\n+            bottomDocs = new FieldDoc[] { new FieldDoc(bottom.doc, bottom.score, bottom.fields, shardIndex) };\n+        } else {\n+            bottomDocs = new ScoreDoc[0];\n+        }\n+        TopFieldDocs toMerge = new TopFieldDocs(topDocs.totalHits, bottomDocs, topDocs.fields);\n+        if (bottomTopDocs == null) {\n+            bottomTopDocs = toMerge;\n+        } else {\n+            final Sort sort = new Sort(bottomTopDocs.fields);\n+            bottomTopDocs = TopFieldDocs.merge(sort, 0, 1, new TopFieldDocs[]{ bottomTopDocs, toMerge }, false);\n+        }\n+    }\n+\n+    ShardSearchRequest rewriteShardSearchRequest(ShardSearchRequest request) {\n+        final TopFieldDocs current = bottomTopDocs;", "originalCommit": "2307e73ce5c4500609a22c9bbba6162a9028407b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg1Mjg3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r388852876", "bodyText": "rawBottomSortValues stores the implementation-specific values while isFieldWithinQuery expects high-level representations of the values. For instance, I believe that this implementation as-is is incorrect for date_nanos, which would return a number of nanos since Epoch in rawBottomSortValues and then parse a number of millis in isFieldWithinQuery. So we should call DocValueFormat#format on the min/max values before passing them to isFieldWithinQuery.", "author": "jpountz", "createdAt": "2020-03-06T11:29:30Z", "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "diffHunk": "@@ -351,6 +352,41 @@ public SortFieldAndFormat build(QueryShardContext context) throws IOException {\n         return new SortFieldAndFormat(field, fieldType.docValueFormat(null, null));\n     }\n \n+    public boolean canRewriteToMatchNone() {\n+        return nestedSort == null && (missing == null || \"_last\".equals(missing));\n+    }\n+\n+    /**\n+     * Returns whether some values of the given {@link QueryShardContext#getIndexReader()} are within the\n+     * primary sort value provided in the <code>rawBottomSortValues</code>.\n+     */\n+    public boolean isBottomSortShardDisjoint(QueryShardContext context, Object[] rawBottomSortValues) {\n+        if (rawBottomSortValues == null || rawBottomSortValues.length == 0) {\n+            return false;\n+        }\n+\n+        if (canRewriteToMatchNone() == false) {\n+            return false;\n+        }\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType == null) {\n+            // unmapped\n+            return false;\n+        }\n+        if (fieldType.indexOptions() == IndexOptions.NONE) {\n+            return false;\n+        }\n+        Object minValue = order() == SortOrder.DESC ? rawBottomSortValues[0] : null;\n+        Object maxValue = order() == SortOrder.DESC ? null : rawBottomSortValues[0];\n+        try {\n+            MappedFieldType.Relation relation = fieldType.isFieldWithinQuery(context.getIndexReader(), minValue, maxValue,\n+                true, true, null, DEFAULT_DATE_TIME_FORMATTER.toDateMathParser(), context);", "originalCommit": "2307e73ce5c4500609a22c9bbba6162a9028407b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NDM0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r389784345", "bodyText": "Good catch, I pushed a change to handle this correctly. I had to pass the original docvalues format in the shard search request in order to use the correct date math parser.", "author": "jimczi", "createdAt": "2020-03-09T15:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg1Mjg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg1MzExMw==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r388853113", "bodyText": "I don't like silently ignoring exceptions here, can we narrow down the exception type or remove the catch block entirely? I worry that this might hide bugs.", "author": "jpountz", "createdAt": "2020-03-06T11:30:09Z", "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "diffHunk": "@@ -351,6 +352,41 @@ public SortFieldAndFormat build(QueryShardContext context) throws IOException {\n         return new SortFieldAndFormat(field, fieldType.docValueFormat(null, null));\n     }\n \n+    public boolean canRewriteToMatchNone() {\n+        return nestedSort == null && (missing == null || \"_last\".equals(missing));\n+    }\n+\n+    /**\n+     * Returns whether some values of the given {@link QueryShardContext#getIndexReader()} are within the\n+     * primary sort value provided in the <code>rawBottomSortValues</code>.\n+     */\n+    public boolean isBottomSortShardDisjoint(QueryShardContext context, Object[] rawBottomSortValues) {\n+        if (rawBottomSortValues == null || rawBottomSortValues.length == 0) {\n+            return false;\n+        }\n+\n+        if (canRewriteToMatchNone() == false) {\n+            return false;\n+        }\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType == null) {\n+            // unmapped\n+            return false;\n+        }\n+        if (fieldType.indexOptions() == IndexOptions.NONE) {\n+            return false;\n+        }\n+        Object minValue = order() == SortOrder.DESC ? rawBottomSortValues[0] : null;\n+        Object maxValue = order() == SortOrder.DESC ? null : rawBottomSortValues[0];\n+        try {\n+            MappedFieldType.Relation relation = fieldType.isFieldWithinQuery(context.getIndexReader(), minValue, maxValue,\n+                true, true, null, DEFAULT_DATE_TIME_FORMATTER.toDateMathParser(), context);\n+            return relation == MappedFieldType.Relation.DISJOINT;\n+        } catch (Exception exc) {\n+            return false;", "originalCommit": "2307e73ce5c4500609a22c9bbba6162a9028407b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NTA3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r389785071", "bodyText": "++, this should not be needed with the new logic that send the original date math parser. I removed it.", "author": "jimczi", "createdAt": "2020-03-09T15:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg1MzExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg1MzM4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r388853381", "bodyText": "why do we need both?", "author": "jpountz", "createdAt": "2020-03-06T11:30:55Z", "path": "server/src/main/java/org/elasticsearch/common/lucene/Lucene.java", "diffHunk": "@@ -111,6 +111,7 @@\n     public static final NamedAnalyzer KEYWORD_ANALYZER = new NamedAnalyzer(\"_keyword\", AnalyzerScope.GLOBAL, new KeywordAnalyzer());\n \n     public static final ScoreDoc[] EMPTY_SCORE_DOCS = new ScoreDoc[0];\n+    public static final ScoreDoc[] EMPTY_FIELD_DOCS = new ScoreDoc[0];", "originalCommit": "2307e73ce5c4500609a22c9bbba6162a9028407b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NTMxMw==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r389785313", "bodyText": "we don't, I removed it.", "author": "jimczi", "createdAt": "2020-03-09T15:55:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg1MzM4MQ=="}], "type": "inlineReview"}, {"oid": "ae1b2789bbc509e17c4b99b32d1a2bbb59eac6f0", "url": "https://github.com/elastic/elasticsearch/commit/ae1b2789bbc509e17c4b99b32d1a2bbb59eac6f0", "message": "Replace raw sort values with formatted ones to handle date and date_nanos correctly", "committedDate": "2020-03-09T15:50:03Z", "type": "commit"}, {"oid": "bfd2c7253c2996c08d250b550800370dc9971348", "url": "https://github.com/elastic/elasticsearch/commit/bfd2c7253c2996c08d250b550800370dc9971348", "message": "Merge branch 'master' into distributed_time_sort", "committedDate": "2020-03-09T19:27:09Z", "type": "commit"}, {"oid": "6489ffeefff1e0ceb43be2e2a16384b1a96567ed", "url": "https://github.com/elastic/elasticsearch/commit/6489ffeefff1e0ceb43be2e2a16384b1a96567ed", "message": "fix unset of track total hits in distributed search", "committedDate": "2020-03-09T19:43:08Z", "type": "commit"}, {"oid": "73aa68159154be7d8da13f34e15d8a4c51c9ec60", "url": "https://github.com/elastic/elasticsearch/commit/73aa68159154be7d8da13f34e15d8a4c51c9ec60", "message": "fix compilation test after merging with master", "committedDate": "2020-03-10T00:07:34Z", "type": "commit"}, {"oid": "b2504e6afb995ebaa428f3d3ebf60b6096b5b241", "url": "https://github.com/elastic/elasticsearch/commit/b2504e6afb995ebaa428f3d3ebf60b6096b5b241", "message": "Merge branch 'master' into distributed_time_sort", "committedDate": "2020-03-10T07:49:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0NzY3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r390147679", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            this.formattedSortValues[i] = sortValue;\n          \n          \n            \n                            assert sortValue == null : \"Sort values must be a BytesRef, Long or Double, but got \" + sortValue.getClass() + \": \" + sortValue;\n          \n          \n            \n                            this.formattedSortValues[i] = sortValue;", "author": "jpountz", "createdAt": "2020-03-10T08:12:05Z", "path": "server/src/main/java/org/elasticsearch/search/SearchSortValuesAndFormats.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search;\n+\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.lucene.Lucene;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class SearchSortValuesAndFormats implements Writeable {\n+    private final Object[] rawSortValues;\n+    private final Object[] formattedSortValues;\n+    private final DocValueFormat[] sortValueFormats;\n+\n+    public SearchSortValuesAndFormats(Object[] rawSortValues, DocValueFormat[] sortValueFormats) {\n+        assert rawSortValues.length == sortValueFormats.length;\n+        this.rawSortValues = rawSortValues;\n+        this.sortValueFormats = sortValueFormats;\n+        this.formattedSortValues = Arrays.copyOf(rawSortValues, rawSortValues.length);\n+        for (int i = 0; i < rawSortValues.length; ++i) {\n+            Object sortValue = rawSortValues[i];\n+            if (sortValue instanceof BytesRef) {\n+                this.formattedSortValues[i] = sortValueFormats[i].format((BytesRef) sortValue);\n+            } else if (sortValue instanceof Long) {\n+                this.formattedSortValues[i] = sortValueFormats[i].format((long) sortValue);\n+            } else if (sortValue instanceof Double) {\n+                this.formattedSortValues[i] = sortValueFormats[i].format((double) sortValue);\n+            } else {\n+                this.formattedSortValues[i] = sortValue;", "originalCommit": "b2504e6afb995ebaa428f3d3ebf60b6096b5b241", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE1NDc3OA==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r390154778", "bodyText": "is my understanding correct that we need this for the case when a shard is mapped as a date_nanos field while other fields are mapped as date fields?", "author": "jpountz", "createdAt": "2020-03-10T08:28:21Z", "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "diffHunk": "@@ -351,6 +353,49 @@ public SortFieldAndFormat build(QueryShardContext context) throws IOException {\n         return new SortFieldAndFormat(field, fieldType.docValueFormat(null, null));\n     }\n \n+    public boolean canRewriteToMatchNone() {\n+        return nestedSort == null && (missing == null || \"_last\".equals(missing));\n+    }\n+\n+    /**\n+     * Returns whether some values of the given {@link QueryShardContext#getIndexReader()} are within the\n+     * primary sort value provided in the <code>bottomSortValues</code>.\n+     */\n+    public boolean isBottomSortShardDisjoint(QueryShardContext context, SearchSortValuesAndFormats bottomSortValues) throws IOException {\n+        if (bottomSortValues == null || bottomSortValues.getRawSortValues().length == 0) {\n+            return false;\n+        }\n+\n+        if (canRewriteToMatchNone() == false) {\n+            return false;\n+        }\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType == null) {\n+            // unmapped\n+            return false;\n+        }\n+        if (fieldType.indexOptions() == IndexOptions.NONE) {\n+            return false;\n+        }\n+        DocValueFormat docValueFormat = bottomSortValues.getSortValueFormats()[0];\n+        final DateMathParser dateMathParser;\n+        if (docValueFormat instanceof DocValueFormat.DateTime) {\n+            if (fieldType instanceof DateFieldType && ((DateFieldType) fieldType).resolution() == NANOSECONDS) {\n+                // no matter what\n+                docValueFormat = DocValueFormat.withNanosecondResolution(docValueFormat);", "originalCommit": "b2504e6afb995ebaa428f3d3ebf60b6096b5b241", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE1OTc2OA==", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r390159768", "bodyText": "correct, I fixed the comment ;)", "author": "jimczi", "createdAt": "2020-03-10T08:39:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE1NDc3OA=="}], "type": "inlineReview"}, {"oid": "36bec996a78aa340dc7686cbdd0f8af3d57c4263", "url": "https://github.com/elastic/elasticsearch/commit/36bec996a78aa340dc7686cbdd0f8af3d57c4263", "message": "fix partial comment", "committedDate": "2020-03-10T09:48:12Z", "type": "commit"}, {"oid": "74b8bea6e39f2be287e361e0ae6c87f3b5980395", "url": "https://github.com/elastic/elasticsearch/commit/74b8bea6e39f2be287e361e0ae6c87f3b5980395", "message": "Merge branch 'master' into distributed_time_sort", "committedDate": "2020-03-11T12:07:31Z", "type": "commit"}, {"oid": "7a5422282569cd68acbf04268939247e765513d3", "url": "https://github.com/elastic/elasticsearch/commit/7a5422282569cd68acbf04268939247e765513d3", "message": "iter", "committedDate": "2020-03-11T14:00:18Z", "type": "commit"}, {"oid": "abda5305ee9602bb9a4c3b9c733c57b41b2fb268", "url": "https://github.com/elastic/elasticsearch/commit/abda5305ee9602bb9a4c3b9c733c57b41b2fb268", "message": "Add stricter assertions\n\nCo-Authored-By: Adrien Grand <jpountz@gmail.com>", "committedDate": "2020-03-13T11:22:48Z", "type": "commit"}, {"oid": "06cbc1981b63cca2b8ab23001f0e14523fd21c51", "url": "https://github.com/elastic/elasticsearch/commit/06cbc1981b63cca2b8ab23001f0e14523fd21c51", "message": "checkstyle", "committedDate": "2020-03-13T11:37:45Z", "type": "commit"}, {"oid": "74c5d993d0298abc9f214ebb275045a4cd3f461f", "url": "https://github.com/elastic/elasticsearch/commit/74c5d993d0298abc9f214ebb275045a4cd3f461f", "message": "Merge branch 'master' into distributed_time_sort", "committedDate": "2020-03-13T11:38:12Z", "type": "commit"}, {"oid": "e526147b9a4ff2456d8e0cb24b5e6e06a72accd0", "url": "https://github.com/elastic/elasticsearch/commit/e526147b9a4ff2456d8e0cb24b5e6e06a72accd0", "message": "Merge branch 'master' into distributed_time_sort", "committedDate": "2020-03-13T13:51:05Z", "type": "commit"}, {"oid": "14542f00db2cca904381678a3a26a20ee77e229b", "url": "https://github.com/elastic/elasticsearch/commit/14542f00db2cca904381678a3a26a20ee77e229b", "message": "sort values can be integers and floats (_doc and _score)", "committedDate": "2020-03-16T08:26:14Z", "type": "commit"}, {"oid": "8ad41c26ecd936a74229795cc9edbff17f6057ab", "url": "https://github.com/elastic/elasticsearch/commit/8ad41c26ecd936a74229795cc9edbff17f6057ab", "message": "fix test to handle accepted raw sort format", "committedDate": "2020-03-16T11:07:29Z", "type": "commit"}, {"oid": "270533c93ed2d9265208acceb37abc96ffe398d0", "url": "https://github.com/elastic/elasticsearch/commit/270533c93ed2d9265208acceb37abc96ffe398d0", "message": "Merge branch 'master' into distributed_time_sort", "committedDate": "2020-03-17T08:16:50Z", "type": "commit"}, {"oid": "e4e8b0224b70f1423f156b3081de5d5491b4b43a", "url": "https://github.com/elastic/elasticsearch/commit/e4e8b0224b70f1423f156b3081de5d5491b4b43a", "message": "fix compil after master merge", "committedDate": "2020-03-17T08:38:43Z", "type": "commit"}]}