{"pr_number": 63226, "pr_title": "Do not block Translog add on file write", "pr_createdAt": "2020-10-05T04:34:31Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/63226", "timeline": [{"oid": "5ffdcd0a4c7487b29460da77ffcee38f21c8dac3", "url": "https://github.com/elastic/elasticsearch/commit/5ffdcd0a4c7487b29460da77ffcee38f21c8dac3", "message": "Changes", "committedDate": "2020-10-03T00:02:30Z", "type": "commit"}, {"oid": "76f9264b272d8bafa36332c80498fff40255c079", "url": "https://github.com/elastic/elasticsearch/commit/76f9264b272d8bafa36332c80498fff40255c079", "message": "Merge remote-tracking branch 'upstream/master' into fix_flush_seq_no_issue", "committedDate": "2020-10-05T03:53:59Z", "type": "commit"}, {"oid": "a9ce40edc7f44851efffc777927244d05355e537", "url": "https://github.com/elastic/elasticsearch/commit/a9ce40edc7f44851efffc777927244d05355e537", "message": "Revert \"Revert \"Do not block Translog add on file write (#62513)\"\"\n\nThis reverts commit 59a365d7034f0ec4e126ab2c03420164804b417e.", "committedDate": "2020-10-05T03:58:25Z", "type": "commit"}, {"oid": "62b429d3254b324e559e539aee44c76de62abf4d", "url": "https://github.com/elastic/elasticsearch/commit/62b429d3254b324e559e539aee44c76de62abf4d", "message": "Changes", "committedDate": "2020-10-05T04:32:46Z", "type": "commit"}, {"oid": "af27c3fcbbc8f1661e99cf07e2761d8dcf2c37a4", "url": "https://github.com/elastic/elasticsearch/commit/af27c3fcbbc8f1661e99cf07e2761d8dcf2c37a4", "message": "Merge remote-tracking branch 'upstream/master' into fix_flush_seq_no_issue", "committedDate": "2020-10-05T04:33:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3Mjg0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/63226#discussion_r499372841", "bodyText": "nit: the ordering of fields is a bit odd, I would prefer this went either before or after the buffer related fields.", "author": "henningandersen", "createdAt": "2020-10-05T06:42:44Z", "path": "server/src/main/java/org/elasticsearch/index/translog/TranslogWriter.java", "diffHunk": "@@ -72,10 +80,15 @@\n     private final LongConsumer persistedSequenceNumberConsumer;\n \n     protected final AtomicBoolean closed = new AtomicBoolean(false);\n-    // lock order synchronized(syncLock) -> synchronized(this)\n+    // lock order try(Releasable lock = writeLock.acquire()) -> synchronized(this)\n+    private final ReleasableLock writeLock = new ReleasableLock(new ReentrantLock());\n+    // lock order synchronized(syncLock) -> try(Releasable lock = writeLock.acquire()) -> synchronized(this)\n     private final Object syncLock = new Object();\n \n-    private LongArrayList nonFsyncedSequenceNumbers;\n+    private final int forceWriteThreshold;\n+    private final ArrayList<ReleasableBytesReference> bufferedOps = new ArrayList<>();\n+    private LongArrayList nonFsyncedSequenceNumbers = new LongArrayList(64);", "originalCommit": "af27c3fcbbc8f1661e99cf07e2761d8dcf2c37a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM4NTQwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/63226#discussion_r499385405", "bodyText": "Would be good to also include testing that the readBytes path works, for instance by randomly choosing to do readBytes here instead.", "author": "henningandersen", "createdAt": "2020-10-05T07:14:46Z", "path": "server/src/test/java/org/elasticsearch/index/translog/TranslogTests.java", "diffHunk": "@@ -1315,15 +1315,185 @@ public void testTranslogWriter() throws IOException {\n         IOUtils.close(writer);\n     }\n \n+    public void testTranslogWriterFlushesOnWriteWhenBufferFull() throws IOException {\n+        Path tempDir = createTempDir();\n+        final TranslogConfig temp = getTranslogConfig(tempDir);\n+        final TranslogConfig config = new TranslogConfig(temp.getShardId(), temp.getTranslogPath(), temp.getIndexSettings(),\n+            temp.getBigArrays(), new ByteSizeValue(1, ByteSizeUnit.KB));\n+\n+        final Set<Long> persistedSeqNos = new HashSet<>();\n+        final AtomicInteger writeCalls = new AtomicInteger();\n+\n+        final ChannelFactory channelFactory = (file, openOption) -> {\n+            FileChannel delegate = FileChannel.open(file, openOption);\n+            boolean success = false;\n+            try {\n+                // don't do partial writes for checkpoints we rely on the fact that the bytes are written as an atomic operation\n+                final boolean isCkpFile = file.getFileName().toString().endsWith(\".ckp\");\n+\n+                final FileChannel channel;\n+                if (isCkpFile) {\n+                    channel = delegate;\n+                } else {\n+                    channel = new FilterFileChannel(delegate) {\n+\n+                        @Override\n+                        public int write(ByteBuffer src) throws IOException {\n+                            writeCalls.incrementAndGet();\n+                            return super.write(src);\n+                        }\n+                    };\n+                }\n+                success = true;\n+                return channel;\n+            } finally {\n+                if (success == false) {\n+                    IOUtils.closeWhileHandlingException(delegate);\n+                }\n+            }\n+        };\n+\n+        String translogUUID = Translog.createEmptyTranslog(\n+            config.getTranslogPath(), SequenceNumbers.NO_OPS_PERFORMED, shardId, channelFactory, primaryTerm.get());\n+\n+        try (Translog translog = new Translog(config, translogUUID, new TranslogDeletionPolicy(),\n+            () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, persistedSeqNos::add) {\n+            @Override\n+            ChannelFactory getChannelFactory() {\n+                return channelFactory;\n+            }\n+        }) {\n+            try (TranslogWriter writer = translog.createWriter(translog.currentFileGeneration() + 1)) {\n+                int initialWriteCalls = writeCalls.get();\n+                byte[] bytes = new byte[256];\n+                writer.add(ReleasableBytesReference.wrap(new BytesArray(bytes)), 1);\n+                writer.add(ReleasableBytesReference.wrap(new BytesArray(bytes)), 2);\n+                writer.add(ReleasableBytesReference.wrap(new BytesArray(bytes)), 3);\n+                assertThat(persistedSeqNos, empty());\n+                assertEquals(initialWriteCalls, writeCalls.get());\n+\n+                // This will fill the buffer and force a flush\n+                writer.add(ReleasableBytesReference.wrap(new BytesArray(bytes)), 4);", "originalCommit": "af27c3fcbbc8f1661e99cf07e2761d8dcf2c37a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d0fbe88e9f276407b2dfd6c059cdba9044b3aef5", "url": "https://github.com/elastic/elasticsearch/commit/d0fbe88e9f276407b2dfd6c059cdba9044b3aef5", "message": "Vhanges", "committedDate": "2020-10-05T15:49:28Z", "type": "commit"}, {"oid": "7fc3be10cb141fa3e1ae4a07c1944d96ef7fcfda", "url": "https://github.com/elastic/elasticsearch/commit/7fc3be10cb141fa3e1ae4a07c1944d96ef7fcfda", "message": "Merge remote-tracking branch 'upstream/master' into fix_flush_seq_no_issue", "committedDate": "2020-10-05T15:57:15Z", "type": "commit"}]}