{"pr_number": 50805, "pr_title": "Make cluster state writer resilient to disk issues", "pr_createdAt": "2020-01-09T16:36:39Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/50805", "timeline": [{"oid": "75ec3eebdc492d3e43e86fd4c194d3287d64c017", "url": "https://github.com/elastic/elasticsearch/commit/75ec3eebdc492d3e43e86fd4c194d3287d64c017", "message": "Make cluster state writer resilient to disk issues", "committedDate": "2020-01-09T16:33:01Z", "type": "commit"}, {"oid": "1c7eb4c7dc61c3bfc41e111b4d9c5313c43a3e5c", "url": "https://github.com/elastic/elasticsearch/commit/1c7eb4c7dc61c3bfc41e111b4d9c5313c43a3e5c", "message": "checkstyle", "committedDate": "2020-01-09T17:00:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3NDkwMA==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365174900", "bodyText": "Suggest suppressing exceptions while closing so we get to see the original exception too:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            writer.close();\n          \n          \n            \n                            IOUtils.close(e, writer);", "author": "DaveCTurner", "createdAt": "2020-01-10T10:44:33Z", "path": "server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java", "diffHunk": "@@ -406,7 +412,14 @@ boolean allPendingAsyncStatesWritten() {\n             // In the common case it's actually sufficient to commit() the existing state and not do any indexing. For instance,\n             // this is true if there's only one data path on this master node, and the commit we just loaded was already written out\n             // by this version of Elasticsearch. TODO TBD should we avoid indexing when possible?\n-            persistenceWriter.writeFullStateAndCommit(currentTerm, lastAcceptedState);\n+            final PersistedClusterStateService.Writer writer = persistedClusterStateService.createWriter();\n+            try {\n+                writer.writeFullStateAndCommit(currentTerm, lastAcceptedState);\n+            } catch (Exception e) {\n+                writer.close();", "originalCommit": "1c7eb4c7dc61c3bfc41e111b4d9c5313c43a3e5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI0NTAzMA==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365245030", "bodyText": "I've added the  inner exception as suppressed now in 333f42a", "author": "ywelsch", "createdAt": "2020-01-10T13:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3NDkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3NjEyMw==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365176123", "bodyText": "This is subsumed by the previous suggestion.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            throw e;", "author": "DaveCTurner", "createdAt": "2020-01-10T10:47:33Z", "path": "server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java", "diffHunk": "@@ -406,7 +412,14 @@ boolean allPendingAsyncStatesWritten() {\n             // In the common case it's actually sufficient to commit() the existing state and not do any indexing. For instance,\n             // this is true if there's only one data path on this master node, and the commit we just loaded was already written out\n             // by this version of Elasticsearch. TODO TBD should we avoid indexing when possible?\n-            persistenceWriter.writeFullStateAndCommit(currentTerm, lastAcceptedState);\n+            final PersistedClusterStateService.Writer writer = persistedClusterStateService.createWriter();\n+            try {\n+                writer.writeFullStateAndCommit(currentTerm, lastAcceptedState);\n+            } catch (Exception e) {\n+                writer.close();\n+                throw e;", "originalCommit": "1c7eb4c7dc61c3bfc41e111b4d9c5313c43a3e5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4MzI0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365183242", "bodyText": "I suggest combining this with getWriterSafe(), because in all cases we call reloadWriterIfNecessary() followed (essentially) immediately by getWriterSafe(). Why not return the writer from this method instead?", "author": "DaveCTurner", "createdAt": "2020-01-10T11:05:30Z", "path": "server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java", "diffHunk": "@@ -419,34 +432,77 @@ public ClusterState getLastAcceptedState() {\n             return lastAcceptedState;\n         }\n \n+        private PersistedClusterStateService.Writer getWriterSafe() {\n+            PersistedClusterStateService.Writer writer = persistenceWriter.get();\n+            if (writer == null) {\n+                throw new AlreadyClosedException(\"persisted state has been closed\");\n+            }\n+            return writer;\n+        }\n+\n         @Override\n         public void setCurrentTerm(long currentTerm) {\n-            persistenceWriter.commit(currentTerm, lastAcceptedState.version());\n+            reloadWriterIfNecessary();\n+            try {\n+                if (writeNextStateFully) {\n+                    getWriterSafe().writeFullStateAndCommit(currentTerm, lastAcceptedState);\n+                    writeNextStateFully = false;\n+                } else {\n+                    getWriterSafe().commit(currentTerm, lastAcceptedState.version());\n+                }\n+            } catch (Exception e) {\n+                handleExceptionOnWrite(e);\n+            }\n             this.currentTerm = currentTerm;\n         }\n \n         @Override\n         public void setLastAcceptedState(ClusterState clusterState) {\n+            reloadWriterIfNecessary();\n             try {\n-                if (clusterState.term() != lastAcceptedState.term()) {\n-                    assert clusterState.term() > lastAcceptedState.term() : clusterState.term() + \" vs \" + lastAcceptedState.term();\n-                    // In a new currentTerm, we cannot compare the persisted metadata's lastAcceptedVersion to those in the new state, so\n-                    // it's simplest to write everything again.\n-                    persistenceWriter.writeFullStateAndCommit(currentTerm, clusterState);\n+                if (writeNextStateFully) {\n+                    getWriterSafe().writeFullStateAndCommit(currentTerm, clusterState);\n+                    writeNextStateFully = false;\n                 } else {\n-                    // Within the same currentTerm, we _can_ use metadata versions to skip unnecessary writing.\n-                    persistenceWriter.writeIncrementalStateAndCommit(currentTerm, lastAcceptedState, clusterState);\n+                    if (clusterState.term() != lastAcceptedState.term()) {\n+                        assert clusterState.term() > lastAcceptedState.term() : clusterState.term() + \" vs \" + lastAcceptedState.term();\n+                        // In a new currentTerm, we cannot compare the persisted metadata's lastAcceptedVersion to those in the new state,\n+                        // so it's simplest to write everything again.\n+                        getWriterSafe().writeFullStateAndCommit(currentTerm, clusterState);\n+                    } else {\n+                        // Within the same currentTerm, we _can_ use metadata versions to skip unnecessary writing.\n+                        getWriterSafe().writeIncrementalStateAndCommit(currentTerm, lastAcceptedState, clusterState);\n+                    }\n                 }\n-            } catch (IOException e) {\n-                throw new UncheckedIOException(e);\n+            } catch (Exception e) {\n+                handleExceptionOnWrite(e);\n             }\n \n             lastAcceptedState = clusterState;\n         }\n \n+        private void reloadWriterIfNecessary() {", "originalCommit": "1c7eb4c7dc61c3bfc41e111b4d9c5313c43a3e5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI0NDkxNA==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365244914", "bodyText": "good idea, done in 333f42a", "author": "ywelsch", "createdAt": "2020-01-10T13:57:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4MzI0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4NTk3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365185977", "bodyText": "Continuing here seems risky -- at least, it's outside what we have modelled for correctness. If we successfully write the data to disk then fail (e.g. unrelated fsync failure) then continue then we will treat that as if we didn't update the last-accepted state and maybe emit some further messages based on that older state, but a reboot will pick up the newer state.", "author": "DaveCTurner", "createdAt": "2020-01-10T11:13:10Z", "path": "server/src/main/java/org/elasticsearch/gateway/PersistedClusterStateService.java", "diffHunk": "@@ -634,23 +667,23 @@ private void addMetaData(MetaData metaData) throws IOException {\n             }\n         }\n \n-        public void commit(long currentTerm, long lastAcceptedVersion) {\n+        public void commit(long currentTerm, long lastAcceptedVersion) throws IOException {\n+            ensureOpen();\n             try {\n                 for (MetaDataIndexWriter metaDataIndexWriter : metaDataIndexWriters) {\n                     metaDataIndexWriter.commit(nodeId, currentTerm, lastAcceptedVersion);\n                 }\n-            } catch (IOException e) {\n-                // The commit() call has similar semantics to a fsync(): although it's atomic, if it fails then we've no idea whether the\n-                // data on disk is now the old version or the new version, and this is a disaster. It's safest to fail the whole node and\n-                // retry from the beginning.\n-                throw new IOError(e);\n+            } finally {\n+                closeIfAnyIndexWriterHasTragedyOrIsClosed();", "originalCommit": "1c7eb4c7dc61c3bfc41e111b4d9c5313c43a3e5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE5NzQ1OA==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365197458", "bodyText": "We may be able to add some resilience by calling IndexWriter#prepareCommit() and handling an exception from that gracefully, since an exception while preparing the commit doesn't deviate from the model.", "author": "DaveCTurner", "createdAt": "2020-01-10T11:45:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4NTk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI0MTAxOA==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365241018", "bodyText": "What do you think about alternatively failing calls to the getters (i.e. getCurrentTerm and getLastAcceptedClusterState) and reloading the writer and forcing the cluster state to disk again if certain amount of time elapsed?", "author": "ywelsch", "createdAt": "2020-01-10T13:48:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4NTk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI0NjI3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365246273", "bodyText": "IMO this is excessively heroic. A failure in commit() indicates something very fundamentally wrong with the node and I think dying is the right thing to do. Note that this is pretty much our behaviour today (since 7.0) and I haven't heard of a single case of this actually happening.", "author": "DaveCTurner", "createdAt": "2020-01-10T14:00:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4NTk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI2NDMxNg==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365264316", "bodyText": "ok, I've pushed 7082947", "author": "ywelsch", "createdAt": "2020-01-10T14:39:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4NTk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4ODgyMw==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365188823", "bodyText": "I'm surprised we need to check for a tragic exception ourselves here, since the IndexWriter checks this already. Can you clarify?", "author": "DaveCTurner", "createdAt": "2020-01-10T11:21:27Z", "path": "server/src/main/java/org/elasticsearch/gateway/PersistedClusterStateService.java", "diffHunk": "@@ -520,30 +521,62 @@ public void close() throws IOException {\n         private final BigArrays bigArrays;\n \n         boolean fullStateWritten = false;\n+        private final AtomicBoolean closed = new AtomicBoolean();\n \n         private Writer(List<MetaDataIndexWriter> metaDataIndexWriters, String nodeId, BigArrays bigArrays) {\n             this.metaDataIndexWriters = metaDataIndexWriters;\n             this.nodeId = nodeId;\n             this.bigArrays = bigArrays;\n         }\n \n+        private void ensureOpen() {\n+            if (closed.get()) {\n+                throw new AlreadyClosedException(\"cluster state writer is closed already\");\n+            }\n+        }\n+\n+        public boolean isOpen() {\n+            return closed.get() == false;\n+        }\n+\n+        private void closeIfAnyIndexWriterHasTragedyOrIsClosed() {\n+            if (metaDataIndexWriters.stream().map(writer -> writer.indexWriter)\n+                .anyMatch(iw -> iw.getTragicException() != null || iw.isOpen() == false)) {", "originalCommit": "1c7eb4c7dc61c3bfc41e111b4d9c5313c43a3e5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI0MzgwNA==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365243804", "bodyText": "I've looked at IndexWriter and concluded that there might be cases where onTragicEvent is called but where there is no corresponding call to maybeCloseOnTragicEvent, hence the extra safeguard here. @jpountz might know more why that's the case?", "author": "ywelsch", "createdAt": "2020-01-10T13:54:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4ODgyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMwMDUyNw==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365300527", "bodyText": "I'm not very familiar with this part of the Lucene codebase, but comments and assertions suggest it might be due to the fact that closing could cause deadlocks if done during a flush. @s1monw might know more.", "author": "jpountz", "createdAt": "2020-01-10T15:51:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4ODgyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMxMjQwMw==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365312403", "bodyText": "Ok I see what you mean, let's leave it like this. This is trappier than I expected.", "author": "DaveCTurner", "createdAt": "2020-01-10T16:15:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4ODgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE5MDA4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365190089", "bodyText": "I'm surprised we need to check this, given that the caller has already checked we're open in reloadWriterIfNecessary(). Can you clarify?", "author": "DaveCTurner", "createdAt": "2020-01-10T11:25:06Z", "path": "server/src/main/java/org/elasticsearch/gateway/PersistedClusterStateService.java", "diffHunk": "@@ -520,30 +521,62 @@ public void close() throws IOException {\n         private final BigArrays bigArrays;\n \n         boolean fullStateWritten = false;\n+        private final AtomicBoolean closed = new AtomicBoolean();\n \n         private Writer(List<MetaDataIndexWriter> metaDataIndexWriters, String nodeId, BigArrays bigArrays) {\n             this.metaDataIndexWriters = metaDataIndexWriters;\n             this.nodeId = nodeId;\n             this.bigArrays = bigArrays;\n         }\n \n+        private void ensureOpen() {", "originalCommit": "1c7eb4c7dc61c3bfc41e111b4d9c5313c43a3e5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI0NDY3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365244675", "bodyText": "This was more separation of concerns. I did not want Writer here to rely on correct usage by the caller, but enforce it as well.", "author": "ywelsch", "createdAt": "2020-01-10T13:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE5MDA4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMxMTYwNg==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365311606", "bodyText": "Maybe we should be asserting that it's open instead?", "author": "DaveCTurner", "createdAt": "2020-01-10T16:13:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE5MDA4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMyODQ3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365328471", "bodyText": "Now I remembered. We can't make this an assertion as it breaks due to concurrency between close() and the other methods.", "author": "ywelsch", "createdAt": "2020-01-10T16:47:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE5MDA4OQ=="}], "type": "inlineReview"}, {"oid": "333f42a417882d3d34a3daf25788f5110ead26f1", "url": "https://github.com/elastic/elasticsearch/commit/333f42a417882d3d34a3daf25788f5110ead26f1", "message": "inline reloadWriterIfNecessary", "committedDate": "2020-01-10T13:36:28Z", "type": "commit"}, {"oid": "7082947b86ac9d95cf66b98c83025c03a84e892e", "url": "https://github.com/elastic/elasticsearch/commit/7082947b86ac9d95cf66b98c83025c03a84e892e", "message": "David likes crashes", "committedDate": "2020-01-10T14:39:15Z", "type": "commit"}, {"oid": "069730c015f3904309f961e5bf9946ec254c8394", "url": "https://github.com/elastic/elasticsearch/commit/069730c015f3904309f961e5bf9946ec254c8394", "message": "too fancy for Java", "committedDate": "2020-01-10T14:53:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI3NTEwMw==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365275103", "bodyText": "Only throws an IOError if close() throws an exception?", "author": "DaveCTurner", "createdAt": "2020-01-10T15:02:05Z", "path": "server/src/main/java/org/elasticsearch/gateway/PersistedClusterStateService.java", "diffHunk": "@@ -634,23 +672,48 @@ private void addMetaData(MetaData metaData) throws IOException {\n             }\n         }\n \n-        public void commit(long currentTerm, long lastAcceptedVersion) {\n+        public void commit(long currentTerm, long lastAcceptedVersion) throws IOException {\n+            ensureOpen();\n             try {\n                 for (MetaDataIndexWriter metaDataIndexWriter : metaDataIndexWriters) {\n-                    metaDataIndexWriter.commit(nodeId, currentTerm, lastAcceptedVersion);\n+                    metaDataIndexWriter.prepareCommit(nodeId, currentTerm, lastAcceptedVersion);\n+                }\n+            } catch (Exception e) {\n+                try {\n+                    close();\n+                } catch (Exception e2) {\n+                    logger.warn(\"failed on closing cluster state writer\", e2);\n+                    e.addSuppressed(e2);\n+                }\n+                throw e;\n+            } finally {\n+                closeIfAnyIndexWriterHasTragedyOrIsClosed();\n+            }\n+            try {\n+                for (MetaDataIndexWriter metaDataIndexWriter : metaDataIndexWriters) {\n+                    metaDataIndexWriter.commit();\n                 }\n             } catch (IOException e) {\n                 // The commit() call has similar semantics to a fsync(): although it's atomic, if it fails then we've no idea whether the\n                 // data on disk is now the old version or the new version, and this is a disaster. It's safest to fail the whole node and\n                 // retry from the beginning.\n-                throw new IOError(e);\n+                try {\n+                    close();\n+                } catch (Exception e2) {\n+                    e.addSuppressed(e2);\n+                    throw new IOError(e);", "originalCommit": "069730c015f3904309f961e5bf9946ec254c8394", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI3Njg2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365276867", "bodyText": "was also caught by the tests right away :)", "author": "ywelsch", "createdAt": "2020-01-10T15:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI3NTEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI4NzU2NA==", "url": "https://github.com/elastic/elasticsearch/pull/50805#discussion_r365287564", "bodyText": "damn robots taking our jobs \ud83e\udd16", "author": "DaveCTurner", "createdAt": "2020-01-10T15:27:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI3NTEwMw=="}], "type": "inlineReview"}, {"oid": "8a9c8641afa0abde44afd8cd70f46c07f4d5ca73", "url": "https://github.com/elastic/elasticsearch/commit/8a9c8641afa0abde44afd8cd70f46c07f4d5ca73", "message": "duh", "committedDate": "2020-01-10T15:05:21Z", "type": "commit"}]}