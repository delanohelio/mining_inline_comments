{"pr_number": 61427, "pr_title": "Allow parsing Content-Type and Accept headers with version", "pr_createdAt": "2020-08-21T15:41:53Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/61427", "timeline": [{"oid": "7514d87cbc1269be095ebcf77e586fc20e67849e", "url": "https://github.com/elastic/elasticsearch/commit/7514d87cbc1269be095ebcf77e586fc20e67849e", "message": "Allow parsing Content-Type and Accept headers with version\n\nContent-Type and Accept headers expect a verioned form of media types\nlike application/vnd.elasticsearch+json;compatible-with=7\nwhen previously it was simple application/json or similar - it is still\nsupported", "committedDate": "2020-08-21T15:31:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc5MDE1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r475790152", "bodyText": "can you add a test for yaml too ?", "author": "jakelandis", "createdAt": "2020-08-24T17:48:51Z", "path": "server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java", "diffHunk": "@@ -84,4 +84,57 @@ public void testFromRubbish() throws Exception {\n         assertThat(XContentType.fromMediaTypeOrFormat(\"text/plain\"), nullValue());\n         assertThat(XContentType.fromMediaTypeOrFormat(\"gobbly;goop\"), nullValue());\n     }\n+\n+    public void testMediaType() {", "originalCommit": "7514d87cbc1269be095ebcf77e586fc20e67849e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyMjQ4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r476422487", "bodyText": "will do", "author": "pgomulka", "createdAt": "2020-08-25T12:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc5MDE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwODI4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r476608285", "bodyText": "Regex needs a few more escapes:\n\nEscape the . within vnd.elasticsearch+\nEscape the / between the type and subtype\n\n(application|text)\\\\/(vnd\\\\.elasticsearch\\\\+)?([^;]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+))?", "author": "sethmlarson", "createdAt": "2020-08-25T17:14:55Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -114,13 +116,19 @@ public XContent xContent() {\n         }\n     };\n \n+    private static final Pattern COMPATIBLE_API_HEADER_PATTERN = Pattern.compile(\n+        \"(application|text)/(vnd.elasticsearch\\\\+)?([^;]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+))?\",", "originalCommit": "7514d87cbc1269be095ebcf77e586fc20e67849e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc4NTY2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r476785662", "bodyText": "Something I am curious about is the (\\\\d+))? at the end. If possible, it would be nice to define this as part of our \"spec\". This would be something we could be strict (eschew leniency!) about, such as enforcing it to be in a specific format (and throwing an exception when someone specifies a pattern that is not correct. We can also put the format into the documentation.\nIf you agree with the sentiment, I would be curious what we expect the final number to be, for example, which of these do we intend to support (now and in the future):\n\ncompatible-with=7\ncompatible-with=7.11\ncompatible-with=7.x\ncompatible-with=7x\ncompatible-with=7.11.2\n\nThen I think we should make this strict so users find out early if they've send an illegal value", "author": "dakrone", "createdAt": "2020-08-25T22:08:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwODI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyMzQxOA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r477423418", "bodyText": "@sethmlarson Why does the forward slash needs escaping? It's not special in Java?\nI wondering if we should anchor the pattern with ^ at the start and $ at the end, to be on the safe side?\nIn ([^;]+)(\\\\s*;, the [^;]+ will also consume whitespace, so I believe you can remove the \\\\s*.\nCan we switch any of these capture groups to non-capturing if we don't actually need the contents, just the grouping? i.e (?:<pattern>)", "author": "pugnascotia", "createdAt": "2020-08-26T16:15:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwODI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQzMDMyNg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r477430326", "bodyText": "@pugnascotia You're right the / doesn't need an escape in Java", "author": "sethmlarson", "createdAt": "2020-08-26T16:26:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwODI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE4OTk2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r480189969", "bodyText": "@sethmlarson fixed the \\\\.\n@dakrone Only major versions are supported, hence only digits are allowed - representing the major part of the version #51816 (no dots or any other character, preventing parsing minor version)\nGood point on validation - how much should be done, how precise the exception should be.. @jakelandis or @jaymode  any views on this?\n@pugnascotia good point on consuming a space. The subtype (json, yaml, etc) are not allowing spaces. Added the anchoring and skipped capturing when possible. I think all of the groups require capturing though (except maybe for the optional ; charset=UTF-8)", "author": "pgomulka", "createdAt": "2020-08-31T15:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwODI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYwODQ3OA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r477608478", "bodyText": "(vnd.elasticsearch\\+)?\n\nAm I reading this correctly that the vnd.elasticsearch part is completely optional? I thought the intent was to only add compatible-with when vnd.elasticsearch is present?", "author": "rjernst", "createdAt": "2020-08-26T21:47:52Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -114,13 +116,19 @@ public XContent xContent() {\n         }\n     };\n \n+    private static final Pattern COMPATIBLE_API_HEADER_PATTERN = Pattern.compile(\n+        \"(application|text)/(vnd.elasticsearch\\\\+)?([^;]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+))?\",", "originalCommit": "7514d87cbc1269be095ebcf77e586fc20e67849e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA4OTI3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r480089275", "bodyText": "you are right. This is possibly a bit oversimplified.\nDo you think we should aim to be more strict on the regex side or should we validate the values after the parsing with more relaxed regex?\nThe more strict could look like\nPattern.compile(\n        \"(application|text)/((vnd\\\\.elasticsearch\\\\+(json|smile|yaml|cbor)(\\\\s*;\\\\s*compatible-with=(\\\\d+)))\" +\n            \"|(json|smile|yaml|cbor))\");\n\nthere is a simplistic validation in parseVerion method, but it still allows to add compatible-with even when subtype vnd.elasticsearch is not present. The version won't be parsed though", "author": "pgomulka", "createdAt": "2020-08-31T12:14:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYwODQ3OA=="}], "type": "inlineReview"}, {"oid": "921bc6f6047c2c8412a8cd44c2fa3b40c398cc23", "url": "https://github.com/elastic/elasticsearch/commit/921bc6f6047c2c8412a8cd44c2fa3b40c398cc23", "message": "code review follow up", "committedDate": "2020-09-01T07:43:11Z", "type": "commit"}, {"oid": "ee280bab965e94a29a388710804b1379ee7b9801", "url": "https://github.com/elastic/elasticsearch/commit/ee280bab965e94a29a388710804b1379ee7b9801", "message": "unused imports", "committedDate": "2020-09-01T08:58:47Z", "type": "commit"}, {"oid": "433de741d264768174cd95a9475d77cc0d41f247", "url": "https://github.com/elastic/elasticsearch/commit/433de741d264768174cd95a9475d77cc0d41f247", "message": "revert unrelated test", "committedDate": "2020-09-02T09:31:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyMjMyNA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r482122324", "bodyText": "why do we allow */* to be JSON?", "author": "jaymode", "createdAt": "2020-09-02T14:39:56Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -130,7 +154,7 @@ public static XContentType fromMediaTypeOrFormat(String mediaType) {\n             }\n         }\n         final String lowercaseMediaType = mediaType.toLowerCase(Locale.ROOT);\n-        if (lowercaseMediaType.startsWith(\"application/*\")) {\n+        if (lowercaseMediaType.startsWith(\"application/*\") || lowercaseMediaType.equals(\"*/*\")) {", "originalCommit": "433de741d264768174cd95a9475d77cc0d41f247", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE1NTAzMw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r482155033", "bodyText": "I incorrectly read the SQL test, will remove", "author": "pgomulka", "createdAt": "2020-09-02T15:18:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyMjMyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyNzIwMg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r482127202", "bodyText": "I think the charset aspect should be handled separately since we haven't deprecated accepting other charsets yet, see #22769", "author": "jaymode", "createdAt": "2020-09-02T14:46:14Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -114,13 +116,35 @@ public XContent xContent() {\n         }\n     };\n \n+    /**\n+     * A regexp to allow parsing media types. It covers two use cases.\n+     * 1. Media type with a version - requires a custom vnd.elasticserach subtype and a compatible-with parameter\n+     * i.e. application/vnd.elasticsearch+json;compatible-with\n+     * 2. Media type without a version - for users not using compatible API i.e. application/json\n+     */\n+    private static final Pattern COMPATIBLE_API_HEADER_PATTERN = Pattern.compile(\n+            //type\n+        \"^(application|text)/\" +\n+            // custom subtype and a version: vnd.elasticsearch+json;compatible-with=7\n+            \"((vnd\\\\.elasticsearch\\\\+([^;\\\\s]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+)))\" +\n+            \"|([^;\\\\s]+))\" + //subtype: json,yaml,etc some of these are defined in x-pack so can't be enumerated\n+            \"(?:\\\\s*;\\\\s*(charset=UTF-8)?)?$\",", "originalCommit": "433de741d264768174cd95a9475d77cc0d41f247", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE1NzAyMA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r482157020", "bodyText": "good point. What is more there could other parameters which we do not expect from server perspective.\nSQL for instance has header=absent parameter\nSo this should either be any text or a sequence of ; key=value", "author": "pgomulka", "createdAt": "2020-09-02T15:20:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyNzIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEzMTgxMg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r482131812", "bodyText": "since this hack is not in this PR can we make this pkg private for now?", "author": "jaymode", "createdAt": "2020-09-02T14:51:58Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -157,6 +183,30 @@ public static XContentType fromMediaType(String mediaType) {\n         return null;\n     }\n \n+    //public scope needed for text formats hack", "originalCommit": "433de741d264768174cd95a9475d77cc0d41f247", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE1Nzg3MA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r482157870", "bodyText": "this possibly was a stale comment - removed and changed to package private", "author": "pgomulka", "createdAt": "2020-09-02T15:21:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEzMTgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEzMjM1NA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r482132354", "bodyText": "let's remove this since it is now commented out", "author": "jaymode", "createdAt": "2020-09-02T14:52:41Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -114,13 +116,35 @@ public XContent xContent() {\n         }\n     };\n \n+    /**\n+     * A regexp to allow parsing media types. It covers two use cases.\n+     * 1. Media type with a version - requires a custom vnd.elasticserach subtype and a compatible-with parameter\n+     * i.e. application/vnd.elasticsearch+json;compatible-with\n+     * 2. Media type without a version - for users not using compatible API i.e. application/json\n+     */\n+    private static final Pattern COMPATIBLE_API_HEADER_PATTERN = Pattern.compile(\n+            //type\n+        \"^(application|text)/\" +\n+            // custom subtype and a version: vnd.elasticsearch+json;compatible-with=7\n+            \"((vnd\\\\.elasticsearch\\\\+([^;\\\\s]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+)))\" +\n+            \"|([^;\\\\s]+))\" + //subtype: json,yaml,etc some of these are defined in x-pack so can't be enumerated\n+            \"(?:\\\\s*;\\\\s*(charset=UTF-8)?)?$\",\n+        Pattern.CASE_INSENSITIVE);\n+\n+\n+    /*Pattern.compile(", "originalCommit": "433de741d264768174cd95a9475d77cc0d41f247", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "51467e0ea1d8af04da4c4f5eac3449a3a40da9e6", "url": "https://github.com/elastic/elasticsearch/commit/51467e0ea1d8af04da4c4f5eac3449a3a40da9e6", "message": "remove */* and method visibility", "committedDate": "2020-09-02T15:26:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk3MjczMg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r482972732", "bodyText": "elasticserach broke my eyes", "author": "tlrx", "createdAt": "2020-09-03T13:21:57Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -114,13 +116,35 @@ public XContent xContent() {\n         }\n     };\n \n+    /**\n+     * A regexp to allow parsing media types. It covers two use cases.\n+     * 1. Media type with a version - requires a custom vnd.elasticserach subtype and a compatible-with parameter", "originalCommit": "51467e0ea1d8af04da4c4f5eac3449a3a40da9e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5NDIzMw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r482994233", "bodyText": "sorry for this :D fixed", "author": "pgomulka", "createdAt": "2020-09-03T13:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk3MjczMg=="}], "type": "inlineReview"}, {"oid": "ccaadbd7867f9a5cf9211f6a6f3a22456b8e9abd", "url": "https://github.com/elastic/elasticsearch/commit/ccaadbd7867f9a5cf9211f6a6f3a22456b8e9abd", "message": "typos", "committedDate": "2020-09-03T13:52:05Z", "type": "commit"}, {"oid": "de13d4be25dd9506dc555eb1e38ada04c0d0e960", "url": "https://github.com/elastic/elasticsearch/commit/de13d4be25dd9506dc555eb1e38ada04c0d0e960", "message": "Merge branch 'master' into compat/content-type-header-with-version", "committedDate": "2020-09-17T15:04:09Z", "type": "commit"}, {"oid": "d9ee420f73ebe68a40842963a2df89c3eb03f98d", "url": "https://github.com/elastic/elasticsearch/commit/d9ee420f73ebe68a40842963a2df89c3eb03f98d", "message": "exted parsing with parameters", "committedDate": "2020-09-17T17:04:37Z", "type": "commit"}, {"oid": "41150a6a7efce3a34ebcfa603274a7130c863788", "url": "https://github.com/elastic/elasticsearch/commit/41150a6a7efce3a34ebcfa603274a7130c863788", "message": "import", "committedDate": "2020-09-17T17:06:21Z", "type": "commit"}, {"oid": "2fc8f86027e3576cd677f644902b75265dc6ad26", "url": "https://github.com/elastic/elasticsearch/commit/2fc8f86027e3576cd677f644902b75265dc6ad26", "message": "fix test", "committedDate": "2020-09-17T17:22:35Z", "type": "commit"}, {"oid": "734031a55d9f784f66c5e4a4fcfb9fb90e6e13cf", "url": "https://github.com/elastic/elasticsearch/commit/734031a55d9f784f66c5e4a4fcfb9fb90e6e13cf", "message": "scope parser", "committedDate": "2020-09-18T10:21:48Z", "type": "commit"}, {"oid": "c04af650551c1522c8300830be2c3c754dad1759", "url": "https://github.com/elastic/elasticsearch/commit/c04af650551c1522c8300830be2c3c754dad1759", "message": "x-ndjson to be versioned", "committedDate": "2020-09-18T10:30:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NjQxMA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490876410", "bodyText": "for the discussion:\ndefining versioned media types up front, means that we won't throw an exception if someone specifies it with oss licence\nif he uses oss on v8 server for api that was removed and provides application/vnd.elasticsearch+json;compatible-with=7 he will get a 404\nis there an easy way to make XContentType plugin aware? or licence aware?\nor are we ok with allowing to use versioned media types with oss?", "author": "pgomulka", "createdAt": "2020-09-18T11:14:50Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -112,10 +113,25 @@ public XContent xContent() {\n             return CborXContent.cborXContent;\n         }\n     };\n-\n-    public static final MediaTypeParser<XContentType> mediaTypeParser = new MediaTypeParser<>(XContentType.values(),\n-        Map.of(\"application/*\", JSON, \"application/x-ndjson\", JSON));\n-\n+    /**\n+     * A regexp to allow parsing media types. It covers two use cases.\n+     * 1. Media type with a version - requires a custom vnd.elasticsearch subtype and a compatible-with parameter\n+     * i.e. application/vnd.elasticsearch+json;compatible-with\n+     * 2. Media type without a version - for users not using compatible API i.e. application/json\n+     */\n+     private static final MediaTypeParser<XContentType> mediaTypeParser = new MediaTypeParser.Builder<XContentType>()\n+        .withMediaTypeAndParams(\"application/smile\", SMILE, Collections.emptyMap())\n+        .withMediaTypeAndParams(\"application/cbor\", CBOR, Collections.emptyMap())\n+        .withMediaTypeAndParams(\"application/json\", JSON, Map.of(\"charset\", \"UTF-8\"))\n+        .withMediaTypeAndParams(\"application/yaml\", YAML, Map.of(\"charset\", \"UTF-8\"))\n+        .withMediaTypeAndParams(\"application/*\", JSON, Map.of(\"charset\", \"UTF-8\"))\n+        .withMediaTypeAndParams(\"application/x-ndjson\", JSON, Map.of(\"charset\", \"UTF-8\"))\n+        .withMediaTypeAndParams(\"application/vnd.elasticsearch+json\", JSON, Map.of(\"compatible-with\", \"\\\\d+\",\"charset\", \"UTF-8\"))\n+        .withMediaTypeAndParams(\"application/vnd.elasticsearch+smile\", SMILE, Map.of(\"compatible-with\", \"\\\\d+\",\"charset\", \"UTF-8\"))\n+        .withMediaTypeAndParams(\"application/vnd.elasticsearch+yaml\", YAML, Map.of(\"compatible-with\", \"\\\\d+\",\"charset\", \"UTF-8\"))\n+        .withMediaTypeAndParams(\"application/vnd.elasticsearch+cbor\", CBOR, Map.of(\"compatible-with\", \"\\\\d+\",\"charset\", \"UTF-8\"))\n+        .withMediaTypeAndParams(\"application/vnd.elasticsearch+x-ndjson\", JSON, Map.of(\"compatible-with\", \"\\\\d+\",\"charset\", \"UTF-8\"))\n+        .build();", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3NTM4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490975383", "bodyText": "I think a 404 (or maybe 400) is the right thing to do here since the infrastructure for version support is in OSS and we do not have a compatible handler for V7.", "author": "jaymode", "createdAt": "2020-09-18T14:09:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NjQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkwMzc3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r491903775", "bodyText": "but this also would affect plugins like SQL. In oss we don't know about MediaTypes which are defined over there\nif we throw an exception for a unknown type I am worried we might end up with a logic based on exceptions\ntry XContentType.parseMediaType\ntry XContentType.parseFormat\ntry TextFormat.parseMediaType\ntry TextFormat.parseFormat\n\n@bpintea any thoughts on this? I guess SQL had to face this in the past", "author": "pgomulka", "createdAt": "2020-09-21T09:28:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NjQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEyMTg1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r492121856", "bodyText": "Is there any way to register a custom parser ? or just add the SQL values to the core parser and specificy which rule set to use when parsing ?", "author": "jakelandis", "createdAt": "2020-09-21T15:01:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NjQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIxMzQxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r492213411", "bodyText": "that is an interesting idea.. We could have something like a SqlMediaTypeParser and it would either return TextFormat or XContentType. The parsing logic would remain the same in the MediaTypeParser. The idea of SqlMediaTypeParser woudl be just to abstract on the setup of the parser.\nThe same could be done for CompatibleApiMediaTypeParser and we could keep it in xpack plugin.\nthis does not solve the problem of trying to parse a format, then if failed to parse a media type. I think we should try to just check for presence of the format parameter and if present to used. Otherwise trying to use Accept Header.\nI think also that Content-Type should not be used for response formatting in SQL plugin. It looks like it is allowed in code, but I don't think it would work (it would fail when parsing that header in server)", "author": "pgomulka", "createdAt": "2020-09-21T17:02:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NjQxMA=="}], "type": "inlineReview"}, {"oid": "474eb298470fdb651f9900f050949c738b2cca2c", "url": "https://github.com/elastic/elasticsearch/commit/474eb298470fdb651f9900f050949c738b2cca2c", "message": "Merge branch 'master' into compat/content-type-header-with-version", "committedDate": "2020-09-18T14:20:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3MTUyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490971521", "bodyText": "I suggest that we benchmark this with a JMH microbenchmark (separately) with a variety of different content types and parameters", "author": "jaymode", "createdAt": "2020-09-18T14:03:02Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -65,8 +51,10 @@ public T fromFormat(String format) {\n \n     /**\n      * parsing media type that follows https://tools.ietf.org/html/rfc7231#section-3.1.1.1\n+     *\n      * @param headerValue a header value from Accept or Content-Type\n      * @return a parsed media-type\n+     * //todo pg should this all be maybe based on a regex?", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2MDc0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496660746", "bodyText": "I wrote a benchmark and regex approach is slower. I does cover more (the exact characters allowed by rfc) but not sure we need this. See the implementation:\nhttps://github.com/pgomulka/elasticsearch/blob/compat/benchmark_regex_vs_splits/benchmarks/src/main/java/org/elasticsearch/benchmark/MediaTypeParsingBenchmark.java\nhttps://github.com/pgomulka/elasticsearch/blob/compat/benchmark_regex_vs_splits/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParserRegex.java\nBenchmark                                     Mode  Cnt  Score   Error  Units\nMediaTypeParsingBenchmark.parseIter           avgt   30  0.801 \u00b1 0.010  us/op\nMediaTypeParsingBenchmark.parseIterNoParams   avgt   30  0.200 \u00b1 0.002  us/op\nMediaTypeParsingBenchmark.parseRegex          avgt   30  1.639 \u00b1 0.012  us/op\nMediaTypeParsingBenchmark.parseRegexNoParams  avgt   30  0.504 \u00b1 0.011  us/op", "author": "pgomulka", "createdAt": "2020-09-29T12:03:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3MTUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3MTk5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490971997", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(parametersMap.containsKey(typeWithSubtype)){\n          \n          \n            \n                    if (parametersMap.containsKey(typeWithSubtype)) {", "author": "jaymode", "createdAt": "2020-09-18T14:03:44Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -96,6 +91,17 @@ public ParsedMediaType parseMediaType(String headerValue) {\n         return null;\n     }\n \n+    private boolean isValidParameter(String typeWithSubtype, String parameterName, String parameterValue) {\n+        if(parametersMap.containsKey(typeWithSubtype)){", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3MjExNg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490972116", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if(parameters.containsKey(parameterName)){\n          \n          \n            \n                        if (parameters.containsKey(parameterName)) {", "author": "jaymode", "createdAt": "2020-09-18T14:03:56Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -96,6 +91,17 @@ public ParsedMediaType parseMediaType(String headerValue) {\n         return null;\n     }\n \n+    private boolean isValidParameter(String typeWithSubtype, String parameterName, String parameterValue) {\n+        if(parametersMap.containsKey(typeWithSubtype)){\n+            Map<String, String> parameters = parametersMap.get(typeWithSubtype);\n+            if(parameters.containsKey(parameterName)){", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3MzU4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490973583", "bodyText": "We should compile the regex into a pattern to avoid doing it everytime", "author": "jaymode", "createdAt": "2020-09-18T14:06:11Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -96,6 +91,17 @@ public ParsedMediaType parseMediaType(String headerValue) {\n         return null;\n     }\n \n+    private boolean isValidParameter(String typeWithSubtype, String parameterName, String parameterValue) {\n+        if(parametersMap.containsKey(typeWithSubtype)){\n+            Map<String, String> parameters = parametersMap.get(typeWithSubtype);\n+            if(parameters.containsKey(parameterName)){\n+                String regex = parameters.get(parameterName);\n+                return parameterValue.matches(regex);//todo pg should we precompile regex?", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAxNTY2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r491015667", "bodyText": "will do", "author": "pgomulka", "createdAt": "2020-09-18T15:10:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3MzU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3NTU2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490975562", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(parsedMediaType != null) {\n          \n          \n            \n                    if (parsedMediaType != null) {", "author": "jaymode", "createdAt": "2020-09-18T14:09:19Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -137,13 +153,23 @@ public static XContentType fromMediaType(String mediaTypeHeaderValue) {\n         return mediaTypeParser.fromMediaType(mediaTypeHeaderValue);\n     }\n \n-\n     private int index;\n \n     XContentType(int index) {\n         this.index = index;\n     }\n \n+    public static Byte parseVersion(String mediaType) {\n+        MediaTypeParser<XContentType>.ParsedMediaType parsedMediaType = mediaTypeParser.parseMediaType(mediaType);\n+        if(parsedMediaType != null) {", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3OTgyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490979821", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        XContentType.JSON,Map.of(\"compatible-with\",\"\\\\d+\",\n          \n          \n            \n                        \"charset\",\"UTF-8\"))\n          \n          \n            \n                        XContentType.JSON, Map.of(\"compatible-with\", \"\\\\d+\",\n          \n          \n            \n                        \"charset\", \"UTF-8\"))", "author": "jaymode", "createdAt": "2020-09-18T14:15:44Z", "path": "libs/x-content/src/test/java/org/elasticsearch/common/xcontent/MediaTypeParserTests.java", "diffHunk": "@@ -29,37 +29,42 @@\n import static org.hamcrest.Matchers.nullValue;\n \n public class MediaTypeParserTests extends ESTestCase {\n-    MediaTypeParser<XContentType> mediaTypeParser = XContentType.mediaTypeParser;\n+\n+    MediaTypeParser<XContentType> mediaTypeParser = new MediaTypeParser.Builder<XContentType>()\n+        .withMediaTypeAndParams(\"application/vnd.elasticsearch+json\",\n+            XContentType.JSON,Map.of(\"compatible-with\",\"\\\\d+\",\n+            \"charset\",\"UTF-8\"))", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4MDM0OA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490980348", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(XContentType.parseVersion(\"application/json;compatible-with=\" + version+\".0\"),\n          \n          \n            \n                    assertThat(XContentType.parseVersion(\"application/json;compatible-with=\" + version + \".0\"),", "author": "jaymode", "createdAt": "2020-09-18T14:16:27Z", "path": "server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java", "diffHunk": "@@ -93,4 +94,66 @@ public void testFromRubbish() throws Exception {\n         assertThat(XContentType.fromMediaType(\"text/plain\"), nullValue());\n         assertThat(XContentType.fromMediaType(\"gobbly;goop\"), nullValue());\n     }\n+\n+    public void testVersionedMediaType() {\n+        String version = String.valueOf(Math.abs(randomByte()));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n+            equalTo(XContentType.CBOR));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+smile;compatible-with=\" + version),\n+            equalTo(XContentType.SMILE));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+yaml;compatible-with=\" + version),\n+            equalTo(XContentType.YAML));\n+        assertThat(XContentType.fromMediaType(\"application/json\"),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+x-ndjson;compatible-with=\" + version),\n+            equalTo(XContentType.JSON));\n+\n+\n+        assertThat(XContentType.fromMediaType(\"APPLICATION/VND.ELASTICSEARCH+JSON;COMPATIBLE-WITH=\" + version),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"APPLICATION/JSON\"),\n+            equalTo(XContentType.JSON));\n+    }\n+\n+    public void testVersionParsing() {\n+        byte version = (byte)Math.abs(randomByte());\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+smile;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+x-ndjson;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/json\"),\n+            nullValue());\n+\n+\n+        assertThat(XContentType.parseVersion(\"APPLICATION/VND.ELASTICSEARCH+JSON;COMPATIBLE-WITH=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"APPLICATION/JSON\"),\n+            nullValue());\n+\n+        assertThat(XContentType.parseVersion(\"application/json;compatible-with=\" + version+\".0\"),", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4MTI3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490981271", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(XContentType.fromMediaType(\"sth_application/json;compatible-with=\" + version+\".0\"), nullValue());\n          \n          \n            \n                    assertThat(XContentType.fromMediaType(\"sth_application/json;compatible-with=\" + version+\"_sth\"), nullValue());\n          \n          \n            \n                    assertThat(XContentType.fromMediaType(\"application/json;compatible-with=\" + version+\"_sth\"), nullValue());\n          \n          \n            \n                    assertThat(XContentType.fromMediaType(\"sth_application/json;compatible-with=\" + version + \".0\"), nullValue());\n          \n          \n            \n                    assertThat(XContentType.fromMediaType(\"sth_application/json;compatible-with=\" + version + \"_sth\"), nullValue());\n          \n          \n            \n                    assertThat(XContentType.fromMediaType(\"application/json;compatible-with=\" + version + \"_sth\"), nullValue());", "author": "jaymode", "createdAt": "2020-09-18T14:17:42Z", "path": "server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java", "diffHunk": "@@ -93,4 +94,66 @@ public void testFromRubbish() throws Exception {\n         assertThat(XContentType.fromMediaType(\"text/plain\"), nullValue());\n         assertThat(XContentType.fromMediaType(\"gobbly;goop\"), nullValue());\n     }\n+\n+    public void testVersionedMediaType() {\n+        String version = String.valueOf(Math.abs(randomByte()));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n+            equalTo(XContentType.CBOR));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+smile;compatible-with=\" + version),\n+            equalTo(XContentType.SMILE));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+yaml;compatible-with=\" + version),\n+            equalTo(XContentType.YAML));\n+        assertThat(XContentType.fromMediaType(\"application/json\"),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+x-ndjson;compatible-with=\" + version),\n+            equalTo(XContentType.JSON));\n+\n+\n+        assertThat(XContentType.fromMediaType(\"APPLICATION/VND.ELASTICSEARCH+JSON;COMPATIBLE-WITH=\" + version),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"APPLICATION/JSON\"),\n+            equalTo(XContentType.JSON));\n+    }\n+\n+    public void testVersionParsing() {\n+        byte version = (byte)Math.abs(randomByte());\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+smile;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+x-ndjson;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/json\"),\n+            nullValue());\n+\n+\n+        assertThat(XContentType.parseVersion(\"APPLICATION/VND.ELASTICSEARCH+JSON;COMPATIBLE-WITH=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"APPLICATION/JSON\"),\n+            nullValue());\n+\n+        assertThat(XContentType.parseVersion(\"application/json;compatible-with=\" + version+\".0\"),\n+            is(nullValue()));\n+    }\n+\n+    public void testUnrecognizedParameter() {\n+        assertThat(XContentType.parseVersion(\"application/json; sth=123\"),\n+            is(nullValue()));\n+    }\n+\n+    public void testMediaTypeWithoutESSubtype() {\n+        String version = String.valueOf(Math.abs(randomByte()));\n+        assertThat(XContentType.fromMediaType(\"application/json;compatible-with=\" + version), nullValue());\n+    }\n+\n+    public void testAnchoring(){\n+        String version = String.valueOf(Math.abs(randomByte()));\n+        assertThat(XContentType.fromMediaType(\"sth_application/json;compatible-with=\" + version+\".0\"), nullValue());\n+        assertThat(XContentType.fromMediaType(\"sth_application/json;compatible-with=\" + version+\"_sth\"), nullValue());\n+        assertThat(XContentType.fromMediaType(\"application/json;compatible-with=\" + version+\"_sth\"), nullValue());", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4MTQwNw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490981407", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testAnchoring(){\n          \n          \n            \n                public void testAnchoring() {", "author": "jaymode", "createdAt": "2020-09-18T14:17:52Z", "path": "server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java", "diffHunk": "@@ -93,4 +94,66 @@ public void testFromRubbish() throws Exception {\n         assertThat(XContentType.fromMediaType(\"text/plain\"), nullValue());\n         assertThat(XContentType.fromMediaType(\"gobbly;goop\"), nullValue());\n     }\n+\n+    public void testVersionedMediaType() {\n+        String version = String.valueOf(Math.abs(randomByte()));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n+            equalTo(XContentType.CBOR));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+smile;compatible-with=\" + version),\n+            equalTo(XContentType.SMILE));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+yaml;compatible-with=\" + version),\n+            equalTo(XContentType.YAML));\n+        assertThat(XContentType.fromMediaType(\"application/json\"),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+x-ndjson;compatible-with=\" + version),\n+            equalTo(XContentType.JSON));\n+\n+\n+        assertThat(XContentType.fromMediaType(\"APPLICATION/VND.ELASTICSEARCH+JSON;COMPATIBLE-WITH=\" + version),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"APPLICATION/JSON\"),\n+            equalTo(XContentType.JSON));\n+    }\n+\n+    public void testVersionParsing() {\n+        byte version = (byte)Math.abs(randomByte());\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+smile;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+x-ndjson;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/json\"),\n+            nullValue());\n+\n+\n+        assertThat(XContentType.parseVersion(\"APPLICATION/VND.ELASTICSEARCH+JSON;COMPATIBLE-WITH=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"APPLICATION/JSON\"),\n+            nullValue());\n+\n+        assertThat(XContentType.parseVersion(\"application/json;compatible-with=\" + version+\".0\"),\n+            is(nullValue()));\n+    }\n+\n+    public void testUnrecognizedParameter() {\n+        assertThat(XContentType.parseVersion(\"application/json; sth=123\"),\n+            is(nullValue()));\n+    }\n+\n+    public void testMediaTypeWithoutESSubtype() {\n+        String version = String.valueOf(Math.abs(randomByte()));\n+        assertThat(XContentType.fromMediaType(\"application/json;compatible-with=\" + version), nullValue());\n+    }\n+\n+    public void testAnchoring(){", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4NTM2NA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490985364", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    byte version = (byte)Math.abs(randomByte());\n          \n          \n            \n                    byte version = (byte) Math.abs(randomByte());", "author": "jaymode", "createdAt": "2020-09-18T14:23:11Z", "path": "server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java", "diffHunk": "@@ -93,4 +94,66 @@ public void testFromRubbish() throws Exception {\n         assertThat(XContentType.fromMediaType(\"text/plain\"), nullValue());\n         assertThat(XContentType.fromMediaType(\"gobbly;goop\"), nullValue());\n     }\n+\n+    public void testVersionedMediaType() {\n+        String version = String.valueOf(Math.abs(randomByte()));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n+            equalTo(XContentType.CBOR));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+smile;compatible-with=\" + version),\n+            equalTo(XContentType.SMILE));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+yaml;compatible-with=\" + version),\n+            equalTo(XContentType.YAML));\n+        assertThat(XContentType.fromMediaType(\"application/json\"),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+x-ndjson;compatible-with=\" + version),\n+            equalTo(XContentType.JSON));\n+\n+\n+        assertThat(XContentType.fromMediaType(\"APPLICATION/VND.ELASTICSEARCH+JSON;COMPATIBLE-WITH=\" + version),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"APPLICATION/JSON\"),\n+            equalTo(XContentType.JSON));\n+    }\n+\n+    public void testVersionParsing() {\n+        byte version = (byte)Math.abs(randomByte());", "originalCommit": "474eb298470fdb651f9900f050949c738b2cca2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4NzYxNg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490987616", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if(isValidParameter(typeWithSubtype,parameterName,parameterValue) == false) {\n          \n          \n            \n                                    if (isValidParameter(typeWithSubtype, parameterName, parameterValue) == false) {", "author": "jaymode", "createdAt": "2020-09-18T14:26:27Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -86,7 +76,12 @@ public ParsedMediaType parseMediaType(String headerValue) {\n                         if (keyValueParam.length != 2 || hasSpaces(keyValueParam[0]) || hasSpaces(keyValueParam[1])) {\n                             return null;\n                         }\n-                        parameters.put(keyValueParam[0].toLowerCase(Locale.ROOT), keyValueParam[1].toLowerCase(Locale.ROOT));\n+                        String parameterName = keyValueParam[0].toLowerCase(Locale.ROOT);\n+                        String parameterValue = keyValueParam[1].toLowerCase(Locale.ROOT);\n+                        if(isValidParameter(typeWithSubtype,parameterName,parameterValue) == false) {", "originalCommit": "474eb298470fdb651f9900f050949c738b2cca2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4ODgyOA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490988828", "bodyText": "should we throw an exception here? Maybe one that returns a 400 since the parameter is invalid", "author": "jaymode", "createdAt": "2020-09-18T14:28:24Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -86,7 +76,12 @@ public ParsedMediaType parseMediaType(String headerValue) {\n                         if (keyValueParam.length != 2 || hasSpaces(keyValueParam[0]) || hasSpaces(keyValueParam[1])) {\n                             return null;\n                         }\n-                        parameters.put(keyValueParam[0].toLowerCase(Locale.ROOT), keyValueParam[1].toLowerCase(Locale.ROOT));\n+                        String parameterName = keyValueParam[0].toLowerCase(Locale.ROOT);\n+                        String parameterValue = keyValueParam[1].toLowerCase(Locale.ROOT);\n+                        if(isValidParameter(typeWithSubtype,parameterName,parameterValue) == false) {\n+                            return null;", "originalCommit": "474eb298470fdb651f9900f050949c738b2cca2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkzNDgzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r491934835", "bodyText": "but should it only be here? or should we throw exceptions in other places where we return null.\nI think we should throw an exception when a media type does not conform to rfc\nbut if we don't know about the requested media type I think it might cause problems in code at the moment (we rely on checking if parsing returned null and then try a different method. See https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/rest/AbstractRestChannel.java#L100", "author": "pgomulka", "createdAt": "2020-09-21T10:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4ODgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEwODUwOA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r492108508", "bodyText": "I think we should throw an exception here that results in a 400 (either due to non-conformance with RFC or our own definition of what is supported).  Since we are very explicit about what is supported (as of this PR), we should throw the exception as soon we discover something that is not supported. I don't think we should \"fallback\" to use format ... those cases should be handled explicitly.", "author": "jakelandis", "createdAt": "2020-09-21T14:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4ODgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4MDMzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496080335", "bodyText": "as mentioned here this PR will not introduce throwing exceptions yet. I will follow up in another PR", "author": "pgomulka", "createdAt": "2020-09-28T16:27:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4ODgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUzOTIwMg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r497539202", "bodyText": "Can you log an issue for this ?", "author": "jakelandis", "createdAt": "2020-09-30T14:07:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4ODgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4NzA3NA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r497587074", "bodyText": "done - #63080 will try to gather more details before starting work on it and possibly discussing with the team", "author": "pgomulka", "createdAt": "2020-09-30T15:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4ODgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk5Mjg1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490992855", "bodyText": "I am concerned that having charset with a regex of utf-8 could break someone using sql. This should be checked with the sql team", "author": "jaymode", "createdAt": "2020-09-18T14:34:49Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/TextFormat.java", "diffHunk": "@@ -294,7 +295,11 @@ public String subtype() {\n     private static final String PARAM_HEADER_ABSENT = \"absent\";\n     private static final String PARAM_HEADER_PRESENT = \"present\";\n \n-    private static final MediaTypeParser<TextFormat> parser = new MediaTypeParser<>(TextFormat.values());\n+    private static final MediaTypeParser<TextFormat> parser = new MediaTypeParser.Builder<TextFormat>()\n+        .withMediaTypeAndParams(PLAIN_TEXT.typeWithSubtype(), PLAIN_TEXT, Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\"))", "originalCommit": "474eb298470fdb651f9900f050949c738b2cca2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkzNTg5OA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r491935898", "bodyText": "this only means that a parameter is possible. if it won't be provided it won't fail any validation.\nI asked SQL team about this offline.\n@bpintea  can you confirm that we can expect any of these in SQL? Do you expect any other charsets?", "author": "pgomulka", "createdAt": "2020-09-21T10:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk5Mjg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc5MzU4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r492793589", "bodyText": "Not speaking for SQL, but in general with a lot of clients on Windows, I have seen them send charset=ISO-8859-1 with the Content-Type header and would operate under the assumption that they may also send the charset with the Accept header; nothing in RFC 7231 would prevent that. Additionally, multiple accept headers are allowed so you can wind up with something like:\nAccept: text/plain;charset=\"utf-8\", text/plain;charset=\"ISO-8859-1\"\n\nThere is also the Accept-Charset header which technically should have precedence over the media type parameter in the Accept header. (It is kind of a mess)", "author": "jaymode", "createdAt": "2020-09-22T14:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk5Mjg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY0OTUxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r493649511", "bodyText": "I think having multiple headers would be beyond the scope of this change. We would also have to support the q factor to understand the preference of clients Accept type.", "author": "pgomulka", "createdAt": "2020-09-23T14:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk5Mjg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNjE1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r498916152", "bodyText": "if it won't be provided it won't fail any validation.\n\nRight, I believe currently the TextFormater simply ignores an Accept-requested charset (that happens to be different than UTF-8). Hasn't been an issue so far, but it might make sense to do something about it at some point.", "author": "bpintea", "createdAt": "2020-10-02T16:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk5Mjg1NQ=="}], "type": "inlineReview"}, {"oid": "5c308136a2c10c74bca289b54b7f899afda6c9fb", "url": "https://github.com/elastic/elasticsearch/commit/5c308136a2c10c74bca289b54b7f899afda6c9fb", "message": "Apply suggestions from code review\n\nCo-authored-by: Jay Modi <jaymode@users.noreply.github.com>", "committedDate": "2020-09-18T14:51:05Z", "type": "commit"}, {"oid": "7b760ba92ea2c032febabc5ced960802dd9385b1", "url": "https://github.com/elastic/elasticsearch/commit/7b760ba92ea2c032febabc5ced960802dd9385b1", "message": "precompile pattern", "committedDate": "2020-09-18T15:10:06Z", "type": "commit"}, {"oid": "5853561bb30b1d61aaf3db6b74bd1aa7f43e6ea8", "url": "https://github.com/elastic/elasticsearch/commit/5853561bb30b1d61aaf3db6b74bd1aa7f43e6ea8", "message": "import", "committedDate": "2020-09-21T08:45:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA5NzA2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r492097063", "bodyText": "nit: I would suggest to pass a Map<String, Pattern> so that the contract is a bit clearer (not obvious that the value can a regex expression)", "author": "jakelandis", "createdAt": "2020-09-21T14:34:12Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -120,4 +125,36 @@ public T getMediaType() {\n             return parameters;\n         }\n     }\n+\n+    public static class Builder<T extends MediaType> {\n+        private final Map<String, T> formatMap = new HashMap<>();\n+        private final Map<String, T> typeMap = new HashMap<>();\n+        private final Map<String, Map<String, Pattern>> parametersMap = new HashMap<>();\n+\n+        public Builder<T> withMediaTypeNoParams(String alternativeMediaType, T mediaType) {\n+            typeMap.put(alternativeMediaType.toLowerCase(Locale.ROOT), mediaType);\n+            formatMap.put(mediaType.format(), mediaType);\n+            return this;\n+        }\n+\n+        public Builder<T> withMediaTypeAndParams(String alternativeMediaType, T mediaType, Map<String, String> paramNameAndValueRegex) {", "originalCommit": "5853561bb30b1d61aaf3db6b74bd1aa7f43e6ea8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIwNzE5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r492207196", "bodyText": "I will have to copy the pattern and create a new one to make sure  case insensitivity is used. I will give a go and see how it works", "author": "pgomulka", "createdAt": "2020-09-21T16:52:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA5NzA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA5ODMxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r492098319", "bodyText": "I think you can remove this method in favor of just consumers just passing Colections.emptyMap() (which is how it is currently used).", "author": "jakelandis", "createdAt": "2020-09-21T14:35:50Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -120,4 +125,36 @@ public T getMediaType() {\n             return parameters;\n         }\n     }\n+\n+    public static class Builder<T extends MediaType> {\n+        private final Map<String, T> formatMap = new HashMap<>();\n+        private final Map<String, T> typeMap = new HashMap<>();\n+        private final Map<String, Map<String, Pattern>> parametersMap = new HashMap<>();\n+\n+        public Builder<T> withMediaTypeNoParams(String alternativeMediaType, T mediaType) {", "originalCommit": "5853561bb30b1d61aaf3db6b74bd1aa7f43e6ea8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b6ebd6399abcec1faad8a994ae202c82151139f7", "url": "https://github.com/elastic/elasticsearch/commit/b6ebd6399abcec1faad8a994ae202c82151139f7", "message": "removal of unused method and pattern in method", "committedDate": "2020-09-21T17:07:24Z", "type": "commit"}, {"oid": "ff6c94f3e6d483b53415b7a2162c4a9f651fad7c", "url": "https://github.com/elastic/elasticsearch/commit/ff6c94f3e6d483b53415b7a2162c4a9f651fad7c", "message": "throwing exception when failing to parse", "committedDate": "2020-09-22T13:49:35Z", "type": "commit"}, {"oid": "b969f2bd860b74caff6bbf11b9eb19e3f4651ae9", "url": "https://github.com/elastic/elasticsearch/commit/b969f2bd860b74caff6bbf11b9eb19e3f4651ae9", "message": "checkstyle", "committedDate": "2020-09-22T15:03:06Z", "type": "commit"}, {"oid": "0684e584eb812fe76e2eb8427ac0b323b43ff83d", "url": "https://github.com/elastic/elasticsearch/commit/0684e584eb812fe76e2eb8427ac0b323b43ff83d", "message": "test fixes", "committedDate": "2020-09-23T09:34:18Z", "type": "commit"}, {"oid": "b91d4721754e7d0111ba1a3731bb0170b52fe8cb", "url": "https://github.com/elastic/elasticsearch/commit/b91d4721754e7d0111ba1a3731bb0170b52fe8cb", "message": "*/* header", "committedDate": "2020-09-23T12:16:03Z", "type": "commit"}, {"oid": "9edc49f64ad91799628068bd80abc8706ebc86c4", "url": "https://github.com/elastic/elasticsearch/commit/9edc49f64ad91799628068bd80abc8706ebc86c4", "message": "catch", "committedDate": "2020-09-23T12:43:58Z", "type": "commit"}, {"oid": "c5d816693e18003a9b78246cb3ed2e3efc0be3be", "url": "https://github.com/elastic/elasticsearch/commit/c5d816693e18003a9b78246cb3ed2e3efc0be3be", "message": "hacks around text/plain", "committedDate": "2020-09-23T17:48:43Z", "type": "commit"}, {"oid": "ad673b64ddd1a2bbe01823084515af5706d46c4e", "url": "https://github.com/elastic/elasticsearch/commit/ad673b64ddd1a2bbe01823084515af5706d46c4e", "message": "sout remove", "committedDate": "2020-09-23T17:53:13Z", "type": "commit"}, {"oid": "1ae6a609a9b6ed0826ac5bb1847f431e5e56190e", "url": "https://github.com/elastic/elasticsearch/commit/1ae6a609a9b6ed0826ac5bb1847f431e5e56190e", "message": "precommit", "committedDate": "2020-09-23T18:12:03Z", "type": "commit"}, {"oid": "1ae63c69122b0deec888afa0f236cfb579472eeb", "url": "https://github.com/elastic/elasticsearch/commit/1ae63c69122b0deec888afa0f236cfb579472eeb", "message": "fix nullpointer", "committedDate": "2020-09-24T06:28:56Z", "type": "commit"}, {"oid": "ee1e5a0459d7228c53369928516d0e9acb1e2e2f", "url": "https://github.com/elastic/elasticsearch/commit/ee1e5a0459d7228c53369928516d0e9acb1e2e2f", "message": "fix yml test", "committedDate": "2020-09-24T07:23:53Z", "type": "commit"}, {"oid": "9f4b6c38a5869c22b8354e59bf0f7a7aeb1e69f2", "url": "https://github.com/elastic/elasticsearch/commit/9f4b6c38a5869c22b8354e59bf0f7a7aeb1e69f2", "message": "fix yml test", "committedDate": "2020-09-24T07:51:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE1MTg1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r494151857", "bodyText": "an exception is thrown when parsing so we would not need thisif", "author": "pgomulka", "createdAt": "2020-09-24T08:57:27Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/RestHighLevelClient.java", "diffHunk": "@@ -1900,9 +1900,9 @@ protected final ElasticsearchStatusException parseResponseException(ResponseExce\n             throw new IllegalStateException(\"Elasticsearch didn't return the [Content-Type] header, unable to parse response body\");\n         }\n         XContentType xContentType = XContentType.fromMediaType(entity.getContentType().getValue());\n-        if (xContentType == null) {\n-            throw new IllegalStateException(\"Unsupported Content-Type: \" + entity.getContentType().getValue());\n-        }\n+//        if (xContentType == null) {", "originalCommit": "9f4b6c38a5869c22b8354e59bf0f7a7aeb1e69f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzOTI0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r495939241", "bodyText": "not throwin exception in this PR", "author": "pgomulka", "createdAt": "2020-09-28T13:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE1MTg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE2MDU1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r494160556", "bodyText": "when parsing returns a supertype to TextFormat and XContentType - MediaType -  it makes it harder to implement these two branches.\ni think we should probably move the formatting behaviour out of TextFormat. It should only implement methods defined on MediaType (the original XContentType methods)", "author": "pgomulka", "createdAt": "2020-09-24T09:11:24Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java", "diffHunk": "@@ -107,16 +61,16 @@ public RestResponse buildResponse(SqlQueryResponse response) throws Exception {\n                 RestResponse restResponse;\n \n                 // XContent branch\n-                if (xContentType != null) {\n-                    XContentBuilder builder = channel.newBuilder(request.getXContentType(), xContentType, true);\n+                if (responseMediaType != null && responseMediaType instanceof XContentType) {", "originalCommit": "9f4b6c38a5869c22b8354e59bf0f7a7aeb1e69f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzODI2NA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r495938264", "bodyText": "leaving this up for discussion. With this approach we can have a single parser that returns both XContentType and TextFormat under MediaType interface\nXContentType does not implement format method. But maybe these two should have a common createRestResponse method?", "author": "pgomulka", "createdAt": "2020-09-28T13:27:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE2MDU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE2MzIwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r494163209", "bodyText": "I made a comment to suggest we get rid of using Content-Type to set responseType. However I think most sql queries contain a body, so using a Content-Type to default responseType might be ok.\nIf however a request did not contain a body, then it would not make sense. I don't know we have any SQL api though.\nHowever, this obviously means that only json/cbor/smile/yml are allowed .", "author": "pgomulka", "createdAt": "2020-09-24T09:15:43Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.plugin;\n+\n+import org.elasticsearch.common.xcontent.MediaType;\n+import org.elasticsearch.common.xcontent.MediaTypeParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.xpack.sql.action.SqlQueryRequest;\n+import org.elasticsearch.xpack.sql.proto.Mode;\n+\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+import static org.elasticsearch.xpack.sql.proto.Protocol.URL_PARAM_FORMAT;\n+\n+public class SqlMediaTypeParser {\n+    private static final MediaTypeParser<? extends MediaType> parser = new MediaTypeParser.Builder<>()\n+        .copyFromMediaTypeParser(XContentType.mediaTypeParser)\n+        .withMediaTypeAndParams(TextFormat.PLAIN_TEXT.typeWithSubtype(), TextFormat.PLAIN_TEXT,\n+            Map.of(\"header\", Pattern.compile(\"present|absent\"), \"charset\", Pattern.compile(\"utf-8\")))\n+        .withMediaTypeAndParams(TextFormat.CSV.typeWithSubtype(), TextFormat.CSV,\n+            Map.of(\"header\", Pattern.compile(\"present|absent\"), \"charset\", Pattern.compile(\"utf-8\")))\n+        .withMediaTypeAndParams(TextFormat.TSV.typeWithSubtype(), TextFormat.TSV,\n+            Map.of(\"header\", Pattern.compile(\"present|absent\"), \"charset\", Pattern.compile(\"utf-8\")))\n+        .build();\n+\n+    /*\n+     * Since we support {@link TextFormat} <strong>and</strong>\n+     * {@link XContent} outputs we can't use {@link RestToXContentListener}\n+     * like everything else. We want to stick as closely as possible to\n+     * Elasticsearch's defaults though, while still layering in ways to\n+     * control the output more easily.\n+     *\n+     * First we find the string that the user used to specify the response\n+     * format. If there is a {@code format} parameter we use that. If there\n+     * isn't but there is a {@code Accept} header then we use that. If there\n+     * isn't then we use the {@code Content-Type} header which is required.\n+     */\n+    public MediaType getMediaType(RestRequest request, SqlQueryRequest sqlRequest) {\n+\n+        if (Mode.isDedicatedClient(sqlRequest.requestInfo().mode())\n+            && (sqlRequest.binaryCommunication() == null || sqlRequest.binaryCommunication())) {\n+            // enforce CBOR response for drivers and CLI (unless instructed differently through the config param)\n+            return XContentType.CBOR;\n+        } else if (request.hasParam(URL_PARAM_FORMAT)){\n+            return validateColumnarRequest(sqlRequest.columnar(), parser.fromFormat( request.param(URL_PARAM_FORMAT)));\n+        }\n+        if (request.getHeaders().containsKey(\"Accept\")) {\n+            String accept = request.header(\"Accept\");\n+            // */* means \"I don't care\" which we should treat like not specifying the header\n+            if (\"*/*\".equals(accept) == false) {\n+                return validateColumnarRequest(sqlRequest.columnar(), parser.fromMediaType(accept));\n+            }\n+        }\n+\n+        //todo pg we should probably remove this possibility. it should only be accept or format.\n+        // also if you specify sql's textformat in content type it will fail with exception now\n+        String contentType = request.header(\"Content-Type\");", "originalCommit": "9f4b6c38a5869c22b8354e59bf0f7a7aeb1e69f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkyMjQwMA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r495922400", "bodyText": "also not fixing this in current PR. might be worth discussing with @elastic/es-ql", "author": "pgomulka", "createdAt": "2020-09-28T13:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE2MzIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5Mzc4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r498893782", "bodyText": "I think most sql queries contain a body\n\nIndeed, all requests concerning this code always contain a body.\n(In the SQL API only one API lacks it, the one for stats inquiring, which won't hit this code tho.)", "author": "bpintea", "createdAt": "2020-10-02T15:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE2MzIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE2Mzg2NA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r494163864", "bodyText": "this client does not have access to SQL code, but has to support these formats too.", "author": "pgomulka", "createdAt": "2020-09-24T09:16:45Z", "path": "test/framework/src/main/java/org/elasticsearch/test/rest/yaml/ClientYamlTestResponse.java", "diffHunk": "@@ -45,15 +45,21 @@\n \n     private final Response response;\n     private final byte[] body;\n-    private final XContentType bodyContentType;\n+    private XContentType bodyContentType;\n     private ObjectPath parsedResponse;\n     private String bodyAsString;\n \n     public ClientYamlTestResponse(Response response) throws IOException {\n         this.response = response;\n         if (response.getEntity() != null) {\n             String contentType = response.getHeader(\"Content-Type\");\n-            this.bodyContentType = XContentType.fromMediaType(contentType);\n+            // todo pg it feels like there is a lot of 'ifs' around text, csv etc being returned. shouldn't we treat text as the same json and others?\n+            // we are testing sql formats with this client, but don't have access to sql parsing code\n+            try{", "originalCommit": "9f4b6c38a5869c22b8354e59bf0f7a7aeb1e69f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkyMjAxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r495922015", "bodyText": "we are not throwing an exception when parsing in this PR", "author": "pgomulka", "createdAt": "2020-09-28T13:04:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE2Mzg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE2NDc2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r494164761", "bodyText": "since parsing is strict and throws an exception when unkown type is used then it requires a lot of \"if guards\" to make sure it will not fail.\nOr it leads to flow being controlled by exceptions -which is bad I think.\nAlso looks to me that text/plain is commonly used as returnType for _cat api. We should probably add it to xcontentType?", "author": "pgomulka", "createdAt": "2020-09-24T09:18:20Z", "path": "server/src/main/java/org/elasticsearch/rest/AbstractRestChannel.java", "diffHunk": "@@ -98,10 +101,17 @@ public XContentBuilder newBuilder(@Nullable XContentType requestContentType, boo\n     public XContentBuilder newBuilder(@Nullable XContentType requestContentType, @Nullable XContentType responseContentType,\n             boolean useFiltering) throws IOException {\n         if (responseContentType == null) {\n-            //TODO PG shoudld format vs acceptHeader be always the same, do we allow overriding?\n-            responseContentType = XContentType.fromFormat(format);\n-            if (responseContentType == null) {\n-                responseContentType = XContentType.fromMediaType(acceptHeader);\n+            if (Strings.hasText(format)) {\n+                responseContentType = XContentType.fromFormat(format);\n+            } else if (Strings.hasText(acceptHeader) && acceptHeader.equals(\"*/*\") == false", "originalCommit": "9f4b6c38a5869c22b8354e59bf0f7a7aeb1e69f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkyMTY4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r495921681", "bodyText": "not fixing this in current PR. will follow up", "author": "pgomulka", "createdAt": "2020-09-28T13:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE2NDc2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE3NTQ0NA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r494175444", "bodyText": "should this be renamed to acceptType?", "author": "pgomulka", "createdAt": "2020-09-24T09:35:39Z", "path": "server/src/main/java/org/elasticsearch/rest/BytesRestResponse.java", "diffHunk": "@@ -83,6 +83,7 @@ public BytesRestResponse(RestStatus status, String contentType, byte[] content)\n     /**\n      * Creates a binary response.\n      */\n+    //todo pg this should probably be acceptType? (2nd param)\n     public BytesRestResponse(RestStatus status, String contentType, BytesReference content) {", "originalCommit": "9f4b6c38a5869c22b8354e59bf0f7a7aeb1e69f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkxMjE1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r495912159", "bodyText": "renamed.", "author": "pgomulka", "createdAt": "2020-09-28T12:49:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE3NTQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE3NjUwOA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r494176508", "bodyText": "this prevents defaulting Accept header to text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2 by sun.net.www.protocol.http.HttpURLConnection", "author": "pgomulka", "createdAt": "2020-09-24T09:37:24Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/http/WaitForHttpResource.java", "diffHunk": "@@ -145,6 +145,7 @@ HttpURLConnection buildConnection(SSLContext ssl) throws IOException {\n         configureSslContext(connection, ssl);\n         configureBasicAuth(connection);\n         connection.setRequestMethod(\"GET\");\n+        connection.setRequestProperty(\"Accept\", \"text/plain; charset=UTF-8\");", "originalCommit": "9f4b6c38a5869c22b8354e59bf0f7a7aeb1e69f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bd4dee1126974d0cf66d63eaf62564b8c3d9f032", "url": "https://github.com/elastic/elasticsearch/commit/bd4dee1126974d0cf66d63eaf62564b8c3d9f032", "message": "throwing exception when failing to parse\n\ncheckstyle\n\ntest fixes\n\n*/* header\n\ncatch\n\nhacks around text/plain\n\nsout remove\n\nprecommit\n\nfix nullpointer\n\nfix yml test\n\nfix yml test", "committedDate": "2020-09-24T10:25:09Z", "type": "commit"}, {"oid": "ce42f1bd933ef7823b11258d1b3c5f5efa88fcbc", "url": "https://github.com/elastic/elasticsearch/commit/ce42f1bd933ef7823b11258d1b3c5f5efa88fcbc", "message": "Revert \"throwing exception when failing to parse\"\n\nThis reverts commit bd4dee1126974d0cf66d63eaf62564b8c3d9f032.", "committedDate": "2020-09-24T16:41:34Z", "type": "commit"}, {"oid": "0f8ae7b50485a8ca201f235d15ba3a0fe77c15bf", "url": "https://github.com/elastic/elasticsearch/commit/0f8ae7b50485a8ca201f235d15ba3a0fe77c15bf", "message": "Merge branch 'revert_strict_header_parsing' into compat/content-type-header-with-version", "committedDate": "2020-09-24T16:48:40Z", "type": "commit"}, {"oid": "c4f02ade240cd69c6966d0082800c8cc5ba69854", "url": "https://github.com/elastic/elasticsearch/commit/c4f02ade240cd69c6966d0082800c8cc5ba69854", "message": "import", "committedDate": "2020-09-28T07:27:51Z", "type": "commit"}, {"oid": "176302efd7687f267a211337d6c5632bc44d3085", "url": "https://github.com/elastic/elasticsearch/commit/176302efd7687f267a211337d6c5632bc44d3085", "message": "fix storing response time in sql", "committedDate": "2020-09-28T07:57:09Z", "type": "commit"}, {"oid": "eab471c5ebd45f8ab008bdf1f3272cd091bae2b7", "url": "https://github.com/elastic/elasticsearch/commit/eab471c5ebd45f8ab008bdf1f3272cd091bae2b7", "message": "return null on errors", "committedDate": "2020-09-28T09:34:40Z", "type": "commit"}, {"oid": "e128fd78e363cb027ccf7a41018cb9e965fcc801", "url": "https://github.com/elastic/elasticsearch/commit/e128fd78e363cb027ccf7a41018cb9e965fcc801", "message": "sqlmedia type parsing test - do not throw exceptions", "committedDate": "2020-09-28T10:16:37Z", "type": "commit"}, {"oid": "66435dd9c9bf07f1457344b9e6772d65ac4a4afc", "url": "https://github.com/elastic/elasticsearch/commit/66435dd9c9bf07f1457344b9e6772d65ac4a4afc", "message": "remove todoes", "committedDate": "2020-09-28T12:45:26Z", "type": "commit"}, {"oid": "08f1395ce1f1014d06cefaff9f2722945f761e75", "url": "https://github.com/elastic/elasticsearch/commit/08f1395ce1f1014d06cefaff9f2722945f761e75", "message": "rename argument", "committedDate": "2020-09-28T16:30:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4MTgyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496781829", "bodyText": "remove todo", "author": "jakelandis", "createdAt": "2020-09-29T14:49:59Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -65,8 +50,10 @@ public T fromFormat(String format) {\n \n     /**\n      * parsing media type that follows https://tools.ietf.org/html/rfc7231#section-3.1.1.1\n+     *\n      * @param headerValue a header value from Accept or Content-Type\n      * @return a parsed media-type\n+     * //todo pg write a benchmark and consider using a regex", "originalCommit": "08f1395ce1f1014d06cefaff9f2722945f761e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5MjIzNw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496792237", "bodyText": "I think this is technically non-passive (only supporting UTF-8 encoding) and should probably be mentioned in the breaking changes ... thus only targeting 8.0 and (outside of this PR) ensure that a 7.x server maps the compatible header to standard header ... i.e. (application/vnd.elasticsearch+yaml; compatible-with=7 == application/yaml)", "author": "jakelandis", "createdAt": "2020-09-29T15:02:48Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -113,9 +115,26 @@ public XContent xContent() {\n         }\n     };\n \n-    public static final MediaTypeParser<XContentType> mediaTypeParser = new MediaTypeParser<>(XContentType.values(),\n-        Map.of(\"application/*\", JSON, \"application/x-ndjson\", JSON));\n-\n+    private static final Pattern VERSION_PATTERN = Pattern.compile(\"\\\\d+\");\n+    private static final String COMPATIBLE_WITH_PARAMETER_NAME = \"compatible-with\";\n+     public static final MediaTypeParser<XContentType> mediaTypeParser = new MediaTypeParser.Builder<XContentType>()\n+        .withMediaTypeAndParams(\"application/smile\", SMILE, Collections.emptyMap())\n+        .withMediaTypeAndParams(\"application/cbor\", CBOR, Collections.emptyMap())\n+        .withMediaTypeAndParams(\"application/json\", JSON, Map.of(\"charset\", Pattern.compile(\"UTF-8\")))\n+        .withMediaTypeAndParams(\"application/yaml\", YAML, Map.of(\"charset\", Pattern.compile(\"UTF-8\")))", "originalCommit": "08f1395ce1f1014d06cefaff9f2722945f761e75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxNzczNw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496917737", "bodyText": "that's a good point. I think clients will have to upgrade to latest 7.x client to get compatible-with  sent on their request.\nWe should also support that in 7.x server. Will raise an issue/pr", "author": "pgomulka", "createdAt": "2020-09-29T17:32:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5MjIzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4OTg0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r497489847", "bodyText": "handling of versioned media types in a form application/vnd.elasticsearch+json;compatible-with=7 will be handled in this pr #63071", "author": "pgomulka", "createdAt": "2020-09-30T13:00:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5MjIzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwODQwNA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496808404", "bodyText": "Can you also add a small test for (lowercase charset=utf-8)", "author": "jakelandis", "createdAt": "2020-09-29T15:22:44Z", "path": "server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java", "diffHunk": "@@ -23,6 +23,7 @@\n import java.util.Locale;\n \n import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.nullValue;\n \n public class XContentTypeTests extends ESTestCase {", "originalCommit": "08f1395ce1f1014d06cefaff9f2722945f761e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxNTgwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496815809", "bodyText": "can you remove the insensitive recompile here and and just use the pattern as-is (and move the insenstivie up to the declration)", "author": "jakelandis", "createdAt": "2020-09-29T15:29:42Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -120,4 +125,37 @@ public T getMediaType() {\n             return parameters;\n         }\n     }\n+\n+    public static class Builder<T extends MediaType> {\n+        private final Map<String, T> formatToMediaType = new HashMap<>();\n+        private final Map<String, T> typeWithSubtypeToMediaType = new HashMap<>();\n+        private final Map<String, Map<String, Pattern>> parametersMap = new HashMap<>();\n+\n+        public Builder<T> withMediaTypeAndParams(String alternativeMediaType, T mediaType, Map<String, Pattern> paramNameAndValueRegex) {\n+            typeWithSubtypeToMediaType.put(alternativeMediaType.toLowerCase(Locale.ROOT), mediaType);\n+            formatToMediaType.put(mediaType.format(), mediaType);\n+\n+            Map<String, Pattern> parametersForMediaType = new HashMap<>(paramNameAndValueRegex.size());\n+            for (Map.Entry<String, Pattern> params : paramNameAndValueRegex.entrySet()) {\n+                String parameterName = params.getKey().toLowerCase(Locale.ROOT);\n+                Pattern parameterRegex = params.getValue();\n+                Pattern pattern = Pattern.compile(parameterRegex.pattern(), Pattern.CASE_INSENSITIVE);", "originalCommit": "08f1395ce1f1014d06cefaff9f2722945f761e75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxMzA0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496913042", "bodyText": "It would result in a fairly big number of duplication. there are other textual parameters like header (present/absent), delimeter which would also had to declare case insensitivity.\nI wonder if we ever want to support case sensitivity for params values", "author": "pgomulka", "createdAt": "2020-09-29T17:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxNTgwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA5MzUzNw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r497093537", "bodyText": "OK ... in that case, maybe go back to a Map<String, String> as the collection passed ?  It is a bit confusing to compile it, then re-compile it.  Sorry, when i first suggested to pass Map<String, Pattern> I had envisioned only compiling once.", "author": "jakelandis", "createdAt": "2020-09-29T22:19:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxNTgwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI3NzgwOA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r497277808", "bodyText": "agree, will refactor this back. Using the Pattern as a type was making it obvious what that parameter was, but then compiling multiple times is probably not clean.", "author": "pgomulka", "createdAt": "2020-09-30T06:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxNTgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgzMjQ4MA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496832480", "bodyText": "can you also add a test that has both compatible-with and charset ?", "author": "jakelandis", "createdAt": "2020-09-29T15:45:08Z", "path": "server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java", "diffHunk": "@@ -93,4 +94,65 @@ public void testFromRubbish() throws Exception {\n         assertThat(XContentType.fromMediaType(\"text/plain\"), nullValue());\n         assertThat(XContentType.fromMediaType(\"gobbly;goop\"), nullValue());\n     }\n+\n+    public void testVersionedMediaType() {\n+        String version = String.valueOf(Math.abs(randomByte()));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+json;compatible-with=\" + version),", "originalCommit": "08f1395ce1f1014d06cefaff9f2722945f761e75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxNjkxMA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496916910", "bodyText": "this specific test is only meant to test versioning. I covered multiple parameters support in MediaTypeParserTests.testJsonWithParameters", "author": "pgomulka", "createdAt": "2020-09-29T17:31:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgzMjQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA5NDI1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r497094253", "bodyText": "thanks... i missed that!", "author": "jakelandis", "createdAt": "2020-09-29T22:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgzMjQ4MA=="}], "type": "inlineReview"}, {"oid": "3f3f0d55628bc05dd679ac6dd0f333446cd6093c", "url": "https://github.com/elastic/elasticsearch/commit/3f3f0d55628bc05dd679ac6dd0f333446cd6093c", "message": "review follow up", "committedDate": "2020-09-29T18:04:50Z", "type": "commit"}, {"oid": "427c3913e197afecb821f36f29adbf8a298e2055", "url": "https://github.com/elastic/elasticsearch/commit/427c3913e197afecb821f36f29adbf8a298e2055", "message": "remove pattern from signature", "committedDate": "2020-09-30T07:07:59Z", "type": "commit"}, {"oid": "e0316054c4a9559ddc5b115b9b5b72999c701649", "url": "https://github.com/elastic/elasticsearch/commit/e0316054c4a9559ddc5b115b9b5b72999c701649", "message": "fix regex", "committedDate": "2020-09-30T08:01:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM2Nzg2OA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r498367868", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                XContentType type = (XContentType)responseMediaType;\n          \n          \n            \n                                XContentType type = (XContentType) responseMediaType;", "author": "jaymode", "createdAt": "2020-10-01T16:20:19Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java", "diffHunk": "@@ -107,16 +61,16 @@ public RestResponse buildResponse(SqlQueryResponse response) throws Exception {\n                 RestResponse restResponse;\n \n                 // XContent branch\n-                if (xContentType != null) {\n-                    XContentBuilder builder = channel.newBuilder(request.getXContentType(), xContentType, true);\n+                if (responseMediaType != null && responseMediaType instanceof XContentType) {\n+                    XContentType type = (XContentType)responseMediaType;", "originalCommit": "e0316054c4a9559ddc5b115b9b5b72999c701649", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM2ODI1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r498368253", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            } else {// TextFormat\n          \n          \n            \n                            } else { // TextFormat", "author": "jaymode", "createdAt": "2020-10-01T16:20:54Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java", "diffHunk": "@@ -107,16 +61,16 @@ public RestResponse buildResponse(SqlQueryResponse response) throws Exception {\n                 RestResponse restResponse;\n \n                 // XContent branch\n-                if (xContentType != null) {\n-                    XContentBuilder builder = channel.newBuilder(request.getXContentType(), xContentType, true);\n+                if (responseMediaType != null && responseMediaType instanceof XContentType) {\n+                    XContentType type = (XContentType)responseMediaType;\n+                    XContentBuilder builder = channel.newBuilder(request.getXContentType(), type, true);\n                     response.toXContent(builder, request);\n                     restResponse = new BytesRestResponse(RestStatus.OK, builder);\n-                }\n-                // TextFormat\n-                else {\n-                    final String data = textFormat.format(request, response);\n+                } else {// TextFormat", "originalCommit": "e0316054c4a9559ddc5b115b9b5b72999c701649", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4134d92ef9ea93c205746bc2f5031ee40c1d579e", "url": "https://github.com/elastic/elasticsearch/commit/4134d92ef9ea93c205746bc2f5031ee40c1d579e", "message": "Apply suggestions from code review\n\nCo-authored-by: Jay Modi <jaymode@users.noreply.github.com>", "committedDate": "2020-10-02T06:24:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3OTAwNg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r498879006", "bodyText": "Is the delimiter regex derived from TextFormat.CSV#delimiter()? Because it specifies what characters are allowed, inline with what that method checks, on one hand, but allows a count of multiple character, out of line with a check there, on the other.\nThe exception messages in the method are explanatory and I'd ever so slightly prefer to return those (and maybe don't enforce a specific set here), but if you'd still like to enforce the param format in the parser definition, I'd suggest to maybe also limit the char count to one.", "author": "bpintea", "createdAt": "2020-10-02T15:04:40Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.plugin;\n+\n+import org.elasticsearch.common.xcontent.MediaType;\n+import org.elasticsearch.common.xcontent.MediaTypeParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.xpack.sql.action.SqlQueryRequest;\n+import org.elasticsearch.xpack.sql.proto.Mode;\n+\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.sql.proto.Protocol.URL_PARAM_FORMAT;\n+\n+public class SqlMediaTypeParser {\n+    private static final MediaTypeParser<? extends MediaType> parser = new MediaTypeParser.Builder<>()\n+        .copyFromMediaTypeParser(XContentType.mediaTypeParser)\n+        .withMediaTypeAndParams(TextFormat.PLAIN_TEXT.typeWithSubtype(), TextFormat.PLAIN_TEXT,\n+            Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\"))\n+        .withMediaTypeAndParams(TextFormat.CSV.typeWithSubtype(), TextFormat.CSV,\n+            Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\",\n+                \"delimiter\", \"[^\\\"\\n\\r\\t]+\"))", "originalCommit": "4134d92ef9ea93c205746bc2f5031ee40c1d579e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1MTQ3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r499451472", "bodyText": "good point, I misread that method. It should only be one character.\nThe exception messages are indeed explanatory in this method. With the parameter validation when parsing, we will loose them - that code will not be reachable as it will fail earlier when parsing", "author": "pgomulka", "createdAt": "2020-10-05T09:11:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3OTAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU2MDI3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r499560277", "bodyText": "I changed this to expect the presence of a delimiter parameter, but the pattern will be .+ which will always pass, and the validation will be done in TextFormat.CSV#delimiter()", "author": "pgomulka", "createdAt": "2020-10-05T12:28:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3OTAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg4MjMzNg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r498882336", "bodyText": "nit, spacing\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else if (request.hasParam(URL_PARAM_FORMAT)){\n          \n          \n            \n                        return validateColumnarRequest(sqlRequest.columnar(), parser.fromFormat( request.param(URL_PARAM_FORMAT)));\n          \n          \n            \n                    } else if (request.hasParam(URL_PARAM_FORMAT)) {\n          \n          \n            \n                        return validateColumnarRequest(sqlRequest.columnar(), parser.fromFormat(request.param(URL_PARAM_FORMAT)));", "author": "bpintea", "createdAt": "2020-10-02T15:10:09Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.plugin;\n+\n+import org.elasticsearch.common.xcontent.MediaType;\n+import org.elasticsearch.common.xcontent.MediaTypeParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.xpack.sql.action.SqlQueryRequest;\n+import org.elasticsearch.xpack.sql.proto.Mode;\n+\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.sql.proto.Protocol.URL_PARAM_FORMAT;\n+\n+public class SqlMediaTypeParser {\n+    private static final MediaTypeParser<? extends MediaType> parser = new MediaTypeParser.Builder<>()\n+        .copyFromMediaTypeParser(XContentType.mediaTypeParser)\n+        .withMediaTypeAndParams(TextFormat.PLAIN_TEXT.typeWithSubtype(), TextFormat.PLAIN_TEXT,\n+            Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\"))\n+        .withMediaTypeAndParams(TextFormat.CSV.typeWithSubtype(), TextFormat.CSV,\n+            Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\",\n+                \"delimiter\", \"[^\\\"\\n\\r\\t]+\"))\n+        .withMediaTypeAndParams(TextFormat.TSV.typeWithSubtype(), TextFormat.TSV,\n+            Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\"))\n+        .build();\n+\n+    /*\n+     * Since we support {@link TextFormat} <strong>and</strong>\n+     * {@link XContent} outputs we can't use {@link RestToXContentListener}\n+     * like everything else. We want to stick as closely as possible to\n+     * Elasticsearch's defaults though, while still layering in ways to\n+     * control the output more easily.\n+     *\n+     * First we find the string that the user used to specify the response\n+     * format. If there is a {@code format} parameter we use that. If there\n+     * isn't but there is a {@code Accept} header then we use that. If there\n+     * isn't then we use the {@code Content-Type} header which is required.\n+     */\n+    public MediaType getMediaType(RestRequest request, SqlQueryRequest sqlRequest) {\n+\n+        if (Mode.isDedicatedClient(sqlRequest.requestInfo().mode())\n+            && (sqlRequest.binaryCommunication() == null || sqlRequest.binaryCommunication())) {\n+            // enforce CBOR response for drivers and CLI (unless instructed differently through the config param)\n+            return XContentType.CBOR;\n+        } else if (request.hasParam(URL_PARAM_FORMAT)){\n+            return validateColumnarRequest(sqlRequest.columnar(), parser.fromFormat( request.param(URL_PARAM_FORMAT)));", "originalCommit": "4134d92ef9ea93c205746bc2f5031ee40c1d579e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg4ODM1MA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r498888350", "bodyText": "optional, could be made static.", "author": "bpintea", "createdAt": "2020-10-02T15:20:22Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.plugin;\n+\n+import org.elasticsearch.common.xcontent.MediaType;\n+import org.elasticsearch.common.xcontent.MediaTypeParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.xpack.sql.action.SqlQueryRequest;\n+import org.elasticsearch.xpack.sql.proto.Mode;\n+\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.sql.proto.Protocol.URL_PARAM_FORMAT;\n+\n+public class SqlMediaTypeParser {\n+    private static final MediaTypeParser<? extends MediaType> parser = new MediaTypeParser.Builder<>()\n+        .copyFromMediaTypeParser(XContentType.mediaTypeParser)\n+        .withMediaTypeAndParams(TextFormat.PLAIN_TEXT.typeWithSubtype(), TextFormat.PLAIN_TEXT,\n+            Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\"))\n+        .withMediaTypeAndParams(TextFormat.CSV.typeWithSubtype(), TextFormat.CSV,\n+            Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\",\n+                \"delimiter\", \"[^\\\"\\n\\r\\t]+\"))\n+        .withMediaTypeAndParams(TextFormat.TSV.typeWithSubtype(), TextFormat.TSV,\n+            Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\"))\n+        .build();\n+\n+    /*\n+     * Since we support {@link TextFormat} <strong>and</strong>\n+     * {@link XContent} outputs we can't use {@link RestToXContentListener}\n+     * like everything else. We want to stick as closely as possible to\n+     * Elasticsearch's defaults though, while still layering in ways to\n+     * control the output more easily.\n+     *\n+     * First we find the string that the user used to specify the response\n+     * format. If there is a {@code format} parameter we use that. If there\n+     * isn't but there is a {@code Accept} header then we use that. If there\n+     * isn't then we use the {@code Content-Type} header which is required.\n+     */\n+    public MediaType getMediaType(RestRequest request, SqlQueryRequest sqlRequest) {\n+\n+        if (Mode.isDedicatedClient(sqlRequest.requestInfo().mode())\n+            && (sqlRequest.binaryCommunication() == null || sqlRequest.binaryCommunication())) {\n+            // enforce CBOR response for drivers and CLI (unless instructed differently through the config param)\n+            return XContentType.CBOR;\n+        } else if (request.hasParam(URL_PARAM_FORMAT)){\n+            return validateColumnarRequest(sqlRequest.columnar(), parser.fromFormat( request.param(URL_PARAM_FORMAT)));\n+        }\n+        if (request.getHeaders().containsKey(\"Accept\")) {\n+            String accept = request.header(\"Accept\");\n+            // */* means \"I don't care\" which we should treat like not specifying the header\n+            if (\"*/*\".equals(accept) == false) {\n+                return validateColumnarRequest(sqlRequest.columnar(), parser.fromMediaType(accept));\n+            }\n+        }\n+\n+        String contentType = request.header(\"Content-Type\");\n+        assert contentType != null : \"The Content-Type header is required\";\n+        return validateColumnarRequest(sqlRequest.columnar(), parser.fromMediaType(contentType));\n+    }\n+\n+    private MediaType validateColumnarRequest(boolean requestIsColumnar, MediaType fromMediaType) {", "originalCommit": "4134d92ef9ea93c205746bc2f5031ee40c1d579e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkwOTU1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r498909556", "bodyText": "Since the methods only tests media type correct detection - i.e. the other parameters in the Accept aren't analysed by SqlMediaTypeParser, nor tested here, right? -, I would maybe propose to rename it (testMediaTypeDetection or similar?).\n(Slightly off-topic, the header parameter will need a rework or removal, as per #60271, but that's not the object of this PR).", "author": "bpintea", "createdAt": "2020-10-02T15:57:49Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParserTests.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.plugin;\n+\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.MediaType;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.rest.FakeRestRequest;\n+import org.elasticsearch.xpack.sql.action.SqlQueryRequest;\n+import org.elasticsearch.xpack.sql.proto.Mode;\n+import org.elasticsearch.xpack.sql.proto.RequestInfo;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.sql.plugin.TextFormat.CSV;\n+import static org.elasticsearch.xpack.sql.plugin.TextFormat.PLAIN_TEXT;\n+import static org.elasticsearch.xpack.sql.plugin.TextFormat.TSV;\n+import static org.elasticsearch.xpack.sql.proto.RequestInfo.CLIENT_IDS;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+\n+public class SqlMediaTypeParserTests extends ESTestCase {\n+    SqlMediaTypeParser parser = new SqlMediaTypeParser();\n+\n+    public void testPlainTextDetection() {\n+        MediaType text = parser.getMediaType(reqWithAccept(\"text/plain\"), createTestInstance(false, Mode.PLAIN, false));\n+        assertThat(text, is(PLAIN_TEXT));\n+    }\n+\n+    public void testCsvDetection() {\n+        MediaType text = parser.getMediaType(reqWithAccept(\"text/csv\"), createTestInstance(false, Mode.PLAIN, false));\n+        assertThat(text, is(CSV));\n+    }\n+\n+    public void testTsvDetection() {\n+        MediaType text = parser.getMediaType(reqWithAccept(\"text/tab-separated-values\"), createTestInstance(false, Mode.PLAIN, false));\n+        assertThat(text, is(TSV));\n+    }\n+\n+    public void testParametersParsing() {", "originalCommit": "4134d92ef9ea93c205746bc2f5031ee40c1d579e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a976f5b53d024edf45b5e583130f53f65184ffd9", "url": "https://github.com/elastic/elasticsearch/commit/a976f5b53d024edf45b5e583130f53f65184ffd9", "message": "Apply suggestions from code review\n\nCo-authored-by: Bogdan Pintea <bpintea@gmail.com>", "committedDate": "2020-10-05T09:11:33Z", "type": "commit"}, {"oid": "3e0eec01383a9cbb7ec2f5e858149a93848ae8d6", "url": "https://github.com/elastic/elasticsearch/commit/3e0eec01383a9cbb7ec2f5e858149a93848ae8d6", "message": "relax delimiter validation", "committedDate": "2020-10-05T12:09:59Z", "type": "commit"}]}