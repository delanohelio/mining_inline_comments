{"pr_number": 51100, "pr_title": "Add NestedPathFieldMapper to store nested path information", "pr_createdAt": "2020-01-16T13:45:37Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51100", "timeline": [{"oid": "35a8c50b023e28dfc073cf039eec53e74db3ac38", "url": "https://github.com/elastic/elasticsearch/commit/35a8c50b023e28dfc073cf039eec53e74db3ac38", "message": "Add new NestedPathFieldMapper, migrate nested docs to use it rather than type field", "committedDate": "2020-01-16T13:07:46Z", "type": "commit"}, {"oid": "89c13b7bcbebf1470a345659fa2477546aa59c3c", "url": "https://github.com/elastic/elasticsearch/commit/89c13b7bcbebf1470a345659fa2477546aa59c3c", "message": "Don't add nested field mapper for pre-8 indexes, as this breaks mapping updates due to the _type field being overloaded", "committedDate": "2020-01-16T14:42:13Z", "type": "commit"}, {"oid": "894bb528ae1c8ac54adad76a34f17ce26f831e75", "url": "https://github.com/elastic/elasticsearch/commit/894bb528ae1c8ac54adad76a34f17ce26f831e75", "message": "test different built-in mapper counts on different versions", "committedDate": "2020-01-16T15:30:45Z", "type": "commit"}, {"oid": "39d2d1a85354ab7fda08ba0e5de032f535dffd8c", "url": "https://github.com/elastic/elasticsearch/commit/39d2d1a85354ab7fda08ba0e5de032f535dffd8c", "message": "doh", "committedDate": "2020-01-16T16:34:44Z", "type": "commit"}, {"oid": "0fff0cfd2dade3274c601991809ea9340599ad3d", "url": "https://github.com/elastic/elasticsearch/commit/0fff0cfd2dade3274c601991809ea9340599ad3d", "message": "Adjust isMetaDataField test to take version into account", "committedDate": "2020-01-17T09:04:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTIwNg==", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367835206", "bodyText": "should we disallow fielddata on this field ? It's an implementation details and I am not sure that we want to expose it in aggs or sorting ?", "author": "jimczi", "createdAt": "2020-01-17T09:17:07Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.SortedSetDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.lucene.Lucene;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.plain.ConstantIndexFieldData;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public class NestedPathFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME_PRE_V8 = \"_type\";\n+    public static final String NAME = \"_nested_path\";\n+\n+    public static String name(Settings settings) {\n+        if (Version.indexCreated(settings).before(Version.V_8_0_0)) {\n+            return NAME_PRE_V8;\n+        }\n+        return NAME;\n+    }\n+\n+    public static Query filter(Settings settings, String path) {\n+        return new TermQuery(new Term(name(settings), new BytesRef(path)));\n+    }\n+\n+    public static Field field(Settings settings, String path) {\n+        return new Field(name(settings), path, Defaults.FIELD_TYPE);\n+    }\n+\n+    public static class Defaults {\n+\n+        public static final MappedFieldType FIELD_TYPE = new NestedPathFieldType();\n+\n+        static {\n+            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setStored(false);\n+            FIELD_TYPE.setOmitNorms(true);\n+            FIELD_TYPE.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+        @Override\n+        public MetadataFieldMapper.Builder<?,?> parse(String name, Map<String, Object> node,\n+                                                      ParserContext parserContext) throws MapperParsingException {\n+            throw new MapperParsingException(name(parserContext.mapperService().getIndexSettings().getSettings()) + \" is not configurable\");\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {\n+            final IndexSettings indexSettings = context.mapperService().getIndexSettings();\n+            return new NestedPathFieldMapper(indexSettings, fieldType);\n+        }\n+    }\n+\n+    public static final class NestedPathFieldType extends StringFieldType {\n+\n+        NestedPathFieldType() {\n+        }\n+\n+        protected NestedPathFieldType(NestedPathFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new NestedPathFieldType(this);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+            Function<MapperService, String> typeFunction = mapperService -> mapperService.documentMapper().type();", "originalCommit": "0fff0cfd2dade3274c601991809ea9340599ad3d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTQxOA==", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367835418", "bodyText": "Maybe keep it only for indices created before 8 to handle bwc ?", "author": "jimczi", "createdAt": "2020-01-17T09:17:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTIwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3OTE0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367879147", "bodyText": "I'll remove it - indices created before 8 still use TypeFieldMapper, so BWC is handled that way", "author": "romseygeek", "createdAt": "2020-01-17T10:57:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTIwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU0MjIxMw==", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r368542213", "bodyText": "I pushed 7ea0da8", "author": "romseygeek", "createdAt": "2020-01-20T13:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTkwNw==", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367835907", "bodyText": "Can you switch to the NestedPathFieldMapper.TypeParser in this pr since you handle bwc in the new field type ?", "author": "jimczi", "createdAt": "2020-01-17T09:18:56Z", "path": "server/src/main/java/org/elasticsearch/indices/IndicesModule.java", "diffHunk": "@@ -157,6 +158,7 @@ public IndicesModule(List<MapperPlugin> mapperPlugins) {\n         builtInMetadataMappers.put(IndexFieldMapper.NAME, new IndexFieldMapper.TypeParser());\n         builtInMetadataMappers.put(SourceFieldMapper.NAME, new SourceFieldMapper.TypeParser());\n         builtInMetadataMappers.put(TypeFieldMapper.NAME, new TypeFieldMapper.TypeParser());", "originalCommit": "0fff0cfd2dade3274c601991809ea9340599ad3d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0NTAwNA==", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367845004", "bodyText": "We may be able to in future, but I think we need to keep TypeFieldMapper around for the moment because it's still used for type queries, etc.", "author": "romseygeek", "createdAt": "2020-01-17T09:39:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTkwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4NjgzNw==", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367986837", "bodyText": "Ok I was confused because there are some logic to handle bwc in NestedPathFieldMapper.", "author": "jimczi", "createdAt": "2020-01-17T15:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTkwNw=="}], "type": "inlineReview"}, {"oid": "81c36c77d46370278cd8fb5d086b5ff89980a420", "url": "https://github.com/elastic/elasticsearch/commit/81c36c77d46370278cd8fb5d086b5ff89980a420", "message": "Merge remote-tracking branch 'origin/master' into types-removal/nested-field-mapper", "committedDate": "2020-01-17T09:44:20Z", "type": "commit"}, {"oid": "bba4d6a284ac875f799e1f6d8a4389e76632f776", "url": "https://github.com/elastic/elasticsearch/commit/bba4d6a284ac875f799e1f6d8a4389e76632f776", "message": "Merge remote-tracking branch 'origin/master' into types-removal/nested-field-mapper", "committedDate": "2020-01-17T10:15:36Z", "type": "commit"}, {"oid": "7ea0da8acc167f8549d0ab77816c9717e5d2334b", "url": "https://github.com/elastic/elasticsearch/commit/7ea0da8acc167f8549d0ab77816c9717e5d2334b", "message": "No fielddata on nested path", "committedDate": "2020-01-17T10:58:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4NjI1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367986256", "bodyText": "For indices created in v8 we don't need to add any prefix since we use a dedicated field ?", "author": "jimczi", "createdAt": "2020-01-17T15:14:48Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/ObjectMapper.java", "diffHunk": "@@ -335,9 +331,8 @@ protected static void parseProperties(ObjectMapper.Builder objBuilder, Map<Strin\n         } else {\n             this.mappers = CopyOnWriteHashMap.copyOf(mappers);\n         }\n-        this.nestedTypePathAsString = \"__\" + fullPath;\n-        this.nestedTypePathAsBytes = new BytesRef(nestedTypePathAsString);\n-        this.nestedTypeFilter = new TermQuery(new Term(TypeFieldMapper.NAME, nestedTypePathAsBytes));\n+        this.nestedTypePath = \"__\" + fullPath;", "originalCommit": "7ea0da8acc167f8549d0ab77816c9717e5d2334b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU0MjA5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r368542096", "bodyText": "++ I pushed 7ea0da8", "author": "romseygeek", "createdAt": "2020-01-20T13:17:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4NjI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4OTkxNw==", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367989917", "bodyText": "I don't think we need to index root document in this field. We use the nested path to find nested documents but we don't use this field to detect root documents so this indexing would be redundant ?", "author": "jimczi", "createdAt": "2020-01-17T15:21:43Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.SortedSetDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.lucene.Lucene;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class NestedPathFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME_PRE_V8 = \"_type\";\n+    public static final String NAME = \"_nested_path\";\n+\n+    public static String name(Settings settings) {\n+        if (Version.indexCreated(settings).before(Version.V_8_0_0)) {\n+            return NAME_PRE_V8;\n+        }\n+        return NAME;\n+    }\n+\n+    public static Query filter(Settings settings, String path) {\n+        return new TermQuery(new Term(name(settings), new BytesRef(path)));\n+    }\n+\n+    public static Field field(Settings settings, String path) {\n+        return new Field(name(settings), path, Defaults.FIELD_TYPE);\n+    }\n+\n+    public static class Defaults {\n+\n+        public static final MappedFieldType FIELD_TYPE = new NestedPathFieldType();\n+\n+        static {\n+            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setStored(false);\n+            FIELD_TYPE.setOmitNorms(true);\n+            FIELD_TYPE.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+        @Override\n+        public MetadataFieldMapper.Builder<?,?> parse(String name, Map<String, Object> node,\n+                                                      ParserContext parserContext) throws MapperParsingException {\n+            throw new MapperParsingException(name(parserContext.mapperService().getIndexSettings().getSettings()) + \" is not configurable\");\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {\n+            final IndexSettings indexSettings = context.mapperService().getIndexSettings();\n+            return new NestedPathFieldMapper(indexSettings, fieldType);\n+        }\n+    }\n+\n+    public static final class NestedPathFieldType extends StringFieldType {\n+\n+        NestedPathFieldType() {\n+        }\n+\n+        protected NestedPathFieldType(NestedPathFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new NestedPathFieldType(this);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public boolean isSearchable() {\n+            return true;\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new UnsupportedOperationException(\"Cannot run exists() query against the nested field path\");\n+        }\n+    }\n+\n+    private NestedPathFieldMapper(IndexSettings indexSettings, MappedFieldType existing) {\n+        this(existing == null ? defaultFieldType(indexSettings) : existing.clone(),\n+            indexSettings);\n+    }\n+\n+    private NestedPathFieldMapper(MappedFieldType fieldType, IndexSettings indexSettings) {\n+        super(name(indexSettings.getSettings()), fieldType, defaultFieldType(indexSettings), indexSettings.getSettings());\n+    }\n+\n+    private static MappedFieldType defaultFieldType(IndexSettings indexSettings) {\n+        MappedFieldType defaultFieldType = Defaults.FIELD_TYPE.clone();\n+        defaultFieldType.setIndexOptions(IndexOptions.NONE);\n+        defaultFieldType.setHasDocValues(false);\n+        defaultFieldType.setName(name(indexSettings.getSettings()));\n+        return defaultFieldType;\n+    }\n+\n+    @Override\n+    public void preParse(ParseContext context) throws IOException {\n+        super.parse(context);\n+    }\n+\n+    @Override\n+    public void parse(ParseContext context) throws IOException {\n+        // we parse in pre parse\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {\n+        if (fieldType().indexOptions() == IndexOptions.NONE && !fieldType().stored()) {\n+            return;\n+        }\n+        fields.add(new Field(fieldType().name(), MapperService.SINGLE_MAPPING_NAME, fieldType()));\n+        if (fieldType().hasDocValues()) {\n+            fields.add(new SortedSetDocValuesField(fieldType().name(), new BytesRef(MapperService.SINGLE_MAPPING_NAME)));\n+        }", "originalCommit": "7ea0da8acc167f8549d0ab77816c9717e5d2334b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU0MjMwNA==", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r368542304", "bodyText": "++ I pushed 7ea0da8", "author": "romseygeek", "createdAt": "2020-01-20T13:18:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4OTkxNw=="}], "type": "inlineReview"}, {"oid": "03029007738f878fe6b4363a6e6e50bc9f1eca80", "url": "https://github.com/elastic/elasticsearch/commit/03029007738f878fe6b4363a6e6e50bc9f1eca80", "message": "feedback", "committedDate": "2020-01-17T16:20:03Z", "type": "commit"}, {"oid": "e59a3297806df9532e8130abd2475618b4d04971", "url": "https://github.com/elastic/elasticsearch/commit/e59a3297806df9532e8130abd2475618b4d04971", "message": "Merge branch 'master' into types-removal/nested-field-mapper", "committedDate": "2020-01-20T10:58:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4MzkyMg==", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r369583922", "bodyText": "I think you need to preserve the sort order ?", "author": "jimczi", "createdAt": "2020-01-22T14:17:11Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/MapperService.java", "diffHunk": "@@ -118,7 +118,7 @@\n     //TODO this needs to be cleaned up: _timestamp and _ttl are not supported anymore, _field_names, _seq_no, _version and _source are\n     //also missing, not sure if on purpose. See IndicesModule#getMetadataMappers\n     private static final String[] SORTED_META_FIELDS = new String[]{\n-        \"_id\", IgnoredFieldMapper.NAME, \"_index\", \"_routing\", \"_size\", \"_timestamp\", \"_ttl\", \"_type\"\n+        \"_id\", IgnoredFieldMapper.NAME, \"_index\", \"_routing\", \"_size\", \"_timestamp\", \"_ttl\", \"_type\", \"_nested_path\"", "originalCommit": "e59a3297806df9532e8130abd2475618b4d04971", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4OTM5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r369589393", "bodyText": "++, will fix.  I had a look at fixing the TODO above, but it's not all that straightforward unfortunately.", "author": "romseygeek", "createdAt": "2020-01-22T14:25:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4MzkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4NDM1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r369584357", "bodyText": "Should it bee IndexOptions.NONE ?", "author": "jimczi", "createdAt": "2020-01-22T14:17:55Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.lucene.Lucene;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class NestedPathFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME_PRE_V8 = \"_type\";\n+    public static final String NAME = \"_nested_path\";\n+\n+    public static String name(Settings settings) {\n+        if (Version.indexCreated(settings).before(Version.V_8_0_0)) {\n+            return NAME_PRE_V8;\n+        }\n+        return NAME;\n+    }\n+\n+    public static Query filter(Settings settings, String path) {\n+        return new TermQuery(new Term(name(settings), new BytesRef(path)));\n+    }\n+\n+    public static Field field(Settings settings, String path) {\n+        return new Field(name(settings), path, Defaults.FIELD_TYPE);\n+    }\n+\n+    public static class Defaults {\n+\n+        public static final MappedFieldType FIELD_TYPE = new NestedPathFieldType();\n+\n+        static {\n+            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);", "originalCommit": "e59a3297806df9532e8130abd2475618b4d04971", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4OTA3OA==", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r369589078", "bodyText": "We still need to search against it, so we need to store matching docs, unless I'm misunderstanding something?", "author": "romseygeek", "createdAt": "2020-01-22T14:25:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4NDM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU5MTYxNA==", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r369591614", "bodyText": "you're right, I mixed this with doc values, sorry for the noise.", "author": "jimczi", "createdAt": "2020-01-22T14:29:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4NDM1Nw=="}], "type": "inlineReview"}, {"oid": "befa0ec9b5fed808c8e4922e29d663d9d529cb46", "url": "https://github.com/elastic/elasticsearch/commit/befa0ec9b5fed808c8e4922e29d663d9d529cb46", "message": "Merge remote-tracking branch 'origin/master' into types-removal/nested-field-mapper", "committedDate": "2020-01-22T14:42:12Z", "type": "commit"}, {"oid": "b90105d14898dda83d27dd100f0b4806809f8bf3", "url": "https://github.com/elastic/elasticsearch/commit/b90105d14898dda83d27dd100f0b4806809f8bf3", "message": "Fix sort order", "committedDate": "2020-01-22T14:43:03Z", "type": "commit"}, {"oid": "7d21c65cf56ad92d0a36b18a66790345870264d4", "url": "https://github.com/elastic/elasticsearch/commit/7d21c65cf56ad92d0a36b18a66790345870264d4", "message": "Merge remote-tracking branch 'romseygeek/types-removal/nested-field-mapper' into types-removal/nested-field-mapper", "committedDate": "2020-01-22T14:43:37Z", "type": "commit"}, {"oid": "ad8ac4d444761bf89790beb57b01cb7b95ab57d3", "url": "https://github.com/elastic/elasticsearch/commit/ad8ac4d444761bf89790beb57b01cb7b95ab57d3", "message": "compilation", "committedDate": "2020-01-22T15:09:49Z", "type": "commit"}, {"oid": "bafb96b8013e303a39d0853030dae214ef20bb7f", "url": "https://github.com/elastic/elasticsearch/commit/bafb96b8013e303a39d0853030dae214ef20bb7f", "message": "fieldtype", "committedDate": "2020-01-22T15:41:21Z", "type": "commit"}]}