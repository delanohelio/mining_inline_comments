{"pr_number": 55683, "pr_title": "Save memory in on aggs in async search", "pr_createdAt": "2020-04-23T16:21:38Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55683", "timeline": [{"oid": "b78976bbb7963b633a9fb6bd6b9ebd40f74824a6", "url": "https://github.com/elastic/elasticsearch/commit/b78976bbb7963b633a9fb6bd6b9ebd40f74824a6", "message": "Save memory in on aggs in async search\n\nThis replaces a reference to the result of partially reducing\naggregations that async search keeps with a reference to the serialized\nform of the result of the partial reduction which we need to keep\nanyway.", "committedDate": "2020-04-23T16:18:25Z", "type": "commit"}, {"oid": "01e583414fd37528f5037c7574bc390a48a6cb11", "url": "https://github.com/elastic/elasticsearch/commit/01e583414fd37528f5037c7574bc390a48a6cb11", "message": "Merge branch 'master' into delay_async_aggs_take_two", "committedDate": "2020-04-23T16:59:35Z", "type": "commit"}, {"oid": "8314fc8c766cf03fd0b70d6a5a476723587092d3", "url": "https://github.com/elastic/elasticsearch/commit/8314fc8c766cf03fd0b70d6a5a476723587092d3", "message": "Sneaky", "committedDate": "2020-04-23T17:38:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MjgxOA==", "url": "https://github.com/elastic/elasticsearch/pull/55683#discussion_r414842818", "bodyText": "Why do we apply a top level reduce here ? We want it to be applied on demand (when the user gets a partial response) in order to avoid doing work when it's not needed. We should keep the pointer to the serialized aggs so that we don't double the memory in async search ?", "author": "jimczi", "createdAt": "2020-04-24T20:26:36Z", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/AsyncSearchTask.java", "diffHunk": "@@ -354,32 +355,30 @@ protected void onListShards(List<SearchShard> shards, List<SearchShard> skipped,\n             // best effort to cancel expired tasks\n             checkCancellation();\n             searchResponse.compareAndSet(null,\n-                new MutableSearchResponse(shards.size() + skipped.size(), skipped.size(), clusters,\n-                    aggReduceContextSupplier, threadPool.getThreadContext()));\n+                new MutableSearchResponse(shards.size() + skipped.size(), skipped.size(), clusters, threadPool.getThreadContext()));\n             executeInitListeners();\n         }\n \n         @Override\n-        public void onPartialReduce(List<SearchShard> shards, TotalHits totalHits, InternalAggregations aggs, int reducePhase) {\n+        public void onPartialReduce(List<SearchShard> shards, TotalHits totalHits,\n+                DelayableWriteable.Serialized<InternalAggregations> aggregations, int reducePhase) {\n             // best effort to cancel expired tasks\n             checkCancellation();\n-            searchResponse.get().updatePartialResponse(shards.size(),\n-                new InternalSearchResponse(new SearchHits(SearchHits.EMPTY, totalHits, Float.NaN), aggs,\n-                    null, null, false, null, reducePhase), aggs == null);\n+            Supplier<InternalAggregations> reducedAggs = () -> aggregations == null ?\n+                    null : InternalAggregations.topLevelReduce(singletonList(aggregations.get()), aggReduceContextSupplier.get());", "originalCommit": "8314fc8c766cf03fd0b70d6a5a476723587092d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0OTMzNw==", "url": "https://github.com/elastic/elasticsearch/pull/55683#discussion_r414849337", "bodyText": "It is on demand via the Supplier<> foo = () -> part. At least, I thought it was.", "author": "nik9000", "createdAt": "2020-04-24T20:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MjgxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg1MTczOA==", "url": "https://github.com/elastic/elasticsearch/pull/55683#discussion_r414851738", "bodyText": "I understand now, the final reduce is a supplier. Although the () -> aggregations == null is hard to read, maybe rewrite it into () -> (aggregations == null) ?", "author": "jimczi", "createdAt": "2020-04-24T20:43:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MjgxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg2MzE5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55683#discussion_r414863191", "bodyText": "I'll rewrite it with good stuff like comments!", "author": "nik9000", "createdAt": "2020-04-24T21:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MjgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MzM3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55683#discussion_r414843371", "bodyText": "We should still apply the final reduce here.", "author": "jimczi", "createdAt": "2020-04-24T20:27:44Z", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -141,23 +130,35 @@ void addShardFailure(int shardIndex, ShardSearchFailure failure) {\n      * This method is synchronized to ensure that we don't perform final reduces concurrently.\n      */\n     synchronized AsyncSearchResponse toAsyncSearchResponse(AsyncSearchTask task, long expirationTime) {\n-        final SearchResponse resp;\n-        if (totalShards != -1) {\n-            if (sections.aggregations() != null && isFinalReduce == false) {", "originalCommit": "8314fc8c766cf03fd0b70d6a5a476723587092d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg1MjQwNw==", "url": "https://github.com/elastic/elasticsearch/pull/55683#discussion_r414852407", "bodyText": "It's applied below.", "author": "jimczi", "createdAt": "2020-04-24T20:45:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MzM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0Mzc1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55683#discussion_r414843759", "bodyText": "Where are we reducing the aggs ?", "author": "jimczi", "createdAt": "2020-04-24T20:28:30Z", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -141,23 +130,35 @@ void addShardFailure(int shardIndex, ShardSearchFailure failure) {\n      * This method is synchronized to ensure that we don't perform final reduces concurrently.\n      */\n     synchronized AsyncSearchResponse toAsyncSearchResponse(AsyncSearchTask task, long expirationTime) {\n-        final SearchResponse resp;\n-        if (totalShards != -1) {\n-            if (sections.aggregations() != null && isFinalReduce == false) {\n-                InternalAggregations oldAggs = (InternalAggregations) sections.aggregations();\n-                InternalAggregations newAggs = topLevelReduce(singletonList(oldAggs), aggReduceContextSupplier.get());\n-                sections = new InternalSearchResponse(sections.hits(), newAggs, sections.suggest(),\n-                    null, sections.timedOut(), sections.terminatedEarly(), sections.getNumReducePhases());\n-                isFinalReduce = true;\n-            }\n-            long tookInMillis = TimeValue.timeValueNanos(System.nanoTime() - task.getStartTimeNanos()).getMillis();\n-            resp = new SearchResponse(sections, null, totalShards, successfulShards,\n-                skippedShards, tookInMillis, buildShardFailures(), clusters);\n-        } else {\n-            resp = null;\n+        SearchResponse response = findOrBuildResponse(task);\n+        return new AsyncSearchResponse(task.getSearchId().getEncoded(), response,\n+                failure, isPartial, frozen == false, task.getStartTime(), expirationTime);\n+    }\n+\n+    private SearchResponse findOrBuildResponse(AsyncSearchTask task) {\n+        if (finalResponse != null) {\n+            // We have a final response, use it.\n+            return finalResponse;\n+        }\n+        if (clusters == null) {\n+            // An error occurred before we got the shard list \n+            return null;\n         }\n-        return new AsyncSearchResponse(task.getSearchId().getEncoded(), resp, failure, isPartial,\n-            frozen == false, task.getStartTime(), expirationTime);\n+        /*\n+         * Build the response, reducing aggs if we haven't already and", "originalCommit": "8314fc8c766cf03fd0b70d6a5a476723587092d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg1MjI0MA==", "url": "https://github.com/elastic/elasticsearch/pull/55683#discussion_r414852240", "bodyText": "My bad, I did not understand what the supplier was doing. It's all clear now.", "author": "jimczi", "createdAt": "2020-04-24T20:44:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0Mzc1OQ=="}], "type": "inlineReview"}, {"oid": "bec12053ec4ea827780874a78bde33ac06da4f64", "url": "https://github.com/elastic/elasticsearch/commit/bec12053ec4ea827780874a78bde33ac06da4f64", "message": "Merge branch 'master' into delay_async_aggs_take_two", "committedDate": "2020-04-24T21:01:44Z", "type": "commit"}, {"oid": "b32dd2edc573a8fad12a2d1fb97e0de320735662", "url": "https://github.com/elastic/elasticsearch/commit/b32dd2edc573a8fad12a2d1fb97e0de320735662", "message": "Protip: don't commit diff markers", "committedDate": "2020-04-24T21:07:54Z", "type": "commit"}, {"oid": "3ef2cc096b83ba3056596c6cd8ac796bf0720de5", "url": "https://github.com/elastic/elasticsearch/commit/3ef2cc096b83ba3056596c6cd8ac796bf0720de5", "message": "Fixup test", "committedDate": "2020-04-28T12:56:46Z", "type": "commit"}, {"oid": "0a5405684d7fcb67e8ce217444e7ff63b4ce5320", "url": "https://github.com/elastic/elasticsearch/commit/0a5405684d7fcb67e8ce217444e7ff63b4ce5320", "message": "I mean it this time", "committedDate": "2020-04-28T13:45:28Z", "type": "commit"}, {"oid": "3184e3d4d729badcc0de95f9bb9cc66ce0b349d9", "url": "https://github.com/elastic/elasticsearch/commit/3184e3d4d729badcc0de95f9bb9cc66ce0b349d9", "message": "Merge branch 'master' into delay_async_aggs_take_two", "committedDate": "2020-04-28T14:34:12Z", "type": "commit"}]}