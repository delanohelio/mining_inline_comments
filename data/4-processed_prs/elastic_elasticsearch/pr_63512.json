{"pr_number": 63512, "pr_title": "Move write out of ir nodes and into an external phase", "pr_createdAt": "2020-10-08T21:38:53Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/63512", "timeline": [{"oid": "0a1b5ed092704a1c25d1509213b16966d263c9c1", "url": "https://github.com/elastic/elasticsearch/commit/0a1b5ed092704a1c25d1509213b16966d263c9c1", "message": "make location final in IRNode", "committedDate": "2020-09-26T16:39:29Z", "type": "commit"}, {"oid": "7d62d0752fb2a99ae998fcab291c0f709bded0f5", "url": "https://github.com/elastic/elasticsearch/commit/7d62d0752fb2a99ae998fcab291c0f709bded0f5", "message": "add scoping for script, class, and method to WriteScope", "committedDate": "2020-09-26T17:18:49Z", "type": "commit"}, {"oid": "712b0a8965bba0939acd0f8e73932796eddc7238", "url": "https://github.com/elastic/elasticsearch/commit/712b0a8965bba0939acd0f8e73932796eddc7238", "message": "update scope to include classwriter and methodwriter", "committedDate": "2020-09-26T17:36:01Z", "type": "commit"}, {"oid": "8e38647855a1c5cca0c30a3f7e43f71c5d164edf", "url": "https://github.com/elastic/elasticsearch/commit/8e38647855a1c5cca0c30a3f7e43f71c5d164edf", "message": "move loop labels to writescope", "committedDate": "2020-09-26T17:56:22Z", "type": "commit"}, {"oid": "65502b186dbd52a0c784a52a83b1fb659e3a6abc", "url": "https://github.com/elastic/elasticsearch/commit/65502b186dbd52a0c784a52a83b1fb659e3a6abc", "message": "move try/catch labels to WriteScope", "committedDate": "2020-09-26T18:22:52Z", "type": "commit"}, {"oid": "7231b5ebd24838d08a18b46615849ab7842667eb", "url": "https://github.com/elastic/elasticsearch/commit/7231b5ebd24838d08a18b46615849ab7842667eb", "message": "move write to an external phase", "committedDate": "2020-09-26T20:26:14Z", "type": "commit"}, {"oid": "ae8d2a1f12069641171f0013205b5887c7dfcd6a", "url": "https://github.com/elastic/elasticsearch/commit/ae8d2a1f12069641171f0013205b5887c7dfcd6a", "message": "Merge branch 'master' into proto", "committedDate": "2020-09-30T14:38:56Z", "type": "commit"}, {"oid": "760b9b940997249b18947d6da787d338f2a9dc38", "url": "https://github.com/elastic/elasticsearch/commit/760b9b940997249b18947d6da787d338f2a9dc38", "message": "Merge branch 'master' into proto", "committedDate": "2020-10-05T16:36:09Z", "type": "commit"}, {"oid": "b0320fe53e81db05b2d0b571bb34fb92af6e57c5", "url": "https://github.com/elastic/elasticsearch/commit/b0320fe53e81db05b2d0b571bb34fb92af6e57c5", "message": "Merge branch 'proto' into proto2", "committedDate": "2020-10-05T17:04:18Z", "type": "commit"}, {"oid": "527afc40f1b3a96f97b63aaf64c0f2c908b9b97f", "url": "https://github.com/elastic/elasticsearch/commit/527afc40f1b3a96f97b63aaf64c0f2c908b9b97f", "message": "Merge branch 'master' into proto", "committedDate": "2020-10-08T19:53:15Z", "type": "commit"}, {"oid": "879afcac4496aa42f0d57c3485a94d11575bfe4c", "url": "https://github.com/elastic/elasticsearch/commit/879afcac4496aa42f0d57c3485a94d11575bfe4c", "message": "Merge branch 'proto' into proto2", "committedDate": "2020-10-08T19:53:23Z", "type": "commit"}, {"oid": "49397f77f269c06949af28d6a0b33e8f5d653018", "url": "https://github.com/elastic/elasticsearch/commit/49397f77f269c06949af28d6a0b33e8f5d653018", "message": "response to pr comments", "committedDate": "2020-10-08T20:17:35Z", "type": "commit"}, {"oid": "4c8082f74654dccabbb2ee339e9089623f445fb3", "url": "https://github.com/elastic/elasticsearch/commit/4c8082f74654dccabbb2ee339e9089623f445fb3", "message": "Merge branch 'master' into proto2", "committedDate": "2020-10-08T21:21:07Z", "type": "commit"}, {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141", "url": "https://github.com/elastic/elasticsearch/commit/883486155e6f1c304fe53b5c8ef09ee255964141", "message": "Merge branch 'proto2' into proto3", "committedDate": "2020-10-08T21:32:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU3NjIwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506576209", "bodyText": "Consider calling this visitCondition.", "author": "stu-elastic", "createdAt": "2020-10-16T16:09:02Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3MTQ3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506671479", "bodyText": "I'm concerned about mixing that up with conditional nodes. I agree this needs renaming, but I need to think about it so probably a follow up PR for this.", "author": "jdconrad", "createdAt": "2020-10-16T19:08:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU3NjIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU3ODQ1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506578453", "bodyText": "Do ya need this?", "author": "stu-elastic", "createdAt": "2020-10-16T16:12:57Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3MjAwOA==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506672008", "bodyText": "Follows the convention of the other external phases so I'd like to keep it. I think it encapsulates the specific phase in a nicer way than calling irXXXNode.visit(...) so I'm going to leave this for now.", "author": "jdconrad", "createdAt": "2020-10-16T19:09:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU3ODQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU3OTkyMA==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506579920", "bodyText": "Pull out some of these inline operations when calling this method, it's hard to read.", "author": "stu-elastic", "createdAt": "2020-10-16T16:15:27Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3Mzk4OA==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506673988", "bodyText": "Done.", "author": "jdconrad", "createdAt": "2020-10-16T19:14:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU3OTkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4MTEzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506581131", "bodyText": "Since MethodWriter.getType(irFlipDefIndexNode.getChildNode().getExpressionType())) is repeated, and it's fine to reuse, let's pull it out.", "author": "stu-elastic", "createdAt": "2020-10-16T16:17:26Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadDotShortcut(LoadDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irDotSubShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (!getterPainlessMethod.returnType.equals(getterPainlessMethod.javaMethod.getReturnType())) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadListShortcut(LoadListShortcutNode irLoadListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadListShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadListShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType == getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadMapShortcut(LoadMapShortcutNode irLoadMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadMapShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadMapShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType != getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadFieldMember(LoadFieldMemberNode irLoadFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadFieldMemberNode.getLocation());\n+\n+        if (irLoadFieldMemberNode.isStatic()) {\n+            methodWriter.getStatic(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        } else {\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadBraceDef(LoadBraceDefNode irLoadBraceDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadBraceDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irLoadBraceDefNode.getIndexType()));\n+        methodWriter.invokeDefCall(\"arrayLoad\", methodType, DefBootstrap.ARRAY_LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadBrace(LoadBraceNode irLoadBraceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceNode.getLocation());\n+        methodWriter.arrayLoad(MethodWriter.getType(irLoadBraceNode.getExpressionType()));\n+    }\n+\n+    @Override\n+    public void visitStoreVariable(StoreVariableNode irStoreVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreVariableNode.getChildNode(), writeScope);\n+\n+        Variable variable = writeScope.getVariable(irStoreVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitStoreDotDef(StoreDotDefNode irStoreDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotDefNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(void.class),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irStoreDotDefNode.getStoreType()));\n+        methodWriter.invokeDefCall(irStoreDotDefNode.getValue(), methodType, DefBootstrap.STORE);\n+    }\n+\n+    @Override\n+    public void visitStoreDot(StoreDotNode irStoreDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotNode.getLocation());\n+\n+        PainlessField painlessField = irStoreDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.putStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.putField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitStoreDotShortcut(StoreDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irDotSubShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irDotSubShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irDotSubShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreListShortcut(StoreListShortcutNode irStoreListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreListShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreListShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irStoreListShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irStoreListShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreMapShortcut(StoreMapShortcutNode irStoreMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreMapShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreMapShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irStoreMapShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irStoreMapShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreFieldMember(StoreFieldMemberNode irStoreFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        if (irStoreFieldMemberNode.isStatic() == false) {\n+            methodWriter.loadThis();\n+        }\n+\n+        visit(irStoreFieldMemberNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreFieldMemberNode.getLocation());\n+\n+        if (irStoreFieldMemberNode.isStatic()) {\n+            methodWriter.putStatic(CLASS_TYPE,\n+                    irStoreFieldMemberNode.getName(), MethodWriter.getType(irStoreFieldMemberNode.getStoreType()));\n+        } else {\n+            methodWriter.putField(CLASS_TYPE,\n+                    irStoreFieldMemberNode.getName(), MethodWriter.getType(irStoreFieldMemberNode.getStoreType()));\n+        }\n+    }\n+\n+    @Override\n+    public void visitStoreBraceDef(StoreBraceDefNode irStoreBraceDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreBraceDefNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreBraceDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(void.class),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irStoreBraceDefNode.getIndexType()),\n+                MethodWriter.getType(irStoreBraceDefNode.getStoreType()));\n+        methodWriter.invokeDefCall(\"arrayStore\", methodType, DefBootstrap.ARRAY_STORE);\n+    }\n+\n+    @Override\n+    public void visitStoreBrace(StoreBraceNode irStoreBraceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreBraceNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreBraceNode.getLocation());\n+        methodWriter.arrayStore(MethodWriter.getType(irStoreBraceNode.getStoreType()));\n+    }\n+\n+    @Override\n+    public void visitInvokeCallDef(InvokeCallDefNode irInvokeCallDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irInvokeCallDefNode.getLocation());\n+\n+        // its possible to have unknown functional interfaces\n+        // as arguments that require captures; the set of\n+        // captures with call arguments is ambiguous so\n+        // additional information is encoded to indicate\n+        // which are values are arguments and which are captures\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;\n+\n+        // add an Object class as a placeholder type for the receiver\n+        typeParameters.add(Object.class);\n+\n+        for (int i = 0; i < irInvokeCallDefNode.getArgumentNodes().size(); ++i) {\n+            ExpressionNode irArgumentNode = irInvokeCallDefNode.getArgumentNodes().get(i);\n+            visit(irArgumentNode, writeScope);\n+\n+            typeParameters.add(irArgumentNode.getExpressionType());\n+\n+            // handle the case for unknown functional interface\n+            // to hint at which values are the call's arguments\n+            // versus which values are captures\n+            if (irArgumentNode instanceof DefInterfaceReferenceNode) {\n+                DefInterfaceReferenceNode defInterfaceReferenceNode = (DefInterfaceReferenceNode)irArgumentNode;\n+                boostrapArguments.add(defInterfaceReferenceNode.getDefReferenceEncoding());\n+\n+                // the encoding uses a char to indicate the number of captures\n+                // where the value is the number of current arguments plus the\n+                // total number of captures for easier capture count tracking\n+                // when resolved at runtime\n+                char encoding = (char)(i + capturedCount);\n+                defCallRecipe.append(encoding);\n+                capturedCount += defInterfaceReferenceNode.getCaptures().size();\n+\n+                for (String capturedName : defInterfaceReferenceNode.getCaptures()) {\n+                    Variable capturedVariable = writeScope.getVariable(capturedName);\n+                    typeParameters.add(capturedVariable.getType());\n+                }\n+            }\n+        }\n+\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irInvokeCallDefNode.getExpressionType()), asmParameterTypes);\n+\n+        boostrapArguments.add(0, defCallRecipe.toString());\n+        methodWriter.invokeDefCall(irInvokeCallDefNode.getName(), methodType, DefBootstrap.METHOD_CALL, boostrapArguments.toArray());\n+    }\n+\n+    @Override\n+    public void visitInvokeCall(InvokeCallNode irInvokeCallNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irInvokeCallNode.getLocation());\n+\n+        if (irInvokeCallNode.getBox().isPrimitive()) {\n+            methodWriter.box(MethodWriter.getType(irInvokeCallNode.getBox()));\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irInvokeCallNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        methodWriter.invokeMethodCall(irInvokeCallNode.getMethod());\n+    }\n+\n+    @Override\n+    public void visitInvokeCallMember(InvokeCallMemberNode irInvokeCallMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irInvokeCallMemberNode.getLocation());\n+\n+        LocalFunction localFunction = irInvokeCallMemberNode.getLocalFunction();\n+        PainlessMethod importedMethod = irInvokeCallMemberNode.getImportedMethod();\n+        PainlessClassBinding classBinding = irInvokeCallMemberNode.getClassBinding();\n+        PainlessInstanceBinding instanceBinding = irInvokeCallMemberNode.getInstanceBinding();\n+        List<ExpressionNode> irArgumentNodes = irInvokeCallMemberNode.getArgumentNodes();\n+\n+        if (localFunction != null) {\n+            if (localFunction.isStatic() == false) {\n+                methodWriter.loadThis();\n+            }\n+\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (localFunction.isStatic()) {\n+                methodWriter.invokeStatic(CLASS_TYPE, localFunction.getAsmMethod());\n+            } else {\n+                methodWriter.invokeVirtual(CLASS_TYPE, localFunction.getAsmMethod());\n+            }\n+        } else if (importedMethod != null) {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            methodWriter.invokeStatic(Type.getType(importedMethod.targetClass),\n+                    new Method(importedMethod.javaMethod.getName(), importedMethod.methodType.toMethodDescriptorString()));\n+        } else if (classBinding != null) {\n+            Type type = Type.getType(classBinding.javaConstructor.getDeclaringClass());\n+            int classBindingOffset = irInvokeCallMemberNode.getClassBindingOffset();\n+            int javaConstructorParameterCount = classBinding.javaConstructor.getParameterCount() - classBindingOffset;\n+            String bindingName = irInvokeCallMemberNode.getBindingName();\n+\n+            Label nonNull = new Label();\n+\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE, bindingName, type);\n+            methodWriter.ifNonNull(nonNull);\n+            methodWriter.loadThis();\n+            methodWriter.newInstance(type);\n+            methodWriter.dup();\n+\n+            if (classBindingOffset == 1) {\n+                methodWriter.loadThis();\n+            }\n+\n+            for (int argument = 0; argument < javaConstructorParameterCount; ++argument) {\n+                visit(irArgumentNodes.get(argument), writeScope);\n+            }\n+\n+            methodWriter.invokeConstructor(type, Method.getMethod(classBinding.javaConstructor));\n+            methodWriter.putField(CLASS_TYPE, bindingName, type);\n+\n+            methodWriter.mark(nonNull);\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE, bindingName, type);\n+\n+            for (int argument = 0; argument < classBinding.javaMethod.getParameterCount(); ++argument) {\n+                visit(irArgumentNodes.get(argument + javaConstructorParameterCount), writeScope);\n+            }\n+\n+            methodWriter.invokeVirtual(type, Method.getMethod(classBinding.javaMethod));\n+        } else if (instanceBinding != null) {\n+            Type type = Type.getType(instanceBinding.targetInstance.getClass());\n+            String bindingName = irInvokeCallMemberNode.getBindingName();\n+\n+            methodWriter.loadThis();\n+            methodWriter.getStatic(CLASS_TYPE, bindingName, type);\n+\n+            for (int argument = 0; argument < instanceBinding.javaMethod.getParameterCount(); ++argument) {\n+                visit(irArgumentNodes.get(argument), writeScope);\n+            }\n+\n+            methodWriter.invokeVirtual(type, Method.getMethod(instanceBinding.javaMethod));\n+        } else {\n+            throw new IllegalStateException(\"invalid unbound call\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitFlipArrayIndex(FlipArrayIndexNode irFlipArrayIndexNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irFlipArrayIndexNode.getChildNode(), writeScope);\n+\n+        Label noFlip = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifZCmp(Opcodes.IFGE, noFlip);\n+        methodWriter.swap();\n+        methodWriter.dupX1();\n+        methodWriter.arrayLength();\n+        methodWriter.visitInsn(Opcodes.IADD);\n+        methodWriter.mark(noFlip);\n+    }\n+\n+    @Override\n+    public void visitFlipCollectionIndex(FlipCollectionIndexNode irFlipCollectionIndexNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irFlipCollectionIndexNode.getChildNode(), writeScope);\n+\n+        Label noFlip = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifZCmp(Opcodes.IFGE, noFlip);\n+        methodWriter.swap();\n+        methodWriter.dupX1();\n+        methodWriter.invokeInterface(WriterConstants.COLLECTION_TYPE, WriterConstants.COLLECTION_SIZE);\n+        methodWriter.visitInsn(Opcodes.IADD);\n+        methodWriter.mark(noFlip);\n+    }\n+\n+    @Override\n+    public void visitFlipDefIndex(FlipDefIndexNode irFlipDefIndexNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        methodWriter.dup();\n+        visit(irFlipDefIndexNode.getChildNode(), writeScope);\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irFlipDefIndexNode.getChildNode().getExpressionType()),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irFlipDefIndexNode.getChildNode().getExpressionType()));", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NTAzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506675039", "bodyText": "Done.", "author": "jdconrad", "createdAt": "2020-10-16T19:16:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4MTEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4MzQzNg==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506583436", "bodyText": "Break this out, there's a lot of text in this statement.", "author": "stu-elastic", "createdAt": "2020-10-16T16:21:23Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NjU1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506676553", "bodyText": "Cleaned this up by importing the Type class from org.objectweb.asm since there's no longer a conflict.", "author": "jdconrad", "createdAt": "2020-10-16T19:19:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4MzQzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4Njc5OA==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506586798", "bodyText": "A bit too much going on here.", "author": "stu-elastic", "createdAt": "2020-10-16T16:27:17Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3ODQxNg==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506678416", "bodyText": "Cleaned up.", "author": "jdconrad", "createdAt": "2020-10-16T19:24:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4Njc5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4NzkxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506587911", "bodyText": "Break this line up.", "author": "stu-elastic", "createdAt": "2020-10-16T16:29:11Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadDotShortcut(LoadDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irDotSubShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (!getterPainlessMethod.returnType.equals(getterPainlessMethod.javaMethod.getReturnType())) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadListShortcut(LoadListShortcutNode irLoadListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadListShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadListShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType == getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadMapShortcut(LoadMapShortcutNode irLoadMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadMapShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadMapShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType != getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadFieldMember(LoadFieldMemberNode irLoadFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadFieldMemberNode.getLocation());\n+\n+        if (irLoadFieldMemberNode.isStatic()) {\n+            methodWriter.getStatic(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        } else {\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadBraceDef(LoadBraceDefNode irLoadBraceDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadBraceDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irLoadBraceDefNode.getIndexType()));\n+        methodWriter.invokeDefCall(\"arrayLoad\", methodType, DefBootstrap.ARRAY_LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadBrace(LoadBraceNode irLoadBraceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceNode.getLocation());\n+        methodWriter.arrayLoad(MethodWriter.getType(irLoadBraceNode.getExpressionType()));\n+    }\n+\n+    @Override\n+    public void visitStoreVariable(StoreVariableNode irStoreVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreVariableNode.getChildNode(), writeScope);\n+\n+        Variable variable = writeScope.getVariable(irStoreVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitStoreDotDef(StoreDotDefNode irStoreDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotDefNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(void.class),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irStoreDotDefNode.getStoreType()));\n+        methodWriter.invokeDefCall(irStoreDotDefNode.getValue(), methodType, DefBootstrap.STORE);\n+    }\n+\n+    @Override\n+    public void visitStoreDot(StoreDotNode irStoreDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotNode.getLocation());\n+\n+        PainlessField painlessField = irStoreDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.putStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.putField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitStoreDotShortcut(StoreDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irDotSubShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irDotSubShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irDotSubShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreListShortcut(StoreListShortcutNode irStoreListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreListShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreListShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irStoreListShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irStoreListShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreMapShortcut(StoreMapShortcutNode irStoreMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreMapShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreMapShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irStoreMapShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irStoreMapShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreFieldMember(StoreFieldMemberNode irStoreFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        if (irStoreFieldMemberNode.isStatic() == false) {\n+            methodWriter.loadThis();\n+        }\n+\n+        visit(irStoreFieldMemberNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreFieldMemberNode.getLocation());\n+\n+        if (irStoreFieldMemberNode.isStatic()) {\n+            methodWriter.putStatic(CLASS_TYPE,\n+                    irStoreFieldMemberNode.getName(), MethodWriter.getType(irStoreFieldMemberNode.getStoreType()));\n+        } else {\n+            methodWriter.putField(CLASS_TYPE,\n+                    irStoreFieldMemberNode.getName(), MethodWriter.getType(irStoreFieldMemberNode.getStoreType()));\n+        }\n+    }\n+\n+    @Override\n+    public void visitStoreBraceDef(StoreBraceDefNode irStoreBraceDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreBraceDefNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreBraceDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(void.class),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irStoreBraceDefNode.getIndexType()),\n+                MethodWriter.getType(irStoreBraceDefNode.getStoreType()));\n+        methodWriter.invokeDefCall(\"arrayStore\", methodType, DefBootstrap.ARRAY_STORE);\n+    }\n+\n+    @Override\n+    public void visitStoreBrace(StoreBraceNode irStoreBraceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreBraceNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreBraceNode.getLocation());\n+        methodWriter.arrayStore(MethodWriter.getType(irStoreBraceNode.getStoreType()));\n+    }\n+\n+    @Override\n+    public void visitInvokeCallDef(InvokeCallDefNode irInvokeCallDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irInvokeCallDefNode.getLocation());\n+\n+        // its possible to have unknown functional interfaces\n+        // as arguments that require captures; the set of\n+        // captures with call arguments is ambiguous so\n+        // additional information is encoded to indicate\n+        // which are values are arguments and which are captures\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;\n+\n+        // add an Object class as a placeholder type for the receiver\n+        typeParameters.add(Object.class);\n+\n+        for (int i = 0; i < irInvokeCallDefNode.getArgumentNodes().size(); ++i) {\n+            ExpressionNode irArgumentNode = irInvokeCallDefNode.getArgumentNodes().get(i);\n+            visit(irArgumentNode, writeScope);\n+\n+            typeParameters.add(irArgumentNode.getExpressionType());\n+\n+            // handle the case for unknown functional interface\n+            // to hint at which values are the call's arguments\n+            // versus which values are captures\n+            if (irArgumentNode instanceof DefInterfaceReferenceNode) {\n+                DefInterfaceReferenceNode defInterfaceReferenceNode = (DefInterfaceReferenceNode)irArgumentNode;\n+                boostrapArguments.add(defInterfaceReferenceNode.getDefReferenceEncoding());\n+\n+                // the encoding uses a char to indicate the number of captures\n+                // where the value is the number of current arguments plus the\n+                // total number of captures for easier capture count tracking\n+                // when resolved at runtime\n+                char encoding = (char)(i + capturedCount);\n+                defCallRecipe.append(encoding);\n+                capturedCount += defInterfaceReferenceNode.getCaptures().size();\n+\n+                for (String capturedName : defInterfaceReferenceNode.getCaptures()) {\n+                    Variable capturedVariable = writeScope.getVariable(capturedName);\n+                    typeParameters.add(capturedVariable.getType());\n+                }\n+            }\n+        }\n+\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irInvokeCallDefNode.getExpressionType()), asmParameterTypes);\n+\n+        boostrapArguments.add(0, defCallRecipe.toString());\n+        methodWriter.invokeDefCall(irInvokeCallDefNode.getName(), methodType, DefBootstrap.METHOD_CALL, boostrapArguments.toArray());\n+    }\n+\n+    @Override\n+    public void visitInvokeCall(InvokeCallNode irInvokeCallNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irInvokeCallNode.getLocation());\n+\n+        if (irInvokeCallNode.getBox().isPrimitive()) {\n+            methodWriter.box(MethodWriter.getType(irInvokeCallNode.getBox()));\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irInvokeCallNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        methodWriter.invokeMethodCall(irInvokeCallNode.getMethod());\n+    }\n+\n+    @Override\n+    public void visitInvokeCallMember(InvokeCallMemberNode irInvokeCallMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irInvokeCallMemberNode.getLocation());\n+\n+        LocalFunction localFunction = irInvokeCallMemberNode.getLocalFunction();\n+        PainlessMethod importedMethod = irInvokeCallMemberNode.getImportedMethod();\n+        PainlessClassBinding classBinding = irInvokeCallMemberNode.getClassBinding();\n+        PainlessInstanceBinding instanceBinding = irInvokeCallMemberNode.getInstanceBinding();\n+        List<ExpressionNode> irArgumentNodes = irInvokeCallMemberNode.getArgumentNodes();\n+\n+        if (localFunction != null) {\n+            if (localFunction.isStatic() == false) {\n+                methodWriter.loadThis();\n+            }\n+\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (localFunction.isStatic()) {\n+                methodWriter.invokeStatic(CLASS_TYPE, localFunction.getAsmMethod());\n+            } else {\n+                methodWriter.invokeVirtual(CLASS_TYPE, localFunction.getAsmMethod());\n+            }\n+        } else if (importedMethod != null) {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            methodWriter.invokeStatic(Type.getType(importedMethod.targetClass),\n+                    new Method(importedMethod.javaMethod.getName(), importedMethod.methodType.toMethodDescriptorString()));", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NzU0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506677549", "bodyText": "Done.", "author": "jdconrad", "createdAt": "2020-10-16T19:22:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4NzkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4ODM1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506588353", "bodyText": "Pull these out into variables.", "author": "stu-elastic", "createdAt": "2020-10-16T16:30:02Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3OTIxNg==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506679216", "bodyText": "Lots of overlap with naming so I'm going to leave this one.", "author": "jdconrad", "createdAt": "2020-10-16T19:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4ODM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4OTQwOA==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506589408", "bodyText": "pull out these arguments.", "author": "stu-elastic", "createdAt": "2020-10-16T16:31:57Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4MDcyNw==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506680727", "bodyText": "Done.", "author": "jdconrad", "createdAt": "2020-10-16T19:29:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4OTQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4OTUwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506589509", "bodyText": "pull out these arguments", "author": "stu-elastic", "createdAt": "2020-10-16T16:32:07Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4MDc4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506680787", "bodyText": "Done.", "author": "jdconrad", "createdAt": "2020-10-16T19:29:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4OTUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4OTc5NA==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506589794", "bodyText": "Pull this out.", "author": "stu-elastic", "createdAt": "2020-10-16T16:32:38Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadDotShortcut(LoadDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irDotSubShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (!getterPainlessMethod.returnType.equals(getterPainlessMethod.javaMethod.getReturnType())) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadListShortcut(LoadListShortcutNode irLoadListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadListShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadListShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType == getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadMapShortcut(LoadMapShortcutNode irLoadMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadMapShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadMapShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType != getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadFieldMember(LoadFieldMemberNode irLoadFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadFieldMemberNode.getLocation());\n+\n+        if (irLoadFieldMemberNode.isStatic()) {\n+            methodWriter.getStatic(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4MjYwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506682609", "bodyText": "Done.", "author": "jdconrad", "createdAt": "2020-10-16T19:34:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4OTc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4OTg0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506589842", "bodyText": "Pull this out.", "author": "stu-elastic", "createdAt": "2020-10-16T16:32:43Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadDotShortcut(LoadDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irDotSubShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (!getterPainlessMethod.returnType.equals(getterPainlessMethod.javaMethod.getReturnType())) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadListShortcut(LoadListShortcutNode irLoadListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadListShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadListShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType == getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadMapShortcut(LoadMapShortcutNode irLoadMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadMapShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadMapShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType != getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadFieldMember(LoadFieldMemberNode irLoadFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadFieldMemberNode.getLocation());\n+\n+        if (irLoadFieldMemberNode.isStatic()) {\n+            methodWriter.getStatic(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        } else {\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE,", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4MjY0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506682643", "bodyText": "Done.", "author": "jdconrad", "createdAt": "2020-10-16T19:34:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4OTg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5MDY3NA==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506590674", "bodyText": "See how difficult it is to make these visits alphabetical.", "author": "stu-elastic", "createdAt": "2020-10-16T16:34:17Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadDotShortcut(LoadDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irDotSubShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (!getterPainlessMethod.returnType.equals(getterPainlessMethod.javaMethod.getReturnType())) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadListShortcut(LoadListShortcutNode irLoadListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadListShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadListShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType == getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadMapShortcut(LoadMapShortcutNode irLoadMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadMapShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadMapShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType != getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadFieldMember(LoadFieldMemberNode irLoadFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadFieldMemberNode.getLocation());\n+\n+        if (irLoadFieldMemberNode.isStatic()) {\n+            methodWriter.getStatic(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        } else {\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadBraceDef(LoadBraceDefNode irLoadBraceDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadBraceDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irLoadBraceDefNode.getIndexType()));\n+        methodWriter.invokeDefCall(\"arrayLoad\", methodType, DefBootstrap.ARRAY_LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadBrace(LoadBraceNode irLoadBraceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceNode.getLocation());\n+        methodWriter.arrayLoad(MethodWriter.getType(irLoadBraceNode.getExpressionType()));\n+    }\n+\n+    @Override\n+    public void visitStoreVariable(StoreVariableNode irStoreVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreVariableNode.getChildNode(), writeScope);\n+\n+        Variable variable = writeScope.getVariable(irStoreVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitStoreDotDef(StoreDotDefNode irStoreDotDefNode, WriteScope writeScope) {", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4MzAwMw==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506683003", "bodyText": "After giving this some thought I'm going to skip it for now as it would require moving things around in 5 different files - 3 concrete phases and 2 base classes. It also aligns better with rules all the way through from grammar -> user tree -> ir tree.", "author": "jdconrad", "createdAt": "2020-10-16T19:35:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5MDY3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5MTE0MA==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506591140", "bodyText": "pull these out.", "author": "stu-elastic", "createdAt": "2020-10-16T16:35:04Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4NDg2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506684861", "bodyText": "Used dropped lines here to make it easier to read. Found little benefit in separate variables.", "author": "jdconrad", "createdAt": "2020-10-16T19:39:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5MTE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5MjU5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506592596", "bodyText": "pull this out.", "author": "stu-elastic", "createdAt": "2020-10-16T16:37:45Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4NTk1NA==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506685954", "bodyText": "Done.", "author": "jdconrad", "createdAt": "2020-10-16T19:41:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5MjU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5MzcxNw==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506593717", "bodyText": "lot going on here.", "author": "stu-elastic", "createdAt": "2020-10-16T16:40:02Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadDotShortcut(LoadDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irDotSubShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (!getterPainlessMethod.returnType.equals(getterPainlessMethod.javaMethod.getReturnType())) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadListShortcut(LoadListShortcutNode irLoadListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadListShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadListShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType == getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadMapShortcut(LoadMapShortcutNode irLoadMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadMapShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadMapShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType != getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadFieldMember(LoadFieldMemberNode irLoadFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadFieldMemberNode.getLocation());\n+\n+        if (irLoadFieldMemberNode.isStatic()) {\n+            methodWriter.getStatic(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        } else {\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadBraceDef(LoadBraceDefNode irLoadBraceDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadBraceDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irLoadBraceDefNode.getIndexType()));\n+        methodWriter.invokeDefCall(\"arrayLoad\", methodType, DefBootstrap.ARRAY_LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadBrace(LoadBraceNode irLoadBraceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceNode.getLocation());\n+        methodWriter.arrayLoad(MethodWriter.getType(irLoadBraceNode.getExpressionType()));\n+    }\n+\n+    @Override\n+    public void visitStoreVariable(StoreVariableNode irStoreVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreVariableNode.getChildNode(), writeScope);\n+\n+        Variable variable = writeScope.getVariable(irStoreVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitStoreDotDef(StoreDotDefNode irStoreDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotDefNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(void.class),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irStoreDotDefNode.getStoreType()));\n+        methodWriter.invokeDefCall(irStoreDotDefNode.getValue(), methodType, DefBootstrap.STORE);\n+    }\n+\n+    @Override\n+    public void visitStoreDot(StoreDotNode irStoreDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotNode.getLocation());\n+\n+        PainlessField painlessField = irStoreDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.putStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4MTI3MA==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506681270", "bodyText": "Done.", "author": "jdconrad", "createdAt": "2020-10-16T19:30:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5MzcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5MzgwNA==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506593804", "bodyText": "lot going on here.", "author": "stu-elastic", "createdAt": "2020-10-16T16:40:10Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadDotShortcut(LoadDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irDotSubShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (!getterPainlessMethod.returnType.equals(getterPainlessMethod.javaMethod.getReturnType())) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadListShortcut(LoadListShortcutNode irLoadListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadListShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadListShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType == getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadMapShortcut(LoadMapShortcutNode irLoadMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadMapShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadMapShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType != getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadFieldMember(LoadFieldMemberNode irLoadFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadFieldMemberNode.getLocation());\n+\n+        if (irLoadFieldMemberNode.isStatic()) {\n+            methodWriter.getStatic(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        } else {\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadBraceDef(LoadBraceDefNode irLoadBraceDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadBraceDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irLoadBraceDefNode.getIndexType()));\n+        methodWriter.invokeDefCall(\"arrayLoad\", methodType, DefBootstrap.ARRAY_LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadBrace(LoadBraceNode irLoadBraceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceNode.getLocation());\n+        methodWriter.arrayLoad(MethodWriter.getType(irLoadBraceNode.getExpressionType()));\n+    }\n+\n+    @Override\n+    public void visitStoreVariable(StoreVariableNode irStoreVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreVariableNode.getChildNode(), writeScope);\n+\n+        Variable variable = writeScope.getVariable(irStoreVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitStoreDotDef(StoreDotDefNode irStoreDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotDefNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(void.class),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irStoreDotDefNode.getStoreType()));\n+        methodWriter.invokeDefCall(irStoreDotDefNode.getValue(), methodType, DefBootstrap.STORE);\n+    }\n+\n+    @Override\n+    public void visitStoreDot(StoreDotNode irStoreDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotNode.getLocation());\n+\n+        PainlessField painlessField = irStoreDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.putStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.putField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4MTMwNw==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506681307", "bodyText": "Done.", "author": "jdconrad", "createdAt": "2020-10-16T19:30:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5MzgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5NDA0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506594047", "bodyText": "break this up.", "author": "stu-elastic", "createdAt": "2020-10-16T16:40:38Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadDotShortcut(LoadDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irDotSubShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (!getterPainlessMethod.returnType.equals(getterPainlessMethod.javaMethod.getReturnType())) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadListShortcut(LoadListShortcutNode irLoadListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadListShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadListShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType == getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadMapShortcut(LoadMapShortcutNode irLoadMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadMapShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadMapShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType != getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadFieldMember(LoadFieldMemberNode irLoadFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadFieldMemberNode.getLocation());\n+\n+        if (irLoadFieldMemberNode.isStatic()) {\n+            methodWriter.getStatic(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        } else {\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadBraceDef(LoadBraceDefNode irLoadBraceDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadBraceDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irLoadBraceDefNode.getIndexType()));\n+        methodWriter.invokeDefCall(\"arrayLoad\", methodType, DefBootstrap.ARRAY_LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadBrace(LoadBraceNode irLoadBraceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceNode.getLocation());\n+        methodWriter.arrayLoad(MethodWriter.getType(irLoadBraceNode.getExpressionType()));\n+    }\n+\n+    @Override\n+    public void visitStoreVariable(StoreVariableNode irStoreVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreVariableNode.getChildNode(), writeScope);\n+\n+        Variable variable = writeScope.getVariable(irStoreVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitStoreDotDef(StoreDotDefNode irStoreDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotDefNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(void.class),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irStoreDotDefNode.getStoreType()));\n+        methodWriter.invokeDefCall(irStoreDotDefNode.getValue(), methodType, DefBootstrap.STORE);\n+    }\n+\n+    @Override\n+    public void visitStoreDot(StoreDotNode irStoreDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotNode.getLocation());\n+\n+        PainlessField painlessField = irStoreDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.putStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.putField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitStoreDotShortcut(StoreDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irDotSubShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irDotSubShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irDotSubShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreListShortcut(StoreListShortcutNode irStoreListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreListShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreListShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irStoreListShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irStoreListShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreMapShortcut(StoreMapShortcutNode irStoreMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreMapShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreMapShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irStoreMapShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irStoreMapShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreFieldMember(StoreFieldMemberNode irStoreFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        if (irStoreFieldMemberNode.isStatic() == false) {\n+            methodWriter.loadThis();\n+        }\n+\n+        visit(irStoreFieldMemberNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreFieldMemberNode.getLocation());\n+\n+        if (irStoreFieldMemberNode.isStatic()) {\n+            methodWriter.putStatic(CLASS_TYPE,\n+                    irStoreFieldMemberNode.getName(), MethodWriter.getType(irStoreFieldMemberNode.getStoreType()));", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4Mzc4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506683782", "bodyText": "Done.", "author": "jdconrad", "createdAt": "2020-10-16T19:37:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5NDA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5NDE0NA==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506594144", "bodyText": "break this up.", "author": "stu-elastic", "createdAt": "2020-10-16T16:40:48Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadDotShortcut(LoadDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irDotSubShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (!getterPainlessMethod.returnType.equals(getterPainlessMethod.javaMethod.getReturnType())) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadListShortcut(LoadListShortcutNode irLoadListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadListShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadListShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType == getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadMapShortcut(LoadMapShortcutNode irLoadMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadMapShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadMapShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType != getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadFieldMember(LoadFieldMemberNode irLoadFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadFieldMemberNode.getLocation());\n+\n+        if (irLoadFieldMemberNode.isStatic()) {\n+            methodWriter.getStatic(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        } else {\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadBraceDef(LoadBraceDefNode irLoadBraceDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadBraceDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irLoadBraceDefNode.getIndexType()));\n+        methodWriter.invokeDefCall(\"arrayLoad\", methodType, DefBootstrap.ARRAY_LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadBrace(LoadBraceNode irLoadBraceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceNode.getLocation());\n+        methodWriter.arrayLoad(MethodWriter.getType(irLoadBraceNode.getExpressionType()));\n+    }\n+\n+    @Override\n+    public void visitStoreVariable(StoreVariableNode irStoreVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreVariableNode.getChildNode(), writeScope);\n+\n+        Variable variable = writeScope.getVariable(irStoreVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitStoreDotDef(StoreDotDefNode irStoreDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotDefNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(void.class),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irStoreDotDefNode.getStoreType()));\n+        methodWriter.invokeDefCall(irStoreDotDefNode.getValue(), methodType, DefBootstrap.STORE);\n+    }\n+\n+    @Override\n+    public void visitStoreDot(StoreDotNode irStoreDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotNode.getLocation());\n+\n+        PainlessField painlessField = irStoreDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.putStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.putField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitStoreDotShortcut(StoreDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irDotSubShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irDotSubShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irDotSubShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreListShortcut(StoreListShortcutNode irStoreListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreListShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreListShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irStoreListShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irStoreListShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreMapShortcut(StoreMapShortcutNode irStoreMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreMapShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreMapShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irStoreMapShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irStoreMapShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreFieldMember(StoreFieldMemberNode irStoreFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        if (irStoreFieldMemberNode.isStatic() == false) {\n+            methodWriter.loadThis();\n+        }\n+\n+        visit(irStoreFieldMemberNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreFieldMemberNode.getLocation());\n+\n+        if (irStoreFieldMemberNode.isStatic()) {\n+            methodWriter.putStatic(CLASS_TYPE,\n+                    irStoreFieldMemberNode.getName(), MethodWriter.getType(irStoreFieldMemberNode.getStoreType()));\n+        } else {\n+            methodWriter.putField(CLASS_TYPE,\n+                    irStoreFieldMemberNode.getName(), MethodWriter.getType(irStoreFieldMemberNode.getStoreType()));", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4Mzg1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506683855", "bodyText": "Done.", "author": "jdconrad", "createdAt": "2020-10-16T19:37:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5NDE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5NDk1MA==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506594950", "bodyText": "put some parens around this condition.", "author": "stu-elastic", "createdAt": "2020-10-16T16:42:24Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4OTA5OA==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506689098", "bodyText": "Pulled this into a boolean to make it clearer.", "author": "jdconrad", "createdAt": "2020-10-16T19:48:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5NDk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5NTI1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506595257", "bodyText": "These got pretty long, pull some variables out.", "author": "stu-elastic", "createdAt": "2020-10-16T16:42:59Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());", "originalCommit": "883486155e6f1c304fe53b5c8ef09ee255964141", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4OTk2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506689962", "bodyText": "Split the lines to make it clearer.", "author": "jdconrad", "createdAt": "2020-10-16T19:50:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5NTI1Nw=="}], "type": "inlineReview"}, {"oid": "e31faeae9f99ed35a64d812596604b342fbc63f1", "url": "https://github.com/elastic/elasticsearch/commit/e31faeae9f99ed35a64d812596604b342fbc63f1", "message": "Merge branch 'master' into proto2", "committedDate": "2020-10-16T19:07:24Z", "type": "commit"}, {"oid": "16031ac02038b84fd67bdc650a3f374ba9c8b927", "url": "https://github.com/elastic/elasticsearch/commit/16031ac02038b84fd67bdc650a3f374ba9c8b927", "message": "Merge branch 'proto2' into proto3", "committedDate": "2020-10-16T19:07:32Z", "type": "commit"}, {"oid": "902b2ba328e4f9e3fc0a3d5f3809e257e396d2a4", "url": "https://github.com/elastic/elasticsearch/commit/902b2ba328e4f9e3fc0a3d5f3809e257e396d2a4", "message": "response to pr comments", "committedDate": "2020-10-16T19:51:59Z", "type": "commit"}]}