{"pr_number": 63590, "pr_title": "Add CCR repository test for snapshot shard size", "pr_createdAt": "2020-10-13T07:38:25Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/63590", "timeline": [{"oid": "680defec049132ea75dd369d78cabacaefa428a4", "url": "https://github.com/elastic/elasticsearch/commit/680defec049132ea75dd369d78cabacaefa428a4", "message": "Add CCR repository test for snapshot shard size", "committedDate": "2020-10-13T07:30:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg4MDY4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/63590#discussion_r503880683", "bodyText": "NIT: can go on a single line\n            bulkRequest.add(new IndexRequest(leaderIndex).id(Integer.toString(i)).source(\"field\", i));\nno need to set the default XContentType.JSON IMO", "author": "original-brownbear", "createdAt": "2020-10-13T11:39:52Z", "path": "x-pack/plugin/ccr/src/internalClusterTest/java/org/elasticsearch/xpack/ccr/CcrRepositoryIT.java", "diffHunk": "@@ -439,6 +463,242 @@ public void testFollowerMappingIsUpdated() throws IOException {\n         }\n     }\n \n+    public void testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats() throws Exception {\n+        final String leaderIndex = \"leader\";\n+        final int numberOfShards = randomIntBetween(1, 2);\n+        assertAcked(leaderClient().admin().indices().prepareCreate(leaderIndex)\n+            .setSource(getIndexSettings(numberOfShards, 0,\n+                Map.of(Store.INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING.getKey(), TimeValue.ZERO.getStringRep())), XContentType.JSON));\n+\n+        final int numDocs = scaledRandomIntBetween(0, 1_000);\n+        final BulkRequestBuilder bulkRequest = leaderClient().prepareBulk(leaderIndex);\n+        for (int i = 0; i < numDocs; i++) {\n+            bulkRequest.add(new IndexRequest(leaderIndex)", "originalCommit": "680defec049132ea75dd369d78cabacaefa428a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4OTI2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/63590#discussion_r503989262", "bodyText": "Indeed", "author": "tlrx", "createdAt": "2020-10-13T14:16:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg4MDY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg4MjMzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/63590#discussion_r503882339", "bodyText": "no need to check for null when we match the type on the next line anyway?", "author": "original-brownbear", "createdAt": "2020-10-13T11:42:43Z", "path": "x-pack/plugin/ccr/src/internalClusterTest/java/org/elasticsearch/xpack/ccr/CcrRepositoryIT.java", "diffHunk": "@@ -439,6 +463,242 @@ public void testFollowerMappingIsUpdated() throws IOException {\n         }\n     }\n \n+    public void testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats() throws Exception {\n+        final String leaderIndex = \"leader\";\n+        final int numberOfShards = randomIntBetween(1, 2);\n+        assertAcked(leaderClient().admin().indices().prepareCreate(leaderIndex)\n+            .setSource(getIndexSettings(numberOfShards, 0,\n+                Map.of(Store.INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING.getKey(), TimeValue.ZERO.getStringRep())), XContentType.JSON));\n+\n+        final int numDocs = scaledRandomIntBetween(0, 1_000);\n+        final BulkRequestBuilder bulkRequest = leaderClient().prepareBulk(leaderIndex);\n+        for (int i = 0; i < numDocs; i++) {\n+            bulkRequest.add(new IndexRequest(leaderIndex)\n+                .id(Integer.toString(i))\n+                .source(XContentType.JSON, \"field\", i));\n+        }\n+        assertThat(bulkRequest.get().hasFailures(), is(false));\n+\n+        final ForceMergeResponse forceMergeResponse = leaderClient().admin().indices().prepareForceMerge(leaderIndex).setFlush(true).get();\n+        assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards));\n+        assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        ensureLeaderGreen(leaderIndex);\n+\n+        final IndexStats indexStats = leaderClient().admin().indices().prepareStats(leaderIndex)\n+            .clear()\n+            .setStore(true)\n+            .get()\n+            .getIndex(leaderIndex);\n+        assertThat(indexStats.getIndexShards(), notNullValue());", "originalCommit": "680defec049132ea75dd369d78cabacaefa428a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk5MjY1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/63590#discussion_r503992653", "bodyText": "Mostly to prevent a NPE that would be thrown by assertThat(indexStats.getIndexShards(), aMapWithSize(numberOfShards));", "author": "tlrx", "createdAt": "2020-10-13T14:20:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg4MjMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg4NTAxMg==", "url": "https://github.com/elastic/elasticsearch/pull/63590#discussion_r503885012", "bodyText": "NIT (really just personal preference ... feel free to ignore :)) but it seems much easier to follow this test if we would match with equalTo(indexStats.getIndexShards().get(shardId).getPrimary().store.getSizeInBytes())) in the below two spots where we use this array, much less indirection IMO and even shorter despite some duplication :)", "author": "original-brownbear", "createdAt": "2020-10-13T11:47:39Z", "path": "x-pack/plugin/ccr/src/internalClusterTest/java/org/elasticsearch/xpack/ccr/CcrRepositoryIT.java", "diffHunk": "@@ -439,6 +463,242 @@ public void testFollowerMappingIsUpdated() throws IOException {\n         }\n     }\n \n+    public void testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats() throws Exception {\n+        final String leaderIndex = \"leader\";\n+        final int numberOfShards = randomIntBetween(1, 2);\n+        assertAcked(leaderClient().admin().indices().prepareCreate(leaderIndex)\n+            .setSource(getIndexSettings(numberOfShards, 0,\n+                Map.of(Store.INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING.getKey(), TimeValue.ZERO.getStringRep())), XContentType.JSON));\n+\n+        final int numDocs = scaledRandomIntBetween(0, 1_000);\n+        final BulkRequestBuilder bulkRequest = leaderClient().prepareBulk(leaderIndex);\n+        for (int i = 0; i < numDocs; i++) {\n+            bulkRequest.add(new IndexRequest(leaderIndex)\n+                .id(Integer.toString(i))\n+                .source(XContentType.JSON, \"field\", i));\n+        }\n+        assertThat(bulkRequest.get().hasFailures(), is(false));\n+\n+        final ForceMergeResponse forceMergeResponse = leaderClient().admin().indices().prepareForceMerge(leaderIndex).setFlush(true).get();\n+        assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards));\n+        assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        ensureLeaderGreen(leaderIndex);\n+\n+        final IndexStats indexStats = leaderClient().admin().indices().prepareStats(leaderIndex)\n+            .clear()\n+            .setStore(true)\n+            .get()\n+            .getIndex(leaderIndex);\n+        assertThat(indexStats.getIndexShards(), notNullValue());\n+        assertThat(indexStats.getIndexShards(), aMapWithSize(numberOfShards));\n+\n+        final long[] storeSizeInBytes = new long[numberOfShards];", "originalCommit": "680defec049132ea75dd369d78cabacaefa428a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk5Mzk2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/63590#discussion_r503993966", "bodyText": "Thanks for the suggestion, I'll take it", "author": "tlrx", "createdAt": "2020-10-13T14:22:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg4NTAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg4NjU3OA==", "url": "https://github.com/elastic/elasticsearch/pull/63590#discussion_r503886578", "bodyText": "assertTrue on this?", "author": "original-brownbear", "createdAt": "2020-10-13T11:50:29Z", "path": "x-pack/plugin/ccr/src/internalClusterTest/java/org/elasticsearch/xpack/ccr/CcrRepositoryIT.java", "diffHunk": "@@ -439,6 +463,242 @@ public void testFollowerMappingIsUpdated() throws IOException {\n         }\n     }\n \n+    public void testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats() throws Exception {\n+        final String leaderIndex = \"leader\";\n+        final int numberOfShards = randomIntBetween(1, 2);\n+        assertAcked(leaderClient().admin().indices().prepareCreate(leaderIndex)\n+            .setSource(getIndexSettings(numberOfShards, 0,\n+                Map.of(Store.INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING.getKey(), TimeValue.ZERO.getStringRep())), XContentType.JSON));\n+\n+        final int numDocs = scaledRandomIntBetween(0, 1_000);\n+        final BulkRequestBuilder bulkRequest = leaderClient().prepareBulk(leaderIndex);\n+        for (int i = 0; i < numDocs; i++) {\n+            bulkRequest.add(new IndexRequest(leaderIndex)\n+                .id(Integer.toString(i))\n+                .source(XContentType.JSON, \"field\", i));\n+        }\n+        assertThat(bulkRequest.get().hasFailures(), is(false));\n+\n+        final ForceMergeResponse forceMergeResponse = leaderClient().admin().indices().prepareForceMerge(leaderIndex).setFlush(true).get();\n+        assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards));\n+        assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        ensureLeaderGreen(leaderIndex);\n+\n+        final IndexStats indexStats = leaderClient().admin().indices().prepareStats(leaderIndex)\n+            .clear()\n+            .setStore(true)\n+            .get()\n+            .getIndex(leaderIndex);\n+        assertThat(indexStats.getIndexShards(), notNullValue());\n+        assertThat(indexStats.getIndexShards(), aMapWithSize(numberOfShards));\n+\n+        final long[] storeSizeInBytes = new long[numberOfShards];\n+        indexStats.getIndexShards().forEach((key, value) -> storeSizeInBytes[key] = value.getPrimary().getStore().getSizeInBytes());\n+\n+        final String leaderCluster = CcrRepository.NAME_PREFIX + \"leader_cluster\";\n+        final RepositoriesService repositoriesService = getFollowerCluster().getCurrentMasterNodeInstance(RepositoriesService.class);\n+        final Repository repository = repositoriesService.repository(leaderCluster);\n+        assertThat(repository.getMetadata().type(), equalTo(CcrRepository.TYPE));\n+        assertThat(repository.getMetadata().name(), equalTo(leaderCluster));\n+\n+        for (int shardId = 0; shardId < numberOfShards; shardId++) {\n+            IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = repository.getShardSnapshotStatus(\n+                new SnapshotId(CcrRepository.LATEST, CcrRepository.LATEST),\n+                new IndexId(indexStats.getIndex(), indexStats.getUuid()),\n+                new ShardId(new Index(indexStats.getIndex(), indexStats.getUuid()), shardId)).asCopy();\n+\n+            assertThat(indexShardSnapshotStatus, notNullValue());\n+            assertThat(indexShardSnapshotStatus.getStage(), is(IndexShardSnapshotStatus.Stage.DONE));\n+            assertThat(indexShardSnapshotStatus.getTotalSize(), equalTo(storeSizeInBytes[shardId]));\n+        }\n+\n+        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n+\n+        final List<MockTransportService> transportServices = new ArrayList<>();\n+        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n+            final MockTransportService mockTransportService = (MockTransportService) transportService;\n+            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n+                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n+                    try {\n+                        blockCcrRestore.await();\n+                    } catch (InterruptedException e) {\n+                        throw new ElasticsearchException(e);\n+                    }\n+                }\n+                connection.sendRequest(requestId, action, request, options);\n+            });\n+            transportServices.add(mockTransportService);\n+        }\n+\n+        try {\n+            final RestoreService restoreService = getFollowerCluster().getCurrentMasterNodeInstance(RestoreService.class);\n+            final ClusterService clusterService = getFollowerCluster().getCurrentMasterNodeInstance(ClusterService.class);\n+\n+            final CountDownLatch waitForRestoreInProgress = new CountDownLatch(1);\n+            final ClusterStateListener listener = event -> {\n+                RestoreInProgress restoreInProgress = event.state().custom(RestoreInProgress.TYPE, RestoreInProgress.EMPTY);\n+                if (restoreInProgress != null && restoreInProgress.isEmpty() == false) {\n+                    waitForRestoreInProgress.countDown();\n+                }\n+            };\n+            clusterService.addListener(listener);\n+\n+            final String followerIndex = \"follower\";\n+            final RestoreSnapshotRequest restoreRequest = new RestoreSnapshotRequest(leaderCluster, CcrRepository.LATEST)\n+                .indices(leaderIndex).indicesOptions(indicesOptions).renamePattern(\"^(.*)$\")\n+                .renameReplacement(followerIndex)\n+                .masterNodeTimeout(TimeValue.MAX_VALUE)\n+                .indexSettings(Settings.builder()\n+                    .put(IndexMetadata.SETTING_INDEX_PROVIDED_NAME, followerIndex)\n+                    .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true));\n+            restoreService.restoreSnapshot(restoreRequest, PlainActionFuture.newFuture());\n+\n+            waitForRestoreInProgress.await(30L, TimeUnit.SECONDS);", "originalCommit": "680defec049132ea75dd369d78cabacaefa428a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg5MDU4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/63590#discussion_r503890589", "bodyText": "NIT (again just random personal preference for keeping things short): I suppose you could speed things up a little and save some code by just using a PlainActionFuture that you resolve with the cluster state for waitForRestoreInProgress instead of using the latch and then loading the state once again (then you also have the built in exception on timeout on .get to work with I suppose).", "author": "original-brownbear", "createdAt": "2020-10-13T11:57:23Z", "path": "x-pack/plugin/ccr/src/internalClusterTest/java/org/elasticsearch/xpack/ccr/CcrRepositoryIT.java", "diffHunk": "@@ -439,6 +463,242 @@ public void testFollowerMappingIsUpdated() throws IOException {\n         }\n     }\n \n+    public void testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats() throws Exception {\n+        final String leaderIndex = \"leader\";\n+        final int numberOfShards = randomIntBetween(1, 2);\n+        assertAcked(leaderClient().admin().indices().prepareCreate(leaderIndex)\n+            .setSource(getIndexSettings(numberOfShards, 0,\n+                Map.of(Store.INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING.getKey(), TimeValue.ZERO.getStringRep())), XContentType.JSON));\n+\n+        final int numDocs = scaledRandomIntBetween(0, 1_000);\n+        final BulkRequestBuilder bulkRequest = leaderClient().prepareBulk(leaderIndex);\n+        for (int i = 0; i < numDocs; i++) {\n+            bulkRequest.add(new IndexRequest(leaderIndex)\n+                .id(Integer.toString(i))\n+                .source(XContentType.JSON, \"field\", i));\n+        }\n+        assertThat(bulkRequest.get().hasFailures(), is(false));\n+\n+        final ForceMergeResponse forceMergeResponse = leaderClient().admin().indices().prepareForceMerge(leaderIndex).setFlush(true).get();\n+        assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards));\n+        assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        ensureLeaderGreen(leaderIndex);\n+\n+        final IndexStats indexStats = leaderClient().admin().indices().prepareStats(leaderIndex)\n+            .clear()\n+            .setStore(true)\n+            .get()\n+            .getIndex(leaderIndex);\n+        assertThat(indexStats.getIndexShards(), notNullValue());\n+        assertThat(indexStats.getIndexShards(), aMapWithSize(numberOfShards));\n+\n+        final long[] storeSizeInBytes = new long[numberOfShards];\n+        indexStats.getIndexShards().forEach((key, value) -> storeSizeInBytes[key] = value.getPrimary().getStore().getSizeInBytes());\n+\n+        final String leaderCluster = CcrRepository.NAME_PREFIX + \"leader_cluster\";\n+        final RepositoriesService repositoriesService = getFollowerCluster().getCurrentMasterNodeInstance(RepositoriesService.class);\n+        final Repository repository = repositoriesService.repository(leaderCluster);\n+        assertThat(repository.getMetadata().type(), equalTo(CcrRepository.TYPE));\n+        assertThat(repository.getMetadata().name(), equalTo(leaderCluster));\n+\n+        for (int shardId = 0; shardId < numberOfShards; shardId++) {\n+            IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = repository.getShardSnapshotStatus(\n+                new SnapshotId(CcrRepository.LATEST, CcrRepository.LATEST),\n+                new IndexId(indexStats.getIndex(), indexStats.getUuid()),\n+                new ShardId(new Index(indexStats.getIndex(), indexStats.getUuid()), shardId)).asCopy();\n+\n+            assertThat(indexShardSnapshotStatus, notNullValue());\n+            assertThat(indexShardSnapshotStatus.getStage(), is(IndexShardSnapshotStatus.Stage.DONE));\n+            assertThat(indexShardSnapshotStatus.getTotalSize(), equalTo(storeSizeInBytes[shardId]));\n+        }\n+\n+        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n+\n+        final List<MockTransportService> transportServices = new ArrayList<>();\n+        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n+            final MockTransportService mockTransportService = (MockTransportService) transportService;\n+            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n+                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n+                    try {\n+                        blockCcrRestore.await();\n+                    } catch (InterruptedException e) {\n+                        throw new ElasticsearchException(e);\n+                    }\n+                }\n+                connection.sendRequest(requestId, action, request, options);\n+            });\n+            transportServices.add(mockTransportService);\n+        }\n+\n+        try {\n+            final RestoreService restoreService = getFollowerCluster().getCurrentMasterNodeInstance(RestoreService.class);\n+            final ClusterService clusterService = getFollowerCluster().getCurrentMasterNodeInstance(ClusterService.class);\n+\n+            final CountDownLatch waitForRestoreInProgress = new CountDownLatch(1);\n+            final ClusterStateListener listener = event -> {\n+                RestoreInProgress restoreInProgress = event.state().custom(RestoreInProgress.TYPE, RestoreInProgress.EMPTY);\n+                if (restoreInProgress != null && restoreInProgress.isEmpty() == false) {\n+                    waitForRestoreInProgress.countDown();\n+                }\n+            };\n+            clusterService.addListener(listener);\n+\n+            final String followerIndex = \"follower\";\n+            final RestoreSnapshotRequest restoreRequest = new RestoreSnapshotRequest(leaderCluster, CcrRepository.LATEST)\n+                .indices(leaderIndex).indicesOptions(indicesOptions).renamePattern(\"^(.*)$\")\n+                .renameReplacement(followerIndex)\n+                .masterNodeTimeout(TimeValue.MAX_VALUE)\n+                .indexSettings(Settings.builder()\n+                    .put(IndexMetadata.SETTING_INDEX_PROVIDED_NAME, followerIndex)\n+                    .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true));\n+            restoreService.restoreSnapshot(restoreRequest, PlainActionFuture.newFuture());\n+\n+            waitForRestoreInProgress.await(30L, TimeUnit.SECONDS);\n+            clusterService.removeListener(listener);\n+\n+            final IndexRoutingTable indexRoutingTable = followerClient().admin().cluster().prepareState().clear().setRoutingTable(true)", "originalCommit": "680defec049132ea75dd369d78cabacaefa428a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAwNjI0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/63590#discussion_r504006246", "bodyText": "Thanks for the suggestion, I pushed 539caaf", "author": "tlrx", "createdAt": "2020-10-13T14:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg5MDU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg5MDk0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/63590#discussion_r503890943", "bodyText": "just rethrow AssertionError?", "author": "original-brownbear", "createdAt": "2020-10-13T11:58:01Z", "path": "x-pack/plugin/ccr/src/internalClusterTest/java/org/elasticsearch/xpack/ccr/CcrRepositoryIT.java", "diffHunk": "@@ -439,6 +463,242 @@ public void testFollowerMappingIsUpdated() throws IOException {\n         }\n     }\n \n+    public void testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats() throws Exception {\n+        final String leaderIndex = \"leader\";\n+        final int numberOfShards = randomIntBetween(1, 2);\n+        assertAcked(leaderClient().admin().indices().prepareCreate(leaderIndex)\n+            .setSource(getIndexSettings(numberOfShards, 0,\n+                Map.of(Store.INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING.getKey(), TimeValue.ZERO.getStringRep())), XContentType.JSON));\n+\n+        final int numDocs = scaledRandomIntBetween(0, 1_000);\n+        final BulkRequestBuilder bulkRequest = leaderClient().prepareBulk(leaderIndex);\n+        for (int i = 0; i < numDocs; i++) {\n+            bulkRequest.add(new IndexRequest(leaderIndex)\n+                .id(Integer.toString(i))\n+                .source(XContentType.JSON, \"field\", i));\n+        }\n+        assertThat(bulkRequest.get().hasFailures(), is(false));\n+\n+        final ForceMergeResponse forceMergeResponse = leaderClient().admin().indices().prepareForceMerge(leaderIndex).setFlush(true).get();\n+        assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards));\n+        assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        ensureLeaderGreen(leaderIndex);\n+\n+        final IndexStats indexStats = leaderClient().admin().indices().prepareStats(leaderIndex)\n+            .clear()\n+            .setStore(true)\n+            .get()\n+            .getIndex(leaderIndex);\n+        assertThat(indexStats.getIndexShards(), notNullValue());\n+        assertThat(indexStats.getIndexShards(), aMapWithSize(numberOfShards));\n+\n+        final long[] storeSizeInBytes = new long[numberOfShards];\n+        indexStats.getIndexShards().forEach((key, value) -> storeSizeInBytes[key] = value.getPrimary().getStore().getSizeInBytes());\n+\n+        final String leaderCluster = CcrRepository.NAME_PREFIX + \"leader_cluster\";\n+        final RepositoriesService repositoriesService = getFollowerCluster().getCurrentMasterNodeInstance(RepositoriesService.class);\n+        final Repository repository = repositoriesService.repository(leaderCluster);\n+        assertThat(repository.getMetadata().type(), equalTo(CcrRepository.TYPE));\n+        assertThat(repository.getMetadata().name(), equalTo(leaderCluster));\n+\n+        for (int shardId = 0; shardId < numberOfShards; shardId++) {\n+            IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = repository.getShardSnapshotStatus(\n+                new SnapshotId(CcrRepository.LATEST, CcrRepository.LATEST),\n+                new IndexId(indexStats.getIndex(), indexStats.getUuid()),\n+                new ShardId(new Index(indexStats.getIndex(), indexStats.getUuid()), shardId)).asCopy();\n+\n+            assertThat(indexShardSnapshotStatus, notNullValue());\n+            assertThat(indexShardSnapshotStatus.getStage(), is(IndexShardSnapshotStatus.Stage.DONE));\n+            assertThat(indexShardSnapshotStatus.getTotalSize(), equalTo(storeSizeInBytes[shardId]));\n+        }\n+\n+        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n+\n+        final List<MockTransportService> transportServices = new ArrayList<>();\n+        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n+            final MockTransportService mockTransportService = (MockTransportService) transportService;\n+            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n+                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n+                    try {\n+                        blockCcrRestore.await();\n+                    } catch (InterruptedException e) {\n+                        throw new ElasticsearchException(e);", "originalCommit": "680defec049132ea75dd369d78cabacaefa428a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg5MTIwNw==", "url": "https://github.com/elastic/elasticsearch/pull/63590#discussion_r503891207", "bodyText": "Just rethrow AssertionError?", "author": "original-brownbear", "createdAt": "2020-10-13T11:58:28Z", "path": "x-pack/plugin/ccr/src/internalClusterTest/java/org/elasticsearch/xpack/ccr/CcrRepositoryIT.java", "diffHunk": "@@ -439,6 +463,242 @@ public void testFollowerMappingIsUpdated() throws IOException {\n         }\n     }\n \n+    public void testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats() throws Exception {\n+        final String leaderIndex = \"leader\";\n+        final int numberOfShards = randomIntBetween(1, 2);\n+        assertAcked(leaderClient().admin().indices().prepareCreate(leaderIndex)\n+            .setSource(getIndexSettings(numberOfShards, 0,\n+                Map.of(Store.INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING.getKey(), TimeValue.ZERO.getStringRep())), XContentType.JSON));\n+\n+        final int numDocs = scaledRandomIntBetween(0, 1_000);\n+        final BulkRequestBuilder bulkRequest = leaderClient().prepareBulk(leaderIndex);\n+        for (int i = 0; i < numDocs; i++) {\n+            bulkRequest.add(new IndexRequest(leaderIndex)\n+                .id(Integer.toString(i))\n+                .source(XContentType.JSON, \"field\", i));\n+        }\n+        assertThat(bulkRequest.get().hasFailures(), is(false));\n+\n+        final ForceMergeResponse forceMergeResponse = leaderClient().admin().indices().prepareForceMerge(leaderIndex).setFlush(true).get();\n+        assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards));\n+        assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        ensureLeaderGreen(leaderIndex);\n+\n+        final IndexStats indexStats = leaderClient().admin().indices().prepareStats(leaderIndex)\n+            .clear()\n+            .setStore(true)\n+            .get()\n+            .getIndex(leaderIndex);\n+        assertThat(indexStats.getIndexShards(), notNullValue());\n+        assertThat(indexStats.getIndexShards(), aMapWithSize(numberOfShards));\n+\n+        final long[] storeSizeInBytes = new long[numberOfShards];\n+        indexStats.getIndexShards().forEach((key, value) -> storeSizeInBytes[key] = value.getPrimary().getStore().getSizeInBytes());\n+\n+        final String leaderCluster = CcrRepository.NAME_PREFIX + \"leader_cluster\";\n+        final RepositoriesService repositoriesService = getFollowerCluster().getCurrentMasterNodeInstance(RepositoriesService.class);\n+        final Repository repository = repositoriesService.repository(leaderCluster);\n+        assertThat(repository.getMetadata().type(), equalTo(CcrRepository.TYPE));\n+        assertThat(repository.getMetadata().name(), equalTo(leaderCluster));\n+\n+        for (int shardId = 0; shardId < numberOfShards; shardId++) {\n+            IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = repository.getShardSnapshotStatus(\n+                new SnapshotId(CcrRepository.LATEST, CcrRepository.LATEST),\n+                new IndexId(indexStats.getIndex(), indexStats.getUuid()),\n+                new ShardId(new Index(indexStats.getIndex(), indexStats.getUuid()), shardId)).asCopy();\n+\n+            assertThat(indexShardSnapshotStatus, notNullValue());\n+            assertThat(indexShardSnapshotStatus.getStage(), is(IndexShardSnapshotStatus.Stage.DONE));\n+            assertThat(indexShardSnapshotStatus.getTotalSize(), equalTo(storeSizeInBytes[shardId]));\n+        }\n+\n+        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n+\n+        final List<MockTransportService> transportServices = new ArrayList<>();\n+        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n+            final MockTransportService mockTransportService = (MockTransportService) transportService;\n+            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n+                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n+                    try {\n+                        blockCcrRestore.await();\n+                    } catch (InterruptedException e) {\n+                        throw new ElasticsearchException(e);\n+                    }\n+                }\n+                connection.sendRequest(requestId, action, request, options);\n+            });\n+            transportServices.add(mockTransportService);\n+        }\n+\n+        try {\n+            final RestoreService restoreService = getFollowerCluster().getCurrentMasterNodeInstance(RestoreService.class);\n+            final ClusterService clusterService = getFollowerCluster().getCurrentMasterNodeInstance(ClusterService.class);\n+\n+            final CountDownLatch waitForRestoreInProgress = new CountDownLatch(1);\n+            final ClusterStateListener listener = event -> {\n+                RestoreInProgress restoreInProgress = event.state().custom(RestoreInProgress.TYPE, RestoreInProgress.EMPTY);\n+                if (restoreInProgress != null && restoreInProgress.isEmpty() == false) {\n+                    waitForRestoreInProgress.countDown();\n+                }\n+            };\n+            clusterService.addListener(listener);\n+\n+            final String followerIndex = \"follower\";\n+            final RestoreSnapshotRequest restoreRequest = new RestoreSnapshotRequest(leaderCluster, CcrRepository.LATEST)\n+                .indices(leaderIndex).indicesOptions(indicesOptions).renamePattern(\"^(.*)$\")\n+                .renameReplacement(followerIndex)\n+                .masterNodeTimeout(TimeValue.MAX_VALUE)\n+                .indexSettings(Settings.builder()\n+                    .put(IndexMetadata.SETTING_INDEX_PROVIDED_NAME, followerIndex)\n+                    .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true));\n+            restoreService.restoreSnapshot(restoreRequest, PlainActionFuture.newFuture());\n+\n+            waitForRestoreInProgress.await(30L, TimeUnit.SECONDS);\n+            clusterService.removeListener(listener);\n+\n+            final IndexRoutingTable indexRoutingTable = followerClient().admin().cluster().prepareState().clear().setRoutingTable(true)\n+                .setIndices(followerIndex).get().getState().routingTable().index(followerIndex);\n+            assertThat(indexRoutingTable, notNullValue());\n+\n+            final SnapshotsInfoService snapshotsInfoService = getFollowerCluster().getCurrentMasterNodeInstance(SnapshotsInfoService.class);\n+            assertBusy(() -> {\n+                SnapshotShardSizeInfo snapshotShardSizeInfo = snapshotsInfoService.snapshotShardSizes();\n+                for (int shardId = 0; shardId < numberOfShards; shardId++) {\n+                    Long snapshotShardSize = snapshotShardSizeInfo.getShardSize(indexRoutingTable.shard(shardId).primaryShard());\n+                    assertThat(snapshotShardSize, equalTo(storeSizeInBytes[shardId]));\n+                }\n+            });\n+\n+            blockCcrRestore.countDown();\n+            ensureFollowerGreen(followerIndex);\n+\n+            assertAcked(followerClient().admin().indices().prepareDelete(followerIndex).setMasterNodeTimeout(TimeValue.MAX_VALUE));\n+        } finally {\n+            transportServices.forEach(MockTransportService::clearAllRules);\n+        }\n+    }\n+\n+    public void testCcrRepositoryFailsToFetchSnapshotShardSizes() throws Exception {\n+        final String leaderIndex = \"leader\";\n+        final int numberOfShards = randomIntBetween(1, 2);\n+        assertAcked(leaderClient().admin().indices().prepareCreate(leaderIndex)\n+            .setSource(getIndexSettings(numberOfShards, 0,\n+                Map.of(Store.INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING.getKey(), TimeValue.ZERO.getStringRep())), XContentType.JSON));\n+\n+        final IndexMetadata indexMetadata = leaderClient().admin().cluster().prepareState().setIndices(leaderIndex)\n+            .clear().setMetadata(true).get().getState().metadata().index(leaderIndex);\n+\n+        final AtomicInteger indicesStatsRequestsCount = new AtomicInteger(0);\n+        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n+\n+        final List<MockTransportService> transportServices = new ArrayList<>();\n+        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n+            final MockTransportService mockTransportService = (MockTransportService) transportService;\n+            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n+                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n+                    try {\n+                        blockCcrRestore.await();\n+                    } catch (InterruptedException e) {\n+                        throw new ElasticsearchException(e);", "originalCommit": "680defec049132ea75dd369d78cabacaefa428a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg5MTk3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/63590#discussion_r503891976", "bodyText": "Merge nested if?", "author": "original-brownbear", "createdAt": "2020-10-13T11:59:46Z", "path": "x-pack/plugin/ccr/src/internalClusterTest/java/org/elasticsearch/xpack/ccr/CcrRepositoryIT.java", "diffHunk": "@@ -439,6 +463,242 @@ public void testFollowerMappingIsUpdated() throws IOException {\n         }\n     }\n \n+    public void testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats() throws Exception {\n+        final String leaderIndex = \"leader\";\n+        final int numberOfShards = randomIntBetween(1, 2);\n+        assertAcked(leaderClient().admin().indices().prepareCreate(leaderIndex)\n+            .setSource(getIndexSettings(numberOfShards, 0,\n+                Map.of(Store.INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING.getKey(), TimeValue.ZERO.getStringRep())), XContentType.JSON));\n+\n+        final int numDocs = scaledRandomIntBetween(0, 1_000);\n+        final BulkRequestBuilder bulkRequest = leaderClient().prepareBulk(leaderIndex);\n+        for (int i = 0; i < numDocs; i++) {\n+            bulkRequest.add(new IndexRequest(leaderIndex)\n+                .id(Integer.toString(i))\n+                .source(XContentType.JSON, \"field\", i));\n+        }\n+        assertThat(bulkRequest.get().hasFailures(), is(false));\n+\n+        final ForceMergeResponse forceMergeResponse = leaderClient().admin().indices().prepareForceMerge(leaderIndex).setFlush(true).get();\n+        assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards));\n+        assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        ensureLeaderGreen(leaderIndex);\n+\n+        final IndexStats indexStats = leaderClient().admin().indices().prepareStats(leaderIndex)\n+            .clear()\n+            .setStore(true)\n+            .get()\n+            .getIndex(leaderIndex);\n+        assertThat(indexStats.getIndexShards(), notNullValue());\n+        assertThat(indexStats.getIndexShards(), aMapWithSize(numberOfShards));\n+\n+        final long[] storeSizeInBytes = new long[numberOfShards];\n+        indexStats.getIndexShards().forEach((key, value) -> storeSizeInBytes[key] = value.getPrimary().getStore().getSizeInBytes());\n+\n+        final String leaderCluster = CcrRepository.NAME_PREFIX + \"leader_cluster\";\n+        final RepositoriesService repositoriesService = getFollowerCluster().getCurrentMasterNodeInstance(RepositoriesService.class);\n+        final Repository repository = repositoriesService.repository(leaderCluster);\n+        assertThat(repository.getMetadata().type(), equalTo(CcrRepository.TYPE));\n+        assertThat(repository.getMetadata().name(), equalTo(leaderCluster));\n+\n+        for (int shardId = 0; shardId < numberOfShards; shardId++) {\n+            IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = repository.getShardSnapshotStatus(\n+                new SnapshotId(CcrRepository.LATEST, CcrRepository.LATEST),\n+                new IndexId(indexStats.getIndex(), indexStats.getUuid()),\n+                new ShardId(new Index(indexStats.getIndex(), indexStats.getUuid()), shardId)).asCopy();\n+\n+            assertThat(indexShardSnapshotStatus, notNullValue());\n+            assertThat(indexShardSnapshotStatus.getStage(), is(IndexShardSnapshotStatus.Stage.DONE));\n+            assertThat(indexShardSnapshotStatus.getTotalSize(), equalTo(storeSizeInBytes[shardId]));\n+        }\n+\n+        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n+\n+        final List<MockTransportService> transportServices = new ArrayList<>();\n+        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n+            final MockTransportService mockTransportService = (MockTransportService) transportService;\n+            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n+                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n+                    try {\n+                        blockCcrRestore.await();\n+                    } catch (InterruptedException e) {\n+                        throw new ElasticsearchException(e);\n+                    }\n+                }\n+                connection.sendRequest(requestId, action, request, options);\n+            });\n+            transportServices.add(mockTransportService);\n+        }\n+\n+        try {\n+            final RestoreService restoreService = getFollowerCluster().getCurrentMasterNodeInstance(RestoreService.class);\n+            final ClusterService clusterService = getFollowerCluster().getCurrentMasterNodeInstance(ClusterService.class);\n+\n+            final CountDownLatch waitForRestoreInProgress = new CountDownLatch(1);\n+            final ClusterStateListener listener = event -> {\n+                RestoreInProgress restoreInProgress = event.state().custom(RestoreInProgress.TYPE, RestoreInProgress.EMPTY);\n+                if (restoreInProgress != null && restoreInProgress.isEmpty() == false) {\n+                    waitForRestoreInProgress.countDown();\n+                }\n+            };\n+            clusterService.addListener(listener);\n+\n+            final String followerIndex = \"follower\";\n+            final RestoreSnapshotRequest restoreRequest = new RestoreSnapshotRequest(leaderCluster, CcrRepository.LATEST)\n+                .indices(leaderIndex).indicesOptions(indicesOptions).renamePattern(\"^(.*)$\")\n+                .renameReplacement(followerIndex)\n+                .masterNodeTimeout(TimeValue.MAX_VALUE)\n+                .indexSettings(Settings.builder()\n+                    .put(IndexMetadata.SETTING_INDEX_PROVIDED_NAME, followerIndex)\n+                    .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true));\n+            restoreService.restoreSnapshot(restoreRequest, PlainActionFuture.newFuture());\n+\n+            waitForRestoreInProgress.await(30L, TimeUnit.SECONDS);\n+            clusterService.removeListener(listener);\n+\n+            final IndexRoutingTable indexRoutingTable = followerClient().admin().cluster().prepareState().clear().setRoutingTable(true)\n+                .setIndices(followerIndex).get().getState().routingTable().index(followerIndex);\n+            assertThat(indexRoutingTable, notNullValue());\n+\n+            final SnapshotsInfoService snapshotsInfoService = getFollowerCluster().getCurrentMasterNodeInstance(SnapshotsInfoService.class);\n+            assertBusy(() -> {\n+                SnapshotShardSizeInfo snapshotShardSizeInfo = snapshotsInfoService.snapshotShardSizes();\n+                for (int shardId = 0; shardId < numberOfShards; shardId++) {\n+                    Long snapshotShardSize = snapshotShardSizeInfo.getShardSize(indexRoutingTable.shard(shardId).primaryShard());\n+                    assertThat(snapshotShardSize, equalTo(storeSizeInBytes[shardId]));\n+                }\n+            });\n+\n+            blockCcrRestore.countDown();\n+            ensureFollowerGreen(followerIndex);\n+\n+            assertAcked(followerClient().admin().indices().prepareDelete(followerIndex).setMasterNodeTimeout(TimeValue.MAX_VALUE));\n+        } finally {\n+            transportServices.forEach(MockTransportService::clearAllRules);\n+        }\n+    }\n+\n+    public void testCcrRepositoryFailsToFetchSnapshotShardSizes() throws Exception {\n+        final String leaderIndex = \"leader\";\n+        final int numberOfShards = randomIntBetween(1, 2);\n+        assertAcked(leaderClient().admin().indices().prepareCreate(leaderIndex)\n+            .setSource(getIndexSettings(numberOfShards, 0,\n+                Map.of(Store.INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING.getKey(), TimeValue.ZERO.getStringRep())), XContentType.JSON));\n+\n+        final IndexMetadata indexMetadata = leaderClient().admin().cluster().prepareState().setIndices(leaderIndex)\n+            .clear().setMetadata(true).get().getState().metadata().index(leaderIndex);\n+\n+        final AtomicInteger indicesStatsRequestsCount = new AtomicInteger(0);\n+        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n+\n+        final List<MockTransportService> transportServices = new ArrayList<>();\n+        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n+            final MockTransportService mockTransportService = (MockTransportService) transportService;\n+            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n+                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n+                    try {\n+                        blockCcrRestore.await();\n+                    } catch (InterruptedException e) {\n+                        throw new ElasticsearchException(e);\n+                    }\n+                }\n+                connection.sendRequest(requestId, action, request, options);\n+            });\n+            transportServices.add(mockTransportService);\n+        }\n+        for (TransportService transportService : getLeaderCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n+            final MockTransportService mockTransportService = (MockTransportService) transportService;\n+            mockTransportService.addRequestHandlingBehavior(IndicesStatsAction.NAME, (handler, request, channel, task) -> {\n+                if (request instanceof IndicesStatsRequest) {\n+                    IndicesStatsRequest indicesStatsRequest = (IndicesStatsRequest) request;\n+                    if (Arrays.equals(indicesStatsRequest.indices(), new String[]{leaderIndex})) {\n+                        if (indicesStatsRequest.store()", "originalCommit": "680defec049132ea75dd369d78cabacaefa428a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk5NTMzMw==", "url": "https://github.com/elastic/elasticsearch/pull/63590#discussion_r503995333", "bodyText": "Sure", "author": "tlrx", "createdAt": "2020-10-13T14:23:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg5MTk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg5MzMwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/63590#discussion_r503893301", "bodyText": "Why do we need TimeValue.MAX_VALUE, the default 30s or so should be fine? (same in the other test?)", "author": "original-brownbear", "createdAt": "2020-10-13T12:01:58Z", "path": "x-pack/plugin/ccr/src/internalClusterTest/java/org/elasticsearch/xpack/ccr/CcrRepositoryIT.java", "diffHunk": "@@ -439,6 +463,242 @@ public void testFollowerMappingIsUpdated() throws IOException {\n         }\n     }\n \n+    public void testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats() throws Exception {\n+        final String leaderIndex = \"leader\";\n+        final int numberOfShards = randomIntBetween(1, 2);\n+        assertAcked(leaderClient().admin().indices().prepareCreate(leaderIndex)\n+            .setSource(getIndexSettings(numberOfShards, 0,\n+                Map.of(Store.INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING.getKey(), TimeValue.ZERO.getStringRep())), XContentType.JSON));\n+\n+        final int numDocs = scaledRandomIntBetween(0, 1_000);\n+        final BulkRequestBuilder bulkRequest = leaderClient().prepareBulk(leaderIndex);\n+        for (int i = 0; i < numDocs; i++) {\n+            bulkRequest.add(new IndexRequest(leaderIndex)\n+                .id(Integer.toString(i))\n+                .source(XContentType.JSON, \"field\", i));\n+        }\n+        assertThat(bulkRequest.get().hasFailures(), is(false));\n+\n+        final ForceMergeResponse forceMergeResponse = leaderClient().admin().indices().prepareForceMerge(leaderIndex).setFlush(true).get();\n+        assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards));\n+        assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        ensureLeaderGreen(leaderIndex);\n+\n+        final IndexStats indexStats = leaderClient().admin().indices().prepareStats(leaderIndex)\n+            .clear()\n+            .setStore(true)\n+            .get()\n+            .getIndex(leaderIndex);\n+        assertThat(indexStats.getIndexShards(), notNullValue());\n+        assertThat(indexStats.getIndexShards(), aMapWithSize(numberOfShards));\n+\n+        final long[] storeSizeInBytes = new long[numberOfShards];\n+        indexStats.getIndexShards().forEach((key, value) -> storeSizeInBytes[key] = value.getPrimary().getStore().getSizeInBytes());\n+\n+        final String leaderCluster = CcrRepository.NAME_PREFIX + \"leader_cluster\";\n+        final RepositoriesService repositoriesService = getFollowerCluster().getCurrentMasterNodeInstance(RepositoriesService.class);\n+        final Repository repository = repositoriesService.repository(leaderCluster);\n+        assertThat(repository.getMetadata().type(), equalTo(CcrRepository.TYPE));\n+        assertThat(repository.getMetadata().name(), equalTo(leaderCluster));\n+\n+        for (int shardId = 0; shardId < numberOfShards; shardId++) {\n+            IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = repository.getShardSnapshotStatus(\n+                new SnapshotId(CcrRepository.LATEST, CcrRepository.LATEST),\n+                new IndexId(indexStats.getIndex(), indexStats.getUuid()),\n+                new ShardId(new Index(indexStats.getIndex(), indexStats.getUuid()), shardId)).asCopy();\n+\n+            assertThat(indexShardSnapshotStatus, notNullValue());\n+            assertThat(indexShardSnapshotStatus.getStage(), is(IndexShardSnapshotStatus.Stage.DONE));\n+            assertThat(indexShardSnapshotStatus.getTotalSize(), equalTo(storeSizeInBytes[shardId]));\n+        }\n+\n+        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n+\n+        final List<MockTransportService> transportServices = new ArrayList<>();\n+        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n+            final MockTransportService mockTransportService = (MockTransportService) transportService;\n+            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n+                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n+                    try {\n+                        blockCcrRestore.await();\n+                    } catch (InterruptedException e) {\n+                        throw new ElasticsearchException(e);\n+                    }\n+                }\n+                connection.sendRequest(requestId, action, request, options);\n+            });\n+            transportServices.add(mockTransportService);\n+        }\n+\n+        try {\n+            final RestoreService restoreService = getFollowerCluster().getCurrentMasterNodeInstance(RestoreService.class);\n+            final ClusterService clusterService = getFollowerCluster().getCurrentMasterNodeInstance(ClusterService.class);\n+\n+            final CountDownLatch waitForRestoreInProgress = new CountDownLatch(1);\n+            final ClusterStateListener listener = event -> {\n+                RestoreInProgress restoreInProgress = event.state().custom(RestoreInProgress.TYPE, RestoreInProgress.EMPTY);\n+                if (restoreInProgress != null && restoreInProgress.isEmpty() == false) {\n+                    waitForRestoreInProgress.countDown();\n+                }\n+            };\n+            clusterService.addListener(listener);\n+\n+            final String followerIndex = \"follower\";\n+            final RestoreSnapshotRequest restoreRequest = new RestoreSnapshotRequest(leaderCluster, CcrRepository.LATEST)\n+                .indices(leaderIndex).indicesOptions(indicesOptions).renamePattern(\"^(.*)$\")\n+                .renameReplacement(followerIndex)\n+                .masterNodeTimeout(TimeValue.MAX_VALUE)\n+                .indexSettings(Settings.builder()\n+                    .put(IndexMetadata.SETTING_INDEX_PROVIDED_NAME, followerIndex)\n+                    .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true));\n+            restoreService.restoreSnapshot(restoreRequest, PlainActionFuture.newFuture());\n+\n+            waitForRestoreInProgress.await(30L, TimeUnit.SECONDS);\n+            clusterService.removeListener(listener);\n+\n+            final IndexRoutingTable indexRoutingTable = followerClient().admin().cluster().prepareState().clear().setRoutingTable(true)\n+                .setIndices(followerIndex).get().getState().routingTable().index(followerIndex);\n+            assertThat(indexRoutingTable, notNullValue());\n+\n+            final SnapshotsInfoService snapshotsInfoService = getFollowerCluster().getCurrentMasterNodeInstance(SnapshotsInfoService.class);\n+            assertBusy(() -> {\n+                SnapshotShardSizeInfo snapshotShardSizeInfo = snapshotsInfoService.snapshotShardSizes();\n+                for (int shardId = 0; shardId < numberOfShards; shardId++) {\n+                    Long snapshotShardSize = snapshotShardSizeInfo.getShardSize(indexRoutingTable.shard(shardId).primaryShard());\n+                    assertThat(snapshotShardSize, equalTo(storeSizeInBytes[shardId]));\n+                }\n+            });\n+\n+            blockCcrRestore.countDown();\n+            ensureFollowerGreen(followerIndex);\n+\n+            assertAcked(followerClient().admin().indices().prepareDelete(followerIndex).setMasterNodeTimeout(TimeValue.MAX_VALUE));\n+        } finally {\n+            transportServices.forEach(MockTransportService::clearAllRules);\n+        }\n+    }\n+\n+    public void testCcrRepositoryFailsToFetchSnapshotShardSizes() throws Exception {\n+        final String leaderIndex = \"leader\";\n+        final int numberOfShards = randomIntBetween(1, 2);\n+        assertAcked(leaderClient().admin().indices().prepareCreate(leaderIndex)\n+            .setSource(getIndexSettings(numberOfShards, 0,\n+                Map.of(Store.INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING.getKey(), TimeValue.ZERO.getStringRep())), XContentType.JSON));\n+\n+        final IndexMetadata indexMetadata = leaderClient().admin().cluster().prepareState().setIndices(leaderIndex)\n+            .clear().setMetadata(true).get().getState().metadata().index(leaderIndex);\n+\n+        final AtomicInteger indicesStatsRequestsCount = new AtomicInteger(0);\n+        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n+\n+        final List<MockTransportService> transportServices = new ArrayList<>();\n+        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n+            final MockTransportService mockTransportService = (MockTransportService) transportService;\n+            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n+                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n+                    try {\n+                        blockCcrRestore.await();\n+                    } catch (InterruptedException e) {\n+                        throw new ElasticsearchException(e);\n+                    }\n+                }\n+                connection.sendRequest(requestId, action, request, options);\n+            });\n+            transportServices.add(mockTransportService);\n+        }\n+        for (TransportService transportService : getLeaderCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n+            final MockTransportService mockTransportService = (MockTransportService) transportService;\n+            mockTransportService.addRequestHandlingBehavior(IndicesStatsAction.NAME, (handler, request, channel, task) -> {\n+                if (request instanceof IndicesStatsRequest) {\n+                    IndicesStatsRequest indicesStatsRequest = (IndicesStatsRequest) request;\n+                    if (Arrays.equals(indicesStatsRequest.indices(), new String[]{leaderIndex})) {\n+                        if (indicesStatsRequest.store()\n+                            && indicesStatsRequest.search() == false\n+                            && indicesStatsRequest.fieldData() == false\n+                        ) {\n+                            indicesStatsRequestsCount.incrementAndGet();\n+                            channel.sendResponse(new ElasticsearchException(\"simulated\"));\n+                            return;\n+                        }\n+                    }\n+                }\n+                handler.messageReceived(request, channel, task);\n+            });\n+            transportServices.add(mockTransportService);\n+        }\n+\n+        final String followerIndex = \"follower\";\n+        try {\n+            final String leaderCluster = CcrRepository.NAME_PREFIX + \"leader_cluster\";\n+            final RepositoriesService repositoriesService = getFollowerCluster().getCurrentMasterNodeInstance(RepositoriesService.class);\n+            final Repository repository = repositoriesService.repository(leaderCluster);\n+            assertThat(repository.getMetadata().type(), equalTo(CcrRepository.TYPE));\n+            assertThat(repository.getMetadata().name(), equalTo(leaderCluster));\n+\n+            for (int i = 0; i < numberOfShards; i++) {\n+                final Index index = indexMetadata.getIndex();\n+                final int shardId = i;\n+                ElasticsearchException exception = expectThrows(ElasticsearchException.class,\n+                    () -> repository.getShardSnapshotStatus(\n+                        new SnapshotId(CcrRepository.LATEST, CcrRepository.LATEST),\n+                        new IndexId(index.getName(), index.getUUID()),\n+                        new ShardId(index, shardId)));\n+                assertThat(exception.getMessage(), equalTo(\"simulated\"));\n+            }\n+            assertThat(indicesStatsRequestsCount.getAndSet(0), equalTo(numberOfShards));\n+\n+            final RestoreService restoreService = getFollowerCluster().getCurrentMasterNodeInstance(RestoreService.class);\n+            final ClusterService clusterService = getFollowerCluster().getCurrentMasterNodeInstance(ClusterService.class);\n+\n+            final CountDownLatch waitForRestoreInProgress = new CountDownLatch(1);\n+            final ClusterStateListener listener = event -> {\n+                RestoreInProgress restoreInProgress = event.state().custom(RestoreInProgress.TYPE, RestoreInProgress.EMPTY);\n+                if (restoreInProgress != null && restoreInProgress.isEmpty() == false) {\n+                    waitForRestoreInProgress.countDown();\n+                }\n+            };\n+            clusterService.addListener(listener);\n+\n+            final RestoreSnapshotRequest restoreRequest = new RestoreSnapshotRequest(leaderCluster, CcrRepository.LATEST)\n+                .indices(leaderIndex).indicesOptions(indicesOptions).renamePattern(\"^(.*)$\")\n+                .renameReplacement(followerIndex)\n+                .masterNodeTimeout(TimeValue.MAX_VALUE)\n+                .indexSettings(Settings.builder()\n+                    .put(IndexMetadata.SETTING_INDEX_PROVIDED_NAME, followerIndex)\n+                    .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true));\n+            restoreService.restoreSnapshot(restoreRequest, PlainActionFuture.newFuture());\n+\n+            waitForRestoreInProgress.await(30L, TimeUnit.SECONDS);\n+            clusterService.removeListener(listener);\n+\n+            final IndexRoutingTable indexRoutingTable = followerClient().admin().cluster().prepareState().clear().setRoutingTable(true)\n+                .setIndices(followerIndex).get().getState().routingTable().index(followerIndex);\n+            assertThat(indexRoutingTable, notNullValue());\n+\n+            final SnapshotsInfoService snapshotsInfoService = getFollowerCluster().getCurrentMasterNodeInstance(SnapshotsInfoService.class);\n+            assertBusy(() -> {\n+                SnapshotShardSizeInfo snapshotShardSizeInfo = snapshotsInfoService.snapshotShardSizes();\n+                for (int shardId = 0; shardId < numberOfShards; shardId++) {\n+                    final ShardRouting primary = indexRoutingTable.shard(shardId).primaryShard();\n+                    assertThat(snapshotShardSizeInfo.getShardSize(primary), equalTo(ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE));\n+                    final long randomSize = randomNonNegativeLong();\n+                    assertThat(snapshotShardSizeInfo.getShardSize(primary, randomSize), equalTo(randomSize));\n+                }\n+            });\n+        } finally {\n+            transportServices.forEach(MockTransportService::clearAllRules);\n+        }\n+\n+        assertThat(indicesStatsRequestsCount.get(), equalTo(numberOfShards));\n+        blockCcrRestore.countDown();\n+\n+        followerClient().admin().cluster().prepareReroute().get();\n+        ensureFollowerGreen(followerIndex);\n+\n+        assertAcked(followerClient().admin().indices().prepareDelete(followerIndex).setMasterNodeTimeout(TimeValue.MAX_VALUE));", "originalCommit": "680defec049132ea75dd369d78cabacaefa428a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk5Nzg2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/63590#discussion_r503997862", "bodyText": "Because of CcrIntegTestCase#setupMasterNodeRequestsValidatorOnFollowerCluster() which verifies that the master node timeout is unlimited on AcknowledgedRequest requests (#60070 has some background on this)", "author": "tlrx", "createdAt": "2020-10-13T14:26:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg5MzMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg5MzM1OA==", "url": "https://github.com/elastic/elasticsearch/pull/63590#discussion_r503893358", "bodyText": "NIT: random empty line", "author": "original-brownbear", "createdAt": "2020-10-13T12:02:06Z", "path": "x-pack/plugin/ccr/src/internalClusterTest/java/org/elasticsearch/xpack/ccr/CcrRepositoryIT.java", "diffHunk": "@@ -439,6 +463,242 @@ public void testFollowerMappingIsUpdated() throws IOException {\n         }\n     }\n \n+    public void testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats() throws Exception {\n+        final String leaderIndex = \"leader\";\n+        final int numberOfShards = randomIntBetween(1, 2);\n+        assertAcked(leaderClient().admin().indices().prepareCreate(leaderIndex)\n+            .setSource(getIndexSettings(numberOfShards, 0,\n+                Map.of(Store.INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING.getKey(), TimeValue.ZERO.getStringRep())), XContentType.JSON));\n+\n+        final int numDocs = scaledRandomIntBetween(0, 1_000);\n+        final BulkRequestBuilder bulkRequest = leaderClient().prepareBulk(leaderIndex);\n+        for (int i = 0; i < numDocs; i++) {\n+            bulkRequest.add(new IndexRequest(leaderIndex)\n+                .id(Integer.toString(i))\n+                .source(XContentType.JSON, \"field\", i));\n+        }\n+        assertThat(bulkRequest.get().hasFailures(), is(false));\n+\n+        final ForceMergeResponse forceMergeResponse = leaderClient().admin().indices().prepareForceMerge(leaderIndex).setFlush(true).get();\n+        assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards));\n+        assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        ensureLeaderGreen(leaderIndex);\n+\n+        final IndexStats indexStats = leaderClient().admin().indices().prepareStats(leaderIndex)\n+            .clear()\n+            .setStore(true)\n+            .get()\n+            .getIndex(leaderIndex);\n+        assertThat(indexStats.getIndexShards(), notNullValue());\n+        assertThat(indexStats.getIndexShards(), aMapWithSize(numberOfShards));\n+\n+        final long[] storeSizeInBytes = new long[numberOfShards];\n+        indexStats.getIndexShards().forEach((key, value) -> storeSizeInBytes[key] = value.getPrimary().getStore().getSizeInBytes());\n+\n+        final String leaderCluster = CcrRepository.NAME_PREFIX + \"leader_cluster\";\n+        final RepositoriesService repositoriesService = getFollowerCluster().getCurrentMasterNodeInstance(RepositoriesService.class);\n+        final Repository repository = repositoriesService.repository(leaderCluster);\n+        assertThat(repository.getMetadata().type(), equalTo(CcrRepository.TYPE));\n+        assertThat(repository.getMetadata().name(), equalTo(leaderCluster));\n+\n+        for (int shardId = 0; shardId < numberOfShards; shardId++) {\n+            IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = repository.getShardSnapshotStatus(\n+                new SnapshotId(CcrRepository.LATEST, CcrRepository.LATEST),\n+                new IndexId(indexStats.getIndex(), indexStats.getUuid()),\n+                new ShardId(new Index(indexStats.getIndex(), indexStats.getUuid()), shardId)).asCopy();\n+\n+            assertThat(indexShardSnapshotStatus, notNullValue());\n+            assertThat(indexShardSnapshotStatus.getStage(), is(IndexShardSnapshotStatus.Stage.DONE));\n+            assertThat(indexShardSnapshotStatus.getTotalSize(), equalTo(storeSizeInBytes[shardId]));\n+        }\n+\n+        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n+\n+        final List<MockTransportService> transportServices = new ArrayList<>();\n+        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n+            final MockTransportService mockTransportService = (MockTransportService) transportService;\n+            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n+                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n+                    try {\n+                        blockCcrRestore.await();\n+                    } catch (InterruptedException e) {\n+                        throw new ElasticsearchException(e);\n+                    }\n+                }\n+                connection.sendRequest(requestId, action, request, options);\n+            });\n+            transportServices.add(mockTransportService);\n+        }\n+\n+        try {\n+            final RestoreService restoreService = getFollowerCluster().getCurrentMasterNodeInstance(RestoreService.class);\n+            final ClusterService clusterService = getFollowerCluster().getCurrentMasterNodeInstance(ClusterService.class);\n+\n+            final CountDownLatch waitForRestoreInProgress = new CountDownLatch(1);\n+            final ClusterStateListener listener = event -> {\n+                RestoreInProgress restoreInProgress = event.state().custom(RestoreInProgress.TYPE, RestoreInProgress.EMPTY);\n+                if (restoreInProgress != null && restoreInProgress.isEmpty() == false) {\n+                    waitForRestoreInProgress.countDown();\n+                }\n+            };\n+            clusterService.addListener(listener);\n+\n+            final String followerIndex = \"follower\";\n+            final RestoreSnapshotRequest restoreRequest = new RestoreSnapshotRequest(leaderCluster, CcrRepository.LATEST)\n+                .indices(leaderIndex).indicesOptions(indicesOptions).renamePattern(\"^(.*)$\")\n+                .renameReplacement(followerIndex)\n+                .masterNodeTimeout(TimeValue.MAX_VALUE)\n+                .indexSettings(Settings.builder()\n+                    .put(IndexMetadata.SETTING_INDEX_PROVIDED_NAME, followerIndex)\n+                    .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true));\n+            restoreService.restoreSnapshot(restoreRequest, PlainActionFuture.newFuture());\n+\n+            waitForRestoreInProgress.await(30L, TimeUnit.SECONDS);\n+            clusterService.removeListener(listener);\n+\n+            final IndexRoutingTable indexRoutingTable = followerClient().admin().cluster().prepareState().clear().setRoutingTable(true)\n+                .setIndices(followerIndex).get().getState().routingTable().index(followerIndex);\n+            assertThat(indexRoutingTable, notNullValue());\n+\n+            final SnapshotsInfoService snapshotsInfoService = getFollowerCluster().getCurrentMasterNodeInstance(SnapshotsInfoService.class);\n+            assertBusy(() -> {\n+                SnapshotShardSizeInfo snapshotShardSizeInfo = snapshotsInfoService.snapshotShardSizes();\n+                for (int shardId = 0; shardId < numberOfShards; shardId++) {\n+                    Long snapshotShardSize = snapshotShardSizeInfo.getShardSize(indexRoutingTable.shard(shardId).primaryShard());\n+                    assertThat(snapshotShardSize, equalTo(storeSizeInBytes[shardId]));\n+                }\n+            });\n+\n+            blockCcrRestore.countDown();\n+            ensureFollowerGreen(followerIndex);\n+\n+            assertAcked(followerClient().admin().indices().prepareDelete(followerIndex).setMasterNodeTimeout(TimeValue.MAX_VALUE));\n+        } finally {\n+            transportServices.forEach(MockTransportService::clearAllRules);\n+        }\n+    }\n+\n+    public void testCcrRepositoryFailsToFetchSnapshotShardSizes() throws Exception {\n+        final String leaderIndex = \"leader\";\n+        final int numberOfShards = randomIntBetween(1, 2);\n+        assertAcked(leaderClient().admin().indices().prepareCreate(leaderIndex)\n+            .setSource(getIndexSettings(numberOfShards, 0,\n+                Map.of(Store.INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING.getKey(), TimeValue.ZERO.getStringRep())), XContentType.JSON));\n+\n+        final IndexMetadata indexMetadata = leaderClient().admin().cluster().prepareState().setIndices(leaderIndex)\n+            .clear().setMetadata(true).get().getState().metadata().index(leaderIndex);\n+\n+        final AtomicInteger indicesStatsRequestsCount = new AtomicInteger(0);\n+        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n+\n+        final List<MockTransportService> transportServices = new ArrayList<>();\n+        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n+            final MockTransportService mockTransportService = (MockTransportService) transportService;\n+            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n+                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n+                    try {\n+                        blockCcrRestore.await();\n+                    } catch (InterruptedException e) {\n+                        throw new ElasticsearchException(e);\n+                    }\n+                }\n+                connection.sendRequest(requestId, action, request, options);\n+            });\n+            transportServices.add(mockTransportService);\n+        }\n+        for (TransportService transportService : getLeaderCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n+            final MockTransportService mockTransportService = (MockTransportService) transportService;\n+            mockTransportService.addRequestHandlingBehavior(IndicesStatsAction.NAME, (handler, request, channel, task) -> {\n+                if (request instanceof IndicesStatsRequest) {\n+                    IndicesStatsRequest indicesStatsRequest = (IndicesStatsRequest) request;\n+                    if (Arrays.equals(indicesStatsRequest.indices(), new String[]{leaderIndex})) {\n+                        if (indicesStatsRequest.store()\n+                            && indicesStatsRequest.search() == false\n+                            && indicesStatsRequest.fieldData() == false\n+                        ) {\n+                            indicesStatsRequestsCount.incrementAndGet();\n+                            channel.sendResponse(new ElasticsearchException(\"simulated\"));\n+                            return;\n+                        }\n+                    }\n+                }\n+                handler.messageReceived(request, channel, task);\n+            });\n+            transportServices.add(mockTransportService);\n+        }\n+\n+        final String followerIndex = \"follower\";\n+        try {\n+            final String leaderCluster = CcrRepository.NAME_PREFIX + \"leader_cluster\";\n+            final RepositoriesService repositoriesService = getFollowerCluster().getCurrentMasterNodeInstance(RepositoriesService.class);\n+            final Repository repository = repositoriesService.repository(leaderCluster);\n+            assertThat(repository.getMetadata().type(), equalTo(CcrRepository.TYPE));\n+            assertThat(repository.getMetadata().name(), equalTo(leaderCluster));\n+\n+            for (int i = 0; i < numberOfShards; i++) {\n+                final Index index = indexMetadata.getIndex();\n+                final int shardId = i;\n+                ElasticsearchException exception = expectThrows(ElasticsearchException.class,\n+                    () -> repository.getShardSnapshotStatus(\n+                        new SnapshotId(CcrRepository.LATEST, CcrRepository.LATEST),\n+                        new IndexId(index.getName(), index.getUUID()),\n+                        new ShardId(index, shardId)));\n+                assertThat(exception.getMessage(), equalTo(\"simulated\"));\n+            }\n+            assertThat(indicesStatsRequestsCount.getAndSet(0), equalTo(numberOfShards));\n+\n+            final RestoreService restoreService = getFollowerCluster().getCurrentMasterNodeInstance(RestoreService.class);\n+            final ClusterService clusterService = getFollowerCluster().getCurrentMasterNodeInstance(ClusterService.class);\n+\n+            final CountDownLatch waitForRestoreInProgress = new CountDownLatch(1);\n+            final ClusterStateListener listener = event -> {\n+                RestoreInProgress restoreInProgress = event.state().custom(RestoreInProgress.TYPE, RestoreInProgress.EMPTY);\n+                if (restoreInProgress != null && restoreInProgress.isEmpty() == false) {\n+                    waitForRestoreInProgress.countDown();\n+                }\n+            };\n+            clusterService.addListener(listener);\n+\n+            final RestoreSnapshotRequest restoreRequest = new RestoreSnapshotRequest(leaderCluster, CcrRepository.LATEST)\n+                .indices(leaderIndex).indicesOptions(indicesOptions).renamePattern(\"^(.*)$\")\n+                .renameReplacement(followerIndex)\n+                .masterNodeTimeout(TimeValue.MAX_VALUE)\n+                .indexSettings(Settings.builder()\n+                    .put(IndexMetadata.SETTING_INDEX_PROVIDED_NAME, followerIndex)\n+                    .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true));\n+            restoreService.restoreSnapshot(restoreRequest, PlainActionFuture.newFuture());\n+\n+            waitForRestoreInProgress.await(30L, TimeUnit.SECONDS);\n+            clusterService.removeListener(listener);\n+\n+            final IndexRoutingTable indexRoutingTable = followerClient().admin().cluster().prepareState().clear().setRoutingTable(true)\n+                .setIndices(followerIndex).get().getState().routingTable().index(followerIndex);\n+            assertThat(indexRoutingTable, notNullValue());\n+\n+            final SnapshotsInfoService snapshotsInfoService = getFollowerCluster().getCurrentMasterNodeInstance(SnapshotsInfoService.class);\n+            assertBusy(() -> {\n+                SnapshotShardSizeInfo snapshotShardSizeInfo = snapshotsInfoService.snapshotShardSizes();\n+                for (int shardId = 0; shardId < numberOfShards; shardId++) {\n+                    final ShardRouting primary = indexRoutingTable.shard(shardId).primaryShard();\n+                    assertThat(snapshotShardSizeInfo.getShardSize(primary), equalTo(ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE));\n+                    final long randomSize = randomNonNegativeLong();\n+                    assertThat(snapshotShardSizeInfo.getShardSize(primary, randomSize), equalTo(randomSize));\n+                }\n+            });\n+        } finally {\n+            transportServices.forEach(MockTransportService::clearAllRules);\n+        }\n+\n+        assertThat(indicesStatsRequestsCount.get(), equalTo(numberOfShards));\n+        blockCcrRestore.countDown();\n+\n+        followerClient().admin().cluster().prepareReroute().get();\n+        ensureFollowerGreen(followerIndex);\n+\n+        assertAcked(followerClient().admin().indices().prepareDelete(followerIndex).setMasterNodeTimeout(TimeValue.MAX_VALUE));\n+", "originalCommit": "680defec049132ea75dd369d78cabacaefa428a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6fbb8d274fd1eaec43d9a96bf3168f294ae34340", "url": "https://github.com/elastic/elasticsearch/commit/6fbb8d274fd1eaec43d9a96bf3168f294ae34340", "message": "feedback", "committedDate": "2020-10-13T14:28:40Z", "type": "commit"}, {"oid": "539caaf7aabea8e85ce6372f7c6fe3325840f1a6", "url": "https://github.com/elastic/elasticsearch/commit/539caaf7aabea8e85ce6372f7c6fe3325840f1a6", "message": "plainactionfuture", "committedDate": "2020-10-13T14:37:10Z", "type": "commit"}]}