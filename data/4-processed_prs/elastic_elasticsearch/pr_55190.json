{"pr_number": 55190, "pr_title": "Remove ILambda user tree node from Painless", "pr_createdAt": "2020-04-14T23:30:39Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55190", "timeline": [{"oid": "eac1d61e41717df51b42edf65cbd1570a2a46663", "url": "https://github.com/elastic/elasticsearch/commit/eac1d61e41717df51b42edf65cbd1570a2a46663", "message": "remove statement, use read instead", "committedDate": "2020-03-27T23:55:26Z", "type": "commit"}, {"oid": "082e94b4a590591196625bad85750d2fcbc4f551", "url": "https://github.com/elastic/elasticsearch/commit/082e94b4a590591196625bad85750d2fcbc4f551", "message": "add tests for not a statement", "committedDate": "2020-03-30T16:27:34Z", "type": "commit"}, {"oid": "d6ca6a35cfeb2f5b8689b7258bb19eda858c03bf", "url": "https://github.com/elastic/elasticsearch/commit/d6ca6a35cfeb2f5b8689b7258bb19eda858c03bf", "message": "Merge branch 'master' into nodes0", "committedDate": "2020-03-30T16:51:01Z", "type": "commit"}, {"oid": "4459ee9a8029edd7c995865bd3202830def8097c", "url": "https://github.com/elastic/elasticsearch/commit/4459ee9a8029edd7c995865bd3202830def8097c", "message": "move isDefOptimized to output instead of as mutable state on the nodes", "committedDate": "2020-03-30T19:02:43Z", "type": "commit"}, {"oid": "1eb0a513f54a2abc3a4d90877d43297a246e7dac", "url": "https://github.com/elastic/elasticsearch/commit/1eb0a513f54a2abc3a4d90877d43297a246e7dac", "message": "Merge branch 'master' into nodes0", "committedDate": "2020-03-30T19:05:32Z", "type": "commit"}, {"oid": "372ec631791fceda73c22bb1dfbba176aeba7c1f", "url": "https://github.com/elastic/elasticsearch/commit/372ec631791fceda73c22bb1dfbba176aeba7c1f", "message": "Merge branch 'nodes0' into nodes1", "committedDate": "2020-03-30T19:05:58Z", "type": "commit"}, {"oid": "99c54f190497586547ab073b41a0c5d39d89b5fd", "url": "https://github.com/elastic/elasticsearch/commit/99c54f190497586547ab073b41a0c5d39d89b5fd", "message": "remove AStoreable and give individual nodes responsibility to check\nwrite", "committedDate": "2020-03-30T20:18:46Z", "type": "commit"}, {"oid": "2eceff4ba180840b185ae834b963c9b7ae1f58bc", "url": "https://github.com/elastic/elasticsearch/commit/2eceff4ba180840b185ae834b963c9b7ae1f58bc", "message": "clean up write messages and add tests", "committedDate": "2020-03-30T22:18:14Z", "type": "commit"}, {"oid": "78961f80bef311dfa557dd0288dec8a7a1564be6", "url": "https://github.com/elastic/elasticsearch/commit/78961f80bef311dfa557dd0288dec8a7a1564be6", "message": "elimate extraneous new array function reference ir node", "committedDate": "2020-03-30T22:57:27Z", "type": "commit"}, {"oid": "7a3a3870e6443c2cfa2cdf9a3e0920977daaaf82", "url": "https://github.com/elastic/elasticsearch/commit/7a3a3870e6443c2cfa2cdf9a3e0920977daaaf82", "message": "switch ir function ref nodes to different types", "committedDate": "2020-03-31T20:07:52Z", "type": "commit"}, {"oid": "791eca3b0d29f37c9d84fd196fb03618d33b8606", "url": "https://github.com/elastic/elasticsearch/commit/791eca3b0d29f37c9d84fd196fb03618d33b8606", "message": "remove ILambda in favor of ir tree calculating def method call recipe", "committedDate": "2020-03-31T20:45:25Z", "type": "commit"}, {"oid": "94b6c80f963c042dae95604d3c6b469fff10d9ac", "url": "https://github.com/elastic/elasticsearch/commit/94b6c80f963c042dae95604d3c6b469fff10d9ac", "message": "Merge branch 'master' into nodes0", "committedDate": "2020-04-08T17:03:44Z", "type": "commit"}, {"oid": "e7af841e35bcd8d4f845f54ffb082d3d201a51b4", "url": "https://github.com/elastic/elasticsearch/commit/e7af841e35bcd8d4f845f54ffb082d3d201a51b4", "message": "Merge branch 'nodes0' into nodes1", "committedDate": "2020-04-08T17:03:54Z", "type": "commit"}, {"oid": "97549c8d5b65a1c97a361a9fb8fa30bdab0ea6db", "url": "https://github.com/elastic/elasticsearch/commit/97549c8d5b65a1c97a361a9fb8fa30bdab0ea6db", "message": "Merge branch 'nodes1' into nodes2", "committedDate": "2020-04-08T17:24:14Z", "type": "commit"}, {"oid": "251ff50fcac2ded70f1026560cf7cb67d1e86c28", "url": "https://github.com/elastic/elasticsearch/commit/251ff50fcac2ded70f1026560cf7cb67d1e86c28", "message": "Merge branch 'master' into nodes1", "committedDate": "2020-04-10T15:30:43Z", "type": "commit"}, {"oid": "198fa475e180a169ca1911734d49096dbaf4a1f3", "url": "https://github.com/elastic/elasticsearch/commit/198fa475e180a169ca1911734d49096dbaf4a1f3", "message": "Merge branch 'nodes1' into nodes2", "committedDate": "2020-04-10T15:36:40Z", "type": "commit"}, {"oid": "a79f9b33ca1b8333d0e0b471c8c337674ca6f3f4", "url": "https://github.com/elastic/elasticsearch/commit/a79f9b33ca1b8333d0e0b471c8c337674ca6f3f4", "message": "Merge branch 'master' into nodes1", "committedDate": "2020-04-14T23:12:20Z", "type": "commit"}, {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328", "url": "https://github.com/elastic/elasticsearch/commit/4c93293c2ada3933550f1b64fa303a8785b7b328", "message": "Merge branch 'nodes1' into nodes2", "committedDate": "2020-04-14T23:12:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0MzY3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410343676", "bodyText": "Reciever?", "author": "stu-elastic", "createdAt": "2020-04-17T16:44:52Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;\n \n-    public List<String> getPointers() {\n-        return pointers;\n-    }\n+        typeParameters.add(Object.class);", "originalCommit": "4c93293c2ada3933550f1b64fa303a8785b7b328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI1OTY5MA==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412259690", "bodyText": "commented", "author": "jdconrad", "createdAt": "2020-04-21T14:57:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0MzY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0MzczMg==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410343732", "bodyText": "?", "author": "stu-elastic", "createdAt": "2020-04-17T16:44:59Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;", "originalCommit": "4c93293c2ada3933550f1b64fa303a8785b7b328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3MjE0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412272141", "bodyText": "commented", "author": "jdconrad", "createdAt": "2020-04-21T15:11:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0MzczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NDM1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410344352", "bodyText": "?", "author": "stu-elastic", "createdAt": "2020-04-17T16:46:02Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;\n \n-    public List<String> getPointers() {\n-        return pointers;\n-    }\n+        typeParameters.add(Object.class);\n \n-    public void addTypeParameter(Class<?> typeParameter) {\n-        typeParameters.add(typeParameter);\n-    }\n+        for (int i = 0; i < getArgumentNodes().size(); ++i) {\n+            ExpressionNode argumentNode = getArgumentNodes().get(i);\n+            argumentNode.write(classWriter, methodWriter, scopeTable);\n \n-    public List<Class<?>> getTypeParameters() {\n-        return typeParameters;\n-    }\n+            typeParameters.add(argumentNode.getExpressionType());\n \n-    /* ---- end node data ---- */\n+            if (argumentNode instanceof DefInterfaceReferenceNode) {\n+                DefInterfaceReferenceNode defInterfaceReferenceNode = (DefInterfaceReferenceNode)argumentNode;\n+                boostrapArguments.add(defInterfaceReferenceNode.getDefReferenceEncoding());\n \n-    @Override\n-    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n-        methodWriter.writeDebugInfo(location);\n+                char encoding = (char)(i + capturedCount);", "originalCommit": "4c93293c2ada3933550f1b64fa303a8785b7b328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3MjMwMA==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412272300", "bodyText": "commented", "author": "jdconrad", "createdAt": "2020-04-21T15:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NDM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NDc2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410344767", "bodyText": "don't leave me hanging!", "author": "stu-elastic", "createdAt": "2020-04-17T16:46:46Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/DefInterfaceReferenceNode.java", "diffHunk": "@@ -20,34 +20,36 @@\n package org.elasticsearch.painless.ir;\n \n import org.elasticsearch.painless.ClassWriter;\n-import org.elasticsearch.painless.FunctionRef;\n import org.elasticsearch.painless.MethodWriter;\n import org.elasticsearch.painless.symbol.ScopeTable;\n+import org.objectweb.asm.Opcodes;\n \n-public class NewArrayFuncRefNode extends ExpressionNode {\n+public class DefInterfaceReferenceNode extends ReferenceNode {\n \n     /* ---- begin node data ---- */\n \n-    private FunctionRef funcRef;\n+    private String defReferenceEncoding;\n \n-    public void setFuncRef(FunctionRef funcRef) {\n-        this.funcRef = funcRef;\n+    public void setDefReferenceEncoding(String defReferenceEncoding) {\n+        this.defReferenceEncoding = defReferenceEncoding;\n     }\n \n-    public FunctionRef getFuncRef() {\n-        return funcRef;\n+    public String getDefReferenceEncoding() {\n+        return defReferenceEncoding;\n     }\n \n     /* ---- end node data ---- */\n \n     @Override\n     protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n-        if (funcRef != null) {\n-            methodWriter.writeDebugInfo(location);\n-            methodWriter.invokeLambdaCall(funcRef);\n-        } else {\n-            // push a null instruction as a placeholder for future lambda instructions\n-            methodWriter.push((String)null);\n+        methodWriter.writeDebugInfo(location);\n+\n+        // place holder for", "originalCommit": "4c93293c2ada3933550f1b64fa303a8785b7b328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4MjI2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412282267", "bodyText": "oops, fixed :)", "author": "jdconrad", "createdAt": "2020-04-21T15:23:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NDc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NjM0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410346345", "bodyText": "visitVarInsn -> visit variable instance?", "author": "stu-elastic", "createdAt": "2020-04-17T16:49:40Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/DefInterfaceReferenceNode.java", "diffHunk": "@@ -20,34 +20,36 @@\n package org.elasticsearch.painless.ir;\n \n import org.elasticsearch.painless.ClassWriter;\n-import org.elasticsearch.painless.FunctionRef;\n import org.elasticsearch.painless.MethodWriter;\n import org.elasticsearch.painless.symbol.ScopeTable;\n+import org.objectweb.asm.Opcodes;\n \n-public class NewArrayFuncRefNode extends ExpressionNode {\n+public class DefInterfaceReferenceNode extends ReferenceNode {\n \n     /* ---- begin node data ---- */\n \n-    private FunctionRef funcRef;\n+    private String defReferenceEncoding;\n \n-    public void setFuncRef(FunctionRef funcRef) {\n-        this.funcRef = funcRef;\n+    public void setDefReferenceEncoding(String defReferenceEncoding) {\n+        this.defReferenceEncoding = defReferenceEncoding;\n     }\n \n-    public FunctionRef getFuncRef() {\n-        return funcRef;\n+    public String getDefReferenceEncoding() {\n+        return defReferenceEncoding;\n     }\n \n     /* ---- end node data ---- */\n \n     @Override\n     protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n-        if (funcRef != null) {\n-            methodWriter.writeDebugInfo(location);\n-            methodWriter.invokeLambdaCall(funcRef);\n-        } else {\n-            // push a null instruction as a placeholder for future lambda instructions\n-            methodWriter.push((String)null);\n+        methodWriter.writeDebugInfo(location);\n+\n+        // place holder for\n+        methodWriter.push((String)null);\n+\n+        for (String capture : getCaptures()) {\n+            ScopeTable.Variable variable = scopeTable.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());", "originalCommit": "4c93293c2ada3933550f1b64fa303a8785b7b328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3MjY5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412272691", "bodyText": "an asm instruction to load a variable's value onto the stack", "author": "jdconrad", "createdAt": "2020-04-21T15:12:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NjM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NjUyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410346521", "bodyText": "?", "author": "stu-elastic", "createdAt": "2020-04-17T16:49:55Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/ReferenceNode.java", "diffHunk": "@@ -7,7 +7,7 @@\n  * not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n+ *     http://www.apache.org/licenses/LICENSE-2.0", "originalCommit": "4c93293c2ada3933550f1b64fa303a8785b7b328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMyMTQxNw==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412321417", "bodyText": "I believe this got fixed to be a tab + 1 space away from the star since the rest of the lines have an extra space away from the star.", "author": "jdconrad", "createdAt": "2020-04-21T16:49:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NjUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NjkyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410346925", "bodyText": "is it ok to leak a mutable data structure here?", "author": "stu-elastic", "createdAt": "2020-04-17T16:50:46Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/ReferenceNode.java", "diffHunk": "@@ -17,26 +17,25 @@\n  * under the License.\n  */\n \n-package org.elasticsearch.painless.node;\n+package org.elasticsearch.painless.ir;\n \n+import java.util.ArrayList;\n import java.util.List;\n \n-/**\n- * Interface for lambda/method reference nodes. They need special handling by LDefCall.\n- * <p>\n- * This is because they know nothing about the target interface, and can only push\n- * all their captures onto the stack and defer everything until link-time.\n- */\n-interface ILambda {\n+public abstract class ReferenceNode extends ExpressionNode {\n+\n+    /* ---- begin node data ---- */\n \n-    /** Returns reference to resolve at link-time */\n-    String getPointer();\n+    private final List<String> captures = new ArrayList<>();\n \n-    /** Returns the types of captured parameters. Can be empty */\n-    List<Class<?>> getCaptures();\n+    public void addCapture(String capture) {\n+        captures.add(capture);\n+    }\n \n-    /** Returns the number of captured parameters */\n-    default int getCaptureCount() {\n-        return getCaptures().size();\n+    public List<String> getCaptures() {\n+        return captures;", "originalCommit": "4c93293c2ada3933550f1b64fa303a8785b7b328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3NDMzMg==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412274332", "bodyText": "all ir nodes are designed to be completely mutable as we hope to modify the ir tree structure at some point to add optimizations and possibly other features; we keep the user tree as immutable and hide the ir tree behind it", "author": "jdconrad", "createdAt": "2020-04-21T15:13:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NjkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NzUxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410347511", "bodyText": "why is the get(0) safe here?", "author": "stu-elastic", "createdAt": "2020-04-17T16:51:44Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/TypedCaptureReferenceNode.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.ir;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.symbol.ScopeTable;\n+import org.elasticsearch.painless.symbol.ScopeTable.Variable;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+\n+public class TypedCaptureReferenceNode extends ReferenceNode {\n+\n+    /* ---- begin node data ---- */\n+\n+    private String methodName;\n+\n+    public void setMethodName(String methodName) {\n+        this.methodName = methodName;\n+    }\n+\n+    public String getMethodName() {\n+        return methodName;\n+    }\n+\n+    /* ---- end node data ---- */\n+\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n+        Variable captured = scopeTable.getVariable(getCaptures().get(0));", "originalCommit": "4c93293c2ada3933550f1b64fa303a8785b7b328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3ODU2NA==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412278564", "bodyText": "there is only a single capture for reference types in this case (foo::bar where foo is the captured variable)", "author": "jdconrad", "createdAt": "2020-04-21T15:18:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NzUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2OTUyNw==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410369527", "bodyText": "Javadocs: \"Write out invokedynamic instruction\" or something similar.  Nothing fancy.", "author": "stu-elastic", "createdAt": "2020-04-17T17:33:12Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override", "originalCommit": "4c93293c2ada3933550f1b64fa303a8785b7b328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3OTcxMg==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412279712", "bodyText": "commented", "author": "jdconrad", "createdAt": "2020-04-21T15:20:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2OTUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MDI2OA==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410370268", "bodyText": "\"Handle lambdas as args\"", "author": "stu-elastic", "createdAt": "2020-04-17T17:34:37Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();", "originalCommit": "4c93293c2ada3933550f1b64fa303a8785b7b328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3ODgzNg==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412278836", "bodyText": "commented", "author": "jdconrad", "createdAt": "2020-04-21T15:19:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MDI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MDk0MA==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410370940", "bodyText": "This is an unknown method ref that we have to resolve at runtime.", "author": "stu-elastic", "createdAt": "2020-04-17T17:35:57Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;\n \n-    public List<String> getPointers() {\n-        return pointers;\n-    }\n+        typeParameters.add(Object.class);\n \n-    public void addTypeParameter(Class<?> typeParameter) {\n-        typeParameters.add(typeParameter);\n-    }\n+        for (int i = 0; i < getArgumentNodes().size(); ++i) {\n+            ExpressionNode argumentNode = getArgumentNodes().get(i);\n+            argumentNode.write(classWriter, methodWriter, scopeTable);\n \n-    public List<Class<?>> getTypeParameters() {\n-        return typeParameters;\n-    }\n+            typeParameters.add(argumentNode.getExpressionType());\n \n-    /* ---- end node data ---- */\n+            if (argumentNode instanceof DefInterfaceReferenceNode) {", "originalCommit": "4c93293c2ada3933550f1b64fa303a8785b7b328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4MDE0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412280143", "bodyText": "commented", "author": "jdconrad", "createdAt": "2020-04-21T15:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MDk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MzA3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410373071", "bodyText": "Small comment about the char encoding skip table, perhaps refing some other documentation, would be helpful.", "author": "stu-elastic", "createdAt": "2020-04-17T17:40:05Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;\n \n-    public List<String> getPointers() {\n-        return pointers;\n-    }\n+        typeParameters.add(Object.class);\n \n-    public void addTypeParameter(Class<?> typeParameter) {\n-        typeParameters.add(typeParameter);\n-    }\n+        for (int i = 0; i < getArgumentNodes().size(); ++i) {\n+            ExpressionNode argumentNode = getArgumentNodes().get(i);\n+            argumentNode.write(classWriter, methodWriter, scopeTable);\n \n-    public List<Class<?>> getTypeParameters() {\n-        return typeParameters;\n-    }\n+            typeParameters.add(argumentNode.getExpressionType());\n \n-    /* ---- end node data ---- */\n+            if (argumentNode instanceof DefInterfaceReferenceNode) {\n+                DefInterfaceReferenceNode defInterfaceReferenceNode = (DefInterfaceReferenceNode)argumentNode;\n+                boostrapArguments.add(defInterfaceReferenceNode.getDefReferenceEncoding());\n \n-    @Override\n-    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n-        methodWriter.writeDebugInfo(location);\n+                char encoding = (char)(i + capturedCount);", "originalCommit": "4c93293c2ada3933550f1b64fa303a8785b7b328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI5MDk3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412290975", "bodyText": "commented", "author": "jdconrad", "createdAt": "2020-04-21T15:37:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MzA3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxMzU1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412313553", "bodyText": "commented", "author": "jdconrad", "createdAt": "2020-04-21T16:38:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MzA3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3OTY0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410379641", "bodyText": "Add TODO, let's pull this encoding creation out into something that makes the arguments clear.", "author": "stu-elastic", "createdAt": "2020-04-17T17:52:37Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECapturingFunctionRef.java", "diffHunk": "@@ -63,51 +59,53 @@ Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input in\n                     \"not a statement: capturing function reference [\" + variable + \":\"  + call + \"] not used\"));\n         }\n \n-        FunctionRef ref = null;\n-\n         Output output = new Output();\n \n-        captured = scope.getVariable(location, variable);\n+        Variable captured = scope.getVariable(location, variable);\n         if (input.expected == null) {\n+            String defReferenceEncoding;\n             if (captured.getType() == def.class) {\n                 // dynamic implementation\n-                defPointer = \"D\" + variable + \".\" + call + \",1\";\n+                defReferenceEncoding = \"D\" + variable + \".\" + call + \",1\";", "originalCommit": "4c93293c2ada3933550f1b64fa303a8785b7b328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMwMTg0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412301843", "bodyText": "#55543", "author": "jdconrad", "createdAt": "2020-04-21T16:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3OTY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4MDM2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410380361", "bodyText": "Add comment on this case.", "author": "stu-elastic", "createdAt": "2020-04-17T17:53:58Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECapturingFunctionRef.java", "diffHunk": "@@ -63,51 +59,53 @@ Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input in\n                     \"not a statement: capturing function reference [\" + variable + \":\"  + call + \"] not used\"));\n         }\n \n-        FunctionRef ref = null;\n-\n         Output output = new Output();\n \n-        captured = scope.getVariable(location, variable);\n+        Variable captured = scope.getVariable(location, variable);\n         if (input.expected == null) {\n+            String defReferenceEncoding;\n             if (captured.getType() == def.class) {\n                 // dynamic implementation\n-                defPointer = \"D\" + variable + \".\" + call + \",1\";\n+                defReferenceEncoding = \"D\" + variable + \".\" + call + \",1\";\n             } else {\n                 // typed implementation\n-                defPointer = \"S\" + captured.getCanonicalTypeName() + \".\" + call + \",1\";\n+                defReferenceEncoding = \"S\" + captured.getCanonicalTypeName() + \".\" + call + \",1\";\n             }\n             output.actual = String.class;\n+\n+            DefInterfaceReferenceNode defInterfaceReferenceNode = new DefInterfaceReferenceNode();\n+\n+            defInterfaceReferenceNode.setLocation(location);\n+            defInterfaceReferenceNode.setExpressionType(output.actual);\n+            defInterfaceReferenceNode.addCapture(captured.getName());\n+            defInterfaceReferenceNode.setDefReferenceEncoding(defReferenceEncoding);\n+\n+            output.expressionNode = defInterfaceReferenceNode;\n         } else {\n-            defPointer = null;\n+            output.actual = input.expected;\n             // static case\n             if (captured.getType() != def.class) {\n-                ref = FunctionRef.create(scriptRoot.getPainlessLookup(), scriptRoot.getFunctionTable(), location,\n+                FunctionRef ref = FunctionRef.create(scriptRoot.getPainlessLookup(), scriptRoot.getFunctionTable(), location,\n                         input.expected, captured.getCanonicalTypeName(), call, 1);\n-            }\n-            output.actual = input.expected;\n-        }\n \n-        CapturingFuncRefNode capturingFuncRefNode = new CapturingFuncRefNode();\n+                TypedInterfaceReferenceNode typedInterfaceReferenceNode = new TypedInterfaceReferenceNode();\n+                typedInterfaceReferenceNode.setLocation(location);\n+                typedInterfaceReferenceNode.setExpressionType(output.actual);\n+                typedInterfaceReferenceNode.addCapture(captured.getName());\n+                typedInterfaceReferenceNode.setReference(ref);\n \n-        capturingFuncRefNode.setLocation(location);\n-        capturingFuncRefNode.setExpressionType(output.actual);\n-        capturingFuncRefNode.setCapturedName(captured.getName());\n-        capturingFuncRefNode.setName(call);\n-        capturingFuncRefNode.setPointer(defPointer);\n-        capturingFuncRefNode.setFuncRef(ref);\n+                output.expressionNode = typedInterfaceReferenceNode;\n+            } else {\n+                TypedCaptureReferenceNode typedCaptureReferenceNode = new TypedCaptureReferenceNode();", "originalCommit": "4c93293c2ada3933550f1b64fa303a8785b7b328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxMzQ3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412313475", "bodyText": "commented", "author": "jdconrad", "createdAt": "2020-04-21T16:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4MDM2MQ=="}], "type": "inlineReview"}, {"oid": "c8076bfa4366e371aaba802a038db3c56ce43074", "url": "https://github.com/elastic/elasticsearch/commit/c8076bfa4366e371aaba802a038db3c56ce43074", "message": "Merge branch 'master' into nodes2", "committedDate": "2020-04-21T14:51:10Z", "type": "commit"}, {"oid": "a4d34169a4724a4111cb30c9671e79798b64f3ef", "url": "https://github.com/elastic/elasticsearch/commit/a4d34169a4724a4111cb30c9671e79798b64f3ef", "message": "response to pr comments", "committedDate": "2020-04-21T16:38:42Z", "type": "commit"}]}