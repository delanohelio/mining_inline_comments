{"pr_number": 57666, "pr_title": "MappedFieldType should not extend FieldType", "pr_createdAt": "2020-06-04T13:22:10Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/57666", "timeline": [{"oid": "23a35eb3942dbfe9171616891290978e1da6143d", "url": "https://github.com/elastic/elasticsearch/commit/23a35eb3942dbfe9171616891290978e1da6143d", "message": "Cut 1: /server compiles, mapping tests pass", "committedDate": "2020-06-03T14:22:57Z", "type": "commit"}, {"oid": "ac2cc4a58982e13e8758cf8c6e8cb6bec76e18b9", "url": "https://github.com/elastic/elasticsearch/commit/ac2cc4a58982e13e8758cf8c6e8cb6bec76e18b9", "message": "server/ tests passing", "committedDate": "2020-06-04T13:16:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI1ODUyMA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r435258520", "bodyText": "I super hate all of these instanceofs!", "author": "nik9000", "createdAt": "2020-06-04T13:36:37Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/analyze/TransportAnalyzeAction.java", "diffHunk": "@@ -179,7 +179,7 @@ private static Analyzer getAnalyzer(AnalyzeAction.Request request, AnalysisRegis\n             }\n             MappedFieldType fieldType = indexService.mapperService().fieldType(request.field());\n             if (fieldType != null) {\n-                if (fieldType.tokenized() || fieldType instanceof KeywordFieldMapper.KeywordFieldType) {", "originalCommit": "ac2cc4a58982e13e8758cf8c6e8cb6bec76e18b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI1ODYwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r435258605", "bodyText": "But you are making it better.", "author": "nik9000", "createdAt": "2020-06-04T13:36:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI1ODUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI1OTcyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r435259729", "bodyText": "\u2764\ufe0f", "author": "nik9000", "createdAt": "2020-06-04T13:37:51Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java", "diffHunk": "@@ -54,52 +52,45 @@\n \n import java.io.IOException;\n import java.time.ZoneId;\n-import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n \n /**\n  * This defines the core properties and functions to operate on a field.\n  */\n-public abstract class MappedFieldType extends FieldType {\n+public abstract class MappedFieldType {\n \n-    private String name;\n+    private final String name;", "originalCommit": "ac2cc4a58982e13e8758cf8c6e8cb6bec76e18b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI2MTI3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r435261276", "bodyText": "I've always been a fan of if (o == null || getClass() != o.getClass()) for this. Every equals implementation is ugly, but at least mine bails early if the subtypes don't line up.", "author": "nik9000", "createdAt": "2020-06-04T13:39:21Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java", "diffHunk": "@@ -130,7 +121,9 @@ public ValuesSourceType getValuesSourceType() {\n \n     @Override\n     public boolean equals(Object o) {\n-        if (!super.equals(o)) return false;\n+        if (o instanceof MappedFieldType == false) {", "originalCommit": "ac2cc4a58982e13e8758cf8c6e8cb6bec76e18b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYyMzI0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r438623245", "bodyText": "+1 to check classes directly instead of using instanceof, I expect that MappedFieldType instances should never be considered equal if they are different implementations?", "author": "jpountz", "createdAt": "2020-06-11T08:24:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI2MTI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI2MzQ5NA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r435263494", "bodyText": "Could Mapper has a method that returns null if it isn't a FieldMapper?", "author": "nik9000", "createdAt": "2020-06-04T13:41:34Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/MapperService.java", "diffHunk": "@@ -166,6 +167,17 @@ public DocumentMapperParser documentMapperParser() {\n         return this.documentParser;\n     }\n \n+    public FieldType getLuceneFieldType(String field) {\n+        Mapper mapper = documentMapper().mappers().getMapper(field);\n+        if (mapper == null) {\n+            return null;\n+        }\n+        if (mapper instanceof FieldMapper == false) {", "originalCommit": "ac2cc4a58982e13e8758cf8c6e8cb6bec76e18b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI2NjYxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r435266615", "bodyText": "Maybe just run the formatter on the method declaration while you are here. It isn't really my favorite formatter, but we're going to hit the whole code base with it eventually.", "author": "nik9000", "createdAt": "2020-06-04T13:44:38Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/LegacyGeoShapeFieldMapper.java", "diffHunk": "@@ -441,11 +420,11 @@ public PrefixTreeStrategy resolvePrefixTreeStrategy(String strategyName) {\n         }\n     }\n \n-    public LegacyGeoShapeFieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType,\n-                               Explicit<Boolean> ignoreMalformed, Explicit<Boolean> coerce, Explicit<Orientation> orientation,\n-                               Explicit<Boolean> ignoreZValue, Settings indexSettings,\n-                               MultiFields multiFields, CopyTo copyTo) {\n-        super(simpleName, fieldType, defaultFieldType, ignoreMalformed, coerce, ignoreZValue, orientation, indexSettings,\n+    public LegacyGeoShapeFieldMapper(String simpleName, FieldType fieldType, MappedFieldType mappedFieldType,", "originalCommit": "ac2cc4a58982e13e8758cf8c6e8cb6bec76e18b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI1MzE3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r435253175", "bodyText": "The fact that we only have a single type helps simplify a lot here", "author": "romseygeek", "createdAt": "2020-06-04T13:28:53Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -56,66 +55,46 @@\n         Setting.boolSetting(\"index.mapping.ignore_malformed\", false, Property.IndexScope);\n     public static final Setting<Boolean> COERCE_SETTING =\n         Setting.boolSetting(\"index.mapping.coerce\", false, Property.IndexScope);\n-    public abstract static class Builder<T extends Builder> extends Mapper.Builder<T> {\n+    public abstract static class Builder<T extends Builder<T>> extends Mapper.Builder<T> {\n \n-        protected final MappedFieldType fieldType;\n-        protected final MappedFieldType defaultFieldType;\n-        private final IndexOptions defaultOptions;\n+        protected final FieldType fieldType;\n         protected boolean omitNormsSet = false;\n         protected boolean indexOptionsSet = false;\n-        protected boolean docValuesSet = false;\n+        protected boolean hasDocValues = true;\n+        protected boolean indexed = true;\n         protected final MultiFields.Builder multiFieldsBuilder;\n         protected CopyTo copyTo = CopyTo.empty();\n-\n-        protected Builder(String name, MappedFieldType fieldType, MappedFieldType defaultFieldType) {\n+        protected float boost = 1.0f;\n+        protected Map<String, String> meta = Collections.emptyMap();\n+        // TODO move to KeywordFieldMapper.Builder\n+        protected boolean eagerGlobalOrdinals;\n+        // TODO move to text-specific builder base class\n+        protected NamedAnalyzer indexAnalyzer;\n+        protected NamedAnalyzer searchAnalyzer;\n+        protected NamedAnalyzer searchQuoteAnalyzer;\n+        protected SimilarityProvider similarity;\n+\n+        protected Builder(String name, FieldType fieldType) {\n             super(name);\n-            this.fieldType = fieldType.clone();\n-            this.defaultFieldType = defaultFieldType.clone();\n-            this.defaultOptions = fieldType.indexOptions(); // we have to store it the fieldType is mutable\n-            this.docValuesSet = fieldType.hasDocValues();\n+            this.fieldType = new FieldType(fieldType);\n             multiFieldsBuilder = new MultiFields.Builder();\n         }\n \n-        public MappedFieldType fieldType() {\n-            return fieldType;\n-        }\n-\n         public T index(boolean index) {\n-            if (index) {\n-                if (fieldType.indexOptions() == IndexOptions.NONE) {\n-                    /*\n-                     * the logic here is to reset to the default options only if we are not indexed ie. options are null\n-                     * if the fieldType has a non-null option we are all good it might have been set through a different\n-                     * call.\n-                     */\n-                    IndexOptions options = getDefaultIndexOption();\n-                    if (options == IndexOptions.NONE) {\n-                        // can happen when an existing type on the same index has disabled indexing\n-                        // since we inherit the default field type from the first mapper that is\n-                        // created on an index\n-                        throw new IllegalArgumentException(\"mapper [\" + name + \"] has different [index] values from other types\"\n-                            + \" of the same index\");\n-                    }\n-                    fieldType.setIndexOptions(options);\n-                }\n-            } else {\n-                fieldType.setIndexOptions(IndexOptions.NONE);", "originalCommit": "ac2cc4a58982e13e8758cf8c6e8cb6bec76e18b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI1Njk5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r435256997", "bodyText": "We have a few places that were doing instanceof checks on lucene IndexableField fieldtypes - this allows us to continue doing those for now, as we can instead do an instanceof check for KeywordField", "author": "romseygeek", "createdAt": "2020-06-04T13:34:26Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "diffHunk": "@@ -72,23 +75,36 @@\n \n         public static final String NULL_VALUE = null;\n         public static final int IGNORE_ABOVE = Integer.MAX_VALUE;\n+        public static final boolean EAGER_GLOBAL_ORDINALS = false;\n+        public static final boolean SPLIT_QUERIES_ON_WHITESPACE = false;\n+    }\n+\n+    public static class KeywordField extends Field {\n+\n+        public KeywordField(String field, BytesRef term, FieldType ft) {\n+            super(field, term, ft);\n+        }\n+", "originalCommit": "ac2cc4a58982e13e8758cf8c6e8cb6bec76e18b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI1ODQ2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r435258469", "bodyText": "nullValue and nullValueAsString are now dealt with directly by FieldMappers that require it", "author": "romseygeek", "createdAt": "2020-06-04T13:36:32Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java", "diffHunk": "@@ -54,52 +52,45 @@\n \n import java.io.IOException;\n import java.time.ZoneId;\n-import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n \n /**\n  * This defines the core properties and functions to operate on a field.\n  */\n-public abstract class MappedFieldType extends FieldType {\n+public abstract class MappedFieldType {\n \n-    private String name;\n+    private final String name;\n+    private final boolean docValues;\n+    private final boolean isSearchable;\n     private float boost;\n-    // TODO: remove this docvalues flag and use docValuesType\n-    private boolean docValues;\n     private NamedAnalyzer indexAnalyzer;\n     private NamedAnalyzer searchAnalyzer;\n     private NamedAnalyzer searchQuoteAnalyzer;\n     private SimilarityProvider similarity;\n-    private Object nullValue;", "originalCommit": "ac2cc4a58982e13e8758cf8c6e8cb6bec76e18b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI2MTA3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r435261075", "bodyText": "This is a bit of an unfortunate hack - there are still places that require access directly to the lucene field type, particularly in the highlighter code.  They can almost certainly be refactored to use either information from the MappedFieldType or from the Mapper, but this PR is big enough already.", "author": "romseygeek", "createdAt": "2020-06-04T13:39:10Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/MapperService.java", "diffHunk": "@@ -166,6 +167,17 @@ public DocumentMapperParser documentMapperParser() {\n         return this.documentParser;\n     }\n \n+    public FieldType getLuceneFieldType(String field) {", "originalCommit": "ac2cc4a58982e13e8758cf8c6e8cb6bec76e18b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI3OTE3NA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r435279174", "bodyText": "++.", "author": "nik9000", "createdAt": "2020-06-04T13:58:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI2MTA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI2Nzc0NA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r435267744", "bodyText": "Formatter and Resolution are non-modifiable, so the tests on DateFieldMapperTests replace these bits", "author": "romseygeek", "createdAt": "2020-06-04T13:45:45Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java", "diffHunk": "@@ -53,67 +51,46 @@\n import org.elasticsearch.index.query.QueryRewriteContext;\n import org.elasticsearch.index.query.QueryShardContext;\n import org.joda.time.DateTimeZone;\n-import org.junit.Before;\n \n import java.io.IOException;\n import java.time.Instant;\n import java.time.ZoneOffset;\n+import java.util.Collections;\n+import java.util.Map;\n \n public class DateFieldTypeTests extends FieldTypeTestCase<DateFieldType> {\n-    @Override\n-    protected DateFieldType createDefaultFieldType() {\n-        return new DateFieldType();\n-    }\n \n-    @Before", "originalCommit": "ac2cc4a58982e13e8758cf8c6e8cb6bec76e18b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI2OTgxMg==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r435269812", "bodyText": "This ends up making this TODO official", "author": "romseygeek", "createdAt": "2020-06-04T13:47:42Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/SignificantTextAggregatorTests.java", "diffHunk": "@@ -76,10 +77,7 @@ protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldTy\n     @Override\n     protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n         // TODO it is likely accidental that SigText supports anything other than Bytes, and then only text fields\n-        return List.of(CoreValuesSourceType.NUMERIC,", "originalCommit": "ac2cc4a58982e13e8758cf8c6e8cb6bec76e18b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI3MTE1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r435271159", "bodyText": "So it turns out that these tests didn't test what they thought they were testing, and the functionality they should have been testing for is broken.  I opened #57651 to deal with them separately.", "author": "romseygeek", "createdAt": "2020-06-04T13:48:58Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/DateRangeAggregatorTests.java", "diffHunk": "@@ -70,6 +71,7 @@ public void testNoMatchingField() throws IOException {\n         });\n     }\n \n+    @AwaitsFix(bugUrl=\"https://github.com/elastic/elasticsearch/issues/57651\")", "originalCommit": "ac2cc4a58982e13e8758cf8c6e8cb6bec76e18b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI3NTE5MA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r435275190", "bodyText": "This is a bit slow, unfortunately - the idea is to check that serializing a mapper and then using it as a merge input always ends up with the same mapper, for each possible modification.  But we need a new MapperService for each test, because some modifications are unmergeable.  And that means we have to rebuild a whole new index each time, so that we load mappers from plugins, etc.  Which is slow.", "author": "romseygeek", "createdAt": "2020-06-04T13:53:19Z", "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/FieldMapperTestCase.java", "diffHunk": "@@ -205,4 +203,47 @@ protected String contentType() {\n         }\n     }\n \n+    public void testSerialization() throws IOException {\n+        for (Modifier modifier : modifiers) {\n+            if (unsupportedProperties().contains(modifier.property)) {\n+                continue;\n+            }\n+            T builder1 = newBuilder();\n+            T builder2 = newBuilder();\n+            modifier.apply(builder1, builder2);\n+            assertSerializes(modifier.property + \"-a\", builder1);\n+            assertSerializes(modifier.property + \"-b\", builder2);\n+        }\n+    }\n+\n+    protected Settings getIndexMapperSettings() {\n+        return Settings.EMPTY;\n+    }\n+\n+    protected void assertSerializes(String indexname, T builder) throws IOException {\n+\n+        // TODO can we do this without building an entire index?", "originalCommit": "ac2cc4a58982e13e8758cf8c6e8cb6bec76e18b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b18c1b9d3d06fe90cb5f1cd7fc7ef86a0ba7fbb0", "url": "https://github.com/elastic/elasticsearch/commit/b18c1b9d3d06fe90cb5f1cd7fc7ef86a0ba7fbb0", "message": "Merge remote-tracking branch 'origin/master' into mapper/fieldtype", "committedDate": "2020-06-04T16:09:57Z", "type": "commit"}, {"oid": "344520bd33727e47c326bcd1a8e7dc368a40d4f6", "url": "https://github.com/elastic/elasticsearch/commit/344520bd33727e47c326bcd1a8e7dc368a40d4f6", "message": "compilation", "committedDate": "2020-06-07T15:41:29Z", "type": "commit"}, {"oid": "b26fd8007e3339fa8e1c7dc82eaaad8188a55ea9", "url": "https://github.com/elastic/elasticsearch/commit/b26fd8007e3339fa8e1c7dc82eaaad8188a55ea9", "message": "Merge remote-tracking branch 'origin/master' into mapper/fieldtype", "committedDate": "2020-06-07T15:43:20Z", "type": "commit"}, {"oid": "f331482137dede869b42de5efd8152f685377a5b", "url": "https://github.com/elastic/elasticsearch/commit/f331482137dede869b42de5efd8152f685377a5b", "message": "mapper-extras, analytics", "committedDate": "2020-06-08T11:01:00Z", "type": "commit"}, {"oid": "a146b6fb63296215ed24565aa662ef25aaf3eb94", "url": "https://github.com/elastic/elasticsearch/commit/a146b6fb63296215ed24565aa662ef25aaf3eb94", "message": "percolator", "committedDate": "2020-06-08T12:57:02Z", "type": "commit"}, {"oid": "fc791057092db6f8dd9744ee18586fe6f143521e", "url": "https://github.com/elastic/elasticsearch/commit/fc791057092db6f8dd9744ee18586fe6f143521e", "message": "server integtests", "committedDate": "2020-06-08T14:57:00Z", "type": "commit"}, {"oid": "3772c31f8f5513c6a2549532ffa1d39b905fe23f", "url": "https://github.com/elastic/elasticsearch/commit/3772c31f8f5513c6a2549532ffa1d39b905fe23f", "message": "checkstyle", "committedDate": "2020-06-08T15:02:50Z", "type": "commit"}, {"oid": "bb8a244e084ce34f83d6d94fcc8ec0fcc2fad9e1", "url": "https://github.com/elastic/elasticsearch/commit/bb8a244e084ce34f83d6d94fcc8ec0fcc2fad9e1", "message": "flattened; precommit", "committedDate": "2020-06-08T16:55:15Z", "type": "commit"}, {"oid": "5e6ce42d7ab85044fb2fe0aa23ffb18c85c1e222", "url": "https://github.com/elastic/elasticsearch/commit/5e6ce42d7ab85044fb2fe0aa23ffb18c85c1e222", "message": "tests", "committedDate": "2020-06-09T10:07:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI5ODg5OA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r437298898", "bodyText": "How hard would it be to get rid of FieldType here? It's a bit annoying because usually there isn't a single FieldType that applies, e.g. numeric fields leverage both points and numeric doc values, but it's impossible to configure both on a FieldType, which is why we create different Fields for points and doc values.", "author": "jpountz", "createdAt": "2020-06-09T10:14:07Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -210,44 +189,30 @@ protected boolean defaultDocValues(Version indexCreated) {\n             return fieldType.tokenized() == false;\n         }\n \n-        protected void setupFieldType(BuilderContext context) {\n-            fieldType.setName(buildFullName(context));\n-            if (fieldType.indexAnalyzer() == null && fieldType.tokenized() == false && fieldType.indexOptions() != IndexOptions.NONE) {\n-                fieldType.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);\n-                fieldType.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);\n-            }\n-            boolean defaultDocValues = defaultDocValues(context.indexCreatedVersion());\n-            defaultFieldType.setHasDocValues(defaultDocValues);\n-            if (docValuesSet == false) {\n-                fieldType.setHasDocValues(defaultDocValues);\n-            }\n-        }\n-\n         /** Set metadata on this field. */\n         public T meta(Map<String, String> meta) {\n-            fieldType.setMeta(meta);\n+            this.meta = meta;\n             return (T) this;\n         }\n     }\n \n     protected final Version indexCreatedVersion;\n-    protected MappedFieldType fieldType;\n-    protected final MappedFieldType defaultFieldType;\n+    protected FieldType fieldType;\n+    protected MappedFieldType mappedFieldType;\n     protected MultiFields multiFields;\n     protected CopyTo copyTo;\n \n-    protected FieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType,\n+    protected FieldMapper(String simpleName, FieldType fieldType, MappedFieldType mappedFieldType,", "originalCommit": "5e6ce42d7ab85044fb2fe0aa23ffb18c85c1e222", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI5OTkyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r437299925", "bodyText": "Oh apologies, I just saw your previous message where you explain exactly this. +1 for progress over perfection and keeping it for a follow-up refactoring.", "author": "jpountz", "createdAt": "2020-06-09T10:16:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI5ODg5OA=="}], "type": "inlineReview"}, {"oid": "50d43a636d269424182d2bc57145caf1c3a7113d", "url": "https://github.com/elastic/elasticsearch/commit/50d43a636d269424182d2bc57145caf1c3a7113d", "message": "tests", "committedDate": "2020-06-09T12:56:19Z", "type": "commit"}, {"oid": "9b6ebdf17c33579543352352c555f0822e56f8f9", "url": "https://github.com/elastic/elasticsearch/commit/9b6ebdf17c33579543352352c555f0822e56f8f9", "message": "tests", "committedDate": "2020-06-09T14:19:45Z", "type": "commit"}, {"oid": "f71d49e499536de1e9f7bc2f30a6b8716e4b9852", "url": "https://github.com/elastic/elasticsearch/commit/f71d49e499536de1e9f7bc2f30a6b8716e4b9852", "message": "line length", "committedDate": "2020-06-09T14:22:24Z", "type": "commit"}, {"oid": "a5bbeeec9472d9da5d6938eb34f9c1d403e92e30", "url": "https://github.com/elastic/elasticsearch/commit/a5bbeeec9472d9da5d6938eb34f9c1d403e92e30", "message": "moar", "committedDate": "2020-06-09T15:48:16Z", "type": "commit"}, {"oid": "39468c05f069405b2e0a04e1496d8dc19f14f114", "url": "https://github.com/elastic/elasticsearch/commit/39468c05f069405b2e0a04e1496d8dc19f14f114", "message": "murmur3", "committedDate": "2020-06-09T16:10:57Z", "type": "commit"}, {"oid": "6816f5fad17866b747508d77b77198abe12a5f90", "url": "https://github.com/elastic/elasticsearch/commit/6816f5fad17866b747508d77b77198abe12a5f90", "message": "Merge remote-tracking branch 'origin/master' into mapper/fieldtype", "committedDate": "2020-06-09T17:28:42Z", "type": "commit"}, {"oid": "a9e36a7132e0dedcdf0eac637dc1ea11a312c5b8", "url": "https://github.com/elastic/elasticsearch/commit/a9e36a7132e0dedcdf0eac637dc1ea11a312c5b8", "message": "percolator", "committedDate": "2020-06-10T09:12:40Z", "type": "commit"}, {"oid": "f97840e27eb50236c2f82b64855ccb87e67d61c1", "url": "https://github.com/elastic/elasticsearch/commit/f97840e27eb50236c2f82b64855ccb87e67d61c1", "message": "Merge remote-tracking branch 'origin/master' into mapper/fieldtype", "committedDate": "2020-06-15T09:10:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMyNDA2NA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r435324064", "bodyText": "maybe as a follow-up we'll want to rename this, I assume that the reason why its name ends with FieldType is that it extended FieldType.", "author": "javanna", "createdAt": "2020-06-04T14:56:37Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java", "diffHunk": "@@ -54,52 +52,45 @@\n \n import java.io.IOException;\n import java.time.ZoneId;\n-import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n \n /**\n  * This defines the core properties and functions to operate on a field.\n  */\n-public abstract class MappedFieldType extends FieldType {\n+public abstract class MappedFieldType {", "originalCommit": "ac2cc4a58982e13e8758cf8c6e8cb6bec76e18b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE1Njg4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440156883", "bodyText": "Yup, plan is to rename it to SearchField", "author": "romseygeek", "createdAt": "2020-06-15T12:58:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMyNDA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4MDI4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440180281", "bodyText": "cool", "author": "javanna", "createdAt": "2020-06-15T13:36:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMyNDA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1MDA2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440050062", "bodyText": "intuitively, this has been replaced by the newly added docValuesByDefault method ? But why doesn't indexedByDefault also replace the index options bit above?", "author": "javanna", "createdAt": "2020-06-15T09:34:00Z", "path": "modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/RankFeaturesFieldMapper.java", "diffHunk": "@@ -41,12 +42,11 @@\n     public static final String CONTENT_TYPE = \"rank_features\";\n \n     public static class Defaults {\n-        public static final MappedFieldType FIELD_TYPE = new RankFeaturesFieldType();\n+        public static final FieldType FIELD_TYPE = new FieldType();\n \n         static {\n             FIELD_TYPE.setTokenized(false);\n             FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n-            FIELD_TYPE.setHasDocValues(false);", "originalCommit": "f97840e27eb50236c2f82b64855ccb87e67d61c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE1ODMwMA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440158300", "bodyText": "This is because setting docvalues on lucene's FieldType doesn't have any effect at the API level, as adding a DocValues field explicitly will set things later.  But you do need to set index options separately.  A follow up will remove this entirely (RankFeaturesFieldMapper, along with many many other field mappers, doesn't actually need a lucene FieldType at all).", "author": "romseygeek", "createdAt": "2020-06-15T13:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1MDA2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4MDIyOA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440180228", "bodyText": "thanks for clarifying", "author": "javanna", "createdAt": "2020-06-15T13:36:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1MDA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1MTI0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440051247", "bodyText": "I got lost on where this error was returned before, can you help me out?", "author": "javanna", "createdAt": "2020-06-15T09:36:06Z", "path": "modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/RankFeaturesFieldMapper.java", "diffHunk": "@@ -55,35 +55,37 @@\n     public static class Builder extends FieldMapper.Builder<Builder> {\n \n         public Builder(String name) {\n-            super(name, Defaults.FIELD_TYPE, Defaults.FIELD_TYPE);\n+            super(name, Defaults.FIELD_TYPE);\n             builder = this;\n         }\n \n         @Override\n-        public RankFeaturesFieldType fieldType() {\n-            return (RankFeaturesFieldType) super.fieldType();\n+        public Builder docValues(boolean docValues) {\n+            if (docValues) {\n+                throw new IllegalArgumentException(\"mapper [\" + name() + \"] of type [rank_features] does not support doc values\");", "originalCommit": "f97840e27eb50236c2f82b64855ccb87e67d61c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3NTg2NA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440175864", "bodyText": "Double checking, it wasn't an error before, it was just silently ignored.  Will change it back.", "author": "romseygeek", "createdAt": "2020-06-15T13:29:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1MTI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3OTAyMA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440179020", "bodyText": "ok, I suspect there are other similar errors, I had the same question but I refrained from asking it as I may have missed something.", "author": "javanna", "createdAt": "2020-06-15T13:34:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1MTI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxOTMwNw==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440419307", "bodyText": "I left a bunch of new questions/comments wherever I saw errors that I am not sure we were previously returning.", "author": "javanna", "createdAt": "2020-06-15T20:11:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1MTI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA2MTY0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440061649", "bodyText": "for my info, are these newly introduced checks or were they just moved?", "author": "javanna", "createdAt": "2020-06-15T09:53:52Z", "path": "modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/TokenCountFieldMapper.java", "diffHunk": "@@ -202,8 +212,14 @@ protected String contentType() {\n \n     @Override\n     protected void mergeOptions(FieldMapper other, List<String> conflicts) {\n-        this.analyzer = ((TokenCountFieldMapper) other).analyzer;\n-        this.enablePositionIncrements = ((TokenCountFieldMapper) other).enablePositionIncrements;\n+        // TODO we should ban updating analyzers as well\n+        if (this.enablePositionIncrements != ((TokenCountFieldMapper)other).enablePositionIncrements) {\n+            conflicts.add(\"mapper [\" + name() + \"] has a different [enable_position_increments] setting\");\n+        }\n+        if (Objects.equals(this.nullValue, ((TokenCountFieldMapper)other).nullValue) == false) {\n+            conflicts.add(\"mapper [\" + name() + \"] has a different [null_value] setting\");\n+        }", "originalCommit": "f97840e27eb50236c2f82b64855ccb87e67d61c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3ODM2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440178363", "bodyText": "I thought I had moved this from the root mapper, but I've looked again and there was no check, which meant that null_value could be changed.  However, null_value is an index-time setting and so we shouldn't really allow it to be updated on merge - I can remove the check and allow an update, but that feels like re-introducing a bug?", "author": "romseygeek", "createdAt": "2020-06-15T13:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA2MTY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3OTk2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440179961", "bodyText": "I would address this separately, in the effort of keeping this PR on point as well as  promoting the bugfix.", "author": "javanna", "createdAt": "2020-06-15T13:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA2MTY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4Njc4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440186787", "bodyText": "Actually looking again, an update to null_value was previously being ignored - it wouldn't be copied across on merge at all.", "author": "romseygeek", "createdAt": "2020-06-15T13:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA2MTY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4OTYwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440189609", "bodyText": "not great, yet better than allowing to update it :) lets open an issue and fix this as a followup?", "author": "javanna", "createdAt": "2020-06-15T13:50:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA2MTY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA3Mzk1OA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440073958", "bodyText": "I find this confusing given that soon we'll have searchable fields that are not indexed. Should we rather rename it to failIfNotSearchable ? And the error message? Or maybe isSearchable should rather be isIndexed ?", "author": "javanna", "createdAt": "2020-06-15T10:16:05Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java", "diffHunk": "@@ -378,7 +342,7 @@ protected final void failIfNoDocValues() {\n     }\n \n     protected final void failIfNotIndexed() {\n-        if (indexOptions() == IndexOptions.NONE && pointDimensionCount() == 0) {\n+        if (isSearchable == false) {", "originalCommit": "f97840e27eb50236c2f82b64855ccb87e67d61c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3OTk5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440179997", "bodyText": "I'll change the various to be isIndexed - I think the isSearchable method should stay named as it is though?", "author": "romseygeek", "createdAt": "2020-06-15T13:36:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA3Mzk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4MDg1MA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440180850", "bodyText": "yes the existing method that is used by field_caps , I would leave unchanged", "author": "javanna", "createdAt": "2020-06-15T13:37:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA3Mzk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEzMjg0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440132849", "bodyText": "Am I correct that these methods are only used for serialization? Should we also rely on these default for parsing?", "author": "jpountz", "createdAt": "2020-06-15T12:15:16Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -431,6 +398,18 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n         return builder.endObject();\n     }\n \n+    protected boolean indexedByDefault() {\n+        return true;\n+    }\n+\n+    protected boolean docValuesByDefault() {\n+        return true;\n+    }\n+\n+    protected boolean storedByDefault() {\n+        return false;\n+    }", "originalCommit": "f97840e27eb50236c2f82b64855ccb87e67d61c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4MTQ5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440181499", "bodyText": "Unfortunately we can't use them for parsing because the builders/parsers are static.  I think builder parameters/parsing/serialization/merging can all be cleaned up a lot though; I have some ideas which I'll sketch out in a separate issue.", "author": "romseygeek", "createdAt": "2020-06-15T13:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEzMjg0OQ=="}], "type": "inlineReview"}, {"oid": "fd0e5e16a3679b46f31d285307e3c8e84e4827f6", "url": "https://github.com/elastic/elasticsearch/commit/fd0e5e16a3679b46f31d285307e3c8e84e4827f6", "message": "feedback", "committedDate": "2020-06-15T13:53:23Z", "type": "commit"}, {"oid": "0ac318dbcf7a767e370e8a36417dcc22796ede0c", "url": "https://github.com/elastic/elasticsearch/commit/0ac318dbcf7a767e370e8a36417dcc22796ede0c", "message": "null check for booleans", "committedDate": "2020-06-15T14:16:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIwMDc1NA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440200754", "bodyText": "This is so much better!", "author": "nik9000", "createdAt": "2020-06-15T14:06:01Z", "path": "modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/ScaledFloatFieldMapper.java", "diffHunk": "@@ -111,11 +114,16 @@ public Builder coerce(boolean coerce) {\n         }\n \n         public Builder scalingFactor(double scalingFactor) {\n-            ((ScaledFloatFieldType) fieldType).setScalingFactor(scalingFactor);\n+            this.scalingFactor = scalingFactor;", "originalCommit": "f97840e27eb50236c2f82b64855ccb87e67d61c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIwOTY3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440209675", "bodyText": "\ud83d\udc4d", "author": "nik9000", "createdAt": "2020-06-15T14:18:37Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java", "diffHunk": "@@ -592,35 +595,34 @@ protected void parseCreateField(ParseContext context) throws IOException {\n             dateAsString = context.parser().textOrNull();\n         }\n \n-        if (dateAsString == null) {\n-            dateAsString = fieldType().nullValueAsString();\n-        }\n-\n-        if (dateAsString == null) {\n-            return;\n-        }\n-\n         long timestamp;\n-        try {\n-            timestamp = fieldType().parse(dateAsString);\n-        } catch (IllegalArgumentException | ElasticsearchParseException | DateTimeException e) {\n-            if (ignoreMalformed.value()) {\n-                context.addIgnoredField(fieldType.name());\n+        if (dateAsString == null) {\n+            if (nullValue == null) {\n                 return;\n-            } else {\n-                throw e;\n+            }\n+            timestamp = nullValue;", "originalCommit": "f97840e27eb50236c2f82b64855ccb87e67d61c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIxMDIyNw==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440210227", "bodyText": "\ud83d\udc4d", "author": "nik9000", "createdAt": "2020-06-15T14:19:24Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -56,66 +55,46 @@\n         Setting.boolSetting(\"index.mapping.ignore_malformed\", false, Property.IndexScope);\n     public static final Setting<Boolean> COERCE_SETTING =\n         Setting.boolSetting(\"index.mapping.coerce\", false, Property.IndexScope);\n-    public abstract static class Builder<T extends Builder> extends Mapper.Builder<T> {\n+    public abstract static class Builder<T extends Builder<T>> extends Mapper.Builder<T> {\n \n-        protected final MappedFieldType fieldType;\n-        protected final MappedFieldType defaultFieldType;\n-        private final IndexOptions defaultOptions;\n+        protected final FieldType fieldType;\n         protected boolean omitNormsSet = false;\n         protected boolean indexOptionsSet = false;\n-        protected boolean docValuesSet = false;\n+        protected boolean hasDocValues = true;\n+        protected boolean indexed = true;\n         protected final MultiFields.Builder multiFieldsBuilder;\n         protected CopyTo copyTo = CopyTo.empty();\n-\n-        protected Builder(String name, MappedFieldType fieldType, MappedFieldType defaultFieldType) {\n+        protected float boost = 1.0f;\n+        protected Map<String, String> meta = Collections.emptyMap();\n+        // TODO move to KeywordFieldMapper.Builder\n+        protected boolean eagerGlobalOrdinals;\n+        // TODO move to text-specific builder base class", "originalCommit": "f97840e27eb50236c2f82b64855ccb87e67d61c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIxNjM5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440216393", "bodyText": "I don't think we meant to support it, no. We probably should deprecate it and drop it in 8.0.\nI think it is probably worth adding a comment that this won't cause us to make an index of the text representation of the keyword.", "author": "nik9000", "createdAt": "2020-06-15T14:28:11Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java", "diffHunk": "@@ -893,12 +903,15 @@ private static double objectToDouble(Object value) {\n \n         private final NumberType type;\n \n-        public NumberFieldType(NumberType type) {\n-            super();\n+        public NumberFieldType(String name, NumberType type, boolean isSearchable, boolean hasDocValues, Map<String, String> meta) {\n+            super(name, isSearchable, hasDocValues, meta);\n             this.type = Objects.requireNonNull(type);\n-            setTokenized(false);\n-            setHasDocValues(true);\n-            setOmitNorms(true);\n+            this.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);     // allows number fields in significant text aggs - do we need this?", "originalCommit": "f97840e27eb50236c2f82b64855ccb87e67d61c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIxNjY4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440216686", "bodyText": "Huh! That feels like a \"funny\" abstraction being invoked.", "author": "nik9000", "createdAt": "2020-06-15T14:28:34Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java", "diffHunk": "@@ -893,12 +903,15 @@ private static double objectToDouble(Object value) {\n \n         private final NumberType type;\n \n-        public NumberFieldType(NumberType type) {\n-            super();\n+        public NumberFieldType(String name, NumberType type, boolean isSearchable, boolean hasDocValues, Map<String, String> meta) {\n+            super(name, isSearchable, hasDocValues, meta);\n             this.type = Objects.requireNonNull(type);\n-            setTokenized(false);\n-            setHasDocValues(true);\n-            setOmitNorms(true);\n+            this.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);     // allows number fields in significant text aggs - do we need this?\n+            this.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);    // allows match queries on number fields", "originalCommit": "f97840e27eb50236c2f82b64855ccb87e67d61c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3OTk4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440379989", "bodyText": "is it ok that the includeDefaults condition is gone here?", "author": "javanna", "createdAt": "2020-06-15T18:54:52Z", "path": "modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/ScaledFloatFieldMapper.java", "diffHunk": "@@ -446,17 +456,16 @@ protected void mergeOptions(FieldMapper other, List<String> conflicts) {\n     protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {\n         super.doXContentBody(builder, includeDefaults, params);\n \n-        builder.field(\"scaling_factor\", fieldType().getScalingFactor());\n+        builder.field(\"scaling_factor\", scalingFactor);\n \n         if (includeDefaults || ignoreMalformed.explicit()) {\n             builder.field(\"ignore_malformed\", ignoreMalformed.value());\n         }\n         if (includeDefaults || coerce.explicit()) {\n             builder.field(\"coerce\", coerce.value());\n         }\n-\n-        if (includeDefaults || fieldType().nullValue() != null) {\n-            builder.field(\"null_value\", fieldType().nullValue());\n+        if (nullValue != null) {", "originalCommit": "0ac318dbcf7a767e370e8a36417dcc22796ede0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI2MTU5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r448261596", "bodyText": "This is a slightly tricky one, in that null is not accepted as a value for null_value in mappings; so if we emit null here, then you can't use the output to set up mappings elsewhere.  FieldMapperTestBase in this PR adds a check that for each modified parameter, serialization/deserialization produces the same mapper configuration, both with and without including defaults, and this test will fail if null is emitted at this point.  It is a change, but I think it's a correct one?  I can open a separate issue regarding null values here, and mark it as team-discuss if we want to have a wider discussion about it.", "author": "romseygeek", "createdAt": "2020-07-01T10:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3OTk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA3OTM4NA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r450079384", "bodyText": "thanks for explaining, it sounds to me like no discussion is needed and this is a required change.", "author": "javanna", "createdAt": "2020-07-06T08:55:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3OTk4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4MDYwNg==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440380606", "bodyText": "is this an existing error or was it silently rejected before?", "author": "javanna", "createdAt": "2020-06-15T18:55:56Z", "path": "modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/SearchAsYouTypeFieldMapper.java", "diffHunk": "@@ -147,23 +148,26 @@ public Builder maxShingleSize(int maxShingleSize) {\n         }\n \n         @Override\n-        public SearchAsYouTypeFieldType fieldType() {\n-            return (SearchAsYouTypeFieldType) this.fieldType;\n+        public Builder docValues(boolean docValues) {\n+            if (docValues) {\n+                throw new IllegalArgumentException(\"mapper [\" + name() + \"] of type [search_as_you_type] does not support doc values\");", "originalCommit": "0ac318dbcf7a767e370e8a36417dcc22796ede0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI2Mjk3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r448262979", "bodyText": "It was silently ignored before - I think an error message is better, but maybe it should just issue a warning in 7.x?", "author": "romseygeek", "createdAt": "2020-07-01T10:15:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4MDYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4MDMwMA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r450080300", "bodyText": "for all of these subtle changes, on one hand we could consider them bugfixes. but I am afraid that users may rely on us silently accepting wrong mappings and we should rather deprecate first and remove in 8.0, if possible", "author": "javanna", "createdAt": "2020-07-06T08:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4MDYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4MTU1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440381553", "bodyText": "was this also thrown before?", "author": "javanna", "createdAt": "2020-06-15T18:57:38Z", "path": "modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/SearchAsYouTypeFieldMapper.java", "diffHunk": "@@ -681,6 +703,9 @@ protected void mergeOptions(FieldMapper other, List<String> conflicts) {\n                 this.shingleFields[i] = (ShingleFieldMapper) this.shingleFields[i].merge(m.shingleFields[i]);\n             }\n         }\n+        if (Objects.equals(this.fieldType().similarity(), other.fieldType().similarity()) == false) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [similarity] settings\");", "originalCommit": "0ac318dbcf7a767e370e8a36417dcc22796ede0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3NDUzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r448274531", "bodyText": "As above, it was silently ignored.  I'll open an issue to make this emit a warning in 7x", "author": "romseygeek", "createdAt": "2020-07-01T10:38:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4MTU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4MjEzMg==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440382132", "bodyText": "this seems like a new error that was not returned before?", "author": "javanna", "createdAt": "2020-06-15T18:58:42Z", "path": "modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/TokenCountFieldMapper.java", "diffHunk": "@@ -202,8 +211,11 @@ protected String contentType() {\n \n     @Override\n     protected void mergeOptions(FieldMapper other, List<String> conflicts) {\n-        this.analyzer = ((TokenCountFieldMapper) other).analyzer;\n-        this.enablePositionIncrements = ((TokenCountFieldMapper) other).enablePositionIncrements;\n+        // TODO we should ban updating analyzers and null values as well\n+        if (this.enablePositionIncrements != ((TokenCountFieldMapper)other).enablePositionIncrements) {\n+            conflicts.add(\"mapper [\" + name() + \"] has a different [enable_position_increments] setting\");", "originalCommit": "0ac318dbcf7a767e370e8a36417dcc22796ede0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3NTIyMw==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r448275223", "bodyText": "You're right.  I think this is the right choice (if you've indexed some docs while disabling increments, and then you index further docs after they have been enabled, the numbers stored in the two docs won't be comparable), but it should be a warning in 7x instead of an error.", "author": "romseygeek", "createdAt": "2020-07-01T10:39:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4MjEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwMjIxMg==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440402212", "bodyText": "what happens with these checks once isSearchable returns true yet there is no index? Do we need to distinguish between the two?", "author": "javanna", "createdAt": "2020-06-15T19:37:07Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/AbstractGeometryFieldMapper.java", "diffHunk": "@@ -328,13 +306,13 @@ public void parse(ParseContext context) throws IOException {\n             }\n \n             List<IndexableField> fields = new ArrayList<>();\n-            if (fieldType.indexOptions() != IndexOptions.NONE || fieldType.hasDocValues()) {\n+            if (mappedFieldType.isSearchable() || mappedFieldType.hasDocValues()) {", "originalCommit": "0ac318dbcf7a767e370e8a36417dcc22796ede0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3NTk3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r448275976", "bodyText": "We will need to distinguish between them in the future, yes.  This is something of a shim though - the plan is to eventually move everything to parametrized mappers (see #58663) which will change how this works again.", "author": "romseygeek", "createdAt": "2020-07-01T10:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwMjIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwMjc1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440402753", "bodyText": "is this a new error that gets returned compared to before?", "author": "javanna", "createdAt": "2020-06-15T19:38:09Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/BinaryFieldMapper.java", "diffHunk": "@@ -65,16 +67,23 @@\n     public static class Builder extends FieldMapper.Builder<Builder> {\n \n         public Builder(String name) {\n-            super(name, Defaults.FIELD_TYPE, Defaults.FIELD_TYPE);\n+            super(name, Defaults.FIELD_TYPE);\n             builder = this;\n         }\n \n         @Override\n         public BinaryFieldMapper build(BuilderContext context) {\n-            setupFieldType(context);\n-            return new BinaryFieldMapper(name, fieldType, defaultFieldType,\n+            return new BinaryFieldMapper(name, fieldType, new BinaryFieldType(buildFullName(context), hasDocValues, meta),\n                     context.indexSettings(), multiFieldsBuilder.build(this, context), copyTo);\n         }\n+\n+        @Override\n+        public Builder index(boolean index) {\n+            if (index) {\n+                throw new MapperParsingException(\"Binary field [\" + name() + \"] cannot be indexed\");", "originalCommit": "0ac318dbcf7a767e370e8a36417dcc22796ede0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3NjUyOA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r448276528", "bodyText": "It would have previously been caught by the rather byzantine logic in the base class.", "author": "romseygeek", "createdAt": "2020-07-01T10:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwMjc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwMzI2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440403267", "bodyText": "new error?", "author": "javanna", "createdAt": "2020-06-15T19:39:11Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/CompletionFieldMapper.java", "diffHunk": "@@ -411,13 +422,21 @@ private void checkCompletionContextsLimit(BuilderContext context) {\n                 }\n             }\n         }\n+\n+        @Override\n+        public Builder index(boolean index) {\n+            if (index == false) {\n+                throw new MapperParsingException(\"Completion field type must be indexed\");", "originalCommit": "0ac318dbcf7a767e370e8a36417dcc22796ede0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3Nzc5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r448277795", "bodyText": "It was ignored before, should be a warning in 7x", "author": "romseygeek", "createdAt": "2020-07-01T10:44:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwMzI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwNjEwNw==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440406107", "bodyText": "new or existing error?", "author": "javanna", "createdAt": "2020-06-15T19:44:38Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -372,18 +334,23 @@ private void mergeSharedOptions(FieldMapper mergeWith, List<String> conflicts) {\n                 + \"] to [\" + mergeWith.contentType() + \"]\");\n         }\n \n-        MappedFieldType other = mergeWith.fieldType;\n+        FieldType other = mergeWith.fieldType;\n+        MappedFieldType otherm = mergeWith.mappedFieldType;\n+        this.mappedFieldType.updateMeta(otherm.meta());\n \n         boolean indexed =  fieldType.indexOptions() != IndexOptions.NONE;\n         boolean mergeWithIndexed = other.indexOptions() != IndexOptions.NONE;\n-        // TODO: should be validating if index options go \"up\" (but \"down\" is ok)\n         if (indexed != mergeWithIndexed) {\n             conflicts.add(\"mapper [\" + name() + \"] has different [index] values\");\n         }\n+        // TODO: should be validating if index options go \"up\" (but \"down\" is ok)\n+        if (fieldType.indexOptions() != other.indexOptions()) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [index_options] values\");", "originalCommit": "0ac318dbcf7a767e370e8a36417dcc22796ede0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4MDc2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r448280763", "bodyText": "Hm, I thought this was an existing error but it looks like it's a new one.  I'll add to the 'warnings in 7x' list.", "author": "romseygeek", "createdAt": "2020-07-01T10:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwNjEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwNzA1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440407059", "bodyText": "have we changed behaviour here?", "author": "javanna", "createdAt": "2020-06-15T19:46:22Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/IdFieldMapper.java", "diffHunk": "@@ -160,9 +169,6 @@ public Query termsQuery(List<?> values, QueryShardContext context) {\n \n         @Override\n         public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n-            if (indexOptions() == IndexOptions.NONE) {\n-                throw new IllegalArgumentException(\"Fielddata access on the _id field is disallowed\");", "originalCommit": "0ac318dbcf7a767e370e8a36417dcc22796ede0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4MTEzNg==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r448281136", "bodyText": "No, the ID field is always indexed (you can't configure metadata).", "author": "romseygeek", "createdAt": "2020-07-01T10:51:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwNzA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwOTc3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440409775", "bodyText": "new error?", "author": "javanna", "createdAt": "2020-06-15T19:51:57Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/MetadataFieldMapper.java", "diffHunk": "@@ -46,16 +47,24 @@\n     }\n \n     @SuppressWarnings(\"rawtypes\")\n-    public abstract static class Builder<T extends Builder> extends FieldMapper.Builder<T> {\n-        public Builder(String name, MappedFieldType fieldType, MappedFieldType defaultFieldType) {\n-            super(name, fieldType, defaultFieldType);\n+    public abstract static class Builder<T extends Builder<T>> extends FieldMapper.Builder<T> {\n+        public Builder(String name, FieldType fieldType) {\n+            super(name, fieldType);\n+        }\n+\n+        @Override\n+        public T index(boolean index) {\n+            if (index == false) {\n+                throw new IllegalArgumentException(\"Metadata fields must be indexed\");", "originalCommit": "0ac318dbcf7a767e370e8a36417dcc22796ede0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4MTQyMA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r448281420", "bodyText": "It should be an assertion really - you can't configure metadata fields, so this should never be called.", "author": "romseygeek", "createdAt": "2020-07-01T10:52:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwOTc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxMDI0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440410249", "bodyText": "is it ok that includeDefaults is no longer checked?", "author": "javanna", "createdAt": "2020-06-15T19:52:55Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java", "diffHunk": "@@ -1114,8 +1129,8 @@ protected void doXContentBody(XContentBuilder builder, boolean includeDefaults,\n             builder.field(\"coerce\", coerce.value());\n         }\n \n-        if (includeDefaults || fieldType().nullValue() != null) {\n-            builder.field(\"null_value\", fieldType().nullValue());\n+        if (nullValue != null) {", "originalCommit": "0ac318dbcf7a767e370e8a36417dcc22796ede0c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxNjAxMA==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r440416010", "bodyText": "I got lost trying to figure out if the updated if is equivalent to the previous one.", "author": "javanna", "createdAt": "2020-06-15T20:04:31Z", "path": "server/src/main/java/org/elasticsearch/index/termvectors/TermVectorsService.java", "diffHunk": "@@ -333,10 +332,12 @@ private static Fields generateTermVectorsFromDoc(IndexShard indexShard, TermVect\n     public static String[] getValues(IndexableField[] fields) {\n         List<String> result = new ArrayList<>();\n         for (IndexableField field : fields) {\n-            if (field.fieldType() instanceof KeywordFieldMapper.KeywordFieldType) {\n-                result.add(field.binaryValue().utf8ToString());\n-            } else if (field.fieldType() instanceof StringFieldType) {\n-                result.add(field.stringValue());\n+            if (field.fieldType().indexOptions() != IndexOptions.NONE) {\n+                if (field.binaryValue() != null) {\n+                    result.add(field.binaryValue().utf8ToString());\n+                } else {\n+                    result.add(field.stringValue());\n+                }", "originalCommit": "0ac318dbcf7a767e370e8a36417dcc22796ede0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4MzA3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/57666#discussion_r448283073", "bodyText": "Point fields all have IndexOptions.NONE set, so we should only encounter keyword (binary) fields and text fields here.  Text fields return null from field.binaryValue(), so we check that first to see if it's a keyword field and if so extract the binary value; otherwise it's a text field and so we get the string value.  The tests all seem happy...", "author": "romseygeek", "createdAt": "2020-07-01T10:55:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxNjAxMA=="}], "type": "inlineReview"}]}