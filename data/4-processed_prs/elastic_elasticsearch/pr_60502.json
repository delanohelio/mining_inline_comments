{"pr_number": 60502, "pr_title": "[ML] Implement AucRoc metric for classification", "pr_createdAt": "2020-07-31T09:19:17Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/60502", "timeline": [{"oid": "f5b8e8f05a556a9218fc1e28fdcf4f97e0c338c9", "url": "https://github.com/elastic/elasticsearch/commit/f5b8e8f05a556a9218fc1e28fdcf4f97e0c338c9", "message": "Implement AucRoc metric for classification", "committedDate": "2020-08-21T08:15:59Z", "type": "forcePushed"}, {"oid": "5238ef131722baaddbacb47adb940142ceb3e903", "url": "https://github.com/elastic/elasticsearch/commit/5238ef131722baaddbacb47adb940142ceb3e903", "message": "Implement AucRoc metric for classification", "committedDate": "2020-08-24T12:10:24Z", "type": "forcePushed"}, {"oid": "268189ab6a86d46bd38f33ad9575b40880745e17", "url": "https://github.com/elastic/elasticsearch/commit/268189ab6a86d46bd38f33ad9575b40880745e17", "message": "Implement AucRoc metric for classification", "committedDate": "2020-08-25T12:42:25Z", "type": "forcePushed"}, {"oid": "31b30d5d371e19c5618fc124c203c7e744184bdc", "url": "https://github.com/elastic/elasticsearch/commit/31b30d5d371e19c5618fc124c203c7e744184bdc", "message": "Implement AucRoc metric for classification", "committedDate": "2020-08-26T08:27:46Z", "type": "forcePushed"}, {"oid": "7118804926e43727ff3e5b1364fc22f02818d568", "url": "https://github.com/elastic/elasticsearch/commit/7118804926e43727ff3e5b1364fc22f02818d568", "message": "Implement AucRoc metric for classification", "committedDate": "2020-08-26T11:08:01Z", "type": "forcePushed"}, {"oid": "d8a61aa3fae1824c8b68683eabcfd8ce601ae2cc", "url": "https://github.com/elastic/elasticsearch/commit/d8a61aa3fae1824c8b68683eabcfd8ce601ae2cc", "message": "Implement AucRoc metric for classification", "committedDate": "2020-08-26T11:31:17Z", "type": "forcePushed"}, {"oid": "cd6d20abac5cc5b4cbf54aa7ec4c96cce9bace5d", "url": "https://github.com/elastic/elasticsearch/commit/cd6d20abac5cc5b4cbf54aa7ec4c96cce9bace5d", "message": "Implement AucRoc metric for classification", "committedDate": "2020-08-27T06:25:44Z", "type": "forcePushed"}, {"oid": "2b1f9f3c431c04e0fd322cfdcb104a41c883c917", "url": "https://github.com/elastic/elasticsearch/commit/2b1f9f3c431c04e0fd322cfdcb104a41c883c917", "message": "Implement AucRoc metric for classification", "committedDate": "2020-08-27T07:25:23Z", "type": "forcePushed"}, {"oid": "4c96cc5a67c3e8ff3ef884f0b39ad996f0bde0a9", "url": "https://github.com/elastic/elasticsearch/commit/4c96cc5a67c3e8ff3ef884f0b39ad996f0bde0a9", "message": "Implement AucRoc metric for classification", "committedDate": "2020-09-08T06:29:22Z", "type": "forcePushed"}, {"oid": "c0a07e4eb82f214a3663e740142df472c779bb06", "url": "https://github.com/elastic/elasticsearch/commit/c0a07e4eb82f214a3663e740142df472c779bb06", "message": "Implement AucRoc metric for classification", "committedDate": "2020-09-08T13:13:28Z", "type": "forcePushed"}, {"oid": "3ced241ddc73bd295ba4bdfcd44864a7cdb67430", "url": "https://github.com/elastic/elasticsearch/commit/3ced241ddc73bd295ba4bdfcd44864a7cdb67430", "message": "Implement AucRoc metric for classification", "committedDate": "2020-09-08T13:28:32Z", "type": "forcePushed"}, {"oid": "61a7cf408d415dbc31ececca31699ae4b0c8979e", "url": "https://github.com/elastic/elasticsearch/commit/61a7cf408d415dbc31ececca31699ae4b0c8979e", "message": "Implement AucRoc metric for classification", "committedDate": "2020-09-09T09:59:30Z", "type": "forcePushed"}, {"oid": "3f5f0c9f2d1bd56ac8367dbb69aae1420135218d", "url": "https://github.com/elastic/elasticsearch/commit/3f5f0c9f2d1bd56ac8367dbb69aae1420135218d", "message": "Implement AucRoc metric for classification", "committedDate": "2020-09-09T10:32:51Z", "type": "forcePushed"}, {"oid": "9c70df71ad342ef67d982f196f00f0bcfadeb018", "url": "https://github.com/elastic/elasticsearch/commit/9c70df71ad342ef67d982f196f00f0bcfadeb018", "message": "Implement AucRoc metric for classification", "committedDate": "2020-09-09T11:12:50Z", "type": "forcePushed"}, {"oid": "95c85aa521a699ef3c8637b4492a5e79eedb3aa4", "url": "https://github.com/elastic/elasticsearch/commit/95c85aa521a699ef3c8637b4492a5e79eedb3aa4", "message": "Implement AucRoc metric for classification", "committedDate": "2020-09-09T11:59:35Z", "type": "forcePushed"}, {"oid": "1dc8a0d9ebf11f205e79a57a0463d42551e3a2ff", "url": "https://github.com/elastic/elasticsearch/commit/1dc8a0d9ebf11f205e79a57a0463d42551e3a2ff", "message": "Implement AucRoc metric for classification", "committedDate": "2020-09-09T12:47:58Z", "type": "forcePushed"}, {"oid": "65dff00209489d0fe11eee1c749a4787e5504ecb", "url": "https://github.com/elastic/elasticsearch/commit/65dff00209489d0fe11eee1c749a4787e5504ecb", "message": "Implement AucRoc metric for classification", "committedDate": "2020-09-09T12:56:07Z", "type": "forcePushed"}, {"oid": "4a44d7cb1a219ba35e772f6eb1f9e1b05b323304", "url": "https://github.com/elastic/elasticsearch/commit/4a44d7cb1a219ba35e772f6eb1f9e1b05b323304", "message": "Implement AucRoc metric for classification", "committedDate": "2020-09-09T13:05:27Z", "type": "forcePushed"}, {"oid": "7478cf9ebb1de37626aabcd3aeb87344103d19eb", "url": "https://github.com/elastic/elasticsearch/commit/7478cf9ebb1de37626aabcd3aeb87344103d19eb", "message": "Implement AucRoc metric for classification", "committedDate": "2020-09-10T05:44:18Z", "type": "forcePushed"}, {"oid": "da2577d38b028183297d4ac3fc698f378e5ac30d", "url": "https://github.com/elastic/elasticsearch/commit/da2577d38b028183297d4ac3fc698f378e5ac30d", "message": "Implement AucRoc metric for classification", "committedDate": "2020-09-10T06:33:20Z", "type": "forcePushed"}, {"oid": "efc4ec35a7be295ea34406a7986814df6591fec0", "url": "https://github.com/elastic/elasticsearch/commit/efc4ec35a7be295ea34406a7986814df6591fec0", "message": "Implement AucRoc metric for classification", "committedDate": "2020-09-10T07:05:06Z", "type": "forcePushed"}, {"oid": "f516ddfeae888d2073a4fb5d624a3503fb9e6617", "url": "https://github.com/elastic/elasticsearch/commit/f516ddfeae888d2073a4fb5d624a3503fb9e6617", "message": "Implement AucRoc metric for classification", "committedDate": "2020-09-10T07:27:47Z", "type": "forcePushed"}, {"oid": "f2c19b3a03454357a5439b86aea6868545c5d755", "url": "https://github.com/elastic/elasticsearch/commit/f2c19b3a03454357a5439b86aea6868545c5d755", "message": "Implement AucRoc metric for classification", "committedDate": "2020-09-10T07:36:12Z", "type": "forcePushed"}, {"oid": "a366fbbf67fb8cffaee3ca1327467693c0db0d49", "url": "https://github.com/elastic/elasticsearch/commit/a366fbbf67fb8cffaee3ca1327467693c0db0d49", "message": "Implement AucRoc metric for classification", "committedDate": "2020-09-10T08:25:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMyMTA0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r486321046", "bodyText": "Many of these classes return the same thing in getRequiredFields. Consider making it a default method of EvaluationMetric", "author": "davidkyle", "createdAt": "2020-09-10T13:07:57Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/evaluation/outlierdetection/AbstractConfusionMatrixMetric.java", "diffHunk": "@@ -65,13 +67,19 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n         return builder;\n     }\n \n+    @Override\n+    public Set<String> getRequiredFields() {\n+        return Set.of(EvaluationFields.ACTUAL_FIELD.getPreferredName(), EvaluationFields.PREDICTED_PROBABILITY_FIELD.getPreferredName());", "originalCommit": "0c27a1000c15439c9db0b169294ff74de4008aba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzczNzQyMA==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r487737420", "bodyText": "Many of these classes return the same thing in getRequiredFields\n\nThat's true.\n\nclassification metrics (with the exception of the new AucRoc metric) require actual and predicted\nregression metrics require actual and predicted\noutlier detection metrics require actual and predicted probability\n\n\nConsider making it a default method of EvaluationMetric\n\nThe reason I did not use default is that I didn't want to distinguish any of the analyses. I could re-introduce base abstract classes like ClassificationMetric and put the default there but I don't think it's (so far) worth it.", "author": "przemekwitek", "createdAt": "2020-09-14T08:26:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMyMTA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMyNDI2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r486324267", "bodyText": "actual field is a number or bool?\npredicted field is a number?", "author": "davidkyle", "createdAt": "2020-09-10T13:12:32Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/evaluation/outlierdetection/OutlierDetection.java", "diffHunk": "@@ -50,30 +51,33 @@ public static OutlierDetection fromXContent(XContentParser parser) {\n         return PARSER.apply(parser, null);\n     }\n \n-    static QueryBuilder actualIsTrueQuery(String actualField) {\n+    public static QueryBuilder actualIsTrueQuery(String actualField) {\n         return QueryBuilders.queryStringQuery(actualField + \": (1 OR true)\");\n     }\n \n     /**\n-     * The field where the actual class is marked up.\n-     * The value of this field is assumed to either be 1 or 0, or true or false.\n+     * The collection of fields in the index being evaluated.\n+     *   fields.getActualField() is assumed to either be 1 or 0, or true or false.\n+     *   fields.getPredictedField() is assumed to be a number in [0.0, 1.0].", "originalCommit": "c384b15ad75b6b1a2b143a8c19193b49ff4ffca0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc0MTEyMw==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r487741123", "bodyText": "actual field is a number or bool?\n\nIt can either be a number of bool (it was like this from the beginning of Evaluate API).\nHere is the query that select positive docs:\n    public static QueryBuilder actualIsTrueQuery(String actualField) {\n        return QueryBuilders.queryStringQuery(actualField + \": (1 OR true)\");\n    }\n\n\npredicted field is a number?\n\nThere was a mistake in this comment. I've just fixed it.", "author": "przemekwitek", "createdAt": "2020-09-14T08:32:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMyNDI2Nw=="}], "type": "inlineReview"}, {"oid": "bfb68f21fa26d11562d02185f0509a9e7a4abae8", "url": "https://github.com/elastic/elasticsearch/commit/bfb68f21fa26d11562d02185f0509a9e7a4abae8", "message": "Apply review comment", "committedDate": "2020-09-14T08:32:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg0OTkwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r487849909", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            registeredMetricName(Classification.NAME, AbstractAucRoc.NAME),\n          \n          \n            \n                            registeredMetricName(Classification.NAME, AucRoc.NAME),\n          \n      \n    \n    \n  \n\nI am not sure we should randomly choose AbstraceAucRoc here.", "author": "benwtrent", "createdAt": "2020-09-14T11:47:11Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/evaluation/MlEvaluationNamedXContentProvider.java", "diffHunk": "@@ -163,29 +173,27 @@ public static String registeredMetricName(String evaluationName, String metricNa\n                 RSquared::new),\n \n             // Evaluation metrics results\n-            new NamedWriteableRegistry.Entry(EvaluationMetricResult.class,\n-                registeredMetricName(OutlierDetection.NAME, AucRoc.NAME),\n-                AucRoc.Result::new),\n             new NamedWriteableRegistry.Entry(EvaluationMetricResult.class,\n                 registeredMetricName(OutlierDetection.NAME, ScoreByThresholdResult.NAME),\n                 ScoreByThresholdResult::new),\n             new NamedWriteableRegistry.Entry(EvaluationMetricResult.class,\n                 registeredMetricName(OutlierDetection.NAME, ConfusionMatrix.NAME),\n                 ConfusionMatrix.Result::new),\n+            new NamedWriteableRegistry.Entry(EvaluationMetricResult.class,\n+                registeredMetricName(Classification.NAME, AbstractAucRoc.NAME),", "originalCommit": "bfb68f21fa26d11562d02185f0509a9e7a4abae8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NzEwNw==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r488397107", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-09-15T05:37:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg0OTkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MDQ2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r487850466", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final ParseField NAME = new ParseField(\"auc_roc\");\n          \n      \n    \n    \n  \n\nI don't think this class should provide this. Either all subclasses respect it and use it (i.e. don't supply their own name), or we should provide it at all.\nThe mix between the two will only cause bugs.", "author": "benwtrent", "createdAt": "2020-09-14T11:48:20Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/evaluation/classification/AbstractAucRoc.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.dataframe.evaluation.classification;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.search.aggregations.metrics.Percentiles;\n+import org.elasticsearch.xpack.core.ml.dataframe.evaluation.EvaluationMetric;\n+import org.elasticsearch.xpack.core.ml.dataframe.evaluation.EvaluationMetricResult;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.xpack.core.ml.dataframe.evaluation.MlEvaluationNamedXContentProvider.registeredMetricName;\n+\n+/**\n+ * Area under the curve (AUC) of the receiver operating characteristic (ROC).\n+ * The ROC curve is a plot of the TPR (true positive rate) against\n+ * the FPR (false positive rate) over a varying threshold.\n+ *\n+ * This particular implementation is making use of ES aggregations\n+ * to calculate the curve. It then uses the trapezoidal rule to calculate\n+ * the AUC.\n+ *\n+ * In particular, in order to calculate the ROC, we get percentiles of TP\n+ * and FP against the predicted probability. We call those Rate-Threshold\n+ * curves. We then scan ROC points from each Rate-Threshold curve against the\n+ * other using interpolation. This gives us an approximation of the ROC curve\n+ * that has the advantage of being efficient and resilient to some edge cases.\n+ *\n+ * When this is used for multi-class classification, it will calculate the ROC\n+ * curve of each class versus the rest.\n+ */\n+public abstract class AbstractAucRoc implements EvaluationMetric {\n+\n+    public static final ParseField NAME = new ParseField(\"auc_roc\");", "originalCommit": "bfb68f21fa26d11562d02185f0509a9e7a4abae8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5ODU4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r488398587", "bodyText": "Good spot, a copy-paste error.\nI decided to use the field from AbstractAucRoc everywhere and remove the field from subclasses.", "author": "przemekwitek", "createdAt": "2020-09-15T05:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MDQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MDYwMg==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r487850602", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Override\n          \n          \n            \n                public String getName() {\n          \n          \n            \n                    return NAME.getPreferredName();\n          \n          \n            \n                }", "author": "benwtrent", "createdAt": "2020-09-14T11:48:37Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/evaluation/classification/AbstractAucRoc.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.dataframe.evaluation.classification;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.search.aggregations.metrics.Percentiles;\n+import org.elasticsearch.xpack.core.ml.dataframe.evaluation.EvaluationMetric;\n+import org.elasticsearch.xpack.core.ml.dataframe.evaluation.EvaluationMetricResult;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.xpack.core.ml.dataframe.evaluation.MlEvaluationNamedXContentProvider.registeredMetricName;\n+\n+/**\n+ * Area under the curve (AUC) of the receiver operating characteristic (ROC).\n+ * The ROC curve is a plot of the TPR (true positive rate) against\n+ * the FPR (false positive rate) over a varying threshold.\n+ *\n+ * This particular implementation is making use of ES aggregations\n+ * to calculate the curve. It then uses the trapezoidal rule to calculate\n+ * the AUC.\n+ *\n+ * In particular, in order to calculate the ROC, we get percentiles of TP\n+ * and FP against the predicted probability. We call those Rate-Threshold\n+ * curves. We then scan ROC points from each Rate-Threshold curve against the\n+ * other using interpolation. This gives us an approximation of the ROC curve\n+ * that has the advantage of being efficient and resilient to some edge cases.\n+ *\n+ * When this is used for multi-class classification, it will calculate the ROC\n+ * curve of each class versus the rest.\n+ */\n+public abstract class AbstractAucRoc implements EvaluationMetric {\n+\n+    public static final ParseField NAME = new ParseField(\"auc_roc\");\n+\n+    protected AbstractAucRoc() {}\n+\n+    @Override\n+    public String getName() {\n+        return NAME.getPreferredName();\n+    }\n+", "originalCommit": "bfb68f21fa26d11562d02185f0509a9e7a4abae8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5ODg3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r488398876", "bodyText": "I've left this method in the base class but removed it from subclasses.", "author": "przemekwitek", "createdAt": "2020-09-15T05:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MDYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MTgyMg==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r487851822", "bodyText": "As mentioned in the comment on AbstractAucRoc.\nHaving both supply this parsefield name is going to lead to confusion. I think a cleaner abstraction would be that only one supplies the writable and xcontent names.\nI could go either way it being only supplied by the abstract class or only by the concrete class.", "author": "benwtrent", "createdAt": "2020-09-14T11:50:55Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/evaluation/classification/AucRoc.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.dataframe.evaluation.classification;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.index.query.QueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.aggregations.AggregationBuilder;\n+import org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.elasticsearch.search.aggregations.Aggregations;\n+import org.elasticsearch.search.aggregations.PipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.filter.Filter;\n+import org.elasticsearch.search.aggregations.bucket.nested.Nested;\n+import org.elasticsearch.search.aggregations.metrics.Percentiles;\n+import org.elasticsearch.xpack.core.ml.dataframe.evaluation.EvaluationFields;\n+import org.elasticsearch.xpack.core.ml.dataframe.evaluation.EvaluationMetricResult;\n+import org.elasticsearch.xpack.core.ml.dataframe.evaluation.EvaluationParameters;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.xpack.core.ml.dataframe.evaluation.MlEvaluationNamedXContentProvider.registeredMetricName;\n+\n+/**\n+ * Area under the curve (AUC) of the receiver operating characteristic (ROC).\n+ * The ROC curve is a plot of the TPR (true positive rate) against\n+ * the FPR (false positive rate) over a varying threshold.\n+ *\n+ * This particular implementation is making use of ES aggregations\n+ * to calculate the curve. It then uses the trapezoidal rule to calculate\n+ * the AUC.\n+ *\n+ * In particular, in order to calculate the ROC, we get percentiles of TP\n+ * and FP against the predicted probability. We call those Rate-Threshold\n+ * curves. We then scan ROC points from each Rate-Threshold curve against the\n+ * other using interpolation. This gives us an approximation of the ROC curve\n+ * that has the advantage of being efficient and resilient to some edge cases.\n+ *\n+ * When this is used for multi-class classification, it will calculate the ROC\n+ * curve of each class versus the rest.\n+ */\n+public class AucRoc extends AbstractAucRoc {\n+\n+    public static final ParseField NAME = new ParseField(\"auc_roc\");", "originalCommit": "bfb68f21fa26d11562d02185f0509a9e7a4abae8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5OTg5MA==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r488399890", "bodyText": "I could go either way it being only supplied by the abstract class or only by the concrete class.\n\nAgree, I chose the former approach (supplied by the abstract class).", "author": "przemekwitek", "createdAt": "2020-09-15T05:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MTgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MzQ1NA==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r487853454", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (out.getVersion().onOrAfter(Version.CURRENT)) {\n          \n          \n            \n                    if (out.getVersion().onOrAfter(Version.V_8_0_0)) {", "author": "benwtrent", "createdAt": "2020-09-14T11:54:07Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/evaluation/classification/Classification.java", "diffHunk": "@@ -109,17 +154,34 @@ public String getWriteableName() {\n \n     @Override\n     public void writeTo(StreamOutput out) throws IOException {\n-        out.writeString(actualField);\n-        out.writeString(predictedField);\n+        out.writeString(fields.getActualField());\n+        if (out.getVersion().onOrAfter(Version.CURRENT)) {", "originalCommit": "bfb68f21fa26d11562d02185f0509a9e7a4abae8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQyNzY3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r488427676", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-09-15T06:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MzQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MzUxOA==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r487853518", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (in.getVersion().onOrAfter(Version.CURRENT)) {\n          \n          \n            \n                    if (in.getVersion().onOrAfter(Version.V_8_0_0)) {", "author": "benwtrent", "createdAt": "2020-09-14T11:54:14Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/evaluation/classification/Classification.java", "diffHunk": "@@ -77,8 +122,13 @@ public Classification(String actualField, String predictedField, @Nullable List<\n     }\n \n     public Classification(StreamInput in) throws IOException {\n-        this.actualField = in.readString();\n-        this.predictedField = in.readString();\n+        if (in.getVersion().onOrAfter(Version.CURRENT)) {", "originalCommit": "bfb68f21fa26d11562d02185f0509a9e7a4abae8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQyNzYzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r488427635", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-09-15T06:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MzUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1NDI5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r487854296", "bodyText": "See previous comment around abstract writable names vs concrete ones.", "author": "benwtrent", "createdAt": "2020-09-14T11:55:45Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/evaluation/outlierdetection/AucRoc.java", "diffHunk": "@@ -58,30 +53,29 @@\n  * When this is used for multi-class classification, it will calculate the ROC\n  * curve of each class versus the rest.\n  */\n-public class AucRoc implements EvaluationMetric {\n+public class AucRoc extends AbstractAucRoc {\n \n     public static final ParseField NAME = new ParseField(\"auc_roc\");", "originalCommit": "bfb68f21fa26d11562d02185f0509a9e7a4abae8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQyNzc5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r488427799", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-09-15T06:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1NDI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1NzIyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r487857225", "bodyText": "I understand that removing the abstract auc_roc NAME might cause issues here. But the subclasses could supply a concrete version of these results class or the abstract is the thing that supplies the serialization names.", "author": "benwtrent", "createdAt": "2020-09-14T12:01:17Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/evaluation/classification/AbstractAucRoc.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.dataframe.evaluation.classification;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.search.aggregations.metrics.Percentiles;\n+import org.elasticsearch.xpack.core.ml.dataframe.evaluation.EvaluationMetric;\n+import org.elasticsearch.xpack.core.ml.dataframe.evaluation.EvaluationMetricResult;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.xpack.core.ml.dataframe.evaluation.MlEvaluationNamedXContentProvider.registeredMetricName;\n+\n+/**\n+ * Area under the curve (AUC) of the receiver operating characteristic (ROC).\n+ * The ROC curve is a plot of the TPR (true positive rate) against\n+ * the FPR (false positive rate) over a varying threshold.\n+ *\n+ * This particular implementation is making use of ES aggregations\n+ * to calculate the curve. It then uses the trapezoidal rule to calculate\n+ * the AUC.\n+ *\n+ * In particular, in order to calculate the ROC, we get percentiles of TP\n+ * and FP against the predicted probability. We call those Rate-Threshold\n+ * curves. We then scan ROC points from each Rate-Threshold curve against the\n+ * other using interpolation. This gives us an approximation of the ROC curve\n+ * that has the advantage of being efficient and resilient to some edge cases.\n+ *\n+ * When this is used for multi-class classification, it will calculate the ROC\n+ * curve of each class versus the rest.\n+ */\n+public abstract class AbstractAucRoc implements EvaluationMetric {\n+\n+    public static final ParseField NAME = new ParseField(\"auc_roc\");\n+\n+    protected AbstractAucRoc() {}\n+\n+    @Override\n+    public String getName() {\n+        return NAME.getPreferredName();\n+    }\n+\n+    protected static double[] percentilesArray(Percentiles percentiles, String errorIfUndefined) {\n+        double[] result = new double[99];\n+        percentiles.forEach(percentile -> {\n+            if (Double.isNaN(percentile.getValue())) {\n+                throw ExceptionsHelper.badRequestException(errorIfUndefined);\n+            }\n+            result[((int) percentile.getPercent()) - 1] = percentile.getValue();\n+        });\n+        return result;\n+    }\n+\n+    /**\n+     * Visible for testing\n+     */\n+    protected static List<AucRocPoint> buildAucRocCurve(double[] tpPercentiles, double[] fpPercentiles) {\n+        assert tpPercentiles.length == fpPercentiles.length;\n+        assert tpPercentiles.length == 99;\n+\n+        List<AucRocPoint> aucRocCurve = new ArrayList<>();\n+        aucRocCurve.add(new AucRocPoint(0.0, 0.0, 1.0));\n+        aucRocCurve.add(new AucRocPoint(1.0, 1.0, 0.0));\n+        RateThresholdCurve tpCurve = new RateThresholdCurve(tpPercentiles, true);\n+        RateThresholdCurve fpCurve = new RateThresholdCurve(fpPercentiles, false);\n+        aucRocCurve.addAll(tpCurve.scanPoints(fpCurve));\n+        aucRocCurve.addAll(fpCurve.scanPoints(tpCurve));\n+        Collections.sort(aucRocCurve);\n+        return aucRocCurve;\n+    }\n+\n+    /**\n+     * Visible for testing\n+     */\n+    protected static double calculateAucScore(List<AucRocPoint> rocCurve) {\n+        // Calculates AUC based on the trapezoid rule\n+        double aucRoc = 0.0;\n+        for (int i = 1; i < rocCurve.size(); i++) {\n+            AucRocPoint left = rocCurve.get(i - 1);\n+            AucRocPoint right = rocCurve.get(i);\n+            aucRoc += (right.fpr - left.fpr) * (right.tpr + left.tpr) / 2;\n+        }\n+        return aucRoc;\n+    }\n+\n+    private static class RateThresholdCurve {\n+\n+        private final double[] percentiles;\n+        private final boolean isTp;\n+\n+        private RateThresholdCurve(double[] percentiles, boolean isTp) {\n+            this.percentiles = percentiles;\n+            this.isTp = isTp;\n+        }\n+\n+        private double getRate(int index) {\n+            return 1 - 0.01 * (index + 1);\n+        }\n+\n+        private double getThreshold(int index) {\n+            return percentiles[index];\n+        }\n+\n+        private double interpolateRate(double threshold) {\n+            int binarySearchResult = Arrays.binarySearch(percentiles, threshold);\n+            if (binarySearchResult >= 0) {\n+                return getRate(binarySearchResult);\n+            } else {\n+                int right = (binarySearchResult * -1) -1;\n+                int left = right - 1;\n+                if (right >= percentiles.length) {\n+                    return 0.0;\n+                } else if (left < 0) {\n+                    return 1.0;\n+                } else {\n+                    double rightRate = getRate(right);\n+                    double leftRate = getRate(left);\n+                    return interpolate(threshold, percentiles[left], leftRate, percentiles[right], rightRate);\n+                }\n+            }\n+        }\n+\n+        private List<AucRocPoint> scanPoints(RateThresholdCurve againstCurve) {\n+            List<AucRocPoint> points = new ArrayList<>();\n+            for (int index = 0; index < percentiles.length; index++) {\n+                double rate = getRate(index);\n+                double scannedThreshold = getThreshold(index);\n+                double againstRate = againstCurve.interpolateRate(scannedThreshold);\n+                AucRocPoint point;\n+                if (isTp) {\n+                    point = new AucRocPoint(rate, againstRate, scannedThreshold);\n+                } else {\n+                    point = new AucRocPoint(againstRate, rate, scannedThreshold);\n+                }\n+                points.add(point);\n+            }\n+            return points;\n+        }\n+    }\n+\n+    public static final class AucRocPoint implements Comparable<AucRocPoint>, ToXContentObject, Writeable {\n+\n+        private final double tpr;\n+        private final double fpr;\n+        private final double threshold;\n+\n+        AucRocPoint(double tpr, double fpr, double threshold) {\n+            this.tpr = tpr;\n+            this.fpr = fpr;\n+            this.threshold = threshold;\n+        }\n+\n+        private AucRocPoint(StreamInput in) throws IOException {\n+            this.tpr = in.readDouble();\n+            this.fpr = in.readDouble();\n+            this.threshold = in.readDouble();\n+        }\n+\n+        @Override\n+        public int compareTo(AucRocPoint o) {\n+            return Comparator.comparingDouble((AucRocPoint p) -> p.threshold).reversed()\n+                .thenComparing(p -> p.fpr)\n+                .thenComparing(p -> p.tpr)\n+                .compare(this, o);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeDouble(tpr);\n+            out.writeDouble(fpr);\n+            out.writeDouble(threshold);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(\"tpr\", tpr);\n+            builder.field(\"fpr\", fpr);\n+            builder.field(\"threshold\", threshold);\n+            builder.endObject();\n+            return builder;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            AucRocPoint that = (AucRocPoint) o;\n+            return tpr == that.tpr\n+                && fpr == that.fpr\n+                && threshold == that.threshold;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(tpr, fpr, threshold);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return Strings.toString(this);\n+        }\n+    }\n+\n+    private static double interpolate(double x, double x1, double y1, double x2, double y2) {\n+        return y1 + (x - x1) * (y2 - y1) / (x2 - x1);\n+    }\n+\n+    public static class Result implements EvaluationMetricResult {\n+\n+        private final double score;\n+        private final List<AucRocPoint> curve;\n+\n+        public Result(double score, List<AucRocPoint> curve) {\n+            this.score = score;\n+            this.curve = Objects.requireNonNull(curve);\n+        }\n+\n+        public Result(StreamInput in) throws IOException {\n+            this.score = in.readDouble();\n+            this.curve = in.readList(AucRocPoint::new);\n+        }\n+\n+        public double getScore() {\n+            return score;\n+        }\n+\n+        public List<AucRocPoint> getCurve() {\n+            return Collections.unmodifiableList(curve);\n+        }\n+\n+        @Override\n+        public String getWriteableName() {\n+            return registeredMetricName(Classification.NAME, NAME);\n+        }", "originalCommit": "bfb68f21fa26d11562d02185f0509a9e7a4abae8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQyODkzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r488428931", "bodyText": "I left NAME field and  getName method in the base class.\nI would leave the classification prefix in the result though as classification is where auc_roc metric really belongs (outlier_detection can be viewed as just one kind of classification  task).", "author": "przemekwitek", "createdAt": "2020-09-15T06:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1NzIyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3MzYxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r487873619", "bodyText": "Let's not use Map.of as it doesn't backport well to 7.x", "author": "dimitris-athanasiou", "createdAt": "2020-09-14T12:30:28Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/analyses/Classification.java", "diffHunk": "@@ -391,7 +391,11 @@ public boolean supportsCategoricalFields() {\n             return additionalProperties;\n         }\n         additionalProperties.put(resultsFieldName + \".\" + predictionFieldName, dependentVariableMapping);\n-        additionalProperties.put(resultsFieldName + \".top_classes.class_name\", dependentVariableMapping);\n+        additionalProperties.put(\n+            resultsFieldName + \".top_classes\",\n+            Map.of(", "originalCommit": "bfb68f21fa26d11562d02185f0509a9e7a4abae8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQzMDM4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r488430383", "bodyText": "Done.\nI've also changed Set.of to Sets.newHashSet.", "author": "przemekwitek", "createdAt": "2020-09-15T06:58:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3MzYxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NDIzOA==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r487874238", "bodyText": "to be complete, shall we also include mappings for the probability field?", "author": "dimitris-athanasiou", "createdAt": "2020-09-14T12:31:31Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/analyses/Classification.java", "diffHunk": "@@ -391,7 +391,11 @@ public boolean supportsCategoricalFields() {\n             return additionalProperties;\n         }\n         additionalProperties.put(resultsFieldName + \".\" + predictionFieldName, dependentVariableMapping);\n-        additionalProperties.put(resultsFieldName + \".top_classes.class_name\", dependentVariableMapping);\n+        additionalProperties.put(\n+            resultsFieldName + \".top_classes\",\n+            Map.of(\n+                \"type\", ObjectMapper.NESTED_CONTENT_TYPE,\n+                \"properties\", Map.of(\"class_name\", dependentVariableMapping)));", "originalCommit": "bfb68f21fa26d11562d02185f0509a9e7a4abae8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQzNTg5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r488435897", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-09-15T07:09:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NDIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3ODY4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r487878682", "bodyText": "extract in a method checkRequiredFieldsAreSet or similar?", "author": "dimitris-athanasiou", "createdAt": "2020-09-14T12:38:54Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/evaluation/Evaluation.java", "diffHunk": "@@ -59,6 +57,22 @@\n             throw ExceptionsHelper.badRequestException(\"[{}] must have one or more metrics\", getName());\n         }\n         Collections.sort(metrics, Comparator.comparing(EvaluationMetric::getName));\n+        for (Tuple<String, String> requiredField : getFields().listAll()) {", "originalCommit": "bfb68f21fa26d11562d02185f0509a9e7a4abae8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQ1MTg2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r488451867", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-09-15T07:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3ODY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4MjgxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r487882819", "bodyText": "Could we have a method List<QueryBuilder> EvaluationFields.buildExistsQueries()? Would that allow us to delete the explicit getters from EvaluationFields?", "author": "dimitris-athanasiou", "createdAt": "2020-09-14T12:45:34Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/evaluation/Evaluation.java", "diffHunk": "@@ -70,16 +84,46 @@ default SearchSourceBuilder buildSearch(EvaluationParameters parameters, QueryBu\n         Objects.requireNonNull(userProvidedQueryBuilder);\n         BoolQueryBuilder boolQuery =\n             QueryBuilders.boolQuery()\n-                // Verify existence of required fields\n-                .filter(QueryBuilders.existsQuery(getActualField()))\n-                .filter(QueryBuilders.existsQuery(getPredictedField()))\n-                // Apply user-provided query\n-                .filter(userProvidedQueryBuilder);\n+                // Verify existence of the actual field (which is always required)\n+                .filter(QueryBuilders.existsQuery(getFields().getActualField()));\n+        if (getFields().getPredictedField() != null) {", "originalCommit": "bfb68f21fa26d11562d02185f0509a9e7a4abae8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQ1NDM1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r488454353", "bodyText": "Could we have a method List EvaluationFields.buildExistsQueries()?\n\nWe could. I don't see much value in doing so though. EvaluationFields is a simple placeholder without any logic and there are benefits (simplicity) if it stays like this.\n\nWould that allow us to delete the explicit getters from EvaluationFields?\n\nNo, the individual fields are still accessed in aggs methods in metrics so that metrics can build their aggregations.", "author": "przemekwitek", "createdAt": "2020-09-15T07:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4MjgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MTQ1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r487891459", "bodyText": "I wonder if we need this validation. We already validate that all fields required by the metrics are specified. Don't those two overlap?", "author": "dimitris-athanasiou", "createdAt": "2020-09-14T12:58:27Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/evaluation/classification/Classification.java", "diffHunk": "@@ -50,25 +61,59 @@ public static Classification fromXContent(XContentParser parser) {\n     }\n \n     /**\n-     * The field containing the actual value\n-     * The value of this field is assumed to be categorical\n+     * The collection of fields in the index being evaluated.\n+     *   fields.getActualField() is assumed to be a ground truth label.\n+     *   fields.getPredictedField() is assumed to be a predicted label.\n+     *   fields.getPredictedClassNameField() is assumed to be nested under fields.getResultsNestedField().\n+     *   fields.getPredictedProbabilityField() is assumed to be nested under fields.getResultsNestedField().\n      */\n-    private final String actualField;\n-\n-    /**\n-     * The field containing the predicted value\n-     * The value of this field is assumed to be categorical\n-     */\n-    private final String predictedField;\n+    private final EvaluationFields fields;\n \n     /**\n      * The list of metrics to calculate\n      */\n     private final List<EvaluationMetric> metrics;\n \n-    public Classification(String actualField, String predictedField, @Nullable List<EvaluationMetric> metrics) {\n-        this.actualField = ExceptionsHelper.requireNonNull(actualField, ACTUAL_FIELD);\n-        this.predictedField = ExceptionsHelper.requireNonNull(predictedField, PREDICTED_FIELD);\n+    public Classification(String actualField,\n+                          @Nullable String predictedField,\n+                          @Nullable String resultsNestedField,\n+                          @Nullable String predictedClassNameField,\n+                          @Nullable String predictedProbabilityField,\n+                          @Nullable List<EvaluationMetric> metrics) {\n+        // If any of these fields is specified, all of them must be specified.\n+        if (resultsNestedField != null || predictedClassNameField != null || predictedProbabilityField != null) {", "originalCommit": "bfb68f21fa26d11562d02185f0509a9e7a4abae8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQwMzkzNg==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r488403936", "bodyText": "This validation is independent of metrics that are provided by metrics argument.\nMy reasoning here was that for Classification this set of fields (resultsNestedField, predictedClassNameField, predictedProbabilityField) only makes sense if all three are provided. But you may be right, such a strict check is not needed, and when there is no auc_roc in metrics, we shouldn't care which of these three fields are set.\nI've removed this validation.", "author": "przemekwitek", "createdAt": "2020-09-15T05:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MTQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MjkzOA==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r487892938", "bodyText": "I think we should explain here that this calculates AUC ROC for a specific class. Plus, we need to think where we explain what happens to the docs that don't have the target class in the top classes.", "author": "dimitris-athanasiou", "createdAt": "2020-09-14T13:00:39Z", "path": "docs/reference/ml/df-analytics/apis/evaluate-dfanalytics.asciidoc", "diffHunk": "@@ -164,6 +164,11 @@ belongs.\n   `accuracy`:::\n     (Optional, object) Accuracy of predictions (per-class and overall).\n \n+  `auc_roc`:::\n+    (Optional, object) The AUC ROC (area under the curve of the receiver\n+    operating characteristic) score and optionally the curve. Default value is", "originalCommit": "bfb68f21fa26d11562d02185f0509a9e7a4abae8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQ2MTczMw==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r488461733", "bodyText": "I think we should explain here that this calculates AUC ROC for a specific class.\n\nDone. Although @lcawl or @szabosteve may want to take a look at it. Do you think auc_roc now deserves a separate section (It has two fields now: class_name and include_curve).\n\nPlus, we need to think where we explain what happens to the docs that don't have the target class in the top classes.\n\nAgree. This is still on my list. Let me experiment with this case a little bit.", "author": "przemekwitek", "createdAt": "2020-09-15T07:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MjkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQ4OTgwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r488489809", "bodyText": "@przemekwitek Yes, I think it is a good idea to haveclass_name and include_curve as separated items under auc_roc.", "author": "szabosteve", "createdAt": "2020-09-15T08:38:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MjkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYyNTEwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r488625101", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-09-15T12:27:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MjkzOA=="}], "type": "inlineReview"}, {"oid": "a42677b64ce8a8999d021ba8050842fcfbdb25bc", "url": "https://github.com/elastic/elasticsearch/commit/a42677b64ce8a8999d021ba8050842fcfbdb25bc", "message": "Apply review comments", "committedDate": "2020-09-15T08:23:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQ4MzE3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r488483175", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                It is calculated for a particular class X (provided as \"class_name\")\n          \n          \n            \n                It is calculated for a specific class (provided as \"class_name\")\n          \n      \n    \n    \n  \n\nSmall change that might simplify the sentence.", "author": "szabosteve", "createdAt": "2020-09-15T08:28:21Z", "path": "docs/reference/ml/df-analytics/apis/evaluate-dfanalytics.asciidoc", "diffHunk": "@@ -154,16 +154,36 @@ belongs.\n   The data type of this field must be categorical.\n   \n `predicted_field`::\n-  (Required, string) The field in the `index` that contains the predicted value, \n+  (Optional, string) The field in the `index` which contains the predicted value,\n   in other words the results of the {classanalysis}.\n \n+`results_nested_field`::\n+  (Optional, string) The field of the `index` which is a nested array of results.\n+\n+`predicted_class_name_field`::\n+  (Optional, string) The field of the `index` which contains the predicted class name.\n+  Must be nested under `results_nested_field`.\n+\n+`predicted_probability_field`::\n+  (Optional, string) The field of the `index` which contains the probability of\n+  whether the item belongs to the class in question or not.\n+  Must be nested under `results_nested_field`.\n+\n `metrics`::\n   (Optional, object) Specifies the metrics that are used for the evaluation.\n   Available metrics:\n \n   `accuracy`:::\n     (Optional, object) Accuracy of predictions (per-class and overall).\n \n+  `auc_roc`:::\n+    (Optional, object) The AUC ROC (area under the curve of the receiver\n+    operating characteristic) score and optionally the curve.\n+    It is calculated for a particular class X (provided as \"class_name\")", "originalCommit": "a42677b64ce8a8999d021ba8050842fcfbdb25bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYxNjIyOA==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r488616228", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-09-15T12:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQ4MzE3NQ=="}], "type": "inlineReview"}, {"oid": "b5f7305d71633dd7fa89f891f64a3600088a50c2", "url": "https://github.com/elastic/elasticsearch/commit/b5f7305d71633dd7fa89f891f64a3600088a50c2", "message": "Apply review comments", "committedDate": "2020-09-15T11:20:28Z", "type": "forcePushed"}, {"oid": "eabaefa39259f57a7b6a49011b53fef694069218", "url": "https://github.com/elastic/elasticsearch/commit/eabaefa39259f57a7b6a49011b53fef694069218", "message": "Fix compile error", "committedDate": "2020-09-15T12:11:21Z", "type": "forcePushed"}, {"oid": "fbbf3a61bc5ee88f18f99ddb4926c39e8abea68a", "url": "https://github.com/elastic/elasticsearch/commit/fbbf3a61bc5ee88f18f99ddb4926c39e8abea68a", "message": "Fix org.elasticsearch.client.RestHighLevelClientTests.testProvidedNamedXContents after merge", "committedDate": "2020-09-17T13:46:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxMDY1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r491210655", "bodyText": "predicted_class_field\n\nWe can fix this in a subsequent PR if necessary, but this option doesn't appear in the right order alphabetically.", "author": "lcawl", "createdAt": "2020-09-18T21:56:51Z", "path": "docs/reference/ml/df-analytics/apis/evaluate-dfanalytics.asciidoc", "diffHunk": "@@ -154,16 +154,41 @@ belongs.\n   The data type of this field must be categorical.\n   \n `predicted_field`::\n-  (Required, string) The field in the `index` that contains the predicted value, \n+  (Optional, string) The field in the `index` which contains the predicted value,\n   in other words the results of the {classanalysis}.\n \n+`predicted_class_field`::", "originalCommit": "fbbf3a61bc5ee88f18f99ddb4926c39e8abea68a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg4MDM0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r491880345", "bodyText": "Done.\nBut this makes me think how will the user understand the difference between predicted_field and predicted_class_field. The former is non-nested (and used for precision, recall, etc.) while the latter is nested (and used for AucRoc).\nDo you have an idea on how to express the difference clearly?", "author": "przemekwitek", "createdAt": "2020-09-21T08:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxMDY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxMzExMg==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r491213112", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  (i.e. in the auc_roc.doc_count field).\n          \n          \n            \n                  (`auc_roc.doc_count` field).", "author": "lcawl", "createdAt": "2020-09-18T22:00:51Z", "path": "docs/reference/ml/df-analytics/apis/evaluate-dfanalytics.asciidoc", "diffHunk": "@@ -154,16 +154,41 @@ belongs.\n   The data type of this field must be categorical.\n   \n `predicted_field`::\n-  (Required, string) The field in the `index` that contains the predicted value, \n+  (Optional, string) The field in the `index` which contains the predicted value,\n   in other words the results of the {classanalysis}.\n \n+`predicted_class_field`::\n+  (Optional, string) The field of the `index` which contains the predicted class name.\n+\n+`predicted_probability_field`::\n+  (Optional, string) The field of the `index` which contains the probability of\n+  whether the item belongs to the class in question or not.\n+\n `metrics`::\n   (Optional, object) Specifies the metrics that are used for the evaluation.\n   Available metrics:\n \n   `accuracy`:::\n     (Optional, object) Accuracy of predictions (per-class and overall).\n \n+  `auc_roc`:::\n+    (Optional, object) The AUC ROC (area under the curve of the receiver\n+    operating characteristic) score and optionally the curve.\n+    It is calculated for a specific class (provided as \"class_name\")\n+    treated as positive.\n+\n+    `class_name`::::\n+      (Required, string) Name of the only class that will be treated as\n+      positive during AUC ROC calculation. Other classes will be treated as\n+      negative (\"one-vs-all\" strategy). Documents which do not have `class_name`\n+      in the list of their top classes will not be taken into account for evaluation.\n+      The number of documents taken into account is returned in the evaluation result\n+      (i.e. in the auc_roc.doc_count field).", "originalCommit": "fbbf3a61bc5ee88f18f99ddb4926c39e8abea68a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg4MDA3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/60502#discussion_r491880071", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-09-21T08:47:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxMzExMg=="}], "type": "inlineReview"}, {"oid": "ced0818215269828d8198d641ad5d91bd2d852ab", "url": "https://github.com/elastic/elasticsearch/commit/ced0818215269828d8198d641ad5d91bd2d852ab", "message": "Apply review comments.", "committedDate": "2020-09-21T08:48:51Z", "type": "forcePushed"}, {"oid": "fe85e5c33eacaff060d2dc221e09ed11b93f30a9", "url": "https://github.com/elastic/elasticsearch/commit/fe85e5c33eacaff060d2dc221e09ed11b93f30a9", "message": "Add top_classes_field to the Classification evaluation.", "committedDate": "2020-09-28T09:28:52Z", "type": "forcePushed"}, {"oid": "aeba04e99449a6be5eb6e79970815c21b373bdd5", "url": "https://github.com/elastic/elasticsearch/commit/aeba04e99449a6be5eb6e79970815c21b373bdd5", "message": "Implement AucRoc metric for classification", "committedDate": "2020-09-30T06:03:20Z", "type": "commit"}, {"oid": "243576e8403e4c7daa301359d2e360d4a1992073", "url": "https://github.com/elastic/elasticsearch/commit/243576e8403e4c7daa301359d2e360d4a1992073", "message": "Revert HLRC changes", "committedDate": "2020-09-30T06:03:20Z", "type": "commit"}, {"oid": "8a1b503336a6e3e3ef3b8f006ba9df9ee43f1e3f", "url": "https://github.com/elastic/elasticsearch/commit/8a1b503336a6e3e3ef3b8f006ba9df9ee43f1e3f", "message": "Revert HLRC changes", "committedDate": "2020-09-30T06:03:20Z", "type": "commit"}, {"oid": "6fd073a5b33f75ff966bae63e3e784b2828fb709", "url": "https://github.com/elastic/elasticsearch/commit/6fd073a5b33f75ff966bae63e3e784b2828fb709", "message": "Revert HLRC changes", "committedDate": "2020-09-30T06:03:20Z", "type": "commit"}, {"oid": "f0d6317d320c9b560fc409595c0c8d1fbdbc7129", "url": "https://github.com/elastic/elasticsearch/commit/f0d6317d320c9b560fc409595c0c8d1fbdbc7129", "message": "Use ignoreUnmapped flag on nested queries so that the search doesn't fail when the nested field is absent;\nAdd validation that requires that either all the nested fields are specified or none of them are;", "committedDate": "2020-09-30T06:03:20Z", "type": "commit"}, {"oid": "4673c74586d3b429c92e10cc0e3deb1787b18275", "url": "https://github.com/elastic/elasticsearch/commit/4673c74586d3b429c92e10cc0e3deb1787b18275", "message": "Apply review comment", "committedDate": "2020-09-30T06:03:20Z", "type": "commit"}, {"oid": "ea136d718126680ce656fd920f6353a9cd4b1cb9", "url": "https://github.com/elastic/elasticsearch/commit/ea136d718126680ce656fd920f6353a9cd4b1cb9", "message": "Apply review comments", "committedDate": "2020-09-30T06:03:20Z", "type": "commit"}, {"oid": "126cb7d342108580f2af1e50bcd138964c7603a6", "url": "https://github.com/elastic/elasticsearch/commit/126cb7d342108580f2af1e50bcd138964c7603a6", "message": "Fix compile error", "committedDate": "2020-09-30T06:03:21Z", "type": "commit"}, {"oid": "147398f8381d32f9cc1e6f9d47435509615ba28a", "url": "https://github.com/elastic/elasticsearch/commit/147398f8381d32f9cc1e6f9d47435509615ba28a", "message": "Apply docs-related review comments", "committedDate": "2020-09-30T06:03:21Z", "type": "commit"}, {"oid": "21efd55ef18b05f31e5161e553bfae7f0c096d5b", "url": "https://github.com/elastic/elasticsearch/commit/21efd55ef18b05f31e5161e553bfae7f0c096d5b", "message": "Fix bug in Classification::getExplicitlyMappedFields method", "committedDate": "2020-09-30T06:03:21Z", "type": "commit"}, {"oid": "0aff0a887a1e5863043253d5a1098f6b3cada935", "url": "https://github.com/elastic/elasticsearch/commit/0aff0a887a1e5863043253d5a1098f6b3cada935", "message": "Add doc_count field; Make exception messages more detailed;", "committedDate": "2020-09-30T06:03:21Z", "type": "commit"}, {"oid": "18b742897b02fbcca2b0a19a8ea352b81ff64869", "url": "https://github.com/elastic/elasticsearch/commit/18b742897b02fbcca2b0a19a8ea352b81ff64869", "message": "Adapt outlier_detection.AucRoc to have the same error messages as classification.AucRoc", "committedDate": "2020-09-30T06:03:21Z", "type": "commit"}, {"oid": "782e7d2d01654b6bf1067b4dde67d93e96e479e9", "url": "https://github.com/elastic/elasticsearch/commit/782e7d2d01654b6bf1067b4dde67d93e96e479e9", "message": "Fix error message", "committedDate": "2020-09-30T06:03:21Z", "type": "commit"}, {"oid": "40ac4e5af63afd02cb12ac0706e63c3611723f94", "url": "https://github.com/elastic/elasticsearch/commit/40ac4e5af63afd02cb12ac0706e63c3611723f94", "message": "Rename predicted_class_name_field to predicted_class_field", "committedDate": "2020-09-30T06:03:21Z", "type": "commit"}, {"oid": "0f5b82e8749a53d42419d713d3422293b2454414", "url": "https://github.com/elastic/elasticsearch/commit/0f5b82e8749a53d42419d713d3422293b2454414", "message": "Remove redundant evaluation.classification.results_nested_field", "committedDate": "2020-09-30T06:03:21Z", "type": "commit"}, {"oid": "f831d9f1d5855a999ed786d6c97ad90f9022318c", "url": "https://github.com/elastic/elasticsearch/commit/f831d9f1d5855a999ed786d6c97ad90f9022318c", "message": "Fix ml-with-security yaml tests", "committedDate": "2020-09-30T06:03:21Z", "type": "commit"}, {"oid": "c0e6ca5f891f592d682ec9ad1a99032a5d9fad7a", "url": "https://github.com/elastic/elasticsearch/commit/c0e6ca5f891f592d682ec9ad1a99032a5d9fad7a", "message": "Apply default values for predicted_class_field and predicted_probability_field", "committedDate": "2020-09-30T06:03:22Z", "type": "commit"}, {"oid": "aa082183d03b6c7be4daf47945c6963849ea2216", "url": "https://github.com/elastic/elasticsearch/commit/aa082183d03b6c7be4daf47945c6963849ea2216", "message": "Apply review comment", "committedDate": "2020-09-30T06:03:22Z", "type": "commit"}, {"oid": "6d707184e94f39c0a6142596a7eb8103bcf1e290", "url": "https://github.com/elastic/elasticsearch/commit/6d707184e94f39c0a6142596a7eb8103bcf1e290", "message": "Fix org.elasticsearch.client.RestHighLevelClientTests.testProvidedNamedXContents after merge", "committedDate": "2020-09-30T06:03:22Z", "type": "commit"}, {"oid": "634eb2e4871d722bcc9f44952d250bb37c8713e1", "url": "https://github.com/elastic/elasticsearch/commit/634eb2e4871d722bcc9f44952d250bb37c8713e1", "message": "Apply review comments.", "committedDate": "2020-09-30T06:03:22Z", "type": "commit"}, {"oid": "f99bad1760b59e6dcc35507a921c82bbd4c92527", "url": "https://github.com/elastic/elasticsearch/commit/f99bad1760b59e6dcc35507a921c82bbd4c92527", "message": "Add top_classes_field to the Classification evaluation.", "committedDate": "2020-09-30T06:03:22Z", "type": "commit"}, {"oid": "f99bad1760b59e6dcc35507a921c82bbd4c92527", "url": "https://github.com/elastic/elasticsearch/commit/f99bad1760b59e6dcc35507a921c82bbd4c92527", "message": "Add top_classes_field to the Classification evaluation.", "committedDate": "2020-09-30T06:03:22Z", "type": "forcePushed"}]}