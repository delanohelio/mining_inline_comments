{"pr_number": 65843, "pr_title": "Move RestClusterStateAction Response Serialization to Management Pool", "pr_createdAt": "2020-12-03T18:16:57Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65843", "timeline": [{"oid": "b05cbb7fc3aa6c303658d7851faa0e68892009ec", "url": "https://github.com/elastic/elasticsearch/commit/b05cbb7fc3aa6c303658d7851faa0e68892009ec", "message": "Move TransportClusterStateAction to Management Pool\n\nResponding with the full cluster state implies serializing the full cluster\nstate on the IO thread. In case of very large cluster states this serialization\nis not a trivial action and can take multiple seconds so it shouldn't be happening\non a transport thread.", "committedDate": "2020-12-03T18:10:57Z", "type": "commit"}, {"oid": "e6898eba67aa3dde49b5e7fe031f779f8ab28c43", "url": "https://github.com/elastic/elasticsearch/commit/e6898eba67aa3dde49b5e7fe031f779f8ab28c43", "message": "Merge remote-tracking branch 'elastic/master' into cs-response-on-management-thread", "committedDate": "2020-12-03T22:24:56Z", "type": "commit"}, {"oid": "3f0ea978a519531400b8df96c75fa21e91ed9761", "url": "https://github.com/elastic/elasticsearch/commit/3f0ea978a519531400b8df96c75fa21e91ed9761", "message": "fix test", "committedDate": "2020-12-03T22:33:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk0NzcwMA==", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r535947700", "bodyText": "Are you sure that buildResponse() is the expensive bit? That's not where the serialisation happens, it's just reorganising some maps a bit.", "author": "DaveCTurner", "createdAt": "2020-12-04T09:13:18Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/state/TransportClusterStateAction.java", "diffHunk": "@@ -115,6 +116,13 @@ public void onTimeout(TimeValue timeout) {\n         }\n     }\n \n+    // The cluster state can be a large object so we resolve the response listener on the MANAGEMENT pool to not serialize the resulting\n+    // large response on a transport or cluster state thread which we don't want to block needlessly\n+    private void resolveListener(ClusterStateRequest request, ClusterState currentState, ActionListener<ClusterStateResponse> listener) {\n+        threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(\n+                ActionRunnable.supply(listener, () -> buildResponse(request, currentState)));", "originalCommit": "3f0ea978a519531400b8df96c75fa21e91ed9761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk1ODg0MA==", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r535958840", "bodyText": "It's not but the thread that resolves the listener is also the thread that will do the serialization in the TCP transport (OutboundHandler). I could obviously just resolve the listener on the management thread for that reason, but if I already fork-off then I might as well fork off as much work as I can?", "author": "original-brownbear", "createdAt": "2020-12-04T09:30:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk0NzcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2MTgyMw==", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r535961823", "bodyText": "Right, sorry, I lost track.", "author": "DaveCTurner", "createdAt": "2020-12-04T09:34:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk0NzcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk0OTM3OA==", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r535949378", "bodyText": "If we build a response not on a transport thread, we still serialise it on the transport thread right? If it's just the outbound serialization bit that's slow, how is it logged? AIUI today we only log slowness when processing an inbound request.", "author": "DaveCTurner", "createdAt": "2020-12-04T09:15:55Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/state/TransportClusterStateAction.java", "diffHunk": "@@ -115,6 +116,13 @@ public void onTimeout(TimeValue timeout) {\n         }\n     }\n \n+    // The cluster state can be a large object so we resolve the response listener on the MANAGEMENT pool to not serialize the resulting\n+    // large response on a transport or cluster state thread which we don't want to block needlessly\n+    private void resolveListener(ClusterStateRequest request, ClusterState currentState, ActionListener<ClusterStateResponse> listener) {\n+        threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(", "originalCommit": "3f0ea978a519531400b8df96c75fa21e91ed9761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk1OTI5OA==", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r535959298", "bodyText": "If we build a response not on a transport thread, we still serialise it on the transport thread right?\n\nNah not anymore, we reverted that change. Once again serialization happens on the thread that resolves the listener in the transport action.", "author": "original-brownbear", "createdAt": "2020-12-04T09:31:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk0OTM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2MTY0OA==", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r535961648", "bodyText": "Oh yeah, sorry, I lost track. This is ok then, at least until we reinstate that change.", "author": "DaveCTurner", "createdAt": "2020-12-04T09:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk0OTM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk1MDAxNg==", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r535950016", "bodyText": "Nice \ud83d\udc4d", "author": "DaveCTurner", "createdAt": "2020-12-04T09:16:53Z", "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestClusterStateAction.java", "diffHunk": "@@ -107,20 +114,36 @@ public RestChannelConsumer prepareRequest(final RestRequest request, final NodeC\n         }\n         settingsFilter.addFilterSettingParams(request);\n \n-        return channel -> client.admin().cluster().state(clusterStateRequest, new RestBuilderListener<ClusterStateResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(ClusterStateResponse response, XContentBuilder builder) throws Exception {\n-                builder.startObject();\n-                if (clusterStateRequest.waitForMetadataVersion() != null) {\n-                    builder.field(Fields.WAIT_FOR_TIMED_OUT, response.isWaitForTimedOut());\n-                }\n-                builder.field(Fields.CLUSTER_NAME, response.getClusterName().value());\n-                ToXContent.Params params = new ToXContent.DelegatingMapParams(\n-                    singletonMap(Metadata.CONTEXT_MODE_PARAM, Metadata.CONTEXT_MODE_API), request);\n-                response.getState().toXContent(builder, params);\n-                builder.endObject();\n-                return new BytesRestResponse(RestStatus.OK, builder);\n-            }\n+        return channel -> client.admin().cluster().state(clusterStateRequest, new RestActionListener<>(channel) {\n+\n+                    @Override\n+                    protected void processResponse(ClusterStateResponse response) {\n+                        final long startTimeMs = threadPool.relativeTimeInMillis();\n+                        // Process serialization on MANAGEMENT pool since the serialization of the cluster state to XContent\n+                        // can be too slow to execute on an IO thread\n+                        threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(\n+                                ActionRunnable.wrap(this, l -> new RestBuilderListener<ClusterStateResponse>(channel) {\n+                                    @Override\n+                                    public RestResponse buildResponse(final ClusterStateResponse response,\n+                                                                      final XContentBuilder builder) throws Exception {\n+                                        if (clusterStateRequest.local() == false &&\n+                                                threadPool.relativeTimeInMillis() - startTimeMs >\n+                                                        clusterStateRequest.masterNodeTimeout().millis()) {\n+                                            throw new ElasticsearchTimeoutException(\"Timed out getting cluster state\");", "originalCommit": "3f0ea978a519531400b8df96c75fa21e91ed9761", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a326f797bfd8386e157e16426b62919536af68db", "url": "https://github.com/elastic/elasticsearch/commit/a326f797bfd8386e157e16426b62919536af68db", "message": "Merge remote-tracking branch 'elastic/master' into cs-response-on-management-thread", "committedDate": "2020-12-04T10:55:21Z", "type": "commit"}, {"oid": "02b7fb649528f6707a4e33b98a239e8786a8b3e9", "url": "https://github.com/elastic/elasticsearch/commit/02b7fb649528f6707a4e33b98a239e8786a8b3e9", "message": "revert transport action changes", "committedDate": "2020-12-04T11:00:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxOTY5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r536019692", "bodyText": "I kept this test cleanup even though it's not necessary now with the transport action changes reverted because busy asserting on futures was just weird ...", "author": "original-brownbear", "createdAt": "2020-12-04T11:06:08Z", "path": "server/src/test/java/org/elasticsearch/action/admin/cluster/state/ClusterStateApiTests.java", "diffHunk": "@@ -52,10 +53,7 @@ public void testWaitForMetadataVersion() throws Exception {\n         updateSettingsRequest.transientSettings(Settings.builder().put(\"cluster.max_shards_per_node\", 999));\n         assertAcked(client().admin().cluster().updateSettings(updateSettingsRequest).actionGet());\n \n-        assertBusy(() -> {\n-            assertThat(future2.isDone(), is(true));\n-        });\n-        ClusterStateResponse response = future2.actionGet();\n+        response = future2.get(10L, TimeUnit.SECONDS);", "originalCommit": "02b7fb649528f6707a4e33b98a239e8786a8b3e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA0MzQyNg==", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r536043426", "bodyText": "Seems a bit weird to create the listener just to immediately complete it. Why not inline this?", "author": "DaveCTurner", "createdAt": "2020-12-04T11:49:35Z", "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestClusterStateAction.java", "diffHunk": "@@ -107,20 +114,36 @@ public RestChannelConsumer prepareRequest(final RestRequest request, final NodeC\n         }\n         settingsFilter.addFilterSettingParams(request);\n \n-        return channel -> client.admin().cluster().state(clusterStateRequest, new RestBuilderListener<ClusterStateResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(ClusterStateResponse response, XContentBuilder builder) throws Exception {\n-                builder.startObject();\n-                if (clusterStateRequest.waitForMetadataVersion() != null) {\n-                    builder.field(Fields.WAIT_FOR_TIMED_OUT, response.isWaitForTimedOut());\n-                }\n-                builder.field(Fields.CLUSTER_NAME, response.getClusterName().value());\n-                ToXContent.Params params = new ToXContent.DelegatingMapParams(\n-                    singletonMap(Metadata.CONTEXT_MODE_PARAM, Metadata.CONTEXT_MODE_API), request);\n-                response.getState().toXContent(builder, params);\n-                builder.endObject();\n-                return new BytesRestResponse(RestStatus.OK, builder);\n-            }\n+        return channel -> client.admin().cluster().state(clusterStateRequest, new RestActionListener<>(channel) {\n+\n+                    @Override\n+                    protected void processResponse(ClusterStateResponse response) {\n+                        final long startTimeMs = threadPool.relativeTimeInMillis();\n+                        // Process serialization on MANAGEMENT pool since the serialization of the cluster state to XContent\n+                        // can be too slow to execute on an IO thread\n+                        threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(\n+                                ActionRunnable.wrap(this, l -> new RestBuilderListener<ClusterStateResponse>(channel) {\n+                                    @Override\n+                                    public RestResponse buildResponse(final ClusterStateResponse response,\n+                                                                      final XContentBuilder builder) throws Exception {\n+                                        if (clusterStateRequest.local() == false &&\n+                                                threadPool.relativeTimeInMillis() - startTimeMs >\n+                                                        clusterStateRequest.masterNodeTimeout().millis()) {\n+                                            throw new ElasticsearchTimeoutException(\"Timed out getting cluster state\");\n+                                        }\n+                                        builder.startObject();\n+                                        if (clusterStateRequest.waitForMetadataVersion() != null) {\n+                                            builder.field(Fields.WAIT_FOR_TIMED_OUT, response.isWaitForTimedOut());\n+                                        }\n+                                        builder.field(Fields.CLUSTER_NAME, response.getClusterName().value());\n+                                        ToXContent.Params params = new ToXContent.DelegatingMapParams(\n+                                                singletonMap(Metadata.CONTEXT_MODE_PARAM, Metadata.CONTEXT_MODE_API), request);\n+                                        response.getState().toXContent(builder, params);\n+                                        builder.endObject();\n+                                        return new BytesRestResponse(RestStatus.OK, builder);\n+                                    }\n+                                }.onResponse(response)));", "originalCommit": "02b7fb649528f6707a4e33b98a239e8786a8b3e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA0NjI5OA==", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r536046298", "bodyText": "Did the same for the mappings, so I didn't have to duplicate the logic in RestBuilderListener but now that we have two spots that follow this pattern I think we can refactor this in a follow-up and extract the logic for writing out the response somewhere so we don't have to do this.", "author": "original-brownbear", "createdAt": "2020-12-04T11:54:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA0MzQyNg=="}], "type": "inlineReview"}]}