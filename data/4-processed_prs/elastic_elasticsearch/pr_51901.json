{"pr_number": 51901, "pr_title": "EQL: Convert wildcards to LIKE in analyzer", "pr_createdAt": "2020-02-05T00:36:22Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51901", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3MTAzMw==", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375171033", "bodyText": "Can a wildcard appear in any type of string? e.g. some*glob?\nI wonder whether the parser could detect it so instead of having Literal that might a string, it could have its own expression rule.", "author": "costin", "createdAt": "2020-02-05T10:22:08Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -42,4 +60,110 @@ private LogicalPlan verify(LogicalPlan plan) {\n         }\n         return plan;\n     }\n+\n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {", "originalCommit": "61da57cc693b0a9f3b90ba55d7e021a9f3654140", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3MzY0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375173646", "bodyText": "A potential improvement is to check whether an expression is foldable instead of being a literal.\nThus if string concatenation were to be added, the rule would still be applied:\nif (e.foldable() && e.fold() instanceof String) {\n    return e.fold().toString().contains(\"*\");\n}\nwhich can be transformed into a one-liner:\nreturn e.foldable() && e.fold() instanceof String && e.fold().toString().contains(\"*\");", "author": "costin", "createdAt": "2020-02-05T10:27:19Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -42,4 +60,110 @@ private LogicalPlan verify(LogicalPlan plan) {\n         }\n         return plan;\n     }\n+\n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();", "originalCommit": "61da57cc693b0a9f3b90ba55d7e021a9f3654140", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3NTEyNg==", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375175126", "bodyText": "what about foo > \"wild*card\" or other value comparisons?\nIf that's valid grammar, the verifier should pick the pattern and fail the query.", "author": "costin", "createdAt": "2020-02-05T10:30:07Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -42,4 +60,110 @@ private LogicalPlan verify(LogicalPlan plan) {\n         }\n         return plan;\n     }\n+\n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private static LikePattern toLikePattern(String s) {\n+            // pick a character that is guaranteed not to be in the string, because it isn't allowed to escape itself\n+            char escape = 1;\n+\n+            // replace wildcards with % and escape special characters\n+            String likeString = s.replace(\"%\", escape + \"%\")\n+                                 .replace(\"_\", escape + \"_\")\n+                                 .replace(\"*\", \"%\");\n+\n+            return new LikePattern(likeString, escape);\n+        }\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                // expr == \"wildcard*phrase\"", "originalCommit": "61da57cc693b0a9f3b90ba55d7e021a9f3654140", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM1OTcwMw==", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375359703", "bodyText": "yeah, it is valid grammar, but since it's not == or !=, this will just be a lexicographical comparison", "author": "rw-access", "createdAt": "2020-02-05T16:20:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3NTEyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQwNjY2MA==", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r376406660", "bodyText": "That would mean the operators are not consistent since == would expand the wildcard while > & co would compare against it...", "author": "costin", "createdAt": "2020-02-07T14:06:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3NTEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3NTM4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375175386", "bodyText": "isWildcard already does the checks so simply do: eq.fold().toString()", "author": "costin", "createdAt": "2020-02-05T10:30:39Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -42,4 +60,110 @@ private LogicalPlan verify(LogicalPlan plan) {\n         }\n         return plan;\n     }\n+\n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private static LikePattern toLikePattern(String s) {\n+            // pick a character that is guaranteed not to be in the string, because it isn't allowed to escape itself\n+            char escape = 1;\n+\n+            // replace wildcards with % and escape special characters\n+            String likeString = s.replace(\"%\", escape + \"%\")\n+                                 .replace(\"_\", escape + \"_\")\n+                                 .replace(\"*\", \"%\");\n+\n+            return new LikePattern(likeString, escape);\n+        }\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                // expr == \"wildcard*phrase\"\n+                if (e instanceof Equals) {\n+                    Equals eq = (Equals) e;\n+\n+                    if (isWildcard(eq.right())) {\n+                        String wcString = (String) ((Literal) eq.right()).value();", "originalCommit": "61da57cc693b0a9f3b90ba55d7e021a9f3654140", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3NjIxMA==", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375176210", "bodyText": "the rule makes the assumption that the literal is always on the right hand side which not always the case: \"wildcard*phrase\" != expr is also valid.\nThus the rule is better inside the optimizer, which will also handle folding and move the literals to right (#51929).", "author": "costin", "createdAt": "2020-02-05T10:32:17Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -42,4 +60,110 @@ private LogicalPlan verify(LogicalPlan plan) {\n         }\n         return plan;\n     }\n+\n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private static LikePattern toLikePattern(String s) {\n+            // pick a character that is guaranteed not to be in the string, because it isn't allowed to escape itself\n+            char escape = 1;\n+\n+            // replace wildcards with % and escape special characters\n+            String likeString = s.replace(\"%\", escape + \"%\")\n+                                 .replace(\"_\", escape + \"_\")\n+                                 .replace(\"*\", \"%\");\n+\n+            return new LikePattern(likeString, escape);\n+        }\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                // expr == \"wildcard*phrase\"\n+                if (e instanceof Equals) {\n+                    Equals eq = (Equals) e;\n+\n+                    if (isWildcard(eq.right())) {\n+                        String wcString = (String) ((Literal) eq.right()).value();\n+                        e = new Like(e.source(), eq.left(), toLikePattern(wcString));\n+                    }\n+                }\n+\n+                // expr != \"wildcard*phrase\"", "originalCommit": "61da57cc693b0a9f3b90ba55d7e021a9f3654140", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM2MDkyMA==", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375360920", "bodyText": "I doubt that the functionality has been leveraged by many users, but if a wildcard string is on the left instead of the right, then it's just a normal, non-wildcard comparison and will check for equality or inequality depending on the operator.", "author": "rw-access", "createdAt": "2020-02-05T16:22:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3NjIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5MjU2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375392567", "bodyText": "That seems a bit strange to me. I'd find it more intuitive if == and != would work in the same way regardless of right/left positioning of the args.", "author": "matriv", "createdAt": "2020-02-05T17:15:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3NjIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQwNzc4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r376407781", "bodyText": "if a wildcard string is on the left instead of the right, then it's just a normal, non-wildcard comparison and will check for equality or inequality depending on the operator.\n\nWhich would make == and != non commutative which is a bug.", "author": "costin", "createdAt": "2020-02-07T14:08:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3NjIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI0MzM3NA==", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375243374", "bodyText": "Would be possible to add more tests that also look at scenarios involving escape characters and all types of string that eql supports?\nCan the * be escaped? If so, we should have a test covering this case.", "author": "astefan", "createdAt": "2020-02-05T13:07:05Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -51,6 +61,60 @@ private LogicalPlan verify(LogicalPlan plan) {\n         return plan;\n     }\n \n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");", "originalCommit": "61da57cc693b0a9f3b90ba55d7e021a9f3654140", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM2MjU4MA==", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375362580", "bodyText": "yeah, I can add more tests. And there's no escape for *. But if you want to perform an exact (+/- case sensitivity) comparison, you can put the wildcard on the left (#51901 (comment)). Whether this functionality is good or not is a fair question, and I think it's fair to change this because I doubt any users are aware of the workaround.\nfield == \"*wildcard*\" <==> field LIKE \"%wildcard%\"\n\"*wildcard*\" == field <==> field == '*wildcard*'", "author": "rw-access", "createdAt": "2020-02-05T16:25:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI0MzM3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2MTI4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375761285", "bodyText": "To be honest, I find this more like a bug, rather than feature (that implies an workaround).\nA == B and B == A should be equivalent imo. Equality is not a predicate (like LIKE) where a certain element sits on the right and another one sits on the left and they are not interchangeable.", "author": "astefan", "createdAt": "2020-02-06T10:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI0MzM3NA=="}], "type": "inlineReview"}, {"oid": "32232515cce148213fd4760388172868f0dc0fb0", "url": "https://github.com/elastic/elasticsearch/commit/32232515cce148213fd4760388172868f0dc0fb0", "message": "EQL: Convert wildcards to LIKE in analyzer", "committedDate": "2020-02-05T16:51:21Z", "type": "forcePushed"}, {"oid": "a294d144019f062a49176300e0674dca34b6ccdb", "url": "https://github.com/elastic/elasticsearch/commit/a294d144019f062a49176300e0674dca34b6ccdb", "message": "EQL: Convert wildcards to LIKE in analyzer", "committedDate": "2020-02-05T16:53:28Z", "type": "forcePushed"}, {"oid": "14b37e830df31ed36aa7f1e118e8a53d2a1cd3e7", "url": "https://github.com/elastic/elasticsearch/commit/14b37e830df31ed36aa7f1e118e8a53d2a1cd3e7", "message": "EQL: Convert wildcards to LIKE in analyzer", "committedDate": "2020-02-05T16:56:46Z", "type": "forcePushed"}, {"oid": "fd1cd70b907f5e83e3096ef8385c37af49267484", "url": "https://github.com/elastic/elasticsearch/commit/fd1cd70b907f5e83e3096ef8385c37af49267484", "message": "EQL: Convert wildcards to LIKE in analyzer", "committedDate": "2020-02-05T16:57:41Z", "type": "forcePushed"}, {"oid": "ffc5e6f7dffeba8f843991747ef3954fe2b36e48", "url": "https://github.com/elastic/elasticsearch/commit/ffc5e6f7dffeba8f843991747ef3954fe2b36e48", "message": "EQL: Convert wildcard comparisons to Like", "committedDate": "2020-02-25T18:16:54Z", "type": "commit"}, {"oid": "ffc5e6f7dffeba8f843991747ef3954fe2b36e48", "url": "https://github.com/elastic/elasticsearch/commit/ffc5e6f7dffeba8f843991747ef3954fe2b36e48", "message": "EQL: Convert wildcard comparisons to Like", "committedDate": "2020-02-25T18:16:54Z", "type": "forcePushed"}, {"oid": "cc610ba7c59f7e55bda8aa584e41a27f74c3c171", "url": "https://github.com/elastic/elasticsearch/commit/cc610ba7c59f7e55bda8aa584e41a27f74c3c171", "message": "Merge remote-tracking branch 'origin/master' into eql/wildcards", "committedDate": "2020-03-04T17:13:30Z", "type": "commit"}, {"oid": "d6f8c397acd2bf199d929d3b54104d6f36140772", "url": "https://github.com/elastic/elasticsearch/commit/d6f8c397acd2bf199d929d3b54104d6f36140772", "message": "EQL: Simplify wildcard handling, update tests", "committedDate": "2020-03-04T17:34:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3ODUxOA==", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r387878518", "bodyText": "The comment seems incorrect as it referred to PropagateEquals", "author": "costin", "createdAt": "2020-03-04T19:17:07Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "diffHunk": "@@ -33,6 +43,7 @@ public LogicalPlan optimize(LogicalPlan verified) {\n                 new BooleanSimplification(),\n                 new BooleanLiteralsOnTheRight(),\n                 // needs to occur before BinaryComparison combinations", "originalCommit": "d6f8c397acd2bf199d929d3b54104d6f36140772", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk1ODU3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r387958573", "bodyText": "where should ReplaceWildcards() be moved to?", "author": "rw-access", "createdAt": "2020-03-04T21:56:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3ODUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3OTQ1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r387879459", "bodyText": "Why not 0?", "author": "costin", "createdAt": "2020-03-04T19:18:47Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "diffHunk": "@@ -45,4 +56,51 @@ public LogicalPlan optimize(LogicalPlan verified) {\n \n         return Arrays.asList(operators, label);\n     }\n+\n+\n+    private static class ReplaceWildcards extends OptimizerRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr.foldable()) {\n+                Object value = expr.fold();\n+                return value instanceof String && value.toString().contains(\"*\");\n+            }\n+            return false;\n+        }\n+\n+        private static LikePattern toLikePattern(String s) {\n+            // pick a character that is guaranteed not to be in the string, because it isn't allowed to escape itself\n+            char escape = 1;", "originalCommit": "d6f8c397acd2bf199d929d3b54104d6f36140772", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk1ODc3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r387958776", "bodyText": "Looks like there's explicit handling for \\0\n\n  \n    \n      elasticsearch/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/util/StringUtils.java\n    \n    \n         Line 104\n      in\n      bf317e8\n    \n    \n    \n    \n\n        \n          \n           if (!escaped && (curr == escape) && escape != 0) {", "author": "rw-access", "createdAt": "2020-03-04T21:57:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3OTQ1OQ=="}], "type": "inlineReview"}, {"oid": "87ee384d4c6a8746d07f1e096d7e473c9b6bda26", "url": "https://github.com/elastic/elasticsearch/commit/87ee384d4c6a8746d07f1e096d7e473c9b6bda26", "message": "EQL: Lint fixes for Optimizer.java", "committedDate": "2020-03-04T21:58:45Z", "type": "commit"}]}