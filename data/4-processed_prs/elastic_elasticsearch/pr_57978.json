{"pr_number": 57978, "pr_title": "[ML] Add categorizer stats ML result type", "pr_createdAt": "2020-06-11T10:23:47Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/57978", "timeline": [{"oid": "6f216eb1f9140d1649dfc7c001238918389eb5f2", "url": "https://github.com/elastic/elasticsearch/commit/6f216eb1f9140d1649dfc7c001238918389eb5f2", "message": "[ML] Add categorizer stats ML result type\n\nThis type of result will store stats about how well categorization\nis performing.  When per-partition categorization is in use, separate\ndocuments will be written for every partition so that it is possible\nto see if categorization is working well for some partitions but not\nothers.\n\nThis PR is a minimal implementation to allow the C++ side changes to\nbe made.  More Java side changes related to per-partition\ncategorization will be in followup PRs.  However, even in the long\nterm I do not see a major benefit in introducing dedicated APIs for\nquerying categorizer stats.  Like forecast request stats the\ncategorizer stats can be read directly from the job's results alias.", "committedDate": "2020-06-11T10:22:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyMjkxNA==", "url": "https://github.com/elastic/elasticsearch/pull/57978#discussion_r438722914", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        &&Objects.equals(this.partitionFieldName, that.partitionFieldName)\n          \n          \n            \n                        && Objects.equals(this.partitionFieldName, that.partitionFieldName)\n          \n      \n    \n    \n  \n\n\"obsessive formatting disorder\" :D", "author": "benwtrent", "createdAt": "2020-06-11T11:40:24Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/process/autodetect/state/CategorizerStats.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ml.job.process.autodetect.state;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser.ValueType;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.common.time.TimeUtils;\n+import org.elasticsearch.xpack.core.ml.job.config.Job;\n+import org.elasticsearch.xpack.core.ml.job.results.ReservedFieldNames;\n+import org.elasticsearch.xpack.core.ml.job.results.Result;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+public class CategorizerStats implements ToXContentObject, Writeable {\n+\n+    /**\n+     * Result type\n+     */\n+    public static final String RESULT_TYPE_VALUE = \"categorizer_stats\";\n+    public static final ParseField RESULT_TYPE_FIELD = new ParseField(RESULT_TYPE_VALUE);\n+\n+    /**\n+     * Field Names\n+     */\n+    public static final ParseField PARTITION_FIELD_NAME = new ParseField(\"partition_field_name\");\n+    public static final ParseField PARTITION_FIELD_VALUE = new ParseField(\"partition_field_value\");\n+    public static final ParseField CATEGORIZED_DOC_COUNT_FIELD = new ParseField(\"categorized_doc_count\");\n+    public static final ParseField TOTAL_CATEGORY_COUNT_FIELD = new ParseField(\"total_category_count\");\n+    public static final ParseField FREQUENT_CATEGORY_COUNT_FIELD = new ParseField(\"frequent_category_count\");\n+    public static final ParseField RARE_CATEGORY_COUNT_FIELD = new ParseField(\"rare_category_count\");\n+    public static final ParseField DEAD_CATEGORY_COUNT_FIELD = new ParseField(\"dead_category_count\");\n+    public static final ParseField FAILED_CATEGORY_COUNT_FIELD = new ParseField(\"failed_category_count\");\n+    public static final ParseField CATEGORIZATION_STATUS_FIELD = new ParseField(\"categorization_status\");\n+    public static final ParseField LOG_TIME_FIELD = new ParseField(\"log_time\");\n+    public static final ParseField TIMESTAMP_FIELD = new ParseField(\"timestamp\");\n+\n+    public static final ConstructingObjectParser<Builder, Void> STRICT_PARSER = createParser(false);\n+    public static final ConstructingObjectParser<Builder, Void> LENIENT_PARSER = createParser(true);\n+\n+    private static ConstructingObjectParser<Builder, Void> createParser(boolean ignoreUnknownFields) {\n+        ConstructingObjectParser<Builder, Void> parser = new ConstructingObjectParser<>(RESULT_TYPE_FIELD.getPreferredName(),\n+            ignoreUnknownFields, a -> new Builder((String) a[0]));\n+\n+        parser.declareString(ConstructingObjectParser.constructorArg(), Job.ID);\n+        parser.declareString((modelSizeStat, s) -> {}, Result.RESULT_TYPE);\n+        parser.declareString(Builder::setPartitionFieldName, PARTITION_FIELD_NAME);\n+        parser.declareString(Builder::setPartitionFieldValue, PARTITION_FIELD_VALUE);\n+        parser.declareLong(Builder::setCategorizedDocCount, CATEGORIZED_DOC_COUNT_FIELD);\n+        parser.declareLong(Builder::setTotalCategoryCount, TOTAL_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setFrequentCategoryCount, FREQUENT_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setRareCategoryCount, RARE_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setDeadCategoryCount, DEAD_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setFailedCategoryCount, FAILED_CATEGORY_COUNT_FIELD);\n+        parser.declareField(Builder::setCategorizationStatus,\n+            p -> CategorizationStatus.fromString(p.text()), CATEGORIZATION_STATUS_FIELD, ValueType.STRING);\n+        parser.declareField(Builder::setLogTime,\n+            p -> TimeUtils.parseTimeFieldToInstant(p, LOG_TIME_FIELD.getPreferredName()), LOG_TIME_FIELD, ValueType.VALUE);\n+        parser.declareField(Builder::setTimestamp,\n+            p -> TimeUtils.parseTimeFieldToInstant(p, TIMESTAMP_FIELD.getPreferredName()), TIMESTAMP_FIELD, ValueType.VALUE);\n+\n+        return parser;\n+    }\n+\n+    private final String jobId;\n+    private final String partitionFieldName;\n+    private final String partitionFieldValue;\n+    private final long categorizedDocCount;\n+    private final long totalCategoryCount;\n+    private final long frequentCategoryCount;\n+    private final long rareCategoryCount;\n+    private final long deadCategoryCount;\n+    private final long failedCategoryCount;\n+    private final CategorizationStatus categorizationStatus;\n+    private final Instant timestamp;\n+    private final Instant logTime;\n+\n+    private CategorizerStats(String jobId, @Nullable String partitionFieldName, @Nullable String partitionFieldValue,\n+                             long categorizedDocCount, long totalCategoryCount, long frequentCategoryCount, long rareCategoryCount,\n+                             long deadCategoryCount, long failedCategoryCount, CategorizationStatus categorizationStatus, Instant timestamp,\n+                             Instant logTime) {\n+        this.jobId = Objects.requireNonNull(jobId);\n+        this.partitionFieldName = partitionFieldName;\n+        this.partitionFieldValue = partitionFieldValue;\n+        this.categorizedDocCount = categorizedDocCount;\n+        this.totalCategoryCount = totalCategoryCount;\n+        this.frequentCategoryCount = frequentCategoryCount;\n+        this.rareCategoryCount = rareCategoryCount;\n+        this.deadCategoryCount = deadCategoryCount;\n+        this.failedCategoryCount = failedCategoryCount;\n+        this.categorizationStatus = Objects.requireNonNull(categorizationStatus);\n+        this.timestamp = Instant.ofEpochMilli(timestamp.toEpochMilli());\n+        this.logTime = Instant.ofEpochMilli(logTime.toEpochMilli());\n+    }\n+\n+    public CategorizerStats(StreamInput in) throws IOException {\n+        jobId = in.readString();\n+        partitionFieldName = in.readOptionalString();\n+        partitionFieldValue = in.readOptionalString();\n+        categorizedDocCount = in.readVLong();\n+        totalCategoryCount = in.readVLong();\n+        frequentCategoryCount = in.readVLong();\n+        rareCategoryCount = in.readVLong();\n+        deadCategoryCount = in.readVLong();\n+        failedCategoryCount = in.readVLong();\n+        categorizationStatus = CategorizationStatus.readFromStream(in);\n+        logTime = in.readInstant();\n+        timestamp = in.readInstant();\n+    }\n+\n+    public String getId() {\n+        return documentIdPrefix(jobId) + logTime.toEpochMilli();\n+    }\n+\n+    public static String documentIdPrefix(String jobId) {\n+        return jobId + \"_categorizer_stats_\";\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeString(jobId);\n+        out.writeOptionalString(partitionFieldName);\n+        out.writeOptionalString(partitionFieldValue);\n+        out.writeVLong(categorizedDocCount);\n+        out.writeVLong(totalCategoryCount);\n+        out.writeVLong(frequentCategoryCount);\n+        out.writeVLong(rareCategoryCount);\n+        out.writeVLong(deadCategoryCount);\n+        out.writeVLong(failedCategoryCount);\n+        categorizationStatus.writeTo(out);\n+        out.writeInstant(logTime);\n+        out.writeInstant(timestamp);\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(Job.ID.getPreferredName(), jobId);\n+        builder.field(Result.RESULT_TYPE.getPreferredName(), RESULT_TYPE_VALUE);\n+        if (partitionFieldName != null) {\n+            builder.field(PARTITION_FIELD_NAME.getPreferredName(), partitionFieldName);\n+            builder.field(PARTITION_FIELD_VALUE.getPreferredName(), partitionFieldValue);\n+            if (ReservedFieldNames.isValidFieldName(partitionFieldName)) {\n+                builder.field(partitionFieldName, partitionFieldValue);\n+            }\n+        }\n+        builder.field(CATEGORIZED_DOC_COUNT_FIELD.getPreferredName(), categorizedDocCount);\n+        builder.field(TOTAL_CATEGORY_COUNT_FIELD.getPreferredName(), totalCategoryCount);\n+        builder.field(FREQUENT_CATEGORY_COUNT_FIELD.getPreferredName(), frequentCategoryCount);\n+        builder.field(RARE_CATEGORY_COUNT_FIELD.getPreferredName(), rareCategoryCount);\n+        builder.field(DEAD_CATEGORY_COUNT_FIELD.getPreferredName(), deadCategoryCount);\n+        builder.field(FAILED_CATEGORY_COUNT_FIELD.getPreferredName(), failedCategoryCount);\n+        builder.field(CATEGORIZATION_STATUS_FIELD.getPreferredName(), categorizationStatus);\n+        builder.timeField(LOG_TIME_FIELD.getPreferredName(), LOG_TIME_FIELD.getPreferredName() + \"_string\", logTime.toEpochMilli());\n+        builder.timeField(TIMESTAMP_FIELD.getPreferredName(), TIMESTAMP_FIELD.getPreferredName() + \"_string\", timestamp.toEpochMilli());\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public String getJobId() {\n+        return jobId;\n+    }\n+\n+    public String getPartitionFieldName() {\n+        return partitionFieldName;\n+    }\n+\n+    public String getPartitionFieldValue() {\n+        return partitionFieldValue;\n+    }\n+\n+    public long getCategorizedDocCount() {\n+        return categorizedDocCount;\n+    }\n+\n+    public long getTotalCategoryCount() {\n+        return totalCategoryCount;\n+    }\n+\n+    public long getFrequentCategoryCount() {\n+        return frequentCategoryCount;\n+    }\n+\n+    public long getRareCategoryCount() {\n+        return rareCategoryCount;\n+    }\n+\n+    public long getDeadCategoryCount() {\n+        return deadCategoryCount;\n+    }\n+\n+    public long getFailedCategoryCount() {\n+        return deadCategoryCount;\n+    }\n+\n+    public CategorizationStatus getCategorizationStatus() {\n+        return categorizationStatus;\n+    }\n+\n+    /**\n+     * The model timestamp when these stats were created.\n+     * @return The model time\n+     */\n+    public Instant getTimestamp() {\n+        return timestamp;\n+    }\n+\n+    /**\n+     * The wall clock time at the point when this instance was created.\n+     * @return The wall clock time\n+     */\n+    public Instant getLogTime() {\n+        return logTime;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(jobId, partitionFieldName, partitionFieldValue, categorizedDocCount, totalCategoryCount,\n+            frequentCategoryCount, rareCategoryCount, deadCategoryCount, failedCategoryCount, categorizationStatus, timestamp, logTime);\n+    }\n+\n+    /**\n+     * Compare all the fields.\n+     */\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (other instanceof CategorizerStats == false) {\n+            return false;\n+        }\n+\n+        CategorizerStats that = (CategorizerStats) other;\n+\n+        return Objects.equals(this.jobId, that.jobId)\n+            &&Objects.equals(this.partitionFieldName, that.partitionFieldName)", "originalCommit": "6f216eb1f9140d1649dfc7c001238918389eb5f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyMzg5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57978#discussion_r438723899", "bodyText": "We don't check that all of these are > 0. This is probably OK since we are getting this data from C++ and there is an implicit trust.", "author": "benwtrent", "createdAt": "2020-06-11T11:42:33Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/process/autodetect/state/CategorizerStats.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ml.job.process.autodetect.state;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser.ValueType;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.common.time.TimeUtils;\n+import org.elasticsearch.xpack.core.ml.job.config.Job;\n+import org.elasticsearch.xpack.core.ml.job.results.ReservedFieldNames;\n+import org.elasticsearch.xpack.core.ml.job.results.Result;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+public class CategorizerStats implements ToXContentObject, Writeable {\n+\n+    /**\n+     * Result type\n+     */\n+    public static final String RESULT_TYPE_VALUE = \"categorizer_stats\";\n+    public static final ParseField RESULT_TYPE_FIELD = new ParseField(RESULT_TYPE_VALUE);\n+\n+    /**\n+     * Field Names\n+     */\n+    public static final ParseField PARTITION_FIELD_NAME = new ParseField(\"partition_field_name\");\n+    public static final ParseField PARTITION_FIELD_VALUE = new ParseField(\"partition_field_value\");\n+    public static final ParseField CATEGORIZED_DOC_COUNT_FIELD = new ParseField(\"categorized_doc_count\");\n+    public static final ParseField TOTAL_CATEGORY_COUNT_FIELD = new ParseField(\"total_category_count\");\n+    public static final ParseField FREQUENT_CATEGORY_COUNT_FIELD = new ParseField(\"frequent_category_count\");\n+    public static final ParseField RARE_CATEGORY_COUNT_FIELD = new ParseField(\"rare_category_count\");\n+    public static final ParseField DEAD_CATEGORY_COUNT_FIELD = new ParseField(\"dead_category_count\");\n+    public static final ParseField FAILED_CATEGORY_COUNT_FIELD = new ParseField(\"failed_category_count\");\n+    public static final ParseField CATEGORIZATION_STATUS_FIELD = new ParseField(\"categorization_status\");\n+    public static final ParseField LOG_TIME_FIELD = new ParseField(\"log_time\");\n+    public static final ParseField TIMESTAMP_FIELD = new ParseField(\"timestamp\");\n+\n+    public static final ConstructingObjectParser<Builder, Void> STRICT_PARSER = createParser(false);\n+    public static final ConstructingObjectParser<Builder, Void> LENIENT_PARSER = createParser(true);\n+\n+    private static ConstructingObjectParser<Builder, Void> createParser(boolean ignoreUnknownFields) {\n+        ConstructingObjectParser<Builder, Void> parser = new ConstructingObjectParser<>(RESULT_TYPE_FIELD.getPreferredName(),\n+            ignoreUnknownFields, a -> new Builder((String) a[0]));\n+\n+        parser.declareString(ConstructingObjectParser.constructorArg(), Job.ID);\n+        parser.declareString((modelSizeStat, s) -> {}, Result.RESULT_TYPE);\n+        parser.declareString(Builder::setPartitionFieldName, PARTITION_FIELD_NAME);\n+        parser.declareString(Builder::setPartitionFieldValue, PARTITION_FIELD_VALUE);\n+        parser.declareLong(Builder::setCategorizedDocCount, CATEGORIZED_DOC_COUNT_FIELD);\n+        parser.declareLong(Builder::setTotalCategoryCount, TOTAL_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setFrequentCategoryCount, FREQUENT_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setRareCategoryCount, RARE_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setDeadCategoryCount, DEAD_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setFailedCategoryCount, FAILED_CATEGORY_COUNT_FIELD);\n+        parser.declareField(Builder::setCategorizationStatus,\n+            p -> CategorizationStatus.fromString(p.text()), CATEGORIZATION_STATUS_FIELD, ValueType.STRING);\n+        parser.declareField(Builder::setLogTime,\n+            p -> TimeUtils.parseTimeFieldToInstant(p, LOG_TIME_FIELD.getPreferredName()), LOG_TIME_FIELD, ValueType.VALUE);\n+        parser.declareField(Builder::setTimestamp,\n+            p -> TimeUtils.parseTimeFieldToInstant(p, TIMESTAMP_FIELD.getPreferredName()), TIMESTAMP_FIELD, ValueType.VALUE);\n+\n+        return parser;\n+    }\n+\n+    private final String jobId;\n+    private final String partitionFieldName;\n+    private final String partitionFieldValue;\n+    private final long categorizedDocCount;\n+    private final long totalCategoryCount;\n+    private final long frequentCategoryCount;\n+    private final long rareCategoryCount;\n+    private final long deadCategoryCount;\n+    private final long failedCategoryCount;\n+    private final CategorizationStatus categorizationStatus;\n+    private final Instant timestamp;\n+    private final Instant logTime;\n+\n+    private CategorizerStats(String jobId, @Nullable String partitionFieldName, @Nullable String partitionFieldValue,\n+                             long categorizedDocCount, long totalCategoryCount, long frequentCategoryCount, long rareCategoryCount,\n+                             long deadCategoryCount, long failedCategoryCount, CategorizationStatus categorizationStatus, Instant timestamp,\n+                             Instant logTime) {\n+        this.jobId = Objects.requireNonNull(jobId);\n+        this.partitionFieldName = partitionFieldName;\n+        this.partitionFieldValue = partitionFieldValue;\n+        this.categorizedDocCount = categorizedDocCount;\n+        this.totalCategoryCount = totalCategoryCount;\n+        this.frequentCategoryCount = frequentCategoryCount;\n+        this.rareCategoryCount = rareCategoryCount;\n+        this.deadCategoryCount = deadCategoryCount;\n+        this.failedCategoryCount = failedCategoryCount;", "originalCommit": "6f216eb1f9140d1649dfc7c001238918389eb5f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNjk3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/57978#discussion_r438736971", "bodyText": "Yes, good point.  This is dodgy when we're using VLong serialization.  It means someone can DoS us by updating a document to contain a negative number.\nThis same problem applies to most of our other results classes too, so I think it's best to deal with it in a separate PR.\nLike you say, the C++ won't send negative values for unsigned counters, so it's not a likely problem.", "author": "droberts195", "createdAt": "2020-06-11T12:10:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyMzg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyNjM5OA==", "url": "https://github.com/elastic/elasticsearch/pull/57978#discussion_r438726398", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (in.getVersion().onOrAfter(Version.V_8_0_0) && in.readBoolean()) {\n          \n          \n            \n                        this.categorizerStats = new CategorizerStats(in);\n          \n          \n            \n                    if (in.getVersion().onOrAfter(Version.V_8_0_0)) {\n          \n          \n            \n                        this.categorizerStats = in.readOptionalWriteable(CategorizerStats::new);", "author": "benwtrent", "createdAt": "2020-06-11T11:47:55Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/results/AutodetectResult.java", "diffHunk": "@@ -136,12 +143,16 @@ public AutodetectResult(StreamInput in) throws IOException {\n         } else {\n             this.categoryDefinition = null;\n         }\n+        if (in.getVersion().onOrAfter(Version.V_8_0_0) && in.readBoolean()) {\n+            this.categorizerStats = new CategorizerStats(in);", "originalCommit": "6f216eb1f9140d1649dfc7c001238918389eb5f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyNzc1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/57978#discussion_r438727756", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        writeNullable(categorizerStats, out);\n          \n          \n            \n                        out.writeOptionalWriteable(categorizerStats);\n          \n      \n    \n    \n  \n\nI wonder if this writeNullable method could just be removed? The down side is that there is no StreamOutput#writeOptionalList. Maybe there should be?", "author": "benwtrent", "createdAt": "2020-06-11T11:50:54Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/results/AutodetectResult.java", "diffHunk": "@@ -165,6 +176,9 @@ public void writeTo(StreamOutput out) throws IOException {\n         writeNullable(modelPlot, out);\n         writeNullable(annotation, out);\n         writeNullable(categoryDefinition, out);\n+        if (out.getVersion().onOrAfter(Version.V_8_0_0)) {\n+            writeNullable(categorizerStats, out);", "originalCommit": "6f216eb1f9140d1649dfc7c001238918389eb5f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8c0bc5acb237c8f2f4e09230e0fd005d7d3ec876", "url": "https://github.com/elastic/elasticsearch/commit/8c0bc5acb237c8f2f4e09230e0fd005d7d3ec876", "message": "Apply suggestions from code review\n\nCo-authored-by: Benjamin Trent <ben.w.trent@gmail.com>", "committedDate": "2020-06-11T12:11:53Z", "type": "commit"}]}