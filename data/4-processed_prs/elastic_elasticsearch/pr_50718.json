{"pr_number": 50718, "pr_title": "ILM wait for active shards on rolled index in a separate step", "pr_createdAt": "2020-01-07T21:52:34Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/50718", "timeline": [{"oid": "f6290e4a884a794639cc73a5b2e0bb7e8587f7d3", "url": "https://github.com/elastic/elasticsearch/commit/f6290e4a884a794639cc73a5b2e0bb7e8587f7d3", "message": "ILM wait for active shards on rolled index in a separate step", "committedDate": "2020-01-07T21:46:33Z", "type": "commit"}, {"oid": "fccfee5c9101322f6e93893b7472c3cd4956513a", "url": "https://github.com/elastic/elasticsearch/commit/fccfee5c9101322f6e93893b7472c3cd4956513a", "message": "Add license header", "committedDate": "2020-01-07T22:03:21Z", "type": "commit"}, {"oid": "456ba486c783ec17ec6f673d64d2a5cfcefe96ee", "url": "https://github.com/elastic/elasticsearch/commit/456ba486c783ec17ec6f673d64d2a5cfcefe96ee", "message": "Fix RolloverActionTests to reflect the new step", "committedDate": "2020-01-08T10:52:02Z", "type": "commit"}, {"oid": "292a8e6069e7b88165336640b0b30e53c42a7afb", "url": "https://github.com/elastic/elasticsearch/commit/292a8e6069e7b88165336640b0b30e53c42a7afb", "message": "WaitForActiveShardsStep uses the alias index", "committedDate": "2020-01-15T12:18:47Z", "type": "commit"}, {"oid": "b2673bd66eed05aeb89a666456b5dad63f7493d8", "url": "https://github.com/elastic/elasticsearch/commit/b2673bd66eed05aeb89a666456b5dad63f7493d8", "message": "Fix integratino test", "committedDate": "2020-01-15T12:18:54Z", "type": "commit"}, {"oid": "77364de507d4b05dca388dbf5231118afbef08a2", "url": "https://github.com/elastic/elasticsearch/commit/77364de507d4b05dca388dbf5231118afbef08a2", "message": "Merge branch 'master' into ilm-rollover-wait-for-active-shards", "committedDate": "2020-01-15T12:26:37Z", "type": "commit"}, {"oid": "0a98bf0a01f9701a4a27d1fbc130683a068abb50", "url": "https://github.com/elastic/elasticsearch/commit/0a98bf0a01f9701a4a27d1fbc130683a068abb50", "message": "Merge branch 'master' into ilm-rollover-wait-for-active-shards", "committedDate": "2020-01-15T13:17:24Z", "type": "commit"}, {"oid": "4842f395b66365ca26b4a4090e99dc7846a98112", "url": "https://github.com/elastic/elasticsearch/commit/4842f395b66365ca26b4a4090e99dc7846a98112", "message": "Don't wait for active shards when rolling over in ILM", "committedDate": "2020-01-15T13:25:18Z", "type": "commit"}, {"oid": "eb8f95f27d87b6a52aa49e627684c101b5dc2a7b", "url": "https://github.com/elastic/elasticsearch/commit/eb8f95f27d87b6a52aa49e627684c101b5dc2a7b", "message": "Fix TransportPutLifecycleActionTests", "committedDate": "2020-01-15T17:31:43Z", "type": "commit"}, {"oid": "a4615f8e23006c9d3c0416d7e864d26afc64ec7a", "url": "https://github.com/elastic/elasticsearch/commit/a4615f8e23006c9d3c0416d7e864d26afc64ec7a", "message": "Merge branch 'master' into ilm-rollover-wait-for-active-shards", "committedDate": "2020-01-15T17:46:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxMzc4OA==", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r367013788", "bodyText": "Can you add a comment above this about why we are setting it to zero (for future code spelunkers)", "author": "dakrone", "createdAt": "2020-01-15T17:40:26Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RolloverStep.java", "diffHunk": "@@ -70,6 +71,7 @@ public void performAction(IndexMetaData indexMetaData, ClusterState currentClust\n \n         // Calling rollover with no conditions will always roll over the index\n         RolloverRequest rolloverRequest = new RolloverRequest(rolloverAlias, null);\n+        rolloverRequest.setWaitForActiveShards(ActiveShardCount.NONE);", "originalCommit": "eb8f95f27d87b6a52aa49e627684c101b5dc2a7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxNDYxOA==", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r367014618", "bodyText": "We should check for this to be null here (in the event the index was deleted immediately prior to the invocation), our other ClusterStateWaitSteps have this null check", "author": "dakrone", "createdAt": "2020-01-15T17:42:14Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.index.Index;\n+\n+import java.util.List;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);", "originalCommit": "eb8f95f27d87b6a52aa49e627684c101b5dc2a7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0NDEwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r367144109", "bodyText": "I think we can return a more descriptive information object here, something like \"waiting for 3 shards to become active, currently 2 are active\" or something that includes the amount we're waiting for and the amount currently active.", "author": "dakrone", "createdAt": "2020-01-15T22:36:24Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.index.Index;\n+\n+import java.util.List;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            // if the rollover was not performed on a write index alias, the alias will be moved to the new index and it will be the only\n+            // index this alias points to\n+            List<IndexMetaData> indices = alias.getIndices();\n+            assert indices.size() == 1 : \"when performing rollover on alias with is_write_index = false the alias must point to only \" +\n+                \"one index\";\n+            IndexMetaData indexMetaData = indices.get(0);\n+            rolledIndexName = indexMetaData.getIndex().getName();\n+            waitForActiveShardsSettingValue = indexMetaData.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        return new Result(activeShardCount.enoughShardsActive(clusterState, rolledIndexName), null);", "originalCommit": "a4615f8e23006c9d3c0416d7e864d26afc64ec7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "115a1312554445947c073f17fecb93c6663e4f83", "url": "https://github.com/elastic/elasticsearch/commit/115a1312554445947c073f17fecb93c6663e4f83", "message": "Comment to clarify why rollover doens't wait for active shards", "committedDate": "2020-01-16T12:47:25Z", "type": "commit"}, {"oid": "0924222ed9ac7a98a95c4220ffca25b9003b14e5", "url": "https://github.com/elastic/elasticsearch/commit/0924222ed9ac7a98a95c4220ffca25b9003b14e5", "message": "Guard against the index having been deleted while executing a policy", "committedDate": "2020-01-16T12:47:25Z", "type": "commit"}, {"oid": "bf09bbc3132713bef72a866faf810238206a5e8c", "url": "https://github.com/elastic/elasticsearch/commit/bf09bbc3132713bef72a866faf810238206a5e8c", "message": "Return a meaningful shards state message", "committedDate": "2020-01-16T12:47:26Z", "type": "commit"}, {"oid": "c33a595e0afc994082256c726824c43b15eedd77", "url": "https://github.com/elastic/elasticsearch/commit/c33a595e0afc994082256c726824c43b15eedd77", "message": "Merge branch 'master' into ilm-rollover-wait-for-active-shards", "committedDate": "2020-01-16T12:47:50Z", "type": "commit"}, {"oid": "6225c04f81cbe3690686916695a04c7641d1b84c", "url": "https://github.com/elastic/elasticsearch/commit/6225c04f81cbe3690686916695a04c7641d1b84c", "message": "Merge branch 'master' into ilm-rollover-wait-for-active-shards", "committedDate": "2020-01-16T13:54:47Z", "type": "commit"}, {"oid": "a27e1cc370bed4abcb2e3c378b4bc02f45ef2537", "url": "https://github.com/elastic/elasticsearch/commit/a27e1cc370bed4abcb2e3c378b4bc02f45ef2537", "message": "Merge branch 'master' into ilm-rollover-wait-for-active-shards", "committedDate": "2020-01-16T15:03:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2MzkzMw==", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r367563933", "bodyText": "this assertion doesn't stand in a CCR environment", "author": "andreidan", "createdAt": "2020-01-16T17:53:39Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            // if the rollover was not performed on a write index alias, the alias will be moved to the new index and it will be the only\n+            // index this alias points to\n+            List<IndexMetaData> indices = alias.getIndices();\n+            assert indices.size() == 1 : \"when performing rollover on alias with is_write_index = false the alias must point to only \" +", "originalCommit": "a27e1cc370bed4abcb2e3c378b4bc02f45ef2537", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2OTA4MA==", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r367969080", "bodyText": "coming up with the fix by parsing the number from the index name and finding the rolled index by \"max number\"", "author": "andreidan", "createdAt": "2020-01-17T14:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2MzkzMw=="}], "type": "inlineReview"}, {"oid": "a838925f90b2b1cda1828c4ca6c2e29d8c8fcaf6", "url": "https://github.com/elastic/elasticsearch/commit/a838925f90b2b1cda1828c4ca6c2e29d8c8fcaf6", "message": "Drop unused getters", "committedDate": "2020-01-17T15:47:21Z", "type": "commit"}, {"oid": "9f9b842b9313e077a2ae89bed28e334f258c33c8", "url": "https://github.com/elastic/elasticsearch/commit/9f9b842b9313e077a2ae89bed28e334f258c33c8", "message": "Find rolled index by finding the max counter in the name.", "committedDate": "2020-01-17T15:47:21Z", "type": "commit"}, {"oid": "c3f506e9b5c18d3d1beb2aff9b8e4a15eb2852ea", "url": "https://github.com/elastic/elasticsearch/commit/c3f506e9b5c18d3d1beb2aff9b8e4a15eb2852ea", "message": "Escape < and > in javadoc", "committedDate": "2020-01-17T16:05:42Z", "type": "commit"}, {"oid": "76791435a3f96798f6ac29eba5b03b06db697aa4", "url": "https://github.com/elastic/elasticsearch/commit/76791435a3f96798f6ac29eba5b03b06db697aa4", "message": "Skip WaitForActiveShardsStep when lifecycle complete is set", "committedDate": "2020-01-17T17:16:00Z", "type": "commit"}, {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb", "url": "https://github.com/elastic/elasticsearch/commit/3a1cd874b1e1824458af64e8b6544d6bef18d4eb", "message": "Merge branch 'master' into ilm-rollover-wait-for-active-shards", "committedDate": "2020-01-17T17:16:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1MDAzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368050035", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String rolledIndexName;\n          \n          \n            \n                    final String rolledIndexName;", "author": "dakrone", "createdAt": "2020-01-17T17:25:28Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;", "originalCommit": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1MDExMw==", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368050113", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String waitForActiveShardsSettingValue;\n          \n          \n            \n                    final String waitForActiveShardsSettingValue;", "author": "dakrone", "createdAt": "2020-01-17T17:25:37Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;", "originalCommit": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1MTM3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368051373", "bodyText": "Can we return the above log message as part of the \"info\" ToXContent object here? Otherwise this could stick in false forever and the user would never know why", "author": "dakrone", "createdAt": "2020-01-17T17:28:45Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);", "originalCommit": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NDMzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368054339", "bodyText": "I think we should remove this assert and throw a regular error", "author": "dakrone", "createdAt": "2020-01-17T17:36:25Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);\n+            }\n+            rolledIndexName = rolledIndexMeta.getIndex().getName();\n+            waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        boolean enoughShardsActive = activeShardCount.enoughShardsActive(clusterState, rolledIndexName);\n+\n+        IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(rolledIndexName);\n+        int currentActiveShards = 0;\n+        for (final IntObjectCursor<IndexShardRoutingTable> shardRouting : indexRoutingTable.getShards()) {\n+            currentActiveShards += shardRouting.value.activeShards().size();\n+        }\n+        return new Result(enoughShardsActive, new Info(currentActiveShards, activeShardCount.toString(), enoughShardsActive));\n+    }\n+\n+    /**\n+     * Parses the number from the rolled over index name. It also supports the date-math format (ie. index name is wrapped in &lt; and &gt;)\n+     * <p>\n+     * Eg.\n+     * <p>\n+     * - For \"logs-000002\" it'll return 2\n+     * - For \"&lt;logs-{now/d}-3&gt;\" it'll return 3\n+     */\n+    static int parseIndexNameCounter(String indexName) {\n+        int numberIndex = indexName.lastIndexOf(\"-\");\n+        assert numberIndex != -1 : \"no separator '-' found\";", "originalCommit": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NDg4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368054881", "bodyText": "This should catch the NumberFormatException and format it into a nicer, more human readable exception. It's possible to hit this if someone were to take an index foo-000003 and snapshot it, then restore it with a different name (like foo-000003-restored for example), this would flip out but it wouldn't be clear why.", "author": "dakrone", "createdAt": "2020-01-17T17:37:36Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);\n+            }\n+            rolledIndexName = rolledIndexMeta.getIndex().getName();\n+            waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        boolean enoughShardsActive = activeShardCount.enoughShardsActive(clusterState, rolledIndexName);\n+\n+        IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(rolledIndexName);\n+        int currentActiveShards = 0;\n+        for (final IntObjectCursor<IndexShardRoutingTable> shardRouting : indexRoutingTable.getShards()) {\n+            currentActiveShards += shardRouting.value.activeShards().size();\n+        }\n+        return new Result(enoughShardsActive, new Info(currentActiveShards, activeShardCount.toString(), enoughShardsActive));\n+    }\n+\n+    /**\n+     * Parses the number from the rolled over index name. It also supports the date-math format (ie. index name is wrapped in &lt; and &gt;)\n+     * <p>\n+     * Eg.\n+     * <p>\n+     * - For \"logs-000002\" it'll return 2\n+     * - For \"&lt;logs-{now/d}-3&gt;\" it'll return 3\n+     */\n+    static int parseIndexNameCounter(String indexName) {\n+        int numberIndex = indexName.lastIndexOf(\"-\");\n+        assert numberIndex != -1 : \"no separator '-' found\";\n+        return Integer.parseInt(indexName.substring(numberIndex + 1, indexName.endsWith(\">\") ? indexName.length() - 1 :", "originalCommit": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ3MjMwMw==", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368472303", "bodyText": "I've kept the exception handling light here as this step follows closely the RolloverStep (which would not succeed in the example you illustrated as the source index would not match the ^.*-\\d+$ pattern). Its visibility is package default solely for testing purposes.\nI guess renames and such could occur between steps, so I'll add the exception handling and remove the assumptions.", "author": "andreidan", "createdAt": "2020-01-20T10:26:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NDg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NjczMQ==", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368056731", "bodyText": "I believe this PARSER is never actually used?", "author": "dakrone", "createdAt": "2020-01-17T17:42:18Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);\n+            }\n+            rolledIndexName = rolledIndexMeta.getIndex().getName();\n+            waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        boolean enoughShardsActive = activeShardCount.enoughShardsActive(clusterState, rolledIndexName);\n+\n+        IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(rolledIndexName);\n+        int currentActiveShards = 0;\n+        for (final IntObjectCursor<IndexShardRoutingTable> shardRouting : indexRoutingTable.getShards()) {\n+            currentActiveShards += shardRouting.value.activeShards().size();\n+        }\n+        return new Result(enoughShardsActive, new Info(currentActiveShards, activeShardCount.toString(), enoughShardsActive));\n+    }\n+\n+    /**\n+     * Parses the number from the rolled over index name. It also supports the date-math format (ie. index name is wrapped in &lt; and &gt;)\n+     * <p>\n+     * Eg.\n+     * <p>\n+     * - For \"logs-000002\" it'll return 2\n+     * - For \"&lt;logs-{now/d}-3&gt;\" it'll return 3\n+     */\n+    static int parseIndexNameCounter(String indexName) {\n+        int numberIndex = indexName.lastIndexOf(\"-\");\n+        assert numberIndex != -1 : \"no separator '-' found\";\n+        return Integer.parseInt(indexName.substring(numberIndex + 1, indexName.endsWith(\">\") ? indexName.length() - 1 :\n+            indexName.length()));\n+    }\n+\n+    public static final class Info implements ToXContentObject {\n+\n+        private final long currentActiveShardsCount;\n+        private final String targetActiveShardsCount;\n+        private final boolean enoughShardsActive;\n+        private final String message;\n+\n+        static final ParseField CURRENT_ACTIVE_SHARDS_COUNT = new ParseField(\"current_active_shards_count\");\n+        static final ParseField TARGET_ACTIVE_SHARDS_COUNT = new ParseField(\"target_active_shards_count\");\n+        static final ParseField ENOUGH_SHARDS_ACTIVE = new ParseField(\"enough_shards_active\");\n+        static final ParseField MESSAGE = new ParseField(\"message\");\n+        static final ConstructingObjectParser<Info, Void> PARSER = new ConstructingObjectParser<>(\"wait_for_active_shards_step_info\",", "originalCommit": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NzM5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368057397", "bodyText": "Minor nit, but we should keep these lowercase, and I don't think we need a trailing period (these are more like error messages than sentences)", "author": "dakrone", "createdAt": "2020-01-17T17:44:07Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);\n+            }\n+            rolledIndexName = rolledIndexMeta.getIndex().getName();\n+            waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        boolean enoughShardsActive = activeShardCount.enoughShardsActive(clusterState, rolledIndexName);\n+\n+        IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(rolledIndexName);\n+        int currentActiveShards = 0;\n+        for (final IntObjectCursor<IndexShardRoutingTable> shardRouting : indexRoutingTable.getShards()) {\n+            currentActiveShards += shardRouting.value.activeShards().size();\n+        }\n+        return new Result(enoughShardsActive, new Info(currentActiveShards, activeShardCount.toString(), enoughShardsActive));\n+    }\n+\n+    /**\n+     * Parses the number from the rolled over index name. It also supports the date-math format (ie. index name is wrapped in &lt; and &gt;)\n+     * <p>\n+     * Eg.\n+     * <p>\n+     * - For \"logs-000002\" it'll return 2\n+     * - For \"&lt;logs-{now/d}-3&gt;\" it'll return 3\n+     */\n+    static int parseIndexNameCounter(String indexName) {\n+        int numberIndex = indexName.lastIndexOf(\"-\");\n+        assert numberIndex != -1 : \"no separator '-' found\";\n+        return Integer.parseInt(indexName.substring(numberIndex + 1, indexName.endsWith(\">\") ? indexName.length() - 1 :\n+            indexName.length()));\n+    }\n+\n+    public static final class Info implements ToXContentObject {\n+\n+        private final long currentActiveShardsCount;\n+        private final String targetActiveShardsCount;\n+        private final boolean enoughShardsActive;\n+        private final String message;\n+\n+        static final ParseField CURRENT_ACTIVE_SHARDS_COUNT = new ParseField(\"current_active_shards_count\");\n+        static final ParseField TARGET_ACTIVE_SHARDS_COUNT = new ParseField(\"target_active_shards_count\");\n+        static final ParseField ENOUGH_SHARDS_ACTIVE = new ParseField(\"enough_shards_active\");\n+        static final ParseField MESSAGE = new ParseField(\"message\");\n+        static final ConstructingObjectParser<Info, Void> PARSER = new ConstructingObjectParser<>(\"wait_for_active_shards_step_info\",\n+            a -> new Info((long) a[0], (String) a[1], (boolean) a[2]));\n+\n+        static {\n+            PARSER.declareLong(ConstructingObjectParser.constructorArg(), CURRENT_ACTIVE_SHARDS_COUNT);\n+            PARSER.declareString(ConstructingObjectParser.constructorArg(), TARGET_ACTIVE_SHARDS_COUNT);\n+            PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), ENOUGH_SHARDS_ACTIVE);\n+            PARSER.declareString((i, s) -> {\n+            }, MESSAGE);\n+        }\n+\n+        public Info(long currentActiveShardsCount, String targetActiveShardsCount, boolean enoughShardsActive) {\n+            this.currentActiveShardsCount = currentActiveShardsCount;\n+            this.targetActiveShardsCount = targetActiveShardsCount;\n+            this.enoughShardsActive = enoughShardsActive;\n+\n+            if (enoughShardsActive) {\n+                message = \"The target of [\" + targetActiveShardsCount + \"] are active. Don't need to wait anymore.\";", "originalCommit": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NzQ1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368057457", "bodyText": "Same about lowercasing/trailing-period here.", "author": "dakrone", "createdAt": "2020-01-17T17:44:17Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);\n+            }\n+            rolledIndexName = rolledIndexMeta.getIndex().getName();\n+            waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        boolean enoughShardsActive = activeShardCount.enoughShardsActive(clusterState, rolledIndexName);\n+\n+        IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(rolledIndexName);\n+        int currentActiveShards = 0;\n+        for (final IntObjectCursor<IndexShardRoutingTable> shardRouting : indexRoutingTable.getShards()) {\n+            currentActiveShards += shardRouting.value.activeShards().size();\n+        }\n+        return new Result(enoughShardsActive, new Info(currentActiveShards, activeShardCount.toString(), enoughShardsActive));\n+    }\n+\n+    /**\n+     * Parses the number from the rolled over index name. It also supports the date-math format (ie. index name is wrapped in &lt; and &gt;)\n+     * <p>\n+     * Eg.\n+     * <p>\n+     * - For \"logs-000002\" it'll return 2\n+     * - For \"&lt;logs-{now/d}-3&gt;\" it'll return 3\n+     */\n+    static int parseIndexNameCounter(String indexName) {\n+        int numberIndex = indexName.lastIndexOf(\"-\");\n+        assert numberIndex != -1 : \"no separator '-' found\";\n+        return Integer.parseInt(indexName.substring(numberIndex + 1, indexName.endsWith(\">\") ? indexName.length() - 1 :\n+            indexName.length()));\n+    }\n+\n+    public static final class Info implements ToXContentObject {\n+\n+        private final long currentActiveShardsCount;\n+        private final String targetActiveShardsCount;\n+        private final boolean enoughShardsActive;\n+        private final String message;\n+\n+        static final ParseField CURRENT_ACTIVE_SHARDS_COUNT = new ParseField(\"current_active_shards_count\");\n+        static final ParseField TARGET_ACTIVE_SHARDS_COUNT = new ParseField(\"target_active_shards_count\");\n+        static final ParseField ENOUGH_SHARDS_ACTIVE = new ParseField(\"enough_shards_active\");\n+        static final ParseField MESSAGE = new ParseField(\"message\");\n+        static final ConstructingObjectParser<Info, Void> PARSER = new ConstructingObjectParser<>(\"wait_for_active_shards_step_info\",\n+            a -> new Info((long) a[0], (String) a[1], (boolean) a[2]));\n+\n+        static {\n+            PARSER.declareLong(ConstructingObjectParser.constructorArg(), CURRENT_ACTIVE_SHARDS_COUNT);\n+            PARSER.declareString(ConstructingObjectParser.constructorArg(), TARGET_ACTIVE_SHARDS_COUNT);\n+            PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), ENOUGH_SHARDS_ACTIVE);\n+            PARSER.declareString((i, s) -> {\n+            }, MESSAGE);\n+        }\n+\n+        public Info(long currentActiveShardsCount, String targetActiveShardsCount, boolean enoughShardsActive) {\n+            this.currentActiveShardsCount = currentActiveShardsCount;\n+            this.targetActiveShardsCount = targetActiveShardsCount;\n+            this.enoughShardsActive = enoughShardsActive;\n+\n+            if (enoughShardsActive) {\n+                message = \"The target of [\" + targetActiveShardsCount + \"] are active. Don't need to wait anymore.\";\n+            } else {\n+                message = \"Waiting for [\" + targetActiveShardsCount + \"] shards to become active, but only [\" + currentActiveShardsCount +", "originalCommit": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b838f3a6b32b076526ca038310f298f99b8d5626", "url": "https://github.com/elastic/elasticsearch/commit/b838f3a6b32b076526ca038310f298f99b8d5626", "message": "Use lower case and drop . in error messages", "committedDate": "2020-01-20T12:20:35Z", "type": "commit"}, {"oid": "444985353d95bf9ab1ef0f8f3d5fd5bea9295fb8", "url": "https://github.com/elastic/elasticsearch/commit/444985353d95bf9ab1ef0f8f3d5fd5bea9295fb8", "message": "Mark vars as final", "committedDate": "2020-01-20T12:20:35Z", "type": "commit"}, {"oid": "64c9f065cfed09c781acf8fb8866515759afe00a", "url": "https://github.com/elastic/elasticsearch/commit/64c9f065cfed09c781acf8fb8866515759afe00a", "message": "Add explicit error handling to parseIndexNameCounter", "committedDate": "2020-01-20T12:20:35Z", "type": "commit"}, {"oid": "9322665fd4fb46a2ba927f188f7d9b0f607e90d2", "url": "https://github.com/elastic/elasticsearch/commit/9322665fd4fb46a2ba927f188f7d9b0f607e90d2", "message": "Remove Parser", "committedDate": "2020-01-20T12:20:35Z", "type": "commit"}, {"oid": "36e07fc60e2e9d1b3ea4bea46a7d32be23f3884c", "url": "https://github.com/elastic/elasticsearch/commit/36e07fc60e2e9d1b3ea4bea46a7d32be23f3884c", "message": "Add Info object to report various step progress messages", "committedDate": "2020-01-20T12:20:35Z", "type": "commit"}, {"oid": "c0ecf31a35f3535602e7bfaabf4285a9c4440dc4", "url": "https://github.com/elastic/elasticsearch/commit/c0ecf31a35f3535602e7bfaabf4285a9c4440dc4", "message": "Make constructors default visible", "committedDate": "2020-01-20T12:54:35Z", "type": "commit"}, {"oid": "f4f2c84c5e3c3fb85f0a30463c5ec44675d407b1", "url": "https://github.com/elastic/elasticsearch/commit/f4f2c84c5e3c3fb85f0a30463c5ec44675d407b1", "message": "Merge branch 'master' into ilm-rollover-wait-for-active-shards", "committedDate": "2020-01-20T13:24:46Z", "type": "commit"}]}