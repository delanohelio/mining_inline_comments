{"pr_number": 51809, "pr_title": "EQL: Introduce basic execution pipeline", "pr_createdAt": "2020-02-03T13:13:45Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51809", "timeline": [{"oid": "b7bfb1e305fc315e1cd8d063bbbcbb504b62416b", "url": "https://github.com/elastic/elasticsearch/commit/b7bfb1e305fc315e1cd8d063bbbcbb504b62416b", "message": "EQL: Introduce basic execution pipeline\n\nThe main classes that form the 'execution' pipeline are added - most of\nthem have no functionality; the purpose of this PR is to add flesh out\nthe contract between the various moving parts so that work can start on\nthem independently.", "committedDate": "2020-02-03T13:10:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE2Njk1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51809#discussion_r374166955", "bodyText": "include message to hashCode and equals impl?", "author": "aleksmaus", "createdAt": "2020-02-03T15:27:43Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Failure.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.analysis;\n+\n+import org.elasticsearch.xpack.ql.tree.Node;\n+\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+\n+class Failure {\n+\n+    private final Node<?> node;\n+    private final String message;\n+\n+    Failure(Node<?> node, String message) {\n+        this.node = node;\n+        this.message = message;\n+    }\n+\n+    Node<?> node() {\n+        return node;\n+    }\n+\n+    String message() {\n+        return message;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(node);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+\n+        if (obj == null || getClass() != obj.getClass()) {\n+            return false;\n+        }\n+\n+        Failure other = (Failure) obj;\n+        return Objects.equals(node, other.node);\n+    }", "originalCommit": "b7bfb1e305fc315e1cd8d063bbbcbb504b62416b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3NDEyNw==", "url": "https://github.com/elastic/elasticsearch/pull/51809#discussion_r374174127", "bodyText": "nit: a bit deeply nested imho, not sure what are the current guidelines", "author": "aleksmaus", "createdAt": "2020-02-03T15:39:36Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Verifier.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.analysis;\n+\n+import org.elasticsearch.xpack.ql.capabilities.Unresolvable;\n+import org.elasticsearch.xpack.ql.expression.Attribute;\n+import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n+import org.elasticsearch.xpack.ql.plan.logical.LogicalPlan;\n+import org.elasticsearch.xpack.ql.tree.Node;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.xpack.eql.analysis.Failure.fail;\n+\n+/**\n+ * The verifier has the role of checking the analyzed tree for failures and build a list of failures following this check.\n+ * It is created in the plan executor along with the metrics instance passed as constructor parameter.\n+ */\n+public class Verifier {\n+\n+    public Map<Node<?>, String> verifyFailures(LogicalPlan plan) {\n+        Collection<Failure> failures = verify(plan);\n+        return failures.stream().collect(toMap(Failure::node, Failure::message));\n+    }\n+\n+    Collection<Failure> verify(LogicalPlan plan) {\n+        Set<Failure> failures = new LinkedHashSet<>();\n+\n+        // start bottom-up\n+        plan.forEachUp(p -> {\n+            if (p.analyzed()) {\n+                return;\n+            }\n+\n+            // if the children are unresolved, so will this node; counting it will only add noise\n+            if (p.childrenResolved() == false) {\n+                return;\n+            }\n+\n+            Set<Failure> localFailures = new LinkedHashSet<>();\n+\n+            if (p instanceof Unresolvable) {\n+                localFailures.add(fail(p, ((Unresolvable) p).unresolvedMessage()));\n+            } else {\n+                p.forEachExpressions(e -> {\n+                    // everything is fine, skip expression\n+                    if (e.resolved()) {\n+                        return;\n+                    }\n+\n+                    e.forEachUp(ae -> {\n+                        // we're only interested in the children\n+                        if (ae.childrenResolved() == false) {\n+                            return;\n+                        }\n+                        if (ae instanceof Unresolvable) {\n+                            // handle Attributes different to provide more context\n+                            if (ae instanceof UnresolvedAttribute) {\n+                                UnresolvedAttribute ua = (UnresolvedAttribute) ae;\n+                                // only work out the synonyms for raw unresolved attributes\n+                                if (ua.customMessage() == false) {\n+                                    boolean useQualifier = ua.qualifier() != null;\n+                                    List<String> potentialMatches = new ArrayList<>();\n+                                    for (Attribute a : p.inputSet()) {\n+                                        String nameCandidate = useQualifier ? a.qualifiedName() : a.name();\n+                                        // add only primitives (object types would only result in another error)\n+                                        if (DataTypes.isUnsupported(a.dataType()) == false && DataTypes.isPrimitive(a.dataType())) {\n+                                            potentialMatches.add(nameCandidate);\n+                                        }\n+                                    }\n+\n+                                    List<String> matches = StringUtils.findSimilar(ua.qualifiedName(), potentialMatches);\n+                                    if (matches.isEmpty() == false) {\n+                                        ae = ua.withUnresolvedMessage(UnresolvedAttribute.errorMessage(ua.qualifiedName(), matches));\n+                                    }\n+                                }\n+                            }\n+\n+                            localFailures.add(fail(ae, ((Unresolvable) ae).unresolvedMessage()));\n+                            return;\n+                        }\n+                        // type resolution\n+                        if (ae.typeResolved().unresolved()) {\n+                            localFailures.add(fail(ae, ae.typeResolved().message()));\n+                        }\n+\n+                    });\n+                });\n+            }\n+        });", "originalCommit": "b7bfb1e305fc315e1cd8d063bbbcbb504b62416b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE5NjEzNA==", "url": "https://github.com/elastic/elasticsearch/pull/51809#discussion_r374196134", "bodyText": "There are no limits on nesting - it's really a matter of styles. Due to the use of lambdas, some bits tend to be nested and improving that by extracting the code into methods doesn't always work especially when using a lot of variables...", "author": "costin", "createdAt": "2020-02-03T16:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3NDEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3NzU2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51809#discussion_r374177569", "bodyText": "probably address this TODO before merging to master?", "author": "aleksmaus", "createdAt": "2020-02-03T15:45:11Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/plugin/EqlPlugin.java", "diffHunk": "@@ -60,6 +87,11 @@ boolean isSnapshot() {\n         return Build.CURRENT.isSnapshot();\n     }\n \n+    // TODO: this needs to be used by all plugin methods - including getActions and createComponents", "originalCommit": "b7bfb1e305fc315e1cd8d063bbbcbb504b62416b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE5Njk0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51809#discussion_r374196947", "bodyText": "I don't think there's a way to do that currently - the solution is to have a constructor that accepts settings however we provide our settings after instantiation ...", "author": "costin", "createdAt": "2020-02-03T16:17:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3NzU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDExODQ1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51809#discussion_r374118451", "bodyText": "different -> differently", "author": "astefan", "createdAt": "2020-02-03T14:03:21Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Verifier.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.analysis;\n+\n+import org.elasticsearch.xpack.ql.capabilities.Unresolvable;\n+import org.elasticsearch.xpack.ql.expression.Attribute;\n+import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n+import org.elasticsearch.xpack.ql.plan.logical.LogicalPlan;\n+import org.elasticsearch.xpack.ql.tree.Node;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.xpack.eql.analysis.Failure.fail;\n+\n+/**\n+ * The verifier has the role of checking the analyzed tree for failures and build a list of failures following this check.\n+ * It is created in the plan executor along with the metrics instance passed as constructor parameter.\n+ */\n+public class Verifier {\n+\n+    public Map<Node<?>, String> verifyFailures(LogicalPlan plan) {\n+        Collection<Failure> failures = verify(plan);\n+        return failures.stream().collect(toMap(Failure::node, Failure::message));\n+    }\n+\n+    Collection<Failure> verify(LogicalPlan plan) {\n+        Set<Failure> failures = new LinkedHashSet<>();\n+\n+        // start bottom-up\n+        plan.forEachUp(p -> {\n+            if (p.analyzed()) {\n+                return;\n+            }\n+\n+            // if the children are unresolved, so will this node; counting it will only add noise\n+            if (p.childrenResolved() == false) {\n+                return;\n+            }\n+\n+            Set<Failure> localFailures = new LinkedHashSet<>();\n+\n+            if (p instanceof Unresolvable) {\n+                localFailures.add(fail(p, ((Unresolvable) p).unresolvedMessage()));\n+            } else {\n+                p.forEachExpressions(e -> {\n+                    // everything is fine, skip expression\n+                    if (e.resolved()) {\n+                        return;\n+                    }\n+\n+                    e.forEachUp(ae -> {\n+                        // we're only interested in the children\n+                        if (ae.childrenResolved() == false) {\n+                            return;\n+                        }\n+                        if (ae instanceof Unresolvable) {\n+                            // handle Attributes different to provide more context", "originalCommit": "b7bfb1e305fc315e1cd8d063bbbcbb504b62416b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE5NzQ5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51809#discussion_r374197499", "bodyText": "writableRegistry -> writeableRegistry", "author": "astefan", "createdAt": "2020-02-03T16:18:09Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/PlanExecutor.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.execution;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.io.stream.NamedWriteableRegistry;\n+import org.elasticsearch.xpack.eql.analysis.Analyzer;\n+import org.elasticsearch.xpack.eql.analysis.PreAnalyzer;\n+import org.elasticsearch.xpack.eql.analysis.Verifier;\n+import org.elasticsearch.xpack.eql.optimizer.Optimizer;\n+import org.elasticsearch.xpack.eql.planner.Planner;\n+import org.elasticsearch.xpack.eql.session.Configuration;\n+import org.elasticsearch.xpack.eql.session.EqlSession;\n+import org.elasticsearch.xpack.eql.session.Results;\n+import org.elasticsearch.xpack.ql.expression.function.FunctionRegistry;\n+import org.elasticsearch.xpack.ql.index.IndexResolver;\n+\n+import java.util.List;\n+\n+import static org.elasticsearch.action.ActionListener.wrap;\n+\n+public class PlanExecutor {\n+    private final Client client;\n+    private final NamedWriteableRegistry writableRegistry;", "originalCommit": "b7bfb1e305fc315e1cd8d063bbbcbb504b62416b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIxMjk0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51809#discussion_r374212946", "bodyText": "I'm on the fence here - the correct word is writable not writeable; not sure which way to go...", "author": "costin", "createdAt": "2020-02-03T16:44:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE5NzQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE5ODM2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51809#discussion_r374198366", "bodyText": "We are assuming that metrics will be passed in the constructor in the same way as SQL, right?", "author": "astefan", "createdAt": "2020-02-03T16:19:37Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Verifier.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.analysis;\n+\n+import org.elasticsearch.xpack.ql.capabilities.Unresolvable;\n+import org.elasticsearch.xpack.ql.expression.Attribute;\n+import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n+import org.elasticsearch.xpack.ql.plan.logical.LogicalPlan;\n+import org.elasticsearch.xpack.ql.tree.Node;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.xpack.eql.analysis.Failure.fail;\n+\n+/**\n+ * The verifier has the role of checking the analyzed tree for failures and build a list of failures following this check.\n+ * It is created in the plan executor along with the metrics instance passed as constructor parameter.", "originalCommit": "b7bfb1e305fc315e1cd8d063bbbcbb504b62416b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIxMzk1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51809#discussion_r374213951", "bodyText": "Correct as after the analyzer the type of query becomes clear.", "author": "costin", "createdAt": "2020-02-03T16:45:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE5ODM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIwODg4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51809#discussion_r374208882", "bodyText": "Is the clientId acting as a sticky session kind of identifier?", "author": "astefan", "createdAt": "2020-02-03T16:37:08Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/session/Configuration.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.session;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilder;\n+\n+import java.time.ZoneId;\n+\n+public class Configuration extends org.elasticsearch.xpack.ql.session.Configuration {\n+    \n+    private final String[] indices;\n+    private final TimeValue requestTimeout;\n+    private final String clientId;", "originalCommit": "b7bfb1e305fc315e1cd8d063bbbcbb504b62416b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIxMzYzNw==", "url": "https://github.com/elastic/elasticsearch/pull/51809#discussion_r374213637", "bodyText": "Not really sticky however I imagined it would be useful for metrics such as knowing whether we've been called by SIEM or some different entity.", "author": "costin", "createdAt": "2020-02-03T16:45:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIwODg4Mg=="}], "type": "inlineReview"}, {"oid": "cff5a4bd73972d767bdba3b289359349d81f9747", "url": "https://github.com/elastic/elasticsearch/commit/cff5a4bd73972d767bdba3b289359349d81f9747", "message": "Address feedback", "committedDate": "2020-02-03T16:45:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMwMzY2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51809#discussion_r374303667", "bodyText": "at some point, we'll also add join_keys and the other fields mentioned in the initial issue, but this is already good enough as a placeholder until then", "author": "rw-access", "createdAt": "2020-02-03T19:46:30Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/session/Sequence.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.session;\n+\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.search.SearchHit;\n+\n+import java.util.List;\n+\n+public class Sequence {\n+\n+    private final List<Tuple<Object, List<SearchHit>>> events;", "originalCommit": "cff5a4bd73972d767bdba3b289359349d81f9747", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMyOTUzMg==", "url": "https://github.com/elastic/elasticsearch/pull/51809#discussion_r374329532", "bodyText": "Right - the response will be fleshed out. For sequences I've added the join keys in the tuple under object (the response json is an array but the examples contain only one key).", "author": "costin", "createdAt": "2020-02-03T20:42:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMwMzY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMwNDAzMg==", "url": "https://github.com/elastic/elasticsearch/pull/51809#discussion_r374304032", "bodyText": "should this stay?\nalso, does this make sense for QL?", "author": "rw-access", "createdAt": "2020-02-03T19:47:16Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plan/physical/PhysicalPlan.java", "diffHunk": "@@ -13,12 +13,6 @@\n \n import java.util.List;\n \n-/**", "originalCommit": "cff5a4bd73972d767bdba3b289359349d81f9747", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMyOTcyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/51809#discussion_r374329729", "bodyText": "No, that's an accidental commit that needs removal.", "author": "costin", "createdAt": "2020-02-03T20:42:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMwNDAzMg=="}], "type": "inlineReview"}, {"oid": "6f504a040fc6b3bae63ce82676e16fb67058eaaf", "url": "https://github.com/elastic/elasticsearch/commit/6f504a040fc6b3bae63ce82676e16fb67058eaaf", "message": "Revert accidental changes", "committedDate": "2020-02-03T20:43:27Z", "type": "commit"}]}