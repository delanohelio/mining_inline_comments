{"pr_number": 51644, "pr_title": "[ML][Inference] stream inflate to parser + throw when byte limit is reached", "pr_createdAt": "2020-01-29T19:01:00Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51644", "timeline": [{"oid": "87284112ca22ef673ec56724f65b6635d34f26a2", "url": "https://github.com/elastic/elasticsearch/commit/87284112ca22ef673ec56724f65b6635d34f26a2", "message": "[ML][Inference] indicating when limit is reached, stream to parser", "committedDate": "2020-01-29T18:50:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgxNTY2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51644#discussion_r372815667", "bodyText": "Why is 10% a good number?", "author": "przemekwitek", "createdAt": "2020-01-30T08:35:08Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java", "diffHunk": "@@ -33,7 +34,10 @@\n  */\n public final class InferenceToXContentCompressor {\n     private static final int BUFFER_SIZE = 4096;\n-    private static final long MAX_INFLATED_BYTES = 1_000_000_000; // 1 gb maximum\n+    // Either 10% of the configured JVM heap, or 1 GB, which ever is smaller", "originalCommit": "87284112ca22ef673ec56724f65b6635d34f26a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1NjIwOA==", "url": "https://github.com/elastic/elasticsearch/pull/51644#discussion_r372856208", "bodyText": "Eventually we could have a dynamic limit that's integrated with the real memory circuit breaker (#31767).  Maybe we could reserve a percentage of free memory and use that as the dynamic limit for a given request, then give back that reservation after finding out the actual size required.  That's something to investigate for 7.7 or 7.8.\nHowever, I think 10% is an OK first step for 7.6 to reduce the risk of someone accidentally triggering an OOM on a node with a small heap.", "author": "droberts195", "createdAt": "2020-01-30T10:02:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgxNTY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgxNjEwNg==", "url": "https://github.com/elastic/elasticsearch/pull/51644#discussion_r372816106", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IOException(\"compressed stream is longer than maximum allowed bytes [\" + streamSize +\"]\");\n          \n          \n            \n                        throw new IOException(\"compressed stream is longer than maximum allowed bytes [\" + streamSize + \"]\");", "author": "przemekwitek", "createdAt": "2020-01-30T08:36:16Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java", "diffHunk": "@@ -45,29 +49,30 @@ private InferenceToXContentCompressor() {}\n     static <T> T inflate(String compressedString,\n                          CheckedFunction<XContentParser, T, IOException> parserFunction,\n                          NamedXContentRegistry xContentRegistry) throws IOException {\n-        try(XContentParser parser = XContentHelper.createParser(xContentRegistry,\n+        try(XContentParser parser = JsonXContent.jsonXContent.createParser(xContentRegistry,\n             LoggingDeprecationHandler.INSTANCE,\n-            inflate(compressedString, MAX_INFLATED_BYTES),\n-            XContentType.JSON)) {\n+            inflate(compressedString, MAX_INFLATED_BYTES))) {\n             return parserFunction.apply(parser);\n         }\n     }\n \n     static Map<String, Object> inflateToMap(String compressedString) throws IOException {\n         // Don't need the xcontent registry as we are not deflating named objects.\n-        try(XContentParser parser = XContentHelper.createParser(NamedXContentRegistry.EMPTY,\n+        try(XContentParser parser = JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY,\n             LoggingDeprecationHandler.INSTANCE,\n-            inflate(compressedString, MAX_INFLATED_BYTES),\n-            XContentType.JSON)) {\n+            inflate(compressedString, MAX_INFLATED_BYTES))) {\n             return parser.mapOrdered();\n         }\n     }\n \n-    static BytesReference inflate(String compressedString, long streamSize) throws IOException {\n+    static InputStream inflate(String compressedString, long streamSize) throws IOException {\n+        // If the compressed length is already too large, it make sense that the inflated length would be as well\n         byte[] compressedBytes = Base64.getDecoder().decode(compressedString.getBytes(StandardCharsets.UTF_8));\n+        if (compressedBytes.length > streamSize) {\n+            throw new IOException(\"compressed stream is longer than maximum allowed bytes [\" + streamSize +\"]\");", "originalCommit": "87284112ca22ef673ec56724f65b6635d34f26a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgxNjMzNg==", "url": "https://github.com/elastic/elasticsearch/pull/51644#discussion_r372816336", "bodyText": "Could you move this line after line 70 (compressedBytes) so that it is clearly visible that it refers to the if check?", "author": "przemekwitek", "createdAt": "2020-01-30T08:36:50Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java", "diffHunk": "@@ -45,29 +49,30 @@ private InferenceToXContentCompressor() {}\n     static <T> T inflate(String compressedString,\n                          CheckedFunction<XContentParser, T, IOException> parserFunction,\n                          NamedXContentRegistry xContentRegistry) throws IOException {\n-        try(XContentParser parser = XContentHelper.createParser(xContentRegistry,\n+        try(XContentParser parser = JsonXContent.jsonXContent.createParser(xContentRegistry,\n             LoggingDeprecationHandler.INSTANCE,\n-            inflate(compressedString, MAX_INFLATED_BYTES),\n-            XContentType.JSON)) {\n+            inflate(compressedString, MAX_INFLATED_BYTES))) {\n             return parserFunction.apply(parser);\n         }\n     }\n \n     static Map<String, Object> inflateToMap(String compressedString) throws IOException {\n         // Don't need the xcontent registry as we are not deflating named objects.\n-        try(XContentParser parser = XContentHelper.createParser(NamedXContentRegistry.EMPTY,\n+        try(XContentParser parser = JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY,\n             LoggingDeprecationHandler.INSTANCE,\n-            inflate(compressedString, MAX_INFLATED_BYTES),\n-            XContentType.JSON)) {\n+            inflate(compressedString, MAX_INFLATED_BYTES))) {\n             return parser.mapOrdered();\n         }\n     }\n \n-    static BytesReference inflate(String compressedString, long streamSize) throws IOException {\n+    static InputStream inflate(String compressedString, long streamSize) throws IOException {\n+        // If the compressed length is already too large, it make sense that the inflated length would be as well", "originalCommit": "87284112ca22ef673ec56724f65b6635d34f26a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgxNjcyNw==", "url": "https://github.com/elastic/elasticsearch/pull/51644#discussion_r372816727", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            throw new IOException(\"input stream exceeded maximum bytes of [\" + maxBytes +\"]\");\n          \n          \n            \n                            throw new IOException(\"input stream exceeded maximum bytes of [\" + maxBytes + \"]\");", "author": "przemekwitek", "createdAt": "2020-01-30T08:37:45Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/utils/SimpleBoundedInputStream.java", "diffHunk": "@@ -38,6 +39,9 @@ public SimpleBoundedInputStream(InputStream inputStream, long maxBytes) {\n     public int read() throws IOException {\n         // We have reached the maximum, signal stream completion.\n         if (numBytes >= maxBytes) {\n+            if (throwWhenExceeded) {\n+                throw new IOException(\"input stream exceeded maximum bytes of [\" + maxBytes +\"]\");", "originalCommit": "87284112ca22ef673ec56724f65b6635d34f26a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgxNjk4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51644#discussion_r372816981", "bodyText": "Why do we sometimes throw and sometimes return -1? Would it be possible to have only one exit point?", "author": "przemekwitek", "createdAt": "2020-01-30T08:38:19Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/utils/SimpleBoundedInputStream.java", "diffHunk": "@@ -38,6 +39,9 @@ public SimpleBoundedInputStream(InputStream inputStream, long maxBytes) {\n     public int read() throws IOException {\n         // We have reached the maximum, signal stream completion.\n         if (numBytes >= maxBytes) {\n+            if (throwWhenExceeded) {\n+                throw new IOException(\"input stream exceeded maximum bytes of [\" + maxBytes +\"]\");\n+            }\n             return -1;", "originalCommit": "87284112ca22ef673ec56724f65b6635d34f26a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1019208dac59e6be282fa5d966c9938871665e7e", "url": "https://github.com/elastic/elasticsearch/commit/1019208dac59e6be282fa5d966c9938871665e7e", "message": "addressing PR commens", "committedDate": "2020-01-30T12:12:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkxOTY3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51644#discussion_r372919677", "bodyText": "Should we also verify that the IOException has the message containing \"input stream exceeded maximum bytes\"?", "author": "przemekwitek", "createdAt": "2020-01-30T12:26:26Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressorTests.java", "diffHunk": "@@ -35,18 +31,11 @@ public void testInflateAndDeflate() throws IOException {\n     public void testInflateTooLargeStream() throws IOException {\n         TrainedModelDefinition definition = TrainedModelDefinitionTests.createRandomBuilder().build();\n         String firstDeflate = InferenceToXContentCompressor.deflate(definition);\n-        BytesReference inflatedBytes = InferenceToXContentCompressor.inflate(firstDeflate, 10L);\n-        assertThat(inflatedBytes.length(), equalTo(10));\n-        try(XContentParser parser = XContentHelper.createParser(xContentRegistry(),\n-            LoggingDeprecationHandler.INSTANCE,\n-            inflatedBytes,\n-            XContentType.JSON)) {\n-            expectThrows(IOException.class, () -> TrainedModelConfig.fromXContent(parser, true));\n-        }\n+        expectThrows(IOException.class, () -> Streams.readFully(InferenceToXContentCompressor.inflate(firstDeflate, 10L)));", "originalCommit": "1019208dac59e6be282fa5d966c9938871665e7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkyNzk1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51644#discussion_r372927951", "bodyText": "This comment isn't true in general.  If you compress a very small string then the compressed size is bigger than the original.  For example echo a | gzip -9 | wc -c returns 22.\nThe assumption is OK with the sort of streamSize values this method is going to be called with given the current code, so it's not essential to change now, but you could make it something like if (compressedBytes.length > Math.max(100L, streamSize)) in case it ever needs to cope with an extreme edge case in the future.\nAlso, it would be good to adjust the comment to acknowledge the edge case.", "author": "droberts195", "createdAt": "2020-01-30T12:48:12Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java", "diffHunk": "@@ -45,33 +49,33 @@ private InferenceToXContentCompressor() {}\n     static <T> T inflate(String compressedString,\n                          CheckedFunction<XContentParser, T, IOException> parserFunction,\n                          NamedXContentRegistry xContentRegistry) throws IOException {\n-        try(XContentParser parser = XContentHelper.createParser(xContentRegistry,\n+        try(XContentParser parser = JsonXContent.jsonXContent.createParser(xContentRegistry,\n             LoggingDeprecationHandler.INSTANCE,\n-            inflate(compressedString, MAX_INFLATED_BYTES),\n-            XContentType.JSON)) {\n+            inflate(compressedString, MAX_INFLATED_BYTES))) {\n             return parserFunction.apply(parser);\n         }\n     }\n \n     static Map<String, Object> inflateToMap(String compressedString) throws IOException {\n         // Don't need the xcontent registry as we are not deflating named objects.\n-        try(XContentParser parser = XContentHelper.createParser(NamedXContentRegistry.EMPTY,\n+        try(XContentParser parser = JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY,\n             LoggingDeprecationHandler.INSTANCE,\n-            inflate(compressedString, MAX_INFLATED_BYTES),\n-            XContentType.JSON)) {\n+            inflate(compressedString, MAX_INFLATED_BYTES))) {\n             return parser.mapOrdered();\n         }\n     }\n \n-    static BytesReference inflate(String compressedString, long streamSize) throws IOException {\n+    static InputStream inflate(String compressedString, long streamSize) throws IOException {\n         byte[] compressedBytes = Base64.getDecoder().decode(compressedString.getBytes(StandardCharsets.UTF_8));\n+        // If the compressed length is already too large, it make sense that the inflated length would be as well", "originalCommit": "1019208dac59e6be282fa5d966c9938871665e7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3456259f90d890cf71e4bb23a62ab12fe879b1e1", "url": "https://github.com/elastic/elasticsearch/commit/3456259f90d890cf71e4bb23a62ab12fe879b1e1", "message": "adjusting test and throw conditions", "committedDate": "2020-01-30T13:20:05Z", "type": "commit"}]}