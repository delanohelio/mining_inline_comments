{"pr_number": 50792, "pr_title": "SQL: Extend the optimisations for equalities", "pr_createdAt": "2020-01-09T13:57:50Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/50792", "timeline": [{"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "url": "https://github.com/elastic/elasticsearch/commit/59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "message": "Extend the optimizations for equalities\n\nThis commit supplements the optimisations of equalities in conjunctions\nand disjunctions:\n* for conjunctions, the existing optimizations with ranges are extended\nwith not-equalities and inequalities; these lead to a fast resolution,\nthe conjunction either being evaluate to a FALSE, or the non-equality\nconditions being dropped as superfluous;\n* optimisations for disjunctions are added to be applied against ranges,\ninequalities and not-equalities; these lead to disjunction either\nbecoming TRUE or the equality being dropped, either as superfluous or\nmerged into a range/inequality.", "committedDate": "2020-01-09T13:50:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE0Njc3NA==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365146774", "bodyText": "what does fr stand for? Can you expand the name to the full word?", "author": "costin", "createdAt": "2020-01-10T09:40:00Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -976,14 +979,20 @@ private Expression literalToTheRight(BinaryOperator<?, ?, ?, ?> be) {\n         protected Expression rule(Expression e) {\n             if (e instanceof And) {\n                 return propagate((And) e);\n+            } else if (e instanceof Or) {\n+                return propagate((Or) e);\n             }\n             return e;\n         }\n \n         // combine conjunction\n         private Expression propagate(And and) {\n             List<Range> ranges = new ArrayList<>();\n-            List<BinaryComparison> equals = new ArrayList<>();\n+            // Only equalities, not-equalities and inequalities with a foldable .right are extracted separately;\n+            // the others go into the general 'exps'.\n+            List<BinaryComparison> frEquals = new ArrayList<>();", "originalCommit": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE2NTA1NA==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365165054", "bodyText": "I see that fr comes from foldable right - I would remove the prefix since there's no foldable left and the collections are used for compacting or selecting the expressions.", "author": "costin", "createdAt": "2020-01-10T10:20:24Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop\n+        private Expression propagate(Or or) {\n+            List<Expression> exps = new ArrayList<>();\n+            List<Equals> frEquals = new ArrayList<>(); // foldable right term Equals", "originalCommit": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM4NDQ0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365384447", "bodyText": "Sure, removed it. I didn't like it either, tbh, but was trying to avoid the confusion as to why not all references of a certain type are part of the respective container.  But with the added comment (and code) it should be clear enough, indeed.", "author": "bpintea", "createdAt": "2020-01-10T19:03:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE2NTA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE2NjMwNA==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365166304", "bodyText": "Isn't this handled already by the folding rule  + BooleanSimplification?", "author": "costin", "createdAt": "2020-01-10T10:23:34Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop\n+        private Expression propagate(Or or) {\n+            List<Expression> exps = new ArrayList<>();\n+            List<Equals> frEquals = new ArrayList<>(); // foldable right term Equals\n+            List<NotEquals> frNotEquals = new ArrayList<>(); // foldable right term NotEquals\n+            List<Range> ranges = new ArrayList<>();\n+            List<BinaryComparison> frInequalities = new ArrayList<>(); // foldable right term (=limit) BinaryComparision\n+\n+            // split expressions by type\n+            for (Expression ex : Predicates.splitOr(or)) {", "originalCommit": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM4NDU4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365384581", "bodyText": "I believe it's not, no.\n(But I'll happily be corrected.)", "author": "bpintea", "createdAt": "2020-01-10T19:03:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE2NjMwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQwNjcwOA==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365406708", "bodyText": "Or at:\n\n  \n    \n      elasticsearch/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n    \n    \n         Line 838\n      in\n      54c1a59\n    \n    \n    \n    \n\n        \n          \n           if (bc instanceof Or) { \n        \n    \n  \n\n\nAnd at:\n\n  \n    \n      elasticsearch/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n    \n    \n         Line 809\n      in\n      54c1a59\n    \n    \n    \n    \n\n        \n          \n           if (FALSE.equals(l) || FALSE.equals(r)) { \n        \n    \n  \n\n\nThat is each individual and/or is evaluated if possible", "author": "costin", "createdAt": "2020-01-10T19:58:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE2NjMwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5NDY2MA==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365594660", "bodyText": "I had a look at that, but the simplification added by the code isn't covered there. Maybe that's what the // TODO: eliminate conjunction/disjunction was hinting to?\n(BTW and related to the last suggestions below, the comments (a || b) && (a || c) => a && (b || c) and (a && b) || (a && c) => a || (b & c) will also need fixing (the code does the right thing, though) -- I'll address this too.", "author": "bpintea", "createdAt": "2020-01-12T16:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE2NjMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE2NzcyNg==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365167726", "bodyText": "It's worth reviewing the code that does removal through position (for (int i = ...) { ranges.remove(i); } ) since it's incorrect as after a removal it skips the next item as the counter is not decremented.\nMoving that to use iterator removal is better (though more verbose).", "author": "costin", "createdAt": "2020-01-10T10:27:03Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop\n+        private Expression propagate(Or or) {\n+            List<Expression> exps = new ArrayList<>();\n+            List<Equals> frEquals = new ArrayList<>(); // foldable right term Equals\n+            List<NotEquals> frNotEquals = new ArrayList<>(); // foldable right term NotEquals\n+            List<Range> ranges = new ArrayList<>();\n+            List<BinaryComparison> frInequalities = new ArrayList<>(); // foldable right term (=limit) BinaryComparision\n+\n+            // split expressions by type\n+            for (Expression ex : Predicates.splitOr(or)) {\n+                if (ex instanceof Equals) {\n+                    Equals eq = (Equals) ex;\n+                    if (eq.right().foldable()) {\n+                        frEquals.add(eq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof NotEquals) {\n+                    NotEquals neq = (NotEquals) ex;\n+                    if (neq.right().foldable()) {\n+                        frNotEquals.add(neq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof Range) {\n+                    ranges.add((Range) ex);\n+                } else if (ex instanceof BinaryComparison) {\n+                    BinaryComparison bc = (BinaryComparison) ex;\n+                    if (bc.right().foldable()) {\n+                        frInequalities.add(bc);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else {\n+                    exps.add(ex);\n+                }\n+            }\n+\n+            boolean updated = false; // has the expression been modified?\n+\n+            // evaluate the impact of each Equal over the different types of Expressions\n+            for (Iterator<Equals> iterEq = frEquals.iterator(); iterEq.hasNext(); ) {\n+                Equals eq = iterEq.next();\n+\n+                // Equals OR NotEquals\n+                for (NotEquals neq : frNotEquals) {\n+                    if (eq.left().semanticEquals(neq.left())) { // a = 2 OR a != ? -> TRUE\n+                        return TRUE;\n+                    }\n+                }\n+\n+                Object eqValue = eq.right().fold();\n+\n+                // Equals OR Range\n+                for (int i = 0; i < ranges.size(); i ++) { // might modify list, so use index loop\n+                    Range range = ranges.get(i);\n+                    if (! eq.left().semanticEquals(range.value())) {\n+                        continue;\n+                    }\n+\n+                    Integer lowerComp = range.lower().foldable() ? BinaryComparison.compare(eqValue, range.lower().fold()) : null;\n+                    Integer upperComp = range.upper().foldable() ? BinaryComparison.compare(eqValue, range.upper().fold()) : null;\n+\n+                    if (lowerComp != null && lowerComp == 0 && !range.includeLower()) { // a = 2 OR 2 < a < ? -> 2 <= a < ?\n+                        iterEq.remove(); // update range with lower equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), true, range.upper(), range.includeUpper()));\n+                        updated = true;\n+                    } else if (upperComp != null && upperComp == 0 && !range.includeUpper()) { // a = 2 OR ? < a < 2 -> ? < a <= 2\n+                        iterEq.remove(); // update range with upper equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(), true));\n+                        updated = true;\n+                    } else if (lowerComp != null && upperComp != null) {\n+                        if (0 < lowerComp && upperComp < 0) { // a = 2 OR 1 < a < 3\n+                            iterEq.remove(); // equality is superfluous", "originalCommit": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM4NDYyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365384625", "bodyText": "Right, the ranges index-based looping doesn't do removals in the ranges lists, only updates at current index (for cases like a = 2 OR 2 < a < ? -> 2 <= a < ?); in this case, the removal is operated on the equals list, but that's done through the iterator.\n(But let me know please if I still miss something.)", "author": "bpintea", "createdAt": "2020-01-10T19:03:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE2NzcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQwODI2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365408263", "bodyText": "The removal since safe since it is followed by an add the iteration is not affected but inside CombineBinaryComparisons there are some removals that are not compensated for\n\n  \n    \n      elasticsearch/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n    \n    \n         Line 1138\n      in\n      54c1a59\n    \n    \n    \n    \n\n        \n          \n           bcs.remove(j); \n        \n    \n  \n\n\nwhich means the next entry in the bcs list might skipped.\nWorth reviewing (and documenting).\nBut that's a separate issue.", "author": "costin", "createdAt": "2020-01-10T20:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE2NzcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5NDY2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365594665", "bodyText": "Ah, I see. Sure, I'll address that in a separate issue.", "author": "bpintea", "createdAt": "2020-01-12T16:29:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE2NzcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExNTY1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365115652", "bodyText": "It took  me few seconds to determine what fr stands for. My personal preference is to name these variables as foldRightEq or foldRightEquals.", "author": "astefan", "createdAt": "2020-01-10T08:20:22Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -976,14 +979,20 @@ private Expression literalToTheRight(BinaryOperator<?, ?, ?, ?> be) {\n         protected Expression rule(Expression e) {\n             if (e instanceof And) {\n                 return propagate((And) e);\n+            } else if (e instanceof Or) {\n+                return propagate((Or) e);\n             }\n             return e;\n         }\n \n         // combine conjunction\n         private Expression propagate(And and) {\n             List<Range> ranges = new ArrayList<>();\n-            List<BinaryComparison> equals = new ArrayList<>();\n+            // Only equalities, not-equalities and inequalities with a foldable .right are extracted separately;\n+            // the others go into the general 'exps'.\n+            List<BinaryComparison> frEquals = new ArrayList<>();", "originalCommit": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM4NDY3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365384675", "bodyText": "Right, it wasn't a great solution.. I've gone ahead and adopted Costin's solution to simply remove the prefix. I've considered the foldableRight prefix, but thought that having it would slightly reduce the var distinguishability due to lenght (i.e. foldableRightEqual vs foldableRightNotEqual vs foldableRightInequalities etc.); and fold isn't super clear imo: foldable vs folded vs..?\nBut no strong feelings about it.", "author": "bpintea", "createdAt": "2020-01-10T19:04:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExNTY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIzMDY5OA==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365230698", "bodyText": "I think we prefer the eq.left().semanticEquals(bc.left()) == false format for better visibility.\nActually, I would have kept the same \"style\" as the previous conditional statements and not use continue, but the positive outcome of semanticEquals and include the following statements in a bigger if clause.", "author": "astefan", "createdAt": "2020-01-10T13:23:34Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {", "originalCommit": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM4NDcxNg==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365384716", "bodyText": "I think we prefer the eq.left().semanticEquals(bc.left()) == false format for better visibility.\n\nAh, correct, I think it's even in a guideline somewhere the format with just a variable.\n\nI would have kept the same \"style\" as the previous conditional statements and not use continue\n\nI find the more convoluted loops easier to read when flattened, but it's only a slight preference, so I've refactored it in this case.", "author": "bpintea", "createdAt": "2020-01-10T19:04:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIzMDY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIzMTM4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365231387", "bodyText": "Instead of eq.right().fold() you could have used eqValue, no?", "author": "astefan", "createdAt": "2020-01-10T13:25:29Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());", "originalCommit": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM4NDc0MA==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365384740", "bodyText": "Right! Thanks.", "author": "bpintea", "createdAt": "2020-01-10T19:04:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIzMTM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIzMzczMw==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365233733", "bodyText": "return changed == true ? Predicates......", "author": "astefan", "createdAt": "2020-01-10T13:31:02Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;", "originalCommit": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM4NDc2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365384765", "bodyText": "I'd keep this as is, inline with the style of the rest of the class (my change only affected the parameters passed to CollectionUtils.combine).", "author": "bpintea", "createdAt": "2020-01-10T19:04:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIzMzczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIzOTMyMg==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365239322", "bodyText": "Why is this evaluated to true right away?\nAn OR is translated in ES query DSL as a combination of two should statements for a bool query and saying field_x = 2 OR field_x != 4 translates into give me all documents that have field_x = 2 OR field_x != 4 which is in fact a collection of documents with field_x = 2 and documents with field_x != 4. I don't think that statement should be evaluated straight to TRUE, but simplified to field_x != 4.\nEvaluating it to TRUE means give me all documents.\nKeeping the OR as is means give me the docs with field_x != 4.\nThese two ^ are not equivalent.", "author": "astefan", "createdAt": "2020-01-10T13:44:31Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop\n+        private Expression propagate(Or or) {\n+            List<Expression> exps = new ArrayList<>();\n+            List<Equals> frEquals = new ArrayList<>(); // foldable right term Equals\n+            List<NotEquals> frNotEquals = new ArrayList<>(); // foldable right term NotEquals\n+            List<Range> ranges = new ArrayList<>();\n+            List<BinaryComparison> frInequalities = new ArrayList<>(); // foldable right term (=limit) BinaryComparision\n+\n+            // split expressions by type\n+            for (Expression ex : Predicates.splitOr(or)) {\n+                if (ex instanceof Equals) {\n+                    Equals eq = (Equals) ex;\n+                    if (eq.right().foldable()) {\n+                        frEquals.add(eq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof NotEquals) {\n+                    NotEquals neq = (NotEquals) ex;\n+                    if (neq.right().foldable()) {\n+                        frNotEquals.add(neq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof Range) {\n+                    ranges.add((Range) ex);\n+                } else if (ex instanceof BinaryComparison) {\n+                    BinaryComparison bc = (BinaryComparison) ex;\n+                    if (bc.right().foldable()) {\n+                        frInequalities.add(bc);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else {\n+                    exps.add(ex);\n+                }\n+            }\n+\n+            boolean updated = false; // has the expression been modified?\n+\n+            // evaluate the impact of each Equal over the different types of Expressions\n+            for (Iterator<Equals> iterEq = frEquals.iterator(); iterEq.hasNext(); ) {\n+                Equals eq = iterEq.next();\n+\n+                // Equals OR NotEquals\n+                for (NotEquals neq : frNotEquals) {\n+                    if (eq.left().semanticEquals(neq.left())) { // a = 2 OR a != ? -> TRUE", "originalCommit": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM4NDc5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365384796", "bodyText": "Good spot, thanks!\nThe TRUE is only valid if the disjunction terms refer the same value. I've fixed it.", "author": "bpintea", "createdAt": "2020-01-10T19:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIzOTMyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQwNTI3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365405272", "bodyText": "Please add a test to double check this is the case.", "author": "costin", "createdAt": "2020-01-10T19:55:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIzOTMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIzOTk5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365239997", "bodyText": "a = 2 OR a != 5 -> TRUE I think it's not right. Please, see above more details about this.", "author": "astefan", "createdAt": "2020-01-10T13:45:58Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop", "originalCommit": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQwNjgxNg==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365406816", "bodyText": "Indeed, thanks. Will update along the a = 2 OR a != 5 -> a != 5 change.", "author": "bpintea", "createdAt": "2020-01-10T19:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIzOTk5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI0Mjc4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365242786", "bodyText": "Same as above: == false instead of !.", "author": "astefan", "createdAt": "2020-01-10T13:52:25Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop\n+        private Expression propagate(Or or) {\n+            List<Expression> exps = new ArrayList<>();\n+            List<Equals> frEquals = new ArrayList<>(); // foldable right term Equals\n+            List<NotEquals> frNotEquals = new ArrayList<>(); // foldable right term NotEquals\n+            List<Range> ranges = new ArrayList<>();\n+            List<BinaryComparison> frInequalities = new ArrayList<>(); // foldable right term (=limit) BinaryComparision\n+\n+            // split expressions by type\n+            for (Expression ex : Predicates.splitOr(or)) {\n+                if (ex instanceof Equals) {\n+                    Equals eq = (Equals) ex;\n+                    if (eq.right().foldable()) {\n+                        frEquals.add(eq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof NotEquals) {\n+                    NotEquals neq = (NotEquals) ex;\n+                    if (neq.right().foldable()) {\n+                        frNotEquals.add(neq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof Range) {\n+                    ranges.add((Range) ex);\n+                } else if (ex instanceof BinaryComparison) {\n+                    BinaryComparison bc = (BinaryComparison) ex;\n+                    if (bc.right().foldable()) {\n+                        frInequalities.add(bc);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else {\n+                    exps.add(ex);\n+                }\n+            }\n+\n+            boolean updated = false; // has the expression been modified?\n+\n+            // evaluate the impact of each Equal over the different types of Expressions\n+            for (Iterator<Equals> iterEq = frEquals.iterator(); iterEq.hasNext(); ) {\n+                Equals eq = iterEq.next();\n+\n+                // Equals OR NotEquals\n+                for (NotEquals neq : frNotEquals) {\n+                    if (eq.left().semanticEquals(neq.left())) { // a = 2 OR a != ? -> TRUE\n+                        return TRUE;\n+                    }\n+                }\n+\n+                Object eqValue = eq.right().fold();\n+\n+                // Equals OR Range\n+                for (int i = 0; i < ranges.size(); i ++) { // might modify list, so use index loop\n+                    Range range = ranges.get(i);\n+                    if (! eq.left().semanticEquals(range.value())) {", "originalCommit": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM4NDgxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365384819", "bodyText": "Updated.", "author": "bpintea", "createdAt": "2020-01-10T19:04:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI0Mjc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI0OTM2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365249362", "bodyText": "== false", "author": "astefan", "createdAt": "2020-01-10T14:08:20Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop\n+        private Expression propagate(Or or) {\n+            List<Expression> exps = new ArrayList<>();\n+            List<Equals> frEquals = new ArrayList<>(); // foldable right term Equals\n+            List<NotEquals> frNotEquals = new ArrayList<>(); // foldable right term NotEquals\n+            List<Range> ranges = new ArrayList<>();\n+            List<BinaryComparison> frInequalities = new ArrayList<>(); // foldable right term (=limit) BinaryComparision\n+\n+            // split expressions by type\n+            for (Expression ex : Predicates.splitOr(or)) {\n+                if (ex instanceof Equals) {\n+                    Equals eq = (Equals) ex;\n+                    if (eq.right().foldable()) {\n+                        frEquals.add(eq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof NotEquals) {\n+                    NotEquals neq = (NotEquals) ex;\n+                    if (neq.right().foldable()) {\n+                        frNotEquals.add(neq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof Range) {\n+                    ranges.add((Range) ex);\n+                } else if (ex instanceof BinaryComparison) {\n+                    BinaryComparison bc = (BinaryComparison) ex;\n+                    if (bc.right().foldable()) {\n+                        frInequalities.add(bc);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else {\n+                    exps.add(ex);\n+                }\n+            }\n+\n+            boolean updated = false; // has the expression been modified?\n+\n+            // evaluate the impact of each Equal over the different types of Expressions\n+            for (Iterator<Equals> iterEq = frEquals.iterator(); iterEq.hasNext(); ) {\n+                Equals eq = iterEq.next();\n+\n+                // Equals OR NotEquals\n+                for (NotEquals neq : frNotEquals) {\n+                    if (eq.left().semanticEquals(neq.left())) { // a = 2 OR a != ? -> TRUE\n+                        return TRUE;\n+                    }\n+                }\n+\n+                Object eqValue = eq.right().fold();\n+\n+                // Equals OR Range\n+                for (int i = 0; i < ranges.size(); i ++) { // might modify list, so use index loop\n+                    Range range = ranges.get(i);\n+                    if (! eq.left().semanticEquals(range.value())) {\n+                        continue;\n+                    }\n+\n+                    Integer lowerComp = range.lower().foldable() ? BinaryComparison.compare(eqValue, range.lower().fold()) : null;\n+                    Integer upperComp = range.upper().foldable() ? BinaryComparison.compare(eqValue, range.upper().fold()) : null;\n+\n+                    if (lowerComp != null && lowerComp == 0 && !range.includeLower()) { // a = 2 OR 2 < a < ? -> 2 <= a < ?\n+                        iterEq.remove(); // update range with lower equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), true, range.upper(), range.includeUpper()));\n+                        updated = true;\n+                    } else if (upperComp != null && upperComp == 0 && !range.includeUpper()) { // a = 2 OR ? < a < 2 -> ? < a <= 2\n+                        iterEq.remove(); // update range with upper equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(), true));\n+                        updated = true;\n+                    } else if (lowerComp != null && upperComp != null) {\n+                        if (0 < lowerComp && upperComp < 0) { // a = 2 OR 1 < a < 3\n+                            iterEq.remove(); // equality is superfluous\n+                            updated = true;\n+                        }\n+                    }\n+                }\n+\n+                // Equals OR Inequality\n+                for (int i = 0; i < frInequalities.size(); i ++) {\n+                    BinaryComparison bc = frInequalities.get(i);\n+                    if (! eq.left().semanticEquals(bc.left())) {", "originalCommit": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM4NDg0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365384845", "bodyText": "Updated.", "author": "bpintea", "createdAt": "2020-01-10T19:04:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI0OTM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI1MDIyNw==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365250227", "bodyText": "The commented potential condition here - 0 < comp - is not entirely true. A potential else branch can also happen for bc instanceof GreaterThanOrEqual. I don't think it's changing the logic, but just saying.", "author": "astefan", "createdAt": "2020-01-10T14:10:19Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop\n+        private Expression propagate(Or or) {\n+            List<Expression> exps = new ArrayList<>();\n+            List<Equals> frEquals = new ArrayList<>(); // foldable right term Equals\n+            List<NotEquals> frNotEquals = new ArrayList<>(); // foldable right term NotEquals\n+            List<Range> ranges = new ArrayList<>();\n+            List<BinaryComparison> frInequalities = new ArrayList<>(); // foldable right term (=limit) BinaryComparision\n+\n+            // split expressions by type\n+            for (Expression ex : Predicates.splitOr(or)) {\n+                if (ex instanceof Equals) {\n+                    Equals eq = (Equals) ex;\n+                    if (eq.right().foldable()) {\n+                        frEquals.add(eq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof NotEquals) {\n+                    NotEquals neq = (NotEquals) ex;\n+                    if (neq.right().foldable()) {\n+                        frNotEquals.add(neq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof Range) {\n+                    ranges.add((Range) ex);\n+                } else if (ex instanceof BinaryComparison) {\n+                    BinaryComparison bc = (BinaryComparison) ex;\n+                    if (bc.right().foldable()) {\n+                        frInequalities.add(bc);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else {\n+                    exps.add(ex);\n+                }\n+            }\n+\n+            boolean updated = false; // has the expression been modified?\n+\n+            // evaluate the impact of each Equal over the different types of Expressions\n+            for (Iterator<Equals> iterEq = frEquals.iterator(); iterEq.hasNext(); ) {\n+                Equals eq = iterEq.next();\n+\n+                // Equals OR NotEquals\n+                for (NotEquals neq : frNotEquals) {\n+                    if (eq.left().semanticEquals(neq.left())) { // a = 2 OR a != ? -> TRUE\n+                        return TRUE;\n+                    }\n+                }\n+\n+                Object eqValue = eq.right().fold();\n+\n+                // Equals OR Range\n+                for (int i = 0; i < ranges.size(); i ++) { // might modify list, so use index loop\n+                    Range range = ranges.get(i);\n+                    if (! eq.left().semanticEquals(range.value())) {\n+                        continue;\n+                    }\n+\n+                    Integer lowerComp = range.lower().foldable() ? BinaryComparison.compare(eqValue, range.lower().fold()) : null;\n+                    Integer upperComp = range.upper().foldable() ? BinaryComparison.compare(eqValue, range.upper().fold()) : null;\n+\n+                    if (lowerComp != null && lowerComp == 0 && !range.includeLower()) { // a = 2 OR 2 < a < ? -> 2 <= a < ?\n+                        iterEq.remove(); // update range with lower equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), true, range.upper(), range.includeUpper()));\n+                        updated = true;\n+                    } else if (upperComp != null && upperComp == 0 && !range.includeUpper()) { // a = 2 OR ? < a < 2 -> ? < a <= 2\n+                        iterEq.remove(); // update range with upper equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(), true));\n+                        updated = true;\n+                    } else if (lowerComp != null && upperComp != null) {\n+                        if (0 < lowerComp && upperComp < 0) { // a = 2 OR 1 < a < 3\n+                            iterEq.remove(); // equality is superfluous\n+                            updated = true;\n+                        }\n+                    }\n+                }\n+\n+                // Equals OR Inequality\n+                for (int i = 0; i < frInequalities.size(); i ++) {\n+                    BinaryComparison bc = frInequalities.get(i);\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer comp = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (comp == null) {\n+                        continue;\n+                    }\n+                    if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) {\n+                        if (comp < 0) { // a = 1 OR a > 2 -> nop\n+                            continue;\n+                        } else if (comp == 0 && bc instanceof GreaterThan) { // a = 2 OR a > 2 -> a >= 2\n+                                frInequalities.set(i, new GreaterThanOrEqual(bc.source(), bc.left(), bc.right()));\n+                        } // else (0 < comp) : // a = 3 OR a > 2 -> a > 2", "originalCommit": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM4NDg3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365384879", "bodyText": "Right, better be thorough also in comments. Fixed in both affected places.", "author": "bpintea", "createdAt": "2020-01-10T19:04:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI1MDIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI1MTkyOA==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365251928", "bodyText": "Can you, please, be consistent in the code format? The previous if branch used (comp < 0) and then else if. In this one you are switching places between variable and constant and there is no else.", "author": "astefan", "createdAt": "2020-01-10T14:13:57Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop\n+        private Expression propagate(Or or) {\n+            List<Expression> exps = new ArrayList<>();\n+            List<Equals> frEquals = new ArrayList<>(); // foldable right term Equals\n+            List<NotEquals> frNotEquals = new ArrayList<>(); // foldable right term NotEquals\n+            List<Range> ranges = new ArrayList<>();\n+            List<BinaryComparison> frInequalities = new ArrayList<>(); // foldable right term (=limit) BinaryComparision\n+\n+            // split expressions by type\n+            for (Expression ex : Predicates.splitOr(or)) {\n+                if (ex instanceof Equals) {\n+                    Equals eq = (Equals) ex;\n+                    if (eq.right().foldable()) {\n+                        frEquals.add(eq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof NotEquals) {\n+                    NotEquals neq = (NotEquals) ex;\n+                    if (neq.right().foldable()) {\n+                        frNotEquals.add(neq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof Range) {\n+                    ranges.add((Range) ex);\n+                } else if (ex instanceof BinaryComparison) {\n+                    BinaryComparison bc = (BinaryComparison) ex;\n+                    if (bc.right().foldable()) {\n+                        frInequalities.add(bc);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else {\n+                    exps.add(ex);\n+                }\n+            }\n+\n+            boolean updated = false; // has the expression been modified?\n+\n+            // evaluate the impact of each Equal over the different types of Expressions\n+            for (Iterator<Equals> iterEq = frEquals.iterator(); iterEq.hasNext(); ) {\n+                Equals eq = iterEq.next();\n+\n+                // Equals OR NotEquals\n+                for (NotEquals neq : frNotEquals) {\n+                    if (eq.left().semanticEquals(neq.left())) { // a = 2 OR a != ? -> TRUE\n+                        return TRUE;\n+                    }\n+                }\n+\n+                Object eqValue = eq.right().fold();\n+\n+                // Equals OR Range\n+                for (int i = 0; i < ranges.size(); i ++) { // might modify list, so use index loop\n+                    Range range = ranges.get(i);\n+                    if (! eq.left().semanticEquals(range.value())) {\n+                        continue;\n+                    }\n+\n+                    Integer lowerComp = range.lower().foldable() ? BinaryComparison.compare(eqValue, range.lower().fold()) : null;\n+                    Integer upperComp = range.upper().foldable() ? BinaryComparison.compare(eqValue, range.upper().fold()) : null;\n+\n+                    if (lowerComp != null && lowerComp == 0 && !range.includeLower()) { // a = 2 OR 2 < a < ? -> 2 <= a < ?\n+                        iterEq.remove(); // update range with lower equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), true, range.upper(), range.includeUpper()));\n+                        updated = true;\n+                    } else if (upperComp != null && upperComp == 0 && !range.includeUpper()) { // a = 2 OR ? < a < 2 -> ? < a <= 2\n+                        iterEq.remove(); // update range with upper equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(), true));\n+                        updated = true;\n+                    } else if (lowerComp != null && upperComp != null) {\n+                        if (0 < lowerComp && upperComp < 0) { // a = 2 OR 1 < a < 3\n+                            iterEq.remove(); // equality is superfluous\n+                            updated = true;\n+                        }\n+                    }\n+                }\n+\n+                // Equals OR Inequality\n+                for (int i = 0; i < frInequalities.size(); i ++) {\n+                    BinaryComparison bc = frInequalities.get(i);\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer comp = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (comp == null) {\n+                        continue;\n+                    }\n+                    if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) {\n+                        if (comp < 0) { // a = 1 OR a > 2 -> nop\n+                            continue;\n+                        } else if (comp == 0 && bc instanceof GreaterThan) { // a = 2 OR a > 2 -> a >= 2\n+                                frInequalities.set(i, new GreaterThanOrEqual(bc.source(), bc.left(), bc.right()));\n+                        } // else (0 < comp) : // a = 3 OR a > 2 -> a > 2\n+                        iterEq.remove(); // update range with equality instead or simply superfluous\n+                        updated = true;\n+                    } else if (bc instanceof LessThan || bc instanceof LessThanOrEqual) {\n+                        if (0 < comp) { // a = 2 OR a < 1 -> nop", "originalCommit": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM4NDk2OA==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365384968", "bodyText": "I generally prefer the \"0x axis\" spacial ordering for faster understanding - the same reason why ranges are mostly given like a < X < b and less so the other way around -, but I've updated the ordering here.", "author": "bpintea", "createdAt": "2020-01-10T19:04:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI1MTkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI1MjIxMA==", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365252210", "bodyText": "updated == true ? Predicates.....", "author": "astefan", "createdAt": "2020-01-10T14:14:37Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop\n+        private Expression propagate(Or or) {\n+            List<Expression> exps = new ArrayList<>();\n+            List<Equals> frEquals = new ArrayList<>(); // foldable right term Equals\n+            List<NotEquals> frNotEquals = new ArrayList<>(); // foldable right term NotEquals\n+            List<Range> ranges = new ArrayList<>();\n+            List<BinaryComparison> frInequalities = new ArrayList<>(); // foldable right term (=limit) BinaryComparision\n+\n+            // split expressions by type\n+            for (Expression ex : Predicates.splitOr(or)) {\n+                if (ex instanceof Equals) {\n+                    Equals eq = (Equals) ex;\n+                    if (eq.right().foldable()) {\n+                        frEquals.add(eq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof NotEquals) {\n+                    NotEquals neq = (NotEquals) ex;\n+                    if (neq.right().foldable()) {\n+                        frNotEquals.add(neq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof Range) {\n+                    ranges.add((Range) ex);\n+                } else if (ex instanceof BinaryComparison) {\n+                    BinaryComparison bc = (BinaryComparison) ex;\n+                    if (bc.right().foldable()) {\n+                        frInequalities.add(bc);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else {\n+                    exps.add(ex);\n+                }\n+            }\n+\n+            boolean updated = false; // has the expression been modified?\n+\n+            // evaluate the impact of each Equal over the different types of Expressions\n+            for (Iterator<Equals> iterEq = frEquals.iterator(); iterEq.hasNext(); ) {\n+                Equals eq = iterEq.next();\n+\n+                // Equals OR NotEquals\n+                for (NotEquals neq : frNotEquals) {\n+                    if (eq.left().semanticEquals(neq.left())) { // a = 2 OR a != ? -> TRUE\n+                        return TRUE;\n+                    }\n+                }\n+\n+                Object eqValue = eq.right().fold();\n+\n+                // Equals OR Range\n+                for (int i = 0; i < ranges.size(); i ++) { // might modify list, so use index loop\n+                    Range range = ranges.get(i);\n+                    if (! eq.left().semanticEquals(range.value())) {\n+                        continue;\n+                    }\n+\n+                    Integer lowerComp = range.lower().foldable() ? BinaryComparison.compare(eqValue, range.lower().fold()) : null;\n+                    Integer upperComp = range.upper().foldable() ? BinaryComparison.compare(eqValue, range.upper().fold()) : null;\n+\n+                    if (lowerComp != null && lowerComp == 0 && !range.includeLower()) { // a = 2 OR 2 < a < ? -> 2 <= a < ?\n+                        iterEq.remove(); // update range with lower equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), true, range.upper(), range.includeUpper()));\n+                        updated = true;\n+                    } else if (upperComp != null && upperComp == 0 && !range.includeUpper()) { // a = 2 OR ? < a < 2 -> ? < a <= 2\n+                        iterEq.remove(); // update range with upper equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(), true));\n+                        updated = true;\n+                    } else if (lowerComp != null && upperComp != null) {\n+                        if (0 < lowerComp && upperComp < 0) { // a = 2 OR 1 < a < 3\n+                            iterEq.remove(); // equality is superfluous\n+                            updated = true;\n+                        }\n+                    }\n+                }\n+\n+                // Equals OR Inequality\n+                for (int i = 0; i < frInequalities.size(); i ++) {\n+                    BinaryComparison bc = frInequalities.get(i);\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer comp = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (comp == null) {\n+                        continue;\n+                    }\n+                    if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) {\n+                        if (comp < 0) { // a = 1 OR a > 2 -> nop\n+                            continue;\n+                        } else if (comp == 0 && bc instanceof GreaterThan) { // a = 2 OR a > 2 -> a >= 2\n+                                frInequalities.set(i, new GreaterThanOrEqual(bc.source(), bc.left(), bc.right()));\n+                        } // else (0 < comp) : // a = 3 OR a > 2 -> a > 2\n+                        iterEq.remove(); // update range with equality instead or simply superfluous\n+                        updated = true;\n+                    } else if (bc instanceof LessThan || bc instanceof LessThanOrEqual) {\n+                        if (0 < comp) { // a = 2 OR a < 1 -> nop\n+                            continue;\n+                        }\n+                        if (comp == 0 && bc instanceof LessThan) { // a = 2 OR a < 2 -> a <= 2\n+                            frInequalities.set(i, new LessThanOrEqual(bc.source(), bc.left(), bc.right()));\n+                        } // else (comp < 0) { // a = 2 OR a < 3 -> a < 3\n+                        iterEq.remove(); // update range with equality instead or simply superfluous\n+                        updated = true;\n+                    }\n+                }\n             }\n \n-            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, equals, ranges)) : and;\n+            return updated ? Predicates.combineOr(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : or;", "originalCommit": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3eee6ca7fe483d89a73ec2bcd643127abf6f3b63", "url": "https://github.com/elastic/elasticsearch/commit/3eee6ca7fe483d89a73ec2bcd643127abf6f3b63", "message": "Adress review notes\n\n* Fix the bug around wrongly optimizing 'a=2 OR a!=?', which only yields\nTRUE for same values in equality and inequality.\n* Var renamings, code style adjustments, comments corrections.", "committedDate": "2020-01-10T18:58:58Z", "type": "commit"}, {"oid": "55da0357054b1d2e25a15f41fe5d5267bdf7d106", "url": "https://github.com/elastic/elasticsearch/commit/55da0357054b1d2e25a15f41fe5d5267bdf7d106", "message": "Address further review comments. Extend optim.\n\n- fix a few code comments;\n- extend the Equals OR NotEquals optimitsation (a=2 OR a!=5 -> a!=5);\n- extend the Equals OR Range optimisation on limits equality (a=2 OR\n  2<=a<5 -> 2<=a<5);\n- in case an equality is being removed in a conjunction, the rest of\n  possible optimisations to test is now skipped.", "committedDate": "2020-01-13T14:47:24Z", "type": "commit"}, {"oid": "cab0248b3614842579f0222e45ae049349f220bf", "url": "https://github.com/elastic/elasticsearch/commit/cab0248b3614842579f0222e45ae049349f220bf", "message": "rename one var for better legiblity\n\n- s/rmEqual/removeEquals", "committedDate": "2020-01-13T16:32:12Z", "type": "commit"}, {"oid": "7755d1df079d2b230d7941be60fbd128c982770a", "url": "https://github.com/elastic/elasticsearch/commit/7755d1df079d2b230d7941be60fbd128c982770a", "message": "Merge remote-tracking branch 'upstream/master' into enh/propagate-equals-optimisations", "committedDate": "2020-01-13T19:24:16Z", "type": "commit"}]}