{"pr_number": 51986, "pr_title": "[Doc] migration guide joda", "pr_createdAt": "2020-02-06T09:59:29Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51986", "timeline": [{"oid": "89d6cf63e52c5346dd1e235690e23ace75696e4e", "url": "https://github.com/elastic/elasticsearch/commit/89d6cf63e52c5346dd1e235690e23ace75696e4e", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:09:20Z", "type": "commit"}, {"oid": "5ca94dcdb86619d2ea7db6b97cc757088fd8e7ab", "url": "https://github.com/elastic/elasticsearch/commit/5ca94dcdb86619d2ea7db6b97cc757088fd8e7ab", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:09:36Z", "type": "commit"}, {"oid": "f6a3096d6cc3e38cdb82b488a12b609cd510fa70", "url": "https://github.com/elastic/elasticsearch/commit/f6a3096d6cc3e38cdb82b488a12b609cd510fa70", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:11:09Z", "type": "commit"}, {"oid": "170a75be62e874891d6ad6a78f2e745d069f80de", "url": "https://github.com/elastic/elasticsearch/commit/170a75be62e874891d6ad6a78f2e745d069f80de", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:11:27Z", "type": "commit"}, {"oid": "48d8188903eddce0ba8755cf411bf497250719f7", "url": "https://github.com/elastic/elasticsearch/commit/48d8188903eddce0ba8755cf411bf497250719f7", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:11:42Z", "type": "commit"}, {"oid": "d230fcd6cb57c220f8f1a7eddf1aec98688547dd", "url": "https://github.com/elastic/elasticsearch/commit/d230fcd6cb57c220f8f1a7eddf1aec98688547dd", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:12:16Z", "type": "commit"}, {"oid": "a6fb10da60a3873e0f6f6edd360cc85e24ae7034", "url": "https://github.com/elastic/elasticsearch/commit/a6fb10da60a3873e0f6f6edd360cc85e24ae7034", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:13:14Z", "type": "commit"}, {"oid": "5dda7d070d0b6ddc7e6ecddd8a97fbbab1616109", "url": "https://github.com/elastic/elasticsearch/commit/5dda7d070d0b6ddc7e6ecddd8a97fbbab1616109", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:13:26Z", "type": "commit"}, {"oid": "6ecee5cc65d073b1c91006a09d7c38ccd4ed853e", "url": "https://github.com/elastic/elasticsearch/commit/6ecee5cc65d073b1c91006a09d7c38ccd4ed853e", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:13:48Z", "type": "commit"}, {"oid": "83f36f7befa18de744c555c6ad67f580094e49cc", "url": "https://github.com/elastic/elasticsearch/commit/83f36f7befa18de744c555c6ad67f580094e49cc", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:14:02Z", "type": "commit"}, {"oid": "fcd382ae6f480c73a8330ed36393504a1dadb5ab", "url": "https://github.com/elastic/elasticsearch/commit/fcd382ae6f480c73a8330ed36393504a1dadb5ab", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:14:26Z", "type": "commit"}, {"oid": "0469410061b8bfbe3d8527a1a3a3276e013ce0f5", "url": "https://github.com/elastic/elasticsearch/commit/0469410061b8bfbe3d8527a1a3a3276e013ce0f5", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:15:25Z", "type": "commit"}, {"oid": "ec542859de1b6e8816e538c095b887d72513ca40", "url": "https://github.com/elastic/elasticsearch/commit/ec542859de1b6e8816e538c095b887d72513ca40", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:36:32Z", "type": "commit"}, {"oid": "2967f132169c8acb7d871a311931822515f82114", "url": "https://github.com/elastic/elasticsearch/commit/2967f132169c8acb7d871a311931822515f82114", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:36:44Z", "type": "commit"}, {"oid": "e0c325297a8df215c7a8e066616da835b2611da6", "url": "https://github.com/elastic/elasticsearch/commit/e0c325297a8df215c7a8e066616da835b2611da6", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:38:02Z", "type": "commit"}, {"oid": "552f4cb2a8b36b814d9dafb9842be6015bcaff25", "url": "https://github.com/elastic/elasticsearch/commit/552f4cb2a8b36b814d9dafb9842be6015bcaff25", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:38:31Z", "type": "commit"}, {"oid": "b9860708011aadfdc9b922094b7515c50609c6b3", "url": "https://github.com/elastic/elasticsearch/commit/b9860708011aadfdc9b922094b7515c50609c6b3", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:38:49Z", "type": "commit"}, {"oid": "6d7e2c243be9159e516a2d1cd259a6f24c753f16", "url": "https://github.com/elastic/elasticsearch/commit/6d7e2c243be9159e516a2d1cd259a6f24c753f16", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:39:48Z", "type": "commit"}, {"oid": "0e99c3cebf30d5eda10040b01ababbe0c5061534", "url": "https://github.com/elastic/elasticsearch/commit/0e99c3cebf30d5eda10040b01ababbe0c5061534", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:40:13Z", "type": "commit"}, {"oid": "49bb8a408cdf8da99e20770d2d314f7f951825cc", "url": "https://github.com/elastic/elasticsearch/commit/49bb8a408cdf8da99e20770d2d314f7f951825cc", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:40:27Z", "type": "commit"}, {"oid": "4b231f76aef78c3631be08ff51ae91fe25c5a91c", "url": "https://github.com/elastic/elasticsearch/commit/4b231f76aef78c3631be08ff51ae91fe25c5a91c", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:40:49Z", "type": "commit"}, {"oid": "232d6b30a5d8abcf2501e1dfc84c871c33e87b24", "url": "https://github.com/elastic/elasticsearch/commit/232d6b30a5d8abcf2501e1dfc84c871c33e87b24", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:41:01Z", "type": "commit"}, {"oid": "92690fd15a355e4f14cbbf9ce7c6ebe50b2295da", "url": "https://github.com/elastic/elasticsearch/commit/92690fd15a355e4f14cbbf9ce7c6ebe50b2295da", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:55:31Z", "type": "commit"}, {"oid": "a482a7146e43d9c0f945dd7416e6d9ac1224d57e", "url": "https://github.com/elastic/elasticsearch/commit/a482a7146e43d9c0f945dd7416e6d9ac1224d57e", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:56:51Z", "type": "commit"}, {"oid": "78acb559e5ccdb08232b24c0bcc7d416dc0ae87e", "url": "https://github.com/elastic/elasticsearch/commit/78acb559e5ccdb08232b24c0bcc7d416dc0ae87e", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T11:01:43Z", "type": "commit"}, {"oid": "cd0c386b3d166c1c4e71863695adcddf849db9f0", "url": "https://github.com/elastic/elasticsearch/commit/cd0c386b3d166c1c4e71863695adcddf849db9f0", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T11:21:57Z", "type": "commit"}, {"oid": "9229af272f920507d990b420904fc8657efb1089", "url": "https://github.com/elastic/elasticsearch/commit/9229af272f920507d990b420904fc8657efb1089", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T11:22:10Z", "type": "commit"}, {"oid": "d7fb5ab91993d558ccb1647adffe0179ee7a693c", "url": "https://github.com/elastic/elasticsearch/commit/d7fb5ab91993d558ccb1647adffe0179ee7a693c", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T11:22:33Z", "type": "commit"}, {"oid": "22ea0f5aeb7dc41e7f76fee51a2c9ee7a9deac3c", "url": "https://github.com/elastic/elasticsearch/commit/22ea0f5aeb7dc41e7f76fee51a2c9ee7a9deac3c", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T11:23:31Z", "type": "commit"}, {"oid": "7f7881a5580300913b531f06e3630f7c3e8497cb", "url": "https://github.com/elastic/elasticsearch/commit/7f7881a5580300913b531f06e3630f7c3e8497cb", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:03:13Z", "type": "commit"}, {"oid": "fc42904a60fd6426bdf5f6b41121742cc33e11a6", "url": "https://github.com/elastic/elasticsearch/commit/fc42904a60fd6426bdf5f6b41121742cc33e11a6", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:03:27Z", "type": "commit"}, {"oid": "8d64851bf7733f551b5ae0ca56b63d79c44323ad", "url": "https://github.com/elastic/elasticsearch/commit/8d64851bf7733f551b5ae0ca56b63d79c44323ad", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:04:41Z", "type": "commit"}, {"oid": "268a8946a3d9f41792f66048d5a2cf831146507e", "url": "https://github.com/elastic/elasticsearch/commit/268a8946a3d9f41792f66048d5a2cf831146507e", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:04:53Z", "type": "commit"}, {"oid": "08a674851f0046aec198d520b0804b8fa7c6752c", "url": "https://github.com/elastic/elasticsearch/commit/08a674851f0046aec198d520b0804b8fa7c6752c", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:05:16Z", "type": "commit"}, {"oid": "314d68f2dd85daedae603540d2159ab023240386", "url": "https://github.com/elastic/elasticsearch/commit/314d68f2dd85daedae603540d2159ab023240386", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:06:03Z", "type": "commit"}, {"oid": "183725bd21f6ec3f247b99d8906b527f64197a51", "url": "https://github.com/elastic/elasticsearch/commit/183725bd21f6ec3f247b99d8906b527f64197a51", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:13:25Z", "type": "commit"}, {"oid": "8074844089ac5811225f6fb25611a71e4eda3bee", "url": "https://github.com/elastic/elasticsearch/commit/8074844089ac5811225f6fb25611a71e4eda3bee", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:13:45Z", "type": "commit"}, {"oid": "864a4981ea16a1e496b2ebbc8125eefe19eaac28", "url": "https://github.com/elastic/elasticsearch/commit/864a4981ea16a1e496b2ebbc8125eefe19eaac28", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:15:34Z", "type": "commit"}, {"oid": "a4f7c239b1d69bec81d6e531b9b65a844bedffbf", "url": "https://github.com/elastic/elasticsearch/commit/a4f7c239b1d69bec81d6e531b9b65a844bedffbf", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:15:53Z", "type": "commit"}, {"oid": "300e800eb2df034902d3ba74550e454aadebe709", "url": "https://github.com/elastic/elasticsearch/commit/300e800eb2df034902d3ba74550e454aadebe709", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:16:16Z", "type": "commit"}, {"oid": "23af7e0e02e3ddc5e72cda5a743c47ccdb9ab89f", "url": "https://github.com/elastic/elasticsearch/commit/23af7e0e02e3ddc5e72cda5a743c47ccdb9ab89f", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:16:42Z", "type": "commit"}, {"oid": "e84971a088eb10c2354e221266130748d8c48e37", "url": "https://github.com/elastic/elasticsearch/commit/e84971a088eb10c2354e221266130748d8c48e37", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:16:55Z", "type": "commit"}, {"oid": "1efee6712c7218de764810693b129af03aa272af", "url": "https://github.com/elastic/elasticsearch/commit/1efee6712c7218de764810693b129af03aa272af", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:17:21Z", "type": "commit"}, {"oid": "ba82ebb211706fd3c83773646b882564968464f5", "url": "https://github.com/elastic/elasticsearch/commit/ba82ebb211706fd3c83773646b882564968464f5", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:22:50Z", "type": "commit"}, {"oid": "4abeabf8f64c3a5069972233d272fe899d088ff5", "url": "https://github.com/elastic/elasticsearch/commit/4abeabf8f64c3a5069972233d272fe899d088ff5", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:23:11Z", "type": "commit"}, {"oid": "1b389eac203d099d0fd9351ddc1bbb2860ecf473", "url": "https://github.com/elastic/elasticsearch/commit/1b389eac203d099d0fd9351ddc1bbb2860ecf473", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:23:24Z", "type": "commit"}, {"oid": "bad6adfb336d67bf5a1cd21ceceec49d702d76b2", "url": "https://github.com/elastic/elasticsearch/commit/bad6adfb336d67bf5a1cd21ceceec49d702d76b2", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:24:02Z", "type": "commit"}, {"oid": "70bc73d9620c4691b750a85d0b68519be3f5338d", "url": "https://github.com/elastic/elasticsearch/commit/70bc73d9620c4691b750a85d0b68519be3f5338d", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:24:17Z", "type": "commit"}, {"oid": "df97a0d8565ae9a307cf2804973c7c194ecd94a0", "url": "https://github.com/elastic/elasticsearch/commit/df97a0d8565ae9a307cf2804973c7c194ecd94a0", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T12:24:52Z", "type": "commit"}, {"oid": "7443a3fec685136097a61daa79b76fdd51a7dcc9", "url": "https://github.com/elastic/elasticsearch/commit/7443a3fec685136097a61daa79b76fdd51a7dcc9", "message": "Merge branch 'doc/migration_guide_joda' of github.com:pgomulka/elasticsearch into doc/migration_guide_joda", "committedDate": "2020-03-20T12:27:08Z", "type": "commit"}, {"oid": "52690b930385e1ae71343aa0bba8ae3894138c7c", "url": "https://github.com/elastic/elasticsearch/commit/52690b930385e1ae71343aa0bba8ae3894138c7c", "message": "rephrase update index mappings section", "committedDate": "2020-03-20T12:29:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY2NTU2OA==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395665568", "bodyText": "This should fix the docs-ci test.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For a detailed migration guide, see <<migrate_to_java_time>>.\n          \n          \n            \n            For a detailed migration guide, see <<migrate-to-java-time>>.", "author": "jrodewig", "createdAt": "2020-03-20T14:16:58Z", "path": "docs/reference/migration/migrate_7_0/java_time.asciidoc", "diffHunk": "@@ -125,3 +126,10 @@ and should be replaced.\n \n With the switch to java time, support for negative timestamps has been removed.\n For dates before 1970, use a date format containing a year.\n+\n+\n+[float]\n+==== Migration guide\n+For a detailed migration guide, see <<migrate_to_java_time>>.", "originalCommit": "52690b930385e1ae71343aa0bba8ae3894138c7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3MDM4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395670386", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            prefix in {es} 6.8 and later versions.\n          \n          \n            \n             in {es} 6.8 and later versions.", "author": "jrodewig", "createdAt": "2020-03-20T14:24:15Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,408 @@\n+[[migrate-to-java-time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switched from joda time to java time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+[[java-time-convert-date-formats]]\n+=== Convert date formats\n+\n+To upgrade to 7.0, you'll need to convert any joda-time date formats\n+to their java-time equivalents.\n+\n+To help track this effort, you can prefix java-time date formats with an `8`\n+prefix in {es} 6.8 and later versions.", "originalCommit": "52690b930385e1ae71343aa0bba8ae3894138c7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3MTAyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395671025", "bodyText": "Suggested change", "author": "jrodewig", "createdAt": "2020-03-20T14:25:10Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,408 @@\n+[[migrate-to-java-time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switched from joda time to java time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+[[java-time-convert-date-formats]]\n+=== Convert date formats\n+\n+To upgrade to 7.0, you'll need to convert any joda-time date formats\n+to their java-time equivalents.\n+\n+To help track this effort, you can prefix java-time date formats with an `8`\n+prefix in {es} 6.8 and later versions.\n+\n+For example, you can change the date format `YYYY-MM-dd` to `8yyyy-MM-dd` to\n+indicate the date format uses java time.\n+\n+{es} treats date formats starting with the `8` prefix differently depending on\n+the version:\n+\n+*6.8*: Date formats with an `8` prefix are handled as java-time formats. Date\n+formats without an `8` prefix are treated as joda-time formats. We recommend\n+converting these joda-time formats to java-time _before_ upgrading to 7.x.\n+\n+*7.x and later*: For indices created in 6.x, date formats without an `8` prefix\n+are treated as joda-time formats. For indices created in 7.x and later versions,\n+all date formats are treated as java-time formats, regardless of whether it\n+starts with an `8` prefix.\n+\n+[[java-time-migration-impacted-features]]\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most custom date formats are compatible. However, several require\n+an update.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+[[java-time-migration-incompatible-date-formats]]\n+==== Incompatible date formats\n+Custom date formats containing the following joda-time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`.\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+", "originalCommit": "52690b930385e1ae71343aa0bba8ae3894138c7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3MTIzMw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395671233", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            values, while `y` cannot. `y` can also be associated with an era field.\n          \n          \n            \n            values while `y` cannot. `y` can also be associated with an era field.", "author": "jrodewig", "createdAt": "2020-03-20T14:25:26Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,408 @@\n+[[migrate-to-java-time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switched from joda time to java time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+[[java-time-convert-date-formats]]\n+=== Convert date formats\n+\n+To upgrade to 7.0, you'll need to convert any joda-time date formats\n+to their java-time equivalents.\n+\n+To help track this effort, you can prefix java-time date formats with an `8`\n+prefix in {es} 6.8 and later versions.\n+\n+For example, you can change the date format `YYYY-MM-dd` to `8yyyy-MM-dd` to\n+indicate the date format uses java time.\n+\n+{es} treats date formats starting with the `8` prefix differently depending on\n+the version:\n+\n+*6.8*: Date formats with an `8` prefix are handled as java-time formats. Date\n+formats without an `8` prefix are treated as joda-time formats. We recommend\n+converting these joda-time formats to java-time _before_ upgrading to 7.x.\n+\n+*7.x and later*: For indices created in 6.x, date formats without an `8` prefix\n+are treated as joda-time formats. For indices created in 7.x and later versions,\n+all date formats are treated as java-time formats, regardless of whether it\n+starts with an `8` prefix.\n+\n+[[java-time-migration-impacted-features]]\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most custom date formats are compatible. However, several require\n+an update.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+[[java-time-migration-incompatible-date-formats]]\n+==== Incompatible date formats\n+Custom date formats containing the following joda-time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`.\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` (Year)::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`.\n+\n+In java time, `y` is used for year of era. `u` can contain non-positive\n+values, while `y` cannot. `y` can also be associated with an era field.", "originalCommit": "52690b930385e1ae71343aa0bba8ae3894138c7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3MTUxNA==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395671514", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `Z` has s similar meaning in java time. However, java time expects different\n          \n          \n            \n            `Z` has a similar meaning in java time. However, java time expects different", "author": "jrodewig", "createdAt": "2020-03-20T14:25:50Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,408 @@\n+[[migrate-to-java-time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switched from joda time to java time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+[[java-time-convert-date-formats]]\n+=== Convert date formats\n+\n+To upgrade to 7.0, you'll need to convert any joda-time date formats\n+to their java-time equivalents.\n+\n+To help track this effort, you can prefix java-time date formats with an `8`\n+prefix in {es} 6.8 and later versions.\n+\n+For example, you can change the date format `YYYY-MM-dd` to `8yyyy-MM-dd` to\n+indicate the date format uses java time.\n+\n+{es} treats date formats starting with the `8` prefix differently depending on\n+the version:\n+\n+*6.8*: Date formats with an `8` prefix are handled as java-time formats. Date\n+formats without an `8` prefix are treated as joda-time formats. We recommend\n+converting these joda-time formats to java-time _before_ upgrading to 7.x.\n+\n+*7.x and later*: For indices created in 6.x, date formats without an `8` prefix\n+are treated as joda-time formats. For indices created in 7.x and later versions,\n+all date formats are treated as java-time formats, regardless of whether it\n+starts with an `8` prefix.\n+\n+[[java-time-migration-impacted-features]]\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most custom date formats are compatible. However, several require\n+an update.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+[[java-time-migration-incompatible-date-formats]]\n+==== Incompatible date formats\n+Custom date formats containing the following joda-time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`.\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` (Year)::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`.\n+\n+In java time, `y` is used for year of era. `u` can contain non-positive\n+values, while `y` cannot. `y` can also be associated with an era field.\n+--\n+\n+\n+`C` (Century of era)::\n++\n+--\n+Century of era is not supported in java time.\n+There is no replacement. Instead, we recommend you preprocess your input.\n+--\n+\n+`x` (Week year)::\n++\n+--\n+Replace with `Y`.\n+\n+In java time, `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset]. \n+\n+[WARNING]\n+====\n+Failure to properly convert `x` (Week year) to `Y` could result in data loss.\n+====\n+--\n+\n+`Z` (Zone offset/id)::\n++\n+--\n+Replace with multiple `X`'s.\n+\n+`Z` has s similar meaning in java time. However, java time expects different", "originalCommit": "52690b930385e1ae71343aa0bba8ae3894138c7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3Mjk0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395672949", "bodyText": "I feel this is covered well later.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n          \n          \n            \n            If you specified a custom date format there, then you need to update it too.", "author": "jrodewig", "createdAt": "2020-03-20T14:27:58Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,408 @@\n+[[migrate-to-java-time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switched from joda time to java time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+[[java-time-convert-date-formats]]\n+=== Convert date formats\n+\n+To upgrade to 7.0, you'll need to convert any joda-time date formats\n+to their java-time equivalents.\n+\n+To help track this effort, you can prefix java-time date formats with an `8`\n+prefix in {es} 6.8 and later versions.\n+\n+For example, you can change the date format `YYYY-MM-dd` to `8yyyy-MM-dd` to\n+indicate the date format uses java time.\n+\n+{es} treats date formats starting with the `8` prefix differently depending on\n+the version:\n+\n+*6.8*: Date formats with an `8` prefix are handled as java-time formats. Date\n+formats without an `8` prefix are treated as joda-time formats. We recommend\n+converting these joda-time formats to java-time _before_ upgrading to 7.x.\n+\n+*7.x and later*: For indices created in 6.x, date formats without an `8` prefix\n+are treated as joda-time formats. For indices created in 7.x and later versions,\n+all date formats are treated as java-time formats, regardless of whether it\n+starts with an `8` prefix.\n+\n+[[java-time-migration-impacted-features]]\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most custom date formats are compatible. However, several require\n+an update.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+[[java-time-migration-incompatible-date-formats]]\n+==== Incompatible date formats\n+Custom date formats containing the following joda-time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`.\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` (Year)::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`.\n+\n+In java time, `y` is used for year of era. `u` can contain non-positive\n+values, while `y` cannot. `y` can also be associated with an era field.\n+--\n+\n+\n+`C` (Century of era)::\n++\n+--\n+Century of era is not supported in java time.\n+There is no replacement. Instead, we recommend you preprocess your input.\n+--\n+\n+`x` (Week year)::\n++\n+--\n+Replace with `Y`.\n+\n+In java time, `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset]. \n+\n+[WARNING]\n+====\n+Failure to properly convert `x` (Week year) to `Y` could result in data loss.\n+====\n+--\n+\n+`Z` (Zone offset/id)::\n++\n+--\n+Replace with multiple `X`'s.\n+\n+`Z` has s similar meaning in java time. However, java time expects different\n+numbers of literals to parse different forms.\n+\n+Consider migrating to `X`, which gives you more control over how time is parsed.\n+For example, the joda-time format `YYYY-MM-dd'T'hh:mm:ssZZ` accepts the following dates:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+In java time, you cannot parse all these dates using a single format\n+Instead, you must specify 3 separate formats:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+The formats must then be delimited using `||`:\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+The same applies if you expect your pattern to occur without a colon (`:`):\n+For example, the `YYYY-MM-dd'T'hh:mm:ssZ` format accepts the following date forms:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+To accept all these forms in java time, you must use the `||` delimiter:\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+`d` (Day)::\n++\n+--\n+In java time, `d` is still interpreted as \"day\" but is less flexible.\n+\n+For example, the joda-time date format `YYYY-MM-dd` accepts `2010-01-01` or\n+`2010-01-1`.\n+\n+In java time, you must use the `||` delimiter to provide specify each format:\n+\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd||yyyy-MM-d\n+--------------------------------------------------\n+\n+In java time, `d` also does not accept more than 2 digits. To accept days with more\n+than two digits, you must include a text literal in your java-time date format.\n+For example, to parse `2010-01-00001`, you must use the following java-time date format: \n+\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-'000'dd\n+--------------------------------------------------\n+--\n+\n+`e` (Name of day)::\n++\n+--\n+In java time, `e` is still interpreted as \"name of day\" but does not parse\n+short- or full-text forms.\n+\n+For example, the joda-time date format `EEE YYYY-MM` accepts both\n+`Wed 2020-01` and `Wednesday 2020-01`.\n+\n+To accept both of these dates in java time, you must specify each format using\n+the `||` delimiter: \n+\n+[source,txt]\n+--------------------------------------------------\n+cccc yyyy-MM||ccc yyyy-MM\n+--------------------------------------------------\n+\n+The joda-time literal `E` is interpreted as \"day of week.\"\n+The java-time literal `c` is interpreted as \"localized day of week.\"\n+`E` does not accept full-text day formats, such as `Wednesday`.\n+--\n+\n+`EEEE` and similar text forms::\n++\n+--\n+Support for full-text forms depends on the locale data provided with your Java\n+Development Kit (JDK) and other implementation details. We recommend you\n+test formats containing these patterns carefully before upgrading.\n+--\n+\n+`z` (Time zone text)::\n++\n+--\n+In java time, `z` outputs 'Z' for Zulu when given a UTC timezone.\n+--\n+\n+[[java-time-migration-test]]\n+===== Test with your data\n+\n+We strongly recommend you test any date format changes using real data before\n+deploying in production.\n+\n+For help with date debugging, consider using\n+https://esddd.herokuapp.com/[https://esddd.herokuapp.com/.]\n+\n+[[java-time-migrate-update-mappings]]\n+==== Update index mappings\n+To update joda-time date formats in index mappings, you must create a new index\n+with an updated mapping and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.", "originalCommit": "52690b930385e1ae71343aa0bba8ae3894138c7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4ODY0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395688642", "bodyText": "removed the part of external templates", "author": "pgomulka", "createdAt": "2020-03-20T14:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3Mjk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3NjI0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395676241", "bodyText": "This is required. Otherwise, the doc splits pages here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            [[java-time-convert-date-formats]]\n          \n          \n            \n            [discrete]\n          \n          \n            \n            [[java-time-convert-date-formats]]", "author": "jrodewig", "createdAt": "2020-03-20T14:32:54Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,408 @@\n+[[migrate-to-java-time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switched from joda time to java time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+[[java-time-convert-date-formats]]", "originalCommit": "52690b930385e1ae71343aa0bba8ae3894138c7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3ODMyNw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395678327", "bodyText": "Adds a missing period.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n          \n          \n            \n            or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant].", "author": "jrodewig", "createdAt": "2020-03-20T14:36:01Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,408 @@\n+[[migrate-to-java-time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switched from joda time to java time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+[[java-time-convert-date-formats]]\n+=== Convert date formats\n+\n+To upgrade to 7.0, you'll need to convert any joda-time date formats\n+to their java-time equivalents.\n+\n+To help track this effort, you can prefix java-time date formats with an `8`\n+prefix in {es} 6.8 and later versions.\n+\n+For example, you can change the date format `YYYY-MM-dd` to `8yyyy-MM-dd` to\n+indicate the date format uses java time.\n+\n+{es} treats date formats starting with the `8` prefix differently depending on\n+the version:\n+\n+*6.8*: Date formats with an `8` prefix are handled as java-time formats. Date\n+formats without an `8` prefix are treated as joda-time formats. We recommend\n+converting these joda-time formats to java-time _before_ upgrading to 7.x.\n+\n+*7.x and later*: For indices created in 6.x, date formats without an `8` prefix\n+are treated as joda-time formats. For indices created in 7.x and later versions,\n+all date formats are treated as java-time formats, regardless of whether it\n+starts with an `8` prefix.\n+\n+[[java-time-migration-impacted-features]]\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most custom date formats are compatible. However, several require\n+an update.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]", "originalCommit": "52690b930385e1ae71343aa0bba8ae3894138c7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3OTg1OA==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395679858", "bodyText": "Not a biggie. Just for consistency.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            PUT _ingest/pipeline/mypipeline\n          \n          \n            \n            PUT _ingest/pipeline/my_pipeline", "author": "jrodewig", "createdAt": "2020-03-20T14:38:14Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,408 @@\n+[[migrate-to-java-time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switched from joda time to java time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+[[java-time-convert-date-formats]]\n+=== Convert date formats\n+\n+To upgrade to 7.0, you'll need to convert any joda-time date formats\n+to their java-time equivalents.\n+\n+To help track this effort, you can prefix java-time date formats with an `8`\n+prefix in {es} 6.8 and later versions.\n+\n+For example, you can change the date format `YYYY-MM-dd` to `8yyyy-MM-dd` to\n+indicate the date format uses java time.\n+\n+{es} treats date formats starting with the `8` prefix differently depending on\n+the version:\n+\n+*6.8*: Date formats with an `8` prefix are handled as java-time formats. Date\n+formats without an `8` prefix are treated as joda-time formats. We recommend\n+converting these joda-time formats to java-time _before_ upgrading to 7.x.\n+\n+*7.x and later*: For indices created in 6.x, date formats without an `8` prefix\n+are treated as joda-time formats. For indices created in 7.x and later versions,\n+all date formats are treated as java-time formats, regardless of whether it\n+starts with an `8` prefix.\n+\n+[[java-time-migration-impacted-features]]\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most custom date formats are compatible. However, several require\n+an update.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+[[java-time-migration-incompatible-date-formats]]\n+==== Incompatible date formats\n+Custom date formats containing the following joda-time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`.\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` (Year)::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`.\n+\n+In java time, `y` is used for year of era. `u` can contain non-positive\n+values, while `y` cannot. `y` can also be associated with an era field.\n+--\n+\n+\n+`C` (Century of era)::\n++\n+--\n+Century of era is not supported in java time.\n+There is no replacement. Instead, we recommend you preprocess your input.\n+--\n+\n+`x` (Week year)::\n++\n+--\n+Replace with `Y`.\n+\n+In java time, `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset]. \n+\n+[WARNING]\n+====\n+Failure to properly convert `x` (Week year) to `Y` could result in data loss.\n+====\n+--\n+\n+`Z` (Zone offset/id)::\n++\n+--\n+Replace with multiple `X`'s.\n+\n+`Z` has s similar meaning in java time. However, java time expects different\n+numbers of literals to parse different forms.\n+\n+Consider migrating to `X`, which gives you more control over how time is parsed.\n+For example, the joda-time format `YYYY-MM-dd'T'hh:mm:ssZZ` accepts the following dates:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+In java time, you cannot parse all these dates using a single format\n+Instead, you must specify 3 separate formats:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+The formats must then be delimited using `||`:\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+The same applies if you expect your pattern to occur without a colon (`:`):\n+For example, the `YYYY-MM-dd'T'hh:mm:ssZ` format accepts the following date forms:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+To accept all these forms in java time, you must use the `||` delimiter:\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+`d` (Day)::\n++\n+--\n+In java time, `d` is still interpreted as \"day\" but is less flexible.\n+\n+For example, the joda-time date format `YYYY-MM-dd` accepts `2010-01-01` or\n+`2010-01-1`.\n+\n+In java time, you must use the `||` delimiter to provide specify each format:\n+\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd||yyyy-MM-d\n+--------------------------------------------------\n+\n+In java time, `d` also does not accept more than 2 digits. To accept days with more\n+than two digits, you must include a text literal in your java-time date format.\n+For example, to parse `2010-01-00001`, you must use the following java-time date format: \n+\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-'000'dd\n+--------------------------------------------------\n+--\n+\n+`e` (Name of day)::\n++\n+--\n+In java time, `e` is still interpreted as \"name of day\" but does not parse\n+short- or full-text forms.\n+\n+For example, the joda-time date format `EEE YYYY-MM` accepts both\n+`Wed 2020-01` and `Wednesday 2020-01`.\n+\n+To accept both of these dates in java time, you must specify each format using\n+the `||` delimiter: \n+\n+[source,txt]\n+--------------------------------------------------\n+cccc yyyy-MM||ccc yyyy-MM\n+--------------------------------------------------\n+\n+The joda-time literal `E` is interpreted as \"day of week.\"\n+The java-time literal `c` is interpreted as \"localized day of week.\"\n+`E` does not accept full-text day formats, such as `Wednesday`.\n+--\n+\n+`EEEE` and similar text forms::\n++\n+--\n+Support for full-text forms depends on the locale data provided with your Java\n+Development Kit (JDK) and other implementation details. We recommend you\n+test formats containing these patterns carefully before upgrading.\n+--\n+\n+`z` (Time zone text)::\n++\n+--\n+In java time, `z` outputs 'Z' for Zulu when given a UTC timezone.\n+--\n+\n+[[java-time-migration-test]]\n+===== Test with your data\n+\n+We strongly recommend you test any date format changes using real data before\n+deploying in production.\n+\n+For help with date debugging, consider using\n+https://esddd.herokuapp.com/[https://esddd.herokuapp.com/.]\n+\n+[[java-time-migrate-update-mappings]]\n+==== Update index mappings\n+To update joda-time date formats in index mappings, you must create a new index\n+with an updated mapping and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.\n+\n+The following `my_index_1` index contains a mapping for the `datetime` field, a\n+`date` field with a custom joda-time date format.\n+////\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_1\n+{\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+}\n+--------------------------------------------------\n+////\n+\n+[source,console]\n+--------------------------------------------------\n+GET my_index_1/_mapping\n+--------------------------------------------------\n+// TEST[continued]\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"my_index_1\" : {\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+\n+To change the date format for the `datetime` field, create a separate index\n+containing an updated mapping and date format.\n+\n+For example, the following `my_index_2` index changes the `datetime` field's \n+date format to `8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis`. The `8` prefix \n+indicates this date format uses java time.\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_2\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"datetime\": {\n+        \"type\": \"date\",\n+        \"format\": \"8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+Next, reindex the data from `my_index_1` to `my_index_2`.\n+\n+[source,console]\n+--------------------------------------------------\n+POST _reindex\n+{\n+  \"source\": {\n+    \"index\": \"my_index_1\"\n+  },\n+  \"dest\": {\n+    \"index\": \"my_index_2\"\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+If you use index aliases, update them to point to the new index.\n+\n+[source,console]\n+--------------------------------------------------\n+POST /_aliases\n+{\n+    \"actions\" : [\n+        { \"remove\" : { \"index\" : \"my_index_1\", \"alias\" : \"my_index\" } },\n+        { \"add\" : { \"index\" : \"my_index_2\", \"alias\" : \"my_index\" } }\n+    ]\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+[[java-time-migration-update-ingest-pipelines]]\n+===== Update ingest pipelines\n+If your ingest pipelines contain joda-time date formats, you can update them\n+using the <<put-pipeline-api,put ingest pipeline>> API.\n+\n+[source,console]\n+--------------------------------------------------\n+PUT _ingest/pipeline/mypipeline", "originalCommit": "52690b930385e1ae71343aa0bba8ae3894138c7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4MTU0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395681541", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Next, reindex the data from `my_index_1` to `my_index_2`.\n          \n          \n            \n            Next, reindex data from the old index to the new index.\n          \n          \n            \n            \n          \n          \n            \n            The following <<docs-reindex,reindex>> API request reindexes data from\n          \n          \n            \n            `my_index_1` to `my_index_2`.", "author": "jrodewig", "createdAt": "2020-03-20T14:40:54Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,408 @@\n+[[migrate-to-java-time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switched from joda time to java time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+[[java-time-convert-date-formats]]\n+=== Convert date formats\n+\n+To upgrade to 7.0, you'll need to convert any joda-time date formats\n+to their java-time equivalents.\n+\n+To help track this effort, you can prefix java-time date formats with an `8`\n+prefix in {es} 6.8 and later versions.\n+\n+For example, you can change the date format `YYYY-MM-dd` to `8yyyy-MM-dd` to\n+indicate the date format uses java time.\n+\n+{es} treats date formats starting with the `8` prefix differently depending on\n+the version:\n+\n+*6.8*: Date formats with an `8` prefix are handled as java-time formats. Date\n+formats without an `8` prefix are treated as joda-time formats. We recommend\n+converting these joda-time formats to java-time _before_ upgrading to 7.x.\n+\n+*7.x and later*: For indices created in 6.x, date formats without an `8` prefix\n+are treated as joda-time formats. For indices created in 7.x and later versions,\n+all date formats are treated as java-time formats, regardless of whether it\n+starts with an `8` prefix.\n+\n+[[java-time-migration-impacted-features]]\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most custom date formats are compatible. However, several require\n+an update.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+[[java-time-migration-incompatible-date-formats]]\n+==== Incompatible date formats\n+Custom date formats containing the following joda-time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`.\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` (Year)::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`.\n+\n+In java time, `y` is used for year of era. `u` can contain non-positive\n+values, while `y` cannot. `y` can also be associated with an era field.\n+--\n+\n+\n+`C` (Century of era)::\n++\n+--\n+Century of era is not supported in java time.\n+There is no replacement. Instead, we recommend you preprocess your input.\n+--\n+\n+`x` (Week year)::\n++\n+--\n+Replace with `Y`.\n+\n+In java time, `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset]. \n+\n+[WARNING]\n+====\n+Failure to properly convert `x` (Week year) to `Y` could result in data loss.\n+====\n+--\n+\n+`Z` (Zone offset/id)::\n++\n+--\n+Replace with multiple `X`'s.\n+\n+`Z` has s similar meaning in java time. However, java time expects different\n+numbers of literals to parse different forms.\n+\n+Consider migrating to `X`, which gives you more control over how time is parsed.\n+For example, the joda-time format `YYYY-MM-dd'T'hh:mm:ssZZ` accepts the following dates:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+In java time, you cannot parse all these dates using a single format\n+Instead, you must specify 3 separate formats:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+The formats must then be delimited using `||`:\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+The same applies if you expect your pattern to occur without a colon (`:`):\n+For example, the `YYYY-MM-dd'T'hh:mm:ssZ` format accepts the following date forms:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+To accept all these forms in java time, you must use the `||` delimiter:\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+`d` (Day)::\n++\n+--\n+In java time, `d` is still interpreted as \"day\" but is less flexible.\n+\n+For example, the joda-time date format `YYYY-MM-dd` accepts `2010-01-01` or\n+`2010-01-1`.\n+\n+In java time, you must use the `||` delimiter to provide specify each format:\n+\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd||yyyy-MM-d\n+--------------------------------------------------\n+\n+In java time, `d` also does not accept more than 2 digits. To accept days with more\n+than two digits, you must include a text literal in your java-time date format.\n+For example, to parse `2010-01-00001`, you must use the following java-time date format: \n+\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-'000'dd\n+--------------------------------------------------\n+--\n+\n+`e` (Name of day)::\n++\n+--\n+In java time, `e` is still interpreted as \"name of day\" but does not parse\n+short- or full-text forms.\n+\n+For example, the joda-time date format `EEE YYYY-MM` accepts both\n+`Wed 2020-01` and `Wednesday 2020-01`.\n+\n+To accept both of these dates in java time, you must specify each format using\n+the `||` delimiter: \n+\n+[source,txt]\n+--------------------------------------------------\n+cccc yyyy-MM||ccc yyyy-MM\n+--------------------------------------------------\n+\n+The joda-time literal `E` is interpreted as \"day of week.\"\n+The java-time literal `c` is interpreted as \"localized day of week.\"\n+`E` does not accept full-text day formats, such as `Wednesday`.\n+--\n+\n+`EEEE` and similar text forms::\n++\n+--\n+Support for full-text forms depends on the locale data provided with your Java\n+Development Kit (JDK) and other implementation details. We recommend you\n+test formats containing these patterns carefully before upgrading.\n+--\n+\n+`z` (Time zone text)::\n++\n+--\n+In java time, `z` outputs 'Z' for Zulu when given a UTC timezone.\n+--\n+\n+[[java-time-migration-test]]\n+===== Test with your data\n+\n+We strongly recommend you test any date format changes using real data before\n+deploying in production.\n+\n+For help with date debugging, consider using\n+https://esddd.herokuapp.com/[https://esddd.herokuapp.com/.]\n+\n+[[java-time-migrate-update-mappings]]\n+==== Update index mappings\n+To update joda-time date formats in index mappings, you must create a new index\n+with an updated mapping and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.\n+\n+The following `my_index_1` index contains a mapping for the `datetime` field, a\n+`date` field with a custom joda-time date format.\n+////\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_1\n+{\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+}\n+--------------------------------------------------\n+////\n+\n+[source,console]\n+--------------------------------------------------\n+GET my_index_1/_mapping\n+--------------------------------------------------\n+// TEST[continued]\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"my_index_1\" : {\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+\n+To change the date format for the `datetime` field, create a separate index\n+containing an updated mapping and date format.\n+\n+For example, the following `my_index_2` index changes the `datetime` field's \n+date format to `8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis`. The `8` prefix \n+indicates this date format uses java time.\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_2\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"datetime\": {\n+        \"type\": \"date\",\n+        \"format\": \"8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+Next, reindex the data from `my_index_1` to `my_index_2`.", "originalCommit": "52690b930385e1ae71343aa0bba8ae3894138c7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "56527142022d13789c2e0c8c79fd5687bbbcba4c", "url": "https://github.com/elastic/elasticsearch/commit/56527142022d13789c2e0c8c79fd5687bbbcba4c", "message": "Apply suggestions from code review\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T14:46:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4NTc0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395685741", "bodyText": "Probably need to rewrap this line as well.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n          \n          \n            \n            For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter-intuitive) because there is >4 days of that week in 2019", "author": "jrodewig", "createdAt": "2020-03-20T14:47:20Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,408 @@\n+[[migrate-to-java-time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switched from joda time to java time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+[[java-time-convert-date-formats]]\n+=== Convert date formats\n+\n+To upgrade to 7.0, you'll need to convert any joda-time date formats\n+to their java-time equivalents.\n+\n+To help track this effort, you can prefix java-time date formats with an `8`\n+prefix in {es} 6.8 and later versions.\n+\n+For example, you can change the date format `YYYY-MM-dd` to `8yyyy-MM-dd` to\n+indicate the date format uses java time.\n+\n+{es} treats date formats starting with the `8` prefix differently depending on\n+the version:\n+\n+*6.8*: Date formats with an `8` prefix are handled as java-time formats. Date\n+formats without an `8` prefix are treated as joda-time formats. We recommend\n+converting these joda-time formats to java-time _before_ upgrading to 7.x.\n+\n+*7.x and later*: For indices created in 6.x, date formats without an `8` prefix\n+are treated as joda-time formats. For indices created in 7.x and later versions,\n+all date formats are treated as java-time formats, regardless of whether it\n+starts with an `8` prefix.\n+\n+[[java-time-migration-impacted-features]]\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most custom date formats are compatible. However, several require\n+an update.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+[[java-time-migration-incompatible-date-formats]]\n+==== Incompatible date formats\n+Custom date formats containing the following joda-time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`.\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019", "originalCommit": "52690b930385e1ae71343aa0bba8ae3894138c7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "533bd1b9ee95c16ac0bd9f0572feb226930c1a53", "url": "https://github.com/elastic/elasticsearch/commit/533bd1b9ee95c16ac0bd9f0572feb226930c1a53", "message": "remove the part of external pipelines form update index section", "committedDate": "2020-03-20T14:50:49Z", "type": "commit"}, {"oid": "aeaa1f296e92ef209689260f2c92dce09ba13e65", "url": "https://github.com/elastic/elasticsearch/commit/aeaa1f296e92ef209689260f2c92dce09ba13e65", "message": "Merge branch 'doc/migration_guide_joda' of github.com:pgomulka/elasticsearch into doc/migration_guide_joda", "committedDate": "2020-03-20T14:51:04Z", "type": "commit"}, {"oid": "ea1e0f220e9089b0d3cfcb13ec0a41e6784ac3e2", "url": "https://github.com/elastic/elasticsearch/commit/ea1e0f220e9089b0d3cfcb13ec0a41e6784ac3e2", "message": "Apply suggestions from code review\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T14:54:47Z", "type": "commit"}, {"oid": "9bbfc8be588e6abcaf5a8c25ad8d3eff611e57bd", "url": "https://github.com/elastic/elasticsearch/commit/9bbfc8be588e6abcaf5a8c25ad8d3eff611e57bd", "message": "draft", "committedDate": "2020-02-06T09:57:28Z", "type": "commit"}, {"oid": "e1752b1f66eea1ad113ca864eefd8ca6014b43ec", "url": "https://github.com/elastic/elasticsearch/commit/e1752b1f66eea1ad113ca864eefd8ca6014b43ec", "message": "todo", "committedDate": "2020-02-06T10:00:37Z", "type": "commit"}, {"oid": "8fa601ca973e19219d0eddb4fcf1a737c968f2b3", "url": "https://github.com/elastic/elasticsearch/commit/8fa601ca973e19219d0eddb4fcf1a737c968f2b3", "message": "more docs", "committedDate": "2020-02-25T15:57:22Z", "type": "commit"}, {"oid": "8770f30a496bcca1dfa8422d27bf106235fc9b5b", "url": "https://github.com/elastic/elasticsearch/commit/8770f30a496bcca1dfa8422d27bf106235fc9b5b", "message": "link", "committedDate": "2020-02-25T16:46:41Z", "type": "commit"}, {"oid": "6bed675c2d648c17155ef507b0d04f5298f4a3f4", "url": "https://github.com/elastic/elasticsearch/commit/6bed675c2d648c17155ef507b0d04f5298f4a3f4", "message": "docs fix", "committedDate": "2020-02-26T09:11:03Z", "type": "commit"}, {"oid": "44a7c7e4e07884251367d3fcb6c2deb797044254", "url": "https://github.com/elastic/elasticsearch/commit/44a7c7e4e07884251367d3fcb6c2deb797044254", "message": "fix build", "committedDate": "2020-02-26T09:57:32Z", "type": "commit"}, {"oid": "7450e9c34432b0419b1619677104325ecaa103f2", "url": "https://github.com/elastic/elasticsearch/commit/7450e9c34432b0419b1619677104325ecaa103f2", "message": "formatting changes", "committedDate": "2020-03-17T14:30:42Z", "type": "commit"}, {"oid": "eceb3b84433d369f465a67fcd8d520c7bebcb678", "url": "https://github.com/elastic/elasticsearch/commit/eceb3b84433d369f465a67fcd8d520c7bebcb678", "message": "cleanup and todos", "committedDate": "2020-03-17T16:11:31Z", "type": "commit"}, {"oid": "fa9b6617e486493152e10e230104c481aa35fdc1", "url": "https://github.com/elastic/elasticsearch/commit/fa9b6617e486493152e10e230104c481aa35fdc1", "message": "test fixes", "committedDate": "2020-03-17T16:40:58Z", "type": "commit"}, {"oid": "d7f877b93e55a1153134aee2a989321e289d636c", "url": "https://github.com/elastic/elasticsearch/commit/d7f877b93e55a1153134aee2a989321e289d636c", "message": "test fix", "committedDate": "2020-03-17T16:52:04Z", "type": "commit"}, {"oid": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "url": "https://github.com/elastic/elasticsearch/commit/2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "message": "Merge branch '7.x' into doc/migration_guide_joda", "committedDate": "2020-03-17T16:58:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkwOTYyNw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r393909627", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The fix is in JDK version 9 and newer.\n          \n          \n            \n            This bug is fixed in JDK9 and later versions.", "author": "jrodewig", "createdAt": "2020-03-17T19:10:49Z", "path": "docs/reference/migration/migrate_7_0/java_time.asciidoc", "diffHunk": "@@ -89,6 +89,7 @@ When you are running Elasticsearch 7 with Java 8, you are not able to parse\n the timezone `GMT0` properly anymore. The reason for this is a bug in the\n JDK, which has not been fixed for JDK8. You can read more in the\n https://bugs.openjdk.java.net/browse/JDK-8138664[official issue]\n+The fix is in JDK version 9 and newer.", "originalCommit": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkxMDk3NA==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r393910974", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can find a detailed migration guide here\n          \n          \n            \n            \n          \n          \n            \n            * <<migrate_to_java_time>>\n          \n          \n            \n            For a detailed migration guide, see <<migrate_to_java_time>>.", "author": "jrodewig", "createdAt": "2020-03-17T19:13:29Z", "path": "docs/reference/migration/migrate_7_0/java_time.asciidoc", "diffHunk": "@@ -125,3 +126,12 @@ and should be replaced.\n \n With the switch to java time, support for negative timestamps has been removed.\n For dates before 1970, use a date format containing a year.\n+\n+\n+[float]\n+==== Migration Guide\n+You can find a detailed migration guide here\n+\n+* <<migrate_to_java_time>>", "originalCommit": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkxMTA5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r393911091", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ==== Migration Guide\n          \n          \n            \n            ==== Migration guide", "author": "jrodewig", "createdAt": "2020-03-17T19:13:44Z", "path": "docs/reference/migration/migrate_7_0/java_time.asciidoc", "diffHunk": "@@ -125,3 +126,12 @@ and should be replaced.\n \n With the switch to java time, support for negative timestamps has been removed.\n For dates before 1970, use a date format containing a year.\n+\n+\n+[float]\n+==== Migration Guide", "originalCommit": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkxMTE5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r393911197", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            === Java Time Migration Guide\n          \n          \n            \n            === Java time migration guide", "author": "jrodewig", "createdAt": "2020-03-17T19:13:57Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,309 @@\n+[[migrate_to_java_time]]\n+=== Java Time Migration Guide", "originalCommit": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkxNjYwMg==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r393916602", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Since version 7.0 Elasticsearch is using java.time as an underlying implementation of dates parsing, formatting and calculations.\n          \n          \n            \n            java.time is in many aspects very similar to joda-time which we previously used. However there are some differences and this guide is meant to\n          \n          \n            \n            help you to become compatible.\n          \n          \n            \n            With 7.0, {es} switch to java time from joda time for date-related parsing,\n          \n          \n            \n            formatting, and calculations. This guide is designed to help you determine\n          \n          \n            \n            if your cluster is impacted and, if so, prepare for the upgrade.", "author": "jrodewig", "createdAt": "2020-03-17T19:24:33Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,309 @@\n+[[migrate_to_java_time]]\n+=== Java Time Migration Guide\n+\n+Since version 7.0 Elasticsearch is using java.time as an underlying implementation of dates parsing, formatting and calculations.\n+java.time is in many aspects very similar to joda-time which we previously used. However there are some differences and this guide is meant to\n+help you to become compatible.", "originalCommit": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkxOTU3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r393919571", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ==== Identifying if you are affected\n          \n          \n            \n            ==== Impacted features", "author": "jrodewig", "createdAt": "2020-03-17T19:30:21Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,309 @@\n+[[migrate_to_java_time]]\n+=== Java Time Migration Guide\n+\n+Since version 7.0 Elasticsearch is using java.time as an underlying implementation of dates parsing, formatting and calculations.\n+java.time is in many aspects very similar to joda-time which we previously used. However there are some differences and this guide is meant to\n+help you to become compatible.\n+\n+==== Identifying if you are affected", "originalCommit": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkyMTEyNw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r393921127", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You are only affected if you have used any custom date formats in your mappings, pipelines or templates.\n          \n          \n            \n            The switch to java time only impacts custom <<date,`date`>> and\n          \n          \n            \n            <<date_nanos,`date_nanos`>> formats.\n          \n          \n            \n            \n          \n          \n            \n             These formats are commonly used in:\n          \n          \n            \n            \n          \n          \n            \n            * <<mapping,Index mappings>>\n          \n          \n            \n            * <<indices-templates,Index templates>>\n          \n          \n            \n            * <<pipeline,Ingest pipelines>>\n          \n          \n            \n            \n          \n          \n            \n            If you don't use custom date formats, you can skip the rest of this guide.", "author": "jrodewig", "createdAt": "2020-03-17T19:33:21Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,309 @@\n+[[migrate_to_java_time]]\n+=== Java Time Migration Guide\n+\n+Since version 7.0 Elasticsearch is using java.time as an underlying implementation of dates parsing, formatting and calculations.\n+java.time is in many aspects very similar to joda-time which we previously used. However there are some differences and this guide is meant to\n+help you to become compatible.\n+\n+==== Identifying if you are affected\n+You are only affected if you have used any custom date formats in your mappings, pipelines or templates.", "originalCommit": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkyNTMwNw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r393925307", "bodyText": "I think we can remove this section entirely.", "author": "jrodewig", "createdAt": "2020-03-17T19:41:25Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,309 @@\n+[[migrate_to_java_time]]\n+=== Java Time Migration Guide\n+\n+Since version 7.0 Elasticsearch is using java.time as an underlying implementation of dates parsing, formatting and calculations.\n+java.time is in many aspects very similar to joda-time which we previously used. However there are some differences and this guide is meant to\n+help you to become compatible.\n+\n+==== Identifying if you are affected\n+You are only affected if you have used any custom date formats in your mappings, pipelines or templates.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+A custom format is specified on a date field like this:\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"date\": {\n+        \"type\":   \"date\",\n+        \"format\": \"YYYY/MM/dd HH:mm:ss||YYYY/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------", "originalCommit": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEzMjIxMw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r394132213", "bodyText": "will remove", "author": "pgomulka", "createdAt": "2020-03-18T06:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkyNTMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkyNjY2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r393926665", "bodyText": "To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\nor the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]", "author": "jrodewig", "createdAt": "2020-03-17T19:44:08Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,309 @@\n+[[migrate_to_java_time]]\n+=== Java Time Migration Guide\n+\n+Since version 7.0 Elasticsearch is using java.time as an underlying implementation of dates parsing, formatting and calculations.\n+java.time is in many aspects very similar to joda-time which we previously used. However there are some differences and this guide is meant to\n+help you to become compatible.\n+\n+==== Identifying if you are affected\n+You are only affected if you have used any custom date formats in your mappings, pipelines or templates.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+A custom format is specified on a date field like this:\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"date\": {\n+        \"type\":   \"date\",\n+        \"format\": \"YYYY/MM/dd HH:mm:ss||YYYY/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+To make sure if any of the date formats is deprecated run deprecation API or kibana upgrade assistant.", "originalCommit": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkyNjg4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r393926886", "bodyText": "I'm not sure if this is needed. I'd remove it.", "author": "jrodewig", "createdAt": "2020-03-17T19:44:36Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,309 @@\n+[[migrate_to_java_time]]\n+=== Java Time Migration Guide\n+\n+Since version 7.0 Elasticsearch is using java.time as an underlying implementation of dates parsing, formatting and calculations.\n+java.time is in many aspects very similar to joda-time which we previously used. However there are some differences and this guide is meant to\n+help you to become compatible.\n+\n+==== Identifying if you are affected\n+You are only affected if you have used any custom date formats in your mappings, pipelines or templates.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+A custom format is specified on a date field like this:\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"date\": {\n+        \"type\":   \"date\",\n+        \"format\": \"YYYY/MM/dd HH:mm:ss||YYYY/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+To make sure if any of the date formats is deprecated run deprecation API or kibana upgrade assistant.\n+//todo fix this\n+xx migration-api-deprecation xx\n+xxinclude ::../apis/deprecation.asciidoc\n+\n+Sample output of deprecation api will be as follows:\n+[source,text]\n+--------------------------------------------------\n+This index has date fields with deprecated formats: [[type: doc, field: param2, format: yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis, suggestion: 'y' year should be replaced with 'u'. Use 'y' for year-of-era.]]. Prefix your date format with '8' to use the new specifier.\n+--------------------------------------------------\n+", "originalCommit": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkyODcwMg==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r393928702", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If a pattern contains literals below, that means the pattern is incompatible and needs to be changed.\n          \n          \n            \n            Custom date formats containing the following joda time literals should be\n          \n          \n            \n            changed before upgrading.", "author": "jrodewig", "createdAt": "2020-03-17T19:47:58Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,309 @@\n+[[migrate_to_java_time]]\n+=== Java Time Migration Guide\n+\n+Since version 7.0 Elasticsearch is using java.time as an underlying implementation of dates parsing, formatting and calculations.\n+java.time is in many aspects very similar to joda-time which we previously used. However there are some differences and this guide is meant to\n+help you to become compatible.\n+\n+==== Identifying if you are affected\n+You are only affected if you have used any custom date formats in your mappings, pipelines or templates.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+A custom format is specified on a date field like this:\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"date\": {\n+        \"type\":   \"date\",\n+        \"format\": \"YYYY/MM/dd HH:mm:ss||YYYY/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+To make sure if any of the date formats is deprecated run deprecation API or kibana upgrade assistant.\n+//todo fix this\n+xx migration-api-deprecation xx\n+xxinclude ::../apis/deprecation.asciidoc\n+\n+Sample output of deprecation api will be as follows:\n+[source,text]\n+--------------------------------------------------\n+This index has date fields with deprecated formats: [[type: doc, field: param2, format: yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis, suggestion: 'y' year should be replaced with 'u'. Use 'y' for year-of-era.]]. Prefix your date format with '8' to use the new specifier.\n+--------------------------------------------------\n+\n+\n+==== Incompatible formats\n+If a pattern contains literals below, that means the pattern is incompatible and needs to be changed.", "originalCommit": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkzMTcyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r393931725", "bodyText": "Rather than using headings =====, I'd create a definition list with each literal:\n`Y` (Year of era)::\n+\n--\nReplace with `y`. \n\n*Example:*\n`YYYY-MM-dd` should become `yyyy-MM-dd`\n\nIn java time, `Y` is used for\nhttps://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based\nyear]. Using `Y` in place of `y` could result in off-by-one errors in year\ncalculation.\n--", "author": "jrodewig", "createdAt": "2020-03-17T19:53:41Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,309 @@\n+[[migrate_to_java_time]]\n+=== Java Time Migration Guide\n+\n+Since version 7.0 Elasticsearch is using java.time as an underlying implementation of dates parsing, formatting and calculations.\n+java.time is in many aspects very similar to joda-time which we previously used. However there are some differences and this guide is meant to\n+help you to become compatible.\n+\n+==== Identifying if you are affected\n+You are only affected if you have used any custom date formats in your mappings, pipelines or templates.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+A custom format is specified on a date field like this:\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"date\": {\n+        \"type\":   \"date\",\n+        \"format\": \"YYYY/MM/dd HH:mm:ss||YYYY/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+To make sure if any of the date formats is deprecated run deprecation API or kibana upgrade assistant.\n+//todo fix this\n+xx migration-api-deprecation xx\n+xxinclude ::../apis/deprecation.asciidoc\n+\n+Sample output of deprecation api will be as follows:\n+[source,text]\n+--------------------------------------------------\n+This index has date fields with deprecated formats: [[type: doc, field: param2, format: yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis, suggestion: 'y' year should be replaced with 'u'. Use 'y' for year-of-era.]]. Prefix your date format with '8' to use the new specifier.\n+--------------------------------------------------\n+\n+\n+==== Incompatible formats\n+If a pattern contains literals below, that means the pattern is incompatible and needs to be changed.\n+\n+===== Y - in 6.8 meaning Year of era. It should be replaced to y in 7.0 This is a big change because in 7.0 'Y' means week-based-year.", "originalCommit": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE1MTA4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r394151082", "bodyText": "good idea - fixed", "author": "pgomulka", "createdAt": "2020-03-18T07:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkzMTcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkzNzU2MA==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r393937560", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            ////", "author": "jrodewig", "createdAt": "2020-03-17T20:04:39Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,309 @@\n+[[migrate_to_java_time]]\n+=== Java Time Migration Guide\n+\n+Since version 7.0 Elasticsearch is using java.time as an underlying implementation of dates parsing, formatting and calculations.\n+java.time is in many aspects very similar to joda-time which we previously used. However there are some differences and this guide is meant to\n+help you to become compatible.\n+\n+==== Identifying if you are affected\n+You are only affected if you have used any custom date formats in your mappings, pipelines or templates.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+A custom format is specified on a date field like this:\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"date\": {\n+        \"type\":   \"date\",\n+        \"format\": \"YYYY/MM/dd HH:mm:ss||YYYY/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+To make sure if any of the date formats is deprecated run deprecation API or kibana upgrade assistant.\n+//todo fix this\n+xx migration-api-deprecation xx\n+xxinclude ::../apis/deprecation.asciidoc\n+\n+Sample output of deprecation api will be as follows:\n+[source,text]\n+--------------------------------------------------\n+This index has date fields with deprecated formats: [[type: doc, field: param2, format: yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis, suggestion: 'y' year should be replaced with 'u'. Use 'y' for year-of-era.]]. Prefix your date format with '8' to use the new specifier.\n+--------------------------------------------------\n+\n+\n+==== Incompatible formats\n+If a pattern contains literals below, that means the pattern is incompatible and needs to be changed.\n+\n+===== Y - in 6.8 meaning Year of era. It should be replaced to y in 7.0 This is a big change because in 7.0 'Y' means week-based-year.\n+If you don't update your date pattern, you will have problems with search results, parsing and date calculations.\n+example:\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+====== The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+\n+===== y - in 6.8 meaning year. It should be replaced to 'u' in 7.0. This is a subtle change, but worth fixing.\n+As previously stated `y` means year-of-era. `u` means year. The difference is that year can contain non positive values, whereas `y` can not. //clarify 0 year\n+year-of-era can also be associated with an era field.\n+\n+===== C - century of era is no longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+\n+===== x - in 6.8 meaning week year. It should be replaced with 'Y' in 7.0. Again a big change as 'x' means zone-offset in 7.0.\n+You will get parsing and search problems if you do not update this.\n+\n+===== Z - in 6.8 meaning time zone offset/id. It has similar meaning in 7.0 with a notable difference that it expects different number of literals\n+to parse different forms.\n+It also won't parse `Z` for Zulu timezone. You should consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+\n+===== d for day.\n+This one have the same meaning in 7.0 but are less flexible.\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expects dates in form\n+`2010-01-01` or `2010-01-1`\n+You will need to provide an alternative pattern for all of these.\n+`yyyy-MM-dd||yyyy-MM-d`\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+\n+===== e for name of day\n+Also has a similar meaning in 7.0. However was more flexible in 6.8 and allowed to parse short and full text forms.\n+if you used `EEE YYYY-MM` for a format and expected days in form:\n+Wed 2020-01 or Wednesday 2020-01\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+\n+===== more on text forms EEEE and similar\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+\n+===== 'z'\n+'z' time zone text. Will print 'Z' for Zulu given UTC timezone.\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expected your timezone to only be in `+01:00` form (XXX in java, ZZ in joda),\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n+\n+==== Migrating affected mappings\n+Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping\n+and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.\n+\n+===== Example migration procedure\n+Let's assume that you have an index with a date field and custom format\n+////\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_1\n+{\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+}\n+--------------------------------------------------\n+", "originalCommit": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkzNzY2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r393937665", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ////", "author": "jrodewig", "createdAt": "2020-03-17T20:04:50Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,309 @@\n+[[migrate_to_java_time]]\n+=== Java Time Migration Guide\n+\n+Since version 7.0 Elasticsearch is using java.time as an underlying implementation of dates parsing, formatting and calculations.\n+java.time is in many aspects very similar to joda-time which we previously used. However there are some differences and this guide is meant to\n+help you to become compatible.\n+\n+==== Identifying if you are affected\n+You are only affected if you have used any custom date formats in your mappings, pipelines or templates.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+A custom format is specified on a date field like this:\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"date\": {\n+        \"type\":   \"date\",\n+        \"format\": \"YYYY/MM/dd HH:mm:ss||YYYY/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+To make sure if any of the date formats is deprecated run deprecation API or kibana upgrade assistant.\n+//todo fix this\n+xx migration-api-deprecation xx\n+xxinclude ::../apis/deprecation.asciidoc\n+\n+Sample output of deprecation api will be as follows:\n+[source,text]\n+--------------------------------------------------\n+This index has date fields with deprecated formats: [[type: doc, field: param2, format: yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis, suggestion: 'y' year should be replaced with 'u'. Use 'y' for year-of-era.]]. Prefix your date format with '8' to use the new specifier.\n+--------------------------------------------------\n+\n+\n+==== Incompatible formats\n+If a pattern contains literals below, that means the pattern is incompatible and needs to be changed.\n+\n+===== Y - in 6.8 meaning Year of era. It should be replaced to y in 7.0 This is a big change because in 7.0 'Y' means week-based-year.\n+If you don't update your date pattern, you will have problems with search results, parsing and date calculations.\n+example:\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+====== The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+\n+===== y - in 6.8 meaning year. It should be replaced to 'u' in 7.0. This is a subtle change, but worth fixing.\n+As previously stated `y` means year-of-era. `u` means year. The difference is that year can contain non positive values, whereas `y` can not. //clarify 0 year\n+year-of-era can also be associated with an era field.\n+\n+===== C - century of era is no longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+\n+===== x - in 6.8 meaning week year. It should be replaced with 'Y' in 7.0. Again a big change as 'x' means zone-offset in 7.0.\n+You will get parsing and search problems if you do not update this.\n+\n+===== Z - in 6.8 meaning time zone offset/id. It has similar meaning in 7.0 with a notable difference that it expects different number of literals\n+to parse different forms.\n+It also won't parse `Z` for Zulu timezone. You should consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+\n+===== d for day.\n+This one have the same meaning in 7.0 but are less flexible.\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expects dates in form\n+`2010-01-01` or `2010-01-1`\n+You will need to provide an alternative pattern for all of these.\n+`yyyy-MM-dd||yyyy-MM-d`\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+\n+===== e for name of day\n+Also has a similar meaning in 7.0. However was more flexible in 6.8 and allowed to parse short and full text forms.\n+if you used `EEE YYYY-MM` for a format and expected days in form:\n+Wed 2020-01 or Wednesday 2020-01\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+\n+===== more on text forms EEEE and similar\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+\n+===== 'z'\n+'z' time zone text. Will print 'Z' for Zulu given UTC timezone.\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expected your timezone to only be in `+01:00` form (XXX in java, ZZ in joda),\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n+\n+==== Migrating affected mappings\n+Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping\n+and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.\n+\n+===== Example migration procedure\n+Let's assume that you have an index with a date field and custom format\n+////\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_1\n+{\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+}\n+--------------------------------------------------\n+\n+\n+[source,console]\n+--------------------------------------------------\n+GET my_index_1/_mapping\n+--------------------------------------------------\n+// TEST[continued]\n+\n+[source,js]\n+--------------------------------------------------\n+{\n+  \"my_index_1\" : {\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+\n+* Create my_index_2 with mappings changed with the format set to 8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_2\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"datetime\": {\n+        \"type\": \"date\",\n+        \"format\": \"8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+* Reindex the deprecated format index to new_index_1\n+\n+[source,console]\n+--------------------------------------------------\n+POST _reindex\n+{\n+  \"source\": {\n+    \"index\": \"my_index_1\"\n+  },\n+  \"dest\": {\n+    \"index\": \"my_index_2\"\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+* If you were using aliases, update them to a new index\n+\n+[source,console]\n+--------------------------------------------------\n+POST /_aliases\n+{\n+    \"actions\" : [\n+        { \"remove\" : { \"index\" : \"my_index_1\", \"alias\" : \"my_index\" } },\n+        { \"add\" : { \"index\" : \"my_index_2\", \"alias\" : \"my_index\" } }\n+    ]\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+===== Update before upgrading to ES7.\n+* update pipeline\n+If your pipelines were using a joda style patterns, they also have to be updated. There is no need to create a new pipeline.\n+Just update the already existing one.\n+\n+[source,console]\n+--------------------------------------------------\n+PUT _ingest/pipeline/mypipeline\n+{\n+  \"description\": \"Pipeline for routing data to specific index\",\n+  \"processors\": [\n+    {\n+      \"date\": {\n+        \"field\": \"createdTime\",\n+        \"formats\": [\n+         \"8uuuu-w\"\n+        ]\n+      },\n+      \"date_index_name\": {\n+        \"field\": \"@timestamp\",\n+        \"date_rounding\": \"d\",\n+        \"index_name_prefix\": \"x-\",\n+        \"index_name_format\": \"8uuuu-w\"\n+      }\n+    }\n+  ]\n+}\n+--------------------------------------------------\n+\n+\n+* upgrade template\n+If your template was using joda date pattern it also should be updated before upgrading to ES7.\n+\n+[source,console]\n+--------------------------------------------------\n+PUT _template/template_1\n+{\n+  \"index_patterns\": [\n+    \"te*\",\n+    \"bar*\"\n+  ],\n+  \"settings\": {\n+    \"number_of_shards\": 1\n+  },\n+  \"mappings\": {\n+    \"_source\": {\n+      \"enabled\": false\n+    },\n+    \"properties\": {\n+      \"host_name\": {\n+        \"type\": \"keyword\"\n+      },\n+      \"created_at\": {\n+        \"type\": \"date\",\n+        \"format\": \"8EEE MMM dd HH:mm:ss Z yyyy\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+////", "originalCommit": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkzNzc5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r393937792", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            [source,js]\n          \n          \n            \n            [source,console-result]", "author": "jrodewig", "createdAt": "2020-03-17T20:05:09Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,309 @@\n+[[migrate_to_java_time]]\n+=== Java Time Migration Guide\n+\n+Since version 7.0 Elasticsearch is using java.time as an underlying implementation of dates parsing, formatting and calculations.\n+java.time is in many aspects very similar to joda-time which we previously used. However there are some differences and this guide is meant to\n+help you to become compatible.\n+\n+==== Identifying if you are affected\n+You are only affected if you have used any custom date formats in your mappings, pipelines or templates.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+A custom format is specified on a date field like this:\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"date\": {\n+        \"type\":   \"date\",\n+        \"format\": \"YYYY/MM/dd HH:mm:ss||YYYY/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+To make sure if any of the date formats is deprecated run deprecation API or kibana upgrade assistant.\n+//todo fix this\n+xx migration-api-deprecation xx\n+xxinclude ::../apis/deprecation.asciidoc\n+\n+Sample output of deprecation api will be as follows:\n+[source,text]\n+--------------------------------------------------\n+This index has date fields with deprecated formats: [[type: doc, field: param2, format: yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis, suggestion: 'y' year should be replaced with 'u'. Use 'y' for year-of-era.]]. Prefix your date format with '8' to use the new specifier.\n+--------------------------------------------------\n+\n+\n+==== Incompatible formats\n+If a pattern contains literals below, that means the pattern is incompatible and needs to be changed.\n+\n+===== Y - in 6.8 meaning Year of era. It should be replaced to y in 7.0 This is a big change because in 7.0 'Y' means week-based-year.\n+If you don't update your date pattern, you will have problems with search results, parsing and date calculations.\n+example:\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+====== The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+\n+===== y - in 6.8 meaning year. It should be replaced to 'u' in 7.0. This is a subtle change, but worth fixing.\n+As previously stated `y` means year-of-era. `u` means year. The difference is that year can contain non positive values, whereas `y` can not. //clarify 0 year\n+year-of-era can also be associated with an era field.\n+\n+===== C - century of era is no longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+\n+===== x - in 6.8 meaning week year. It should be replaced with 'Y' in 7.0. Again a big change as 'x' means zone-offset in 7.0.\n+You will get parsing and search problems if you do not update this.\n+\n+===== Z - in 6.8 meaning time zone offset/id. It has similar meaning in 7.0 with a notable difference that it expects different number of literals\n+to parse different forms.\n+It also won't parse `Z` for Zulu timezone. You should consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+\n+===== d for day.\n+This one have the same meaning in 7.0 but are less flexible.\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expects dates in form\n+`2010-01-01` or `2010-01-1`\n+You will need to provide an alternative pattern for all of these.\n+`yyyy-MM-dd||yyyy-MM-d`\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+\n+===== e for name of day\n+Also has a similar meaning in 7.0. However was more flexible in 6.8 and allowed to parse short and full text forms.\n+if you used `EEE YYYY-MM` for a format and expected days in form:\n+Wed 2020-01 or Wednesday 2020-01\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+\n+===== more on text forms EEEE and similar\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+\n+===== 'z'\n+'z' time zone text. Will print 'Z' for Zulu given UTC timezone.\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expected your timezone to only be in `+01:00` form (XXX in java, ZZ in joda),\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n+\n+==== Migrating affected mappings\n+Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping\n+and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.\n+\n+===== Example migration procedure\n+Let's assume that you have an index with a date field and custom format\n+////\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_1\n+{\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+}\n+--------------------------------------------------\n+\n+\n+[source,console]\n+--------------------------------------------------\n+GET my_index_1/_mapping\n+--------------------------------------------------\n+// TEST[continued]\n+\n+[source,js]", "originalCommit": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkzNzg2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r393937863", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // NOTCONSOLE", "author": "jrodewig", "createdAt": "2020-03-17T20:05:17Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,309 @@\n+[[migrate_to_java_time]]\n+=== Java Time Migration Guide\n+\n+Since version 7.0 Elasticsearch is using java.time as an underlying implementation of dates parsing, formatting and calculations.\n+java.time is in many aspects very similar to joda-time which we previously used. However there are some differences and this guide is meant to\n+help you to become compatible.\n+\n+==== Identifying if you are affected\n+You are only affected if you have used any custom date formats in your mappings, pipelines or templates.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+A custom format is specified on a date field like this:\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"date\": {\n+        \"type\":   \"date\",\n+        \"format\": \"YYYY/MM/dd HH:mm:ss||YYYY/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+To make sure if any of the date formats is deprecated run deprecation API or kibana upgrade assistant.\n+//todo fix this\n+xx migration-api-deprecation xx\n+xxinclude ::../apis/deprecation.asciidoc\n+\n+Sample output of deprecation api will be as follows:\n+[source,text]\n+--------------------------------------------------\n+This index has date fields with deprecated formats: [[type: doc, field: param2, format: yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis, suggestion: 'y' year should be replaced with 'u'. Use 'y' for year-of-era.]]. Prefix your date format with '8' to use the new specifier.\n+--------------------------------------------------\n+\n+\n+==== Incompatible formats\n+If a pattern contains literals below, that means the pattern is incompatible and needs to be changed.\n+\n+===== Y - in 6.8 meaning Year of era. It should be replaced to y in 7.0 This is a big change because in 7.0 'Y' means week-based-year.\n+If you don't update your date pattern, you will have problems with search results, parsing and date calculations.\n+example:\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+====== The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+\n+===== y - in 6.8 meaning year. It should be replaced to 'u' in 7.0. This is a subtle change, but worth fixing.\n+As previously stated `y` means year-of-era. `u` means year. The difference is that year can contain non positive values, whereas `y` can not. //clarify 0 year\n+year-of-era can also be associated with an era field.\n+\n+===== C - century of era is no longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+\n+===== x - in 6.8 meaning week year. It should be replaced with 'Y' in 7.0. Again a big change as 'x' means zone-offset in 7.0.\n+You will get parsing and search problems if you do not update this.\n+\n+===== Z - in 6.8 meaning time zone offset/id. It has similar meaning in 7.0 with a notable difference that it expects different number of literals\n+to parse different forms.\n+It also won't parse `Z` for Zulu timezone. You should consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+\n+===== d for day.\n+This one have the same meaning in 7.0 but are less flexible.\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expects dates in form\n+`2010-01-01` or `2010-01-1`\n+You will need to provide an alternative pattern for all of these.\n+`yyyy-MM-dd||yyyy-MM-d`\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+\n+===== e for name of day\n+Also has a similar meaning in 7.0. However was more flexible in 6.8 and allowed to parse short and full text forms.\n+if you used `EEE YYYY-MM` for a format and expected days in form:\n+Wed 2020-01 or Wednesday 2020-01\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+\n+===== more on text forms EEEE and similar\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+\n+===== 'z'\n+'z' time zone text. Will print 'Z' for Zulu given UTC timezone.\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expected your timezone to only be in `+01:00` form (XXX in java, ZZ in joda),\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n+\n+==== Migrating affected mappings\n+Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping\n+and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.\n+\n+===== Example migration procedure\n+Let's assume that you have an index with a date field and custom format\n+////\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_1\n+{\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+}\n+--------------------------------------------------\n+\n+\n+[source,console]\n+--------------------------------------------------\n+GET my_index_1/_mapping\n+--------------------------------------------------\n+// TEST[continued]\n+\n+[source,js]\n+--------------------------------------------------\n+{\n+  \"my_index_1\" : {\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+// NOTCONSOLE", "originalCommit": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkzODY3NA==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r393938674", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Create my_index_2 with mappings changed with the format set to 8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis\n          \n          \n            \n            * Create my_index_2 with mappings changed with the format set to `8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis`", "author": "jrodewig", "createdAt": "2020-03-17T20:06:47Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,309 @@\n+[[migrate_to_java_time]]\n+=== Java Time Migration Guide\n+\n+Since version 7.0 Elasticsearch is using java.time as an underlying implementation of dates parsing, formatting and calculations.\n+java.time is in many aspects very similar to joda-time which we previously used. However there are some differences and this guide is meant to\n+help you to become compatible.\n+\n+==== Identifying if you are affected\n+You are only affected if you have used any custom date formats in your mappings, pipelines or templates.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+A custom format is specified on a date field like this:\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"date\": {\n+        \"type\":   \"date\",\n+        \"format\": \"YYYY/MM/dd HH:mm:ss||YYYY/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+To make sure if any of the date formats is deprecated run deprecation API or kibana upgrade assistant.\n+//todo fix this\n+xx migration-api-deprecation xx\n+xxinclude ::../apis/deprecation.asciidoc\n+\n+Sample output of deprecation api will be as follows:\n+[source,text]\n+--------------------------------------------------\n+This index has date fields with deprecated formats: [[type: doc, field: param2, format: yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis, suggestion: 'y' year should be replaced with 'u'. Use 'y' for year-of-era.]]. Prefix your date format with '8' to use the new specifier.\n+--------------------------------------------------\n+\n+\n+==== Incompatible formats\n+If a pattern contains literals below, that means the pattern is incompatible and needs to be changed.\n+\n+===== Y - in 6.8 meaning Year of era. It should be replaced to y in 7.0 This is a big change because in 7.0 'Y' means week-based-year.\n+If you don't update your date pattern, you will have problems with search results, parsing and date calculations.\n+example:\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+====== The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+\n+===== y - in 6.8 meaning year. It should be replaced to 'u' in 7.0. This is a subtle change, but worth fixing.\n+As previously stated `y` means year-of-era. `u` means year. The difference is that year can contain non positive values, whereas `y` can not. //clarify 0 year\n+year-of-era can also be associated with an era field.\n+\n+===== C - century of era is no longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+\n+===== x - in 6.8 meaning week year. It should be replaced with 'Y' in 7.0. Again a big change as 'x' means zone-offset in 7.0.\n+You will get parsing and search problems if you do not update this.\n+\n+===== Z - in 6.8 meaning time zone offset/id. It has similar meaning in 7.0 with a notable difference that it expects different number of literals\n+to parse different forms.\n+It also won't parse `Z` for Zulu timezone. You should consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+\n+===== d for day.\n+This one have the same meaning in 7.0 but are less flexible.\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expects dates in form\n+`2010-01-01` or `2010-01-1`\n+You will need to provide an alternative pattern for all of these.\n+`yyyy-MM-dd||yyyy-MM-d`\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+\n+===== e for name of day\n+Also has a similar meaning in 7.0. However was more flexible in 6.8 and allowed to parse short and full text forms.\n+if you used `EEE YYYY-MM` for a format and expected days in form:\n+Wed 2020-01 or Wednesday 2020-01\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+\n+===== more on text forms EEEE and similar\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+\n+===== 'z'\n+'z' time zone text. Will print 'Z' for Zulu given UTC timezone.\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expected your timezone to only be in `+01:00` form (XXX in java, ZZ in joda),\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n+\n+==== Migrating affected mappings\n+Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping\n+and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.\n+\n+===== Example migration procedure\n+Let's assume that you have an index with a date field and custom format\n+////\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_1\n+{\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+}\n+--------------------------------------------------\n+\n+\n+[source,console]\n+--------------------------------------------------\n+GET my_index_1/_mapping\n+--------------------------------------------------\n+// TEST[continued]\n+\n+[source,js]\n+--------------------------------------------------\n+{\n+  \"my_index_1\" : {\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+\n+* Create my_index_2 with mappings changed with the format set to 8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis", "originalCommit": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkzODgyMw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r393938823", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * update pipeline", "author": "jrodewig", "createdAt": "2020-03-17T20:07:06Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,309 @@\n+[[migrate_to_java_time]]\n+=== Java Time Migration Guide\n+\n+Since version 7.0 Elasticsearch is using java.time as an underlying implementation of dates parsing, formatting and calculations.\n+java.time is in many aspects very similar to joda-time which we previously used. However there are some differences and this guide is meant to\n+help you to become compatible.\n+\n+==== Identifying if you are affected\n+You are only affected if you have used any custom date formats in your mappings, pipelines or templates.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+A custom format is specified on a date field like this:\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"date\": {\n+        \"type\":   \"date\",\n+        \"format\": \"YYYY/MM/dd HH:mm:ss||YYYY/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+To make sure if any of the date formats is deprecated run deprecation API or kibana upgrade assistant.\n+//todo fix this\n+xx migration-api-deprecation xx\n+xxinclude ::../apis/deprecation.asciidoc\n+\n+Sample output of deprecation api will be as follows:\n+[source,text]\n+--------------------------------------------------\n+This index has date fields with deprecated formats: [[type: doc, field: param2, format: yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis, suggestion: 'y' year should be replaced with 'u'. Use 'y' for year-of-era.]]. Prefix your date format with '8' to use the new specifier.\n+--------------------------------------------------\n+\n+\n+==== Incompatible formats\n+If a pattern contains literals below, that means the pattern is incompatible and needs to be changed.\n+\n+===== Y - in 6.8 meaning Year of era. It should be replaced to y in 7.0 This is a big change because in 7.0 'Y' means week-based-year.\n+If you don't update your date pattern, you will have problems with search results, parsing and date calculations.\n+example:\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+====== The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+\n+===== y - in 6.8 meaning year. It should be replaced to 'u' in 7.0. This is a subtle change, but worth fixing.\n+As previously stated `y` means year-of-era. `u` means year. The difference is that year can contain non positive values, whereas `y` can not. //clarify 0 year\n+year-of-era can also be associated with an era field.\n+\n+===== C - century of era is no longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+\n+===== x - in 6.8 meaning week year. It should be replaced with 'Y' in 7.0. Again a big change as 'x' means zone-offset in 7.0.\n+You will get parsing and search problems if you do not update this.\n+\n+===== Z - in 6.8 meaning time zone offset/id. It has similar meaning in 7.0 with a notable difference that it expects different number of literals\n+to parse different forms.\n+It also won't parse `Z` for Zulu timezone. You should consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+\n+===== d for day.\n+This one have the same meaning in 7.0 but are less flexible.\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expects dates in form\n+`2010-01-01` or `2010-01-1`\n+You will need to provide an alternative pattern for all of these.\n+`yyyy-MM-dd||yyyy-MM-d`\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+\n+===== e for name of day\n+Also has a similar meaning in 7.0. However was more flexible in 6.8 and allowed to parse short and full text forms.\n+if you used `EEE YYYY-MM` for a format and expected days in form:\n+Wed 2020-01 or Wednesday 2020-01\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+\n+===== more on text forms EEEE and similar\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+\n+===== 'z'\n+'z' time zone text. Will print 'Z' for Zulu given UTC timezone.\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expected your timezone to only be in `+01:00` form (XXX in java, ZZ in joda),\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n+\n+==== Migrating affected mappings\n+Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping\n+and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.\n+\n+===== Example migration procedure\n+Let's assume that you have an index with a date field and custom format\n+////\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_1\n+{\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+}\n+--------------------------------------------------\n+\n+\n+[source,console]\n+--------------------------------------------------\n+GET my_index_1/_mapping\n+--------------------------------------------------\n+// TEST[continued]\n+\n+[source,js]\n+--------------------------------------------------\n+{\n+  \"my_index_1\" : {\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+\n+* Create my_index_2 with mappings changed with the format set to 8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_2\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"datetime\": {\n+        \"type\": \"date\",\n+        \"format\": \"8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+* Reindex the deprecated format index to new_index_1\n+\n+[source,console]\n+--------------------------------------------------\n+POST _reindex\n+{\n+  \"source\": {\n+    \"index\": \"my_index_1\"\n+  },\n+  \"dest\": {\n+    \"index\": \"my_index_2\"\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+* If you were using aliases, update them to a new index\n+\n+[source,console]\n+--------------------------------------------------\n+POST /_aliases\n+{\n+    \"actions\" : [\n+        { \"remove\" : { \"index\" : \"my_index_1\", \"alias\" : \"my_index\" } },\n+        { \"add\" : { \"index\" : \"my_index_2\", \"alias\" : \"my_index\" } }\n+    ]\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+===== Update before upgrading to ES7.\n+* update pipeline", "originalCommit": "2cdf1eccbd4f3ab4c76b4c764423750817cfab05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "01d73d62eed845d8b80cfbf50c75b7ac9d7b26a5", "url": "https://github.com/elastic/elasticsearch/commit/01d73d62eed845d8b80cfbf50c75b7ac9d7b26a5", "message": "Update docs/reference/migration/migrate_7_0/java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-18T06:36:28Z", "type": "commit"}, {"oid": "c2673dbffe40f7b1c0843b533c53f41b73456040", "url": "https://github.com/elastic/elasticsearch/commit/c2673dbffe40f7b1c0843b533c53f41b73456040", "message": "Update docs/reference/migration/migrate_7_0/java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-18T06:36:44Z", "type": "commit"}, {"oid": "02eca6b263e7c92eaa4d3018778ebff8d2c26235", "url": "https://github.com/elastic/elasticsearch/commit/02eca6b263e7c92eaa4d3018778ebff8d2c26235", "message": "Update docs/reference/migration/migrate_7_0/java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-18T06:36:55Z", "type": "commit"}, {"oid": "e0aed7804665ff1b76de944e5749fb4bfe268531", "url": "https://github.com/elastic/elasticsearch/commit/e0aed7804665ff1b76de944e5749fb4bfe268531", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-18T06:37:34Z", "type": "commit"}, {"oid": "2f695b5463b4a7e17bfd1d8e0f51464034e0564f", "url": "https://github.com/elastic/elasticsearch/commit/2f695b5463b4a7e17bfd1d8e0f51464034e0564f", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-18T06:38:28Z", "type": "commit"}, {"oid": "3bd83f4697da234622395d9aab1d42e283f84964", "url": "https://github.com/elastic/elasticsearch/commit/3bd83f4697da234622395d9aab1d42e283f84964", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-18T06:39:17Z", "type": "commit"}, {"oid": "88ad15b23872a7188867975f7f992f99b52121de", "url": "https://github.com/elastic/elasticsearch/commit/88ad15b23872a7188867975f7f992f99b52121de", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-18T06:39:42Z", "type": "commit"}, {"oid": "79c5ada7421284384c491ccb6bdf45d6c8d25de2", "url": "https://github.com/elastic/elasticsearch/commit/79c5ada7421284384c491ccb6bdf45d6c8d25de2", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-18T06:41:06Z", "type": "commit"}, {"oid": "48bfbdf503496d4b8520f2ec9371a8b602c3f612", "url": "https://github.com/elastic/elasticsearch/commit/48bfbdf503496d4b8520f2ec9371a8b602c3f612", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-18T06:41:19Z", "type": "commit"}, {"oid": "9c154838d2d339e3c727b1a224fbbb6dcc4dd61f", "url": "https://github.com/elastic/elasticsearch/commit/9c154838d2d339e3c727b1a224fbbb6dcc4dd61f", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-18T06:41:28Z", "type": "commit"}, {"oid": "c10e7c15b6122809e799604e4373cf3286033192", "url": "https://github.com/elastic/elasticsearch/commit/c10e7c15b6122809e799604e4373cf3286033192", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-18T06:41:36Z", "type": "commit"}, {"oid": "cf6c0eff4488fdc08a2dc56bbfbf4f1127338f7f", "url": "https://github.com/elastic/elasticsearch/commit/cf6c0eff4488fdc08a2dc56bbfbf4f1127338f7f", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-18T06:41:44Z", "type": "commit"}, {"oid": "5e85c5384bb8961a2c5146818f674fa41b29e6be", "url": "https://github.com/elastic/elasticsearch/commit/5e85c5384bb8961a2c5146818f674fa41b29e6be", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-18T06:41:52Z", "type": "commit"}, {"oid": "72478aba8c76eec8378d34db1041eb7095ae745e", "url": "https://github.com/elastic/elasticsearch/commit/72478aba8c76eec8378d34db1041eb7095ae745e", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-18T06:42:19Z", "type": "commit"}, {"oid": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "url": "https://github.com/elastic/elasticsearch/commit/b51fea425b6ccf972df41a06b6b9151b2efb56a9", "message": "review follow up", "committedDate": "2020-03-18T08:03:10Z", "type": "commit"}, {"oid": "e0f99f49edb0b4e00d4ce5d6189dc34c237e7d98", "url": "https://github.com/elastic/elasticsearch/commit/e0f99f49edb0b4e00d4ce5d6189dc34c237e7d98", "message": "known issue", "committedDate": "2020-03-18T08:22:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxMTgxMg==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395311812", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            With 7.0, {es} switch to java time from joda time for date-related parsing,\n          \n          \n            \n            With 7.0, {es} switched from joda time to java time for date-related parsing,", "author": "jrodewig", "createdAt": "2020-03-19T20:50:24Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxOTY2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395319662", "bodyText": "As this will be used to create a URL, we try to use hyphens.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            [[migrate_to_java_time]]\n          \n          \n            \n            [[migrate-to-java-time]]", "author": "jrodewig", "createdAt": "2020-03-19T21:06:39Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMyMDMyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395320329", "bodyText": "I would add this as a new section. If possible, move it below the \"Impacted features\" section.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n          \n          \n            \n            All new indices created in 7.x are expected to be using java-time patterns.\n          \n          \n            \n            \n          \n          \n            \n            We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n          \n          \n            \n            \n          \n          \n            \n            - In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n          \n          \n            \n            - In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n          \n          \n            \n            - Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n          \n          \n            \n            [[java-time-convert-date-formats]]\n          \n          \n            \n            === Convert date formats\n          \n          \n            \n            \n          \n          \n            \n            To upgrade to 7.0, you'll need to convert any joda-time date formats\n          \n          \n            \n            to their java-time equivalents.\n          \n          \n            \n            \n          \n          \n            \n            To help track this effort, you can prefix java-time date formats with an `8`\n          \n          \n            \n            prefix in {es} 6.8 and later versions.\n          \n          \n            \n            \n          \n          \n            \n            For example, you can change the date format `YYYY-MM-dd` to `8yyyy-MM-dd` to\n          \n          \n            \n            indicate the date format uses java time.\n          \n          \n            \n            \n          \n          \n            \n            {es} treats date formats starting with the `8` prefix differently depending on\n          \n          \n            \n            the version:\n          \n          \n            \n            \n          \n          \n            \n            *6.8*: Date formats with an `8` prefix are handled as java-time formats. Date\n          \n          \n            \n            formats without an `8` prefix are treated as joda-time formats. We recommend\n          \n          \n            \n            converting these joda-time formats to java-time _before_ upgrading to 7.x.\n          \n          \n            \n            \n          \n          \n            \n            *7.x and later*: For indices created in 6.x, date formats without an `8` prefix\n          \n          \n            \n            are treated as joda-time formats. For indices created in 7.x and later versions,\n          \n          \n            \n            all date formats are treated as java-time formats, regardless of whether it\n          \n          \n            \n            starts with an `8` prefix.", "author": "jrodewig", "createdAt": "2020-03-19T21:08:06Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMyMTA1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395321059", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n          \n          \n            \n            Most custom date formats are compatible. However, several require\n          \n          \n            \n            an update.", "author": "jrodewig", "createdAt": "2020-03-19T21:09:36Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMyMzQ4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395323489", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The difference between year-of-era and week based year\n          \n          \n            \n            For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n          \n          \n            \n            For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n          \n          \n            \n            For example, using the java-time `YYYY-ww` format, `2019-01-01T00:00:00.000Z` is\n          \n          \n            \n            formatted as `2019-01`. However, this format also converts\n          \n          \n            \n            `2018-12-31T00:00:00.000Z` to `2019-01`, despite the date containing the year\n          \n          \n            \n            `2018`. This is because more than four days of that week fall in 2019.", "author": "jrodewig", "createdAt": "2020-03-19T21:14:37Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMyNTA3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395325073", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Custom date formats containing the following joda time literals should be\n          \n          \n            \n            Custom date formats containing the following joda-time literals should be", "author": "jrodewig", "createdAt": "2020-03-19T21:17:57Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMyNjIzNw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395326237", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n          \n          \n            \n            In java time, `y` is used for year of era. `u` can contain non-positive\n          \n          \n            \n            values, while `y` cannot. `y` can also be associated with an era field.", "author": "jrodewig", "createdAt": "2020-03-19T21:20:25Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMyNzIzNA==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395327234", "bodyText": "I think you can remove this line.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The difference between year-of-era and week based year", "author": "jrodewig", "createdAt": "2020-03-19T21:22:30Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMyODk3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395328975", "bodyText": "I don't think we need to include the stackoverflow link, but I'll defer to you if you feel strongly.\nI think a tip on ways to preprocess your input (for example, using an ingest processor) would be great.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n          \n          \n            \n            \n          \n          \n            \n            A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n          \n          \n            \n            Century of era is not supported in java time.\n          \n          \n            \n            There is no replacement. Instead, we recommend you preprocess your input.", "author": "jrodewig", "createdAt": "2020-03-19T21:26:20Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NzYyNw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395597627", "bodyText": "agree, it is not a 100% workaround so better to suggest a preprocessing.\nThe scenario is very uncommon. I guess an example processor or pipeline would unnecessarily extend this guide. I will stick with your suggestion.", "author": "pgomulka", "createdAt": "2020-03-20T12:15:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMyODk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMyOTEyMw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395329123", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `y` year::\n          \n          \n            \n            `y` (Year)::", "author": "jrodewig", "createdAt": "2020-03-19T21:26:41Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMyOTE5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395329195", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `C` century of era::\n          \n          \n            \n            `C` (Century of era)::", "author": "jrodewig", "createdAt": "2020-03-19T21:26:52Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMTE4OA==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395331188", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n          \n          \n            \n            In java time, `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset]. \n          \n          \n            \n            \n          \n          \n            \n            [WARNING]\n          \n          \n            \n            ====\n          \n          \n            \n            Failure to properly convert `x` (Week year) to `Y` could result in data loss.\n          \n          \n            \n            ====", "author": "jrodewig", "createdAt": "2020-03-19T21:31:15Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMTM2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395331365", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `Z` Zone offset/id::\n          \n          \n            \n            `Z` (Zone offset/id)::", "author": "jrodewig", "createdAt": "2020-03-19T21:31:33Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMTQ2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395331465", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Replace with `Y`\n          \n          \n            \n            Replace with `Y`.", "author": "jrodewig", "createdAt": "2020-03-19T21:31:43Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMTQ3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395331479", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `x` week year::\n          \n          \n            \n            `x` (Week year)::", "author": "jrodewig", "createdAt": "2020-03-19T21:31:45Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMTU3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395331572", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `yyyy-MM-dd` should become `uuuu-MM-dd`\n          \n          \n            \n            `yyyy-MM-dd` should become `uuuu-MM-dd`.", "author": "jrodewig", "createdAt": "2020-03-19T21:31:58Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMTY4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395331685", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `YYYY-MM-dd` should become `yyyy-MM-dd`\n          \n          \n            \n            `YYYY-MM-dd` should become `yyyy-MM-dd`.", "author": "jrodewig", "createdAt": "2020-03-19T21:32:12Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMTg3OA==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395331878", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Replace with multiple `X`\n          \n          \n            \n            Replace with multiple `X`'s.", "author": "jrodewig", "createdAt": "2020-03-19T21:32:37Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMjIzMg==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395332232", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n          \n          \n            \n            `Z` has s similar meaning in java time. However, java time expects different\n          \n          \n            \n            numbers of literals to parse different forms.", "author": "jrodewig", "createdAt": "2020-03-19T21:33:25Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMjUyMg==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395332522", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Consider migrating to `X` which give you more control of how your time is parsed.\n          \n          \n            \n            For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n          \n          \n            \n            Consider migrating to `X`, which gives you more control over how time is parsed.\n          \n          \n            \n            For example, the joda-time format `YYYY-MM-dd'T'hh:mm:ssZZ` accepts the following dates:", "author": "jrodewig", "createdAt": "2020-03-19T21:34:10Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMjgxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395332815", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n          \n          \n            \n            In java time, you cannot parse all these dates using a single format\n          \n          \n            \n            Instead, you must specify 3 separate formats:", "author": "jrodewig", "createdAt": "2020-03-19T21:34:46Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMzM3NA==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395333374", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n          \n          \n            \n            The formats must then be delimited using `||`:", "author": "jrodewig", "createdAt": "2020-03-19T21:36:02Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMzQ2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395333469", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The same applies if you expect your pattern to occur without a colon:\n          \n          \n            \n            The same applies if you expect your pattern to occur without a colon (`:`):", "author": "jrodewig", "createdAt": "2020-03-19T21:36:16Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMzY2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395333662", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n          \n          \n            \n            For example, the `YYYY-MM-dd'T'hh:mm:ssZ` format accepts the following date forms:", "author": "jrodewig", "createdAt": "2020-03-19T21:36:40Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMzk2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395333963", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            should be migrated to\n          \n          \n            \n            To accept all these forms in java time, you must use the `||` delimiter:", "author": "jrodewig", "createdAt": "2020-03-19T21:37:21Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNDAyMg==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395334022", "bodyText": "Suggested change", "author": "jrodewig", "createdAt": "2020-03-19T21:37:29Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNDA2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395334069", "bodyText": "Suggested change", "author": "jrodewig", "createdAt": "2020-03-19T21:37:35Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNDMxNw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395334317", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `d` day::\n          \n          \n            \n            `d` (Day)::", "author": "jrodewig", "createdAt": "2020-03-19T21:38:05Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNjQxMg==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395336412", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The same meaning in 7.0 but is less flexible.\n          \n          \n            \n            \n          \n          \n            \n            If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n          \n          \n            \n            You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n          \n          \n            \n            More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n          \n          \n            \n            `yyyy-MM-'000'dd`\n          \n          \n            \n            In java time, `d` is still interpreted as \"day\" but is less flexible.\n          \n          \n            \n            \n          \n          \n            \n            For example, the joda-time date format `YYYY-MM-dd` accepts `2010-01-01` or\n          \n          \n            \n            `2010-01-1`.\n          \n          \n            \n            \n          \n          \n            \n            In java time, you must use the `||` delimiter to provide specify each format:\n          \n          \n            \n            \n          \n          \n            \n            [source,txt]\n          \n          \n            \n            --------------------------------------------------\n          \n          \n            \n            yyyy-MM-dd||yyyy-MM-d\n          \n          \n            \n            --------------------------------------------------\n          \n          \n            \n            \n          \n          \n            \n            In java time, `d` also does not accept more than 2 digits. To accept days with more\n          \n          \n            \n            than two digits, you must include a text literal in your java-time date format.\n          \n          \n            \n            For example, to parse `2010-01-00001`, you must use the following java-time date format: \n          \n          \n            \n            \n          \n          \n            \n            [source,txt]\n          \n          \n            \n            --------------------------------------------------\n          \n          \n            \n            yyyy-MM-'000'dd\n          \n          \n            \n            --------------------------------------------------", "author": "jrodewig", "createdAt": "2020-03-19T21:42:56Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNjQ3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395336471", "bodyText": "Suggested change", "author": "jrodewig", "createdAt": "2020-03-19T21:43:04Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNjU5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395336599", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `e` name of day::\n          \n          \n            \n            `e` (Name of day)::", "author": "jrodewig", "createdAt": "2020-03-19T21:43:22Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzOTYxNg==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395339616", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n          \n          \n            \n            \n          \n          \n            \n            If you used `EEE YYYY-MM` for a format and expected days in form:\n          \n          \n            \n            `Wed 2020-01` or `Wednesday 2020-01`\n          \n          \n            \n            then you have to use two combined patterns in 7.0\n          \n          \n            \n            `cccc yyyy-MM||ccc yyyy-MM`\n          \n          \n            \n            \n          \n          \n            \n            E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n          \n          \n            \n            In java time, `e` is still interpreted as \"name of day\" but does not parse\n          \n          \n            \n            short- or full-text forms.\n          \n          \n            \n            \n          \n          \n            \n            For example, the joda-time date format `EEE YYYY-MM` accepts both\n          \n          \n            \n            `Wed 2020-01` and `Wednesday 2020-01`.\n          \n          \n            \n            \n          \n          \n            \n            To accept both of these dates in java time, you must specify each format using\n          \n          \n            \n            the `||` delimiter: \n          \n          \n            \n            \n          \n          \n            \n            [source,txt]\n          \n          \n            \n            --------------------------------------------------\n          \n          \n            \n            cccc yyyy-MM||ccc yyyy-MM\n          \n          \n            \n            --------------------------------------------------\n          \n          \n            \n            \n          \n          \n            \n            The joda-time literal `E` is interpreted as \"day of week.\"\n          \n          \n            \n            The java-time literal `c` is interpreted as \"localized day of week.\"\n          \n          \n            \n            `E` does not accept full-text day formats, such as `Wednesday`.", "author": "jrodewig", "createdAt": "2020-03-19T21:50:28Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzOTgzNg==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395339836", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Text forms EEEE and similar::\n          \n          \n            \n            `EEEE` and similar text forms::", "author": "jrodewig", "createdAt": "2020-03-19T21:50:58Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+--\n+\n+Text forms EEEE and similar::", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MDQ5NA==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395340494", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n          \n          \n            \n            Support for full-text forms depends on the locale data provided with your Java\n          \n          \n            \n            Development Kit (JDK) and other implementation details. We recommend you\n          \n          \n            \n            test formats containing these patterns carefully before upgrading.", "author": "jrodewig", "createdAt": "2020-03-19T21:52:40Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+--\n+\n+Text forms EEEE and similar::\n++\n+--\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MDc2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395340769", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In 7.0 it will print 'Z' for Zulu given UTC timezone.\n          \n          \n            \n            In java time, `z` outputs 'Z' for Zulu when given a UTC timezone.", "author": "jrodewig", "createdAt": "2020-03-19T21:53:17Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+--\n+\n+Text forms EEEE and similar::\n++\n+--\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+--\n+\n+`z` time zone text::\n++\n+--\n+In 7.0 it will print 'Z' for Zulu given UTC timezone.", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MDgzNw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395340837", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `z` time zone text::\n          \n          \n            \n            `z` (Time zone text)::", "author": "jrodewig", "createdAt": "2020-03-19T21:53:26Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+--\n+\n+Text forms EEEE and similar::\n++\n+--\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+--\n+\n+`z` time zone text::", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MTAwOA==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395341008", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            [[java-time-migration-incompatible-date-formats]]", "author": "jrodewig", "createdAt": "2020-03-19T21:53:54Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MTA2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395341062", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ==== Incompatible formats\n          \n          \n            \n            ==== Incompatible date formats", "author": "jrodewig", "createdAt": "2020-03-19T21:54:02Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MTI2MA==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395341260", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ==== Impacted features\n          \n          \n            \n            [[java-time-migration-impacted-features]]\n          \n          \n            \n            ==== Impacted features", "author": "jrodewig", "createdAt": "2020-03-19T21:54:36Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MTQxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395341415", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            [[java-time-migration-test]]", "author": "jrodewig", "createdAt": "2020-03-19T21:55:00Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+--\n+\n+Text forms EEEE and similar::\n++\n+--\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+--\n+\n+`z` time zone text::\n++\n+--\n+In 7.0 it will print 'Z' for Zulu given UTC timezone.\n+--\n+\n+", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MzA1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395343056", "bodyText": "If not sure we needed the middle sentences here. I removed them, but feel free to leave them in if you feel strongly.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n          \n          \n            \n            If you expect your timezone to only be in one form - for instance `+01:00`  (XXX in java, ZZ in joda) -\n          \n          \n            \n            then there is no need to create a new java pattern with so many alternatives.\n          \n          \n            \n            \n          \n          \n            \n            Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n          \n          \n            \n            \n          \n          \n            \n            We strongly recommend you test any date format changes using real data before\n          \n          \n            \n            deploying in production.\n          \n          \n            \n            \n          \n          \n            \n            For help with date debugging, consider using\n          \n          \n            \n            https://esddd.herokuapp.com/[https://esddd.herokuapp.com/.]", "author": "jrodewig", "createdAt": "2020-03-19T21:58:49Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+--\n+\n+Text forms EEEE and similar::\n++\n+--\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+--\n+\n+`z` time zone text::\n++\n+--\n+In 7.0 it will print 'Z' for Zulu given UTC timezone.\n+--\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expect your timezone to only be in one form - for instance `+01:00`  (XXX in java, ZZ in joda) -\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MzIxNw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395343217", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ==== Migrating affected mappings\n          \n          \n            \n            [[java-time-migrate-update-mappings]]\n          \n          \n            \n            ==== Update index mappings", "author": "jrodewig", "createdAt": "2020-03-19T21:59:13Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+--\n+\n+Text forms EEEE and similar::\n++\n+--\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+--\n+\n+`z` time zone text::\n++\n+--\n+In 7.0 it will print 'Z' for Zulu given UTC timezone.\n+--\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expect your timezone to only be in one form - for instance `+01:00`  (XXX in java, ZZ in joda) -\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n+\n+==== Migrating affected mappings", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NTE0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395345149", "bodyText": "You cover the tip regarding external tools later. No need to mention it here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping\n          \n          \n            \n            and reindex your data to it.\n          \n          \n            \n            You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n          \n          \n            \n            If you specified a custom date format there, then you need to update it too.\n          \n          \n            \n            \n          \n          \n            \n            To update joda-time date formats in index mappings, you must create a new index\n          \n          \n            \n            with an updated mapping and reindex your data to it.", "author": "jrodewig", "createdAt": "2020-03-19T22:03:56Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+--\n+\n+Text forms EEEE and similar::\n++\n+--\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+--\n+\n+`z` time zone text::\n++\n+--\n+In 7.0 it will print 'Z' for Zulu given UTC timezone.\n+--\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expect your timezone to only be in one form - for instance `+01:00`  (XXX in java, ZZ in joda) -\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n+\n+==== Migrating affected mappings\n+Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping\n+and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYwMzc3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395603777", "bodyText": "I applied the suggestion on the sentence about the need to create a new mapping.\nI think it is worth mentioning pipelines and templates here. This is about the the ones within ES itself (not external)", "author": "pgomulka", "createdAt": "2020-03-20T12:28:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NTE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NTk2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395345963", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Let's assume that you have an index with a date field and custom format\n          \n          \n            \n            The following `my_index_1` index contains a mapping for the `datetime` field, a\n          \n          \n            \n            `date` field with a custom joda-time date format.", "author": "jrodewig", "createdAt": "2020-03-19T22:06:02Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+--\n+\n+Text forms EEEE and similar::\n++\n+--\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+--\n+\n+`z` time zone text::\n++\n+--\n+In 7.0 it will print 'Z' for Zulu given UTC timezone.\n+--\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expect your timezone to only be in one form - for instance `+01:00`  (XXX in java, ZZ in joda) -\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n+\n+==== Migrating affected mappings\n+Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping\n+and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.\n+\n+===== Example migration procedure\n+Let's assume that you have an index with a date field and custom format", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0Njg3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395346876", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Create my_index_2 with mappings changed with the format set to `8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis`\n          \n          \n            \n            To change the date format for the `datetime` field, create a separate index\n          \n          \n            \n            containing an updated mapping and date format.\n          \n          \n            \n            \n          \n          \n            \n            For example, the following `my_index_2` index changes the `datetime` field's \n          \n          \n            \n            date format to `8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis`. The `8` prefix \n          \n          \n            \n            indicates this date format uses java time.", "author": "jrodewig", "createdAt": "2020-03-19T22:08:12Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+--\n+\n+Text forms EEEE and similar::\n++\n+--\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+--\n+\n+`z` time zone text::\n++\n+--\n+In 7.0 it will print 'Z' for Zulu given UTC timezone.\n+--\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expect your timezone to only be in one form - for instance `+01:00`  (XXX in java, ZZ in joda) -\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n+\n+==== Migrating affected mappings\n+Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping\n+and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.\n+\n+===== Example migration procedure\n+Let's assume that you have an index with a date field and custom format\n+////\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_1\n+{\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+}\n+--------------------------------------------------\n+////\n+\n+[source,console]\n+--------------------------------------------------\n+GET my_index_1/_mapping\n+--------------------------------------------------\n+// TEST[continued]\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"my_index_1\" : {\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+\n+* Create my_index_2 with mappings changed with the format set to `8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis`", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NzQzMA==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395347430", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Reindex the deprecated format index to new_index_1\n          \n          \n            \n            Next, reindex the data from `my_index_1` to `my_index_2`.", "author": "jrodewig", "createdAt": "2020-03-19T22:09:36Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+--\n+\n+Text forms EEEE and similar::\n++\n+--\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+--\n+\n+`z` time zone text::\n++\n+--\n+In 7.0 it will print 'Z' for Zulu given UTC timezone.\n+--\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expect your timezone to only be in one form - for instance `+01:00`  (XXX in java, ZZ in joda) -\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n+\n+==== Migrating affected mappings\n+Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping\n+and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.\n+\n+===== Example migration procedure\n+Let's assume that you have an index with a date field and custom format\n+////\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_1\n+{\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+}\n+--------------------------------------------------\n+////\n+\n+[source,console]\n+--------------------------------------------------\n+GET my_index_1/_mapping\n+--------------------------------------------------\n+// TEST[continued]\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"my_index_1\" : {\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+\n+* Create my_index_2 with mappings changed with the format set to `8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis`\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_2\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"datetime\": {\n+        \"type\": \"date\",\n+        \"format\": \"8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+* Reindex the deprecated format index to new_index_1", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NzU5MA==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395347590", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * If you were using aliases, update them to a new index\n          \n          \n            \n            If you use index aliases, update them to point to the new index.", "author": "jrodewig", "createdAt": "2020-03-19T22:10:01Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+--\n+\n+Text forms EEEE and similar::\n++\n+--\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+--\n+\n+`z` time zone text::\n++\n+--\n+In 7.0 it will print 'Z' for Zulu given UTC timezone.\n+--\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expect your timezone to only be in one form - for instance `+01:00`  (XXX in java, ZZ in joda) -\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n+\n+==== Migrating affected mappings\n+Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping\n+and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.\n+\n+===== Example migration procedure\n+Let's assume that you have an index with a date field and custom format\n+////\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_1\n+{\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+}\n+--------------------------------------------------\n+////\n+\n+[source,console]\n+--------------------------------------------------\n+GET my_index_1/_mapping\n+--------------------------------------------------\n+// TEST[continued]\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"my_index_1\" : {\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+\n+* Create my_index_2 with mappings changed with the format set to `8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis`\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_2\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"datetime\": {\n+        \"type\": \"date\",\n+        \"format\": \"8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+* Reindex the deprecated format index to new_index_1\n+\n+[source,console]\n+--------------------------------------------------\n+POST _reindex\n+{\n+  \"source\": {\n+    \"index\": \"my_index_1\"\n+  },\n+  \"dest\": {\n+    \"index\": \"my_index_2\"\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+* If you were using aliases, update them to a new index", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0ODAzNw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395348037", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ===== Update before upgrading to ES7.\n          \n          \n            \n            [[java-time-migration-update-ingest-pipelines]]\n          \n          \n            \n            ===== Update ingest pipelines", "author": "jrodewig", "createdAt": "2020-03-19T22:11:11Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+--\n+\n+Text forms EEEE and similar::\n++\n+--\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+--\n+\n+`z` time zone text::\n++\n+--\n+In 7.0 it will print 'Z' for Zulu given UTC timezone.\n+--\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expect your timezone to only be in one form - for instance `+01:00`  (XXX in java, ZZ in joda) -\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n+\n+==== Migrating affected mappings\n+Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping\n+and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.\n+\n+===== Example migration procedure\n+Let's assume that you have an index with a date field and custom format\n+////\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_1\n+{\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+}\n+--------------------------------------------------\n+////\n+\n+[source,console]\n+--------------------------------------------------\n+GET my_index_1/_mapping\n+--------------------------------------------------\n+// TEST[continued]\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"my_index_1\" : {\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+\n+* Create my_index_2 with mappings changed with the format set to `8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis`\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_2\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"datetime\": {\n+        \"type\": \"date\",\n+        \"format\": \"8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+* Reindex the deprecated format index to new_index_1\n+\n+[source,console]\n+--------------------------------------------------\n+POST _reindex\n+{\n+  \"source\": {\n+    \"index\": \"my_index_1\"\n+  },\n+  \"dest\": {\n+    \"index\": \"my_index_2\"\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+* If you were using aliases, update them to a new index\n+\n+[source,console]\n+--------------------------------------------------\n+POST /_aliases\n+{\n+    \"actions\" : [\n+        { \"remove\" : { \"index\" : \"my_index_1\", \"alias\" : \"my_index\" } },\n+        { \"add\" : { \"index\" : \"my_index_2\", \"alias\" : \"my_index\" } }\n+    ]\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+===== Update before upgrading to ES7.", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0ODQ4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395348487", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If your pipelines were using a joda style patterns, they also have to be updated. There is no need to create a new pipeline.\n          \n          \n            \n            Just update the already existing one.\n          \n          \n            \n            If your ingest pipelines contain joda-time date formats, you can update them\n          \n          \n            \n            using the <<put-pipeline-api,put ingest pipeline>> API.", "author": "jrodewig", "createdAt": "2020-03-19T22:12:25Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+--\n+\n+Text forms EEEE and similar::\n++\n+--\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+--\n+\n+`z` time zone text::\n++\n+--\n+In 7.0 it will print 'Z' for Zulu given UTC timezone.\n+--\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expect your timezone to only be in one form - for instance `+01:00`  (XXX in java, ZZ in joda) -\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n+\n+==== Migrating affected mappings\n+Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping\n+and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.\n+\n+===== Example migration procedure\n+Let's assume that you have an index with a date field and custom format\n+////\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_1\n+{\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+}\n+--------------------------------------------------\n+////\n+\n+[source,console]\n+--------------------------------------------------\n+GET my_index_1/_mapping\n+--------------------------------------------------\n+// TEST[continued]\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"my_index_1\" : {\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+\n+* Create my_index_2 with mappings changed with the format set to `8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis`\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_2\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"datetime\": {\n+        \"type\": \"date\",\n+        \"format\": \"8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+* Reindex the deprecated format index to new_index_1\n+\n+[source,console]\n+--------------------------------------------------\n+POST _reindex\n+{\n+  \"source\": {\n+    \"index\": \"my_index_1\"\n+  },\n+  \"dest\": {\n+    \"index\": \"my_index_2\"\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+* If you were using aliases, update them to a new index\n+\n+[source,console]\n+--------------------------------------------------\n+POST /_aliases\n+{\n+    \"actions\" : [\n+        { \"remove\" : { \"index\" : \"my_index_1\", \"alias\" : \"my_index\" } },\n+        { \"add\" : { \"index\" : \"my_index_2\", \"alias\" : \"my_index\" } }\n+    ]\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+===== Update before upgrading to ES7.\n+If your pipelines were using a joda style patterns, they also have to be updated. There is no need to create a new pipeline.\n+Just update the already existing one.", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0OTQ0MA==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395349440", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * upgrade template\n          \n          \n            \n            If your template was using joda date pattern it also should be updated before upgrading to ES7.\n          \n          \n            \n            [[java-time-migration-update-index-templates]]\n          \n          \n            \n            ===== Update index templates\n          \n          \n            \n            \n          \n          \n            \n            If your index templates contain joda-time date formats, you can update them\n          \n          \n            \n            using the <<indices-templates,put index template>> API.", "author": "jrodewig", "createdAt": "2020-03-19T22:14:37Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+--\n+\n+Text forms EEEE and similar::\n++\n+--\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+--\n+\n+`z` time zone text::\n++\n+--\n+In 7.0 it will print 'Z' for Zulu given UTC timezone.\n+--\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expect your timezone to only be in one form - for instance `+01:00`  (XXX in java, ZZ in joda) -\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n+\n+==== Migrating affected mappings\n+Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping\n+and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.\n+\n+===== Example migration procedure\n+Let's assume that you have an index with a date field and custom format\n+////\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_1\n+{\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+}\n+--------------------------------------------------\n+////\n+\n+[source,console]\n+--------------------------------------------------\n+GET my_index_1/_mapping\n+--------------------------------------------------\n+// TEST[continued]\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"my_index_1\" : {\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+\n+* Create my_index_2 with mappings changed with the format set to `8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis`\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_2\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"datetime\": {\n+        \"type\": \"date\",\n+        \"format\": \"8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+* Reindex the deprecated format index to new_index_1\n+\n+[source,console]\n+--------------------------------------------------\n+POST _reindex\n+{\n+  \"source\": {\n+    \"index\": \"my_index_1\"\n+  },\n+  \"dest\": {\n+    \"index\": \"my_index_2\"\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+* If you were using aliases, update them to a new index\n+\n+[source,console]\n+--------------------------------------------------\n+POST /_aliases\n+{\n+    \"actions\" : [\n+        { \"remove\" : { \"index\" : \"my_index_1\", \"alias\" : \"my_index\" } },\n+        { \"add\" : { \"index\" : \"my_index_2\", \"alias\" : \"my_index\" } }\n+    ]\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+===== Update before upgrading to ES7.\n+If your pipelines were using a joda style patterns, they also have to be updated. There is no need to create a new pipeline.\n+Just update the already existing one.\n+\n+[source,console]\n+--------------------------------------------------\n+PUT _ingest/pipeline/mypipeline\n+{\n+  \"description\": \"Pipeline for routing data to specific index\",\n+  \"processors\": [\n+    {\n+      \"date\": {\n+        \"field\": \"createdTime\",\n+        \"formats\": [\n+         \"8uuuu-w\"\n+        ]\n+      },\n+      \"date_index_name\": {\n+        \"field\": \"@timestamp\",\n+        \"date_rounding\": \"d\",\n+        \"index_name_prefix\": \"x-\",\n+        \"index_name_format\": \"8uuuu-w\"\n+      }\n+    }\n+  ]\n+}\n+--------------------------------------------------\n+\n+\n+* upgrade template\n+If your template was using joda date pattern it also should be updated before upgrading to ES7.", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0OTY4MA==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395349680", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            [source,console]\n          \n          \n            \n            --------------------------------------------------\n          \n          \n            \n            DELETE /_template/template_1\n          \n          \n            \n            --------------------------------------------------\n          \n          \n            \n            // TEST[continued]\n          \n          \n            \n            * Upgrade to 7.x\n          \n          \n            \n            ////\n          \n          \n            \n            [source,console]\n          \n          \n            \n            --------------------------------------------------\n          \n          \n            \n            DELETE /_template/template_1\n          \n          \n            \n            --------------------------------------------------\n          \n          \n            \n            // TEST[continued]\n          \n          \n            \n            ////", "author": "jrodewig", "createdAt": "2020-03-19T22:15:15Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+--\n+\n+Text forms EEEE and similar::\n++\n+--\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+--\n+\n+`z` time zone text::\n++\n+--\n+In 7.0 it will print 'Z' for Zulu given UTC timezone.\n+--\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expect your timezone to only be in one form - for instance `+01:00`  (XXX in java, ZZ in joda) -\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n+\n+==== Migrating affected mappings\n+Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping\n+and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.\n+\n+===== Example migration procedure\n+Let's assume that you have an index with a date field and custom format\n+////\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_1\n+{\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+}\n+--------------------------------------------------\n+////\n+\n+[source,console]\n+--------------------------------------------------\n+GET my_index_1/_mapping\n+--------------------------------------------------\n+// TEST[continued]\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"my_index_1\" : {\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+\n+* Create my_index_2 with mappings changed with the format set to `8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis`\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_2\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"datetime\": {\n+        \"type\": \"date\",\n+        \"format\": \"8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+* Reindex the deprecated format index to new_index_1\n+\n+[source,console]\n+--------------------------------------------------\n+POST _reindex\n+{\n+  \"source\": {\n+    \"index\": \"my_index_1\"\n+  },\n+  \"dest\": {\n+    \"index\": \"my_index_2\"\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+* If you were using aliases, update them to a new index\n+\n+[source,console]\n+--------------------------------------------------\n+POST /_aliases\n+{\n+    \"actions\" : [\n+        { \"remove\" : { \"index\" : \"my_index_1\", \"alias\" : \"my_index\" } },\n+        { \"add\" : { \"index\" : \"my_index_2\", \"alias\" : \"my_index\" } }\n+    ]\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+===== Update before upgrading to ES7.\n+If your pipelines were using a joda style patterns, they also have to be updated. There is no need to create a new pipeline.\n+Just update the already existing one.\n+\n+[source,console]\n+--------------------------------------------------\n+PUT _ingest/pipeline/mypipeline\n+{\n+  \"description\": \"Pipeline for routing data to specific index\",\n+  \"processors\": [\n+    {\n+      \"date\": {\n+        \"field\": \"createdTime\",\n+        \"formats\": [\n+         \"8uuuu-w\"\n+        ]\n+      },\n+      \"date_index_name\": {\n+        \"field\": \"@timestamp\",\n+        \"date_rounding\": \"d\",\n+        \"index_name_prefix\": \"x-\",\n+        \"index_name_format\": \"8uuuu-w\"\n+      }\n+    }\n+  ]\n+}\n+--------------------------------------------------\n+\n+\n+* upgrade template\n+If your template was using joda date pattern it also should be updated before upgrading to ES7.\n+\n+[source,console]\n+--------------------------------------------------\n+PUT _template/template_1\n+{\n+  \"index_patterns\": [\n+    \"te*\",\n+    \"bar*\"\n+  ],\n+  \"settings\": {\n+    \"number_of_shards\": 1\n+  },\n+  \"mappings\": {\n+    \"_source\": {\n+      \"enabled\": false\n+    },\n+    \"properties\": {\n+      \"host_name\": {\n+        \"type\": \"keyword\"\n+      },\n+      \"created_at\": {\n+        \"type\": \"date\",\n+        \"format\": \"8EEE MMM dd HH:mm:ss Z yyyy\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+\n+[source,console]\n+--------------------------------------------------\n+DELETE /_template/template_1\n+--------------------------------------------------\n+// TEST[continued]\n+* Upgrade to 7.x", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1MTI3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395351271", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ===== External templates\n          \n          \n            \n            Revisit other templates from elastic stack where you used a custom date pattern.\n          \n          \n            \n            [[java-time-migration-update-external-tools-templates]]\n          \n          \n            \n            ===== Update external tools and templates\n          \n          \n            \n            Ensure you also update any date formats in templates or tools outside of {es}.\n          \n          \n            \n            This can include tools such as {beats-ref}/getting-started.html[{beats}] or\n          \n          \n            \n            {logstash-ref}/index.html[Logstash].", "author": "jrodewig", "createdAt": "2020-03-19T22:19:18Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+--\n+\n+Text forms EEEE and similar::\n++\n+--\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+--\n+\n+`z` time zone text::\n++\n+--\n+In 7.0 it will print 'Z' for Zulu given UTC timezone.\n+--\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expect your timezone to only be in one form - for instance `+01:00`  (XXX in java, ZZ in joda) -\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n+\n+==== Migrating affected mappings\n+Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping\n+and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.\n+\n+===== Example migration procedure\n+Let's assume that you have an index with a date field and custom format\n+////\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_1\n+{\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+}\n+--------------------------------------------------\n+////\n+\n+[source,console]\n+--------------------------------------------------\n+GET my_index_1/_mapping\n+--------------------------------------------------\n+// TEST[continued]\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"my_index_1\" : {\n+    \"mappings\" : {\n+      \"properties\" : {\n+         \"datetime\": {\n+           \"type\": \"date\",\n+           \"format\": \"yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis\"\n+         }\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+\n+* Create my_index_2 with mappings changed with the format set to `8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis`\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index_2\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"datetime\": {\n+        \"type\": \"date\",\n+        \"format\": \"8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+* Reindex the deprecated format index to new_index_1\n+\n+[source,console]\n+--------------------------------------------------\n+POST _reindex\n+{\n+  \"source\": {\n+    \"index\": \"my_index_1\"\n+  },\n+  \"dest\": {\n+    \"index\": \"my_index_2\"\n+  }\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+* If you were using aliases, update them to a new index\n+\n+[source,console]\n+--------------------------------------------------\n+POST /_aliases\n+{\n+    \"actions\" : [\n+        { \"remove\" : { \"index\" : \"my_index_1\", \"alias\" : \"my_index\" } },\n+        { \"add\" : { \"index\" : \"my_index_2\", \"alias\" : \"my_index\" } }\n+    ]\n+}\n+--------------------------------------------------\n+// TEST[continued]\n+\n+===== Update before upgrading to ES7.\n+If your pipelines were using a joda style patterns, they also have to be updated. There is no need to create a new pipeline.\n+Just update the already existing one.\n+\n+[source,console]\n+--------------------------------------------------\n+PUT _ingest/pipeline/mypipeline\n+{\n+  \"description\": \"Pipeline for routing data to specific index\",\n+  \"processors\": [\n+    {\n+      \"date\": {\n+        \"field\": \"createdTime\",\n+        \"formats\": [\n+         \"8uuuu-w\"\n+        ]\n+      },\n+      \"date_index_name\": {\n+        \"field\": \"@timestamp\",\n+        \"date_rounding\": \"d\",\n+        \"index_name_prefix\": \"x-\",\n+        \"index_name_format\": \"8uuuu-w\"\n+      }\n+    }\n+  ]\n+}\n+--------------------------------------------------\n+\n+\n+* upgrade template\n+If your template was using joda date pattern it also should be updated before upgrading to ES7.\n+\n+[source,console]\n+--------------------------------------------------\n+PUT _template/template_1\n+{\n+  \"index_patterns\": [\n+    \"te*\",\n+    \"bar*\"\n+  ],\n+  \"settings\": {\n+    \"number_of_shards\": 1\n+  },\n+  \"mappings\": {\n+    \"_source\": {\n+      \"enabled\": false\n+    },\n+    \"properties\": {\n+      \"host_name\": {\n+        \"type\": \"keyword\"\n+      },\n+      \"created_at\": {\n+        \"type\": \"date\",\n+        \"format\": \"8EEE MMM dd HH:mm:ss Z yyyy\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+\n+[source,console]\n+--------------------------------------------------\n+DELETE /_template/template_1\n+--------------------------------------------------\n+// TEST[continued]\n+* Upgrade to 7.x\n+\n+===== External templates\n+Revisit other templates from elastic stack where you used a custom date pattern.", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM3Mjc4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51986#discussion_r395372782", "bodyText": "I don't think this heading is needed.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ===== Example migration procedure", "author": "jrodewig", "createdAt": "2020-03-19T23:21:46Z", "path": "docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc", "diffHunk": "@@ -0,0 +1,350 @@\n+[[migrate_to_java_time]]\n+=== Java time migration guide\n+\n+With 7.0, {es} switch to java time from joda time for date-related parsing,\n+formatting, and calculations. This guide is designed to help you determine\n+if your cluster is impacted and, if so, prepare for the upgrade.\n+\n+Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0\n+All new indices created in 7.x are expected to be using java-time patterns.\n+\n+We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x\n+\n+- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.\n+- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.\n+- Patterns with or without `8` on indices *created in 7.x*  are considered java.style\n+\n+==== Impacted features\n+The switch to java time only impacts custom <<date,`date`>> and\n+<<date_nanos,`date_nanos`>> formats.\n+\n+These formats are commonly used in:\n+\n+* <<mapping,Index mappings>>\n+* <<indices-templates,Index templates>>\n+* <<pipeline,Ingest pipelines>>\n+\n+If you don't use custom date formats, you can skip the rest of this guide.\n+Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.\n+\n+To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>\n+or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]\n+\n+\n+==== Incompatible formats\n+Custom date formats containing the following joda time literals should be\n+changed before upgrading.\n+\n+`Y` (Year of era)::\n++\n+--\n+Replace with `y`.\n+\n+*Example:*\n+`YYYY-MM-dd` should become `yyyy-MM-dd`\n+\n+In java time, `Y` is used for\n+https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].\n+Using `Y` in place of `y` could result in off-by-one errors in year calculation.\n+\n+\n+The difference between year-of-era and week based year\n+For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`\n+For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019\n+--\n+\n+`y` year::\n++\n+--\n+Replace with `u`.\n+\n+*Example:*\n+`yyyy-MM-dd` should become `uuuu-MM-dd`\n+\n+The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.\n+--\n+\n+\n+`C` century of era::\n++\n+--\n+No longer supported in 7.0. There is no replacement, so you need to preprocess your input.\n+\n+A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern\n+--\n+\n+`x` week year::\n++\n+--\n+Replace with `Y`\n+\n+This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time\n+--\n+\n+`Z` Zone offset/id::\n++\n+--\n+Replace with multiple `X`\n+\n+`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.\n+\n+Consider migrating to `X` which give you more control of how your time is parsed.\n+For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+01:02\n+2010-01-01T01:02:03+01:02:03\n+```\n+\n+You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns\n+\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+both parsed with yyyy-MM-dd'T'hh:mm:ssX\n+\n+2010-01-01T01:02:03+01:02\n+yyyy-MM-dd'T'hh:mm:ssXXX\n+\n+2010-01-01T01:02:03+01:02:03\n+yyyy-MM-dd'T'hh:mm:ssXXXXX\n+```\n+\n+\n+If you expect all these combination to occur in your data you need to combine these patterns in 7.0\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX\n+--------------------------------------------------\n+\n+\n+The same applies if you expect your pattern to occur without a colon:\n+Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:\n+```\n+2010-01-01T01:02:03Z\n+2010-01-01T01:02:03+01\n+2010-01-01T01:02:03+0102\n+2010-01-01T01:02:03+010203\n+```\n+should be migrated to\n+[source,txt]\n+--------------------------------------------------\n+yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX\n+--------------------------------------------------\n+--\n+\n+\n+\n+`d` day::\n++\n+--\n+The same meaning in 7.0 but is less flexible.\n+\n+If your pattern was `YYYY-MM-dd` in 6.8 and you expect dates in form `2010-01-01` or `2010-01-1`\n+You need to provide an alternative pattern for all of these `yyyy-MM-dd||yyyy-MM-d`.\n+More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`\n+`yyyy-MM-'000'dd`\n+--\n+\n+\n+`e` name of day::\n++\n+--\n+The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.\n+\n+If you used `EEE YYYY-MM` for a format and expected days in form:\n+`Wed 2020-01` or `Wednesday 2020-01`\n+then you have to use two combined patterns in 7.0\n+`cccc yyyy-MM||ccc yyyy-MM`\n+\n+E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday\n+--\n+\n+Text forms EEEE and similar::\n++\n+--\n+Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.\n+--\n+\n+`z` time zone text::\n++\n+--\n+In 7.0 it will print 'Z' for Zulu given UTC timezone.\n+--\n+\n+\n+===== Test with your data\n+All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.\n+If you expect your timezone to only be in one form - for instance `+01:00`  (XXX in java, ZZ in joda) -\n+then there is no need to create a new java pattern with so many alternatives.\n+\n+Consider using this date debugging site for assistance https://esddd.herokuapp.com/\n+\n+==== Migrating affected mappings\n+Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping\n+and reindex your data to it.\n+You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.\n+If you specified a custom date format there, then you need to update it too.\n+\n+===== Example migration procedure", "originalCommit": "b51fea425b6ccf972df41a06b6b9151b2efb56a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f38a28d772e62beba1effbc2896295d957b7e014", "url": "https://github.com/elastic/elasticsearch/commit/f38a28d772e62beba1effbc2896295d957b7e014", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:07:13Z", "type": "commit"}, {"oid": "e552aa6d12387ed5bde5498879875c5e72ecaedc", "url": "https://github.com/elastic/elasticsearch/commit/e552aa6d12387ed5bde5498879875c5e72ecaedc", "message": "Update docs/reference/migration/migrate_7_0/migrate_to_java_time.asciidoc\n\nCo-Authored-By: James Rodewig <james.rodewig@elastic.co>", "committedDate": "2020-03-20T10:09:00Z", "type": "commit"}]}