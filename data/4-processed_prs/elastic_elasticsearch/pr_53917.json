{"pr_number": 53917, "pr_title": "Merge CacheDirectory into SearchableSnapshotDirectory", "pr_createdAt": "2020-03-21T13:46:58Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53917", "timeline": [{"oid": "87658bb1fb817f40f767b2b9716b20b33dff1958", "url": "https://github.com/elastic/elasticsearch/commit/87658bb1fb817f40f767b2b9716b20b33dff1958", "message": "Fold CacheDirectory within SearchableSnapshotDirectory", "committedDate": "2020-03-21T13:44:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NDEzOA==", "url": "https://github.com/elastic/elasticsearch/pull/53917#discussion_r395994138", "bodyText": "This class has been merged down with SearchableSnapshotDirectory (it was useful to me for the 2 previous PRs)", "author": "tlrx", "createdAt": "2020-03-21T13:47:51Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/BaseSearchableSnapshotDirectory.java", "diffHunk": "@@ -1,109 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-package org.elasticsearch.index.store;\n-\n-import org.apache.lucene.store.BaseDirectory;\n-import org.apache.lucene.store.IOContext;\n-import org.apache.lucene.store.IndexOutput;\n-import org.apache.lucene.store.SingleInstanceLockFactory;\n-import org.elasticsearch.common.blobstore.BlobContainer;\n-import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n-import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot.FileInfo;\n-\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-public abstract class BaseSearchableSnapshotDirectory extends BaseDirectory {", "originalCommit": "87658bb1fb817f40f767b2b9716b20b33dff1958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NDIxMg==", "url": "https://github.com/elastic/elasticsearch/pull/53917#discussion_r395994212", "bodyText": "Comes from the now removed CacheDirectory and made public as cache classes are in a different package", "author": "tlrx", "createdAt": "2020-03-21T13:49:01Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -42,17 +60,175 @@\n  * shard files and what it stored in the snapshot the {@link BlobStoreIndexShardSnapshot} is used to map a physical file name as expected by\n  * Lucene with the one (or the ones) corresponding blob(s) in the snapshot.\n  */\n-public class SearchableSnapshotDirectory extends BaseSearchableSnapshotDirectory {\n+public class SearchableSnapshotDirectory extends BaseDirectory {\n \n-    SearchableSnapshotDirectory(final BlobStoreIndexShardSnapshot snapshot, final BlobContainer blobContainer) {\n-        super(blobContainer, snapshot);\n+    private final BlobStoreIndexShardSnapshot snapshot;\n+    private final BlobContainer blobContainer;\n+    private final SnapshotId snapshotId;\n+    private final IndexId indexId;\n+    private final ShardId shardId;\n+    private final LongSupplier statsCurrentTimeNanosSupplier;\n+    private final Map<String, IndexInputStats> stats;\n+    private final CacheService cacheService;\n+    private final boolean useCache;\n+    private final Path cacheDir;\n+    private final AtomicBoolean closed;\n+\n+    public SearchableSnapshotDirectory(\n+        BlobContainer blobContainer,\n+        BlobStoreIndexShardSnapshot snapshot,\n+        SnapshotId snapshotId,\n+        IndexId indexId,\n+        ShardId shardId,\n+        Settings indexSettings,\n+        LongSupplier currentTimeNanosSupplier,\n+        CacheService cacheService,\n+        Path cacheDir\n+    ) {\n+        super(new SingleInstanceLockFactory());\n+        this.snapshot = Objects.requireNonNull(snapshot);\n+        this.blobContainer = Objects.requireNonNull(blobContainer);\n+        this.snapshotId = Objects.requireNonNull(snapshotId);\n+        this.indexId = Objects.requireNonNull(indexId);\n+        this.shardId = Objects.requireNonNull(shardId);\n+        this.stats = ConcurrentCollections.newConcurrentMapWithAggressiveConcurrency();\n+        this.statsCurrentTimeNanosSupplier = Objects.requireNonNull(currentTimeNanosSupplier);\n+        this.cacheService = Objects.requireNonNull(cacheService);\n+        this.cacheDir = Objects.requireNonNull(cacheDir);\n+        this.closed = new AtomicBoolean(false);\n+        this.useCache = SNAPSHOT_CACHE_ENABLED_SETTING.get(indexSettings);\n+    }\n+\n+    public BlobContainer blobContainer() {\n+        return blobContainer;\n+    }\n+\n+    public SnapshotId getSnapshotId() {\n+        return snapshotId;\n+    }\n+\n+    public IndexId getIndexId() {\n+        return indexId;\n+    }\n+\n+    public ShardId getShardId() {\n+        return shardId;\n+    }\n+\n+    public Map<String, IndexInputStats> getStats() {\n+        return Collections.unmodifiableMap(stats);\n+    }\n+\n+    @Nullable\n+    public IndexInputStats getStats(String fileName) {", "originalCommit": "87658bb1fb817f40f767b2b9716b20b33dff1958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NDI1NA==", "url": "https://github.com/elastic/elasticsearch/pull/53917#discussion_r395994254", "bodyText": "I'd like to rename this one to DirectBufferedIndexInput and to clean it up a bit in a follow up PR", "author": "tlrx", "createdAt": "2020-03-21T13:49:52Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -42,17 +60,175 @@\n  * shard files and what it stored in the snapshot the {@link BlobStoreIndexShardSnapshot} is used to map a physical file name as expected by\n  * Lucene with the one (or the ones) corresponding blob(s) in the snapshot.\n  */\n-public class SearchableSnapshotDirectory extends BaseSearchableSnapshotDirectory {\n+public class SearchableSnapshotDirectory extends BaseDirectory {\n \n-    SearchableSnapshotDirectory(final BlobStoreIndexShardSnapshot snapshot, final BlobContainer blobContainer) {\n-        super(blobContainer, snapshot);\n+    private final BlobStoreIndexShardSnapshot snapshot;\n+    private final BlobContainer blobContainer;\n+    private final SnapshotId snapshotId;\n+    private final IndexId indexId;\n+    private final ShardId shardId;\n+    private final LongSupplier statsCurrentTimeNanosSupplier;\n+    private final Map<String, IndexInputStats> stats;\n+    private final CacheService cacheService;\n+    private final boolean useCache;\n+    private final Path cacheDir;\n+    private final AtomicBoolean closed;\n+\n+    public SearchableSnapshotDirectory(\n+        BlobContainer blobContainer,\n+        BlobStoreIndexShardSnapshot snapshot,\n+        SnapshotId snapshotId,\n+        IndexId indexId,\n+        ShardId shardId,\n+        Settings indexSettings,\n+        LongSupplier currentTimeNanosSupplier,\n+        CacheService cacheService,\n+        Path cacheDir\n+    ) {\n+        super(new SingleInstanceLockFactory());\n+        this.snapshot = Objects.requireNonNull(snapshot);\n+        this.blobContainer = Objects.requireNonNull(blobContainer);\n+        this.snapshotId = Objects.requireNonNull(snapshotId);\n+        this.indexId = Objects.requireNonNull(indexId);\n+        this.shardId = Objects.requireNonNull(shardId);\n+        this.stats = ConcurrentCollections.newConcurrentMapWithAggressiveConcurrency();\n+        this.statsCurrentTimeNanosSupplier = Objects.requireNonNull(currentTimeNanosSupplier);\n+        this.cacheService = Objects.requireNonNull(cacheService);\n+        this.cacheDir = Objects.requireNonNull(cacheDir);\n+        this.closed = new AtomicBoolean(false);\n+        this.useCache = SNAPSHOT_CACHE_ENABLED_SETTING.get(indexSettings);\n+    }\n+\n+    public BlobContainer blobContainer() {\n+        return blobContainer;\n+    }\n+\n+    public SnapshotId getSnapshotId() {\n+        return snapshotId;\n+    }\n+\n+    public IndexId getIndexId() {\n+        return indexId;\n+    }\n+\n+    public ShardId getShardId() {\n+        return shardId;\n+    }\n+\n+    public Map<String, IndexInputStats> getStats() {\n+        return Collections.unmodifiableMap(stats);\n+    }\n+\n+    @Nullable\n+    public IndexInputStats getStats(String fileName) {\n+        return stats.get(fileName);\n+    }\n+\n+    public long statsCurrentTimeNanos() {\n+        return statsCurrentTimeNanosSupplier.getAsLong();\n+    }\n+\n+    private BlobStoreIndexShardSnapshot.FileInfo fileInfo(final String name) throws FileNotFoundException {\n+        return snapshot.indexFiles()\n+            .stream()\n+            .filter(fileInfo -> fileInfo.physicalName().equals(name))\n+            .findFirst()\n+            .orElseThrow(() -> new FileNotFoundException(name));\n+    }\n+\n+    @Override\n+    public final String[] listAll() {\n+        ensureOpen();\n+        return snapshot.indexFiles()\n+            .stream()\n+            .map(BlobStoreIndexShardSnapshot.FileInfo::physicalName)\n+            .sorted(String::compareTo)\n+            .toArray(String[]::new);\n+    }\n+\n+    @Override\n+    public final long fileLength(final String name) throws IOException {\n+        ensureOpen();\n+        return fileInfo(name).length();\n+    }\n+\n+    @Override\n+    public Set<String> getPendingDeletions() {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public void sync(Collection<String> names) {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public void syncMetaData() {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public void deleteFile(String name) {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public IndexOutput createOutput(String name, IOContext context) {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public void rename(String source, String dest) {\n+        throw unsupportedException();\n+    }\n+\n+    private static UnsupportedOperationException unsupportedException() {\n+        assert false : \"this operation is not supported and should have not be called\";\n+        return new UnsupportedOperationException(\"Searchable snapshot directory does not support this operation\");\n+    }\n+\n+    @Override\n+    public final void close() {\n+        if (closed.compareAndSet(false, true)) {\n+            isOpen = false;\n+            // Ideally we could let the cache evict/remove cached files by itself after the\n+            // directory has been closed.\n+            clearCache();\n+        }\n+    }\n+\n+    public void clearCache() {\n+        cacheService.removeFromCache(cacheKey -> cacheKey.belongsTo(snapshotId, indexId, shardId));\n+    }\n+\n+    protected IndexInputStats createIndexInputStats(final long fileLength) {\n+        return new IndexInputStats(fileLength);\n+    }\n+\n+    public CacheKey createCacheKey(String fileName) {\n+        return new CacheKey(snapshotId, indexId, shardId, fileName);\n+    }\n+\n+    public CacheFile getCacheFile(CacheKey cacheKey, long fileLength) throws Exception {\n+        return cacheService.get(cacheKey, fileLength, cacheDir);\n     }\n \n     @Override\n     public IndexInput openInput(final String name, final IOContext context) throws IOException {\n         ensureOpen();\n-        return new SearchableSnapshotIndexInput(blobContainer, fileInfo(name), context, blobContainer.readBlobPreferredLength(),\n-            BufferedIndexInput.BUFFER_SIZE);\n+        final BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfo(name);\n+        final IndexInputStats inputStats = stats.computeIfAbsent(name, n -> createIndexInputStats(fileInfo.length()));\n+        if (useCache) {\n+            return new CacheBufferedIndexInput(this, fileInfo, context, inputStats);\n+        } else {\n+            long preferredLength = blobContainer.readBlobPreferredLength();\n+            return new SearchableSnapshotIndexInput(blobContainer, fileInfo, context, preferredLength, BufferedIndexInput.BUFFER_SIZE);", "originalCommit": "87658bb1fb817f40f767b2b9716b20b33dff1958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NDMyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53917#discussion_r395994329", "bodyText": "Has to be public now it's instantiated by SearchableSnapshotDirectory from a different package.", "author": "tlrx", "createdAt": "2020-03-21T13:50:47Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheBufferedIndexInput.java", "diffHunk": "@@ -47,13 +48,13 @@\n     // last seek position is kept around in order to detect forward/backward seeks for stats\n     private long lastSeekPosition;\n \n-    CacheBufferedIndexInput(CacheDirectory directory, FileInfo fileInfo, IOContext context, IndexInputStats stats) {\n+    public CacheBufferedIndexInput(SearchableSnapshotDirectory directory, FileInfo fileInfo, IOContext context, IndexInputStats stats) {", "originalCommit": "87658bb1fb817f40f767b2b9716b20b33dff1958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NDM0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53917#discussion_r395994341", "bodyText": "Same here.", "author": "tlrx", "createdAt": "2020-03-21T13:51:01Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheFile.java", "diffHunk": "@@ -27,7 +27,7 @@\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n-class CacheFile {\n+public class CacheFile {", "originalCommit": "87658bb1fb817f40f767b2b9716b20b33dff1958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NDM0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53917#discussion_r395994345", "bodyText": "And same here.", "author": "tlrx", "createdAt": "2020-03-21T13:51:10Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheKey.java", "diffHunk": "@@ -18,7 +18,7 @@\n     private final ShardId shardId;\n     private final String fileName;\n \n-    CacheKey(SnapshotId snapshotId, IndexId indexId, ShardId shardId, String fileName) {\n+    public CacheKey(SnapshotId snapshotId, IndexId indexId, ShardId shardId, String fileName) {", "originalCommit": "87658bb1fb817f40f767b2b9716b20b33dff1958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NDQwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53917#discussion_r395994409", "bodyText": "This test comes from the now removed CacheDirectoryTests class with very few adjustments for the SearchableSnapshotDirectory instantiation.", "author": "tlrx", "createdAt": "2020-03-21T13:52:12Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/SearchableSnapshotDirectoryTests.java", "diffHunk": "@@ -380,10 +405,86 @@ private void testIndexInputs(final CheckedBiConsumer<IndexInput, IndexInput, Exc\n         });\n     }\n \n+    public void testClearCache() throws Exception {", "originalCommit": "87658bb1fb817f40f767b2b9716b20b33dff1958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}