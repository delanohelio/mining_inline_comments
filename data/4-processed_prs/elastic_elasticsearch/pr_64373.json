{"pr_number": 64373, "pr_title": "Add action to decommission legacy monitoring cluster alerts", "pr_createdAt": "2020-10-29T18:09:29Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/64373", "timeline": [{"oid": "6d15cb27a99e240893b21efb3a75e28667b734cd", "url": "https://github.com/elastic/elasticsearch/commit/6d15cb27a99e240893b21efb3a75e28667b734cd", "message": "Basic action definitions made", "committedDate": "2020-10-29T17:59:41Z", "type": "commit"}, {"oid": "fd7bc4ada4ab178dc32eae32dcbba9b51dcc87f1", "url": "https://github.com/elastic/elasticsearch/commit/fd7bc4ada4ab178dc32eae32dcbba9b51dcc87f1", "message": "Add ability to specify a consumer for when setup is completed by asynchronous tasks.\n\nHTTP Exporter still WIP.", "committedDate": "2020-10-29T17:59:41Z", "type": "commit"}, {"oid": "76e4303a8d04cada138a697c1a436e54d56ea1a0", "url": "https://github.com/elastic/elasticsearch/commit/76e4303a8d04cada138a697c1a436e54d56ea1a0", "message": "Refactor HttpResource to return more information on its success or failure to publish resources.", "committedDate": "2020-10-29T17:59:41Z", "type": "commit"}, {"oid": "9060cfb818998bc37309d606a31f9a26e9ec1dd6", "url": "https://github.com/elastic/elasticsearch/commit/9060cfb818998bc37309d606a31f9a26e9ec1dd6", "message": "Transport action to remove existing cluster alerts from configured exporters.\n\nSpecifically refresh alerts as part of the migration instead of re-running resource installation.\nWe don't want to re-publish old templates if all the old monitoring resources have already been\nremoved.", "committedDate": "2020-10-29T17:59:41Z", "type": "commit"}, {"oid": "b0c5638cb3b26bc3114da4cc862dbd2eb8a2d132", "url": "https://github.com/elastic/elasticsearch/commit/b0c5638cb3b26bc3114da4cc862dbd2eb8a2d132", "message": "satisfy precommit", "committedDate": "2020-10-29T17:59:41Z", "type": "commit"}, {"oid": "63704e50a855124dca7444eb4942857d6ee9588c", "url": "https://github.com/elastic/elasticsearch/commit/63704e50a855124dca7444eb4942857d6ee9588c", "message": "Fix duplicate setting", "committedDate": "2020-10-29T17:59:41Z", "type": "commit"}, {"oid": "a9e7413af30bd5c4d7f0fb68771fc2357aef7134", "url": "https://github.com/elastic/elasticsearch/commit/a9e7413af30bd5c4d7f0fb68771fc2357aef7134", "message": "Add preliminary rest handler", "committedDate": "2020-10-29T17:59:41Z", "type": "commit"}, {"oid": "dfa08773bc0ca8b77255d9ff6fef357e159bdfa8", "url": "https://github.com/elastic/elasticsearch/commit/dfa08773bc0ca8b77255d9ff6fef357e159bdfa8", "message": "Some serious test cleanup, including a fix for a testing bug", "committedDate": "2020-10-29T17:59:42Z", "type": "commit"}, {"oid": "d9c6f00bd02a2fd12c4ac3b2ad7fc0acbecf76fb", "url": "https://github.com/elastic/elasticsearch/commit/d9c6f00bd02a2fd12c4ac3b2ad7fc0acbecf76fb", "message": "The infinite struggle of forgetting to run precommit", "committedDate": "2020-10-29T18:22:51Z", "type": "commit"}, {"oid": "6c3355ba08c3909ce9ce56993f922c8ce63e4e7f", "url": "https://github.com/elastic/elasticsearch/commit/6c3355ba08c3909ce9ce56993f922c8ce63e4e7f", "message": "The struggle continues", "committedDate": "2020-10-29T20:04:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI4NDc3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r516284771", "bodyText": "nit: include the setting name in the error.\nnit: prefer == false over !", "author": "jakelandis", "createdAt": "2020-11-02T22:11:26Z", "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/action/TransportMonitoringMigrateAlertsAction.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.monitoring.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsAction;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsRequest;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse.ExporterMigrationResult;\n+import org.elasticsearch.xpack.monitoring.Monitoring;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter.ExporterResourceStatus;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporters;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+public class TransportMonitoringMigrateAlertsAction extends TransportMasterNodeAction<MonitoringMigrateAlertsRequest,\n+    MonitoringMigrateAlertsResponse> {\n+\n+    private static final Logger logger = LogManager.getLogger(TransportMonitoringMigrateAlertsAction.class);\n+\n+    private static final TimeValue ALERT_MIGRATION_BACK_OFF_RETRY = new TimeValue(5, TimeUnit.SECONDS);\n+    private static final int ALERT_MIGRATION_MAX_RETRY = 3;\n+\n+    private final Client client;\n+    private final Exporters exporters;\n+\n+    @Inject\n+    public TransportMonitoringMigrateAlertsAction(Client client, Exporters exporters, TransportService transportService,\n+                                                  ClusterService clusterService, ThreadPool threadPool,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MonitoringMigrateAlertsAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MonitoringMigrateAlertsRequest::new, indexNameExpressionResolver, MonitoringMigrateAlertsResponse::new,\n+            ThreadPool.Names.MANAGEMENT);\n+        this.client = client;\n+        this.exporters = exporters;\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, MonitoringMigrateAlertsRequest request, ClusterState state,\n+                                   ActionListener<MonitoringMigrateAlertsResponse> listener) throws Exception {\n+        Settings.Builder decommissionAlertSetting = Settings.builder().put(Monitoring.MIGRATION_DECOMMISSION_ALERTS.getKey(), true);\n+        client.admin().cluster().prepareUpdateSettings().setPersistentSettings(decommissionAlertSetting)\n+            .execute(afterSettingUpdate(listener));\n+    }\n+\n+    /**\n+     * Executed after the settings update has been accepted, this collects the enabled and disabled exporters, requesting each of them\n+     * to explicitly remove their installed alerts if possible. This makes sure that alerts are removed in a timely fashion instead of\n+     * waiting for metrics to be bulked into the monitoring cluster.\n+     */\n+    private ActionListener<ClusterUpdateSettingsResponse> afterSettingUpdate(ActionListener<MonitoringMigrateAlertsResponse> listener) {\n+        return ActionListener.wrap(clusterUpdateSettingsResponse -> {\n+\n+            // Ensure positive result\n+            if (!clusterUpdateSettingsResponse.isAcknowledged()) {\n+                listener.onFailure(new ElasticsearchException(\"Failed to update monitoring migration settings\"));", "originalCommit": "6c3355ba08c3909ce9ce56993f922c8ce63e4e7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI4NzA1MA==", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r516287050", "bodyText": "If the setting is already true, does clusterUpdateSettingResponse.isAcknoledged() still return true ?", "author": "jakelandis", "createdAt": "2020-11-02T22:16:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI4NDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU4MDM1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r521580359", "bodyText": "I added a test that runs the migration multiple times. No failures encountered.", "author": "jbaiera", "createdAt": "2020-11-11T19:13:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI4NDc3MQ=="}], "type": "inlineReview"}, {"oid": "7881f15533fba0b663413ca01704c17441d431bb", "url": "https://github.com/elastic/elasticsearch/commit/7881f15533fba0b663413ca01704c17441d431bb", "message": "Use a semaphore to lock the exporters out of running their setup until after migration", "committedDate": "2020-11-11T19:11:55Z", "type": "commit"}, {"oid": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8", "url": "https://github.com/elastic/elasticsearch/commit/25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8", "message": "Merge branch 'master' into monitoring-decommission-watch-action", "committedDate": "2020-11-12T15:53:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUwNDQxNw==", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524504417", "bodyText": "update @return in javadoc", "author": "jakelandis", "createdAt": "2020-11-16T19:03:00Z", "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/exporter/http/VersionHttpResource.java", "diffHunk": "@@ -91,7 +91,7 @@ public void onFailure(final Exception exception) {\n      * @throws ClassCastException if the response is malformed.\n      * @throws IOException if any parsing issue occurs.\n      */\n-    private boolean validateVersion(final Response response) throws IOException {\n+    private ResourcePublishResult validateVersion(final Response response) throws IOException {", "originalCommit": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUxMDEyOA==", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524510128", "bodyText": "Can you update the java doc for all of the params (for all the these constructors)", "author": "jakelandis", "createdAt": "2020-11-16T19:13:01Z", "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/exporter/http/HttpExporter.java", "diffHunk": "@@ -359,24 +362,49 @@ public void validate(final String username, final Map<Setting<?>, Object> settin\n      */\n     private final HttpResource resource;\n \n+    /**\n+     * {@link HttpResource} for setting up or tearing down cluster alerts specifically.\n+     */\n+    private final HttpResource alertingResource;\n+\n     /**\n      * Track whether cluster alerts are allowed or not between requests. This allows us to avoid wiring a listener and to lazily change it.\n      */\n     private final AtomicBoolean clusterAlertsAllowed = new AtomicBoolean(false);\n \n+    /**\n+     * A barrier object to keep the exporter from installing or operating during a migration operation.\n+     */\n+    private final MonitoringMigrationCoordinator migrationCoordinator;\n+\n     private static final ConcurrentHashMap<String, SecureString> SECURE_AUTH_PASSWORDS = new ConcurrentHashMap<>();\n     private final ThreadContext threadContext;\n     private final DateFormatter dateTimeFormatter;\n     private final ClusterStateListener onLocalMasterListener;\n+\n+    /**\n+     * Helper class to separate all resources from just watcher resources\n+     */\n+    static class Resources {\n+        MultiHttpResource allResources;\n+        HttpResource alertingResource;\n+\n+        Resources(MultiHttpResource allResources, HttpResource alertingResource) {\n+            this.allResources = allResources;\n+            this.alertingResource = alertingResource;\n+        }\n+    }\n+\n     /**\n      * Create an {@link HttpExporter}.\n      *\n      * @param config The HTTP Exporter's configuration\n      * @param sslService The SSL Service used to create the SSL Context necessary for TLS / SSL communication\n      * @throws SettingsException if any setting is malformed\n      */\n-    public HttpExporter(final Config config, final SSLService sslService, final ThreadContext threadContext) {\n-        this(config, sslService, threadContext, new NodeFailureListener(), createResources(config));\n+    public HttpExporter(final Config config, final SSLService sslService, final ThreadContext threadContext,", "originalCommit": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUyNzU4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524527589", "bodyText": "tryBlockInstallationTasks and unblockInstallationTasks should be in a corresponding try/finally block...just incase.", "author": "jakelandis", "createdAt": "2020-11-16T19:43:39Z", "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/action/TransportMonitoringMigrateAlertsAction.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.monitoring.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsAction;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsRequest;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse.ExporterMigrationResult;\n+import org.elasticsearch.xpack.monitoring.Monitoring;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter.ExporterResourceStatus;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporters;\n+import org.elasticsearch.xpack.monitoring.exporter.MonitoringMigrationCoordinator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+public class TransportMonitoringMigrateAlertsAction extends TransportMasterNodeAction<MonitoringMigrateAlertsRequest,\n+    MonitoringMigrateAlertsResponse> {\n+\n+    private static final Logger logger = LogManager.getLogger(TransportMonitoringMigrateAlertsAction.class);\n+\n+    private static final TimeValue ALERT_MIGRATION_INSTALLATION_WAIT_TIMEOUT = new TimeValue(10, TimeUnit.SECONDS);\n+    private static final TimeValue ALERT_MIGRATION_BACK_OFF_RETRY = new TimeValue(5, TimeUnit.SECONDS);\n+    private static final int ALERT_MIGRATION_MAX_RETRY = 3;\n+\n+    private final Client client;\n+    private final MonitoringMigrationCoordinator migrationCoordinator;\n+    private final Exporters exporters;\n+\n+    @Inject\n+    public TransportMonitoringMigrateAlertsAction(Client client, Exporters exporters, MonitoringMigrationCoordinator migrationCoordinator,\n+                                                  TransportService transportService, ClusterService clusterService, ThreadPool threadPool,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MonitoringMigrateAlertsAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MonitoringMigrateAlertsRequest::new, indexNameExpressionResolver, MonitoringMigrateAlertsResponse::new,\n+            ThreadPool.Names.MANAGEMENT);\n+        this.client = client;\n+        this.migrationCoordinator = migrationCoordinator;\n+        this.exporters = exporters;\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, MonitoringMigrateAlertsRequest request, ClusterState state,\n+                                   ActionListener<MonitoringMigrateAlertsResponse> listener) throws Exception {\n+        // First, enable the migration coordinator block\n+        if (migrationCoordinator.tryBlockInstallationTasks(ALERT_MIGRATION_INSTALLATION_WAIT_TIMEOUT) == false) {", "originalCommit": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg1MTczMA==", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524851730", "bodyText": "Actually... after looking at this abit more, I think the semaphore should be replaced by a simple atomic boolean. Here we can throw an exception immediately if multiple requests come in while processing, and the other places are currently using this effectively as a boolean .", "author": "jakelandis", "createdAt": "2020-11-17T02:53:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUyNzU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDczODAxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524738015", "bodyText": "nit: addClusterAlertsRemovalAsyncActions (not get)\nAlso, can you update the java doc.", "author": "jakelandis", "createdAt": "2020-11-16T23:20:07Z", "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/exporter/local/LocalExporter.java", "diffHunk": "@@ -481,8 +583,26 @@ private void getClusterAlertsInstallationAsyncActions(final boolean indexExists,\n         }\n     }\n \n-    private void putWatch(final Client client, final String watchId, final String uniqueWatchId,\n-                          final AtomicInteger pendingResponses) {\n+    /**\n+     * Removes Cluster Alerts (Watches) from the cluster\n+     *\n+     * @param asyncActions Asynchronous actions are added to for each Watch.\n+     * @param pendingResponses Pending response countdown we use to track completion.\n+     */\n+    private void getClusterAlertsRemovalAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,", "originalCommit": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc0NzU0OA==", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524747548", "bodyText": "Should this be removeAlerts ? (and javadoc updated)", "author": "jakelandis", "createdAt": "2020-11-16T23:28:23Z", "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/exporter/Exporter.java", "diffHunk": "@@ -136,6 +139,12 @@ public boolean isSingleton() {\n         return false;\n     }\n \n+    /**\n+     * Forces an exporter to deploy (or clean up) cluster alerts immediately instead of waiting to do it\n+     * lazily as part of accepting a bulk operation.\n+     */\n+    public abstract void refreshAlerts(Consumer<ExporterResourceStatus> listener);", "originalCommit": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc0OTQzMg==", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524749432", "bodyText": "should this be deleteAlertsFromOpenExporter ? (or the like ...i.e. not refresh since it just deletes)\nAlso, so probably assert that the exporter is indeed open.", "author": "jakelandis", "createdAt": "2020-11-16T23:30:08Z", "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/action/TransportMonitoringMigrateAlertsAction.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.monitoring.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsAction;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsRequest;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse.ExporterMigrationResult;\n+import org.elasticsearch.xpack.monitoring.Monitoring;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter.ExporterResourceStatus;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporters;\n+import org.elasticsearch.xpack.monitoring.exporter.MonitoringMigrationCoordinator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+public class TransportMonitoringMigrateAlertsAction extends TransportMasterNodeAction<MonitoringMigrateAlertsRequest,\n+    MonitoringMigrateAlertsResponse> {\n+\n+    private static final Logger logger = LogManager.getLogger(TransportMonitoringMigrateAlertsAction.class);\n+\n+    private static final TimeValue ALERT_MIGRATION_INSTALLATION_WAIT_TIMEOUT = new TimeValue(10, TimeUnit.SECONDS);\n+    private static final TimeValue ALERT_MIGRATION_BACK_OFF_RETRY = new TimeValue(5, TimeUnit.SECONDS);\n+    private static final int ALERT_MIGRATION_MAX_RETRY = 3;\n+\n+    private final Client client;\n+    private final MonitoringMigrationCoordinator migrationCoordinator;\n+    private final Exporters exporters;\n+\n+    @Inject\n+    public TransportMonitoringMigrateAlertsAction(Client client, Exporters exporters, MonitoringMigrationCoordinator migrationCoordinator,\n+                                                  TransportService transportService, ClusterService clusterService, ThreadPool threadPool,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MonitoringMigrateAlertsAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MonitoringMigrateAlertsRequest::new, indexNameExpressionResolver, MonitoringMigrateAlertsResponse::new,\n+            ThreadPool.Names.MANAGEMENT);\n+        this.client = client;\n+        this.migrationCoordinator = migrationCoordinator;\n+        this.exporters = exporters;\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, MonitoringMigrateAlertsRequest request, ClusterState state,\n+                                   ActionListener<MonitoringMigrateAlertsResponse> listener) throws Exception {\n+        // First, enable the migration coordinator block\n+        if (migrationCoordinator.tryBlockInstallationTasks(ALERT_MIGRATION_INSTALLATION_WAIT_TIMEOUT) == false) {\n+            throw new EsRejectedExecutionException(\"Could not migrate cluster alerts. Timed out waiting to block resource operations.\");\n+        }\n+        // Wrap the listener to unblock resource installation before completing\n+        listener = ActionListener.runBefore(listener, migrationCoordinator::unblockInstallationTasks);\n+        try {\n+            Settings.Builder decommissionAlertSetting = Settings.builder().put(Monitoring.MIGRATION_DECOMMISSION_ALERTS.getKey(), true);\n+            client.admin().cluster().prepareUpdateSettings().setPersistentSettings(decommissionAlertSetting)\n+                .execute(afterSettingUpdate(listener));\n+        } catch (Exception e) {\n+            // unblock resource installation if something fails here\n+            migrationCoordinator.unblockInstallationTasks();\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Executed after the settings update has been accepted, this collects the enabled and disabled exporters, requesting each of them\n+     * to explicitly remove their installed alerts if possible. This makes sure that alerts are removed in a timely fashion instead of\n+     * waiting for metrics to be bulked into the monitoring cluster.\n+     */\n+    private ActionListener<ClusterUpdateSettingsResponse> afterSettingUpdate(ActionListener<MonitoringMigrateAlertsResponse> listener) {\n+        return ActionListener.wrap(clusterUpdateSettingsResponse -> {\n+            // Ensure positive result\n+            if (!clusterUpdateSettingsResponse.isAcknowledged()) {\n+                listener.onFailure(new ElasticsearchException(\"Failed to update monitoring migration settings\"));\n+            }\n+\n+            // iterate over all the exporters and refresh the alerts\n+            Collection<Exporter> enabledExporters = exporters.getEnabledExporters();\n+            Collection<Exporter.Config> disabledExporterConfigs = exporters.getDisabledExporterConfigs();\n+\n+            List<Runnable> refreshTasks = new ArrayList<>();\n+            AtomicInteger remaining = new AtomicInteger(enabledExporters.size() + disabledExporterConfigs.size());\n+            List<ExporterResourceStatus> results = Collections.synchronizedList(new ArrayList<>(remaining.get()));\n+            logger.debug(\"Exporters in need of refreshing [{}]; enabled [{}], disabled [{}]\", remaining.get(), enabledExporters.size(),\n+                disabledExporterConfigs.size());\n+\n+            for (Exporter enabledExporter : enabledExporters) {\n+                refreshTasks.add(() -> refreshOpenExporter(enabledExporter,\n+                    resultCollector(enabledExporter.config(), listener, remaining, results)));\n+            }\n+            for (Exporter.Config disabledExporter : disabledExporterConfigs) {\n+                refreshTasks.add(() -> refreshDisabledExporter(disabledExporter,\n+                    resultCollector(disabledExporter, listener, remaining, results)));\n+            }\n+            for (Runnable refreshTask : refreshTasks) {\n+                threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(refreshTask);\n+            }\n+        }, listener::onFailure);\n+    }\n+\n+    /**\n+     * Create an action listener that will collect results and finish the request once all results are in.\n+     * @param exporterConfig The exporter being refreshed in this operation (in case of failure)\n+     * @param listener The listener to call after all refresh operations are complete\n+     * @param remaining The counter used to determine if any other operations are in flight\n+     * @param results A thread-safe collection to hold results\n+     */\n+    private ActionListener<ExporterResourceStatus> resultCollector(final Exporter.Config exporterConfig,\n+                                                                   final ActionListener<MonitoringMigrateAlertsResponse> listener,\n+                                                                   final AtomicInteger remaining,\n+                                                                   final List<ExporterResourceStatus> results) {\n+        return new ActionListener<>() {\n+            @Override\n+            public void onResponse(ExporterResourceStatus exporterResourceStatus) {\n+                addStatus(exporterResourceStatus);\n+            }\n+\n+            @Override\n+            public void onFailure(Exception e) {\n+                // Need the exporter name and type here for reporting purposes. Maybe we need to make multiple of these listeners\n+                addStatus(ExporterResourceStatus.notReady(exporterConfig.name(), exporterConfig.type(), e));\n+            }\n+\n+            private void addStatus(ExporterResourceStatus exporterResourceStatus) {\n+                results.add(exporterResourceStatus);\n+                int tasksRemaining = remaining.decrementAndGet();\n+                if (tasksRemaining == 0) {\n+                    finalResult();\n+                }\n+            }\n+\n+            private void finalResult() {\n+                try {\n+                    List<ExporterMigrationResult> collectedResults = results.stream().map(status ->\n+                        new ExporterMigrationResult(\n+                            status.getExporterName(),\n+                            status.getExporterType(),\n+                            status.isComplete(),\n+                            compileReason(status))\n+                    ).collect(Collectors.toList());\n+                    MonitoringMigrateAlertsResponse response = new MonitoringMigrateAlertsResponse(collectedResults);\n+                    listener.onResponse(response);\n+                } catch (Exception e) {\n+                    // Make this self contained, we don't want to bubble up exceptions in a way where this listener's\n+                    // onFailure method could be called multiple times.\n+                    listener.onFailure(e);\n+                }\n+            }\n+\n+            private Exception compileReason(ExporterResourceStatus status) {\n+                // The reason for unsuccessful setup could be multiple exceptions: one or more watches\n+                // may fail to be removed for any reason.\n+                List<Exception> exceptions = status.getExceptions();\n+                if (exceptions == null || exceptions.size() == 0) {\n+                    return null;\n+                } else if (exceptions.size() == 1) {\n+                    return exceptions.get(0);\n+                } else {\n+                    // Set first exception as the cause, and the rest as suppressed under it.\n+                    Exception head = new ElasticsearchException(\"multiple errors occurred during migration\", exceptions.get(0));\n+                    List<Exception> tail = exceptions.subList(1, exceptions.size());\n+                    return tail.stream().reduce(head, ExceptionsHelper::useOrSuppress);\n+                }\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Attempts to migrate a given exporter's alerts, retrying a number of times in case the exporter is busy doing a previous setup task.\n+     * @param exporter The exporter to migrate\n+     * @param listener Notified of success or failure\n+     */\n+    private void refreshOpenExporter(Exporter exporter, ActionListener<ExporterResourceStatus> listener) {", "originalCommit": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc1Mjc5OA==", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524752798", "bodyText": "Am I missing the retry logic ? I see the _RETRY values up above, but I don't think they are used.", "author": "jakelandis", "createdAt": "2020-11-16T23:33:22Z", "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/action/TransportMonitoringMigrateAlertsAction.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.monitoring.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsAction;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsRequest;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse.ExporterMigrationResult;\n+import org.elasticsearch.xpack.monitoring.Monitoring;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter.ExporterResourceStatus;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporters;\n+import org.elasticsearch.xpack.monitoring.exporter.MonitoringMigrationCoordinator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+public class TransportMonitoringMigrateAlertsAction extends TransportMasterNodeAction<MonitoringMigrateAlertsRequest,\n+    MonitoringMigrateAlertsResponse> {\n+\n+    private static final Logger logger = LogManager.getLogger(TransportMonitoringMigrateAlertsAction.class);\n+\n+    private static final TimeValue ALERT_MIGRATION_INSTALLATION_WAIT_TIMEOUT = new TimeValue(10, TimeUnit.SECONDS);\n+    private static final TimeValue ALERT_MIGRATION_BACK_OFF_RETRY = new TimeValue(5, TimeUnit.SECONDS);\n+    private static final int ALERT_MIGRATION_MAX_RETRY = 3;\n+\n+    private final Client client;\n+    private final MonitoringMigrationCoordinator migrationCoordinator;\n+    private final Exporters exporters;\n+\n+    @Inject\n+    public TransportMonitoringMigrateAlertsAction(Client client, Exporters exporters, MonitoringMigrationCoordinator migrationCoordinator,\n+                                                  TransportService transportService, ClusterService clusterService, ThreadPool threadPool,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MonitoringMigrateAlertsAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MonitoringMigrateAlertsRequest::new, indexNameExpressionResolver, MonitoringMigrateAlertsResponse::new,\n+            ThreadPool.Names.MANAGEMENT);\n+        this.client = client;\n+        this.migrationCoordinator = migrationCoordinator;\n+        this.exporters = exporters;\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, MonitoringMigrateAlertsRequest request, ClusterState state,\n+                                   ActionListener<MonitoringMigrateAlertsResponse> listener) throws Exception {\n+        // First, enable the migration coordinator block\n+        if (migrationCoordinator.tryBlockInstallationTasks(ALERT_MIGRATION_INSTALLATION_WAIT_TIMEOUT) == false) {\n+            throw new EsRejectedExecutionException(\"Could not migrate cluster alerts. Timed out waiting to block resource operations.\");\n+        }\n+        // Wrap the listener to unblock resource installation before completing\n+        listener = ActionListener.runBefore(listener, migrationCoordinator::unblockInstallationTasks);\n+        try {\n+            Settings.Builder decommissionAlertSetting = Settings.builder().put(Monitoring.MIGRATION_DECOMMISSION_ALERTS.getKey(), true);\n+            client.admin().cluster().prepareUpdateSettings().setPersistentSettings(decommissionAlertSetting)\n+                .execute(afterSettingUpdate(listener));\n+        } catch (Exception e) {\n+            // unblock resource installation if something fails here\n+            migrationCoordinator.unblockInstallationTasks();\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Executed after the settings update has been accepted, this collects the enabled and disabled exporters, requesting each of them\n+     * to explicitly remove their installed alerts if possible. This makes sure that alerts are removed in a timely fashion instead of\n+     * waiting for metrics to be bulked into the monitoring cluster.\n+     */\n+    private ActionListener<ClusterUpdateSettingsResponse> afterSettingUpdate(ActionListener<MonitoringMigrateAlertsResponse> listener) {\n+        return ActionListener.wrap(clusterUpdateSettingsResponse -> {\n+            // Ensure positive result\n+            if (!clusterUpdateSettingsResponse.isAcknowledged()) {\n+                listener.onFailure(new ElasticsearchException(\"Failed to update monitoring migration settings\"));\n+            }\n+\n+            // iterate over all the exporters and refresh the alerts\n+            Collection<Exporter> enabledExporters = exporters.getEnabledExporters();\n+            Collection<Exporter.Config> disabledExporterConfigs = exporters.getDisabledExporterConfigs();\n+\n+            List<Runnable> refreshTasks = new ArrayList<>();\n+            AtomicInteger remaining = new AtomicInteger(enabledExporters.size() + disabledExporterConfigs.size());\n+            List<ExporterResourceStatus> results = Collections.synchronizedList(new ArrayList<>(remaining.get()));\n+            logger.debug(\"Exporters in need of refreshing [{}]; enabled [{}], disabled [{}]\", remaining.get(), enabledExporters.size(),\n+                disabledExporterConfigs.size());\n+\n+            for (Exporter enabledExporter : enabledExporters) {\n+                refreshTasks.add(() -> refreshOpenExporter(enabledExporter,\n+                    resultCollector(enabledExporter.config(), listener, remaining, results)));\n+            }\n+            for (Exporter.Config disabledExporter : disabledExporterConfigs) {\n+                refreshTasks.add(() -> refreshDisabledExporter(disabledExporter,\n+                    resultCollector(disabledExporter, listener, remaining, results)));\n+            }\n+            for (Runnable refreshTask : refreshTasks) {\n+                threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(refreshTask);\n+            }\n+        }, listener::onFailure);\n+    }\n+\n+    /**\n+     * Create an action listener that will collect results and finish the request once all results are in.\n+     * @param exporterConfig The exporter being refreshed in this operation (in case of failure)\n+     * @param listener The listener to call after all refresh operations are complete\n+     * @param remaining The counter used to determine if any other operations are in flight\n+     * @param results A thread-safe collection to hold results\n+     */\n+    private ActionListener<ExporterResourceStatus> resultCollector(final Exporter.Config exporterConfig,\n+                                                                   final ActionListener<MonitoringMigrateAlertsResponse> listener,\n+                                                                   final AtomicInteger remaining,\n+                                                                   final List<ExporterResourceStatus> results) {\n+        return new ActionListener<>() {\n+            @Override\n+            public void onResponse(ExporterResourceStatus exporterResourceStatus) {\n+                addStatus(exporterResourceStatus);\n+            }\n+\n+            @Override\n+            public void onFailure(Exception e) {\n+                // Need the exporter name and type here for reporting purposes. Maybe we need to make multiple of these listeners\n+                addStatus(ExporterResourceStatus.notReady(exporterConfig.name(), exporterConfig.type(), e));\n+            }\n+\n+            private void addStatus(ExporterResourceStatus exporterResourceStatus) {\n+                results.add(exporterResourceStatus);\n+                int tasksRemaining = remaining.decrementAndGet();\n+                if (tasksRemaining == 0) {\n+                    finalResult();\n+                }\n+            }\n+\n+            private void finalResult() {\n+                try {\n+                    List<ExporterMigrationResult> collectedResults = results.stream().map(status ->\n+                        new ExporterMigrationResult(\n+                            status.getExporterName(),\n+                            status.getExporterType(),\n+                            status.isComplete(),\n+                            compileReason(status))\n+                    ).collect(Collectors.toList());\n+                    MonitoringMigrateAlertsResponse response = new MonitoringMigrateAlertsResponse(collectedResults);\n+                    listener.onResponse(response);\n+                } catch (Exception e) {\n+                    // Make this self contained, we don't want to bubble up exceptions in a way where this listener's\n+                    // onFailure method could be called multiple times.\n+                    listener.onFailure(e);\n+                }\n+            }\n+\n+            private Exception compileReason(ExporterResourceStatus status) {\n+                // The reason for unsuccessful setup could be multiple exceptions: one or more watches\n+                // may fail to be removed for any reason.\n+                List<Exception> exceptions = status.getExceptions();\n+                if (exceptions == null || exceptions.size() == 0) {\n+                    return null;\n+                } else if (exceptions.size() == 1) {\n+                    return exceptions.get(0);\n+                } else {\n+                    // Set first exception as the cause, and the rest as suppressed under it.\n+                    Exception head = new ElasticsearchException(\"multiple errors occurred during migration\", exceptions.get(0));\n+                    List<Exception> tail = exceptions.subList(1, exceptions.size());\n+                    return tail.stream().reduce(head, ExceptionsHelper::useOrSuppress);\n+                }\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Attempts to migrate a given exporter's alerts, retrying a number of times in case the exporter is busy doing a previous setup task.", "originalCommit": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgwNjE2OA==", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524806168", "bodyText": "should this be an assert instead ? since this would be a programmer's error, not a runtime error ?", "author": "jakelandis", "createdAt": "2020-11-17T00:29:37Z", "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/exporter/local/LocalExporter.java", "diffHunk": "@@ -167,6 +174,55 @@ boolean isExporterReady() {\n         return running && installingSomething.get() == false && alertsProcessed;\n     }\n \n+    @Override\n+    public void refreshAlerts(Consumer<ExporterResourceStatus> listener) {\n+        if (state.get() == State.TERMINATED) {\n+            throw new IllegalStateException(\"Cannot refresh alerts on terminated exporter\");\n+        }\n+\n+        ClusterState clusterState = clusterService.state();\n+        if (clusterState.nodes().isLocalNodeElectedMaster()) {\n+            // we are on the elected master\n+            // Check that there is nothing that could block metadata updates\n+            if (clusterState.blocks().hasGlobalBlockWithLevel(ClusterBlockLevel.METADATA_WRITE)) {\n+                throw new ElasticsearchException(\"waiting until metadata writes are unblocked\");\n+            }\n+\n+            if (migrationCoordinator.canInstall()) {", "originalCommit": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg1MTE1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524851157", "bodyText": "What thread is all this work happening on ?", "author": "jakelandis", "createdAt": "2020-11-17T02:51:21Z", "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/action/TransportMonitoringMigrateAlertsAction.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.monitoring.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsAction;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsRequest;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse.ExporterMigrationResult;\n+import org.elasticsearch.xpack.monitoring.Monitoring;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter.ExporterResourceStatus;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporters;\n+import org.elasticsearch.xpack.monitoring.exporter.MonitoringMigrationCoordinator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+public class TransportMonitoringMigrateAlertsAction extends TransportMasterNodeAction<MonitoringMigrateAlertsRequest,\n+    MonitoringMigrateAlertsResponse> {\n+\n+    private static final Logger logger = LogManager.getLogger(TransportMonitoringMigrateAlertsAction.class);\n+\n+    private static final TimeValue ALERT_MIGRATION_INSTALLATION_WAIT_TIMEOUT = new TimeValue(10, TimeUnit.SECONDS);\n+    private static final TimeValue ALERT_MIGRATION_BACK_OFF_RETRY = new TimeValue(5, TimeUnit.SECONDS);\n+    private static final int ALERT_MIGRATION_MAX_RETRY = 3;\n+\n+    private final Client client;\n+    private final MonitoringMigrationCoordinator migrationCoordinator;\n+    private final Exporters exporters;\n+\n+    @Inject\n+    public TransportMonitoringMigrateAlertsAction(Client client, Exporters exporters, MonitoringMigrationCoordinator migrationCoordinator,\n+                                                  TransportService transportService, ClusterService clusterService, ThreadPool threadPool,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MonitoringMigrateAlertsAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MonitoringMigrateAlertsRequest::new, indexNameExpressionResolver, MonitoringMigrateAlertsResponse::new,\n+            ThreadPool.Names.MANAGEMENT);\n+        this.client = client;\n+        this.migrationCoordinator = migrationCoordinator;\n+        this.exporters = exporters;\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, MonitoringMigrateAlertsRequest request, ClusterState state,\n+                                   ActionListener<MonitoringMigrateAlertsResponse> listener) throws Exception {\n+        // First, enable the migration coordinator block\n+        if (migrationCoordinator.tryBlockInstallationTasks(ALERT_MIGRATION_INSTALLATION_WAIT_TIMEOUT) == false) {\n+            throw new EsRejectedExecutionException(\"Could not migrate cluster alerts. Timed out waiting to block resource operations.\");\n+        }\n+        // Wrap the listener to unblock resource installation before completing\n+        listener = ActionListener.runBefore(listener, migrationCoordinator::unblockInstallationTasks);\n+        try {\n+            Settings.Builder decommissionAlertSetting = Settings.builder().put(Monitoring.MIGRATION_DECOMMISSION_ALERTS.getKey(), true);\n+            client.admin().cluster().prepareUpdateSettings().setPersistentSettings(decommissionAlertSetting)\n+                .execute(afterSettingUpdate(listener));", "originalCommit": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAxNzAyNw==", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r528017027", "bodyText": "Hmm, if the master node it seems that this runs on a master service thread that completed the settings update. If not, I believe it's a network thread. I'll fork it over to management after the request succeeds.", "author": "jbaiera", "createdAt": "2020-11-20T23:07:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg1MTE1Nw=="}], "type": "inlineReview"}, {"oid": "0996f6ed1e8a72696f36ec4beb75ddc6f3837965", "url": "https://github.com/elastic/elasticsearch/commit/0996f6ed1e8a72696f36ec4beb75ddc6f3837965", "message": "PR feedback", "committedDate": "2020-12-07T17:30:49Z", "type": "commit"}, {"oid": "8b52a5b6c6041fe6910853fe2d3df881670ac4ac", "url": "https://github.com/elastic/elasticsearch/commit/8b52a5b6c6041fe6910853fe2d3df881670ac4ac", "message": "precommit", "committedDate": "2020-12-07T18:12:28Z", "type": "commit"}, {"oid": "16065ed08deb8d66230d055c17a4969be7924527", "url": "https://github.com/elastic/elasticsearch/commit/16065ed08deb8d66230d055c17a4969be7924527", "message": "Merge branch 'master' into monitoring-decommission-watch-action", "committedDate": "2020-12-07T18:54:18Z", "type": "commit"}, {"oid": "1642f52bcab21729665187bb0f635159bbc2b143", "url": "https://github.com/elastic/elasticsearch/commit/1642f52bcab21729665187bb0f635159bbc2b143", "message": "Wrap mocked listeners to fix calls to ActionListener.map", "committedDate": "2020-12-08T21:00:12Z", "type": "commit"}, {"oid": "e911d7a0a8d556ef9d35b1b04397cf265055a704", "url": "https://github.com/elastic/elasticsearch/commit/e911d7a0a8d556ef9d35b1b04397cf265055a704", "message": "overzealous with one of my reverts", "committedDate": "2020-12-09T15:51:26Z", "type": "commit"}, {"oid": "9942a2583068988e572984bdce5b5f7e3d0eb016", "url": "https://github.com/elastic/elasticsearch/commit/9942a2583068988e572984bdce5b5f7e3d0eb016", "message": "Merge branch 'master' into monitoring-decommission-watch-action", "committedDate": "2020-12-10T19:07:59Z", "type": "commit"}, {"oid": "6a3e4726779573f320fdbe5d9ffe4cae3b637b7c", "url": "https://github.com/elastic/elasticsearch/commit/6a3e4726779573f320fdbe5d9ffe4cae3b637b7c", "message": "Add alert migration API to non operator actions", "committedDate": "2020-12-10T21:13:31Z", "type": "commit"}, {"oid": "062259964ac805553bc29f3a5549f1d5c979328f", "url": "https://github.com/elastic/elasticsearch/commit/062259964ac805553bc29f3a5549f1d5c979328f", "message": "Merge branch 'master' into monitoring-decommission-watch-action", "committedDate": "2020-12-13T20:27:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk5OTgxMw==", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r541999813", "bodyText": "nit: there is no more time out.\nAlso, can we change the language from \"block\" to \"currently running\"  ?", "author": "jakelandis", "createdAt": "2020-12-13T20:34:11Z", "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/action/TransportMonitoringMigrateAlertsAction.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.monitoring.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRunnable;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsAction;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsRequest;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse.ExporterMigrationResult;\n+import org.elasticsearch.xpack.monitoring.Monitoring;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter.ExporterResourceStatus;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporters;\n+import org.elasticsearch.xpack.monitoring.exporter.MonitoringMigrationCoordinator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+public class TransportMonitoringMigrateAlertsAction extends TransportMasterNodeAction<MonitoringMigrateAlertsRequest,\n+    MonitoringMigrateAlertsResponse> {\n+\n+    private static final Logger logger = LogManager.getLogger(TransportMonitoringMigrateAlertsAction.class);\n+\n+    private final Client client;\n+    private final MonitoringMigrationCoordinator migrationCoordinator;\n+    private final Exporters exporters;\n+\n+    @Inject\n+    public TransportMonitoringMigrateAlertsAction(Client client, Exporters exporters, MonitoringMigrationCoordinator migrationCoordinator,\n+                                                  TransportService transportService, ClusterService clusterService, ThreadPool threadPool,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MonitoringMigrateAlertsAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MonitoringMigrateAlertsRequest::new, indexNameExpressionResolver, MonitoringMigrateAlertsResponse::new,\n+            ThreadPool.Names.MANAGEMENT);\n+        this.client = client;\n+        this.migrationCoordinator = migrationCoordinator;\n+        this.exporters = exporters;\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, MonitoringMigrateAlertsRequest request, ClusterState state,\n+                                   ActionListener<MonitoringMigrateAlertsResponse> listener) throws Exception {\n+        // First, enable the migration coordinator block\n+        if (migrationCoordinator.tryBlockInstallationTasks() == false) {\n+            throw new EsRejectedExecutionException(\"Could not migrate cluster alerts. Timed out waiting to block resource operations.\");", "originalCommit": "062259964ac805553bc29f3a5549f1d5c979328f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAwMjQ0MA==", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r542002440", "bodyText": "nit: no longer blocking", "author": "jakelandis", "createdAt": "2020-12-13T20:48:29Z", "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/exporter/MonitoringMigrationCoordinator.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.monitoring.exporter;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A shared coordination object for blocking execution of exporters when a migration that involves them is in progress", "originalCommit": "062259964ac805553bc29f3a5549f1d5c979328f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAwNjc5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r542006793", "bodyText": "This instance is passed to the exporters, but I don't think this is the instance that passed into the Transport action (that one is created by Guice and injected). Which would mean that any state set by the transport actions would not be read by the exporters, which defeats the purpose of having an external coordinator.\nI wonder if we should just remove the MonitoringMigrationCoordinator class entirely in favor of boolean in the tranport action that dis-allows running that action overlapping.\nIf I understand the global coordinator is there to ensure that our cluster state updates from these operations don't end up re-constructing the exporters we are trying to disable while we are disabling them ? If so, can the transport action write a small piece of cluster state and the exporters onClusterState change read that and skip reconstruction while that state exists in the cluster ?", "author": "jakelandis", "createdAt": "2020-12-13T21:13:02Z", "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/Monitoring.java", "diffHunk": "@@ -103,10 +106,12 @@ public Monitoring(Settings settings) {\n         final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n         final CleanerService cleanerService = new CleanerService(settings, clusterSettings, threadPool, getLicenseState());\n         final SSLService dynamicSSLService = getSslService().createDynamicSSLService();\n+        final MonitoringMigrationCoordinator migrationCoordinator = new MonitoringMigrationCoordinator();", "originalCommit": "062259964ac805553bc29f3a5549f1d5c979328f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0MTUwMw==", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r542441503", "bodyText": "OK ... I missed that that Node.java does   pluginComponents.stream().forEach(p -> b.bind((Class) p.getClass()).toInstance(p)); where plugin components are those items created by the plugins, thereby making them the same instance objects that get injected. Sorry for the noise.", "author": "jakelandis", "createdAt": "2020-12-14T14:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAwNjc5Mw=="}], "type": "inlineReview"}, {"oid": "ae5be4c5d806af580f8c7cdc2ada2e8c0fd7e339", "url": "https://github.com/elastic/elasticsearch/commit/ae5be4c5d806af580f8c7cdc2ada2e8c0fd7e339", "message": "PR comments", "committedDate": "2020-12-14T16:08:18Z", "type": "commit"}]}