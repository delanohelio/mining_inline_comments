{"pr_number": 59933, "pr_title": "Add double script fields", "pr_createdAt": "2020-07-20T21:06:01Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/59933", "timeline": [{"oid": "b7a1c8182aae742babfca8794e8dfe3deaf1f164", "url": "https://github.com/elastic/elasticsearch/commit/b7a1c8182aae742babfca8794e8dfe3deaf1f164", "message": "Add double script fields\n\nThis adds support for `double` typed `script` fields.", "committedDate": "2020-07-20T21:03:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5NTY0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/59933#discussion_r458195645", "bodyText": "I was wondering, would it make sense to add tests for the unsupported queries, to verify that they throw error?", "author": "javanna", "createdAt": "2020-07-21T15:39:31Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptDoubleMappedFieldType.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.mapper;\n+\n+import com.carrotsearch.hppc.LongHashSet;\n+import com.carrotsearch.hppc.LongSet;\n+\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.common.lucene.search.Queries;\n+import org.elasticsearch.common.time.DateMathParser;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.xpack.runtimefields.DoubleScriptFieldScript;\n+import org.elasticsearch.xpack.runtimefields.fielddata.ScriptDoubleFieldData;\n+import org.elasticsearch.xpack.runtimefields.query.DoubleScriptFieldExistsQuery;\n+import org.elasticsearch.xpack.runtimefields.query.DoubleScriptFieldRangeQuery;\n+import org.elasticsearch.xpack.runtimefields.query.DoubleScriptFieldTermQuery;\n+import org.elasticsearch.xpack.runtimefields.query.DoubleScriptFieldTermsQuery;\n+\n+import java.time.ZoneId;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class ScriptDoubleMappedFieldType extends AbstractScriptMappedFieldType {\n+    private final DoubleScriptFieldScript.Factory scriptFactory;\n+\n+    ScriptDoubleMappedFieldType(String name, Script script, DoubleScriptFieldScript.Factory scriptFactory, Map<String, String> meta) {\n+        super(name, script, meta);\n+        this.scriptFactory = scriptFactory;\n+    }\n+\n+    @Override\n+    protected String runtimeType() {\n+        return NumberType.DOUBLE.typeName();\n+    }\n+\n+    @Override\n+    public Object valueForDisplay(Object value) {\n+        return value; // These should come back as a Double\n+    }\n+\n+    @Override\n+    public ScriptDoubleFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+        // TODO once we get SearchLookup as an argument, we can already call scriptFactory.newFactory here and pass through the result\n+        return new ScriptDoubleFieldData.Builder(script, scriptFactory);\n+    }\n+\n+    private DoubleScriptFieldScript.LeafFactory leafFactory(QueryShardContext context) {\n+        return scriptFactory.newFactory(script.getParams(), context.lookup());\n+    }\n+\n+    @Override\n+    public Query existsQuery(QueryShardContext context) {\n+        checkAllowExpensiveQueries(context);\n+        return new DoubleScriptFieldExistsQuery(script, leafFactory(context), name());\n+    }\n+\n+    @Override\n+    public Query rangeQuery(\n+        Object lowerTerm,\n+        Object upperTerm,\n+        boolean includeLower,\n+        boolean includeUpper,\n+        ShapeRelation relation,\n+        ZoneId timeZone,\n+        DateMathParser parser,\n+        QueryShardContext context\n+    ) {\n+        checkAllowExpensiveQueries(context);\n+        return NumberType.doubleRangeQuery(\n+            lowerTerm,\n+            upperTerm,\n+            includeLower,\n+            includeUpper,\n+            (l, u) -> new DoubleScriptFieldRangeQuery(script, leafFactory(context), name(), l, u)\n+        );\n+    }\n+\n+    @Override\n+    public Query termQuery(Object value, QueryShardContext context) {\n+        checkAllowExpensiveQueries(context);\n+        return new DoubleScriptFieldTermQuery(script, leafFactory(context), name(), NumberType.objectToDouble(value));\n+    }\n+\n+    @Override\n+    public Query termsQuery(List<?> values, QueryShardContext context) {\n+        if (values.isEmpty()) {\n+            return Queries.newMatchAllQuery();\n+        }\n+        LongSet terms = new LongHashSet(values.size());\n+        for (Object value : values) {\n+            terms.add(Double.doubleToLongBits(NumberType.objectToDouble(value)));\n+        }\n+        checkAllowExpensiveQueries(context);\n+        return new DoubleScriptFieldTermsQuery(script, leafFactory(context), name(), terms);\n+    }", "originalCommit": "b7a1c8182aae742babfca8794e8dfe3deaf1f164", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMDY2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59933#discussion_r458210669", "bodyText": "I can do that!", "author": "nik9000", "createdAt": "2020-07-21T16:00:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5NTY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5NzgxNw==", "url": "https://github.com/elastic/elasticsearch/pull/59933#discussion_r458197817", "bodyText": "do we have tests somewhere to verify that the scripted fields work fine when used for sorting? Maybe we should also have tests for when they get referred to as part of scripts? I would not cover these two scenarios in a yaml test though.", "author": "javanna", "createdAt": "2020-07-21T15:42:28Z", "path": "x-pack/plugin/src/test/resources/rest-api-spec/test/runtime_fields/30_double.yml", "diffHunk": "@@ -0,0 +1,203 @@\n+---\n+setup:", "originalCommit": "b7a1c8182aae742babfca8794e8dfe3deaf1f164", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzNjUwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/59933#discussion_r458236509", "bodyText": "We do have a scenario where a scripted field refers to a another one, but not where a script query refers to a scripted field. I'll add that.", "author": "nik9000", "createdAt": "2020-07-21T16:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5NzgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5ODY2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59933#discussion_r458198669", "bodyText": "I think that most of these methods could be static, not that it matters a lot though :)", "author": "javanna", "createdAt": "2020-07-21T15:43:39Z", "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptDoubleMappedFieldTypeTests.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.mapper;\n+\n+import org.apache.lucene.document.StoredField;\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.Collector;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.LeafCollector;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.search.Scorable;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.fielddata.SortedNumericDoubleValues;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.painless.PainlessPlugin;\n+import org.elasticsearch.plugins.ExtensiblePlugin.ExtensionLoader;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptModule;\n+import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.script.ScriptType;\n+import org.elasticsearch.xpack.runtimefields.DoubleScriptFieldScript;\n+import org.elasticsearch.xpack.runtimefields.RuntimeFields;\n+import org.elasticsearch.xpack.runtimefields.RuntimeFieldsPainlessExtension;\n+import org.elasticsearch.xpack.runtimefields.fielddata.ScriptDoubleFieldData;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+\n+import static java.util.Collections.emptyMap;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class ScriptDoubleMappedFieldTypeTests extends AbstractScriptMappedFieldTypeTestCase {\n+    public void testDocValues() throws IOException {\n+        try (Directory directory = newDirectory(); RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": [1.0]}\"))));\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": [3.14, 1.4]}\"))));\n+            List<Double> results = new ArrayList<>();\n+            try (DirectoryReader reader = iw.getReader()) {\n+                IndexSearcher searcher = newSearcher(reader);\n+                ScriptDoubleMappedFieldType ft = build(\"for (def v : source.foo) {value(v + params.param)}\", Map.of(\"param\", 1));\n+                IndexMetadata imd = IndexMetadata.builder(\"test\")\n+                    .settings(Settings.builder().put(\"index.version.created\", Version.CURRENT))\n+                    .numberOfShards(1)\n+                    .numberOfReplicas(1)\n+                    .build();\n+                ScriptDoubleFieldData ifd = ft.fielddataBuilder(\"test\").build(new IndexSettings(imd, Settings.EMPTY), ft, null, null, null);\n+                ifd.setSearchLookup(mockContext().lookup());\n+                searcher.search(new MatchAllDocsQuery(), new Collector() {\n+                    @Override\n+                    public ScoreMode scoreMode() {\n+                        return ScoreMode.COMPLETE_NO_SCORES;\n+                    }\n+\n+                    @Override\n+                    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n+                        SortedNumericDoubleValues dv = ifd.load(context).getDoubleValues();\n+                        return new LeafCollector() {\n+                            @Override\n+                            public void setScorer(Scorable scorer) throws IOException {}\n+\n+                            @Override\n+                            public void collect(int doc) throws IOException {\n+                                if (dv.advanceExact(doc)) {\n+                                    for (int i = 0; i < dv.docValueCount(); i++) {\n+                                        results.add(dv.nextValue());\n+                                    }\n+                                }\n+                            }\n+                        };\n+                    }\n+                });\n+                assertThat(results, equalTo(List.of(2.0, 2.4, 4.140000000000001)));\n+            }\n+        }\n+    }\n+\n+    public void testExistsQuery() throws IOException {\n+        try (Directory directory = newDirectory(); RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": [1]}\"))));\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": []}\"))));\n+            try (DirectoryReader reader = iw.getReader()) {\n+                IndexSearcher searcher = newSearcher(reader);\n+                assertThat(searcher.count(build(\"for (def v : source.foo) {value(v)}\").existsQuery(mockContext())), equalTo(1));\n+            }\n+        }\n+    }\n+\n+    public void testExistsQueryIsExpensive() throws IOException {\n+        checkExpensiveQuery(ScriptDoubleMappedFieldType::existsQuery);\n+    }\n+\n+    public void testRangeQuery() throws IOException {\n+        try (Directory directory = newDirectory(); RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": 1}\"))));\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": 2}\"))));\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": 2.5}\"))));\n+            try (DirectoryReader reader = iw.getReader()) {\n+                IndexSearcher searcher = newSearcher(reader);\n+                assertThat(\n+                    searcher.count(build(\"value(source.foo)\").rangeQuery(\"2\", \"3\", true, true, null, null, null, mockContext())),\n+                    equalTo(2)\n+                );\n+                assertThat(\n+                    searcher.count(build(\"value(source.foo)\").rangeQuery(2, 3, true, true, null, null, null, mockContext())),\n+                    equalTo(2)\n+                );\n+                assertThat(\n+                    searcher.count(build(\"value(source.foo)\").rangeQuery(1.1, 3, true, true, null, null, null, mockContext())),\n+                    equalTo(2)\n+                );\n+                assertThat(\n+                    searcher.count(build(\"value(source.foo)\").rangeQuery(1.1, 3, false, true, null, null, null, mockContext())),\n+                    equalTo(2)\n+                );\n+                assertThat(\n+                    searcher.count(build(\"value(source.foo)\").rangeQuery(2, 3, false, true, null, null, null, mockContext())),\n+                    equalTo(1)\n+                );\n+                assertThat(\n+                    searcher.count(build(\"value(source.foo)\").rangeQuery(2.5, 3, true, true, null, null, null, mockContext())),\n+                    equalTo(1)\n+                );\n+                assertThat(\n+                    searcher.count(build(\"value(source.foo)\").rangeQuery(2.5, 3, false, true, null, null, null, mockContext())),\n+                    equalTo(0)\n+                );\n+            }\n+        }\n+    }\n+\n+    public void testRangeQueryIsExpensive() throws IOException {\n+        checkExpensiveQuery(\n+            (ft, ctx) -> ft.rangeQuery(randomLong(), randomLong(), randomBoolean(), randomBoolean(), null, null, null, ctx)\n+        );\n+    }\n+\n+    public void testTermQuery() throws IOException {\n+        try (Directory directory = newDirectory(); RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": 1}\"))));\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": 2}\"))));\n+            try (DirectoryReader reader = iw.getReader()) {\n+                IndexSearcher searcher = newSearcher(reader);\n+                assertThat(searcher.count(build(\"value(source.foo)\").termQuery(\"1\", mockContext())), equalTo(1));\n+                assertThat(searcher.count(build(\"value(source.foo)\").termQuery(1, mockContext())), equalTo(1));\n+                assertThat(searcher.count(build(\"value(source.foo)\").termQuery(1.1, mockContext())), equalTo(0));\n+                assertThat(\n+                    searcher.count(build(\"value(source.foo + params.param)\", Map.of(\"param\", 1)).termQuery(2, mockContext())),\n+                    equalTo(1)\n+                );\n+            }\n+        }\n+    }\n+\n+    public void testTermQueryIsExpensive() throws IOException {\n+        checkExpensiveQuery((ft, ctx) -> ft.termQuery(randomLong(), ctx));\n+    }\n+\n+    public void testTermsQuery() throws IOException {\n+        try (Directory directory = newDirectory(); RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": 1}\"))));\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": 2.1}\"))));\n+            try (DirectoryReader reader = iw.getReader()) {\n+                IndexSearcher searcher = newSearcher(reader);\n+                assertThat(searcher.count(build(\"value(source.foo)\").termsQuery(List.of(\"1\"), mockContext())), equalTo(1));\n+                assertThat(searcher.count(build(\"value(source.foo)\").termsQuery(List.of(1), mockContext())), equalTo(1));\n+                assertThat(searcher.count(build(\"value(source.foo)\").termsQuery(List.of(1.1), mockContext())), equalTo(0));\n+                assertThat(searcher.count(build(\"value(source.foo)\").termsQuery(List.of(1.1, 2.1), mockContext())), equalTo(1));\n+                assertThat(searcher.count(build(\"value(source.foo)\").termsQuery(List.of(2.1, 1), mockContext())), equalTo(2));\n+            }\n+        }\n+    }\n+\n+    public void testTermsQueryIsExpensive() throws IOException {\n+        checkExpensiveQuery((ft, ctx) -> ft.termsQuery(List.of(randomLong()), ctx));\n+    }\n+\n+    private ScriptDoubleMappedFieldType build(String code) throws IOException {", "originalCommit": "b7a1c8182aae742babfca8794e8dfe3deaf1f164", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4155e9c329d1feef5a3a9a71233611b51beb24eb", "url": "https://github.com/elastic/elasticsearch/commit/4155e9c329d1feef5a3a9a71233611b51beb24eb", "message": "Merge branch 'feature/runtime_fields' into script_field_double", "committedDate": "2020-07-21T16:39:05Z", "type": "commit"}, {"oid": "491728b66d8751a641b96b601a85ebdcd63c5922", "url": "https://github.com/elastic/elasticsearch/commit/491728b66d8751a641b96b601a85ebdcd63c5922", "message": "Add tests for error from unimplemented queries", "committedDate": "2020-07-21T17:05:16Z", "type": "commit"}, {"oid": "0dd624a36d2c4372a97424b94aea3210b816e169", "url": "https://github.com/elastic/elasticsearch/commit/0dd624a36d2c4372a97424b94aea3210b816e169", "message": "WIP", "committedDate": "2020-07-21T17:53:35Z", "type": "commit"}, {"oid": "f29bd64d89d5b358165773686fdd6440084a8478", "url": "https://github.com/elastic/elasticsearch/commit/f29bd64d89d5b358165773686fdd6440084a8478", "message": "WIP", "committedDate": "2020-07-21T17:59:47Z", "type": "commit"}, {"oid": "bdd3dbe7894f77c68e4c8fda2d0101b8f3e02efd", "url": "https://github.com/elastic/elasticsearch/commit/bdd3dbe7894f77c68e4c8fda2d0101b8f3e02efd", "message": "Merge branch 'feature/runtime_fields' into script_field_double", "committedDate": "2020-07-21T19:48:08Z", "type": "commit"}, {"oid": "fa2af2ee1f5d537552f1dd6c1270bb56443afb67", "url": "https://github.com/elastic/elasticsearch/commit/fa2af2ee1f5d537552f1dd6c1270bb56443afb67", "message": "Merge branch 'feature/runtime_fields' into script_field_double", "committedDate": "2020-07-21T19:49:24Z", "type": "commit"}, {"oid": "76d9ee2a108e9668e79313b707028937f3d93e6f", "url": "https://github.com/elastic/elasticsearch/commit/76d9ee2a108e9668e79313b707028937f3d93e6f", "message": "precommit", "committedDate": "2020-07-21T20:02:57Z", "type": "commit"}]}