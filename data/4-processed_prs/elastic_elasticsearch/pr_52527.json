{"pr_number": 52527, "pr_title": "Auto-allocate searchable snapshots", "pr_createdAt": "2020-02-19T17:20:30Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52527", "timeline": [{"oid": "a524179d505f46409e96d461e7495d6d5fbf2df8", "url": "https://github.com/elastic/elasticsearch/commit/a524179d505f46409e96d461e7495d6d5fbf2df8", "message": "Auto-allocate searchable snapshots\n\nThis commit allows plugins to supply their own allocator for existing shards,\ngeneralizing the default `GatewayAllocator`. It uses this to implement a very\nsimple auto-allocation process for searchable snapshots which respects the\nallocation deciders but which can otherwise be assigned to any node.", "committedDate": "2020-02-19T17:16:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQyNTAyNA==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381425024", "bodyText": "for discussion", "author": "DaveCTurner", "createdAt": "2020-02-19T17:22:24Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java", "diffHunk": "@@ -413,10 +421,18 @@ private void reroute(RoutingAllocation allocation) {\n         assert hasDeadNodes(allocation) == false : \"dead nodes should be explicitly cleaned up. See disassociateDeadNodes\";\n         assert AutoExpandReplicas.getAutoExpandReplicaChanges(allocation.metaData(), allocation).isEmpty() :\n             \"auto-expand replicas out of sync with number of nodes in the cluster\";\n+        assert existingShardsAllocators.isEmpty() == false : \"must have at least one ExistingShardsAllocator\";\n \n         removeDelayMarkers(allocation);\n+\n+        allocation.routingNodes().unassigned().sort(PriorityComparator.getAllocationComparator(allocation)); // sort for priority ordering\n+\n         // try to allocate existing shard copies first\n-        gatewayAllocator.allocateUnassigned(allocation);\n+        // TODO TBD the order in which allocators run depends on the order of plugins so is not properly defined. Does this matter?\n+        // TODO TBD this means earlier allocators allocate shards before the later allocators can allocate possibly-higher-priority ones", "originalCommit": "a524179d505f46409e96d461e7495d6d5fbf2df8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQyNTA3OA==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381425078", "bodyText": "for discussion", "author": "DaveCTurner", "createdAt": "2020-02-19T17:22:30Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java", "diffHunk": "@@ -413,10 +421,18 @@ private void reroute(RoutingAllocation allocation) {\n         assert hasDeadNodes(allocation) == false : \"dead nodes should be explicitly cleaned up. See disassociateDeadNodes\";\n         assert AutoExpandReplicas.getAutoExpandReplicaChanges(allocation.metaData(), allocation).isEmpty() :\n             \"auto-expand replicas out of sync with number of nodes in the cluster\";\n+        assert existingShardsAllocators.isEmpty() == false : \"must have at least one ExistingShardsAllocator\";\n \n         removeDelayMarkers(allocation);\n+\n+        allocation.routingNodes().unassigned().sort(PriorityComparator.getAllocationComparator(allocation)); // sort for priority ordering\n+\n         // try to allocate existing shard copies first\n-        gatewayAllocator.allocateUnassigned(allocation);\n+        // TODO TBD the order in which allocators run depends on the order of plugins so is not properly defined. Does this matter?", "originalCommit": "a524179d505f46409e96d461e7495d6d5fbf2df8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3NDMyNw==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381874327", "bodyText": "We could leave it to the core framework to decide which allocator to invoke", "author": "ywelsch", "createdAt": "2020-02-20T09:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQyNTA3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjU5NDI0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r382594249", "bodyText": "\ud83d\udc4d I've moved to that model now.", "author": "DaveCTurner", "createdAt": "2020-02-21T13:58:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQyNTA3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQyNjI3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381426279", "bodyText": "With this commit, this hack is no longer needed since we do not fetch the shard info like this.", "author": "DaveCTurner", "createdAt": "2020-02-19T17:24:32Z", "path": "server/src/main/java/org/elasticsearch/index/store/Store.java", "diffHunk": "@@ -446,13 +446,8 @@ public static void tryOpenIndex(Path indexLocation, ShardId shardId, NodeEnviron\n         try (ShardLock lock = shardLocker.lock(shardId, \"open index\", TimeUnit.SECONDS.toMillis(5));\n              Directory dir = new SimpleFSDirectory(indexLocation)) {\n             failIfCorrupted(dir);\n-            // Previously we called Lucene#readSegmentInfos which verifies that some Lucene metadata is readable and makes sense, but if it\n-            // weren't then we would mark this shard as corrupt when allocated, so it seems that this is unnecessary (and it breaks when\n-            // the shard's directory is virtual since we use SimpleFSDirectory above.\n-            // TODO NORELEASE is this ok? Need to check that we definitely add a corruption marker if the metadata is corrupt.", "originalCommit": "a524179d505f46409e96d461e7495d6d5fbf2df8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4NDY2MA==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381884660", "bodyText": "\ud83d\udc4d", "author": "ywelsch", "createdAt": "2020-02-20T09:39:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQyNjI3OQ=="}], "type": "inlineReview"}, {"oid": "44df8606f303642ce7230c5d76cdcad0a89415c2", "url": "https://github.com/elastic/elasticsearch/commit/44df8606f303642ce7230c5d76cdcad0a89415c2", "message": "Rename", "committedDate": "2020-02-19T18:25:59Z", "type": "commit"}, {"oid": "1015ac8f4d2ba98d69d1a756ebb08a4ffd42e9e3", "url": "https://github.com/elastic/elasticsearch/commit/1015ac8f4d2ba98d69d1a756ebb08a4ffd42e9e3", "message": "Merge branch 'feature/searchable-snapshots' into 2020-02-19-pluggable-allocator-for-existing-shards", "committedDate": "2020-02-19T20:11:00Z", "type": "commit"}, {"oid": "438ec61043958b6bec8354def99b49d690eeac2f", "url": "https://github.com/elastic/elasticsearch/commit/438ec61043958b6bec8354def99b49d690eeac2f", "message": "Merge branch 'feature/searchable-snapshots' into 2020-02-19-pluggable-allocator-for-existing-shards", "committedDate": "2020-02-19T21:19:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgyOTgwNg==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381829806", "bodyText": "I think I would prefer to not name the plugin in index settings and instead just have a searchable snapshot specific setting that triggers this.", "author": "henningandersen", "createdAt": "2020-02-20T07:47:02Z", "path": "server/src/main/java/org/elasticsearch/gateway/PrimaryShardAllocator.java", "diffHunk": "@@ -82,6 +98,14 @@ public AllocateUnassignedDecision makeAllocationDecision(final ShardRouting unas\n             return AllocateUnassignedDecision.NOT_TAKEN;\n         }\n \n+        final IndexMetaData indexMetaData = allocation.metaData().getIndexSafe(unassignedShard.index());\n+        final String existingShardsAllocator = ExistingShardsAllocator.EXISTING_SHARDS_ALLOCATOR_SETTING.get(indexMetaData.getSettings());\n+        if (unassignedShard.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE\n+            && existingShardsAllocator.equals(GatewayAllocator.ALLOCATOR_NAME) == false) {", "originalCommit": "438ec61043958b6bec8354def99b49d690eeac2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1Nzc2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381857765", "bodyText": "I don't really understand this suggestion, sorry. Are you saying that we should allocate the shard as normal if the plugin is missing?", "author": "DaveCTurner", "createdAt": "2020-02-20T08:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgyOTgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4NDE3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381884171", "bodyText": "I wonder if we should have a separate facility that ensures that certain plugins are installed in the presence of certain types of indices. Otherwise we have to build this again and again for any plugin-specific setting that we introduce.\nTake for example \"follower\" indices (CCR). Those only make sense in the context of x-pack.", "author": "ywelsch", "createdAt": "2020-02-20T09:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgyOTgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkwODQzMw==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381908433", "bodyText": "I now see the leniency in MetaDataIndexUpgradeService.archiveBrokenIndexSettings, I thought we would be stricter on that. It seems dangerous that we just archive all the settings and then act like nothing happened. I think not allocating any such indices until resolved would be better, but that is likely a more intrusive change.\nMaybe there is a different way we can deem indices with searchable snapshot settings without the underlying plugin more invalid than other superfluous settings?", "author": "henningandersen", "createdAt": "2020-02-20T10:22:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgyOTgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjU5NzMxNw==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r382597317", "bodyText": "I have reverted these changes to the PrimaryShardAllocator and instead now the AllocationService chooses the correct allocator based on an index setting. I think a setting is a good approach; we could perhaps deduce the fact that a different allocator is needed for searchable snapshots via some other mechanism, but I'm not sure what that mechanism might be nor what advantage it offers.\nI am generally in favour of validating that the nodes in the cluster \"make sense\" in terms of their plugins but that's a larger topic for another day IMO.", "author": "DaveCTurner", "createdAt": "2020-02-21T14:04:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgyOTgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3ODMxNA==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r382878314", "bodyText": "@henningandersen See #26998.", "author": "jasontedor", "createdAt": "2020-02-22T02:29:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgyOTgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczODYyNA==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r388738624", "bodyText": "My main issue with the approach is redundancy. I can see how the redundancy here solves the issue of a missing plugin and agree that solving that is not now.", "author": "henningandersen", "createdAt": "2020-03-06T06:53:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgyOTgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzOTk5OA==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381839998", "bodyText": "It seems like the loop here and the handling of a NO decision belongs in the framework (allocation service?) rather than in every plugin. It is important that this is done right.\nThis in turn could lead to removing GatewayAllocator completely and letting Replica and PrimaryShardAllocator become individual ExistingShardsAllocators. A method to allow processExistingRecoveries would be necessary though.", "author": "henningandersen", "createdAt": "2020-02-20T08:12:56Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotAllocator.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.RoutingNodes;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.cluster.routing.allocation.AllocateUnassignedDecision;\n+import org.elasticsearch.cluster.routing.allocation.AllocationDecision;\n+import org.elasticsearch.cluster.routing.allocation.ExistingShardsAllocator;\n+import org.elasticsearch.cluster.routing.allocation.FailedShard;\n+import org.elasticsearch.cluster.routing.allocation.NodeAllocationResult;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class SearchableSnapshotAllocator implements ExistingShardsAllocator {\n+\n+    static final String ALLOCATOR_NAME = \"searchable_snapshot_allocator\";\n+\n+    @Override\n+    public void allocateUnassigned(RoutingAllocation allocation) {\n+\n+        final RoutingNodes.UnassignedShards.UnassignedIterator iterator = allocation.routingNodes().unassigned().iterator();\n+\n+        while (iterator.hasNext()) {", "originalCommit": "438ec61043958b6bec8354def99b49d690eeac2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg2NDM4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381864385", "bodyText": "Here we handle NO (and THROTTLE) decisions by stopping further allocation attempts, but that behaviour seems to me to be specific to this plugin (and the fact that this naive implementation checks all nodes against the deciders). For instance, the ReplicaShardAllocator does not share this behaviour: it only checks the deciders for nodes with at least some of the shard on disk already, and allows NO decisions to fall through to the BalancedShardsAllocator so that replicas can be allocated afresh.\nI'm in two minds about iterating through the unassigned shards within each allocator. As written, we prioritise the shards that can be allocated by a plugin over the standard shards. In the case of searchable snapshots I don't think this is too bad (they should be fast to start and may well live on their own nodes). On the other hand if we pulled the loop up to the AllocationService then this would change the allocation order to prefer recovering higher-priority replicas instead of lower-priority primaries, which would keep the cluster in red health for longer after startup.", "author": "DaveCTurner", "createdAt": "2020-02-20T09:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzOTk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg2ODQ5OA==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381868498", "bodyText": "Hmm having written that it's now obvious that we could solve the priority thing by sorting the shards based on whether they're a primary or not \ud83e\udd26\u200d\u2642", "author": "DaveCTurner", "createdAt": "2020-02-20T09:11:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzOTk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg0MTM2MA==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381841360", "bodyText": "If we want to name the allocator in settings, I think we should just pick the right allocator per shard from the outside?", "author": "henningandersen", "createdAt": "2020-02-20T08:16:19Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotAllocator.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.RoutingNodes;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.cluster.routing.allocation.AllocateUnassignedDecision;\n+import org.elasticsearch.cluster.routing.allocation.AllocationDecision;\n+import org.elasticsearch.cluster.routing.allocation.ExistingShardsAllocator;\n+import org.elasticsearch.cluster.routing.allocation.FailedShard;\n+import org.elasticsearch.cluster.routing.allocation.NodeAllocationResult;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class SearchableSnapshotAllocator implements ExistingShardsAllocator {\n+\n+    static final String ALLOCATOR_NAME = \"searchable_snapshot_allocator\";\n+\n+    @Override\n+    public void allocateUnassigned(RoutingAllocation allocation) {\n+\n+        final RoutingNodes.UnassignedShards.UnassignedIterator iterator = allocation.routingNodes().unassigned().iterator();\n+\n+        while (iterator.hasNext()) {\n+            final ShardRouting shardRouting = iterator.next();\n+            final AllocateUnassignedDecision allocateUnassignedDecision = decideAllocation(allocation, shardRouting);\n+\n+            if (allocateUnassignedDecision.isDecisionTaken()) {\n+                if (allocateUnassignedDecision.getAllocationDecision() == AllocationDecision.YES) {\n+                    if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE) {\n+                        // we don't care what the allocation ID is since we know that these shards cannot really be stale, so we can\n+                        // safely ignore the allocation ID with a forced-stale allocation\n+                        iterator.updateUnassigned(shardRouting.unassignedInfo(),\n+                            RecoverySource.ExistingStoreRecoverySource.FORCE_STALE_PRIMARY_INSTANCE, allocation.changes());\n+                    }\n+                    iterator.initialize(allocateUnassignedDecision.getTargetNode().getId(), null, 0L, allocation.changes());\n+                } else {\n+                    iterator.removeAndIgnore(allocateUnassignedDecision.getAllocationStatus(), allocation.changes());\n+                }\n+            }\n+        }\n+    }\n+\n+    private static AllocateUnassignedDecision decideAllocation(RoutingAllocation allocation, ShardRouting shardRouting) {\n+        if (isResponsibleFor(allocation, shardRouting)) {\n+            Decision.Type bestDecision = Decision.Type.NO;\n+            RoutingNode bestNode = null;\n+            final List<NodeAllocationResult> nodeAllocationResults\n+                = allocation.debugDecision() ? new ArrayList<>(allocation.routingNodes().size()) : null;\n+\n+            for (final RoutingNode routingNode : allocation.routingNodes()) {\n+                final Decision decision = allocation.deciders().canAllocate(shardRouting, routingNode, allocation);\n+                if (decision.type() == Decision.Type.YES\n+                    || (decision.type() == Decision.Type.THROTTLE && bestDecision != Decision.Type.YES)) {\n+                    bestDecision = decision.type();\n+                    bestNode = routingNode;\n+                }\n+                if (nodeAllocationResults != null) {\n+                    nodeAllocationResults.add(new NodeAllocationResult(routingNode.node(), null, decision));\n+                }\n+            }\n+\n+            switch (bestDecision) {\n+                case YES:\n+                    return AllocateUnassignedDecision.yes(bestNode.node(), null, nodeAllocationResults, false);\n+                case THROTTLE:\n+                    return AllocateUnassignedDecision.throttle(nodeAllocationResults);\n+                case NO:\n+                    return AllocateUnassignedDecision.no(UnassignedInfo.AllocationStatus.DECIDERS_NO, nodeAllocationResults);\n+            }\n+        }\n+\n+        return AllocateUnassignedDecision.NOT_TAKEN;\n+    }\n+\n+    private static boolean isResponsibleFor(RoutingAllocation allocation, ShardRouting shardRouting) {\n+        final Settings settings = allocation.metaData().getIndexSafe(shardRouting.index()).getSettings();\n+        return shardRouting.unassigned() && ExistingShardsAllocator.EXISTING_SHARDS_ALLOCATOR_SETTING.get(settings).equals(ALLOCATOR_NAME);", "originalCommit": "438ec61043958b6bec8354def99b49d690eeac2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg2OTQ5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381869499", "bodyText": "Yes, this needs the loop to be brought up to the top level, which I now see that we can do safely. I'll try that.", "author": "DaveCTurner", "createdAt": "2020-02-20T09:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg0MTM2MA=="}], "type": "inlineReview"}, {"oid": "41071b2d3a90e4bf314fe34c2b1f275bdef3b072", "url": "https://github.com/elastic/elasticsearch/commit/41071b2d3a90e4bf314fe34c2b1f275bdef3b072", "message": "Select a unique allocator for each shard\n\nMove the iteration through the shards from the individual allocators up to the\nAllocationService, allowing us to allocate them in proper priority order and\nalso allowing us to assign a unique allocator to each shard according to an\nindex setting.", "committedDate": "2020-02-20T18:10:25Z", "type": "commit"}, {"oid": "9d1da9640637b1a8e46d8543c43cee722120c365", "url": "https://github.com/elastic/elasticsearch/commit/9d1da9640637b1a8e46d8543c43cee722120c365", "message": "Didn't know I edited that", "committedDate": "2020-02-20T18:22:37Z", "type": "commit"}, {"oid": "ab39f0a2537f35d8b1beeb7367ed4cc7b2ca03cf", "url": "https://github.com/elastic/elasticsearch/commit/ab39f0a2537f35d8b1beeb7367ed4cc7b2ca03cf", "message": "Revert sorting by primary/replica since we have to iterate twice anyway", "committedDate": "2020-02-21T08:44:56Z", "type": "commit"}, {"oid": "66ca0631b230a8428e7bf391aefea9ca5656144e", "url": "https://github.com/elastic/elasticsearch/commit/66ca0631b230a8428e7bf391aefea9ca5656144e", "message": "Revert some unnecessary changes", "committedDate": "2020-02-21T09:24:12Z", "type": "commit"}, {"oid": "02e615811704046a80f7464cdbc5174c4d4785f5", "url": "https://github.com/elastic/elasticsearch/commit/02e615811704046a80f7464cdbc5174c4d4785f5", "message": "Add tests for duplicate checks of existing shards allocators", "committedDate": "2020-02-21T09:56:30Z", "type": "commit"}, {"oid": "5154f7f91d3e5084bb3d6db618542fb0769d4f8a", "url": "https://github.com/elastic/elasticsearch/commit/5154f7f91d3e5084bb3d6db618542fb0769d4f8a", "message": "We always take a decision right now", "committedDate": "2020-02-21T10:15:12Z", "type": "commit"}, {"oid": "e61a3426fbf314f4119c28a61f19f0d7a76b973e", "url": "https://github.com/elastic/elasticsearch/commit/e61a3426fbf314f4119c28a61f19f0d7a76b973e", "message": "Add test of allocation service behaviour", "committedDate": "2020-02-21T13:29:37Z", "type": "commit"}, {"oid": "aad3fc018a24627b1da5992058ea87011e5ddc20", "url": "https://github.com/elastic/elasticsearch/commit/aad3fc018a24627b1da5992058ea87011e5ddc20", "message": "Add test for unknown allocator too", "committedDate": "2020-02-21T13:43:53Z", "type": "commit"}, {"oid": "09c49b88887e84fce940b219e563e936732458c1", "url": "https://github.com/elastic/elasticsearch/commit/09c49b88887e84fce940b219e563e936732458c1", "message": "Merge branch 'feature/searchable-snapshots' into 2020-02-19-pluggable-allocator-for-existing-shards", "committedDate": "2020-02-21T14:21:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxODUyOA==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r383018528", "bodyText": "for started shards, you used a for loop, whereas here there's a lambda. Perhaps just make it consistent?", "author": "ywelsch", "createdAt": "2020-02-23T16:26:43Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java", "diffHunk": "@@ -217,7 +230,8 @@ public ClusterState applyFailedShards(final ClusterState clusterState, final Lis\n                 logger.trace(\"{} shard routing failed in an earlier iteration (routing: {})\", shardToFail.shardId(), shardToFail);\n             }\n         }\n-        gatewayAllocator.applyFailedShards(allocation, failedShards);\n+        existingShardsAllocators.values().forEach(existingShardsAllocator ->", "originalCommit": "09c49b88887e84fce940b219e563e936732458c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQwNzIzMA==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r386407230", "bodyText": "++ done in  c9b84ab.", "author": "DaveCTurner", "createdAt": "2020-03-02T13:58:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxODUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxODg5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r383018897", "bodyText": "as these lookups can be expensive in case there are many unassigned shards, I wonder if we should pass the retrieved IndexMetaData to the ExistingShardsAllocator.", "author": "ywelsch", "createdAt": "2020-02-23T16:31:36Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java", "diffHunk": "@@ -470,7 +514,104 @@ protected long currentNanoTime() {\n     }\n \n     public void cleanCaches() {\n-        gatewayAllocator.cleanCaches();\n+        assert assertInitialized();\n+        existingShardsAllocators.values().forEach(ExistingShardsAllocator::cleanCaches);\n+    }\n+\n+    public int getNumberOfInFlightFetches() {\n+        assert assertInitialized();\n+        return existingShardsAllocators.values().stream().mapToInt(ExistingShardsAllocator::getNumberOfInFlightFetches).sum();\n+    }\n+\n+    public ShardAllocationDecision explainShardAllocation(ShardRouting shardRouting, RoutingAllocation allocation) {\n+        assert allocation.debugDecision();\n+        AllocateUnassignedDecision allocateDecision\n+            = shardRouting.unassigned() ? explainUnassignedShardAllocation(shardRouting, allocation) : AllocateUnassignedDecision.NOT_TAKEN;\n+        if (allocateDecision.isDecisionTaken()) {\n+            return new ShardAllocationDecision(allocateDecision, MoveDecision.NOT_TAKEN);\n+        } else {\n+            return shardsAllocator.decideShardAllocation(shardRouting, allocation);\n+        }\n+    }\n+\n+    private AllocateUnassignedDecision explainUnassignedShardAllocation(ShardRouting shardRouting, RoutingAllocation routingAllocation) {\n+        assert shardRouting.unassigned();\n+        assert routingAllocation.debugDecision();\n+        assert assertInitialized();\n+        final ExistingShardsAllocator existingShardsAllocator = getAllocatorForShard(shardRouting, routingAllocation);\n+        final AllocateUnassignedDecision decision\n+            = existingShardsAllocator.explainUnassignedShardAllocation(shardRouting, routingAllocation);\n+        if (decision.isDecisionTaken()) {\n+            return decision;\n+        }\n+        return AllocateUnassignedDecision.NOT_TAKEN;\n+    }\n+\n+    private ExistingShardsAllocator getAllocatorForShard(ShardRouting shardRouting, RoutingAllocation routingAllocation) {\n+        assert assertInitialized();\n+        final String allocatorName = ExistingShardsAllocator.EXISTING_SHARDS_ALLOCATOR_SETTING.get(\n+            routingAllocation.metaData().getIndexSafe(shardRouting.index()).getSettings());", "originalCommit": "09c49b88887e84fce940b219e563e936732458c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQyNDkwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r386424905", "bodyText": "It involves passing the IndexMetaData around to a lot of places. I mean we could do that if you're sure this is sufficiently expensive, but it seems surprising to me  that this would be a concern.", "author": "DaveCTurner", "createdAt": "2020-03-02T14:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxODg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxOTg3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r383019879", "bodyText": "The cluster module already receives the clusterPlugins at initialization time. Perhaps we can just reuse those or even extract the ExistingShardsAllocator at init time?", "author": "ywelsch", "createdAt": "2020-02-23T16:45:29Z", "path": "server/src/main/java/org/elasticsearch/cluster/ClusterModule.java", "diffHunk": "@@ -251,4 +252,21 @@ protected void configure() {\n         bind(AllocationDeciders.class).toInstance(allocationDeciders);\n         bind(ShardsAllocator.class).toInstance(shardsAllocator);\n     }\n+\n+    public void setExistingShardsAllocators(GatewayAllocator gatewayAllocator, List<ClusterPlugin> clusterPlugins) {", "originalCommit": "09c49b88887e84fce940b219e563e936732458c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQyMTE0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r386421141", "bodyText": "We have to defer the creation of the allocators until later, because they need a RerouteService and there's an (intrinsically tricky) circular dependency to resolve. We'll need to do this differently when the plugin's allocator also needs a RerouteService but it's premature to address that  now.", "author": "DaveCTurner", "createdAt": "2020-03-02T14:23:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxOTg3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQyMzUwMg==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r386423502", "bodyText": "Ok, addressed in 4b8888c.", "author": "DaveCTurner", "createdAt": "2020-03-02T14:27:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxOTg3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAyMDA0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r383020041", "bodyText": "maybe omit the \"instead\", and explain what the key in this map represents (to which setting it is tied)", "author": "ywelsch", "createdAt": "2020-02-23T16:46:56Z", "path": "server/src/main/java/org/elasticsearch/plugins/ClusterPlugin.java", "diffHunk": "@@ -59,6 +60,14 @@\n         return Collections.emptyMap();\n     }\n \n+    /**\n+     * Return {@link ExistingShardsAllocator} implementations added by this plugin, which will run instead of the default", "originalCommit": "09c49b88887e84fce940b219e563e936732458c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQwNzMzOA==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r386407338", "bodyText": "++ done in 6cd0917.", "author": "DaveCTurner", "createdAt": "2020-03-02T13:59:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAyMDA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3NTY0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r383975643", "bodyText": "nit: I would prefer to leave the field null until initialized (and thus non-final), that seems simpler to me.", "author": "henningandersen", "createdAt": "2020-02-25T16:03:35Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java", "diffHunk": "@@ -70,26 +73,32 @@\n     private static final Logger logger = LogManager.getLogger(AllocationService.class);\n \n     private final AllocationDeciders allocationDeciders;\n-    private GatewayAllocator gatewayAllocator;\n+    private final Map<String, ExistingShardsAllocator> existingShardsAllocators = new HashMap<>();\n     private final ShardsAllocator shardsAllocator;\n     private final ClusterInfoService clusterInfoService;\n \n-    public AllocationService(AllocationDeciders allocationDeciders,\n-                             GatewayAllocator gatewayAllocator,\n+    // only for tests that use the GatewayAllocator as the unique ExistingShardsAllocator\n+    public AllocationService(AllocationDeciders allocationDeciders, GatewayAllocator gatewayAllocator,\n                              ShardsAllocator shardsAllocator, ClusterInfoService clusterInfoService) {\n         this(allocationDeciders, shardsAllocator, clusterInfoService);\n-        setGatewayAllocator(gatewayAllocator);\n+        setExistingShardsAllocators(Collections.singletonMap(GatewayAllocator.ALLOCATOR_NAME, gatewayAllocator));\n     }\n \n-    public AllocationService(AllocationDeciders allocationDeciders,\n-                             ShardsAllocator shardsAllocator, ClusterInfoService clusterInfoService) {\n+    public AllocationService(AllocationDeciders allocationDeciders, ShardsAllocator shardsAllocator,\n+                             ClusterInfoService clusterInfoService) {\n         this.allocationDeciders = allocationDeciders;\n         this.shardsAllocator = shardsAllocator;\n         this.clusterInfoService = clusterInfoService;\n     }\n \n-    public void setGatewayAllocator(GatewayAllocator gatewayAllocator) {\n-        this.gatewayAllocator = gatewayAllocator;\n+    /**\n+     * Inject the {@link ExistingShardsAllocator}s to use. May only be called once.\n+     */\n+    public void setExistingShardsAllocators(Map<String, ExistingShardsAllocator> existingShardsAllocators) {\n+        assert this.existingShardsAllocators.isEmpty()", "originalCommit": "09c49b88887e84fce940b219e563e936732458c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQwNzQ3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r386407471", "bodyText": "Ok, done in e6e5b7e.", "author": "DaveCTurner", "createdAt": "2020-03-02T13:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3NTY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMwMzUzNw==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r384303537", "bodyText": "I would prefer to use a dedicated interface with the 3 methods that a plugin is allowed to use (in particular, they are not allowed to call .next() on this iterator).", "author": "henningandersen", "createdAt": "2020-02-26T06:57:58Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/ExistingShardsAllocator.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.cluster.routing.allocation;\n+\n+import org.elasticsearch.cluster.routing.RoutingNodes;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.gateway.GatewayAllocator;\n+\n+import java.util.List;\n+\n+/**\n+ * Searches for, and allocates, shards for which there is an existing on-disk copy somewhere in the cluster. The default implementation is\n+ * {@link GatewayAllocator}, but plugins can supply their own implementations too.\n+ */\n+public interface ExistingShardsAllocator {\n+\n+    /**\n+     * Allows plugins to override how we allocate shards that may already exist on disk in the cluster.\n+     */\n+    Setting<String> EXISTING_SHARDS_ALLOCATOR_SETTING = Setting.simpleString(\n+        \"index.allocation.existing_shards_allocator\", GatewayAllocator.ALLOCATOR_NAME,\n+        Setting.Property.IndexScope, Setting.Property.PrivateIndex);\n+\n+    /**\n+     * Called before starting a round of allocation, allowing the allocator to invalidate some caches if appropriate.\n+     */\n+    void beforeAllocation(RoutingAllocation allocation);\n+\n+\n+    /**\n+     * Called during a round of allocation after attempting to allocate all the primaries but before any replicas, allowing the allocator\n+     * to prepare for replica allocation.\n+     */\n+    void afterPrimariesBeforeReplicas(RoutingAllocation allocation);\n+\n+    /**\n+     * Allocate any unassigned shards in the given {@link RoutingAllocation} for which this {@link ExistingShardsAllocator} is responsible.\n+     */\n+    void allocateUnassigned(RoutingAllocation allocation, ShardRouting shardRouting,\n+                            RoutingNodes.UnassignedShards.UnassignedIterator iterator);", "originalCommit": "09c49b88887e84fce940b219e563e936732458c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQwOTIyNA==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r386409224", "bodyText": "Ok, done in c7c1701. This whole area is steeped in  legacy -- there's no need to implement Iterator at all -- but now is  not  the time to clean that up.", "author": "DaveCTurner", "createdAt": "2020-03-02T14:02:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMwMzUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQxMjM5OA==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r384412398", "bodyText": "nit: I think the _allocator suffix in the name is superfluous and should be removed.", "author": "henningandersen", "createdAt": "2020-02-26T10:44:49Z", "path": "server/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java", "diffHunk": "@@ -54,7 +55,9 @@\n import java.util.stream.Collectors;\n import java.util.stream.StreamSupport;\n \n-public class GatewayAllocator {\n+public class GatewayAllocator implements ExistingShardsAllocator {\n+\n+    public static final String ALLOCATOR_NAME = \"gateway_allocator\";", "originalCommit": "09c49b88887e84fce940b219e563e936732458c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxMTYyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r386411629", "bodyText": "I prefer to keep the suffix to distinguish it from all the other things called gateway in this area.", "author": "DaveCTurner", "createdAt": "2020-03-02T14:07:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQxMjM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQxMzY1OA==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r384413658", "bodyText": "Some of the methods in this interface have RoutingAllocation first, others have ShardRouting first. I think we should order them consistently. I personally prefer to put the subject of the operation (ShardRouting or List<ShardRouting) first and the \"context\" (RoutingAllocation) last.", "author": "henningandersen", "createdAt": "2020-02-26T10:46:57Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/ExistingShardsAllocator.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.cluster.routing.allocation;\n+\n+import org.elasticsearch.cluster.routing.RoutingNodes;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.gateway.GatewayAllocator;\n+\n+import java.util.List;\n+\n+/**\n+ * Searches for, and allocates, shards for which there is an existing on-disk copy somewhere in the cluster. The default implementation is\n+ * {@link GatewayAllocator}, but plugins can supply their own implementations too.\n+ */\n+public interface ExistingShardsAllocator {\n+\n+    /**\n+     * Allows plugins to override how we allocate shards that may already exist on disk in the cluster.\n+     */\n+    Setting<String> EXISTING_SHARDS_ALLOCATOR_SETTING = Setting.simpleString(\n+        \"index.allocation.existing_shards_allocator\", GatewayAllocator.ALLOCATOR_NAME,\n+        Setting.Property.IndexScope, Setting.Property.PrivateIndex);\n+\n+    /**\n+     * Called before starting a round of allocation, allowing the allocator to invalidate some caches if appropriate.\n+     */\n+    void beforeAllocation(RoutingAllocation allocation);\n+\n+\n+    /**\n+     * Called during a round of allocation after attempting to allocate all the primaries but before any replicas, allowing the allocator\n+     * to prepare for replica allocation.\n+     */\n+    void afterPrimariesBeforeReplicas(RoutingAllocation allocation);\n+\n+    /**\n+     * Allocate any unassigned shards in the given {@link RoutingAllocation} for which this {@link ExistingShardsAllocator} is responsible.\n+     */\n+    void allocateUnassigned(RoutingAllocation allocation, ShardRouting shardRouting,", "originalCommit": "09c49b88887e84fce940b219e563e936732458c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxMTc3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r386411777", "bodyText": "Ok, I've moved the ShardRoutings first in a72d9ba.", "author": "DaveCTurner", "createdAt": "2020-03-02T14:07:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQxMzY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyMjI5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r384422297", "bodyText": "nit: allocateExistingUnassignedShards?", "author": "henningandersen", "createdAt": "2020-02-26T11:03:08Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java", "diffHunk": "@@ -413,15 +427,43 @@ private void reroute(RoutingAllocation allocation) {\n         assert hasDeadNodes(allocation) == false : \"dead nodes should be explicitly cleaned up. See disassociateDeadNodes\";\n         assert AutoExpandReplicas.getAutoExpandReplicaChanges(allocation.metaData(), allocation).isEmpty() :\n             \"auto-expand replicas out of sync with number of nodes in the cluster\";\n+        assert assertInitialized();\n \n         removeDelayMarkers(allocation);\n-        // try to allocate existing shard copies first\n-        gatewayAllocator.allocateUnassigned(allocation);\n \n+        allocateExistingShards(allocation);  // try to allocate existing shard copies first\n         shardsAllocator.allocate(allocation);\n         assert RoutingNodes.assertShardStats(allocation.routingNodes());\n     }\n \n+    private void allocateExistingShards(RoutingAllocation allocation) {", "originalCommit": "09c49b88887e84fce940b219e563e936732458c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxMTg5OA==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r386411898", "bodyText": "Ok, done in 3301a2b.", "author": "DaveCTurner", "createdAt": "2020-03-02T14:07:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyMjI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNjI1OA==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r384426258", "bodyText": "I find this assert unnecessary since it is a final field and it is initialized in constructor?", "author": "henningandersen", "createdAt": "2020-02-26T11:11:23Z", "path": "server/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java", "diffHunk": "@@ -101,47 +106,64 @@ public int getNumberOfInFlightFetch() {\n         return count;\n     }\n \n+    @Override\n     public void applyStartedShards(final RoutingAllocation allocation, final List<ShardRouting> startedShards) {\n         for (ShardRouting startedShard : startedShards) {\n             Releasables.close(asyncFetchStarted.remove(startedShard.shardId()));\n             Releasables.close(asyncFetchStore.remove(startedShard.shardId()));\n         }\n     }\n \n+    @Override\n     public void applyFailedShards(final RoutingAllocation allocation, final List<FailedShard> failedShards) {\n         for (FailedShard failedShard : failedShards) {\n             Releasables.close(asyncFetchStarted.remove(failedShard.getRoutingEntry().shardId()));\n             Releasables.close(asyncFetchStore.remove(failedShard.getRoutingEntry().shardId()));\n         }\n     }\n \n-    public void allocateUnassigned(final RoutingAllocation allocation) {\n+    @Override\n+    public void beforeAllocation(final RoutingAllocation allocation) {\n         assert primaryShardAllocator != null;\n         assert replicaShardAllocator != null;\n         ensureAsyncFetchStorePrimaryRecency(allocation);\n-        innerAllocatedUnassigned(allocation, primaryShardAllocator, replicaShardAllocator);\n     }\n \n-    // allow for testing infra to change shard allocators implementation\n-    protected static void innerAllocatedUnassigned(RoutingAllocation allocation,\n-                                                   PrimaryShardAllocator primaryShardAllocator,\n-                                                   ReplicaShardAllocator replicaShardAllocator) {\n-        RoutingNodes.UnassignedShards unassigned = allocation.routingNodes().unassigned();\n-        unassigned.sort(PriorityComparator.getAllocationComparator(allocation)); // sort for priority ordering\n-\n-        primaryShardAllocator.allocateUnassigned(allocation);\n+    @Override\n+    public void afterPrimariesBeforeReplicas(RoutingAllocation allocation) {\n+        assert replicaShardAllocator != null;", "originalCommit": "09c49b88887e84fce940b219e563e936732458c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxNTUzMg==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r386415532", "bodyText": "It is null in tests that use a subclass, and I found it all-too-easy to trip over this.\nI don't really like how the tests override this class's behaviour, but don't want to start working on that kind of refactoring here.", "author": "DaveCTurner", "createdAt": "2020-03-02T14:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNjI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczOTQ3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r388739473", "bodyText": "Ah yes, I overlooked that, thanks.", "author": "henningandersen", "createdAt": "2020-03-06T06:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNjI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNjQ5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r384426497", "bodyText": "I find these two asserts unnecessary since the fields are final and initialized in constructor?", "author": "henningandersen", "createdAt": "2020-02-26T11:11:52Z", "path": "server/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java", "diffHunk": "@@ -101,47 +106,64 @@ public int getNumberOfInFlightFetch() {\n         return count;\n     }\n \n+    @Override\n     public void applyStartedShards(final RoutingAllocation allocation, final List<ShardRouting> startedShards) {\n         for (ShardRouting startedShard : startedShards) {\n             Releasables.close(asyncFetchStarted.remove(startedShard.shardId()));\n             Releasables.close(asyncFetchStore.remove(startedShard.shardId()));\n         }\n     }\n \n+    @Override\n     public void applyFailedShards(final RoutingAllocation allocation, final List<FailedShard> failedShards) {\n         for (FailedShard failedShard : failedShards) {\n             Releasables.close(asyncFetchStarted.remove(failedShard.getRoutingEntry().shardId()));\n             Releasables.close(asyncFetchStore.remove(failedShard.getRoutingEntry().shardId()));\n         }\n     }\n \n-    public void allocateUnassigned(final RoutingAllocation allocation) {\n+    @Override\n+    public void beforeAllocation(final RoutingAllocation allocation) {\n         assert primaryShardAllocator != null;\n         assert replicaShardAllocator != null;\n         ensureAsyncFetchStorePrimaryRecency(allocation);\n-        innerAllocatedUnassigned(allocation, primaryShardAllocator, replicaShardAllocator);\n     }\n \n-    // allow for testing infra to change shard allocators implementation\n-    protected static void innerAllocatedUnassigned(RoutingAllocation allocation,\n-                                                   PrimaryShardAllocator primaryShardAllocator,\n-                                                   ReplicaShardAllocator replicaShardAllocator) {\n-        RoutingNodes.UnassignedShards unassigned = allocation.routingNodes().unassigned();\n-        unassigned.sort(PriorityComparator.getAllocationComparator(allocation)); // sort for priority ordering\n-\n-        primaryShardAllocator.allocateUnassigned(allocation);\n+    @Override\n+    public void afterPrimariesBeforeReplicas(RoutingAllocation allocation) {\n+        assert replicaShardAllocator != null;\n         if (allocation.routingNodes().hasInactiveShards()) {\n             // cancel existing recoveries if we have a better match\n             replicaShardAllocator.processExistingRecoveries(allocation);\n         }\n-        replicaShardAllocator.allocateUnassigned(allocation);\n     }\n \n-    /**\n-     * Computes and returns the design for allocating a single unassigned shard.  If called on an assigned shard,\n-     * {@link AllocateUnassignedDecision#NOT_TAKEN} is returned.\n-     */\n-    public AllocateUnassignedDecision decideUnassignedShardAllocation(ShardRouting unassignedShard, RoutingAllocation routingAllocation) {\n+    @Override\n+    public void allocateUnassigned(final RoutingAllocation allocation, ShardRouting shardRouting,\n+                                   RoutingNodes.UnassignedShards.UnassignedIterator iterator) {\n+        assert primaryShardAllocator != null;", "originalCommit": "09c49b88887e84fce940b219e563e936732458c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxNTYyMg==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r386415622", "bodyText": "It is null in tests that use a subclass, and I found it all-too-easy to trip over this.\nI don't really like how the tests override this class's behaviour, but don't want to start working on that kind of refactoring here.", "author": "DaveCTurner", "createdAt": "2020-03-02T14:14:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNjQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzNzYzNg==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r384437636", "bodyText": "I think the decision made here effectively bypasses the balancer. I assume you want to tackle that in a follow-up? Would be nice to know if the intention is to invoke balancer somehow here or if the code here will be changed to only consider the nodes that already have data that can be reused?", "author": "henningandersen", "createdAt": "2020-02-26T11:35:49Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotAllocator.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.RoutingNodes;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.cluster.routing.allocation.AllocateUnassignedDecision;\n+import org.elasticsearch.cluster.routing.allocation.AllocationDecision;\n+import org.elasticsearch.cluster.routing.allocation.ExistingShardsAllocator;\n+import org.elasticsearch.cluster.routing.allocation.FailedShard;\n+import org.elasticsearch.cluster.routing.allocation.NodeAllocationResult;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class SearchableSnapshotAllocator implements ExistingShardsAllocator {\n+\n+    static final String ALLOCATOR_NAME = \"searchable_snapshot_allocator\";\n+\n+    @Override\n+    public void beforeAllocation(RoutingAllocation allocation) {\n+    }\n+\n+    @Override\n+    public void afterPrimariesBeforeReplicas(RoutingAllocation allocation) {\n+    }\n+\n+    @Override\n+    public void allocateUnassigned(RoutingAllocation allocation, ShardRouting shardRouting,\n+                                   RoutingNodes.UnassignedShards.UnassignedIterator iterator) {\n+        final AllocateUnassignedDecision allocateUnassignedDecision = decideAllocation(allocation, shardRouting);\n+        assert allocateUnassignedDecision.isDecisionTaken();\n+\n+        if (allocateUnassignedDecision.getAllocationDecision() == AllocationDecision.YES) {\n+            if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE) {\n+                // we don't care what the allocation ID is since we know that these shards cannot really be stale, so we can\n+                // safely ignore the allocation ID with a forced-stale allocation\n+                iterator.updateUnassigned(shardRouting.unassignedInfo(),\n+                    RecoverySource.ExistingStoreRecoverySource.FORCE_STALE_PRIMARY_INSTANCE, allocation.changes());\n+            }\n+            iterator.initialize(allocateUnassignedDecision.getTargetNode().getId(), null, 0L, allocation.changes());\n+        } else {\n+            iterator.removeAndIgnore(allocateUnassignedDecision.getAllocationStatus(), allocation.changes());\n+        }\n+    }\n+\n+    private static AllocateUnassignedDecision decideAllocation(RoutingAllocation allocation, ShardRouting shardRouting) {\n+        assert shardRouting.unassigned();", "originalCommit": "09c49b88887e84fce940b219e563e936732458c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxMjk0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r386412943", "bodyText": "Yes, the actual allocator's behaviour is not really the focus of this PR so I've just done something very simple. To be discussed in the follow-up, but indeed I agree that we will allow shards to fall through to the balancer if we can't find them a good home here.", "author": "DaveCTurner", "createdAt": "2020-03-02T14:09:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzNzYzNg=="}], "type": "inlineReview"}, {"oid": "f1228d6507d255e1cc2770a9311953cd08f0a9e8", "url": "https://github.com/elastic/elasticsearch/commit/f1228d6507d255e1cc2770a9311953cd08f0a9e8", "message": "Merge branch 'feature/searchable-snapshots' into 2020-02-19-pluggable-allocator-for-existing-shards", "committedDate": "2020-03-02T12:29:36Z", "type": "commit"}, {"oid": "76824384122e22ab99f89b6f6bbf8ed10fdc1dbf", "url": "https://github.com/elastic/elasticsearch/commit/76824384122e22ab99f89b6f6bbf8ed10fdc1dbf", "message": "Reformat", "committedDate": "2020-03-02T12:38:26Z", "type": "commit"}, {"oid": "c9b84abb5c0baf326b626328c3acb068fd0b7e00", "url": "https://github.com/elastic/elasticsearch/commit/c9b84abb5c0baf326b626328c3acb068fd0b7e00", "message": "Consistent use of loops", "committedDate": "2020-03-02T12:44:36Z", "type": "commit"}, {"oid": "6cd09170c514caee8c2848fb8708ed94280555ad", "url": "https://github.com/elastic/elasticsearch/commit/6cd09170c514caee8c2848fb8708ed94280555ad", "message": "Improve comment", "committedDate": "2020-03-02T12:47:29Z", "type": "commit"}, {"oid": "e6e5b7e617a94e725a072abe140376b8a92118ad", "url": "https://github.com/elastic/elasticsearch/commit/e6e5b7e617a94e725a072abe140376b8a92118ad", "message": "Use null  rather than empty for unset", "committedDate": "2020-03-02T12:57:12Z", "type": "commit"}, {"oid": "c7c1701c25e51874d75446fe28f8e38691f02df4", "url": "https://github.com/elastic/elasticsearch/commit/c7c1701c25e51874d75446fe28f8e38691f02df4", "message": "Extract interface", "committedDate": "2020-03-02T13:41:22Z", "type": "commit"}, {"oid": "a72d9ba05df5f3861095eb50b6450c3feae98b15", "url": "https://github.com/elastic/elasticsearch/commit/a72d9ba05df5f3861095eb50b6450c3feae98b15", "message": "Consistent argument order", "committedDate": "2020-03-02T13:56:52Z", "type": "commit"}, {"oid": "3301a2b8444c5a37c263754033109d8bee054963", "url": "https://github.com/elastic/elasticsearch/commit/3301a2b8444c5a37c263754033109d8bee054963", "message": "More specific method name", "committedDate": "2020-03-02T13:57:57Z", "type": "commit"}, {"oid": "4b8888c0311d0bfc886baa7ae0349b61749d103e", "url": "https://github.com/elastic/elasticsearch/commit/4b8888c0311d0bfc886baa7ae0349b61749d103e", "message": "Capture plugins at init time", "committedDate": "2020-03-02T14:27:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MDg0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r388740845", "bodyText": "Can we include clusterPlugin.getClass().getName() into the message?", "author": "henningandersen", "createdAt": "2020-03-06T07:02:17Z", "path": "server/src/main/java/org/elasticsearch/cluster/ClusterModule.java", "diffHunk": "@@ -251,4 +254,21 @@ protected void configure() {\n         bind(AllocationDeciders.class).toInstance(allocationDeciders);\n         bind(ShardsAllocator.class).toInstance(shardsAllocator);\n     }\n+\n+    public void setExistingShardsAllocators(GatewayAllocator gatewayAllocator) {\n+        final Map<String, ExistingShardsAllocator> existingShardsAllocators = new HashMap<>();\n+        existingShardsAllocators.put(GatewayAllocator.ALLOCATOR_NAME, gatewayAllocator);\n+\n+        for (ClusterPlugin clusterPlugin : clusterPlugins) {\n+            for (Map.Entry<String, ExistingShardsAllocator> existingShardsAllocatorEntry\n+                : clusterPlugin.getExistingShardsAllocators().entrySet()) {\n+                final String allocatorName = existingShardsAllocatorEntry.getKey();\n+                if (existingShardsAllocators.put(allocatorName, existingShardsAllocatorEntry.getValue()) != null) {\n+                    throw new IllegalArgumentException(\"ExistingShardsAllocator [\" + allocatorName + \"] already defined\");", "originalCommit": "4b8888c0311d0bfc886baa7ae0349b61749d103e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MzU5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r388743599", "bodyText": "nit: remove extra empty line.", "author": "henningandersen", "createdAt": "2020-03-06T07:12:29Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/ExistingShardsAllocator.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.cluster.routing.allocation;\n+\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RoutingChangesObserver;\n+import org.elasticsearch.cluster.routing.RoutingNodes;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.gateway.GatewayAllocator;\n+\n+import java.util.List;\n+\n+/**\n+ * Searches for, and allocates, shards for which there is an existing on-disk copy somewhere in the cluster. The default implementation is\n+ * {@link GatewayAllocator}, but plugins can supply their own implementations too.\n+ */\n+public interface ExistingShardsAllocator {\n+\n+    /**\n+     * Allows plugins to override how we allocate shards that may already exist on disk in the cluster.\n+     */\n+    Setting<String> EXISTING_SHARDS_ALLOCATOR_SETTING = Setting.simpleString(\n+        \"index.allocation.existing_shards_allocator\", GatewayAllocator.ALLOCATOR_NAME,\n+        Setting.Property.IndexScope, Setting.Property.PrivateIndex);\n+\n+    /**\n+     * Called before starting a round of allocation, allowing the allocator to invalidate some caches if appropriate.\n+     */\n+    void beforeAllocation(RoutingAllocation allocation);\n+", "originalCommit": "4b8888c0311d0bfc886baa7ae0349b61749d103e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0NjIxMA==", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r388746210", "bodyText": "nit: swap argument order to make it the same as in ExistingShardsAllocator:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void allocateUnassigned(RoutingAllocation allocation, ShardRouting shardRouting,\n          \n          \n            \n                public void allocateUnassigned(ShardRouting shardRouting, RoutingAllocation allocation,", "author": "henningandersen", "createdAt": "2020-03-06T07:21:21Z", "path": "server/src/main/java/org/elasticsearch/gateway/BaseGatewayShardAllocator.java", "diffHunk": "@@ -45,40 +45,38 @@\n     protected final Logger logger = LogManager.getLogger(this.getClass());\n \n     /**\n-     * Allocate unassigned shards to nodes (if any) where valid copies of the shard already exist.\n+     * Allocate an unassigned shard to nodes (if any) where valid copies of the shard already exist.\n      * It is up to the individual implementations of {@link #makeAllocationDecision(ShardRouting, RoutingAllocation, Logger)}\n      * to make decisions on assigning shards to nodes.\n      *\n      * @param allocation the allocation state container object\n+     * @param shardRouting the shard to allocate\n+     * @param unassignedAllocationHandler handles the allocation of the current shard\n      */\n-    public void allocateUnassigned(RoutingAllocation allocation) {\n-        final RoutingNodes routingNodes = allocation.routingNodes();\n-        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = routingNodes.unassigned().iterator();\n-        while (unassignedIterator.hasNext()) {\n-            final ShardRouting shard = unassignedIterator.next();\n-            final AllocateUnassignedDecision allocateUnassignedDecision = makeAllocationDecision(shard, allocation, logger);\n+    public void allocateUnassigned(RoutingAllocation allocation, ShardRouting shardRouting,", "originalCommit": "4b8888c0311d0bfc886baa7ae0349b61749d103e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ac303eb1587a24c565f05808845c7a7a93820ac8", "url": "https://github.com/elastic/elasticsearch/commit/ac303eb1587a24c565f05808845c7a7a93820ac8", "message": "Merge branch 'feature/searchable-snapshots' into 2020-02-19-pluggable-allocator-for-existing-shards", "committedDate": "2020-03-11T10:03:58Z", "type": "commit"}, {"oid": "01c9b332f2ae5da3ffe904a60b88736a1c8075a0", "url": "https://github.com/elastic/elasticsearch/commit/01c9b332f2ae5da3ffe904a60b88736a1c8075a0", "message": "Include plugin class name in error", "committedDate": "2020-03-11T10:05:34Z", "type": "commit"}, {"oid": "1857794ee90db345ad630389bccc6dc679d84299", "url": "https://github.com/elastic/elasticsearch/commit/1857794ee90db345ad630389bccc6dc679d84299", "message": "Whitespace", "committedDate": "2020-03-11T10:05:56Z", "type": "commit"}, {"oid": "41fa9c6d042bb48c4588b28e14730bde02647e8e", "url": "https://github.com/elastic/elasticsearch/commit/41fa9c6d042bb48c4588b28e14730bde02647e8e", "message": "Reorder params", "committedDate": "2020-03-11T10:15:21Z", "type": "commit"}, {"oid": "4c9d3ee5ec37bde13a62774d11f715ba69e8d5bf", "url": "https://github.com/elastic/elasticsearch/commit/4c9d3ee5ec37bde13a62774d11f715ba69e8d5bf", "message": "Merge branch 'feature/searchable-snapshots' into 2020-02-19-pluggable-allocator-for-existing-shards", "committedDate": "2020-03-11T10:32:38Z", "type": "commit"}, {"oid": "05b690c52472b3246798326088784ae3a91e4b79", "url": "https://github.com/elastic/elasticsearch/commit/05b690c52472b3246798326088784ae3a91e4b79", "message": "Merge branch 'feature/searchable-snapshots' into 2020-02-19-pluggable-allocator-for-existing-shards", "committedDate": "2020-03-11T12:48:29Z", "type": "commit"}]}