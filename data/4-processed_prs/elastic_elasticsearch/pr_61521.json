{"pr_number": 61521, "pr_title": "[ML] refactor ml job node selection into its own class", "pr_createdAt": "2020-08-25T12:42:04Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/61521", "timeline": [{"oid": "7b7042de59444e539c6f67640a1a1728659b495b", "url": "https://github.com/elastic/elasticsearch/commit/7b7042de59444e539c6f67640a1a1728659b495b", "message": "[ML] refactor ml job node selection into its own class", "committedDate": "2020-08-25T12:39:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA2MjQzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/61521#discussion_r477062439", "bodyText": "Should this class have its own unit tests now that it's separated?", "author": "przemekwitek", "createdAt": "2020-08-26T06:27:05Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/NodeLoadDetector.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.job;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.persistent.PersistentTasksCustomMetadata;\n+import org.elasticsearch.xpack.core.ml.MlTasks;\n+import org.elasticsearch.xpack.core.ml.action.OpenJobAction;\n+import org.elasticsearch.xpack.core.ml.action.StartDataFrameAnalyticsAction;\n+import org.elasticsearch.xpack.core.ml.dataframe.DataFrameAnalyticsState;\n+import org.elasticsearch.xpack.core.ml.job.config.JobState;\n+import org.elasticsearch.xpack.ml.MachineLearning;\n+import org.elasticsearch.xpack.ml.process.MlMemoryTracker;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+public class NodeLoadDetector {", "originalCommit": "7b7042de59444e539c6f67640a1a1728659b495b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIzNzA3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61521#discussion_r477237079", "bodyText": "I am not sure. The coverage is already really good in the tests that use the detector.", "author": "benwtrent", "createdAt": "2020-08-26T11:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA2MjQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQxNTU1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61521#discussion_r478415555", "bodyText": "Anyway, since you are adding a new class, I would also add a unit test class. Even if it has one very simple test case.\nThe reasoning is that when the class grows (and you expect it to grow with autoscaling logic for example), there will already be a place to put more tests into.", "author": "przemekwitek", "createdAt": "2020-08-27T13:23:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA2MjQzOQ=="}], "type": "inlineReview"}, {"oid": "ce6f7a2b7316d1af98c347e81b1d148be28be8d5", "url": "https://github.com/elastic/elasticsearch/commit/ce6f7a2b7316d1af98c347e81b1d148be28be8d5", "message": "adding nodeload tests", "committedDate": "2020-08-27T12:48:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzNDk2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61521#discussion_r478334961", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * @return Returns a comma delimited string of errors if any where encountered.\n          \n          \n            \n                     * @return Returns a comma delimited string of errors if any were encountered.", "author": "przemekwitek", "createdAt": "2020-08-27T11:05:17Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/NodeLoadDetector.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.job;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.persistent.PersistentTasksCustomMetadata;\n+import org.elasticsearch.xpack.core.ml.MlTasks;\n+import org.elasticsearch.xpack.core.ml.action.OpenJobAction;\n+import org.elasticsearch.xpack.core.ml.action.StartDataFrameAnalyticsAction;\n+import org.elasticsearch.xpack.core.ml.dataframe.DataFrameAnalyticsState;\n+import org.elasticsearch.xpack.core.ml.job.config.JobState;\n+import org.elasticsearch.xpack.ml.MachineLearning;\n+import org.elasticsearch.xpack.ml.process.MlMemoryTracker;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+public class NodeLoadDetector {\n+    private static final Logger logger = LogManager.getLogger(NodeLoadDetector.class);\n+\n+    private final MlMemoryTracker mlMemoryTracker;\n+\n+    public NodeLoadDetector(MlMemoryTracker memoryTracker) {\n+        this.mlMemoryTracker = memoryTracker;\n+    }\n+\n+    public MlMemoryTracker getMlMemoryTracker() {\n+        return mlMemoryTracker;\n+    }\n+\n+    public NodeLoad detectNodeLoad(ClusterState clusterState,\n+                                   boolean allNodesHaveDynamicMaxWorkers,\n+                                   DiscoveryNode node,\n+                                   int dynamicMaxOpenJobs,\n+                                   int maxMachineMemoryPercent,\n+                                   boolean isMemoryTrackerRecentlyRefreshed) {\n+        PersistentTasksCustomMetadata persistentTasks = clusterState.getMetadata().custom(PersistentTasksCustomMetadata.TYPE);\n+        Map<String, String> nodeAttributes = node.getAttributes();\n+        List<String> errors = new ArrayList<>();\n+        int maxNumberOfOpenJobs = dynamicMaxOpenJobs;\n+        // TODO: remove this in 8.0.0\n+        if (allNodesHaveDynamicMaxWorkers == false) {\n+            String maxNumberOfOpenJobsStr = nodeAttributes.get(MachineLearning.MAX_OPEN_JOBS_NODE_ATTR);\n+            try {\n+                maxNumberOfOpenJobs = Integer.parseInt(maxNumberOfOpenJobsStr);\n+            } catch (NumberFormatException e) {\n+                errors.add(MachineLearning.MAX_OPEN_JOBS_NODE_ATTR + \" attribute [\" + maxNumberOfOpenJobsStr + \"] is not an integer\");\n+                maxNumberOfOpenJobs = -1;\n+            }\n+        }\n+        String machineMemoryStr = nodeAttributes.get(MachineLearning.MACHINE_MEMORY_NODE_ATTR);\n+        long machineMemory = -1;\n+        try {\n+            machineMemory = Long.parseLong(machineMemoryStr);\n+        } catch (NumberFormatException e) {\n+            errors.add(MachineLearning.MACHINE_MEMORY_NODE_ATTR + \" attribute [\" + machineMemoryStr + \"] is not a long\");\n+        }\n+        long maxMlMemory = machineMemory * maxMachineMemoryPercent / 100;\n+\n+        NodeLoad nodeLoad = new NodeLoad(node.getId(), maxMlMemory, maxNumberOfOpenJobs, isMemoryTrackerRecentlyRefreshed);\n+        if (errors.isEmpty() == false) {\n+            nodeLoad.error = Strings.collectionToCommaDelimitedString(errors);\n+            return nodeLoad;\n+        }\n+        updateLoadGivenTasks(nodeLoad, persistentTasks);\n+        return nodeLoad;\n+    }\n+\n+    private void updateLoadGivenTasks(NodeLoad nodeLoad, PersistentTasksCustomMetadata persistentTasks) {\n+        if (persistentTasks != null) {\n+            // find all the anomaly detector job tasks assigned to this node\n+            Collection<PersistentTasksCustomMetadata.PersistentTask<?>> assignedAnomalyDetectorTasks = persistentTasks.findTasks(\n+                MlTasks.JOB_TASK_NAME, task -> nodeLoad.getNodeId().equals(task.getExecutorNode()));\n+            for (PersistentTasksCustomMetadata.PersistentTask<?> assignedTask : assignedAnomalyDetectorTasks) {\n+                JobState jobState = MlTasks.getJobStateModifiedForReassignments(assignedTask);\n+                if (jobState.isAnyOf(JobState.CLOSED, JobState.FAILED) == false) {\n+                    // Don't count CLOSED or FAILED jobs, as they don't consume native memory\n+                    ++nodeLoad.numAssignedJobs;\n+                    if (jobState == JobState.OPENING) {\n+                        ++nodeLoad.numAllocatingJobs;\n+                    }\n+                    OpenJobAction.JobParams params = (OpenJobAction.JobParams) assignedTask.getParams();\n+                    Long jobMemoryRequirement = mlMemoryTracker.getAnomalyDetectorJobMemoryRequirement(params.getJobId());\n+                    if (jobMemoryRequirement == null) {\n+                        nodeLoad.useMemory = false;\n+                        logger.debug(() -> new ParameterizedMessage(\n+                            \"[{}] memory requirement was not available. Calculating load by number of assigned jobs.\",\n+                            params.getJobId()\n+                        ));\n+                    } else {\n+                        nodeLoad.assignedJobMemory += jobMemoryRequirement;\n+                    }\n+                }\n+            }\n+            // find all the data frame analytics job tasks assigned to this node\n+            Collection<PersistentTasksCustomMetadata.PersistentTask<?>> assignedAnalyticsTasks = persistentTasks.findTasks(\n+                MlTasks.DATA_FRAME_ANALYTICS_TASK_NAME, task -> nodeLoad.getNodeId().equals(task.getExecutorNode()));\n+            for (PersistentTasksCustomMetadata.PersistentTask<?> assignedTask : assignedAnalyticsTasks) {\n+                DataFrameAnalyticsState dataFrameAnalyticsState = MlTasks.getDataFrameAnalyticsState(assignedTask);\n+\n+                // Don't count stopped and failed df-analytics tasks as they don't consume native memory\n+                if (dataFrameAnalyticsState.isAnyOf(DataFrameAnalyticsState.STOPPED, DataFrameAnalyticsState.FAILED) == false) {\n+                    // The native process is only running in the ANALYZING and STOPPING states, but in the STARTED\n+                    // and REINDEXING states we're committed to using the memory soon, so account for it here\n+                    ++nodeLoad.numAssignedJobs;\n+                    StartDataFrameAnalyticsAction.TaskParams params =\n+                        (StartDataFrameAnalyticsAction.TaskParams) assignedTask.getParams();\n+                    Long jobMemoryRequirement = mlMemoryTracker.getDataFrameAnalyticsJobMemoryRequirement(params.getId());\n+                    if (jobMemoryRequirement == null) {\n+                        nodeLoad.useMemory = false;\n+                        logger.debug(() -> new ParameterizedMessage(\n+                            \"[{}] memory requirement was not available. Calculating load by number of assigned jobs.\",\n+                            params.getId()\n+                        ));\n+                    } else {\n+                        nodeLoad.assignedJobMemory += jobMemoryRequirement;\n+                    }\n+                }\n+            }\n+            // if any jobs are running then the native code will be loaded, but shared between all jobs,\n+            // so increase the total memory usage of the assigned jobs to account for this\n+            if (nodeLoad.numAssignedJobs > 0) {\n+                nodeLoad.assignedJobMemory += MachineLearning.NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes();\n+            }\n+        }\n+    }\n+\n+\n+    public static class NodeLoad {\n+        private final long maxMemory;\n+        private final int maxJobs;\n+        private final String nodeId;\n+        private boolean useMemory;\n+        private String error;\n+        private long numAssignedJobs;\n+        private long assignedJobMemory;\n+        private long numAllocatingJobs;\n+\n+        private NodeLoad(String nodeId, long maxMemory, int maxJobs, boolean useMemory) {\n+            this.maxJobs = maxJobs;\n+            this.maxMemory = maxMemory;\n+            this.nodeId = nodeId;\n+            this.useMemory = useMemory;\n+        }\n+\n+        /**\n+         * @return The total number of assigned jobs\n+         */\n+        public long getNumAssignedJobs() {\n+            return numAssignedJobs;\n+        }\n+\n+        /**\n+         * @return The total memory in bytes used by the assigned jobs.\n+         */\n+        public long getAssignedJobMemory() {\n+            return assignedJobMemory;\n+        }\n+\n+        /**\n+         * @return The maximum memory on this node for jobs\n+         */\n+        public long getMaxMlMemory() {\n+            return maxMemory;\n+        }\n+\n+        /**\n+         * @return The maximum number of jobs allowed on the node\n+         */\n+        public int getMaxJobs() {\n+            return maxJobs;\n+        }\n+\n+        /**\n+         * @return returns `true` if the assignedJobMemory number is accurate\n+         */\n+        public boolean isUseMemory() {\n+            return useMemory;\n+        }\n+\n+        /**\n+         * @return The node ID\n+         */\n+        public String getNodeId() {\n+            return nodeId;\n+        }\n+\n+        /**\n+         * @return Returns a comma delimited string of errors if any where encountered.", "originalCommit": "7b7042de59444e539c6f67640a1a1728659b495b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2b0b7c92599c33a34a0b7e159fe426e54ee4bea4", "url": "https://github.com/elastic/elasticsearch/commit/2b0b7c92599c33a34a0b7e159fe426e54ee4bea4", "message": "Update x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/NodeLoadDetector.java\n\nCo-authored-by: Przemys\u0142aw Witek <przemyslaw.witek@elastic.co>", "committedDate": "2020-08-27T13:39:17Z", "type": "commit"}, {"oid": "9e9bc47162b3bf4061cd14d0ac1b13c7b8021b8b", "url": "https://github.com/elastic/elasticsearch/commit/9e9bc47162b3bf4061cd14d0ac1b13c7b8021b8b", "message": "Merge branch 'master' into feature/ml-job-node-selector-refactor", "committedDate": "2020-08-27T14:09:10Z", "type": "commit"}]}