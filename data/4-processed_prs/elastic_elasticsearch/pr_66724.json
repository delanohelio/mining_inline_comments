{"pr_number": 66724, "pr_title": "Build complex automatons more efficiently", "pr_createdAt": "2020-12-22T04:31:31Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/66724", "timeline": [{"oid": "6bb4e52c8b319d2ec9ab8543cf2a8b260ac1ea08", "url": "https://github.com/elastic/elasticsearch/commit/6bb4e52c8b319d2ec9ab8543cf2a8b260ac1ea08", "message": "Build complex automatons more efficiently\n\nThis change substantially reduces the CPU and Heap usage of\nStringMatcher when processing large complex patterns.\n\nThe improvement is achieved by switching the order in which we\nperform concatenation and union for common styles of wildcard patterns.\n\nGiven a set of wildcard strings:\n- \"*-logs-*\"\n- \"*-metrics-*\"\n- \"web-*-prod-*\"\n- \"web-*-staging-*\"\n\nThe old implementation would perform steps roughly like:\n\n    minimize {\n        union {\n            concatenate { MATCH_ANY, \"-logs-\", MATCH_ANY }\n            concatenate { MATCH_ANY, \"-metrics-\", MATCH_ANY }\n            concatenate { \"web-\", MATCH_ANY, \"prod-\", MATCH_ANY }\n            concatenate { \"web-\", MATCH_ANY, \"staging-\", MATCH_ANY }\n        }\n    }\n\nThe outer minimize would require determinizing the automaton, which\nwas highly inefficient\n\nThe new implementation is:\n\n    minimize {\n        union {\n            concatenate {\n                MATCH_ANY ,\n                minimize {\n                    union { \"-logs-\", \"-metrics\"- }\n                }\n                MATCH_ANY\n            }\n            concatenate {\n                minimize {\n                    union {\n                        concatenate { \"web-\", MATCH_ANY, \"prod-\" }\n                        concatenate { \"web-\", MATCH_ANY, \"staging-\" }\n                    }\n                }\n                MATCH_ANY\n            }\n        }\n    }\n\nBy performing a union of the inner strings before concatenating the\nMATCH_ANY (\"*\") the time & heap space spent on determinizing the\nautomaton is greatly reduced.", "committedDate": "2020-12-22T04:25:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyMzU0OA==", "url": "https://github.com/elastic/elasticsearch/pull/66724#discussion_r548323548", "bodyText": "Shoud we guard these with a check for p.length() == 0?", "author": "ywangd", "createdAt": "2020-12-23T23:52:23Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/Automatons.java", "diffHunk": "@@ -84,10 +88,74 @@ public static Automaton patterns(Collection<String> patterns) {\n     }\n \n     private static Automaton buildAutomaton(Collection<String> patterns) {\n-        List<Automaton> automata = new ArrayList<>(patterns.size());\n-        for (String pattern : patterns) {\n-            final Automaton patternAutomaton = pattern(pattern);\n-            automata.add(patternAutomaton);\n+        if (patterns.size() == 1) {\n+            return minimize(pattern(patterns.iterator().next()));\n+        }\n+\n+        final Function<Collection<String>, Automaton> build = strings -> {\n+            List<Automaton> automata = new ArrayList<>(strings.size());\n+            for (String pattern : strings) {\n+                final Automaton patternAutomaton = pattern(pattern);\n+                automata.add(patternAutomaton);\n+            }\n+            return unionAndMinimize(automata);\n+        };\n+\n+        // We originally just compiled each automaton separately and then unioned them all.\n+        // However, that approach can be quite slow, and very memory intensive.\n+        // It is far more efficient if\n+        //   1. we strip leading/trailing \"*\"\n+        //   2. union the automaton produced from the remaining text\n+        //   3. append/prepend MatchAnyString automatons as appropriate\n+        // That is:\n+        //  - `MATCH_ALL + (bullseye|daredevil) + MATCH_ALL`\n+        //  can be determinized more efficiently than\n+        //  - `(MATCH_ALL + bullseye + MATCH_ALL)|(MATCH_ALL + daredevil + MATCH_ALL)`\n+\n+        final Set<String> prefix = new HashSet<>();\n+        final Set<String> infix = new HashSet<>();\n+        final Set<String> suffix = new HashSet<>();\n+        final Set<String> misc = new HashSet<>();\n+\n+        for (String p : patterns) {\n+            final char first = p.charAt(0);\n+            final char last = p.charAt(p.length() - 1);", "originalCommit": "6bb4e52c8b319d2ec9ab8543cf2a8b260ac1ea08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyNTQyNw==", "url": "https://github.com/elastic/elasticsearch/pull/66724#discussion_r548325427", "bodyText": "It is possible that the pattern is **. As such the infix is an empty string and can be skipped. But as discussed, it is probably better handled as part of compacting all consecutive *, which can be done in a separate PR.", "author": "ywangd", "createdAt": "2020-12-24T00:02:35Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/Automatons.java", "diffHunk": "@@ -84,10 +88,74 @@ public static Automaton patterns(Collection<String> patterns) {\n     }\n \n     private static Automaton buildAutomaton(Collection<String> patterns) {\n-        List<Automaton> automata = new ArrayList<>(patterns.size());\n-        for (String pattern : patterns) {\n-            final Automaton patternAutomaton = pattern(pattern);\n-            automata.add(patternAutomaton);\n+        if (patterns.size() == 1) {\n+            return minimize(pattern(patterns.iterator().next()));\n+        }\n+\n+        final Function<Collection<String>, Automaton> build = strings -> {\n+            List<Automaton> automata = new ArrayList<>(strings.size());\n+            for (String pattern : strings) {\n+                final Automaton patternAutomaton = pattern(pattern);\n+                automata.add(patternAutomaton);\n+            }\n+            return unionAndMinimize(automata);\n+        };\n+\n+        // We originally just compiled each automaton separately and then unioned them all.\n+        // However, that approach can be quite slow, and very memory intensive.\n+        // It is far more efficient if\n+        //   1. we strip leading/trailing \"*\"\n+        //   2. union the automaton produced from the remaining text\n+        //   3. append/prepend MatchAnyString automatons as appropriate\n+        // That is:\n+        //  - `MATCH_ALL + (bullseye|daredevil) + MATCH_ALL`\n+        //  can be determinized more efficiently than\n+        //  - `(MATCH_ALL + bullseye + MATCH_ALL)|(MATCH_ALL + daredevil + MATCH_ALL)`\n+\n+        final Set<String> prefix = new HashSet<>();\n+        final Set<String> infix = new HashSet<>();\n+        final Set<String> suffix = new HashSet<>();\n+        final Set<String> misc = new HashSet<>();\n+\n+        for (String p : patterns) {\n+            final char first = p.charAt(0);\n+            final char last = p.charAt(p.length() - 1);\n+            if (p.length() <= 1 || first == '/') {\n+                // Single character strings (like \"x\" or \"*\") or regex (\"/something/\")\n+                misc.add(p);\n+            } else if (first == '*') {\n+                if (last == '*') {\n+                    // *something*\n+                    infix.add(p.substring(1, p.length() - 1));", "originalCommit": "6bb4e52c8b319d2ec9ab8543cf2a8b260ac1ea08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyNjA3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/66724#discussion_r548326077", "bodyText": "I think the pattern like something* should also reach here and should be part of the comment.", "author": "ywangd", "createdAt": "2020-12-24T00:05:57Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/Automatons.java", "diffHunk": "@@ -84,10 +88,74 @@ public static Automaton patterns(Collection<String> patterns) {\n     }\n \n     private static Automaton buildAutomaton(Collection<String> patterns) {\n-        List<Automaton> automata = new ArrayList<>(patterns.size());\n-        for (String pattern : patterns) {\n-            final Automaton patternAutomaton = pattern(pattern);\n-            automata.add(patternAutomaton);\n+        if (patterns.size() == 1) {\n+            return minimize(pattern(patterns.iterator().next()));\n+        }\n+\n+        final Function<Collection<String>, Automaton> build = strings -> {\n+            List<Automaton> automata = new ArrayList<>(strings.size());\n+            for (String pattern : strings) {\n+                final Automaton patternAutomaton = pattern(pattern);\n+                automata.add(patternAutomaton);\n+            }\n+            return unionAndMinimize(automata);\n+        };\n+\n+        // We originally just compiled each automaton separately and then unioned them all.\n+        // However, that approach can be quite slow, and very memory intensive.\n+        // It is far more efficient if\n+        //   1. we strip leading/trailing \"*\"\n+        //   2. union the automaton produced from the remaining text\n+        //   3. append/prepend MatchAnyString automatons as appropriate\n+        // That is:\n+        //  - `MATCH_ALL + (bullseye|daredevil) + MATCH_ALL`\n+        //  can be determinized more efficiently than\n+        //  - `(MATCH_ALL + bullseye + MATCH_ALL)|(MATCH_ALL + daredevil + MATCH_ALL)`\n+\n+        final Set<String> prefix = new HashSet<>();\n+        final Set<String> infix = new HashSet<>();\n+        final Set<String> suffix = new HashSet<>();\n+        final Set<String> misc = new HashSet<>();\n+\n+        for (String p : patterns) {\n+            final char first = p.charAt(0);\n+            final char last = p.charAt(p.length() - 1);\n+            if (p.length() <= 1 || first == '/') {\n+                // Single character strings (like \"x\" or \"*\") or regex (\"/something/\")\n+                misc.add(p);\n+            } else if (first == '*') {\n+                if (last == '*') {\n+                    // *something*\n+                    infix.add(p.substring(1, p.length() - 1));\n+                } else {\n+                    // *something\n+                    suffix.add(p.substring(1));\n+                }\n+            } else if (last == '*' && p.indexOf('*') != p.length() - 1) {\n+                // some*thing*\n+                // For simple prefix patterns (\"something*\") it's more efficient to do a single pass\n+                // Lucene handles the shared trailing '*' on an accept state well,\n+                // and performing 2 minimizes (on for the union of strings, then on again after concatenating MATCH_ANY) is slower.\n+                // But, that's not true if the string has an embedded '*' in it - in that case, we should handle them in this special way.\n+                prefix.add(p.substring(0, p.length() - 1));\n+            } else {\n+                // some*thing / some?thing / etc", "originalCommit": "6bb4e52c8b319d2ec9ab8543cf2a8b260ac1ea08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyNjQ5MA==", "url": "https://github.com/elastic/elasticsearch/pull/66724#discussion_r548326490", "bodyText": "This sentence reads weird to me. Should it be something like ... (one for the union of strings, and another one after ...)", "author": "ywangd", "createdAt": "2020-12-24T00:07:57Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/Automatons.java", "diffHunk": "@@ -84,10 +88,74 @@ public static Automaton patterns(Collection<String> patterns) {\n     }\n \n     private static Automaton buildAutomaton(Collection<String> patterns) {\n-        List<Automaton> automata = new ArrayList<>(patterns.size());\n-        for (String pattern : patterns) {\n-            final Automaton patternAutomaton = pattern(pattern);\n-            automata.add(patternAutomaton);\n+        if (patterns.size() == 1) {\n+            return minimize(pattern(patterns.iterator().next()));\n+        }\n+\n+        final Function<Collection<String>, Automaton> build = strings -> {\n+            List<Automaton> automata = new ArrayList<>(strings.size());\n+            for (String pattern : strings) {\n+                final Automaton patternAutomaton = pattern(pattern);\n+                automata.add(patternAutomaton);\n+            }\n+            return unionAndMinimize(automata);\n+        };\n+\n+        // We originally just compiled each automaton separately and then unioned them all.\n+        // However, that approach can be quite slow, and very memory intensive.\n+        // It is far more efficient if\n+        //   1. we strip leading/trailing \"*\"\n+        //   2. union the automaton produced from the remaining text\n+        //   3. append/prepend MatchAnyString automatons as appropriate\n+        // That is:\n+        //  - `MATCH_ALL + (bullseye|daredevil) + MATCH_ALL`\n+        //  can be determinized more efficiently than\n+        //  - `(MATCH_ALL + bullseye + MATCH_ALL)|(MATCH_ALL + daredevil + MATCH_ALL)`\n+\n+        final Set<String> prefix = new HashSet<>();\n+        final Set<String> infix = new HashSet<>();\n+        final Set<String> suffix = new HashSet<>();\n+        final Set<String> misc = new HashSet<>();\n+\n+        for (String p : patterns) {\n+            final char first = p.charAt(0);\n+            final char last = p.charAt(p.length() - 1);\n+            if (p.length() <= 1 || first == '/') {\n+                // Single character strings (like \"x\" or \"*\") or regex (\"/something/\")\n+                misc.add(p);\n+            } else if (first == '*') {\n+                if (last == '*') {\n+                    // *something*\n+                    infix.add(p.substring(1, p.length() - 1));\n+                } else {\n+                    // *something\n+                    suffix.add(p.substring(1));\n+                }\n+            } else if (last == '*' && p.indexOf('*') != p.length() - 1) {\n+                // some*thing*\n+                // For simple prefix patterns (\"something*\") it's more efficient to do a single pass\n+                // Lucene handles the shared trailing '*' on an accept state well,\n+                // and performing 2 minimizes (on for the union of strings, then on again after concatenating MATCH_ANY) is slower.", "originalCommit": "6bb4e52c8b319d2ec9ab8543cf2a8b260ac1ea08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyNjk1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66724#discussion_r548326952", "bodyText": "Nit: I'd prefer to name this variable with a noun, something like buildFunc.", "author": "ywangd", "createdAt": "2020-12-24T00:10:14Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/Automatons.java", "diffHunk": "@@ -84,10 +88,74 @@ public static Automaton patterns(Collection<String> patterns) {\n     }\n \n     private static Automaton buildAutomaton(Collection<String> patterns) {\n-        List<Automaton> automata = new ArrayList<>(patterns.size());\n-        for (String pattern : patterns) {\n-            final Automaton patternAutomaton = pattern(pattern);\n-            automata.add(patternAutomaton);\n+        if (patterns.size() == 1) {\n+            return minimize(pattern(patterns.iterator().next()));\n+        }\n+\n+        final Function<Collection<String>, Automaton> build = strings -> {", "originalCommit": "6bb4e52c8b319d2ec9ab8543cf2a8b260ac1ea08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b9d6735202acb64e951c470fb7cb4c7e84b7de80", "url": "https://github.com/elastic/elasticsearch/commit/b9d6735202acb64e951c470fb7cb4c7e84b7de80", "message": "Merge branch 'master' into feature/string-matcher-infix-perf", "committedDate": "2020-12-29T23:20:00Z", "type": "commit"}, {"oid": "f13045f913654685064e7df411c3c878f78e1d34", "url": "https://github.com/elastic/elasticsearch/commit/f13045f913654685064e7df411c3c878f78e1d34", "message": "Address feedback", "committedDate": "2020-12-29T23:47:46Z", "type": "commit"}, {"oid": "414b8c55aa85df65dec774393d48c7a46dce5e93", "url": "https://github.com/elastic/elasticsearch/commit/414b8c55aa85df65dec774393d48c7a46dce5e93", "message": "Merge branch 'master' into feature/string-matcher-infix-perf", "committedDate": "2020-12-30T00:18:05Z", "type": "commit"}]}