{"pr_number": 61590, "pr_title": "Allow metadata fields in the _source", "pr_createdAt": "2020-08-26T15:14:09Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/61590", "timeline": [{"oid": "8a65d1c4bf7fc1e2b31400d72f980c331dd1f5b7", "url": "https://github.com/elastic/elasticsearch/commit/8a65d1c4bf7fc1e2b31400d72f980c331dd1f5b7", "message": "Configurable metadata field mappers in the _source", "committedDate": "2020-08-26T15:00:33Z", "type": "commit"}, {"oid": "d83b67723679cb7900f468a738c7635ef5789620", "url": "https://github.com/elastic/elasticsearch/commit/d83b67723679cb7900f468a738c7635ef5789620", "message": "Changes to support metadata fields in _source\nAdded test testDocumentContainsAllowedMetadataField()", "committedDate": "2020-09-08T16:50:27Z", "type": "commit"}, {"oid": "76f3dc36707ef36d438a3f48b768b14c5c5c13d8", "url": "https://github.com/elastic/elasticsearch/commit/76f3dc36707ef36d438a3f48b768b14c5c5c13d8", "message": "Merge branch 'master' into metadata-source", "committedDate": "2020-09-08T17:06:27Z", "type": "commit"}, {"oid": "4934129da49025b3d3d314efe8d65d922053c9d1", "url": "https://github.com/elastic/elasticsearch/commit/4934129da49025b3d3d314efe8d65d922053c9d1", "message": "Merged DocumentParserTests from master\nFixed broken tests", "committedDate": "2020-09-09T12:13:47Z", "type": "commit"}, {"oid": "a168a1be2bea0f0a13765c93b7ebc19626559c76", "url": "https://github.com/elastic/elasticsearch/commit/a168a1be2bea0f0a13765c93b7ebc19626559c76", "message": "Merge branch 'master' into metadata-source", "committedDate": "2020-09-09T12:14:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3MjY5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61590#discussion_r485872696", "bodyText": "Maybe we should throw a parsing error if the token isn't a string instead of silently allowing it?", "author": "jtibshirani", "createdAt": "2020-09-09T19:43:33Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/MockMetadataMapperPlugin.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.StringField;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.plugins.MapperPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Mapper plugin providing a mock metadata field mapper implementation that supports setting its value\n+ * through the document source.\n+ */\n+public class MockMetadataMapperPlugin extends Plugin implements MapperPlugin {\n+\n+    /**\n+     * A mock metadata field mapper that supports being set from the document source.\n+     */\n+    public static class MockMetadataMapper extends MetadataFieldMapper {\n+\n+        static final String CONTENT_TYPE = \"_mock_metadata\";\n+        static final String FIELD_NAME = \"_mock_metadata\";\n+\n+        protected MockMetadataMapper() {\n+            super(new KeywordFieldMapper.KeywordFieldType(FIELD_NAME));\n+        }\n+\n+        @Override\n+        protected void parseCreateField(ParseContext context) throws IOException {\n+            if (context.parser().currentToken() == XContentParser.Token.VALUE_STRING) {\n+                context.doc().add(new StringField(FIELD_NAME, context.parser().text(), Field.Store.YES));\n+            } else {", "originalCommit": "a168a1be2bea0f0a13765c93b7ebc19626559c76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3NjYxNA==", "url": "https://github.com/elastic/elasticsearch/pull/61590#discussion_r485876614", "bodyText": "I'm wondering if we really need this new flag isAllowedInSource. Maybe we could avoid adding a new flag and instead do the following:\n\nFor metadata fields that are not allowed in _source, make sure that MetadataFieldMapper#parse throws an descriptive error.\nMany metadata fields currently have logic in parse that's unrelated to _source parsing. We could make sure to move it into the special methods preParse or postParse.", "author": "jtibshirani", "createdAt": "2020-09-09T19:48:07Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/MetadataFieldMapper.java", "diffHunk": "@@ -45,6 +45,14 @@\n          * @param parserContext context that may be useful to build the field like analyzers\n          */\n         MetadataFieldMapper getDefault(ParserContext parserContext);\n+\n+        /**\n+         *  @return Whether a metadata field can be included in the document _source.\n+         */\n+        default boolean isAllowedInSource() {", "originalCommit": "a168a1be2bea0f0a13765c93b7ebc19626559c76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5MjA5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61590#discussion_r486492097", "bodyText": "@jtibshirani I agree with you that delegating this to MetadataFieldMapper#parse() would be a simpler solution. However I see two caveats:\n\n\nThe approach with isAllowedInSource() method detects that a metadata field is being parsed when parsing the field name. This is early in the parsing process. An  exception is thrown and the field value parsing is skipped.\n\n\nAs you mention, I have seen classes (such as IgnoredFieldMapper and VersionFieldMapper) that override parse() method to do nothing on one hand, while calling super.parse() from preParse()/postParse() methods. This approach is too complicated imho, but I am not sure that refactoring this is very simple. WDYT?", "author": "csoulios", "createdAt": "2020-09-10T16:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3NjYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNjg2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61590#discussion_r486506865", "bodyText": "This is early in the parsing process. An exception is thrown and the field value parsing is skipped.\n\nI don't think we need to optimize performance in this case because it's an error condition (and should be a rare one too).\n\nThis approach is too complicated imho, but I am not sure that refactoring this is very simple.\n\nI agree that the logic is complex/ hard to read! I haven't deeply looked into the refactoring myself -- maybe you could try it out and we can rediscuss the approach if you see a roadblock ?", "author": "jtibshirani", "createdAt": "2020-09-10T17:17:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3NjYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3ODc3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61590#discussion_r485878779", "bodyText": "What's the reasoning for rejecting null and non-leaf values here?", "author": "jtibshirani", "createdAt": "2020-09-09T19:50:38Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java", "diffHunk": "@@ -391,9 +391,21 @@ private static void innerParseObject(ParseContext context, ObjectMapper mapper,\n             if (token == XContentParser.Token.FIELD_NAME) {\n                 currentFieldName = parser.currentName();\n                 paths = splitAndValidatePath(currentFieldName);\n+\n                 if (context.mapperService().isMetadataField(context.path().pathAsText(currentFieldName))) {\n-                    throw new MapperParsingException(\"Field [\" + currentFieldName + \"] is a metadata field and cannot be added inside\"\n-                        + \" a document. Use the index API request parameters.\");\n+                    if (context.mapperService().isFieldAllowedInSource(context.path().pathAsText(currentFieldName))) {\n+                        // If token is a metadata field and is allowed in source, parse its value", "originalCommit": "a168a1be2bea0f0a13765c93b7ebc19626559c76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM5NzgyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/61590#discussion_r486397825", "bodyText": "@jimczi and I had a discussion about the possible use cases we want to cover with this feature in the near future and agreed that for the sake of simplicity we should only accept non-null values (no objects or arrays).\nI don't have any strong opinions and I am happy to revisit this.", "author": "csoulios", "createdAt": "2020-09-10T14:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3ODc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQxMTUzNg==", "url": "https://github.com/elastic/elasticsearch/pull/61590#discussion_r486411536", "bodyText": "I think null should be accepted but non-leaf values seemed more challenging. Now that I re-think about it, it shouldn't be an issue as long as we consume the value from the root (object or not).", "author": "jimczi", "createdAt": "2020-09-10T14:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3ODc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQxMTk0OA==", "url": "https://github.com/elastic/elasticsearch/pull/61590#discussion_r486411948", "bodyText": "So +1 to handle object, arrays and null values and let the metadata field mapper deals with it.", "author": "jimczi", "createdAt": "2020-09-10T14:57:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3ODc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ2MjE0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61590#discussion_r486462149", "bodyText": "Ok, let me work on this again", "author": "csoulios", "createdAt": "2020-09-10T16:06:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3ODc3OQ=="}], "type": "inlineReview"}, {"oid": "2effa2f46e16d7bd1a8f63113d71c39a1b023c2f", "url": "https://github.com/elastic/elasticsearch/commit/2effa2f46e16d7bd1a8f63113d71c39a1b023c2f", "message": "Handle non string values", "committedDate": "2020-09-10T16:11:03Z", "type": "commit"}, {"oid": "1f5aa63dc67bb78a7c34b79df34b6764b954f04d", "url": "https://github.com/elastic/elasticsearch/commit/1f5aa63dc67bb78a7c34b79df34b6764b954f04d", "message": "Allow metadata fields to parse values/objects/arrays/null", "committedDate": "2020-09-16T12:00:57Z", "type": "commit"}, {"oid": "78faca38b4b4e8eb0a40af4d6fc5d60343da36e3", "url": "https://github.com/elastic/elasticsearch/commit/78faca38b4b4e8eb0a40af4d6fc5d60343da36e3", "message": "Removed MetadataFieldMapper.isAllowedInSource() method\n\nDelegated this functionality to MetadataFieldMapper.parse()", "committedDate": "2020-09-16T16:55:17Z", "type": "commit"}, {"oid": "13468659fd9907034c7d82cb4545c880fa6a56f6", "url": "https://github.com/elastic/elasticsearch/commit/13468659fd9907034c7d82cb4545c880fa6a56f6", "message": "Merge branch 'master' into metadata-source", "committedDate": "2020-09-16T17:01:43Z", "type": "commit"}, {"oid": "39d19fe38d438bf5799dde3c5b1ff931e2fc1a1b", "url": "https://github.com/elastic/elasticsearch/commit/39d19fe38d438bf5799dde3c5b1ff931e2fc1a1b", "message": "Fixed bug that caused tests to break", "committedDate": "2020-09-16T19:57:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczMTcyNw==", "url": "https://github.com/elastic/elasticsearch/pull/61590#discussion_r489731727", "bodyText": "Instead of overriding parse here, could we override parseCreateField?\n@Override\nprotected void parseCreateField(ParseContext context) throws IOException {\n    throw new MapperParsingException(\"Field [\" + name() + \"] is a metadata field and cannot be added inside\"\n        + \" a document. Use the index API request parameters.\");\n}\n\nThen we could do the following:\n\nFor meta fields that cannot be specified in _source, move all the relevant logic out of parseCreateField and into preParse or postParse as appropriate.\nRemove the new doParse method, as it's no longer needed.", "author": "jtibshirani", "createdAt": "2020-09-16T20:22:07Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/MetadataFieldMapper.java", "diffHunk": "@@ -153,10 +153,35 @@ public final XContentBuilder toXContent(XContentBuilder builder, Params params)\n         return builder.endObject();\n     }\n \n+    /*\n+     * By default metadata fields cannot be set through the document source and parse() method\n+     * throws an exception. To enable a metadata field to parse the document source, this\n+     * method must be overridden and doParse() should be called.\n+     */\n+    @Override\n+    public void parse(ParseContext context) throws IOException {\n+        throw new MapperParsingException(\"Field [\" + name() + \"] is a metadata field and cannot be added inside\"\n+            + \" a document. Use the index API request parameters.\");\n+    }\n+\n+    /**\n+     * Do the actual parse of the field by calling {@link FieldMapper#parse(ParseContext)}\n+     */\n+    protected void doParse(ParseContext context) throws IOException {\n+        super.parse(context);\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context) throws IOException {", "originalCommit": "39d19fe38d438bf5799dde3c5b1ff931e2fc1a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA3NTUzNg==", "url": "https://github.com/elastic/elasticsearch/pull/61590#discussion_r490075536", "bodyText": "Thanks for pointing this out. I had a hard time thinking a simple and clean way to refactor this part.\nInitially, I tried the approach you suggested, but FieldMapper#parse() does all the exception handling by encapsulating all exceptions thrown by parseCreateField() offering a preview of the parsed value.\n(See \n  \n    \n      elasticsearch/server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java\n    \n    \n         Line 249\n      in\n      9a127ad\n    \n    \n    \n    \n\n        \n          \n           } catch (Exception e) { \n        \n    \n  \n\n)\nThis means that the\n    throw new MapperParsingException(\"Field [\" + name() + \"] is a metadata field and cannot be added inside\"\n        + \" a document. Use the index API request parameters.\");\n\nwill be encapsulated in the following exception:\n     throw new MapperParsingException(\"failed to parse field [{}] of type [{}] in document with id '{}'. \" +\n                \"Preview of field's value: '{}'\", e, fieldType().name(), fieldType().typeName(),\n                context.sourceToParse().id(), valuePreview);\n\nOn the other hand, methods preParse() and postParse() delegate parsing to parse() for the same reason (to handle parsing exception). If we were to move all parsing in those two methods, we would have to replicate exception handling in those methods as well.\nSince all FieldMapper#parse() does is to delegate parsing to parseCreateField() and only do the exception handling, I decided to redirect this functionality in 'MetadataFieldMapper#doParse()and call this method frompreParse()andpostParse()`.", "author": "csoulios", "createdAt": "2020-09-17T08:45:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczMTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0Mjk0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61590#discussion_r490442945", "bodyText": "To me that approach you tried/ I suggested is the cleanest way to go. My reasoning...\n\nThis means that the ... will be encapsulated in the following exception:\n\nThis seems like an okay compromise to me, all the exception information is there so the user can determine the cause. It's a little confusing that we wrap the message, but this should be a rare situation.\n\nOn the other hand, methods preParse() and postParse() delegate parsing to parse() for the same reason (to handle parsing exception).\n\nI think that exception handling code is only really helpful when dealing with incorrect user-supplied values. Since preParse and postParse work with internal data such as context.sourceToParse().id(), it would indicate a serious logic error. So I don't think we'd need the same general exception handling strategy where we create a nice user-facing message.", "author": "jtibshirani", "createdAt": "2020-09-17T17:41:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczMTcyNw=="}], "type": "inlineReview"}, {"oid": "f0bb9578d911b0ad4c80a755e9983904082eaa74", "url": "https://github.com/elastic/elasticsearch/commit/f0bb9578d911b0ad4c80a755e9983904082eaa74", "message": "Cleanup parsing for existing metadata fields", "committedDate": "2020-09-17T15:41:05Z", "type": "commit"}, {"oid": "a734ea888118bab84e2aa8af25ffd96eb4022a78", "url": "https://github.com/elastic/elasticsearch/commit/a734ea888118bab84e2aa8af25ffd96eb4022a78", "message": "Cleanup parsing for existing metadata fields", "committedDate": "2020-09-17T18:20:54Z", "type": "commit"}, {"oid": "b8b3a9d4329ccadfa7332922047d6f205c0d7ccb", "url": "https://github.com/elastic/elasticsearch/commit/b8b3a9d4329ccadfa7332922047d6f205c0d7ccb", "message": "Remove doParse() method", "committedDate": "2020-09-17T19:07:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUxMTY4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61590#discussion_r490511683", "bodyText": "I just noticed we're doing a linear scan through all the metadata mappers. Maybe we should make sure to store them as a map from name -> mapper to avoid this overhead?", "author": "jtibshirani", "createdAt": "2020-09-17T19:34:15Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java", "diffHunk": "@@ -881,7 +878,16 @@ private static void parseCopy(String field, ParseContext context) throws IOExcep\n     }\n \n     // looks up a child mapper, but takes into account field names that expand to objects\n-    private static Mapper getMapper(ObjectMapper objectMapper, String fieldName, String[] subfields) {\n+    private static Mapper getMapper(final ParseContext context, ObjectMapper objectMapper, String fieldName, String[] subfields) {\n+        String fieldPath = context.path().pathAsText(fieldName);\n+        if (context.mapperService().isMetadataField(fieldPath)) {\n+            for (MetadataFieldMapper metadataFieldMapper : context.docMapper().mapping().getMetadataMappers()) {", "originalCommit": "b8b3a9d4329ccadfa7332922047d6f205c0d7ccb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUxOTYxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61590#discussion_r490519611", "bodyText": "You are right. I had this point in mind for improvement. I just saw that linear scan happens at:\n\n  \n    \n      elasticsearch/server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java\n    \n    \n         Line 101\n      in\n      b8b3a9d\n    \n    \n    \n    \n\n        \n          \n           for (MetadataFieldMapper metadataMapper : metadataFieldsMappers) { \n        \n    \n  \n\n\nI understand that pre/postParse() internalParseDocument() is called once per document, while the linear scan in getMapper() is executed once per metadata field.\nI will fix this asap!", "author": "csoulios", "createdAt": "2020-09-17T19:46:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUxMTY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUzMjQ0OA==", "url": "https://github.com/elastic/elasticsearch/pull/61590#discussion_r490532448", "bodyText": "Fixed this last bit.  Can  you please  have one last look?\nThank you for your patience and excellent guidance.", "author": "csoulios", "createdAt": "2020-09-17T20:09:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUxMTY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU1NzY2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61590#discussion_r490557661", "bodyText": "The change makes sense to me.\nIt feels redundant that we store an array of metadata mappers, a map from class -> mapper, and a map from name -> mapper. This could be simplified, but we don't necessarily need to do it in this PR.", "author": "jtibshirani", "createdAt": "2020-09-17T20:57:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUxMTY4Mw=="}], "type": "inlineReview"}, {"oid": "1560e732c1222c71ad0c2b64b5ae0dbeeb82bf84", "url": "https://github.com/elastic/elasticsearch/commit/1560e732c1222c71ad0c2b64b5ae0dbeeb82bf84", "message": "Fix broken test", "committedDate": "2020-09-17T19:41:06Z", "type": "commit"}, {"oid": "0c962c48fb24a46d42210c1bf98218d0cb278f1d", "url": "https://github.com/elastic/elasticsearch/commit/0c962c48fb24a46d42210c1bf98218d0cb278f1d", "message": "Lookup metadata mapper by name\n\nInstead of linear scan", "committedDate": "2020-09-17T20:02:52Z", "type": "commit"}]}