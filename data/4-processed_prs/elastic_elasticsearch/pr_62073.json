{"pr_number": 62073, "pr_title": "EQL: Propagate key constraints through the query", "pr_createdAt": "2020-09-07T21:17:47Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62073", "timeline": [{"oid": "9cd60368328f15ff7639163f9bfeb4fa22e6054c", "url": "https://github.com/elastic/elasticsearch/commit/9cd60368328f15ff7639163f9bfeb4fa22e6054c", "message": "EQL: Propagate key constraints through the query\n\nSince join keys are common across all queries in a Join/Sequence, any\nconstraint applied on one query needs to be obeyed but all the other\nqueries.\nThis PR enhances the optimizer to propagate such constraints across\nall queries so they get pushed down to the actual generated ES queries.\n\nFix #58937", "committedDate": "2020-09-07T21:13:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcwMzUzNw==", "url": "https://github.com/elastic/elasticsearch/pull/62073#discussion_r484703537", "bodyText": "Is intentional to have operators twice? (before and after constraints rules) If yes, I don't see the reason.", "author": "astefan", "createdAt": "2020-09-08T07:21:28Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "diffHunk": "@@ -91,7 +99,7 @@ public LogicalPlan optimize(LogicalPlan verified) {\n         Batch label = new Batch(\"Set as Optimized\", Limiter.ONCE,\n                 new SetAsOptimized());\n \n-        return Arrays.asList(substitutions, operators, ordering, local, label);\n+        return Arrays.asList(substitutions, operators, constraints, operators, ordering, local, label);", "originalCommit": "9cd60368328f15ff7639163f9bfeb4fa22e6054c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg0NDM2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62073#discussion_r484844363", "bodyText": "Yes, it is because the operators need to be optimized before and after the new filters are added otherwise they'll be missed.\nFor example the filter where a + 1 > 2 + 3 or true will be skipped due to or. Further more there's folding and potentially some range combinations that might apply.\nLikewise, after the new constraint was added, the filters need to be combined and potentially the resulting condition improved:\nwhere a > 1\nwhere a == 0\nThese two filters would be combined into one then another rule would pick it up and make the filter false which would result in the sequence being skipped.", "author": "costin", "createdAt": "2020-09-08T11:27:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcwMzUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc2MTEyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62073#discussion_r484761125", "bodyText": "Do you mind adding a simple explanation in the form of an example to each test? I find it easier to follow.\nFor this one:\nsequence\n [event where a > 1] by a\n [event where timestamp == true] by a", "author": "astefan", "createdAt": "2020-09-08T08:57:22Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/optimizer/OptimizerTests.java", "diffHunk": "@@ -300,4 +330,176 @@ private LogicalPlan defaultPipes(LogicalPlan plan) {\n         assertTrue(plan instanceof OrderBy);\n         return ((OrderBy) plan).child();\n     }\n+\n+    public void testCombineFilters() {\n+        Expression left = new IsNull(EMPTY, Literal.TRUE);\n+        Expression right = new Equals(EMPTY, timestamp(), Literal.TRUE);\n+\n+        Filter filterChild = new Filter(EMPTY, rel(), left);\n+        Filter filterParent = new Filter(EMPTY, filterChild, right);\n+\n+        LogicalPlan result = new Optimizer.PushDownAndCombineFilters().apply(filterParent);\n+\n+        assertEquals(Filter.class, result.getClass());\n+        Expression condition = ((Filter) result).condition();\n+        assertEquals(And.class, condition.getClass());\n+        And and = (And) condition;\n+        assertEquals(left, and.left());\n+        assertEquals(right, and.right());\n+    }\n+\n+    public void testPushDownFilterUnary() {\n+        Expression left = new IsNull(EMPTY, Literal.TRUE);\n+\n+        OrderBy order = new OrderBy(EMPTY, rel(), emptyList());\n+        Filter filter = new Filter(EMPTY, order, left);\n+\n+        LogicalPlan result = new Optimizer.PushDownAndCombineFilters().apply(filter);\n+\n+        assertEquals(OrderBy.class, result.getClass());\n+        OrderBy o = (OrderBy) result;\n+        assertEquals(Filter.class, o.child().getClass());\n+        Filter f = (Filter) o.child();\n+\n+        assertEquals(rel(), f.child());\n+        assertEquals(filter.condition(), f.condition());\n+    }\n+\n+    public void testPushDownFilterDoesNotApplyOnNonUnary() {\n+        Expression left = new IsNull(EMPTY, Literal.TRUE);\n+\n+        KeyedFilter rule1 = keyedFilter(new LocalRelation(EMPTY, emptyList()));\n+        KeyedFilter rule2 = keyedFilter(new Filter(EMPTY, rel(), new IsNull(EMPTY, Literal.TRUE)));\n+\n+        Sequence s = sequence(rule1, rule2);\n+        Filter filter = new Filter(EMPTY, s, left);\n+\n+        LogicalPlan result = new Optimizer.PushDownAndCombineFilters().apply(filter);\n+\n+        assertEquals(Filter.class, result.getClass());\n+        Filter f = (Filter) result;\n+        assertEquals(s, f.child());\n+    }\n+\n+    public void testKeySameConstraints() {", "originalCommit": "9cd60368328f15ff7639163f9bfeb4fa22e6054c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc2NDgxMg==", "url": "https://github.com/elastic/elasticsearch/pull/62073#discussion_r484764812", "bodyText": "I think this test method is not gonna be picked up. You probably meant testSameTwoKeysConstraints", "author": "astefan", "createdAt": "2020-09-08T09:03:12Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/optimizer/OptimizerTests.java", "diffHunk": "@@ -300,4 +330,176 @@ private LogicalPlan defaultPipes(LogicalPlan plan) {\n         assertTrue(plan instanceof OrderBy);\n         return ((OrderBy) plan).child();\n     }\n+\n+    public void testCombineFilters() {\n+        Expression left = new IsNull(EMPTY, Literal.TRUE);\n+        Expression right = new Equals(EMPTY, timestamp(), Literal.TRUE);\n+\n+        Filter filterChild = new Filter(EMPTY, rel(), left);\n+        Filter filterParent = new Filter(EMPTY, filterChild, right);\n+\n+        LogicalPlan result = new Optimizer.PushDownAndCombineFilters().apply(filterParent);\n+\n+        assertEquals(Filter.class, result.getClass());\n+        Expression condition = ((Filter) result).condition();\n+        assertEquals(And.class, condition.getClass());\n+        And and = (And) condition;\n+        assertEquals(left, and.left());\n+        assertEquals(right, and.right());\n+    }\n+\n+    public void testPushDownFilterUnary() {\n+        Expression left = new IsNull(EMPTY, Literal.TRUE);\n+\n+        OrderBy order = new OrderBy(EMPTY, rel(), emptyList());\n+        Filter filter = new Filter(EMPTY, order, left);\n+\n+        LogicalPlan result = new Optimizer.PushDownAndCombineFilters().apply(filter);\n+\n+        assertEquals(OrderBy.class, result.getClass());\n+        OrderBy o = (OrderBy) result;\n+        assertEquals(Filter.class, o.child().getClass());\n+        Filter f = (Filter) o.child();\n+\n+        assertEquals(rel(), f.child());\n+        assertEquals(filter.condition(), f.condition());\n+    }\n+\n+    public void testPushDownFilterDoesNotApplyOnNonUnary() {\n+        Expression left = new IsNull(EMPTY, Literal.TRUE);\n+\n+        KeyedFilter rule1 = keyedFilter(new LocalRelation(EMPTY, emptyList()));\n+        KeyedFilter rule2 = keyedFilter(new Filter(EMPTY, rel(), new IsNull(EMPTY, Literal.TRUE)));\n+\n+        Sequence s = sequence(rule1, rule2);\n+        Filter filter = new Filter(EMPTY, s, left);\n+\n+        LogicalPlan result = new Optimizer.PushDownAndCombineFilters().apply(filter);\n+\n+        assertEquals(Filter.class, result.getClass());\n+        Filter f = (Filter) result;\n+        assertEquals(s, f.child());\n+    }\n+\n+    public void testKeySameConstraints() {\n+        ZoneId zd = randomZone();\n+        Attribute a = key(\"a\");\n+\n+        Expression keyCondition = new GreaterThan(EMPTY, a, new Literal(EMPTY, 1, DataTypes.INTEGER), zd);\n+        Expression filter = new Equals(EMPTY, timestamp(), Literal.TRUE);\n+\n+        KeyedFilter rule1 = keyedFilter(new Filter(EMPTY, rel(), keyCondition), a);\n+        KeyedFilter rule2 = keyedFilter(new Filter(EMPTY, rel(), filter), a);\n+\n+        Sequence s = sequence(rule1, rule2);\n+\n+        LogicalPlan result = new Optimizer.PropagateJoinKeyConstraints().apply(s);\n+\n+        assertEquals(Sequence.class, result.getClass());\n+        Sequence seq = (Sequence) result;\n+\n+        List<KeyedFilter> queries = seq.queries();\n+        assertEquals(rule1, queries.get(0));\n+        KeyedFilter query2 = queries.get(1);\n+        assertEquals(keyCondition, filterCondition(query2.child()));\n+        assertEquals(filter, filterCondition(query2.child().children().get(0)));\n+    }\n+\n+    public void sameSameTwoKeysConstraints() {", "originalCommit": "9cd60368328f15ff7639163f9bfeb4fa22e6054c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "44142c720aab2c46bd8cb42fdca2f64e72bbd9fc", "url": "https://github.com/elastic/elasticsearch/commit/44142c720aab2c46bd8cb42fdca2f64e72bbd9fc", "message": "Add more tests", "committedDate": "2020-09-08T11:23:17Z", "type": "commit"}]}