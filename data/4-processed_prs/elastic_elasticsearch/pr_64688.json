{"pr_number": 64688, "pr_title": "Implement IndexOrDocValuesQuery for geo_shape field", "pr_createdAt": "2020-11-06T08:52:24Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/64688", "timeline": [{"oid": "8df0f783af30a66b618987f37edcecdb23264d1c", "url": "https://github.com/elastic/elasticsearch/commit/8df0f783af30a66b618987f37edcecdb23264d1c", "message": "Implement IndexOrDocValuesQuery for geo_shape field", "committedDate": "2020-11-06T08:45:13Z", "type": "commit"}, {"oid": "dfa97c0ac50c4bf1384b93cd1ccfd727a0f6bf19", "url": "https://github.com/elastic/elasticsearch/commit/dfa97c0ac50c4bf1384b93cd1ccfd727a0f6bf19", "message": "Merge branch 'master' into IndexOrDocValues", "committedDate": "2020-11-10T06:58:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU2NDY4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/64688#discussion_r520564682", "bodyText": "do you think it should block this PR?", "author": "jpountz", "createdAt": "2020-11-10T13:34:41Z", "path": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/query/LatLonShapeDocValuesQueryTests.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.query;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.document.LatLonShape;\n+import org.apache.lucene.document.ShapeField;\n+import org.apache.lucene.geo.GeoTestUtil;\n+import org.apache.lucene.geo.Polygon;\n+import org.apache.lucene.geo.Rectangle;\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.IndexReader;\n+import org.apache.lucene.index.IndexWriter;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.SerialMergeScheduler;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.QueryUtils;\n+import org.apache.lucene.store.Directory;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.geo.GeometryTestUtils;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.index.mapper.GeoShapeIndexer;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.spatial.index.mapper.BinaryGeoShapeDocValuesField;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+\n+public class LatLonShapeDocValuesQueryTests extends ESTestCase {\n+\n+    private static final String FIELD_NAME = \"field\";\n+\n+    public void testEqualsAndHashcode() {\n+        Polygon polygon = GeoTestUtil.nextPolygon();\n+        Query q1 = new LatLonShapeDocValuesQuery(FIELD_NAME,ShapeField.QueryRelation.INTERSECTS, polygon);\n+        Query q2 = new LatLonShapeDocValuesQuery(FIELD_NAME,ShapeField.QueryRelation.INTERSECTS, polygon);\n+        QueryUtils.checkEqual(q1, q2);\n+\n+        Query q3 = new LatLonShapeDocValuesQuery(FIELD_NAME + \"x\",ShapeField.QueryRelation.INTERSECTS, polygon);\n+        QueryUtils.checkUnequal(q1, q3);\n+\n+        Rectangle rectangle  = GeoTestUtil.nextBox();\n+        Query q4 = new LatLonShapeDocValuesQuery(FIELD_NAME,ShapeField.QueryRelation.INTERSECTS, rectangle);\n+        QueryUtils.checkUnequal(q1, q4);\n+    }\n+\n+    public void testIndexSimpleShapes() throws Exception {\n+        IndexWriterConfig iwc = newIndexWriterConfig();\n+        // Else seeds may not reproduce:\n+        iwc.setMergeScheduler(new SerialMergeScheduler());\n+        // Else we can get O(N^2) merging:\n+        iwc.setMaxBufferedDocs(10);\n+        Directory dir = newDirectory();\n+        // RandomIndexWriter is too slow here:\n+        IndexWriter w = new IndexWriter(dir, iwc);\n+        final int numDocs = randomIntBetween(10, 100);\n+        GeoShapeIndexer indexer = new GeoShapeIndexer(true, FIELD_NAME);\n+        for (int id = 0; id < numDocs; id++) {\n+            Document doc = new Document();\n+            @SuppressWarnings(\"unchecked\") Function<Boolean, Geometry> geometryFunc = ESTestCase.randomFrom(\n+                GeometryTestUtils::randomCircle,\n+                GeometryTestUtils::randomLine,\n+                GeometryTestUtils::randomPoint,\n+                GeometryTestUtils::randomPolygon\n+            );\n+            Geometry geometry = geometryFunc.apply(false);\n+            try {\n+                geometry = indexer.prepareForIndexing(geometry);\n+                List<IndexableField> fields = indexer.indexShape(null, geometry);\n+                for (IndexableField field : fields) {\n+                    doc.add(field);\n+                }\n+                BinaryGeoShapeDocValuesField docVal = new BinaryGeoShapeDocValuesField(FIELD_NAME);\n+                docVal.add(fields, geometry);\n+                doc.add(docVal);\n+                w.addDocument(doc);\n+\n+\n+            } catch (Exception e) {\n+                // ignore\n+            }\n+        }\n+\n+        if (random().nextBoolean()) {\n+            w.forceMerge(1);\n+        }\n+        final IndexReader r = DirectoryReader.open(w);\n+        w.close();\n+\n+        IndexSearcher s = newSearcher(r);\n+        for (int i = 0; i < 100; i++) {\n+            org.apache.lucene.geo.Polygon q = GeoTestUtil.nextPolygon();\n+            Query indexQuery = LatLonShape.newGeometryQuery(FIELD_NAME, ShapeField.QueryRelation.INTERSECTS, q);\n+            Query docValQuery = new LatLonShapeDocValuesQuery(FIELD_NAME,ShapeField.QueryRelation.INTERSECTS, q);\n+            assertEquals(s.count(indexQuery), s.count(docValQuery));\n+            indexQuery = LatLonShape.newGeometryQuery(FIELD_NAME, ShapeField.QueryRelation.WITHIN, q);\n+            docValQuery = new LatLonShapeDocValuesQuery(FIELD_NAME, ShapeField.QueryRelation.WITHIN, q);\n+            assertEquals(s.count(indexQuery), s.count(docValQuery));\n+            indexQuery = LatLonShape.newGeometryQuery(FIELD_NAME, ShapeField.QueryRelation.DISJOINT, q);\n+            docValQuery = new LatLonShapeDocValuesQuery(FIELD_NAME, ShapeField.QueryRelation.DISJOINT, q);\n+            assertEquals(s.count(indexQuery), s.count(docValQuery));\n+            indexQuery = LatLonShape.newGeometryQuery(FIELD_NAME, ShapeField.QueryRelation.CONTAINS, q);\n+            docValQuery = new LatLonShapeDocValuesQuery(FIELD_NAME, ShapeField.QueryRelation.CONTAINS, q);\n+            assertEquals(s.count(indexQuery), s.count(docValQuery));\n+        }\n+        IOUtils.close(r, dir);\n+    }\n+\n+    public void testIndexMultiShapes() throws Exception {\n+        IndexWriterConfig iwc = newIndexWriterConfig();\n+        // Else seeds may not reproduce:\n+        iwc.setMergeScheduler(new SerialMergeScheduler());\n+        // Else we can get O(N^2) merging:\n+        iwc.setMaxBufferedDocs(10);\n+        Directory dir = newDirectory();\n+        // RandomIndexWriter is too slow here:\n+        IndexWriter w = new IndexWriter(dir, iwc);\n+        final int numDocs = randomIntBetween(10, 1000);\n+        GeoShapeIndexer indexer = new GeoShapeIndexer(true, FIELD_NAME);\n+        for (int id = 0; id < numDocs; id++) {\n+            Document doc = new Document();\n+            Geometry geometry = GeometryTestUtils.randomGeometryWithoutCircle(randomIntBetween(1, 5), false);\n+            try {\n+                geometry = indexer.prepareForIndexing(geometry);\n+                List<IndexableField> fields = indexer.indexShape(null, geometry);\n+                for (IndexableField field : fields) {\n+                    doc.add(field);\n+                }\n+                BinaryGeoShapeDocValuesField docVal = new BinaryGeoShapeDocValuesField(FIELD_NAME);\n+                docVal.add(fields, geometry);\n+                doc.add(docVal);\n+                w.addDocument(doc);\n+            } catch (Exception e) {\n+                // ignore\n+            }\n+        }\n+\n+        if (random().nextBoolean()) {\n+            w.forceMerge(1);\n+        }\n+        final IndexReader r = DirectoryReader.open(w);\n+        w.close();\n+\n+        IndexSearcher s = newSearcher(r);\n+        for (int i = 0; i < 100; i++) {\n+            org.apache.lucene.geo.Polygon q = GeoTestUtil.nextPolygon();\n+            Query indexQuery = LatLonShape.newGeometryQuery(FIELD_NAME, ShapeField.QueryRelation.INTERSECTS, q);\n+            Query docValQuery = new LatLonShapeDocValuesQuery(FIELD_NAME,ShapeField.QueryRelation.INTERSECTS, q);\n+            assertEquals(s.count(indexQuery), s.count(docValQuery));\n+            indexQuery = LatLonShape.newGeometryQuery(FIELD_NAME, ShapeField.QueryRelation.WITHIN, q);\n+            docValQuery = new LatLonShapeDocValuesQuery(FIELD_NAME, ShapeField.QueryRelation.WITHIN, q);\n+            assertEquals(s.count(indexQuery), s.count(docValQuery));\n+            indexQuery = LatLonShape.newGeometryQuery(FIELD_NAME, ShapeField.QueryRelation.DISJOINT, q);\n+            docValQuery = new LatLonShapeDocValuesQuery(FIELD_NAME, ShapeField.QueryRelation.DISJOINT, q);\n+            assertEquals(s.count(indexQuery), s.count(docValQuery));\n+            // CONTAINS and multi-shapes fails due to LUCENE-9595", "originalCommit": "dfa97c0ac50c4bf1384b93cd1ccfd727a0f6bf19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk1NTUxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/64688#discussion_r521955511", "bodyText": "I think we can wait until we depend on a Lucene version that contains the fix.", "author": "iverase", "createdAt": "2020-11-12T09:21:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU2NDY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU2NTA2MA==", "url": "https://github.com/elastic/elasticsearch/pull/64688#discussion_r520565060", "bodyText": "is it safe? Can we narrow down the set of exceptions types we ignore?", "author": "jpountz", "createdAt": "2020-11-10T13:35:12Z", "path": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/query/LatLonShapeDocValuesQueryTests.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.query;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.document.LatLonShape;\n+import org.apache.lucene.document.ShapeField;\n+import org.apache.lucene.geo.GeoTestUtil;\n+import org.apache.lucene.geo.Polygon;\n+import org.apache.lucene.geo.Rectangle;\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.IndexReader;\n+import org.apache.lucene.index.IndexWriter;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.SerialMergeScheduler;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.QueryUtils;\n+import org.apache.lucene.store.Directory;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.geo.GeometryTestUtils;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.index.mapper.GeoShapeIndexer;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.spatial.index.mapper.BinaryGeoShapeDocValuesField;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+\n+public class LatLonShapeDocValuesQueryTests extends ESTestCase {\n+\n+    private static final String FIELD_NAME = \"field\";\n+\n+    public void testEqualsAndHashcode() {\n+        Polygon polygon = GeoTestUtil.nextPolygon();\n+        Query q1 = new LatLonShapeDocValuesQuery(FIELD_NAME,ShapeField.QueryRelation.INTERSECTS, polygon);\n+        Query q2 = new LatLonShapeDocValuesQuery(FIELD_NAME,ShapeField.QueryRelation.INTERSECTS, polygon);\n+        QueryUtils.checkEqual(q1, q2);\n+\n+        Query q3 = new LatLonShapeDocValuesQuery(FIELD_NAME + \"x\",ShapeField.QueryRelation.INTERSECTS, polygon);\n+        QueryUtils.checkUnequal(q1, q3);\n+\n+        Rectangle rectangle  = GeoTestUtil.nextBox();\n+        Query q4 = new LatLonShapeDocValuesQuery(FIELD_NAME,ShapeField.QueryRelation.INTERSECTS, rectangle);\n+        QueryUtils.checkUnequal(q1, q4);\n+    }\n+\n+    public void testIndexSimpleShapes() throws Exception {\n+        IndexWriterConfig iwc = newIndexWriterConfig();\n+        // Else seeds may not reproduce:\n+        iwc.setMergeScheduler(new SerialMergeScheduler());\n+        // Else we can get O(N^2) merging:\n+        iwc.setMaxBufferedDocs(10);\n+        Directory dir = newDirectory();\n+        // RandomIndexWriter is too slow here:\n+        IndexWriter w = new IndexWriter(dir, iwc);\n+        final int numDocs = randomIntBetween(10, 100);\n+        GeoShapeIndexer indexer = new GeoShapeIndexer(true, FIELD_NAME);\n+        for (int id = 0; id < numDocs; id++) {\n+            Document doc = new Document();\n+            @SuppressWarnings(\"unchecked\") Function<Boolean, Geometry> geometryFunc = ESTestCase.randomFrom(\n+                GeometryTestUtils::randomCircle,\n+                GeometryTestUtils::randomLine,\n+                GeometryTestUtils::randomPoint,\n+                GeometryTestUtils::randomPolygon\n+            );\n+            Geometry geometry = geometryFunc.apply(false);\n+            try {\n+                geometry = indexer.prepareForIndexing(geometry);\n+                List<IndexableField> fields = indexer.indexShape(null, geometry);\n+                for (IndexableField field : fields) {\n+                    doc.add(field);\n+                }\n+                BinaryGeoShapeDocValuesField docVal = new BinaryGeoShapeDocValuesField(FIELD_NAME);\n+                docVal.add(fields, geometry);\n+                doc.add(docVal);\n+                w.addDocument(doc);\n+\n+\n+            } catch (Exception e) {\n+                // ignore\n+            }\n+        }\n+\n+        if (random().nextBoolean()) {\n+            w.forceMerge(1);\n+        }\n+        final IndexReader r = DirectoryReader.open(w);\n+        w.close();\n+\n+        IndexSearcher s = newSearcher(r);\n+        for (int i = 0; i < 100; i++) {\n+            org.apache.lucene.geo.Polygon q = GeoTestUtil.nextPolygon();\n+            Query indexQuery = LatLonShape.newGeometryQuery(FIELD_NAME, ShapeField.QueryRelation.INTERSECTS, q);\n+            Query docValQuery = new LatLonShapeDocValuesQuery(FIELD_NAME,ShapeField.QueryRelation.INTERSECTS, q);\n+            assertEquals(s.count(indexQuery), s.count(docValQuery));\n+            indexQuery = LatLonShape.newGeometryQuery(FIELD_NAME, ShapeField.QueryRelation.WITHIN, q);\n+            docValQuery = new LatLonShapeDocValuesQuery(FIELD_NAME, ShapeField.QueryRelation.WITHIN, q);\n+            assertEquals(s.count(indexQuery), s.count(docValQuery));\n+            indexQuery = LatLonShape.newGeometryQuery(FIELD_NAME, ShapeField.QueryRelation.DISJOINT, q);\n+            docValQuery = new LatLonShapeDocValuesQuery(FIELD_NAME, ShapeField.QueryRelation.DISJOINT, q);\n+            assertEquals(s.count(indexQuery), s.count(docValQuery));\n+            indexQuery = LatLonShape.newGeometryQuery(FIELD_NAME, ShapeField.QueryRelation.CONTAINS, q);\n+            docValQuery = new LatLonShapeDocValuesQuery(FIELD_NAME, ShapeField.QueryRelation.CONTAINS, q);\n+            assertEquals(s.count(indexQuery), s.count(docValQuery));\n+        }\n+        IOUtils.close(r, dir);\n+    }\n+\n+    public void testIndexMultiShapes() throws Exception {\n+        IndexWriterConfig iwc = newIndexWriterConfig();\n+        // Else seeds may not reproduce:\n+        iwc.setMergeScheduler(new SerialMergeScheduler());\n+        // Else we can get O(N^2) merging:\n+        iwc.setMaxBufferedDocs(10);\n+        Directory dir = newDirectory();\n+        // RandomIndexWriter is too slow here:\n+        IndexWriter w = new IndexWriter(dir, iwc);\n+        final int numDocs = randomIntBetween(10, 1000);\n+        GeoShapeIndexer indexer = new GeoShapeIndexer(true, FIELD_NAME);\n+        for (int id = 0; id < numDocs; id++) {\n+            Document doc = new Document();\n+            Geometry geometry = GeometryTestUtils.randomGeometryWithoutCircle(randomIntBetween(1, 5), false);\n+            try {\n+                geometry = indexer.prepareForIndexing(geometry);\n+                List<IndexableField> fields = indexer.indexShape(null, geometry);\n+                for (IndexableField field : fields) {\n+                    doc.add(field);\n+                }\n+                BinaryGeoShapeDocValuesField docVal = new BinaryGeoShapeDocValuesField(FIELD_NAME);\n+                docVal.add(fields, geometry);\n+                doc.add(docVal);\n+                w.addDocument(doc);\n+            } catch (Exception e) {\n+                // ignore", "originalCommit": "dfa97c0ac50c4bf1384b93cd1ccfd727a0f6bf19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk1NDQxOA==", "url": "https://github.com/elastic/elasticsearch/pull/64688#discussion_r521954418", "bodyText": "I remove the try / catch", "author": "iverase", "createdAt": "2020-11-12T09:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU2NTA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU2NjE0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/64688#discussion_r520566147", "bodyText": "should you also test that geometry has a length > 0?", "author": "jpountz", "createdAt": "2020-11-10T13:36:46Z", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/query/LatLonShapeDocValuesQuery.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.query;\n+\n+import org.apache.lucene.document.ShapeField;\n+import org.apache.lucene.geo.Component2D;\n+import org.apache.lucene.geo.LatLonGeometry;\n+import org.apache.lucene.index.BinaryDocValues;\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.ConstantScoreScorer;\n+import org.apache.lucene.search.ConstantScoreWeight;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.QueryVisitor;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.TwoPhaseIterator;\n+import org.apache.lucene.search.Weight;\n+import org.elasticsearch.xpack.spatial.index.fielddata.Component2DVisitor;\n+import org.elasticsearch.xpack.spatial.index.fielddata.CoordinateEncoder;\n+import org.elasticsearch.xpack.spatial.index.fielddata.GeometryDocValueReader;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+/** Lucene geometry query for {@link org.elasticsearch.xpack.spatial.index.mapper.BinaryGeoShapeDocValuesField}. */\n+class LatLonShapeDocValuesQuery extends Query {\n+\n+    private final String field;\n+    private final LatLonGeometry[] geometry;\n+    private final ShapeField.QueryRelation relation;\n+\n+    LatLonShapeDocValuesQuery(String field, ShapeField.QueryRelation relation, LatLonGeometry... geometry) {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"field must not be null\");\n+        }\n+        this.field = field;", "originalCommit": "dfa97c0ac50c4bf1384b93cd1ccfd727a0f6bf19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU2NjMzNg==", "url": "https://github.com/elastic/elasticsearch/pull/64688#discussion_r520566336", "bodyText": "or alternatively rewrite the query when length == 0?", "author": "jpountz", "createdAt": "2020-11-10T13:37:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU2NjE0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk1NTEwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/64688#discussion_r521955101", "bodyText": "This is done in VectorGeoShapeWithDocValuesQueryProcessor. It gets rewritten to a MatchNoDocsQuery, is that enough?", "author": "iverase", "createdAt": "2020-11-12T09:20:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU2NjE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MjQ2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/64688#discussion_r520972461", "bodyText": "Although this is an extension to the push that is documented in TriangleTreeReader.Visitor, I think it would be convenient to re-write in the documentation what the return value of this function signals", "author": "talevy", "createdAt": "2020-11-11T00:56:43Z", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/fielddata/Component2DVisitor.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.fielddata;\n+\n+import org.apache.lucene.document.ShapeField;\n+import org.apache.lucene.geo.Component2D;\n+import org.apache.lucene.index.PointValues;\n+\n+/**\n+ * A {@link TriangleTreeReader.Visitor} implementation for {@link Component2D} geometries.\n+ * It can solve spatial relationships against a serialize triangle tree.\n+ */\n+public abstract class Component2DVisitor implements TriangleTreeReader.Visitor {\n+\n+    protected final Component2D component2D;\n+    private final CoordinateEncoder encoder;\n+\n+    private Component2DVisitor(Component2D component2D, CoordinateEncoder encoder) {\n+        this.component2D = component2D;\n+        this.encoder = encoder;\n+    }\n+\n+    public abstract boolean matches();\n+\n+    public abstract void reset();\n+\n+    @Override\n+    public void visitPoint(int x, int y) {\n+        doVisitPoint(encoder.decodeX(x), encoder.decodeY(y));\n+    }\n+\n+    abstract void doVisitPoint(double x, double y);\n+\n+    @Override\n+    public void visitLine(int aX, int aY, int bX, int bY, byte metadata) {\n+        doVisitLine(encoder.decodeX(aX), encoder.decodeY(aY), encoder.decodeX(bX), encoder.decodeY(bY), metadata);\n+    }\n+\n+    abstract void doVisitLine(double aX, double aY, double bX, double bY, byte metadata);\n+\n+    @Override\n+    public void visitTriangle(int aX, int aY, int bX, int bY, int cX, int cY, byte metadata) {\n+        doVisitTriangle(\n+            encoder.decodeX(aX),\n+            encoder.decodeY(aY),\n+            encoder.decodeX(bX),\n+            encoder.decodeY(bY),\n+            encoder.decodeX(cX),\n+            encoder.decodeY(cY),\n+            metadata\n+        );\n+    }\n+\n+    abstract void doVisitTriangle(double aX, double aY, double bX, double bY, double cX, double cY, byte metadata);\n+\n+    @Override\n+    public boolean pushX(int minX) {\n+        return component2D.getMaxX() >= encoder.decodeX(minX);\n+    }\n+\n+    @Override\n+    public boolean pushY(int minY) {\n+        return component2D.getMaxY() >= encoder.decodeY(minY);\n+    }\n+\n+    @Override\n+    public boolean push(int maxX, int maxY) {\n+        return component2D.getMinX() <= encoder.decodeX(maxX) &&\n+               component2D.getMinY() <= encoder.decodeY(maxY);\n+\n+    }\n+\n+    @Override\n+    public boolean push(int minX, int minY, int maxX, int maxY) {\n+        final PointValues.Relation relation = component2D.relate(\n+            encoder.decodeX(minX),\n+            encoder.decodeX(maxX),\n+            encoder.decodeY(minY),\n+            encoder.decodeY(maxY)\n+        );\n+        return doPush(relation);\n+    }\n+\n+    abstract boolean doPush(PointValues.Relation relation);", "originalCommit": "dfa97c0ac50c4bf1384b93cd1ccfd727a0f6bf19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3NDI5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/64688#discussion_r520974296", "bodyText": "I think it would be nice to explain the rational behind each of these default answer values (here as well as the other visitors), especially since they are not the same for different Visitors. It seems like the default value is assumed in some of the logic", "author": "talevy", "createdAt": "2020-11-11T00:59:26Z", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/fielddata/Component2DVisitor.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.fielddata;\n+\n+import org.apache.lucene.document.ShapeField;\n+import org.apache.lucene.geo.Component2D;\n+import org.apache.lucene.index.PointValues;\n+\n+/**\n+ * A {@link TriangleTreeReader.Visitor} implementation for {@link Component2D} geometries.\n+ * It can solve spatial relationships against a serialize triangle tree.\n+ */\n+public abstract class Component2DVisitor implements TriangleTreeReader.Visitor {\n+\n+    protected final Component2D component2D;\n+    private final CoordinateEncoder encoder;\n+\n+    private Component2DVisitor(Component2D component2D, CoordinateEncoder encoder) {\n+        this.component2D = component2D;\n+        this.encoder = encoder;\n+    }\n+\n+    public abstract boolean matches();\n+\n+    public abstract void reset();\n+\n+    @Override\n+    public void visitPoint(int x, int y) {\n+        doVisitPoint(encoder.decodeX(x), encoder.decodeY(y));\n+    }\n+\n+    abstract void doVisitPoint(double x, double y);\n+\n+    @Override\n+    public void visitLine(int aX, int aY, int bX, int bY, byte metadata) {\n+        doVisitLine(encoder.decodeX(aX), encoder.decodeY(aY), encoder.decodeX(bX), encoder.decodeY(bY), metadata);\n+    }\n+\n+    abstract void doVisitLine(double aX, double aY, double bX, double bY, byte metadata);\n+\n+    @Override\n+    public void visitTriangle(int aX, int aY, int bX, int bY, int cX, int cY, byte metadata) {\n+        doVisitTriangle(\n+            encoder.decodeX(aX),\n+            encoder.decodeY(aY),\n+            encoder.decodeX(bX),\n+            encoder.decodeY(bY),\n+            encoder.decodeX(cX),\n+            encoder.decodeY(cY),\n+            metadata\n+        );\n+    }\n+\n+    abstract void doVisitTriangle(double aX, double aY, double bX, double bY, double cX, double cY, byte metadata);\n+\n+    @Override\n+    public boolean pushX(int minX) {\n+        return component2D.getMaxX() >= encoder.decodeX(minX);\n+    }\n+\n+    @Override\n+    public boolean pushY(int minY) {\n+        return component2D.getMaxY() >= encoder.decodeY(minY);\n+    }\n+\n+    @Override\n+    public boolean push(int maxX, int maxY) {\n+        return component2D.getMinX() <= encoder.decodeX(maxX) &&\n+               component2D.getMinY() <= encoder.decodeY(maxY);\n+\n+    }\n+\n+    @Override\n+    public boolean push(int minX, int minY, int maxX, int maxY) {\n+        final PointValues.Relation relation = component2D.relate(\n+            encoder.decodeX(minX),\n+            encoder.decodeX(maxX),\n+            encoder.decodeY(minY),\n+            encoder.decodeY(maxY)\n+        );\n+        return doPush(relation);\n+    }\n+\n+    abstract boolean doPush(PointValues.Relation relation);\n+\n+    /**\n+     * Creates a visitor from the provided Component2D and spatial relationship. Visitors are re-usable by\n+     * calling the {@link #reset()} method.\n+     */\n+    public static Component2DVisitor getVisitor(\n+        Component2D component2D,\n+        ShapeField.QueryRelation relation,\n+        CoordinateEncoder encoder\n+    ) {\n+        switch (relation) {\n+            case CONTAINS:\n+                return new ContainsVisitor(component2D, encoder);\n+            case INTERSECTS:\n+                return new IntersectsVisitor(component2D, encoder);\n+            case DISJOINT:\n+                return new DisjointVisitor(component2D, encoder);\n+            case WITHIN:\n+                return new WithinVisitor(component2D, encoder);\n+            default:\n+                throw new IllegalArgumentException(\"Invalid query relation:[\" + relation + \"]\");\n+        }\n+    }\n+\n+    /**\n+     * Intersects visitor stops as soon as there is one triangle intersecting the component\n+     */\n+    private static class IntersectsVisitor extends Component2DVisitor {\n+\n+        boolean answer;\n+\n+        private IntersectsVisitor(Component2D component2D, CoordinateEncoder encoder) {\n+            super(component2D, encoder);\n+        }\n+\n+        @Override\n+        public boolean matches() {\n+            return answer;\n+        }\n+\n+        @Override\n+        public void reset() {\n+            answer = false;\n+        }\n+\n+        @Override\n+        void doVisitPoint(double x, double y) {\n+            answer = component2D.contains(x, y);\n+        }\n+\n+        @Override\n+        void doVisitLine(double aX, double aY, double bX, double bY, byte metadata) {\n+            answer = component2D.intersectsLine(aX, aY, bX, bY);\n+        }\n+\n+        @Override\n+        void doVisitTriangle(double aX, double aY, double bX, double bY, double cX, double cY, byte metadata) {\n+            answer = component2D.intersectsTriangle(aX, aY, bX, bY, cX, cY);\n+        }\n+\n+        @Override\n+        public boolean push() {\n+            return answer == false;\n+        }\n+\n+        @Override\n+       boolean doPush(PointValues.Relation relation) {\n+            if (relation == PointValues.Relation.CELL_OUTSIDE_QUERY) {\n+                return false;\n+            } else if (relation == PointValues.Relation.CELL_INSIDE_QUERY) {\n+                answer = true;\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Disjoint visitor stops as soon as there is one triangle intersecting the component\n+     */\n+    private static class DisjointVisitor extends Component2DVisitor {\n+\n+        boolean answer;\n+\n+        private DisjointVisitor(Component2D component2D, CoordinateEncoder encoder) {\n+            super(component2D, encoder);\n+            answer = true;\n+        }\n+\n+        @Override\n+        public boolean matches() {\n+            return answer;\n+        }\n+\n+        @Override\n+        public void reset() {\n+            answer = true;", "originalCommit": "dfa97c0ac50c4bf1384b93cd1ccfd727a0f6bf19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0dfc256d048be92c1bb910c4a8d46c19738036b3", "url": "https://github.com/elastic/elasticsearch/commit/0dfc256d048be92c1bb910c4a8d46c19738036b3", "message": "Merge branch 'master' into IndexOrDocValues", "committedDate": "2020-11-11T15:26:03Z", "type": "commit"}, {"oid": "16216c5e99353869bf7c45fce36cf766055ab1be", "url": "https://github.com/elastic/elasticsearch/commit/16216c5e99353869bf7c45fce36cf766055ab1be", "message": "Address review comments and fix some bugs on the way", "committedDate": "2020-11-12T09:15:26Z", "type": "commit"}, {"oid": "0d28e8a4953408286f6c85b1c0ba2eaf290c5110", "url": "https://github.com/elastic/elasticsearch/commit/0d28e8a4953408286f6c85b1c0ba2eaf290c5110", "message": "Merge branch 'master' into IndexOrDocValues", "committedDate": "2021-01-12T07:30:47Z", "type": "commit"}, {"oid": "d6f4d26758311cfbee12f22188c5a94e1c0b2583", "url": "https://github.com/elastic/elasticsearch/commit/d6f4d26758311cfbee12f22188c5a94e1c0b2583", "message": "clean up test", "committedDate": "2021-01-12T07:46:03Z", "type": "commit"}, {"oid": "d76fe59507ff41d6620b6d25afb984503aab3bda", "url": "https://github.com/elastic/elasticsearch/commit/d76fe59507ff41d6620b6d25afb984503aab3bda", "message": "unused imports", "committedDate": "2021-01-12T07:46:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgwMjg4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/64688#discussion_r556802882", "bodyText": "I am not too familiar with this. So long as matchCost is constant and the ConstantScoreScorer is used, this number is arbitrary and has no effect, right?", "author": "talevy", "createdAt": "2021-01-13T20:17:21Z", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/query/LatLonShapeDocValuesQuery.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.query;\n+\n+import org.apache.lucene.document.ShapeField;\n+import org.apache.lucene.geo.Component2D;\n+import org.apache.lucene.geo.LatLonGeometry;\n+import org.apache.lucene.geo.Rectangle;\n+import org.apache.lucene.index.BinaryDocValues;\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.ConstantScoreScorer;\n+import org.apache.lucene.search.ConstantScoreWeight;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.QueryVisitor;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.TwoPhaseIterator;\n+import org.apache.lucene.search.Weight;\n+import org.elasticsearch.xpack.spatial.index.fielddata.Component2DVisitor;\n+import org.elasticsearch.xpack.spatial.index.fielddata.CoordinateEncoder;\n+import org.elasticsearch.xpack.spatial.index.fielddata.GeometryDocValueReader;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/** Lucene geometry query for {@link org.elasticsearch.xpack.spatial.index.mapper.BinaryGeoShapeDocValuesField}. */\n+class LatLonShapeDocValuesQuery extends Query {\n+\n+    private final String field;\n+    private final LatLonGeometry[] geometries;\n+    private final ShapeField.QueryRelation relation;\n+\n+    LatLonShapeDocValuesQuery(String field, ShapeField.QueryRelation relation, LatLonGeometry... geometries) {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"field must not be null\");\n+        }\n+        this.field = field;\n+        this.geometries = geometries;\n+        this.relation = relation;\n+    }\n+\n+    @Override\n+    public String toString(String field) {\n+        StringBuilder sb = new StringBuilder();\n+        if (!this.field.equals(field)) {\n+            sb.append(this.field);\n+            sb.append(':');\n+            sb.append(relation);\n+            sb.append(':');\n+        }\n+        sb.append(Arrays.toString(geometries));\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (sameClassAs(obj) == false) {\n+            return false;\n+        }\n+        LatLonShapeDocValuesQuery other = (LatLonShapeDocValuesQuery) obj;\n+        return field.equals(other.field) && relation == other.relation && Arrays.equals(geometries, other.geometries);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int h = classHash();\n+        h = 31 * h + field.hashCode();\n+        h = 31 * h + relation.hashCode();\n+        h = 31 * h + Arrays.hashCode(geometries);\n+        return h;\n+    }\n+\n+    @Override\n+    public void visit(QueryVisitor visitor) {\n+        if (visitor.acceptField(field)) {\n+            visitor.visitLeaf(this);\n+        }\n+    }\n+\n+    @Override\n+    public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) {\n+         if (relation == ShapeField.QueryRelation.CONTAINS) {\n+             return getContainsWeight(scoreMode, boost);\n+         } else {\n+            return getStandardWeight(scoreMode, boost);\n+         }\n+    }\n+\n+    private ConstantScoreWeight getStandardWeight(ScoreMode scoreMode, float boost) {\n+        return new ConstantScoreWeight(this, boost) {\n+            final Component2D component2D = LatLonGeometry.create(geometries);\n+\n+            @Override\n+            public Scorer scorer(LeafReaderContext context) throws IOException {\n+                final BinaryDocValues values = context.reader().getBinaryDocValues(field);\n+                if (values == null) {\n+                    return null;\n+                }\n+                final GeometryDocValueReader reader = new GeometryDocValueReader();\n+                final Component2DVisitor visitor = Component2DVisitor.getVisitor(component2D, relation, CoordinateEncoder.GEO);\n+\n+                final TwoPhaseIterator iterator = new TwoPhaseIterator(values) {\n+\n+                    @Override\n+                    public boolean matches() throws IOException {\n+                        reader.reset(values.binaryValue());\n+                        visitor.reset();\n+                        reader.visit(visitor);\n+                        return visitor.matches();\n+                    }\n+\n+                    @Override\n+                    public float matchCost() {\n+                        return 1000f; // TODO: what should it be?", "originalCommit": "d76fe59507ff41d6620b6d25afb984503aab3bda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzE0MTE4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/64688#discussion_r557141182", "bodyText": "My understanding is that this value is used when you have more that one TwoPhaseIterator in a conjunction in order to sort them. You want to execute the cheaper iterators first.\nIn put case we do not have a good estimation of cost so it is good enough to return a big number. Note that this is done the same for LatLonPointDocValues.", "author": "iverase", "createdAt": "2021-01-14T07:57:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgwMjg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgwMDk2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/64688#discussion_r557800961", "bodyText": "thanks!", "author": "talevy", "createdAt": "2021-01-15T01:12:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgwMjg4Mg=="}], "type": "inlineReview"}, {"oid": "7cbbfcf5a281f63d50d2acfff99220410057d0cc", "url": "https://github.com/elastic/elasticsearch/commit/7cbbfcf5a281f63d50d2acfff99220410057d0cc", "message": "Merge branch 'master' into IndexOrDocValues", "committedDate": "2021-01-15T06:56:46Z", "type": "commit"}, {"oid": "c946c99df42abc4a36335ddb0b7bd2edfc2d0ebc", "url": "https://github.com/elastic/elasticsearch/commit/c946c99df42abc4a36335ddb0b7bd2edfc2d0ebc", "message": "compile error", "committedDate": "2021-01-15T07:28:43Z", "type": "commit"}, {"oid": "9a3a932038f74e145e4d93f88f9ac706cb898dbe", "url": "https://github.com/elastic/elasticsearch/commit/9a3a932038f74e145e4d93f88f9ac706cb898dbe", "message": "checkStyle", "committedDate": "2021-01-15T07:51:14Z", "type": "commit"}]}