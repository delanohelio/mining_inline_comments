{"pr_number": 52166, "pr_title": "Convert RareTerms to new VS registry", "pr_createdAt": "2020-02-10T21:37:02Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52166", "timeline": [{"oid": "d3bc413f0faa17238f9843146ae24f738f545133", "url": "https://github.com/elastic/elasticsearch/commit/d3bc413f0faa17238f9843146ae24f738f545133", "message": "Convert RareTerms to new VS registry", "committedDate": "2020-02-10T21:27:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMDc2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52166#discussion_r377920761", "bodyText": "Nit - align indentation please.", "author": "not-napoleon", "createdAt": "2020-02-11T21:50:20Z", "path": "server/src/main/java/org/elasticsearch/search/SearchModule.java", "diffHunk": "@@ -395,7 +395,8 @@ private void registerAggregations(List<SearchPlugin> plugins) {\n                 RareTermsAggregationBuilder::parse)\n                     .addResultReader(StringRareTerms.NAME, StringRareTerms::new)\n                     .addResultReader(UnmappedRareTerms.NAME, UnmappedRareTerms::new)\n-                    .addResultReader(LongRareTerms.NAME, LongRareTerms::new));\n+                    .addResultReader(LongRareTerms.NAME, LongRareTerms::new)\n+            .setAggregatorRegistrar(RareTermsAggregationBuilder::registerAggregators));", "originalCommit": "d3bc413f0faa17238f9843146ae24f738f545133", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMTM3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52166#discussion_r377921371", "bodyText": "Nit - Do we need to keep copying this TODO around?  I'm not even sure it's really still valid, registration in the factory hasn't been as messy as I'd expected when I first wrote that down.", "author": "not-napoleon", "createdAt": "2020-02-11T21:51:38Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/RareTermsAggregatorFactory.java", "diffHunk": "@@ -44,6 +47,89 @@\n     private final int maxDocCount;\n     private final double precision;\n \n+    // TODO: Registration should happen on the actual aggregator classes", "originalCommit": "d3bc413f0faa17238f9843146ae24f738f545133", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ1NTM2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52166#discussion_r378455365", "bodyText": "Yeah good point, it hasn't bothered me in the factory either.  I'll remove.", "author": "polyfractal", "createdAt": "2020-02-12T19:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMTM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyNDc5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52166#discussion_r377924791", "bodyText": "This seems like it should be an IllegalArgumentException - Something didn't go wrong with the agg, the user sent us nonsense.", "author": "not-napoleon", "createdAt": "2020-02-11T21:58:42Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/RareTermsAggregatorFactory.java", "diffHunk": "@@ -44,6 +47,89 @@\n     private final int maxDocCount;\n     private final double precision;\n \n+    // TODO: Registration should happen on the actual aggregator classes\n+    static void registerAggregators(ValuesSourceRegistry valuesSourceRegistry) {\n+        valuesSourceRegistry.register(RareTermsAggregationBuilder.NAME,\n+            List.of(CoreValuesSourceType.BYTES, CoreValuesSourceType.IP),\n+            RareTermsAggregatorFactory.bytesSupplier());\n+\n+        valuesSourceRegistry.register(RareTermsAggregationBuilder.NAME,\n+            List.of(CoreValuesSourceType.DATE, CoreValuesSourceType.BOOLEAN, CoreValuesSourceType.NUMERIC),\n+            RareTermsAggregatorFactory.numericSupplier());\n+    }\n+\n+    /**\n+     * This supplier is used for all the field types that should be aggregated as bytes/strings,\n+     * including those that need global ordinals\n+     */\n+    private static RareTermsAggregatorSupplier bytesSupplier() {\n+        return new RareTermsAggregatorSupplier() {\n+            @Override\n+            public Aggregator build(String name,\n+                                    AggregatorFactories factories,\n+                                    ValuesSource valuesSource,\n+                                    DocValueFormat format,\n+                                    int maxDocCount,\n+                                    double precision,\n+                                    IncludeExclude includeExclude,\n+                                    SearchContext context,\n+                                    Aggregator parent,\n+                                    List<PipelineAggregator> pipelineAggregators,\n+                                    Map<String, Object> metaData) throws IOException {\n+\n+                ExecutionMode execution = ExecutionMode.MAP; //TODO global ords not implemented yet, only supports \"map\"\n+\n+                if ((includeExclude != null) && (includeExclude.isRegexBased()) && format != DocValueFormat.RAW) {\n+                    throw new AggregationExecutionException(\"Aggregation [\" + name + \"] cannot support \" +\n+                        \"regular expression style include/exclude settings as they can only be applied to string fields. \" +\n+                        \"Use an array of values for include/exclude clauses\");\n+                }\n+\n+                return execution.create(name, factories, valuesSource, format,\n+                    includeExclude, context, parent, pipelineAggregators, metaData, maxDocCount, precision);\n+\n+            }\n+        };\n+    }\n+\n+    /**\n+     * This supplier is used for all fields that expect to be aggregated as a numeric value.\n+     * This includes floating points, and formatted types that use numerics internally for storage (date, boolean, etc)\n+     */\n+    private static RareTermsAggregatorSupplier numericSupplier() {\n+        return new RareTermsAggregatorSupplier() {\n+            @Override\n+            public Aggregator build(String name,\n+                                    AggregatorFactories factories,\n+                                    ValuesSource valuesSource,\n+                                    DocValueFormat format,\n+                                    int maxDocCount,\n+                                    double precision,\n+                                    IncludeExclude includeExclude,\n+                                    SearchContext context,\n+                                    Aggregator parent,\n+                                    List<PipelineAggregator> pipelineAggregators,\n+                                    Map<String, Object> metaData) throws IOException {\n+\n+                if ((includeExclude != null) && (includeExclude.isRegexBased())) {\n+                    throw new AggregationExecutionException(\"Aggregation [\" + name + \"] cannot support regular expression \" +", "originalCommit": "d3bc413f0faa17238f9843146ae24f738f545133", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ1NjEwMw==", "url": "https://github.com/elastic/elasticsearch/pull/52166#discussion_r378456103", "bodyText": "It is somewhat conditional, since the same include/exclude could work on a different field type (strings vs numerics).  But I generally agree, will switch it over.", "author": "polyfractal", "createdAt": "2020-02-12T19:11:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyNDc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyNTcxNA==", "url": "https://github.com/elastic/elasticsearch/pull/52166#discussion_r377925714", "bodyText": "As above, this feels like an IllegalArgumentException.  If they gave us a Range field as input, we'd throw IllegalArgumentException, this feels like the same type of error.", "author": "not-napoleon", "createdAt": "2020-02-11T22:00:37Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/RareTermsAggregatorFactory.java", "diffHunk": "@@ -44,6 +47,89 @@\n     private final int maxDocCount;\n     private final double precision;\n \n+    // TODO: Registration should happen on the actual aggregator classes\n+    static void registerAggregators(ValuesSourceRegistry valuesSourceRegistry) {\n+        valuesSourceRegistry.register(RareTermsAggregationBuilder.NAME,\n+            List.of(CoreValuesSourceType.BYTES, CoreValuesSourceType.IP),\n+            RareTermsAggregatorFactory.bytesSupplier());\n+\n+        valuesSourceRegistry.register(RareTermsAggregationBuilder.NAME,\n+            List.of(CoreValuesSourceType.DATE, CoreValuesSourceType.BOOLEAN, CoreValuesSourceType.NUMERIC),\n+            RareTermsAggregatorFactory.numericSupplier());\n+    }\n+\n+    /**\n+     * This supplier is used for all the field types that should be aggregated as bytes/strings,\n+     * including those that need global ordinals\n+     */\n+    private static RareTermsAggregatorSupplier bytesSupplier() {\n+        return new RareTermsAggregatorSupplier() {\n+            @Override\n+            public Aggregator build(String name,\n+                                    AggregatorFactories factories,\n+                                    ValuesSource valuesSource,\n+                                    DocValueFormat format,\n+                                    int maxDocCount,\n+                                    double precision,\n+                                    IncludeExclude includeExclude,\n+                                    SearchContext context,\n+                                    Aggregator parent,\n+                                    List<PipelineAggregator> pipelineAggregators,\n+                                    Map<String, Object> metaData) throws IOException {\n+\n+                ExecutionMode execution = ExecutionMode.MAP; //TODO global ords not implemented yet, only supports \"map\"\n+\n+                if ((includeExclude != null) && (includeExclude.isRegexBased()) && format != DocValueFormat.RAW) {\n+                    throw new AggregationExecutionException(\"Aggregation [\" + name + \"] cannot support \" +\n+                        \"regular expression style include/exclude settings as they can only be applied to string fields. \" +\n+                        \"Use an array of values for include/exclude clauses\");\n+                }\n+\n+                return execution.create(name, factories, valuesSource, format,\n+                    includeExclude, context, parent, pipelineAggregators, metaData, maxDocCount, precision);\n+\n+            }\n+        };\n+    }\n+\n+    /**\n+     * This supplier is used for all fields that expect to be aggregated as a numeric value.\n+     * This includes floating points, and formatted types that use numerics internally for storage (date, boolean, etc)\n+     */\n+    private static RareTermsAggregatorSupplier numericSupplier() {\n+        return new RareTermsAggregatorSupplier() {\n+            @Override\n+            public Aggregator build(String name,\n+                                    AggregatorFactories factories,\n+                                    ValuesSource valuesSource,\n+                                    DocValueFormat format,\n+                                    int maxDocCount,\n+                                    double precision,\n+                                    IncludeExclude includeExclude,\n+                                    SearchContext context,\n+                                    Aggregator parent,\n+                                    List<PipelineAggregator> pipelineAggregators,\n+                                    Map<String, Object> metaData) throws IOException {\n+\n+                if ((includeExclude != null) && (includeExclude.isRegexBased())) {\n+                    throw new AggregationExecutionException(\"Aggregation [\" + name + \"] cannot support regular expression \" +\n+                        \"style include/exclude settings as they can only be applied to string fields. Use an array of numeric \" +\n+                        \"values for include/exclude clauses used to filter numeric fields\");\n+                }\n+\n+                IncludeExclude.LongFilter longFilter = null;\n+                if (((ValuesSource.Numeric) valuesSource).isFloatingPoint()) {\n+                    throw new AggregationExecutionException(\"RareTerms aggregation does not support floating point fields.\");", "originalCommit": "d3bc413f0faa17238f9843146ae24f738f545133", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyNjQ3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52166#discussion_r377926473", "bodyText": "Again, I think this should be IllegalArgumentException, see comment below.", "author": "not-napoleon", "createdAt": "2020-02-11T22:02:17Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/RareTermsAggregatorFactory.java", "diffHunk": "@@ -44,6 +47,89 @@\n     private final int maxDocCount;\n     private final double precision;\n \n+    // TODO: Registration should happen on the actual aggregator classes\n+    static void registerAggregators(ValuesSourceRegistry valuesSourceRegistry) {\n+        valuesSourceRegistry.register(RareTermsAggregationBuilder.NAME,\n+            List.of(CoreValuesSourceType.BYTES, CoreValuesSourceType.IP),\n+            RareTermsAggregatorFactory.bytesSupplier());\n+\n+        valuesSourceRegistry.register(RareTermsAggregationBuilder.NAME,\n+            List.of(CoreValuesSourceType.DATE, CoreValuesSourceType.BOOLEAN, CoreValuesSourceType.NUMERIC),\n+            RareTermsAggregatorFactory.numericSupplier());\n+    }\n+\n+    /**\n+     * This supplier is used for all the field types that should be aggregated as bytes/strings,\n+     * including those that need global ordinals\n+     */\n+    private static RareTermsAggregatorSupplier bytesSupplier() {\n+        return new RareTermsAggregatorSupplier() {\n+            @Override\n+            public Aggregator build(String name,\n+                                    AggregatorFactories factories,\n+                                    ValuesSource valuesSource,\n+                                    DocValueFormat format,\n+                                    int maxDocCount,\n+                                    double precision,\n+                                    IncludeExclude includeExclude,\n+                                    SearchContext context,\n+                                    Aggregator parent,\n+                                    List<PipelineAggregator> pipelineAggregators,\n+                                    Map<String, Object> metaData) throws IOException {\n+\n+                ExecutionMode execution = ExecutionMode.MAP; //TODO global ords not implemented yet, only supports \"map\"\n+\n+                if ((includeExclude != null) && (includeExclude.isRegexBased()) && format != DocValueFormat.RAW) {\n+                    throw new AggregationExecutionException(\"Aggregation [\" + name + \"] cannot support \" +", "originalCommit": "d3bc413f0faa17238f9843146ae24f738f545133", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "00c78aa306602274db00fa3c2020007aa1de092e", "url": "https://github.com/elastic/elasticsearch/commit/00c78aa306602274db00fa3c2020007aa1de092e", "message": "Address review comments", "committedDate": "2020-02-12T19:15:18Z", "type": "commit"}, {"oid": "0d9f03a7982b4d84279b12046a5a34ea6c20f646", "url": "https://github.com/elastic/elasticsearch/commit/0d9f03a7982b4d84279b12046a5a34ea6c20f646", "message": "Checkstyle", "committedDate": "2020-02-13T12:38:16Z", "type": "commit"}, {"oid": "7c637a5646798952d1a6bc53dd9478ebb7754304", "url": "https://github.com/elastic/elasticsearch/commit/7c637a5646798952d1a6bc53dd9478ebb7754304", "message": "Tweak YAML test assertion\n\nMakes the catch more explicit (looking for the error) while also\nmaking it bwc across versions due to exception change", "committedDate": "2020-02-18T16:11:44Z", "type": "commit"}, {"oid": "a2108b4ca7bcb81a70b2c5580300913ec4017f7d", "url": "https://github.com/elastic/elasticsearch/commit/a2108b4ca7bcb81a70b2c5580300913ec4017f7d", "message": "Merge branch 'feature/extensible-values-source' into vs_rare_terms", "committedDate": "2020-02-19T19:04:27Z", "type": "commit"}, {"oid": "f1d366e822192b792344d9aca29df26ea75e1c51", "url": "https://github.com/elastic/elasticsearch/commit/f1d366e822192b792344d9aca29df26ea75e1c51", "message": "Merge branch 'feature/extensible-values-source' into vs_rare_terms", "committedDate": "2020-02-20T15:56:41Z", "type": "commit"}, {"oid": "96a64cd1f2037b5e38066cb3f3415d56589ef09f", "url": "https://github.com/elastic/elasticsearch/commit/96a64cd1f2037b5e38066cb3f3415d56589ef09f", "message": "Merge branch 'feature/extensible-values-source' into vs_rare_terms", "committedDate": "2020-02-24T16:52:18Z", "type": "commit"}]}