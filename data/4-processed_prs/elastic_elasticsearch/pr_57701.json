{"pr_number": 57701, "pr_title": "Disallow merging existing mapping field definitions in templates", "pr_createdAt": "2020-06-04T21:10:33Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/57701", "timeline": [{"oid": "b393e30af04a06fa08eff0ad21f43dca603af2e6", "url": "https://github.com/elastic/elasticsearch/commit/b393e30af04a06fa08eff0ad21f43dca603af2e6", "message": "Disallow merging existing mapping field definitions in templates\n\nThis commit changes the merge strategy introduced in #55607 and #55982. Instead of overwriting these\nfields, we now prevent them from being merged with an exception when a user attempts to\noverwrite a field.\n\nAs part of this, a more robust validation has been added. The existing validation checked whether\ntemplates (composable and component) were valid on their own, this new validation now checks that\nthe composite template (mappings/settings/aliases) is valid. This means that when a composable\ntemplate is added or updated, we confirm that it is valid with its component pieces. When a\ncomponent template is updated we ensure that all composable templates that make use of the component\ntemplate continue to be valid before allowing the component template to be updated.\n\nThis change also necessitated changes in the tests, however, I have left tests that exercise mapping\nmerging with nested object fields as `@AwaitsFix`, as we intend to change the behavior soon to allow\nmerging in a recursive-with-replacement fashion (see: #57393). I have added tests that check the new\ndisallowing behavior in the meantime.", "committedDate": "2020-06-04T21:00:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4MDIzOA==", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r435780238", "bodyText": "I thnik this could be expressed as, I find it a bit more readable, but maybe it's a personal preference so feel free to ignore\n        List<String> matchedPrefixes = results.keySet().stream().filter(k -> prefixes.contains(prefix(k))).collect(Collectors.toList())", "author": "andreidan", "createdAt": "2020-06-05T08:49:32Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "diffHunk": "@@ -687,18 +687,23 @@ private static void validateValuesAreMapsOfSizeOne(List<Map<String, Object>> sec\n     }\n \n     /**\n-     * Add the objects in the second map to the first, where the keys in the {@code second} map have\n-     * higher predecence and overwrite the keys in the {@code first} map. In the event of a key with\n-     * a dot in it (ie, \"foo.bar\"), the keys are treated as only the prefix counting towards\n-     * equality. If the {@code second} map has a key such as \"foo\", all keys starting from \"foo.\" in\n-     * the {@code first} map are discarded.\n+     * Add the objects in the second map to the first, A duplicated field is treated as illegal and\n+     * an exception is thrown.\n      */\n-    static Map<String, Object> mergeIgnoringDots(Map<String, Object> first, Map<String, Object> second) {\n+    static Map<String, Object> mergeFailingOnReplacement(Map<String, Object> first, Map<String, Object> second) {\n         Objects.requireNonNull(first, \"merging requires two non-null maps but the first map was null\");\n         Objects.requireNonNull(second, \"merging requires two non-null maps but the second map was null\");\n         Map<String, Object> results = new HashMap<>(first);\n         Set<String> prefixes = second.keySet().stream().map(MetadataCreateIndexService::prefix).collect(Collectors.toSet());\n-        results.keySet().removeIf(k -> prefixes.contains(prefix(k)));\n+        List<String> matchedPrefixes = new ArrayList<>();\n+        results.keySet().forEach(k -> {\n+            if (prefixes.contains(prefix(k))) {\n+                matchedPrefixes.add(k);\n+            }\n+        });", "originalCommit": "b393e30af04a06fa08eff0ad21f43dca603af2e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4MTE2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r435781169", "bodyText": "Nice!", "author": "andreidan", "createdAt": "2020-06-05T08:51:01Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -195,15 +195,21 @@ ClusterState addComponentTemplate(final ClusterState currentState, final boolean\n \n         validateTemplate(finalSettings, stringMappings, indicesService, xContentRegistry);\n \n+        // Collect all the composable (index) templates that use this component template, we'll use\n+        // this for validating that they're still going to be valid after this component template\n+        // has been updated\n+        final Map<String, ComposableIndexTemplate> templatesUsingComponent = currentState.metadata().templatesV2().entrySet().stream()\n+            .filter(e -> e.getValue().composedOf().contains(name))\n+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n         // if we're updating a component template, let's check if it's part of any V2 template that will yield the CT update invalid\n         if (create == false && finalSettings != null) {\n             // if the CT is specifying the `index.hidden` setting it cannot be part of any global template\n             if (IndexMetadata.INDEX_HIDDEN_SETTING.exists(finalSettings)) {\n-                Map<String, ComposableIndexTemplate> existingTemplates = currentState.metadata().templatesV2();\n                 List<String> globalTemplatesThatUseThisComponent = new ArrayList<>();\n-                for (Map.Entry<String, ComposableIndexTemplate> entry : existingTemplates.entrySet()) {\n+                for (Map.Entry<String, ComposableIndexTemplate> entry : templatesUsingComponent.entrySet()) {", "originalCommit": "b393e30af04a06fa08eff0ad21f43dca603af2e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4MzQwMw==", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r435783403", "bodyText": "the composite term is a bit confusing (at least for me) - we have composable templates so composite template made me think of a possible v3 template of sorts that might combine other templates. Would it make sense to reuse resolve(d) for the final configuration of a composable template? ie. validateResolvedComposableTemplate ? resolveAndValidateComposableTemplate ?\nWhat do you think?", "author": "andreidan", "createdAt": "2020-06-05T08:55:05Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -910,6 +951,77 @@ private static Settings resolveSettings(Metadata metadata, ComposableIndexTempla\n         return Collections.unmodifiableList(aliases);\n     }\n \n+    /**\n+     * Given a state and a composable template, validate that the final composite template\n+     * generated by the composable template and all of its component templates contains valid\n+     * settings, mappings, and aliases.\n+     */\n+    private static void validateCompositeTemplate(final ClusterState state,", "originalCommit": "b393e30af04a06fa08eff0ad21f43dca603af2e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTUwNw==", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r436445507", "bodyText": "I dunno, I didn't think they were too different, I wanted to treat \"resolved\" as pertaining to a particular index, so I think the current name isn't too bad.", "author": "dakrone", "createdAt": "2020-06-08T03:54:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4MzQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4NjIxMA==", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r435786210", "bodyText": "is this comment obsolete or misplaced?", "author": "andreidan", "createdAt": "2020-06-05T08:59:56Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -910,6 +951,77 @@ private static Settings resolveSettings(Metadata metadata, ComposableIndexTempla\n         return Collections.unmodifiableList(aliases);\n     }\n \n+    /**\n+     * Given a state and a composable template, validate that the final composite template\n+     * generated by the composable template and all of its component templates contains valid\n+     * settings, mappings, and aliases.\n+     */\n+    private static void validateCompositeTemplate(final ClusterState state,\n+                                                  final String templateName,\n+                                                  final ComposableIndexTemplate template,\n+                                                  final IndicesService indicesService,\n+                                                  final NamedXContentRegistry xContentRegistry) throws Exception {\n+        final ClusterState stateWithTemplate = ClusterState.builder(state)\n+            .metadata(Metadata.builder(state.metadata()).put(templateName, template))\n+            .build();\n+\n+        Index createdIndex = null;\n+        final String temporaryIndexName = \"validate-template-\" + UUIDs.randomBase64UUID().toLowerCase(Locale.ROOT);\n+        try {\n+            Settings resolvedSettings = resolveSettings(stateWithTemplate.metadata(), templateName);\n+\n+            // use the provided values, otherwise just pick valid dummy values\n+            int dummyPartitionSize = IndexMetadata.INDEX_ROUTING_PARTITION_SIZE_SETTING.get(resolvedSettings);\n+            int dummyShards = resolvedSettings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_SHARDS,\n+                dummyPartitionSize == 1 ? 1 : dummyPartitionSize + 1);\n+            int shardReplicas = resolvedSettings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0);\n+\n+\n+            //create index service for parsing and validating \"mappings\"\n+            Settings dummySettings = Settings.builder()", "originalCommit": "b393e30af04a06fa08eff0ad21f43dca603af2e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4NzExMg==", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r435787112", "bodyText": "also maybe dummySettings is not the best name as it includes the actual resolvedSettings? maybe finalIndexSettings or resolvedIndexSettings? What do you think?", "author": "andreidan", "createdAt": "2020-06-05T09:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4NjIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MjE1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r436442159", "bodyText": "Yep, I think that makes sense, going with finalResolvedSettings", "author": "dakrone", "createdAt": "2020-06-08T03:34:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4NjIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4OTUxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r435789519", "bodyText": "would using indicesService.withTempIndexService be better as it avoids adding.removing the index from the IndexService and also handles closing the indexService? (we're using this in TransportSimulateIndexTemplateAction)", "author": "andreidan", "createdAt": "2020-06-05T09:05:50Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -910,6 +951,77 @@ private static Settings resolveSettings(Metadata metadata, ComposableIndexTempla\n         return Collections.unmodifiableList(aliases);\n     }\n \n+    /**\n+     * Given a state and a composable template, validate that the final composite template\n+     * generated by the composable template and all of its component templates contains valid\n+     * settings, mappings, and aliases.\n+     */\n+    private static void validateCompositeTemplate(final ClusterState state,\n+                                                  final String templateName,\n+                                                  final ComposableIndexTemplate template,\n+                                                  final IndicesService indicesService,\n+                                                  final NamedXContentRegistry xContentRegistry) throws Exception {\n+        final ClusterState stateWithTemplate = ClusterState.builder(state)\n+            .metadata(Metadata.builder(state.metadata()).put(templateName, template))\n+            .build();\n+\n+        Index createdIndex = null;\n+        final String temporaryIndexName = \"validate-template-\" + UUIDs.randomBase64UUID().toLowerCase(Locale.ROOT);\n+        try {\n+            Settings resolvedSettings = resolveSettings(stateWithTemplate.metadata(), templateName);\n+\n+            // use the provided values, otherwise just pick valid dummy values\n+            int dummyPartitionSize = IndexMetadata.INDEX_ROUTING_PARTITION_SIZE_SETTING.get(resolvedSettings);\n+            int dummyShards = resolvedSettings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_SHARDS,\n+                dummyPartitionSize == 1 ? 1 : dummyPartitionSize + 1);\n+            int shardReplicas = resolvedSettings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0);\n+\n+\n+            //create index service for parsing and validating \"mappings\"\n+            Settings dummySettings = Settings.builder()\n+                .put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n+                .put(resolvedSettings)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, dummyShards)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, shardReplicas)\n+                .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID())\n+                .build();\n+\n+            // Validate index metadata (settings)\n+            final ClusterState stateWithIndex = ClusterState.builder(stateWithTemplate)\n+                .metadata(Metadata.builder(stateWithTemplate.metadata())\n+                    .put(IndexMetadata.builder(temporaryIndexName).settings(dummySettings))\n+                    .build())\n+                .build();\n+            final IndexMetadata tmpIndexMetadata = stateWithIndex.metadata().index(temporaryIndexName);\n+            IndexService dummyIndexService = indicesService.createIndex(tmpIndexMetadata, Collections.emptyList(), false);\n+            createdIndex = dummyIndexService.index();\n+\n+            // Validate aliases\n+            MetadataCreateIndexService.resolveAndValidateAliases(temporaryIndexName, Collections.emptySet(),\n+                MetadataIndexTemplateService.resolveAliases(stateWithIndex.metadata(), templateName), stateWithIndex.metadata(),\n+                new AliasValidator(),\n+                // the context is only used for validation so it's fine to pass fake values for the\n+                // shard id and the current timestamp\n+                xContentRegistry, dummyIndexService.newQueryShardContext(0, null, () -> 0L, null));", "originalCommit": "b393e30af04a06fa08eff0ad21f43dca603af2e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MzMzMA==", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r436443330", "bodyText": "Yes absolutely, I'll change this", "author": "dakrone", "createdAt": "2020-06-08T03:41:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4OTUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5NzUxNw==", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r435797517", "bodyText": "this and the next test names are rather confusing to me. It's quite difficult to pick up what they are testing and what's the invalid case. (maybe related to the previous comment too, but  \"composable composite\" adds to the confusion for me)\nwhat do you think of including the cause of failure in the test name?\nWhat do you think of something along the lines of  testIndexTemplateFailsToOverrideComponentTemplateMappingField and respectively testUpdateComponentTemplateFailsIfResolvedIndexTemplatesWouldBeInvalid ?", "author": "andreidan", "createdAt": "2020-06-05T09:20:21Z", "path": "server/src/test/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateServiceTests.java", "diffHunk": "@@ -859,6 +919,119 @@ public void testRemoveComponentTemplateInUse() throws Exception {\n             containsString(\"component templates [ct] cannot be removed as they are still in use by index templates [template]\"));\n     }\n \n+    /**\n+     * Tests that we check that settings/mappings/etc are valid even after template composition,\n+     * when adding/updating a composable index template\n+     */\n+    public void testInvalidComposableCompositeTemplate() throws Exception {", "originalCommit": "b393e30af04a06fa08eff0ad21f43dca603af2e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2646d9c5d2a54cca25cecf4edae4c04004cebf86", "url": "https://github.com/elastic/elasticsearch/commit/2646d9c5d2a54cca25cecf4edae4c04004cebf86", "message": "Use functional instead of imperative prefix collection", "committedDate": "2020-06-08T03:32:07Z", "type": "commit"}, {"oid": "53b8b9cc9317eb354a50b3401e02b0420d4d3f0a", "url": "https://github.com/elastic/elasticsearch/commit/53b8b9cc9317eb354a50b3401e02b0420d4d3f0a", "message": "Use IndexService.withTempIndexService", "committedDate": "2020-06-08T03:48:30Z", "type": "commit"}, {"oid": "9b3033202886f59d4b1396e2e8a3719c1b327b51", "url": "https://github.com/elastic/elasticsearch/commit/9b3033202886f59d4b1396e2e8a3719c1b327b51", "message": "Rename tests", "committedDate": "2020-06-08T03:48:34Z", "type": "commit"}, {"oid": "95aa23f41c4ca2e6ed2980cf44fac29960f0e76a", "url": "https://github.com/elastic/elasticsearch/commit/95aa23f41c4ca2e6ed2980cf44fac29960f0e76a", "message": "Fix tests", "committedDate": "2020-06-08T03:52:38Z", "type": "commit"}, {"oid": "766b754516d15b0bdfebf2a22af9da1cbf998443", "url": "https://github.com/elastic/elasticsearch/commit/766b754516d15b0bdfebf2a22af9da1cbf998443", "message": "Merge branch 'master' into itv2-validate-composite-templates", "committedDate": "2020-06-08T14:10:09Z", "type": "commit"}]}