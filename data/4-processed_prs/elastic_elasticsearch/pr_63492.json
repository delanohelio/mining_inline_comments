{"pr_number": 63492, "pr_title": "InternalSnapshotsInfoService should also removed failed snapshot shard size infos", "pr_createdAt": "2020-10-08T14:23:04Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/63492", "timeline": [{"oid": "d568084958570b5f366fcd63c072e1149cf622d0", "url": "https://github.com/elastic/elasticsearch/commit/d568084958570b5f366fcd63c072e1149cf622d0", "message": "Also clean up failed shards", "committedDate": "2020-10-08T14:18:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc3Mzg4MA==", "url": "https://github.com/elastic/elasticsearch/pull/63492#discussion_r501773880", "bodyText": "I made these changes so that the cluster state is better in line with a real cluster state containing an index to restore. Also, it allows to use an AllocationService to update the cluster state in order to initialize or start shards.", "author": "tlrx", "createdAt": "2020-10-08T14:37:48Z", "path": "server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java", "diffHunk": "@@ -326,24 +385,28 @@ private ClusterState addUnassignedShards(final ClusterState currentState, String\n             new IndexId(indexName, UUIDs.randomBase64UUID(random()))\n         );\n \n-        final Index index = metadata.get(indexName).getIndex();\n-        final IndexRoutingTable.Builder indexRoutingTable = IndexRoutingTable.builder(index);\n-        for (int primary = 0; primary < numberOfShards; primary++) {\n-            final ShardId shardId = new ShardId(index, primary);\n+        final IndexMetadata indexMetadata = metadata.get(indexName);\n+        final Index index = indexMetadata.getIndex();\n \n-            final IndexShardRoutingTable.Builder indexShards = new IndexShardRoutingTable.Builder(shardId);\n-            indexShards.addShard(TestShardRouting.newShardRouting(shardId, null, true, ShardRoutingState.UNASSIGNED, recoverySource));\n-            for (int replica = 0; replica < metadata.get(indexName).getNumberOfReplicas(); replica++) {\n-                indexShards.addShard(TestShardRouting.newShardRouting(shardId, null, false, ShardRoutingState.UNASSIGNED,\n-                    RecoverySource.PeerRecoverySource.INSTANCE));\n-            }\n-            indexRoutingTable.addIndexShard(indexShards.build());\n+        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());", "originalCommit": "d568084958570b5f366fcd63c072e1149cf622d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEzNzc0NA==", "url": "https://github.com/elastic/elasticsearch/pull/63492#discussion_r503137744", "bodyText": "TYPO: are cleaned up", "author": "original-brownbear", "createdAt": "2020-10-12T08:49:48Z", "path": "server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java", "diffHunk": "@@ -275,6 +281,54 @@ public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, In\n         });\n     }\n \n+    public void testCleanUpSnapshotShardSizes() throws Exception {\n+        final Repository mockRepository = new FilterRepository(mock(Repository.class)) {\n+            @Override\n+            public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+                if (randomBoolean()) {\n+                    throw new SnapshotException(new Snapshot(\"_repo\", snapshotId), \"simulated\");\n+                } else {\n+                    return IndexShardSnapshotStatus.newDone(0L, 0L, 0, 0, 0L, randomNonNegativeLong(), null);\n+                }\n+            }\n+        };\n+        when(repositoriesService.repository(\"_repo\")).thenReturn(mockRepository);\n+\n+        final InternalSnapshotsInfoService snapshotsInfoService =\n+            new InternalSnapshotsInfoService(Settings.EMPTY, clusterService, () -> repositoriesService, () -> rerouteService);\n+\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final int nbShards = randomIntBetween(1, 10);\n+\n+        applyClusterState(\"new snapshot restore for index \" + indexName,\n+            clusterState -> addUnassignedShards(clusterState, indexName, nbShards));\n+\n+        // waiting for snapshot shard size fetches to be executed, as we want to verify that they are clean up", "originalCommit": "d568084958570b5f366fcd63c072e1149cf622d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE0MDMyOA==", "url": "https://github.com/elastic/elasticsearch/pull/63492#discussion_r503140328", "bodyText": "NIT: you can save the conditional here by using:\nfinal RestoreInProgress.Builder restores = new RestoreInProgress.Builder(currentState.custom(RestoreInProgress.TYPE, RestoreInProgress.EMPTY))", "author": "original-brownbear", "createdAt": "2020-10-12T08:53:58Z", "path": "server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java", "diffHunk": "@@ -326,24 +385,28 @@ private ClusterState addUnassignedShards(final ClusterState currentState, String\n             new IndexId(indexName, UUIDs.randomBase64UUID(random()))\n         );\n \n-        final Index index = metadata.get(indexName).getIndex();\n-        final IndexRoutingTable.Builder indexRoutingTable = IndexRoutingTable.builder(index);\n-        for (int primary = 0; primary < numberOfShards; primary++) {\n-            final ShardId shardId = new ShardId(index, primary);\n+        final IndexMetadata indexMetadata = metadata.get(indexName);\n+        final Index index = indexMetadata.getIndex();\n \n-            final IndexShardRoutingTable.Builder indexShards = new IndexShardRoutingTable.Builder(shardId);\n-            indexShards.addShard(TestShardRouting.newShardRouting(shardId, null, true, ShardRoutingState.UNASSIGNED, recoverySource));\n-            for (int replica = 0; replica < metadata.get(indexName).getNumberOfReplicas(); replica++) {\n-                indexShards.addShard(TestShardRouting.newShardRouting(shardId, null, false, ShardRoutingState.UNASSIGNED,\n-                    RecoverySource.PeerRecoverySource.INSTANCE));\n-            }\n-            indexRoutingTable.addIndexShard(indexShards.build());\n+        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());\n+        routingTable.add(IndexRoutingTable.builder(index).initializeAsNewRestore(indexMetadata, recoverySource, new IntHashSet()).build());\n+\n+        final RestoreInProgress.Builder restores;\n+        if (currentState.custom(RestoreInProgress.TYPE) != null) {", "originalCommit": "d568084958570b5f366fcd63c072e1149cf622d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIyMjA0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/63492#discussion_r503222041", "bodyText": "Nice, thanks!", "author": "tlrx", "createdAt": "2020-10-12T11:13:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE0MDMyOA=="}], "type": "inlineReview"}, {"oid": "4d66b19c0401005d54cb0843539b93654f7660ac", "url": "https://github.com/elastic/elasticsearch/commit/4d66b19c0401005d54cb0843539b93654f7660ac", "message": "feedback", "committedDate": "2020-10-12T11:25:55Z", "type": "commit"}]}