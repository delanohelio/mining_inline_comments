{"pr_number": 64500, "pr_title": "Clean up MultiFields implementation", "pr_createdAt": "2020-11-02T18:57:09Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/64500", "timeline": [{"oid": "60ac353c81deee5539f98b516687db009c7bb5f6", "url": "https://github.com/elastic/elasticsearch/commit/60ac353c81deee5539f98b516687db009c7bb5f6", "message": "WIP", "committedDate": "2020-10-13T10:22:27Z", "type": "commit"}, {"oid": "d287714ca25748d6af4d44c387885afc917f9213", "url": "https://github.com/elastic/elasticsearch/commit/d287714ca25748d6af4d44c387885afc917f9213", "message": "Merge remote-tracking branch 'origin/master' into mapper/multifields-builder", "committedDate": "2020-11-02T17:27:42Z", "type": "commit"}, {"oid": "55599e3d038e3387c60db106cd2b9f54328e8418", "url": "https://github.com/elastic/elasticsearch/commit/55599e3d038e3387c60db106cd2b9f54328e8418", "message": "don't need to cast", "committedDate": "2020-11-02T18:57:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5NjUyNw==", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516296527", "bodyText": "I'm kind of surprised that there isn't a simpler way to do this. But, \ud83e\udd37", "author": "nik9000", "createdAt": "2020-11-02T22:35:41Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -163,7 +160,18 @@ protected final void createFieldNamesField(ParseContext context) {\n \n     @Override\n     public Iterator<Mapper> iterator() {\n-        return multiFields.iterator();\n+        Iterator<FieldMapper> multiFieldsIterator = multiFields.iterator();", "originalCommit": "55599e3d038e3387c60db106cd2b9f54328e8418", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjUxNTI0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516515247", "bodyText": "Java generics and inheritance continue to suck.", "author": "romseygeek", "createdAt": "2020-11-03T09:10:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5NjUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5Njg0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516296845", "bodyText": "Yeah, I don't imagine ImmutableOpenMap is buying us too much. Might be worth git blame to see if there is anything back in the mists of time explaining it.", "author": "nik9000", "createdAt": "2020-11-02T22:36:27Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -284,72 +292,58 @@ protected void doXContentBody(XContentBuilder builder, boolean includeDefaults,\n \n     protected abstract String contentType();\n \n-    public static class MultiFields implements Iterable<Mapper> {\n+    public static class MultiFields implements Iterable<FieldMapper> {\n \n         public static MultiFields empty() {\n-            return new MultiFields(ImmutableOpenMap.<String, FieldMapper>of());\n+            return new MultiFields(Collections.emptyMap());\n         }\n \n         public static class Builder {\n \n-            private final ImmutableOpenMap.Builder<String, Mapper.Builder> mapperBuilders = ImmutableOpenMap.builder();\n+            private final Map<String, Function<BuilderContext, FieldMapper>> mapperBuilders = new HashMap<>();", "originalCommit": "55599e3d038e3387c60db106cd2b9f54328e8418", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjUxNjEwMg==", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516516102", "bodyText": "I did some digging and this appears to have been there since the beginning, when ImmutableOpenMap was used all over the place.  I think it was initially supposed to be slightly more memory efficient, and the immutability was a nice add-on, but more modern JVMs and Collections.immutableMap() make that matter less.", "author": "romseygeek", "createdAt": "2020-11-03T09:11:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5Njg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5OTIwMg==", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516299202", "bodyText": "Wrap in unmodifiableMap or call Map.of on it? Just for extra double paranoia that it is immutable.", "author": "nik9000", "createdAt": "2020-11-02T22:39:55Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -284,72 +292,58 @@ protected void doXContentBody(XContentBuilder builder, boolean includeDefaults,\n \n     protected abstract String contentType();\n \n-    public static class MultiFields implements Iterable<Mapper> {\n+    public static class MultiFields implements Iterable<FieldMapper> {\n \n         public static MultiFields empty() {\n-            return new MultiFields(ImmutableOpenMap.<String, FieldMapper>of());\n+            return new MultiFields(Collections.emptyMap());\n         }\n \n         public static class Builder {\n \n-            private final ImmutableOpenMap.Builder<String, Mapper.Builder> mapperBuilders = ImmutableOpenMap.builder();\n+            private final Map<String, Function<BuilderContext, FieldMapper>> mapperBuilders = new HashMap<>();\n \n-            public Builder add(Mapper.Builder builder) {\n-                mapperBuilders.put(builder.name(), builder);\n+            public Builder add(FieldMapper.Builder builder) {\n+                mapperBuilders.put(builder.name(), builder::build);\n                 return this;\n             }\n \n-            public Builder add(Mapper mapper) {\n-                mapperBuilders.put(mapper.simpleName(), new Mapper.Builder(mapper.simpleName()) {\n-                    @Override\n-                    public Mapper build(BuilderContext context) {\n-                        return mapper;\n-                    }\n-                });\n+            public Builder add(FieldMapper mapper) {\n+                mapperBuilders.put(mapper.simpleName(), context -> mapper);\n                 return this;\n             }\n \n-            public Builder update(Mapper toMerge, ContentPath contentPath) {\n+            public Builder update(FieldMapper toMerge, ContentPath contentPath) {\n                 if (mapperBuilders.containsKey(toMerge.simpleName()) == false) {\n                     add(toMerge);\n                 } else {\n-                    Mapper.Builder builder = mapperBuilders.get(toMerge.simpleName());\n-                    Mapper existing = builder.build(new BuilderContext(Settings.EMPTY, contentPath));\n+                    FieldMapper existing\n+                        = mapperBuilders.get(toMerge.simpleName()).apply(new BuilderContext(Settings.EMPTY, contentPath));\n                     add(existing.merge(toMerge));\n                 }\n                 return this;\n             }\n \n-            @SuppressWarnings(\"unchecked\")\n             public MultiFields build(Mapper.Builder mainFieldBuilder, BuilderContext context) {\n                 if (mapperBuilders.isEmpty()) {\n                     return empty();\n                 } else {\n+                    Map<String, FieldMapper> mappers = new HashMap<>();\n                     context.path().add(mainFieldBuilder.name());\n-                    ImmutableOpenMap.Builder mapperBuilders = this.mapperBuilders;\n-                    for (ObjectObjectCursor<String, Mapper.Builder> cursor : this.mapperBuilders) {\n-                        String key = cursor.key;\n-                        Mapper.Builder value = cursor.value;\n-                        Mapper mapper = value.build(context);\n-                        assert mapper instanceof FieldMapper;\n-                        mapperBuilders.put(key, mapper);\n+                    for (Map.Entry<String, Function<BuilderContext, FieldMapper>> entry : this.mapperBuilders.entrySet()) {\n+                        String key = entry.getKey();\n+                        FieldMapper mapper = entry.getValue().apply(context);\n+                        mappers.put(key, mapper);\n                     }\n                     context.path().remove();\n-                    ImmutableOpenMap.Builder<String, FieldMapper> mappers = mapperBuilders.cast();\n-                    return new MultiFields(mappers.build());\n+                    return new MultiFields(mappers);", "originalCommit": "55599e3d038e3387c60db106cd2b9f54328e8418", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5OTgyOA==", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516299828", "bodyText": "Weird. That, like, doesn't do anything, right?", "author": "nik9000", "createdAt": "2020-11-02T22:40:38Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -284,72 +292,58 @@ protected void doXContentBody(XContentBuilder builder, boolean includeDefaults,\n \n     protected abstract String contentType();\n \n-    public static class MultiFields implements Iterable<Mapper> {\n+    public static class MultiFields implements Iterable<FieldMapper> {\n \n         public static MultiFields empty() {\n-            return new MultiFields(ImmutableOpenMap.<String, FieldMapper>of());\n+            return new MultiFields(Collections.emptyMap());\n         }\n \n         public static class Builder {\n \n-            private final ImmutableOpenMap.Builder<String, Mapper.Builder> mapperBuilders = ImmutableOpenMap.builder();\n+            private final Map<String, Function<BuilderContext, FieldMapper>> mapperBuilders = new HashMap<>();\n \n-            public Builder add(Mapper.Builder builder) {\n-                mapperBuilders.put(builder.name(), builder);\n+            public Builder add(FieldMapper.Builder builder) {\n+                mapperBuilders.put(builder.name(), builder::build);\n                 return this;\n             }\n \n-            public Builder add(Mapper mapper) {\n-                mapperBuilders.put(mapper.simpleName(), new Mapper.Builder(mapper.simpleName()) {\n-                    @Override\n-                    public Mapper build(BuilderContext context) {\n-                        return mapper;\n-                    }\n-                });\n+            public Builder add(FieldMapper mapper) {\n+                mapperBuilders.put(mapper.simpleName(), context -> mapper);\n                 return this;\n             }\n \n-            public Builder update(Mapper toMerge, ContentPath contentPath) {\n+            public Builder update(FieldMapper toMerge, ContentPath contentPath) {\n                 if (mapperBuilders.containsKey(toMerge.simpleName()) == false) {\n                     add(toMerge);\n                 } else {\n-                    Mapper.Builder builder = mapperBuilders.get(toMerge.simpleName());\n-                    Mapper existing = builder.build(new BuilderContext(Settings.EMPTY, contentPath));\n+                    FieldMapper existing\n+                        = mapperBuilders.get(toMerge.simpleName()).apply(new BuilderContext(Settings.EMPTY, contentPath));\n                     add(existing.merge(toMerge));\n                 }\n                 return this;\n             }\n \n-            @SuppressWarnings(\"unchecked\")\n             public MultiFields build(Mapper.Builder mainFieldBuilder, BuilderContext context) {\n                 if (mapperBuilders.isEmpty()) {\n                     return empty();\n                 } else {\n+                    Map<String, FieldMapper> mappers = new HashMap<>();\n                     context.path().add(mainFieldBuilder.name());\n-                    ImmutableOpenMap.Builder mapperBuilders = this.mapperBuilders;\n-                    for (ObjectObjectCursor<String, Mapper.Builder> cursor : this.mapperBuilders) {\n-                        String key = cursor.key;\n-                        Mapper.Builder value = cursor.value;\n-                        Mapper mapper = value.build(context);\n-                        assert mapper instanceof FieldMapper;\n-                        mapperBuilders.put(key, mapper);\n+                    for (Map.Entry<String, Function<BuilderContext, FieldMapper>> entry : this.mapperBuilders.entrySet()) {\n+                        String key = entry.getKey();\n+                        FieldMapper mapper = entry.getValue().apply(context);\n+                        mappers.put(key, mapper);\n                     }\n                     context.path().remove();\n-                    ImmutableOpenMap.Builder<String, FieldMapper> mappers = mapperBuilders.cast();\n-                    return new MultiFields(mappers.build());\n+                    return new MultiFields(mappers);\n                 }\n             }\n         }\n \n-        private final ImmutableOpenMap<String, FieldMapper> mappers;\n+        private final Map<String, FieldMapper> mappers;\n \n-        private MultiFields(ImmutableOpenMap<String, FieldMapper> mappers) {\n-            ImmutableOpenMap.Builder<String, FieldMapper> builder = new ImmutableOpenMap.Builder<>();\n-            // we disable the all in multi-field mappers\n-            for (ObjectObjectCursor<String, FieldMapper> cursor : mappers) {\n-                builder.put(cursor.key, cursor.value);\n-            }\n-            this.mappers = builder.build();", "originalCommit": "55599e3d038e3387c60db106cd2b9f54328e8418", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU1NTU4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516555582", "bodyText": "I guess it used to, hence the comment, but no longer indeed", "author": "romseygeek", "createdAt": "2020-11-03T10:14:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5OTgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMTEzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516301139", "bodyText": "Same comment about double super paranoid immutability.", "author": "nik9000", "createdAt": "2020-11-02T22:42:12Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -362,45 +356,37 @@ public void parse(FieldMapper mainField, ParseContext context) throws IOExceptio\n             context = context.createMultiFieldContext();\n \n             context.path().add(mainField.simpleName());\n-            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {\n-                cursor.value.parse(context);\n+            for (FieldMapper mapper : mappers.values()) {\n+                mapper.parse(context);\n             }\n             context.path().remove();\n         }\n \n         public MultiFields merge(MultiFields mergeWith) {\n-            ImmutableOpenMap.Builder<String, FieldMapper> newMappersBuilder = ImmutableOpenMap.builder(mappers);\n-\n-            for (ObjectCursor<FieldMapper> cursor : mergeWith.mappers.values()) {\n-                FieldMapper mergeWithMapper = cursor.value;\n-                FieldMapper mergeIntoMapper = mappers.get(mergeWithMapper.simpleName());\n+            Map<String, FieldMapper> newMappers = new HashMap<>();\n+            for (FieldMapper mapper : mergeWith.mappers.values()) {\n+                FieldMapper mergeIntoMapper = mappers.get(mapper.simpleName());\n                 if (mergeIntoMapper == null) {\n-                    newMappersBuilder.put(mergeWithMapper.simpleName(), mergeWithMapper);\n+                    newMappers.put(mapper.simpleName(), mapper);\n                 } else {\n-                    FieldMapper merged = mergeIntoMapper.merge(mergeWithMapper);\n-                    newMappersBuilder.put(merged.simpleName(), merged); // override previous definition\n+                    FieldMapper merged = mergeIntoMapper.merge(mapper);\n+                    newMappers.put(merged.simpleName(), merged); // override previous definition\n                 }\n             }\n-\n-            ImmutableOpenMap<String, FieldMapper> mappers = newMappersBuilder.build();\n-            return new MultiFields(mappers);\n+            return new MultiFields(newMappers);", "originalCommit": "55599e3d038e3387c60db106cd2b9f54328e8418", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMTY1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516301657", "bodyText": "I'm so happy we sorted this. I know we did it for an odd reason around loops in mapping updates, but it just makes the output nicer to read.", "author": "nik9000", "createdAt": "2020-11-02T22:42:50Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -362,45 +356,37 @@ public void parse(FieldMapper mainField, ParseContext context) throws IOExceptio\n             context = context.createMultiFieldContext();\n \n             context.path().add(mainField.simpleName());\n-            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {\n-                cursor.value.parse(context);\n+            for (FieldMapper mapper : mappers.values()) {\n+                mapper.parse(context);\n             }\n             context.path().remove();\n         }\n \n         public MultiFields merge(MultiFields mergeWith) {\n-            ImmutableOpenMap.Builder<String, FieldMapper> newMappersBuilder = ImmutableOpenMap.builder(mappers);\n-\n-            for (ObjectCursor<FieldMapper> cursor : mergeWith.mappers.values()) {\n-                FieldMapper mergeWithMapper = cursor.value;\n-                FieldMapper mergeIntoMapper = mappers.get(mergeWithMapper.simpleName());\n+            Map<String, FieldMapper> newMappers = new HashMap<>();\n+            for (FieldMapper mapper : mergeWith.mappers.values()) {\n+                FieldMapper mergeIntoMapper = mappers.get(mapper.simpleName());\n                 if (mergeIntoMapper == null) {\n-                    newMappersBuilder.put(mergeWithMapper.simpleName(), mergeWithMapper);\n+                    newMappers.put(mapper.simpleName(), mapper);\n                 } else {\n-                    FieldMapper merged = mergeIntoMapper.merge(mergeWithMapper);\n-                    newMappersBuilder.put(merged.simpleName(), merged); // override previous definition\n+                    FieldMapper merged = mergeIntoMapper.merge(mapper);\n+                    newMappers.put(merged.simpleName(), merged); // override previous definition\n                 }\n             }\n-\n-            ImmutableOpenMap<String, FieldMapper> mappers = newMappersBuilder.build();\n-            return new MultiFields(mappers);\n+            return new MultiFields(newMappers);\n         }\n \n         @Override\n-        public Iterator<Mapper> iterator() {\n-            return StreamSupport.stream(mappers.values().spliterator(), false).map((p) -> (Mapper)p.value).iterator();\n+        public Iterator<FieldMapper> iterator() {\n+            return mappers.values().iterator();\n         }\n \n         public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n             if (!mappers.isEmpty()) {\n                 // sort the mappers so we get consistent serialization format\n-                Mapper[] sortedMappers = mappers.values().toArray(Mapper.class);\n-                Arrays.sort(sortedMappers, new Comparator<Mapper>() {\n-                    @Override\n-                    public int compare(Mapper o1, Mapper o2) {\n-                        return o1.name().compareTo(o2.name());\n-                    }\n-                });\n+                List<Mapper> sortedMappers = mappers.values().stream()", "originalCommit": "55599e3d038e3387c60db106cd2b9f54328e8418", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMzQxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516303415", "bodyText": "I wonder, not that it matters, but, is it faster to do list = new List(mappers.values()); Collections.sort(list);. Sorting a stream feels funny to me because it is a forwards only data structure and feels like it'll amount to just sorting anyway. Whatever. It super doesn't matter.", "author": "nik9000", "createdAt": "2020-11-02T22:45:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMTY1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwNDEwMA==", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516304100", "bodyText": "Oh! It's worth triple checking that this doesn't change the order from before. It sure looks the same to me but please make sure we have a test. We need the same order as before or things can get \"fun\" in a mixed version cluster.", "author": "nik9000", "createdAt": "2020-11-02T22:46:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMTY1Nw=="}], "type": "inlineReview"}, {"oid": "ffdff2a81fa62ea3ac1ca34474cf1a1ef29c6462", "url": "https://github.com/elastic/elasticsearch/commit/ffdff2a81fa62ea3ac1ca34474cf1a1ef29c6462", "message": "Immutability; add tests for sort order", "committedDate": "2020-11-03T10:08:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2ODU5NA==", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r517368594", "bodyText": "I'd make this a Set because weird things will happen if there are dupes, I think.", "author": "nik9000", "createdAt": "2020-11-04T14:08:47Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/MultiFieldsSerializationTests.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import static org.hamcrest.Matchers.greaterThan;\n+\n+public class MultiFieldsSerializationTests extends ESTestCase {\n+\n+    public void testSorting() {\n+\n+        FieldMapper.MultiFields.Builder builder = new FieldMapper.MultiFields.Builder();\n+\n+        List<String> names = new ArrayList<>();", "originalCommit": "ffdff2a81fa62ea3ac1ca34474cf1a1ef29c6462", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b9a4509c1e581268eefc02c5e4d7f627321ed0d0", "url": "https://github.com/elastic/elasticsearch/commit/b9a4509c1e581268eefc02c5e4d7f627321ed0d0", "message": "Merge remote-tracking branch 'origin/master' into mapper/multifields-builder", "committedDate": "2020-11-04T16:14:44Z", "type": "commit"}, {"oid": "45f037205ece7650bb1de864438ca9dc309ed438", "url": "https://github.com/elastic/elasticsearch/commit/45f037205ece7650bb1de864438ca9dc309ed438", "message": "Harden test against random shenanigans", "committedDate": "2020-11-04T16:15:53Z", "type": "commit"}]}