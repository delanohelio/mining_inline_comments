{"pr_number": 62230, "pr_title": "Rationalise fetch phase exceptions", "pr_createdAt": "2020-09-10T14:04:38Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62230", "timeline": [{"oid": "7966f1e4c2baedca0f5252745f5876cdf8fdfac5", "url": "https://github.com/elastic/elasticsearch/commit/7966f1e4c2baedca0f5252745f5876cdf8fdfac5", "message": "Rationalise fetch phase exceptions", "committedDate": "2020-09-10T13:54:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNTAzMg==", "url": "https://github.com/elastic/elasticsearch/pull/62230#discussion_r486505032", "bodyText": "Double-checking that none of this logic changed, you just removed the try/ catch? The git diff is probably just unintuitive.", "author": "jtibshirani", "createdAt": "2020-09-10T17:14:19Z", "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/highlight/FastVectorHighlighter.java", "diffHunk": "@@ -87,126 +86,119 @@ public HighlightField highlight(FieldHighlightContext fieldContext) {\n             hitContext.cache().put(CACHE_KEY, new HighlighterEntry());\n         }\n         HighlighterEntry cache = (HighlighterEntry) hitContext.cache().get(CACHE_KEY);\n-\n-        try {\n-            FieldHighlightEntry entry = cache.fields.get(fieldType);\n-            if (entry == null) {\n-                FragListBuilder fragListBuilder;\n-                BaseFragmentsBuilder fragmentsBuilder;\n-\n-                final BoundaryScanner boundaryScanner = getBoundaryScanner(field);\n-                if (field.fieldOptions().numberOfFragments() == 0) {\n-                    fragListBuilder = new SingleFragListBuilder();\n-\n+        FieldHighlightEntry entry = cache.fields.get(fieldType);", "originalCommit": "7966f1e4c2baedca0f5252745f5876cdf8fdfac5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUxMzI3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62230#discussion_r487513276", "bodyText": "Yes, that's correct.", "author": "romseygeek", "createdAt": "2020-09-13T10:47:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNTAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxMTU1MA==", "url": "https://github.com/elastic/elasticsearch/pull/62230#discussion_r486511550", "bodyText": "Does this change the behavior? I'm not sure if we previously swallowed InvalidTokenOffsetsException.", "author": "jtibshirani", "createdAt": "2020-09-10T17:25:18Z", "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/highlight/PlainHighlighter.java", "diffHunk": "@@ -111,56 +109,42 @@ public HighlightField highlight(FieldHighlightContext fieldContext) {\n         }\n         final int maxAnalyzedOffset = context.getIndexSettings().getHighlightMaxAnalyzedOffset();\n \n-        try {\n-            textsToHighlight = HighlightUtils.loadFieldValues(fieldType, hitContext, fieldContext.forceSource);\n+        textsToHighlight = HighlightUtils.loadFieldValues(fieldType, hitContext, fieldContext.forceSource);\n \n-            for (Object textToHighlight : textsToHighlight) {\n-                String text = convertFieldValue(fieldType, textToHighlight);\n-                int textLength = text.length();\n-                if (keywordIgnoreAbove != null  && textLength > keywordIgnoreAbove) {\n-                    continue; // skip highlighting keyword terms that were ignored during indexing\n-                }\n-                if (textLength > maxAnalyzedOffset) {\n-                    throw new IllegalArgumentException(\n-                        \"The length of [\" + fieldContext.fieldName + \"] field of [\" + hitContext.hit().getId() +\n-                            \"] doc of [\" + context.index().getName() + \"] index \" +\n-                            \"has exceeded [\" + maxAnalyzedOffset + \"] - maximum allowed to be analyzed for highlighting. \" +\n-                            \"This maximum can be set by changing the [\" + IndexSettings.MAX_ANALYZED_OFFSET_SETTING.getKey() +\n-                            \"] index level setting. \" + \"For large texts, indexing with offsets or term vectors, and highlighting \" +\n-                            \"with unified or fvh highlighter is recommended!\");\n-                }\n+        for (Object textToHighlight : textsToHighlight) {\n+            String text = convertFieldValue(fieldType, textToHighlight);\n+            int textLength = text.length();\n+            if (keywordIgnoreAbove != null && textLength > keywordIgnoreAbove) {\n+                continue; // skip highlighting keyword terms that were ignored during indexing\n+            }\n+            if (textLength > maxAnalyzedOffset) {\n+                throw new IllegalArgumentException(\n+                    \"The length of [\" + fieldContext.fieldName + \"] field of [\" + hitContext.hit().getId() +\n+                        \"] doc of [\" + context.index().getName() + \"] index \" +\n+                        \"has exceeded [\" + maxAnalyzedOffset + \"] - maximum allowed to be analyzed for highlighting. \" +\n+                        \"This maximum can be set by changing the [\" + IndexSettings.MAX_ANALYZED_OFFSET_SETTING.getKey() +\n+                        \"] index level setting. \" + \"For large texts, indexing with offsets or term vectors, and highlighting \" +\n+                        \"with unified or fvh highlighter is recommended!\");\n+            }\n \n-                try (TokenStream tokenStream = analyzer.tokenStream(fieldType.name(), text)) {\n-                    if (!tokenStream.hasAttribute(CharTermAttribute.class) || !tokenStream.hasAttribute(OffsetAttribute.class)) {\n-                        // can't perform highlighting if the stream has no terms (binary token stream) or no offsets\n-                        continue;\n-                    }\n-                    TextFragment[] bestTextFragments = entry.getBestTextFragments(tokenStream, text, false, numberOfFragments);\n-                    for (TextFragment bestTextFragment : bestTextFragments) {\n-                        if (bestTextFragment != null && bestTextFragment.getScore() > 0) {\n-                            fragsList.add(bestTextFragment);\n-                        }\n+            try (TokenStream tokenStream = analyzer.tokenStream(fieldType.name(), text)) {\n+                if (!tokenStream.hasAttribute(CharTermAttribute.class) || !tokenStream.hasAttribute(OffsetAttribute.class)) {\n+                    // can't perform highlighting if the stream has no terms (binary token stream) or no offsets\n+                    continue;\n+                }\n+                TextFragment[] bestTextFragments = entry.getBestTextFragments(tokenStream, text, false, numberOfFragments);\n+                for (TextFragment bestTextFragment : bestTextFragments) {\n+                    if (bestTextFragment != null && bestTextFragment.getScore() > 0) {\n+                        fragsList.add(bestTextFragment);\n                     }\n                 }\n-            }\n-        } catch (Exception e) {\n-            if (ExceptionsHelper.unwrap(e, BytesRefHash.MaxBytesLengthExceededException.class) != null) {\n-                // this can happen if for example a field is not_analyzed and ignore_above option is set.\n-                // the field will be ignored when indexing but the huge term is still in the source and\n-                // the plain highlighter will parse the source and try to analyze it.\n-                return null;\n-            } else {\n-                throw new FetchPhaseExecutionException(fieldContext.shardTarget,\n-                    \"Failed to highlight field [\" + fieldContext.fieldName + \"]\", e);\n+            } catch (InvalidTokenOffsetsException | BytesRefHash.MaxBytesLengthExceededException e) {", "originalCommit": "7966f1e4c2baedca0f5252745f5876cdf8fdfac5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUxMzQwMw==", "url": "https://github.com/elastic/elasticsearch/pull/62230#discussion_r487513403", "bodyText": "Well spotted, we need to rethrow InvalidTokenOffsetsException.  I've changed the outer loop in FetchPhase to catch generic Exceptions and rethrow them as FetchPhaseExecutionExceptions, so that we also properly handle this case as well as various other places in highlighting code that throw IllegalArgumentException.  There's a lot more cleanup that can be done around the highlighters, I think!", "author": "romseygeek", "createdAt": "2020-09-13T10:48:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxMTU1MA=="}], "type": "inlineReview"}, {"oid": "898b2d00044805bf9eb5ceb03610e6095b92c908", "url": "https://github.com/elastic/elasticsearch/commit/898b2d00044805bf9eb5ceb03610e6095b92c908", "message": "feedback", "committedDate": "2020-09-12T15:54:42Z", "type": "commit"}, {"oid": "f2d567420dc07b1b7b5dd0893a65f4f1b3140e0f", "url": "https://github.com/elastic/elasticsearch/commit/f2d567420dc07b1b7b5dd0893a65f4f1b3140e0f", "message": "Merge branch 'master' into fetch/exceptions", "committedDate": "2020-09-13T10:49:12Z", "type": "commit"}, {"oid": "25051501b4327146d84397d8189429028e444018", "url": "https://github.com/elastic/elasticsearch/commit/25051501b4327146d84397d8189429028e444018", "message": "Merge branch 'master' into fetch/exceptions", "committedDate": "2020-09-14T09:17:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0NTExMw==", "url": "https://github.com/elastic/elasticsearch/pull/62230#discussion_r488045113", "bodyText": "Sorry if I'm missing something, why does InvalidTokenOffsetsException need special treatment?\nAlso maybe we can keep the comment explaining why we're skipping BytesRefHash.MaxBytesLengthExceededException?", "author": "jtibshirani", "createdAt": "2020-09-14T15:57:33Z", "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/highlight/PlainHighlighter.java", "diffHunk": "@@ -111,56 +109,44 @@ public HighlightField highlight(FieldHighlightContext fieldContext) {\n         }\n         final int maxAnalyzedOffset = context.getIndexSettings().getHighlightMaxAnalyzedOffset();\n \n-        try {\n-            textsToHighlight = HighlightUtils.loadFieldValues(fieldType, hitContext, fieldContext.forceSource);\n+        textsToHighlight = HighlightUtils.loadFieldValues(fieldType, hitContext, fieldContext.forceSource);\n \n-            for (Object textToHighlight : textsToHighlight) {\n-                String text = convertFieldValue(fieldType, textToHighlight);\n-                int textLength = text.length();\n-                if (keywordIgnoreAbove != null  && textLength > keywordIgnoreAbove) {\n-                    continue; // skip highlighting keyword terms that were ignored during indexing\n-                }\n-                if (textLength > maxAnalyzedOffset) {\n-                    throw new IllegalArgumentException(\n-                        \"The length of [\" + fieldContext.fieldName + \"] field of [\" + hitContext.hit().getId() +\n-                            \"] doc of [\" + context.index().getName() + \"] index \" +\n-                            \"has exceeded [\" + maxAnalyzedOffset + \"] - maximum allowed to be analyzed for highlighting. \" +\n-                            \"This maximum can be set by changing the [\" + IndexSettings.MAX_ANALYZED_OFFSET_SETTING.getKey() +\n-                            \"] index level setting. \" + \"For large texts, indexing with offsets or term vectors, and highlighting \" +\n-                            \"with unified or fvh highlighter is recommended!\");\n-                }\n+        for (Object textToHighlight : textsToHighlight) {\n+            String text = convertFieldValue(fieldType, textToHighlight);\n+            int textLength = text.length();\n+            if (keywordIgnoreAbove != null && textLength > keywordIgnoreAbove) {\n+                continue; // skip highlighting keyword terms that were ignored during indexing\n+            }\n+            if (textLength > maxAnalyzedOffset) {\n+                throw new IllegalArgumentException(\n+                    \"The length of [\" + fieldContext.fieldName + \"] field of [\" + hitContext.hit().getId() +\n+                        \"] doc of [\" + context.index().getName() + \"] index \" +\n+                        \"has exceeded [\" + maxAnalyzedOffset + \"] - maximum allowed to be analyzed for highlighting. \" +\n+                        \"This maximum can be set by changing the [\" + IndexSettings.MAX_ANALYZED_OFFSET_SETTING.getKey() +\n+                        \"] index level setting. \" + \"For large texts, indexing with offsets or term vectors, and highlighting \" +\n+                        \"with unified or fvh highlighter is recommended!\");\n+            }\n \n-                try (TokenStream tokenStream = analyzer.tokenStream(fieldType.name(), text)) {\n-                    if (!tokenStream.hasAttribute(CharTermAttribute.class) || !tokenStream.hasAttribute(OffsetAttribute.class)) {\n-                        // can't perform highlighting if the stream has no terms (binary token stream) or no offsets\n-                        continue;\n-                    }\n-                    TextFragment[] bestTextFragments = entry.getBestTextFragments(tokenStream, text, false, numberOfFragments);\n-                    for (TextFragment bestTextFragment : bestTextFragments) {\n-                        if (bestTextFragment != null && bestTextFragment.getScore() > 0) {\n-                            fragsList.add(bestTextFragment);\n-                        }\n+            try (TokenStream tokenStream = analyzer.tokenStream(fieldType.name(), text)) {\n+                if (!tokenStream.hasAttribute(CharTermAttribute.class) || !tokenStream.hasAttribute(OffsetAttribute.class)) {\n+                    // can't perform highlighting if the stream has no terms (binary token stream) or no offsets\n+                    continue;\n+                }\n+                TextFragment[] bestTextFragments = entry.getBestTextFragments(tokenStream, text, false, numberOfFragments);\n+                for (TextFragment bestTextFragment : bestTextFragments) {\n+                    if (bestTextFragment != null && bestTextFragment.getScore() > 0) {\n+                        fragsList.add(bestTextFragment);\n                     }\n                 }\n-            }\n-        } catch (Exception e) {\n-            if (ExceptionsHelper.unwrap(e, BytesRefHash.MaxBytesLengthExceededException.class) != null) {\n-                // this can happen if for example a field is not_analyzed and ignore_above option is set.\n-                // the field will be ignored when indexing but the huge term is still in the source and\n-                // the plain highlighter will parse the source and try to analyze it.\n-                return null;\n-            } else {\n-                throw new FetchPhaseExecutionException(fieldContext.shardTarget,\n-                    \"Failed to highlight field [\" + fieldContext.fieldName + \"]\", e);\n+            } catch (BytesRefHash.MaxBytesLengthExceededException e) {\n+                // ignore and continue to the next value", "originalCommit": "25051501b4327146d84397d8189429028e444018", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA2Mzg0MA==", "url": "https://github.com/elastic/elasticsearch/pull/62230#discussion_r488063840", "bodyText": "We need special treatment because Highlighter#getBestTextFragments is declared as throwing InvalidTokenOffsetsException, which just extends plain Exception.  It doesn't feel correct rethrowing as an IOException (because it isn't one!) so wrapping in an IllegalArgumentException seems like a happy compromise.  It will be caught and translated to a FetchPhaseExecutionException by FetchPhase.\n++ to add the explanatory comment back", "author": "romseygeek", "createdAt": "2020-09-14T16:25:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0NTExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA2NTk1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62230#discussion_r488065959", "bodyText": "Got it, thanks! I had missed that it was a checked exception.", "author": "jtibshirani", "createdAt": "2020-09-14T16:29:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0NTExMw=="}], "type": "inlineReview"}, {"oid": "35363d15b0cef8dbf3e5c8535e16ff6bb7a426c3", "url": "https://github.com/elastic/elasticsearch/commit/35363d15b0cef8dbf3e5c8535e16ff6bb7a426c3", "message": "Merge remote-tracking branch 'origin/master' into fetch/exceptions", "committedDate": "2020-09-14T16:21:17Z", "type": "commit"}, {"oid": "33992c50edd742474a70e34e3530ac82672422cc", "url": "https://github.com/elastic/elasticsearch/commit/33992c50edd742474a70e34e3530ac82672422cc", "message": "add comment back", "committedDate": "2020-09-14T16:26:12Z", "type": "commit"}, {"oid": "67cb9b0b353ae652eb8b25e54bd84a509fc78d9e", "url": "https://github.com/elastic/elasticsearch/commit/67cb9b0b353ae652eb8b25e54bd84a509fc78d9e", "message": "Merge remote-tracking branch 'romseygeek/fetch/exceptions' into fetch/exceptions", "committedDate": "2020-09-14T16:26:24Z", "type": "commit"}]}