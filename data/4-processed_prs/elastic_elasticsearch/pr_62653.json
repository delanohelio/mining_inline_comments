{"pr_number": 62653, "pr_title": "[DOCS] Add docs for runtime fields", "pr_createdAt": "2020-09-18T17:17:21Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62653", "timeline": [{"oid": "1eebe84620386b0d050d0edf2f2b04bef2599b08", "url": "https://github.com/elastic/elasticsearch/commit/1eebe84620386b0d050d0edf2f2b04bef2599b08", "message": "First steps in docs for runtime fields.", "committedDate": "2020-09-14T21:37:39Z", "type": "commit"}, {"oid": "e1c042704be7393445f1a985916aee7abedcdd41", "url": "https://github.com/elastic/elasticsearch/commit/e1c042704be7393445f1a985916aee7abedcdd41", "message": "Adding new page for runtime fields.", "committedDate": "2020-09-14T21:38:51Z", "type": "commit"}, {"oid": "47bb110f54f6f8e331b2a07981e24a1e19b55f1c", "url": "https://github.com/elastic/elasticsearch/commit/47bb110f54f6f8e331b2a07981e24a1e19b55f1c", "message": "Adding page for runtime fields.", "committedDate": "2020-09-15T14:21:25Z", "type": "commit"}, {"oid": "0c97b926552d746d227b8b77b1622a9238c71da6", "url": "https://github.com/elastic/elasticsearch/commit/0c97b926552d746d227b8b77b1622a9238c71da6", "message": "Adding more to the runtime fields topic.", "committedDate": "2020-09-17T21:28:29Z", "type": "commit"}, {"oid": "ee8a16fe17d775bd068467ccaa05ed1bf3e63dac", "url": "https://github.com/elastic/elasticsearch/commit/ee8a16fe17d775bd068467ccaa05ed1bf3e63dac", "message": "Adding parameters and retrieval options for runtime fields.", "committedDate": "2020-09-18T17:15:57Z", "type": "commit"}, {"oid": "f56bde04baa1f7e8b9e4a1769b6dc9ad7a8194b7", "url": "https://github.com/elastic/elasticsearch/commit/f56bde04baa1f7e8b9e4a1769b6dc9ad7a8194b7", "message": "Adding TESTSETUP for index creation.", "committedDate": "2020-09-18T17:51:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA3NDA2MA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r492074060", "bodyText": "I feel like talking about \"Lucene\" and doc_values is very technical for a high level description.\nI wonder if it'd be better to say that we don't build any fancy data structures for them up front but that we still support searching and aggregating on them. Saying that there is a performance cost at search time for this. Interestingly that performance cost varies in very unique and interesting ways, so it might be good to be fairly vague about it.", "author": "nik9000", "createdAt": "2020-09-21T14:08:53Z", "path": "docs/reference/mapping/types.asciidoc", "diffHunk": "@@ -124,6 +125,23 @@ the <<analysis-standard-analyzer,`standard` analyzer>>, the\n This is the purpose of _multi-fields_. Most field types support multi-fields\n via the <<multi-fields>> parameter.\n \n+[discrete]\n+=== Runtime\n+Oftentimes, you just want to make your data available to {es} without indexing\n+or preprocessing. _Runtime fields_ extend the flexibility of the\n+<<search-search,search API>> to quickly make data searchable, even with minimal\n+structure.\n+\n+// tag::runtime-fields-description[]\n+Runtime fields are not indexed and do have <<doc-values,doc_values>>, meaning\n+Lucene is unaware of their existence. However, runtime fields are accessible\n+from the search API like any other field that has `doc_values` and is\n+searchable. You can retrieve and query these fields, as well as aggregate and\n+sort on them.", "originalCommit": "f56bde04baa1f7e8b9e4a1769b6dc9ad7a8194b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE5MDc5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r492190791", "bodyText": "They do have access.", "author": "nik9000", "createdAt": "2020-09-21T16:25:32Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,94 @@\n+[[runtime]]\n+=== Runtime\n+\n+////\n+[source,console]\n+----\n+PUT /my-index\n+----\n+// TESTSETUP\n+////\n+\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at runtime without indexing your data. This\n+flexibility allows you to more quickly ingest raw data into the Elastic Stack\n+and immediately access it. By dynamically evaluating runtime fields at query\n+time, you can choose which fields to index and optimize disk space.\n+\n+include::{es-ref-dir}/mapping/types.asciidoc[tag=runtime-fields-description]\n+\n+// Each runtime field is of the `runtime` data type, and has its own\n+// <<mapping-types,field type>>, such as `boolean`, `long`, or `keyword`. The\n+// field type identifies the data type In\n+// the following example, the data type is `runtime` and the runtime field type is\n+// `keyword`.\n+\n+==== Specifying runtime fields\n+Runtime fields do not have access to the\n+<<mapping-source-field,`_source` field>>. You specify runtime fields in the", "originalCommit": "f56bde04baa1f7e8b9e4a1769b6dc9ad7a8194b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE5MTc1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r492191753", "bodyText": "This is true, but it might not be the right time to talk about it. To be honest we'd prefer folks use the doc way of accessing fields if at all possible and only reach for _source if it is, like, their only choice.", "author": "nik9000", "createdAt": "2020-09-21T16:27:01Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,94 @@\n+[[runtime]]\n+=== Runtime\n+\n+////\n+[source,console]\n+----\n+PUT /my-index\n+----\n+// TESTSETUP\n+////\n+\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at runtime without indexing your data. This\n+flexibility allows you to more quickly ingest raw data into the Elastic Stack\n+and immediately access it. By dynamically evaluating runtime fields at query\n+time, you can choose which fields to index and optimize disk space.\n+\n+include::{es-ref-dir}/mapping/types.asciidoc[tag=runtime-fields-description]\n+\n+// Each runtime field is of the `runtime` data type, and has its own\n+// <<mapping-types,field type>>, such as `boolean`, `long`, or `keyword`. The\n+// field type identifies the data type In\n+// the following example, the data type is `runtime` and the runtime field type is\n+// `keyword`.\n+\n+==== Specifying runtime fields\n+Runtime fields do not have access to the\n+<<mapping-source-field,`_source` field>>. You specify runtime fields in the\n+mapping by <<modules-scripting-using,defining a script>>, which always has\n+access to the `source` field. At search time, the script runs and generates", "originalCommit": "f56bde04baa1f7e8b9e4a1769b6dc9ad7a8194b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE5MjM0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r492192347", "bodyText": "Runtime fields with the runtime_type of date can accept format parameter that functions exactly as the format parameter does on the date field type.", "author": "nik9000", "createdAt": "2020-09-21T16:27:57Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,94 @@\n+[[runtime]]\n+=== Runtime\n+\n+////\n+[source,console]\n+----\n+PUT /my-index\n+----\n+// TESTSETUP\n+////\n+\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at runtime without indexing your data. This\n+flexibility allows you to more quickly ingest raw data into the Elastic Stack\n+and immediately access it. By dynamically evaluating runtime fields at query\n+time, you can choose which fields to index and optimize disk space.\n+\n+include::{es-ref-dir}/mapping/types.asciidoc[tag=runtime-fields-description]\n+\n+// Each runtime field is of the `runtime` data type, and has its own\n+// <<mapping-types,field type>>, such as `boolean`, `long`, or `keyword`. The\n+// field type identifies the data type In\n+// the following example, the data type is `runtime` and the runtime field type is\n+// `keyword`.\n+\n+==== Specifying runtime fields\n+Runtime fields do not have access to the\n+<<mapping-source-field,`_source` field>>. You specify runtime fields in the\n+mapping by <<modules-scripting-using,defining a script>>, which always has\n+access to the `source` field. At search time, the script runs and generates\n+values for each scripted field.\n+\n+The script in the following request extracts the day of the week from the\n+`timestamp` field, which is defined as a `date` data type.\n+\n+[source,console]\n+----\n+PUT /my-index/_mappings\n+{\n+  \"properties\" : {\n+    \"day_of_week\" : {\n+      \"type\" : \"runtime\", <1>\n+      \"runtime_type\" : \"keyword\", <2>\n+      \"script\" : {\n+        \"source\" : \"emit(doc['timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are of the `runtime` data type.\n+<2> Each runtime has its own field type, defined by `runtime_type`.\n+\n+[[runtime-params]]\n+==== Parameters for `runtime` fields\n+Runtime fields accept the following parameters:\n+\n+`type`::\n+The type of runtime computation to perform at query time. Currently, runtime\n+fields only support the `runtime` data type.\n+\n+`runtime_type`::\n+The <<mapping-types,field type>> for each scripted field. {es}\n+supports `boolean`, `date`, `double`, `ip`, `keyword`, and `long`.\n+", "originalCommit": "f56bde04baa1f7e8b9e4a1769b6dc9ad7a8194b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE5NDM3NA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r492194374", "bodyText": "I think it might be more compelling to say something more active like, \"Use the fields parameter on the _search API to fetch the values of runtime fields. This API works for all fields, even those that were not sent as part of the original _source.\"", "author": "nik9000", "createdAt": "2020-09-21T16:30:54Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,94 @@\n+[[runtime]]\n+=== Runtime\n+\n+////\n+[source,console]\n+----\n+PUT /my-index\n+----\n+// TESTSETUP\n+////\n+\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at runtime without indexing your data. This\n+flexibility allows you to more quickly ingest raw data into the Elastic Stack\n+and immediately access it. By dynamically evaluating runtime fields at query\n+time, you can choose which fields to index and optimize disk space.\n+\n+include::{es-ref-dir}/mapping/types.asciidoc[tag=runtime-fields-description]\n+\n+// Each runtime field is of the `runtime` data type, and has its own\n+// <<mapping-types,field type>>, such as `boolean`, `long`, or `keyword`. The\n+// field type identifies the data type In\n+// the following example, the data type is `runtime` and the runtime field type is\n+// `keyword`.\n+\n+==== Specifying runtime fields\n+Runtime fields do not have access to the\n+<<mapping-source-field,`_source` field>>. You specify runtime fields in the\n+mapping by <<modules-scripting-using,defining a script>>, which always has\n+access to the `source` field. At search time, the script runs and generates\n+values for each scripted field.\n+\n+The script in the following request extracts the day of the week from the\n+`timestamp` field, which is defined as a `date` data type.\n+\n+[source,console]\n+----\n+PUT /my-index/_mappings\n+{\n+  \"properties\" : {\n+    \"day_of_week\" : {\n+      \"type\" : \"runtime\", <1>\n+      \"runtime_type\" : \"keyword\", <2>\n+      \"script\" : {\n+        \"source\" : \"emit(doc['timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are of the `runtime` data type.\n+<2> Each runtime has its own field type, defined by `runtime_type`.\n+\n+[[runtime-params]]\n+==== Parameters for `runtime` fields\n+Runtime fields accept the following parameters:\n+\n+`type`::\n+The type of runtime computation to perform at query time. Currently, runtime\n+fields only support the `runtime` data type.\n+\n+`runtime_type`::\n+The <<mapping-types,field type>> for each scripted field. {es}\n+supports `boolean`, `date`, `double`, `ip`, `keyword`, and `long`.\n+\n+==== Retrieving runtime fields\n+Because runtime fields are not part of the `_source` field, they are not", "originalCommit": "f56bde04baa1f7e8b9e4a1769b6dc9ad7a8194b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE5NTY3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r492195677", "bodyText": "I'm not sure I'd add this paragraph to the docs at all, or at least, not with \"retrieving\". It is an important bit of information if you are building an application that consumes Elasticsearch and is super general. I think that is, mostly Kibana. My gut feeling is that most applications that consume Elasticsearch manage the mapping themselves and don't typically use the field capabilities API at all. If that is true, then I think this bit of information belongs as a note on the field caps api page.", "author": "nik9000", "createdAt": "2020-09-21T16:33:03Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,94 @@\n+[[runtime]]\n+=== Runtime\n+\n+////\n+[source,console]\n+----\n+PUT /my-index\n+----\n+// TESTSETUP\n+////\n+\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at runtime without indexing your data. This\n+flexibility allows you to more quickly ingest raw data into the Elastic Stack\n+and immediately access it. By dynamically evaluating runtime fields at query\n+time, you can choose which fields to index and optimize disk space.\n+\n+include::{es-ref-dir}/mapping/types.asciidoc[tag=runtime-fields-description]\n+\n+// Each runtime field is of the `runtime` data type, and has its own\n+// <<mapping-types,field type>>, such as `boolean`, `long`, or `keyword`. The\n+// field type identifies the data type In\n+// the following example, the data type is `runtime` and the runtime field type is\n+// `keyword`.\n+\n+==== Specifying runtime fields\n+Runtime fields do not have access to the\n+<<mapping-source-field,`_source` field>>. You specify runtime fields in the\n+mapping by <<modules-scripting-using,defining a script>>, which always has\n+access to the `source` field. At search time, the script runs and generates\n+values for each scripted field.\n+\n+The script in the following request extracts the day of the week from the\n+`timestamp` field, which is defined as a `date` data type.\n+\n+[source,console]\n+----\n+PUT /my-index/_mappings\n+{\n+  \"properties\" : {\n+    \"day_of_week\" : {\n+      \"type\" : \"runtime\", <1>\n+      \"runtime_type\" : \"keyword\", <2>\n+      \"script\" : {\n+        \"source\" : \"emit(doc['timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are of the `runtime` data type.\n+<2> Each runtime has its own field type, defined by `runtime_type`.\n+\n+[[runtime-params]]\n+==== Parameters for `runtime` fields\n+Runtime fields accept the following parameters:\n+\n+`type`::\n+The type of runtime computation to perform at query time. Currently, runtime\n+fields only support the `runtime` data type.\n+\n+`runtime_type`::\n+The <<mapping-types,field type>> for each scripted field. {es}\n+supports `boolean`, `date`, `double`, `ip`, `keyword`, and `long`.\n+\n+==== Retrieving runtime fields\n+Because runtime fields are not part of the `_source` field, they are not\n+returned in search hits by default. You can request runtime fields by using the\n+<<search-fields,`fields`>> parameter, or by using the\n+<<docvalue-fields,`docvalue_fields`>> parameter to return `doc_values` for one\n+or more fields in the search response.\n+\n+Use the <<search-field-caps,field capabilities API>> to return runtime fields\n+like any other field. For example, a runtime field with a `runtime_type` of\n+`keyword` returns as any other field that belongs to the `keyword` family.", "originalCommit": "f56bde04baa1f7e8b9e4a1769b6dc9ad7a8194b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxOTc0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r492319742", "bodyText": "I'm moving this paragraph to the field caps API page, with a link back to the runtime fields page.", "author": "lockewritesdocs", "createdAt": "2020-09-21T20:14:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE5NTY3Nw=="}], "type": "inlineReview"}, {"oid": "bb822841debbcb14d0cd43b5ed38e989d6fc82f9", "url": "https://github.com/elastic/elasticsearch/commit/bb822841debbcb14d0cd43b5ed38e989d6fc82f9", "message": "Incorporating review feedback.", "committedDate": "2020-09-21T21:50:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NzU1OA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r492267558", "bodyText": "What's the reasoning for the change here?", "author": "jrodewig", "createdAt": "2020-09-21T18:36:49Z", "path": "docs/reference/mapping/types.asciidoc", "diffHunk": "@@ -108,11 +108,12 @@ as-you-type completion.\n === Arrays\n In {es}, arrays do not require a dedicated field data type. Any field can contain\n zero or more values by default, however, all values in the array must be of the\n-same field type. See <<array>>.\n+same field type.\n+\n+See <<array>> to learn more.", "originalCommit": "f56bde04baa1f7e8b9e4a1769b6dc9ad7a8194b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY4OTc3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r492689779", "bodyText": "I think that having the line separation makes the related link more visible. If our convention is See <page_name>, then I'm happy to revert this change.", "author": "lockewritesdocs", "createdAt": "2020-09-22T12:23:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NzU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NzU2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r492267566", "bodyText": "We need an explicit anchor ID here.", "author": "jrodewig", "createdAt": "2020-09-21T18:36:50Z", "path": "docs/reference/mapping/types.asciidoc", "diffHunk": "@@ -124,6 +125,23 @@ the <<analysis-standard-analyzer,`standard` analyzer>>, the\n This is the purpose of _multi-fields_. Most field types support multi-fields\n via the <<multi-fields>> parameter.\n \n+[discrete]\n+=== Runtime", "originalCommit": "f56bde04baa1f7e8b9e4a1769b6dc9ad7a8194b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM2NzY2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r492367665", "bodyText": "I feel like this is too technical. From a high level, what are the problems runtime fields solve? Here's a quick draft to give you an idea of what I'm talking about. You probably shouldn't use it without significant refinement and more context.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Oftentimes, you just want to make your data available to {es} without indexing\n          \n          \n            \n            or preprocessing. _Runtime fields_ extend the flexibility of the\n          \n          \n            \n            <<search-search,search API>> to quickly make data searchable, even with minimal\n          \n          \n            \n            structure.\n          \n          \n            \n            \n          \n          \n            \n            Instead of indexing all of your data, you can use runtime fields to\n          \n          \n            \n            search and aggregate on your data at query time. Runtime fields can incur\n          \n          \n            \n            performance costs at runtime depending on the runtime type, but don't use the\n          \n          \n            \n            disk space that is typically required to index your data. By removing the\n          \n          \n            \n            requirement to index everything, you gain the flexibility of choosing which\n          \n          \n            \n            fields to index.\n          \n          \n            \n            \n          \n          \n            \n            See <<runtime>> to learn more.\n          \n          \n            \n            {es} indexes most field types by default. This allows for faster searches, but\n          \n          \n            \n            it can slow ingest and uses more disk space.\n          \n          \n            \n            \n          \n          \n            \n            If you rarely run searches or aren't sure what fields you'll need to search, you\n          \n          \n            \n            can disable indexing and use runtime fields instead. Runtime fields use a script\n          \n          \n            \n            to extract or compute field values from your unindexed data at search time. Runtime\n          \n          \n            \n            fields use less disk space and increase the flexibility of your data at the\n          \n          \n            \n            cost of search performance. See <<runtime>>.", "author": "jrodewig", "createdAt": "2020-09-21T21:54:33Z", "path": "docs/reference/mapping/types.asciidoc", "diffHunk": "@@ -124,6 +125,22 @@ the <<analysis-standard-analyzer,`standard` analyzer>>, the\n This is the purpose of _multi-fields_. Most field types support multi-fields\n via the <<multi-fields>> parameter.\n \n+[discrete]\n+=== Runtime\n+Oftentimes, you just want to make your data available to {es} without indexing\n+or preprocessing. _Runtime fields_ extend the flexibility of the\n+<<search-search,search API>> to quickly make data searchable, even with minimal\n+structure.\n+\n+Instead of indexing all of your data, you can use runtime fields to\n+search and aggregate on your data at query time. Runtime fields can incur\n+performance costs at runtime depending on the runtime type, but don't use the\n+disk space that is typically required to index your data. By removing the\n+requirement to index everything, you gain the flexibility of choosing which\n+fields to index.\n+\n+See <<runtime>> to learn more.", "originalCommit": "bb822841debbcb14d0cd43b5ed38e989d6fc82f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3MDQ4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r492370489", "bodyText": "Two concerns here:\n\nThis shouldn't be a rehash of the field type description. That's just a quick, condensed preview. On this page, you should take some space to better lay out the problem, give more specific use cases, and cover considerations.\nThe info hierarchy is a little off. Here's how I'd tackle it in order:\n\n\nWhat problems do runtime fields solve? How?\nWhat are the tradeoffs of using runtime fields? E.g., lower storage costs, faster indexing vs. slower search\nWhen are runtime fields commonly used? What use cases? E.g., time series data, logging, etc.\nWhat are some interesting ways I could use it? Examples?\nWhat are some considerations before I use it? Are there fields I should not use as runtime fields?", "author": "jrodewig", "createdAt": "2020-09-21T22:01:30Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,90 @@\n+[[runtime]]\n+=== Runtime\n+\n+////\n+[source,console]\n+----\n+PUT /my-index\n+----\n+// TESTSETUP\n+////\n+\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at runtime without indexing your data. This\n+flexibility allows you to more quickly ingest raw data into the Elastic Stack\n+and immediately access it. By dynamically evaluating runtime fields at query\n+time, you can choose which fields to index and optimize disk space.\n+\n+Runtime fields are not indexed, but are accessible from the search API like any\n+other field that has <<doc-values,doc_values>> and is searchable. You can\n+retrieve and query these fields, as well as aggregate and\n+sort on them.\n+\n+NOTE: Runtime fields can be incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>.", "originalCommit": "bb822841debbcb14d0cd43b5ed38e989d6fc82f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3MTM3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r492371379", "bodyText": "We typically call this \"mapping a field.\" \"Specifying\" doesn't feel right.", "author": "jrodewig", "createdAt": "2020-09-21T22:03:24Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,90 @@\n+[[runtime]]\n+=== Runtime\n+\n+////\n+[source,console]\n+----\n+PUT /my-index\n+----\n+// TESTSETUP\n+////\n+\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at runtime without indexing your data. This\n+flexibility allows you to more quickly ingest raw data into the Elastic Stack\n+and immediately access it. By dynamically evaluating runtime fields at query\n+time, you can choose which fields to index and optimize disk space.\n+\n+Runtime fields are not indexed, but are accessible from the search API like any\n+other field that has <<doc-values,doc_values>> and is searchable. You can\n+retrieve and query these fields, as well as aggregate and\n+sort on them.\n+\n+NOTE: Runtime fields can be incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>.\n+\n+==== Specifying runtime fields\n+You specify runtime fields in the mapping by", "originalCommit": "bb822841debbcb14d0cd43b5ed38e989d6fc82f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY5MDg4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r492690886", "bodyText": "Thanks for clarifying. I'll update the wording.", "author": "lockewritesdocs", "createdAt": "2020-09-22T12:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3MTM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3MTM4OA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r492371388", "bodyText": "Mapping for other field types is almost always done upfront. You typically create a mapping as part of an index template or when you create an index. That means it happens before you start indexing data. To be useful, runtime fields are mapped after you start indexing data.\nI think it'd be useful to show the user how the raw data is typically stored in ES before the runtime field is created. An in-depth example would be good. It may also be helpful to show an example of how a runtime field could replace an existing ingest pipeline, etc.", "author": "jrodewig", "createdAt": "2020-09-21T22:03:25Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,90 @@\n+[[runtime]]\n+=== Runtime\n+\n+////\n+[source,console]\n+----\n+PUT /my-index\n+----\n+// TESTSETUP\n+////\n+\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at runtime without indexing your data. This\n+flexibility allows you to more quickly ingest raw data into the Elastic Stack\n+and immediately access it. By dynamically evaluating runtime fields at query\n+time, you can choose which fields to index and optimize disk space.\n+\n+Runtime fields are not indexed, but are accessible from the search API like any\n+other field that has <<doc-values,doc_values>> and is searchable. You can\n+retrieve and query these fields, as well as aggregate and\n+sort on them.\n+\n+NOTE: Runtime fields can be incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>.\n+\n+==== Specifying runtime fields\n+You specify runtime fields in the mapping by\n+<<modules-scripting-using,defining a script>>. At search time, the script runs\n+and generates values for each scripted field.\n+\n+The script in the following request extracts the day of the week from the\n+`timestamp` field, which is defined as a `date` data type.", "originalCommit": "bb822841debbcb14d0cd43b5ed38e989d6fc82f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3MTY4MA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r492371680", "bodyText": "I'd move this up as part of the example.", "author": "jrodewig", "createdAt": "2020-09-21T22:04:04Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,90 @@\n+[[runtime]]\n+=== Runtime\n+\n+////\n+[source,console]\n+----\n+PUT /my-index\n+----\n+// TESTSETUP\n+////\n+\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at runtime without indexing your data. This\n+flexibility allows you to more quickly ingest raw data into the Elastic Stack\n+and immediately access it. By dynamically evaluating runtime fields at query\n+time, you can choose which fields to index and optimize disk space.\n+\n+Runtime fields are not indexed, but are accessible from the search API like any\n+other field that has <<doc-values,doc_values>> and is searchable. You can\n+retrieve and query these fields, as well as aggregate and\n+sort on them.\n+\n+NOTE: Runtime fields can be incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>.\n+\n+==== Specifying runtime fields\n+You specify runtime fields in the mapping by\n+<<modules-scripting-using,defining a script>>. At search time, the script runs\n+and generates values for each scripted field.\n+\n+The script in the following request extracts the day of the week from the\n+`timestamp` field, which is defined as a `date` data type.\n+\n+[source,console]\n+----\n+PUT /my-index/_mappings\n+{\n+  \"properties\" : {\n+    \"day_of_week\" : {\n+      \"type\" : \"runtime\", <1>\n+      \"runtime_type\" : \"keyword\", <2>\n+      \"script\" : {\n+        \"source\" : \"emit(doc['timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are of the `runtime` data type.\n+<2> Each runtime has its own field type, defined by `runtime_type`.\n+\n+[[runtime-params]]\n+==== Parameters for `runtime` fields\n+Runtime fields accept the following parameters:\n+\n+`type`::\n+The type of runtime computation to perform at query time. Currently, runtime\n+fields only support the `runtime` data type.\n+\n+[[runtime-params-runtime-type]]\n+`runtime_type`::\n+The <<mapping-types,field type>> for each scripted field. {es}\n+supports `boolean`, `date`, `double`, `ip`, `keyword`, and `long`.\n++\n+Runtime fields with a `runtime_type` of `date` can accept the\n+<<mapping-date-format,`format`>> parameter exactly as the `date` field type.\n+\n+==== Retrieving runtime fields\n+Use the <<search-fields,`fields`>> parameter on the `_search` API to retrieve\n+the values of runtime fields. This API works for all fields, even those that\n+were not sent as part of the original `_source`.\n+\n+The following request uses the search API to retrieve the `day_of_week` field\n+that the previous request defined in the mapping.\n+\n+[source,console]\n+----\n+GET /my-index/_search\n+{\n+  \"aggs\": {\n+    \"days_of_week\": {\n+      \"terms\": {\n+        \"field\": \"day_of_week\"\n+      }\n+    }\n+  }\n+}\n+----", "originalCommit": "bb822841debbcb14d0cd43b5ed38e989d6fc82f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3MjQ2OA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r492372468", "bodyText": "Needs an explicit anchor ID.", "author": "jrodewig", "createdAt": "2020-09-21T22:05:52Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,90 @@\n+[[runtime]]\n+=== Runtime\n+\n+////\n+[source,console]\n+----\n+PUT /my-index\n+----\n+// TESTSETUP\n+////\n+\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at runtime without indexing your data. This\n+flexibility allows you to more quickly ingest raw data into the Elastic Stack\n+and immediately access it. By dynamically evaluating runtime fields at query\n+time, you can choose which fields to index and optimize disk space.\n+\n+Runtime fields are not indexed, but are accessible from the search API like any\n+other field that has <<doc-values,doc_values>> and is searchable. You can\n+retrieve and query these fields, as well as aggregate and\n+sort on them.\n+\n+NOTE: Runtime fields can be incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>.\n+\n+==== Specifying runtime fields", "originalCommit": "bb822841debbcb14d0cd43b5ed38e989d6fc82f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3MjU3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r492372575", "bodyText": "Need an explicit anchor ID.", "author": "jrodewig", "createdAt": "2020-09-21T22:06:06Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,90 @@\n+[[runtime]]\n+=== Runtime\n+\n+////\n+[source,console]\n+----\n+PUT /my-index\n+----\n+// TESTSETUP\n+////\n+\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at runtime without indexing your data. This\n+flexibility allows you to more quickly ingest raw data into the Elastic Stack\n+and immediately access it. By dynamically evaluating runtime fields at query\n+time, you can choose which fields to index and optimize disk space.\n+\n+Runtime fields are not indexed, but are accessible from the search API like any\n+other field that has <<doc-values,doc_values>> and is searchable. You can\n+retrieve and query these fields, as well as aggregate and\n+sort on them.\n+\n+NOTE: Runtime fields can be incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>.\n+\n+==== Specifying runtime fields\n+You specify runtime fields in the mapping by\n+<<modules-scripting-using,defining a script>>. At search time, the script runs\n+and generates values for each scripted field.\n+\n+The script in the following request extracts the day of the week from the\n+`timestamp` field, which is defined as a `date` data type.\n+\n+[source,console]\n+----\n+PUT /my-index/_mappings\n+{\n+  \"properties\" : {\n+    \"day_of_week\" : {\n+      \"type\" : \"runtime\", <1>\n+      \"runtime_type\" : \"keyword\", <2>\n+      \"script\" : {\n+        \"source\" : \"emit(doc['timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are of the `runtime` data type.\n+<2> Each runtime has its own field type, defined by `runtime_type`.\n+\n+[[runtime-params]]\n+==== Parameters for `runtime` fields\n+Runtime fields accept the following parameters:\n+\n+`type`::\n+The type of runtime computation to perform at query time. Currently, runtime\n+fields only support the `runtime` data type.\n+\n+[[runtime-params-runtime-type]]\n+`runtime_type`::\n+The <<mapping-types,field type>> for each scripted field. {es}\n+supports `boolean`, `date`, `double`, `ip`, `keyword`, and `long`.\n++\n+Runtime fields with a `runtime_type` of `date` can accept the\n+<<mapping-date-format,`format`>> parameter exactly as the `date` field type.\n+\n+==== Retrieving runtime fields", "originalCommit": "bb822841debbcb14d0cd43b5ed38e989d6fc82f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b2cbf0a7f99b604fa825ab1ffc7cb4360793cbe5", "url": "https://github.com/elastic/elasticsearch/commit/b2cbf0a7f99b604fa825ab1ffc7cb4360793cbe5", "message": "Incorporating reviewer feedback.", "committedDate": "2020-09-22T21:16:51Z", "type": "commit"}, {"oid": "d119cbd38e00cf698d5f3d675644c215d85e16c4", "url": "https://github.com/elastic/elasticsearch/commit/d119cbd38e00cf698d5f3d675644c215d85e16c4", "message": "Adding examples for runtime fields.", "committedDate": "2020-09-23T20:50:58Z", "type": "commit"}, {"oid": "a287895592edf4a5bb9c2a2033eb7a6080c2997b", "url": "https://github.com/elastic/elasticsearch/commit/a287895592edf4a5bb9c2a2033eb7a6080c2997b", "message": "Adding more context and simplifying the example.", "committedDate": "2020-09-24T20:32:08Z", "type": "commit"}, {"oid": "ce0fcdd44bce577483856dbacfa83cbded7d33a6", "url": "https://github.com/elastic/elasticsearch/commit/ce0fcdd44bce577483856dbacfa83cbded7d33a6", "message": "Merge branch 'master' into docs__add-runtime-fields", "committedDate": "2020-09-28T14:50:41Z", "type": "commit"}, {"oid": "2b533f7a25ed53d78123f83164cf493555f72072", "url": "https://github.com/elastic/elasticsearch/commit/2b533f7a25ed53d78123f83164cf493555f72072", "message": "Changing timestamp to @timestamp throughout.", "committedDate": "2020-09-28T15:09:01Z", "type": "commit"}, {"oid": "d2d8551ced48c4f162889fa7b633d2ba76d6d311", "url": "https://github.com/elastic/elasticsearch/commit/d2d8551ced48c4f162889fa7b633d2ba76d6d311", "message": "Removing duplicate @timestamp field.", "committedDate": "2020-09-28T17:08:29Z", "type": "commit"}, {"oid": "282a77756fac10932ad7239da5135edca3567dca", "url": "https://github.com/elastic/elasticsearch/commit/282a77756fac10932ad7239da5135edca3567dca", "message": "Expanding example to hopefully fix CI builds.", "committedDate": "2020-09-28T17:25:13Z", "type": "commit"}, {"oid": "50a30f68035da0c6c253df268f0d31f6cd708357", "url": "https://github.com/elastic/elasticsearch/commit/50a30f68035da0c6c253df268f0d31f6cd708357", "message": "Adding skip test for result.", "committedDate": "2020-09-28T18:21:46Z", "type": "commit"}, {"oid": "eb4c6c7e5d7012504b27ebf3ac80980c70b2debf", "url": "https://github.com/elastic/elasticsearch/commit/eb4c6c7e5d7012504b27ebf3ac80980c70b2debf", "message": "Merge branch 'master' into docs__add-runtime-fields", "committedDate": "2020-09-28T18:32:02Z", "type": "commit"}, {"oid": "f8a3d503c655ecaa2736b816e4e316fd3885a70e", "url": "https://github.com/elastic/elasticsearch/commit/f8a3d503c655ecaa2736b816e4e316fd3885a70e", "message": "Adding missing callout.", "committedDate": "2020-09-28T18:41:09Z", "type": "commit"}, {"oid": "796a10f6c824fa781c53712baf9fb8bcfb18e832", "url": "https://github.com/elastic/elasticsearch/commit/796a10f6c824fa781c53712baf9fb8bcfb18e832", "message": "Merge branch 'docs__add-runtime-fields' of github.com:lockewritesdocs/elasticsearch into docs__add-runtime-fields", "committedDate": "2020-09-28T18:41:35Z", "type": "commit"}, {"oid": "301abd19191c4de27ab94ec0f489720eef46bb4e", "url": "https://github.com/elastic/elasticsearch/commit/301abd19191c4de27ab94ec0f489720eef46bb4e", "message": "Adding TESTRESPONSEs, which are currently broken.", "committedDate": "2020-09-28T21:12:11Z", "type": "commit"}, {"oid": "62a5393d1ffdb422169e7e8feabeeda10856fae4", "url": "https://github.com/elastic/elasticsearch/commit/62a5393d1ffdb422169e7e8feabeeda10856fae4", "message": "Fixing TESTRESPONSEs.", "committedDate": "2020-09-29T12:58:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyMzkxMA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496723910", "bodyText": "I would expect runtime fields to be computed from doc_values, and I would read unindexed data as reading from _source, so maybe I would try to rephrase this. \"from existing fields, either runtime or ordinary\" ?", "author": "javanna", "createdAt": "2020-09-29T13:38:34Z", "path": "docs/reference/mapping/types.asciidoc", "diffHunk": "@@ -126,6 +126,31 @@ the <<analysis-standard-analyzer,`standard` analyzer>>, the\n This is the purpose of _multi-fields_. Most field types support multi-fields\n via the <<multi-fields>> parameter.\n \n+[discrete]\n+[[types-runtime]]\n+=== Runtime\n+{es} indexes most field types by default to promote faster search. However,\n+indexing all of your data can be slow and requires more disk space. If you're\n+experimenting with your data or are unsure which fields you need for search,\n+use _runtime fields_.\n+\n+{es} treats runtime fields like any other field, except that their values are\n+only extracted or computed at search time. When mapping a runtime field, you\n+define a script that determines how to extract or compute field values from\n+your unindexed data.", "originalCommit": "62a5393d1ffdb422169e7e8feabeeda10856fae4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3OTAzNA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496779034", "bodyText": "Thanks for that distinction @javanna. I think we can further refine that statement:\n\nWhen mapping a runtime field, you define a script that determines how to extract or compute values from existing fields.", "author": "lockewritesdocs", "createdAt": "2020-09-29T14:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyMzkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5MzA5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496793095", "bodyText": "++", "author": "javanna", "createdAt": "2020-09-29T15:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyMzkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyNTQyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496725421", "bodyText": "you can also sort on them: shall we rather say they can be used like any other field that is indexed and has doc_values? Or maybe without even mentioning doc_values or index, but rather mention field_caps returns: they are searchable and agregatable.", "author": "javanna", "createdAt": "2020-09-29T13:40:24Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,365 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at search time without indexing your data during\n+ingest time.\n+\n+Runtime fields beta[] are accessible from the search API like any other field that has\n+<<doc-values,doc_values>> and is searchable. You can retrieve and query these\n+fields, as well as aggregate on them.", "originalCommit": "62a5393d1ffdb422169e7e8feabeeda10856fae4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4NDIxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496784219", "bodyText": "Does this modification capture your intent?\n\nRuntime fields are accessible from the search API like any other field\nthat is indexed and has doc_values. You can retrieve and query\nthese fields, as well as sort and aggregate on them.", "author": "lockewritesdocs", "createdAt": "2020-09-29T14:52:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyNTQyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5NDg5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496794896", "bodyText": "I would rather say that is searchable and aggregatable (according to field_caps) . I am wary of listing what you can do with them as there is potentially more you can do with them e.g. accessing them from a script. The message should really be \"treat them like any other field\"", "author": "javanna", "createdAt": "2020-09-29T15:06:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyNTQyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgyMDk4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496820982", "bodyText": "Thanks @javanna. Paring back a bit more and trying to inject some information about field caps. Is it correct to say \"to return runtime fields as searchable and aggregatable\"? Or \"to return the capabilities of runtime fields, which are searchable and aggregatable\"?\n\nRuntime fields are accessible from the search API like any other field. Use the field capabilities API to return runtime fields as searchable and aggregatable.", "author": "lockewritesdocs", "createdAt": "2020-09-29T15:34:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyNTQyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcyMTk3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r497721979", "bodyText": "After talking to Nik, I updated these statements to read:\n\nRuntime fields are accessible from the search API like any other field. The field capabilities API returns runtime fields as searchable and aggregatable.", "author": "lockewritesdocs", "createdAt": "2020-09-30T18:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyNTQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyNzE3OA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496727178", "bodyText": "overriding is only a dream, for now, because you can't define a runtime field with the same name as a concrete field, today. It's more like you would do with multi fields, where you expose a new field that is the correct version of the other existing field.\nwe are though discussing the possible introduction of a runtime section in the mappings that would address this limitation.", "author": "javanna", "createdAt": "2020-09-29T13:42:42Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,365 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at search time without indexing your data during\n+ingest time.\n+\n+Runtime fields beta[] are accessible from the search API like any other field that has\n+<<doc-values,doc_values>> and is searchable. You can retrieve and query these\n+fields, as well as aggregate on them.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain search time performance\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and immediately access it. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. You can also fix errors in indexed fields by overriding them\n+with runtime fields, rather than reindexing all of your data. If you later", "originalCommit": "62a5393d1ffdb422169e7e8feabeeda10856fae4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA1NDU5NA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r497054594", "bodyText": "Sounds good! For now, I'll remove the statement about fixing errors in indexed fields by overriding them with runtime fields.", "author": "lockewritesdocs", "createdAt": "2020-09-29T21:00:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyNzE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyNzczNg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496727736", "bodyText": "removing a runtime field is not possible today.", "author": "javanna", "createdAt": "2020-09-29T13:43:19Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,365 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at search time without indexing your data during\n+ingest time.\n+\n+Runtime fields beta[] are accessible from the search API like any other field that has\n+<<doc-values,doc_values>> and is searchable. You can retrieve and query these\n+fields, as well as aggregate on them.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain search time performance\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and immediately access it. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. You can also fix errors in indexed fields by overriding them\n+with runtime fields, rather than reindexing all of your data. If you later\n+decide that a runtime field is increasingly used for filtering or aggregation,\n+you can remove the runtime field from the mapping and index the field to gain", "originalCommit": "62a5393d1ffdb422169e7e8feabeeda10856fae4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4NTA4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496785085", "bodyText": "Ah, good to know! I think we can omit the part about removing runtime fields and just say:\n\nIf you later decide that a runtime field is increasingly used for filtering or aggregation,\nyou can index the field to gain faster search speed.", "author": "lockewritesdocs", "createdAt": "2020-09-29T14:53:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyNzczNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5NjUxMw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496796513", "bodyText": "Though to index it, at the moment it needs to be added to _source or an ingest processor needs to be added that adds it to source. We are planning to make this much easier in the future, so depending on what you mean here, we may also want to leave out the make it indexed part :)", "author": "javanna", "createdAt": "2020-09-29T15:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyNzczNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwMTM0MA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496801340", "bodyText": "I'm thinking of the cases where users want to add this field to _source to gain search speed. We could clarify that users can \"index the field to _source\" :\n\nIf you later decide that a runtime field is increasingly used for filtering or aggregation,\nyou can index the field to _source to gain faster search speed.", "author": "lockewritesdocs", "createdAt": "2020-09-29T15:14:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyNzczNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwNjg2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496806865", "bodyText": "sounds good, I would replace \"index\" with \"add\"", "author": "javanna", "createdAt": "2020-09-29T15:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyNzczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyODU3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496728575", "bodyText": "indexing is disabled by default sounds weird to me. indexing is not a thing for runtime fields, at least at the moment.", "author": "javanna", "createdAt": "2020-09-29T13:44:18Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,365 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at search time without indexing your data during\n+ingest time.\n+\n+Runtime fields beta[] are accessible from the search API like any other field that has\n+<<doc-values,doc_values>> and is searchable. You can retrieve and query these\n+fields, as well as aggregate on them.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain search time performance\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and immediately access it. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. You can also fix errors in indexed fields by overriding them\n+with runtime fields, rather than reindexing all of your data. If you later\n+decide that a runtime field is increasingly used for filtering or aggregation,\n+you can remove the runtime field from the mapping and index the field to gain\n+faster search speed.\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+When mapping a runtime field, indexing is disabled by default. You map runtime", "originalCommit": "62a5393d1ffdb422169e7e8feabeeda10856fae4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4NjQ3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496786473", "bodyText": "Perhaps we just omit that sentence and start this section with, \"You map runtime fields by defining a painless script.\" Thoughts @javanna?", "author": "lockewritesdocs", "createdAt": "2020-09-29T14:55:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyODU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5NjY5OA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496796698", "bodyText": "++", "author": "javanna", "createdAt": "2020-09-29T15:08:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyODU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyODk1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496728956", "bodyText": "what do you mean by the entire context of a document?", "author": "javanna", "createdAt": "2020-09-29T13:44:48Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,365 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at search time without indexing your data during\n+ingest time.\n+\n+Runtime fields beta[] are accessible from the search API like any other field that has\n+<<doc-values,doc_values>> and is searchable. You can retrieve and query these\n+fields, as well as aggregate on them.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain search time performance\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and immediately access it. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. You can also fix errors in indexed fields by overriding them\n+with runtime fields, rather than reindexing all of your data. If you later\n+decide that a runtime field is increasingly used for filtering or aggregation,\n+you can remove the runtime field from the mapping and index the field to gain\n+faster search speed.\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+When mapping a runtime field, indexing is disabled by default. You map runtime\n+fields by <<modules-scripting-using,defining a painless script>>. At search\n+time, the script runs and generates values for each scripted field. Runtime\n+scripts have access to the entire context of a document, the original", "originalCommit": "62a5393d1ffdb422169e7e8feabeeda10856fae4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyOTc2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496729761", "bodyText": "we should probably expand this and explain why: each shard may see the old or the new version of the script, depending on when the mapping change becomes effective.", "author": "javanna", "createdAt": "2020-09-29T13:45:47Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,365 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at search time without indexing your data during\n+ingest time.\n+\n+Runtime fields beta[] are accessible from the search API like any other field that has\n+<<doc-values,doc_values>> and is searchable. You can retrieve and query these\n+fields, as well as aggregate on them.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain search time performance\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and immediately access it. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. You can also fix errors in indexed fields by overriding them\n+with runtime fields, rather than reindexing all of your data. If you later\n+decide that a runtime field is increasingly used for filtering or aggregation,\n+you can remove the runtime field from the mapping and index the field to gain\n+faster search speed.\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+When mapping a runtime field, indexing is disabled by default. You map runtime\n+fields by <<modules-scripting-using,defining a painless script>>. At search\n+time, the script runs and generates values for each scripted field. Runtime\n+scripts have access to the entire context of a document, the original\n+`_source`, and the mapped field plus its values (`doc_values`).\n+\n+IMPORTANT: Updating a script while a query that relies on the script is running\n+can return inconsistent results.", "originalCommit": "62a5393d1ffdb422169e7e8feabeeda10856fae4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg3NjExNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496876115", "bodyText": "Agreed. I think that this expansion provides more information:\n\nBefore updating a runtime script, ensure that no queries are running that rely\non that script. Updating a script while a dependent query is running can return\ninconsistent results. Each shard might have access to different versions of the\nscript, depending on when the mapping change takes effect.", "author": "lockewritesdocs", "createdAt": "2020-09-29T16:27:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyOTc2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyODg2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496928863", "bodyText": "yes, I would probably leave out the first sentence. it is more about being aware of this than ensuring no queries are running, which is not always possible", "author": "javanna", "createdAt": "2020-09-29T17:51:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyOTc2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjczMDEyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496730129", "bodyText": "that seems scary, but users will wonder why and how?", "author": "javanna", "createdAt": "2020-09-29T13:46:15Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,365 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at search time without indexing your data during\n+ingest time.\n+\n+Runtime fields beta[] are accessible from the search API like any other field that has\n+<<doc-values,doc_values>> and is searchable. You can retrieve and query these\n+fields, as well as aggregate on them.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain search time performance\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and immediately access it. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. You can also fix errors in indexed fields by overriding them\n+with runtime fields, rather than reindexing all of your data. If you later\n+decide that a runtime field is increasingly used for filtering or aggregation,\n+you can remove the runtime field from the mapping and index the field to gain\n+faster search speed.\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+When mapping a runtime field, indexing is disabled by default. You map runtime\n+fields by <<modules-scripting-using,defining a painless script>>. At search\n+time, the script runs and generates values for each scripted field. Runtime\n+scripts have access to the entire context of a document, the original\n+`_source`, and the mapped field plus its values (`doc_values`).\n+\n+IMPORTANT: Updating a script while a query that relies on the script is running\n+can return inconsistent results.\n++\n+Additionally, existing queries or visualizations that rely on runtime fields\n+can break if scripts are updated.", "originalCommit": "62a5393d1ffdb422169e7e8feabeeda10856fae4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyODc4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496928783", "bodyText": "I chatted with Stacey and CJ about this, and they both indicated that users will be unaware in Kibana about changes to the underlying runtime_type -- at least for the first release. However, I think we can explain a bit more that changing the runtime_type will break a visualization:\n\nExisting queries or visualizations in Kibana that rely on runtime fields can fail if you change the runtime_type. For example, a bar chart visualization that uses a runtime field of ip will fail if the runtime_type is changed to boolean.", "author": "lockewritesdocs", "createdAt": "2020-09-29T17:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjczMDEyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyOTg2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496929866", "bodyText": "Makes sense to me, the example makes it clear what type of change and how things would fail, thanks!", "author": "javanna", "createdAt": "2020-09-29T17:52:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjczMDEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjczMDkxNg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496730916", "bodyText": "should we expand on why?", "author": "javanna", "createdAt": "2020-09-29T13:47:13Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,365 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at search time without indexing your data during\n+ingest time.\n+\n+Runtime fields beta[] are accessible from the search API like any other field that has\n+<<doc-values,doc_values>> and is searchable. You can retrieve and query these\n+fields, as well as aggregate on them.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain search time performance\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and immediately access it. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. You can also fix errors in indexed fields by overriding them\n+with runtime fields, rather than reindexing all of your data. If you later\n+decide that a runtime field is increasingly used for filtering or aggregation,\n+you can remove the runtime field from the mapping and index the field to gain\n+faster search speed.\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+When mapping a runtime field, indexing is disabled by default. You map runtime\n+fields by <<modules-scripting-using,defining a painless script>>. At search\n+time, the script runs and generates values for each scripted field. Runtime\n+scripts have access to the entire context of a document, the original\n+`_source`, and the mapped field plus its values (`doc_values`).\n+\n+IMPORTANT: Updating a script while a query that relies on the script is running\n+can return inconsistent results.\n++\n+Additionally, existing queries or visualizations that rely on runtime fields\n+can break if scripts are updated.\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` data type.\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"day_of_week\": {\n+        \"type\": \"runtime\", <1>\n+        \"runtime_type\": \"keyword\", <2>\n+        \"script\": {\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are of the `runtime` data type.\n+<2> Each runtime has its own field type, defined by `runtime_type`.\n+\n+[[runtime-retrieving-fields]]\n+==== Retrieving a runtime field\n+Use the <<search-fields,`fields`>> parameter on the `_search` API to retrieve\n+the values of runtime fields. This API works for all fields, even those that\n+were not sent as part of the original `_source`.\n+\n+NOTE: We highly recommended using the <<async-search,asynchronous search API>>\n+to run searches that use runtime fields.", "originalCommit": "62a5393d1ffdb422169e7e8feabeeda10856fae4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYxOTg2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r497619861", "bodyText": "Yes \ud83d\udc4d @javanna, do you think this statement captures the why enough?\n\nComputing values for runtime fields in each document that might match a\nquery impacts search speed. Use the asynchronous search API\nto run searches that include runtime fields.", "author": "lockewritesdocs", "createdAt": "2020-09-30T15:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjczMDkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYyNzU5MA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r497627590", "bodyText": "sounds good thanks", "author": "javanna", "createdAt": "2020-09-30T16:03:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjczMDkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjczMTQ2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496731465", "bodyText": "is the script missing here in the list of supported parameters?", "author": "javanna", "createdAt": "2020-09-29T13:47:52Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,365 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at search time without indexing your data during\n+ingest time.\n+\n+Runtime fields beta[] are accessible from the search API like any other field that has\n+<<doc-values,doc_values>> and is searchable. You can retrieve and query these\n+fields, as well as aggregate on them.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain search time performance\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and immediately access it. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. You can also fix errors in indexed fields by overriding them\n+with runtime fields, rather than reindexing all of your data. If you later\n+decide that a runtime field is increasingly used for filtering or aggregation,\n+you can remove the runtime field from the mapping and index the field to gain\n+faster search speed.\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+When mapping a runtime field, indexing is disabled by default. You map runtime\n+fields by <<modules-scripting-using,defining a painless script>>. At search\n+time, the script runs and generates values for each scripted field. Runtime\n+scripts have access to the entire context of a document, the original\n+`_source`, and the mapped field plus its values (`doc_values`).\n+\n+IMPORTANT: Updating a script while a query that relies on the script is running\n+can return inconsistent results.\n++\n+Additionally, existing queries or visualizations that rely on runtime fields\n+can break if scripts are updated.\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` data type.\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"day_of_week\": {\n+        \"type\": \"runtime\", <1>\n+        \"runtime_type\": \"keyword\", <2>\n+        \"script\": {\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are of the `runtime` data type.\n+<2> Each runtime has its own field type, defined by `runtime_type`.\n+\n+[[runtime-retrieving-fields]]\n+==== Retrieving a runtime field\n+Use the <<search-fields,`fields`>> parameter on the `_search` API to retrieve\n+the values of runtime fields. This API works for all fields, even those that\n+were not sent as part of the original `_source`.\n+\n+NOTE: We highly recommended using the <<async-search,asynchronous search API>>\n+to run searches that use runtime fields.\n+\n+The following request uses the search API to retrieve the `day_of_week` field\n+that the previous request defined in the mapping.\n+\n+[source,console]\n+----\n+GET /my-index/_search\n+{\n+  \"aggs\": {\n+    \"days_of_week\": {\n+      \"terms\": {\n+        \"field\": \"day_of_week\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+[[runtime-params]]\n+==== Parameters for `runtime` fields\n+Runtime fields accept the following parameters:\n+\n+[[runtime-params-type]]\n+`type`::\n+The type of runtime computation to perform at query time. Currently, runtime\n+fields only support the `runtime` data type.\n+\n+[[runtime-params-runtime-type]]\n+`runtime_type`::\n+The <<mapping-types,field type>> for each scripted field. {es}\n+supports `boolean`, `date`, `double`, `ip`, `keyword`, and `long`.\n++\n+Runtime fields with a `runtime_type` of `date` can accept the\n+<<mapping-date-format,`format`>> parameter exactly as the `date` field type.", "originalCommit": "62a5393d1ffdb422169e7e8feabeeda10856fae4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAwMDQ2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r497000466", "bodyText": "Yes! I'll add it.", "author": "lockewritesdocs", "createdAt": "2020-09-29T19:44:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjczMTQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjczMzYxNw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496733617", "bodyText": "maybe you meant without reindexing the document and adding the day_of_week to it?", "author": "javanna", "createdAt": "2020-09-29T13:50:31Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,365 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With runtime fields, you can explicitly define a field\n+in the mapping and access it at search time without indexing your data during\n+ingest time.\n+\n+Runtime fields beta[] are accessible from the search API like any other field that has\n+<<doc-values,doc_values>> and is searchable. You can retrieve and query these\n+fields, as well as aggregate on them.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain search time performance\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and immediately access it. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. You can also fix errors in indexed fields by overriding them\n+with runtime fields, rather than reindexing all of your data. If you later\n+decide that a runtime field is increasingly used for filtering or aggregation,\n+you can remove the runtime field from the mapping and index the field to gain\n+faster search speed.\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+When mapping a runtime field, indexing is disabled by default. You map runtime\n+fields by <<modules-scripting-using,defining a painless script>>. At search\n+time, the script runs and generates values for each scripted field. Runtime\n+scripts have access to the entire context of a document, the original\n+`_source`, and the mapped field plus its values (`doc_values`).\n+\n+IMPORTANT: Updating a script while a query that relies on the script is running\n+can return inconsistent results.\n++\n+Additionally, existing queries or visualizations that rely on runtime fields\n+can break if scripts are updated.\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` data type.\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"day_of_week\": {\n+        \"type\": \"runtime\", <1>\n+        \"runtime_type\": \"keyword\", <2>\n+        \"script\": {\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are of the `runtime` data type.\n+<2> Each runtime has its own field type, defined by `runtime_type`.\n+\n+[[runtime-retrieving-fields]]\n+==== Retrieving a runtime field\n+Use the <<search-fields,`fields`>> parameter on the `_search` API to retrieve\n+the values of runtime fields. This API works for all fields, even those that\n+were not sent as part of the original `_source`.\n+\n+NOTE: We highly recommended using the <<async-search,asynchronous search API>>\n+to run searches that use runtime fields.\n+\n+The following request uses the search API to retrieve the `day_of_week` field\n+that the previous request defined in the mapping.\n+\n+[source,console]\n+----\n+GET /my-index/_search\n+{\n+  \"aggs\": {\n+    \"days_of_week\": {\n+      \"terms\": {\n+        \"field\": \"day_of_week\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+[[runtime-params]]\n+==== Parameters for `runtime` fields\n+Runtime fields accept the following parameters:\n+\n+[[runtime-params-type]]\n+`type`::\n+The type of runtime computation to perform at query time. Currently, runtime\n+fields only support the `runtime` data type.\n+\n+[[runtime-params-runtime-type]]\n+`runtime_type`::\n+The <<mapping-types,field type>> for each scripted field. {es}\n+supports `boolean`, `date`, `double`, `ip`, `keyword`, and `long`.\n++\n+Runtime fields with a `runtime_type` of `date` can accept the\n+<<mapping-date-format,`format`>> parameter exactly as the `date` field type.\n+\n+[[runtime-examples]]\n+==== Examples\n+Consider a large set of log data that you want to extract fields from.\n+Indexing the data is time consuming and uses a lot of disk space, and you just\n+want to explore the data structure without committing to a schema up front.\n+\n+You know that your log data contains specific fields that you want to extract.\n+By using runtime fields, you can define scripts to calculate values at search\n+time for these fields.\n+\n+You can start with a simple example by adding the `@timestamp` and `message`\n+fields to the `my-index` mapping. To remain flexible, use `wildcard` as the\n+field type for `message`.\n+\n+[source,console]\n+----\n+PUT /my-index/\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"@timestamp\": {\n+        \"format\": \"strict_date_optional_time||epoch_second\",\n+        \"type\": \"date\"\n+      },\n+      \"message\": {\n+        \"type\": \"wildcard\"\n+      }\n+    }\n+  }\n+}\n+----\n+\n+After mapping the fields you want to retrieve, index a few records from\n+your log data into {es}. The following request uses the <<docs-bulk,bulk API>>\n+to index raw log data into `my-index`. Instead of indexing all of your log\n+data, you can use a small sample to experiment with runtime fields.\n+\n+[source,console]\n+----\n+POST /my-index/_bulk?refresh\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-06-21T15:00:01-05:00\", \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-06-21T15:00:01-05:00\", \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:30:17-05:00\", \"message\" : \"40.135.0.0 - - [2020-04-30T14:30:17-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:30:53-05:00\", \"message\" : \"232.0.0.0 - - [2020-04-30T14:30:53-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:12-05:00\", \"message\" : \"26.1.0.0 - - [2020-04-30T14:31:12-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:19-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:19-05:00] \\\"GET /french/splash_inet.html HTTP/1.0\\\" 200 3781\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:27-05:00\", \"message\" : \"252.0.0.0 - - [2020-04-30T14:31:27-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:29-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:29-05:00] \\\"GET /images/hm_brdl.gif HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:29-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:29-05:00] \\\"GET /images/hm_arw.gif HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:32-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:32-05:00] \\\"GET /images/nav_bg_top.gif HTTP/1.0\\\" 200 929\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:43-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:43-05:00] \\\"GET /french/images/nav_venue_off.gif HTTP/1.0\\\" 304 0\"}\n+----\n+// TEST[continued]\n+\n+At this point, you can view how {es} stores your raw data.\n+\n+[source,console]\n+----\n+GET /my-index\n+----\n+// TEST[continued]\n+\n+The mapping contains two fields: `@timestamp` and `message`.\n+\n+[source,console-result]\n+----\n+{\n+  \"my-index\" : {\n+    \"mappings\" : {\n+      \"properties\" : {\n+        \"@timestamp\" : {\n+          \"type\" : \"date\",\n+          \"format\" : \"strict_date_optional_time||epoch_second\"\n+        },\n+        \"message\" : {\n+          \"type\" : \"wildcard\"\n+        }\n+      }\n+    },\n+    ...\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\\.\\.\\./\"aliases\": $body.my-index.aliases, \"settings\": $body.my-index.settings/]\n+\n+If you want to retrieve results that include `clientip`, you can add that field\n+as a runtime field in the mapping. The runtime script operates on the `clientip`\n+field at runtime to calculate values for that field.\n+\n+[source,console]\n+----\n+PUT /my-index/_mappings\n+{\n+  \"properties\": {\n+    \"clientip\": {\n+      \"type\": \"runtime\",\n+      \"runtime_type\": \"ip\",\n+      \"script\" : {\n+      \"source\" : \"String m = doc[\\\"message\\\"].value; int end = m.indexOf(\\\" \\\"); emit(m.substring(0, end));\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+Using the `clientip` runtime field, you can define a simple query to run a\n+search for a specific IP address and return all related fields.\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"query\": {\n+    \"match\": {\n+      \"clientip\": \"211.11.9.0\"\n+    }\n+  },\n+  \"fields\" : [\"*\"]\n+}\n+----\n+// TEST[continued]\n+\n+The API returns the following result. Without building your data structure in\n+advance, you can search and explore your data in meaningful ways to experiment\n+and determine which fields to index.\n+\n+[source,console-result]\n+----\n+{\n+  \"took\" : 150,\n+  \"timed_out\" : false,\n+  \"_shards\" : {\n+    \"total\" : 1,\n+    \"successful\" : 1,\n+    \"skipped\" : 0,\n+    \"failed\" : 0\n+  },\n+  \"hits\" : {\n+    \"total\" : {\n+      \"value\" : 2,\n+      \"relation\" : \"eq\"\n+    },\n+    \"max_score\" : 1.0,\n+    \"hits\" : [\n+      {\n+        \"_index\" : \"my-index\",\n+        \"_id\" : \"8Jh81nQBp2DRDXdiOxVt\",\n+        \"_score\" : 1.0,\n+        \"_source\" : {\n+          \"@timestamp\" : \"2020-06-21T15:00:01-05:00\",\n+          \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"\n+        },\n+        \"fields\" : {\n+          \"clientip\" : [\n+            \"211.11.9.0\"\n+          ],\n+          \"message\" : [\n+            \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"\n+          ],\n+          \"@timestamp\" : [\n+            \"2020-06-21T20:00:01.000Z\"\n+          ]\n+        }\n+      },\n+      {\n+        \"_index\" : \"my-index\",\n+        \"_id\" : \"8Zh81nQBp2DRDXdiOxVu\",\n+        \"_score\" : 1.0,\n+        \"_source\" : {\n+          \"@timestamp\" : \"2020-06-21T15:00:01-05:00\",\n+          \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"\n+        },\n+        \"fields\" : {\n+          \"clientip\" : [\n+            \"211.11.9.0\"\n+          ],\n+          \"message\" : [\n+            \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"\n+          ],\n+          \"@timestamp\" : [\n+            \"2020-06-21T20:00:01.000Z\"\n+          ]\n+        }\n+      }\n+    ]\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\" : 150/\"took\": $body.took/]\n+// TESTRESPONSE[s/\"_id\" : \"8Jh81nQBp2DRDXdiOxVt\"/\"_id\": $body.hits.hits.0._id/]\n+// TESTRESPONSE[s/\"_id\" : \"8Zh81nQBp2DRDXdiOxVu\"/\"_id\": $body.hits.hits.1._id/]\n+\n+If you add the `day_of_week` field to the mapping using the request in\n+<<runtime-mapping-fields,mapping a runtime field>>, you can re-run the previous\n+search request and also retrieve the day of the week based on the `@timestamp`\n+field.\n+\n+The value for this field was never indexed, and is calculated dynamically at\n+runtime. This flexibility allows you to modify the mapping without changing\n+any field values.", "originalCommit": "62a5393d1ffdb422169e7e8feabeeda10856fae4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5NjUzNA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496896534", "bodyText": "Yes, your rendition is much clearer. I think this reads better than the original:\n\nThe value for this field is calculated dynamically at runtime without reindexing the document or adding the day_of_week field.", "author": "lockewritesdocs", "createdAt": "2020-09-29T16:58:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjczMzYxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyOTIyNw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r496929227", "bodyText": "++", "author": "javanna", "createdAt": "2020-09-29T17:51:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjczMzYxNw=="}], "type": "inlineReview"}, {"oid": "36c92442308f8430dbeb881729c542b0fafde793", "url": "https://github.com/elastic/elasticsearch/commit/36c92442308f8430dbeb881729c542b0fafde793", "message": "Incorporating review feedback.", "committedDate": "2020-09-29T21:40:47Z", "type": "commit"}, {"oid": "804f10f5f0e51da6d4905c0f3c09f38dca43ae4e", "url": "https://github.com/elastic/elasticsearch/commit/804f10f5f0e51da6d4905c0f3c09f38dca43ae4e", "message": "Several clarifications, better test cases, and other changes.", "committedDate": "2020-09-30T21:21:55Z", "type": "commit"}, {"oid": "875713c0c86eca35f1282c9dce94ffa5f3b9c0e3", "url": "https://github.com/elastic/elasticsearch/commit/875713c0c86eca35f1282c9dce94ffa5f3b9c0e3", "message": "Adding missing callout in example.", "committedDate": "2020-10-01T14:21:10Z", "type": "commit"}, {"oid": "54d529adfd526d9f84d709328ecade6617517ded", "url": "https://github.com/elastic/elasticsearch/commit/54d529adfd526d9f84d709328ecade6617517ded", "message": "Adding substitutions to TESTRESPONSE for shorter results shown.", "committedDate": "2020-10-01T15:17:09Z", "type": "commit"}, {"oid": "7c1a7e084ffb94e89d0264c0fdc3fa0a55d3d376", "url": "https://github.com/elastic/elasticsearch/commit/7c1a7e084ffb94e89d0264c0fdc3fa0a55d3d376", "message": "Shuffling some information and adding link to script-fields.", "committedDate": "2020-10-26T21:08:09Z", "type": "commit"}, {"oid": "d3f3e4bae0b42e99dcc0816e64f22a910ad7011e", "url": "https://github.com/elastic/elasticsearch/commit/d3f3e4bae0b42e99dcc0816e64f22a910ad7011e", "message": "Fixing typo.", "committedDate": "2020-10-26T21:43:05Z", "type": "commit"}, {"oid": "3fe154187217bd3f6d0f1450c1f567289685d9b7", "url": "https://github.com/elastic/elasticsearch/commit/3fe154187217bd3f6d0f1450c1f567289685d9b7", "message": "Updates for API redesign -- will break builds.", "committedDate": "2020-10-30T14:42:46Z", "type": "commit"}, {"oid": "2d158ded58f29e18934fdb685465bfd1d74d32eb", "url": "https://github.com/elastic/elasticsearch/commit/2d158ded58f29e18934fdb685465bfd1d74d32eb", "message": "Merge branch 'master' into docs__add-runtime-fields", "committedDate": "2020-11-19T16:45:27Z", "type": "commit"}, {"oid": "6d495f024678e0ace4009169019da6bd9a13257f", "url": "https://github.com/elastic/elasticsearch/commit/6d495f024678e0ace4009169019da6bd9a13257f", "message": "Updating examples and including info about overriding fields.", "committedDate": "2020-11-23T22:00:50Z", "type": "commit"}, {"oid": "e00f80f6424280c8c545f2a82e5244bdcca504c2", "url": "https://github.com/elastic/elasticsearch/commit/e00f80f6424280c8c545f2a82e5244bdcca504c2", "message": "Updating examples.", "committedDate": "2020-11-24T15:09:46Z", "type": "commit"}, {"oid": "c631ce959e810f33c53c7c39f62c14b36b9c48d1", "url": "https://github.com/elastic/elasticsearch/commit/c631ce959e810f33c53c7c39f62c14b36b9c48d1", "message": "Merge branch 'master' into docs__add-runtime-fields", "committedDate": "2020-11-24T15:10:39Z", "type": "commit"}, {"oid": "8824beaf87b5399eb3e60491788a48b256b2e38b", "url": "https://github.com/elastic/elasticsearch/commit/8824beaf87b5399eb3e60491788a48b256b2e38b", "message": "Adding info for using runtime fields in the search request.", "committedDate": "2020-11-24T20:56:58Z", "type": "commit"}, {"oid": "282c2613d6e5d98c79a03ccc81d92cdc6cc02c9a", "url": "https://github.com/elastic/elasticsearch/commit/282c2613d6e5d98c79a03ccc81d92cdc6cc02c9a", "message": "Merge branch 'docs__add-runtime-fields' of github.com:lockewritesdocs/elasticsearch into docs__add-runtime-fields", "committedDate": "2020-11-24T20:57:35Z", "type": "commit"}, {"oid": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "url": "https://github.com/elastic/elasticsearch/commit/72cf35429ec99c248e7b3f3e914931b0dc936a05", "message": "Adding that queries against runtime fields are expensive.", "committedDate": "2020-11-25T17:16:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxMDExNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532510115", "bodyText": "runtime is no longer a field type, should it still go under mapping/types?", "author": "javanna", "createdAt": "2020-11-30T10:57:13Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4OTI4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532789286", "bodyText": "Good point. I'm moving runtime fields out of that nested structure and directly under Mappings.", "author": "lockewritesdocs", "createdAt": "2020-11-30T17:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxMDExNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg3OTI2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532879265", "bodyText": "It should not. I've modified the main Mapping page to include a section about runtime fields, and moved the associated page out from under the field types heading.", "author": "lockewritesdocs", "createdAt": "2020-11-30T20:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxMDExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxMDkwNg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532510906", "bodyText": "runtime_type no longer exists", "author": "javanna", "createdAt": "2020-11-30T10:58:32Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With _runtime fields_ beta[], you can explicitly\n+define a field in the mapping and access it at search time without indexing\n+your data during ingest time.\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. Runtime fields are accessible\n+from the search API like any other field. The <<search-field-caps,field capabilities API>> returns runtime fields as both searchable and aggregatable.\n+\n+By dynamically evaluating runtime fields at search time, you can optimize disk\n+space by choosing which fields to index. If you later decide that a runtime\n+field is increasingly used for filtering or aggregation, you can add the field\n+to `_source` to gain faster search speed.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or override field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain performance at search time\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+NOTE: Computing values for runtime fields in each document that might match a\n+query impacts search speed. Use the <<async-search,asynchronous search API>>\n+to run searches that include runtime fields.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+entire context of a document, the original `_source`, and the mapped field plus\n+its values (`doc_values`). At search time, the script runs and generates values\n+for each scripted field.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request. You can retrieve the results of running a script, but\n+also make the script results available for queries and aggregations.\n+\n+[[runtime-updating-scripts]]\n+.Updating runtime scripts\n+****\n+\n+Updating a script while a dependent query is running can return\n+inconsistent results. Each shard might have access to different versions of the\n+script, depending on when the mapping change takes effect.\n+\n+Existing queries or visualizations in {kib} that rely on runtime fields can\n+fail if you change the `runtime_type`. For example, a bar chart visualization", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MzMyOA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532793328", "bodyText": "I'll update this section to just mention the runtime field and not the removed runtime_type.", "author": "lockewritesdocs", "createdAt": "2020-11-30T18:01:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxMDkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxMTkwMw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532511903", "bodyText": "I think I see what you are after here, but I find this section slightly confusing, because the dot notation can also be used to specify fields that are not at the root level, regardless of whether they are also defined under properties.", "author": "javanna", "createdAt": "2020-11-30T11:00:05Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With _runtime fields_ beta[], you can explicitly\n+define a field in the mapping and access it at search time without indexing\n+your data during ingest time.\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. Runtime fields are accessible\n+from the search API like any other field. The <<search-field-caps,field capabilities API>> returns runtime fields as both searchable and aggregatable.\n+\n+By dynamically evaluating runtime fields at search time, you can optimize disk\n+space by choosing which fields to index. If you later decide that a runtime\n+field is increasingly used for filtering or aggregation, you can add the field\n+to `_source` to gain faster search speed.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or override field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain performance at search time\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+NOTE: Computing values for runtime fields in each document that might match a\n+query impacts search speed. Use the <<async-search,asynchronous search API>>\n+to run searches that include runtime fields.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+entire context of a document, the original `_source`, and the mapped field plus\n+its values (`doc_values`). At search time, the script runs and generates values\n+for each scripted field.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request. You can retrieve the results of running a script, but\n+also make the script results available for queries and aggregations.\n+\n+[[runtime-updating-scripts]]\n+.Updating runtime scripts\n+****\n+\n+Updating a script while a dependent query is running can return\n+inconsistent results. Each shard might have access to different versions of the\n+script, depending on when the mapping change takes effect.\n+\n+Existing queries or visualizations in {kib} that rely on runtime fields can\n+fail if you change the `runtime_type`. For example, a bar chart visualization\n+that uses a runtime field of `ip` will fail if the `runtime_type` is changed\n+to `boolean`.\n+\n+****\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` data type.\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `runtime` section of the mapping\n+definition.\n+<2> Each runtime has its own field type, just like any other field.\n+<3> The script defines the evaluation to calculate at search time.\n+\n+[[runtime-search-request]]\n+==== Defining runtime fields in a search request\n+You can specify a `runtime_mappings` section in a search request to create\n+runtime fields that exist only as part of the query. You must specify a script\n+as part of the `runtime_mappings` section, just as you would if adding a\n+runtime field to the mappings.\n+\n+In the following request, the values for the `day_of_week` field are calculated\n+dynamically, and only within the context of this search request.\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"day_of_week\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"day_of_week\": {\n+      \"terms\": {\n+        \"field\": \"day_of_week\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+[[runtime-overriding-fields]]\n+===== Overriding fields in the search request\n+You can use the `runtime_mappings` section of the `_search` request to override\n+field values inside objects by naming the runtime fields with dot notation. For\n+example, index the following documents into `my-index`.", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU0MjMxMg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r534542312", "bodyText": "I changed this section to Shadowing fields in the search request, and added the following:\n\nIf you create a runtime field with the same name as a field that\nalready exists in the mapping, the runtime field shadows the mapped field. At\nsearch time, {es} calculates the value of the runtime field and returns it as\npart of the query. Because the runtime field shadows the mapped field, you can\nmodify the value returned in search without modifying the mapped field.\nObjects are not supported in the \"runtime\" section under the\nmapping definition. However, you can use the runtime_mappings section of the\n_search request to shadow field values inside objects.", "author": "lockewritesdocs", "createdAt": "2020-12-02T23:05:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxMTkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxMjE1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532512153", "bodyText": "this no longer exists", "author": "javanna", "createdAt": "2020-11-30T11:00:28Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With _runtime fields_ beta[], you can explicitly\n+define a field in the mapping and access it at search time without indexing\n+your data during ingest time.\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. Runtime fields are accessible\n+from the search API like any other field. The <<search-field-caps,field capabilities API>> returns runtime fields as both searchable and aggregatable.\n+\n+By dynamically evaluating runtime fields at search time, you can optimize disk\n+space by choosing which fields to index. If you later decide that a runtime\n+field is increasingly used for filtering or aggregation, you can add the field\n+to `_source` to gain faster search speed.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or override field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain performance at search time\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+NOTE: Computing values for runtime fields in each document that might match a\n+query impacts search speed. Use the <<async-search,asynchronous search API>>\n+to run searches that include runtime fields.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+entire context of a document, the original `_source`, and the mapped field plus\n+its values (`doc_values`). At search time, the script runs and generates values\n+for each scripted field.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request. You can retrieve the results of running a script, but\n+also make the script results available for queries and aggregations.\n+\n+[[runtime-updating-scripts]]\n+.Updating runtime scripts\n+****\n+\n+Updating a script while a dependent query is running can return\n+inconsistent results. Each shard might have access to different versions of the\n+script, depending on when the mapping change takes effect.\n+\n+Existing queries or visualizations in {kib} that rely on runtime fields can\n+fail if you change the `runtime_type`. For example, a bar chart visualization\n+that uses a runtime field of `ip` will fail if the `runtime_type` is changed\n+to `boolean`.\n+\n+****\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` data type.\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `runtime` section of the mapping\n+definition.\n+<2> Each runtime has its own field type, just like any other field.\n+<3> The script defines the evaluation to calculate at search time.\n+\n+[[runtime-search-request]]\n+==== Defining runtime fields in a search request\n+You can specify a `runtime_mappings` section in a search request to create\n+runtime fields that exist only as part of the query. You must specify a script\n+as part of the `runtime_mappings` section, just as you would if adding a\n+runtime field to the mappings.\n+\n+In the following request, the values for the `day_of_week` field are calculated\n+dynamically, and only within the context of this search request.\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"day_of_week\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"day_of_week\": {\n+      \"terms\": {\n+        \"field\": \"day_of_week\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+[[runtime-overriding-fields]]\n+===== Overriding fields in the search request\n+You can use the `runtime_mappings` section of the `_search` request to override\n+field values inside objects by naming the runtime fields with dot notation. For\n+example, index the following documents into `my-index`.\n+\n+[source, console]\n+----\n+POST my-index/_bulk?refresh=true\n+{\"index\":{}}\n+{\"name\":{\"first\":\"Jose\",\"last\":\"Hickman\"}}\n+{\"index\":{}}\n+{\"name\":{\"first\":\"India\",\"last\":\"Avila\",\"suffix\":\"II\"}}\n+----\n+\n+In the `runtime_mappings` section of the `_search` request, you can define a\n+script that operates on the `name.first` field. The values you specify will\n+override fields in `_source` for the duration of the query without modifying\n+the field itself.\n+\n+The following request evaluates the `name.last` field and overrides the\n+`name.first` field in the search request based on the script valuation.\n+\n+[source,console]\n+----\n+POST my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"name.first\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"if (\\\"Hickman\\\".equals(doc[\\\"name.last.keyword\\\"].value)) {emit(\\\"Guile\\\");} else if (\\\"Avila\\\".equals(doc[\\\"name.last.keyword\\\"].value)) {emit(\\\"Anastasia\\\");}\"\n+      }\n+    }\n+  },\n+  \"query\": {\n+    \"match\": {\n+      \"name.first\": \"Anastasia\"\n+    }\n+  }\n+}\n+----\n+\n+[[runtime-params]]\n+==== Parameters for runtime fields\n+Runtime fields accept the following parameters:\n+\n+[[runtime-params-type]]\n+`type`::\n+The type of runtime computation to perform at query time. Currently, runtime\n+fields only support the `runtime` data type.\n+\n+[[runtime-params-runtime-type]]\n+`runtime_type`::", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg3ODMyNw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532878327", "bodyText": "Removed \u2702\ufe0f", "author": "lockewritesdocs", "createdAt": "2020-11-30T20:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxMjE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxMzAyMA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532513020", "bodyText": "More than \"use the API to return runtime fields\", I would say \"the fiels caps API returns runtime fields like any ordinary field", "author": "javanna", "createdAt": "2020-11-30T11:01:59Z", "path": "docs/reference/search/field-caps.asciidoc", "diffHunk": "@@ -34,6 +34,10 @@ GET /_field_caps?fields=rating\n The field capabilities API returns the information about the capabilities of\n fields among multiple indices.\n \n+Use the field capabilities API to return <<runtime,runtime fields>> like any", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg3NDEwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532874105", "bodyText": "I'll shorten this statement to:\n\nThe field capabilities API returns runtime fields like any other field.", "author": "lockewritesdocs", "createdAt": "2020-11-30T20:11:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxMzAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxMzE0OA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532513148", "bodyText": "runtime_type no longer exists", "author": "javanna", "createdAt": "2020-11-30T11:02:08Z", "path": "docs/reference/search/field-caps.asciidoc", "diffHunk": "@@ -34,6 +34,10 @@ GET /_field_caps?fields=rating\n The field capabilities API returns the information about the capabilities of\n fields among multiple indices.\n \n+Use the field capabilities API to return <<runtime,runtime fields>> like any\n+other field. For example, a runtime field with a `runtime_type` of\n+`keyword` returns as any other field that belongs to the `keyword` family.", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg3NDI4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532874281", "bodyText": "I'll change runtime_type to just \"type\".", "author": "lockewritesdocs", "createdAt": "2020-11-30T20:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxMzE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1NTc1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532755753", "bodyText": "In most scenarios the best way to use data in {es} is to index it in a schema, because indexing will provide the best query time performance. However, sometimes users want the flexibility to add fields after the documents were already ingested into {es}. Runtime fields enables users to add fields to documents that are already in {es} without needing to re-index. A runtime field includes instructions for calculating its value, and the value itself is calculated only at the time a query requires it. Runtime fields do not increase the index size and allow for faster ingest process, because a runtime field is not indexed.", "author": "giladgal", "createdAt": "2020-11-30T17:06:08Z", "path": "docs/reference/mapping/types.asciidoc", "diffHunk": "@@ -126,6 +126,31 @@ the <<analysis-standard-analyzer,`standard` analyzer>>, the\n This is the purpose of _multi-fields_. Most field types support multi-fields\n via the <<multi-fields>> parameter.\n \n+[discrete]\n+[[types-runtime]]\n+=== Runtime\n+{es} indexes most field types by default to promote faster search. However,", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3NTk0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532775949", "bodyText": "I think these might be better in recipe form at the end of the page. More work to build all the examples, but maybe easier to follow why we're doing it.", "author": "nik9000", "createdAt": "2020-11-30T17:35:18Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With _runtime fields_ beta[], you can explicitly\n+define a field in the mapping and access it at search time without indexing\n+your data during ingest time.\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. Runtime fields are accessible\n+from the search API like any other field. The <<search-field-caps,field capabilities API>> returns runtime fields as both searchable and aggregatable.\n+\n+By dynamically evaluating runtime fields at search time, you can optimize disk\n+space by choosing which fields to index. If you later decide that a runtime\n+field is increasingly used for filtering or aggregation, you can add the field\n+to `_source` to gain faster search speed.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or override field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain performance at search time\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3NjY4NA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532776684", "bodyText": "I dunno if I'm normal but I feel like this is too much words without enough examples or headings. I don't read good on the best of days and I'm usually skimming pages for useful headings.", "author": "nik9000", "createdAt": "2020-11-30T17:36:25Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With _runtime fields_ beta[], you can explicitly\n+define a field in the mapping and access it at search time without indexing\n+your data during ingest time.\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. Runtime fields are accessible\n+from the search API like any other field. The <<search-field-caps,field capabilities API>> returns runtime fields as both searchable and aggregatable.\n+\n+By dynamically evaluating runtime fields at search time, you can optimize disk\n+space by choosing which fields to index. If you later decide that a runtime\n+field is increasingly used for filtering or aggregation, you can add the field\n+to `_source` to gain faster search speed.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or override field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+Runtime fields help to alleviate several common issues when using {es}:", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg5MDM1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532890359", "bodyText": "This is a great observation, and is forcing me to rethink the structure of this information. I'm going to break it up into much more discrete sections that are move obvious and digestible.", "author": "lockewritesdocs", "createdAt": "2020-11-30T20:41:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3NjY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3NzYwMA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532777600", "bodyText": "I'd flip this around, I think. Like \"we prefer indexing a single field that is commonly searched, usually a timestamp, because it will generally make search much fast\". Maybe we just show it in the examples and explain why later.", "author": "nik9000", "createdAt": "2020-11-30T17:37:47Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With _runtime fields_ beta[], you can explicitly\n+define a field in the mapping and access it at search time without indexing\n+your data during ingest time.\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. Runtime fields are accessible\n+from the search API like any other field. The <<search-field-caps,field capabilities API>> returns runtime fields as both searchable and aggregatable.\n+\n+By dynamically evaluating runtime fields at search time, you can optimize disk\n+space by choosing which fields to index. If you later decide that a runtime\n+field is increasingly used for filtering or aggregation, you can add the field\n+to `_source` to gain faster search speed.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or override field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain performance at search time\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3ODEzMw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532778133", "bodyText": "I think a recipe for how to extract things from log data might be better at explaining it then a paragraph.", "author": "nik9000", "createdAt": "2020-11-30T17:38:40Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With _runtime fields_ beta[], you can explicitly\n+define a field in the mapping and access it at search time without indexing\n+your data during ingest time.\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. Runtime fields are accessible\n+from the search API like any other field. The <<search-field-caps,field capabilities API>> returns runtime fields as both searchable and aggregatable.\n+\n+By dynamically evaluating runtime fields at search time, you can optimize disk\n+space by choosing which fields to index. If you later decide that a runtime\n+field is increasingly used for filtering or aggregation, you can add the field\n+to `_source` to gain faster search speed.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or override field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain performance at search time\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+NOTE: Computing values for runtime fields in each document that might match a\n+query impacts search speed. Use the <<async-search,asynchronous search API>>\n+to run searches that include runtime fields.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUwMzA2NA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r533503064", "bodyText": "The Examples section shows how to extract stuff from log data. Is it enough to add a link from this paragraph to that section?", "author": "lockewritesdocs", "createdAt": "2020-12-01T15:30:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3ODEzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUyNTQyMg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r533525422", "bodyText": "I guess my question is, do we need the paragraph at all then? If we have examples that show, maybe we don't have to tell?", "author": "nik9000", "createdAt": "2020-12-01T15:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3ODEzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUyNzkzNA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r533527934", "bodyText": "I still think the information is relevant, especially since I've moved this bit into a separate section for Use cases. I can add a link to the Examples section from there. Also still need to incorporate changes for those bulleted items.", "author": "lockewritesdocs", "createdAt": "2020-12-01T16:01:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3ODEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3OTkyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532779921", "bodyText": "The _source and the doc values are pretty much the entire context of the document. So it might be more concise to just say \"doc values and _source.\"", "author": "nik9000", "createdAt": "2020-11-30T17:41:17Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With _runtime fields_ beta[], you can explicitly\n+define a field in the mapping and access it at search time without indexing\n+your data during ingest time.\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. Runtime fields are accessible\n+from the search API like any other field. The <<search-field-caps,field capabilities API>> returns runtime fields as both searchable and aggregatable.\n+\n+By dynamically evaluating runtime fields at search time, you can optimize disk\n+space by choosing which fields to index. If you later decide that a runtime\n+field is increasingly used for filtering or aggregation, you can add the field\n+to `_source` to gain faster search speed.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or override field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain performance at search time\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+NOTE: Computing values for runtime fields in each document that might match a\n+query impacts search speed. Use the <<async-search,asynchronous search API>>\n+to run searches that include runtime fields.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+entire context of a document, the original `_source`, and the mapped field plus", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4MDc4MA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532780780", "bodyText": "I think this might be missing a conjunction for it to make sense to me - runtime field are similar to script_fields but words words words.", "author": "nik9000", "createdAt": "2020-11-30T17:42:37Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With _runtime fields_ beta[], you can explicitly\n+define a field in the mapping and access it at search time without indexing\n+your data during ingest time.\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. Runtime fields are accessible\n+from the search API like any other field. The <<search-field-caps,field capabilities API>> returns runtime fields as both searchable and aggregatable.\n+\n+By dynamically evaluating runtime fields at search time, you can optimize disk\n+space by choosing which fields to index. If you later decide that a runtime\n+field is increasingly used for filtering or aggregation, you can add the field\n+to `_source` to gain faster search speed.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or override field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain performance at search time\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+NOTE: Computing values for runtime fields in each document that might match a\n+query impacts search speed. Use the <<async-search,asynchronous search API>>\n+to run searches that include runtime fields.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+entire context of a document, the original `_source`, and the mapped field plus\n+its values (`doc_values`). At search time, the script runs and generates values\n+for each scripted field.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request. You can retrieve the results of running a script, but\n+also make the script results available for queries and aggregations.", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUxMjgxNw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r533512817", "bodyText": "I think we can just shorten to:\n\nRuntime fields are similar to the script_fields parameter of the _search request, but also make the script results available for queries and aggregations.", "author": "lockewritesdocs", "createdAt": "2020-12-01T15:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4MDc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUyNTkwNw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r533525907", "bodyText": "\ud83d\udc4d", "author": "nik9000", "createdAt": "2020-12-01T15:58:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4MDc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4MTE3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532781175", "bodyText": "This'd be fine to move lower down. The sooner you get to an example the better.", "author": "nik9000", "createdAt": "2020-11-30T17:43:13Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With _runtime fields_ beta[], you can explicitly\n+define a field in the mapping and access it at search time without indexing\n+your data during ingest time.\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. Runtime fields are accessible\n+from the search API like any other field. The <<search-field-caps,field capabilities API>> returns runtime fields as both searchable and aggregatable.\n+\n+By dynamically evaluating runtime fields at search time, you can optimize disk\n+space by choosing which fields to index. If you later decide that a runtime\n+field is increasingly used for filtering or aggregation, you can add the field\n+to `_source` to gain faster search speed.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or override field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain performance at search time\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+NOTE: Computing values for runtime fields in each document that might match a\n+query impacts search speed. Use the <<async-search,asynchronous search API>>\n+to run searches that include runtime fields.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+entire context of a document, the original `_source`, and the mapped field plus\n+its values (`doc_values`). At search time, the script runs and generates values\n+for each scripted field.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request. You can retrieve the results of running a script, but\n+also make the script results available for queries and aggregations.\n+\n+[[runtime-updating-scripts]]\n+.Updating runtime scripts\n+****\n+\n+Updating a script while a dependent query is running can return", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4MTIzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532781239", "bodyText": "I think.", "author": "nik9000", "createdAt": "2020-11-30T17:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4MTE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUxMzc2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r533513767", "bodyText": "I'm on board with that suggestion. I'll move this section to after the example.", "author": "lockewritesdocs", "createdAt": "2020-12-01T15:43:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4MTE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4MjUwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532782501", "bodyText": "Maybe this should merge with the warning about async search?", "author": "nik9000", "createdAt": "2020-11-30T17:45:12Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With _runtime fields_ beta[], you can explicitly\n+define a field in the mapping and access it at search time without indexing\n+your data during ingest time.\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. Runtime fields are accessible\n+from the search API like any other field. The <<search-field-caps,field capabilities API>> returns runtime fields as both searchable and aggregatable.\n+\n+By dynamically evaluating runtime fields at search time, you can optimize disk\n+space by choosing which fields to index. If you later decide that a runtime\n+field is increasingly used for filtering or aggregation, you can add the field\n+to `_source` to gain faster search speed.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or override field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain performance at search time\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+NOTE: Computing values for runtime fields in each document that might match a\n+query impacts search speed. Use the <<async-search,asynchronous search API>>\n+to run searches that include runtime fields.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+entire context of a document, the original `_source`, and the mapped field plus\n+its values (`doc_values`). At search time, the script runs and generates values\n+for each scripted field.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request. You can retrieve the results of running a script, but\n+also make the script results available for queries and aggregations.\n+\n+[[runtime-updating-scripts]]\n+.Updating runtime scripts\n+****\n+\n+Updating a script while a dependent query is running can return\n+inconsistent results. Each shard might have access to different versions of the\n+script, depending on when the mapping change takes effect.\n+\n+Existing queries or visualizations in {kib} that rely on runtime fields can\n+fail if you change the `runtime_type`. For example, a bar chart visualization\n+that uses a runtime field of `ip` will fail if the `runtime_type` is changed\n+to `boolean`.\n+\n+****\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` data type.\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `runtime` section of the mapping\n+definition.\n+<2> Each runtime has its own field type, just like any other field.\n+<3> The script defines the evaluation to calculate at search time.\n+\n+[[runtime-search-request]]\n+==== Defining runtime fields in a search request\n+You can specify a `runtime_mappings` section in a search request to create\n+runtime fields that exist only as part of the query. You must specify a script\n+as part of the `runtime_mappings` section, just as you would if adding a\n+runtime field to the mappings.\n+\n+In the following request, the values for the `day_of_week` field are calculated\n+dynamically, and only within the context of this search request.\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"day_of_week\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"day_of_week\": {\n+      \"terms\": {\n+        \"field\": \"day_of_week\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+[[runtime-overriding-fields]]\n+===== Overriding fields in the search request\n+You can use the `runtime_mappings` section of the `_search` request to override\n+field values inside objects by naming the runtime fields with dot notation. For\n+example, index the following documents into `my-index`.\n+\n+[source, console]\n+----\n+POST my-index/_bulk?refresh=true\n+{\"index\":{}}\n+{\"name\":{\"first\":\"Jose\",\"last\":\"Hickman\"}}\n+{\"index\":{}}\n+{\"name\":{\"first\":\"India\",\"last\":\"Avila\",\"suffix\":\"II\"}}\n+----\n+\n+In the `runtime_mappings` section of the `_search` request, you can define a\n+script that operates on the `name.first` field. The values you specify will\n+override fields in `_source` for the duration of the query without modifying\n+the field itself.\n+\n+The following request evaluates the `name.last` field and overrides the\n+`name.first` field in the search request based on the script valuation.\n+\n+[source,console]\n+----\n+POST my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"name.first\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"if (\\\"Hickman\\\".equals(doc[\\\"name.last.keyword\\\"].value)) {emit(\\\"Guile\\\");} else if (\\\"Avila\\\".equals(doc[\\\"name.last.keyword\\\"].value)) {emit(\\\"Anastasia\\\");}\"\n+      }\n+    }\n+  },\n+  \"query\": {\n+    \"match\": {\n+      \"name.first\": \"Anastasia\"\n+    }\n+  }\n+}\n+----\n+\n+[[runtime-params]]\n+==== Parameters for runtime fields\n+Runtime fields accept the following parameters:\n+\n+[[runtime-params-type]]\n+`type`::\n+The type of runtime computation to perform at query time. Currently, runtime\n+fields only support the `runtime` data type.\n+\n+[[runtime-params-runtime-type]]\n+`runtime_type`::\n+The <<mapping-types,field type>> for each scripted field. {es}\n+supports `boolean`, `date`, `double`, `ip`, `keyword`, and `long`.\n++\n+Runtime fields with a `runtime_type` of `date` can accept the\n+<<mapping-date-format,`format`>> parameter exactly as the `date` field type.\n+\n+[[runtime-params-script]]\n+`script`::\n+The <<modules-scripting-using,painless script>> that is evaluated at search\n+time to produce the value of the runtime field.\n+\n+[[runtime-retrieving-fields]]\n+==== Retrieving a runtime field\n+Use the <<search-fields,`fields`>> parameter on the `_search` API to retrieve\n+the values of runtime fields. Runtime fields won't display in `_source`, but\n+the `fields` API works for all fields, even those that were not sent as part of\n+the original `_source`.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4MzEzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532783131", "bodyText": "Also, it feels like it is in the wrong section. Retrieving the values isn't expensive. I mean, more expensive than _source access, but not terrible. But querying them can be.", "author": "nik9000", "createdAt": "2020-11-30T17:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4MjUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg5MjE1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532892157", "bodyText": "I'm moving this note to a Tradeoffs section and combining it with other relevant information.", "author": "lockewritesdocs", "createdAt": "2020-11-30T20:45:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4MjUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4MzQ2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532783462", "bodyText": "If you just want to document returning them then I wouldn't search in the same example.", "author": "nik9000", "createdAt": "2020-11-30T17:46:37Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With _runtime fields_ beta[], you can explicitly\n+define a field in the mapping and access it at search time without indexing\n+your data during ingest time.\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. Runtime fields are accessible\n+from the search API like any other field. The <<search-field-caps,field capabilities API>> returns runtime fields as both searchable and aggregatable.\n+\n+By dynamically evaluating runtime fields at search time, you can optimize disk\n+space by choosing which fields to index. If you later decide that a runtime\n+field is increasingly used for filtering or aggregation, you can add the field\n+to `_source` to gain faster search speed.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or override field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain performance at search time\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+NOTE: Computing values for runtime fields in each document that might match a\n+query impacts search speed. Use the <<async-search,asynchronous search API>>\n+to run searches that include runtime fields.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+entire context of a document, the original `_source`, and the mapped field plus\n+its values (`doc_values`). At search time, the script runs and generates values\n+for each scripted field.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request. You can retrieve the results of running a script, but\n+also make the script results available for queries and aggregations.\n+\n+[[runtime-updating-scripts]]\n+.Updating runtime scripts\n+****\n+\n+Updating a script while a dependent query is running can return\n+inconsistent results. Each shard might have access to different versions of the\n+script, depending on when the mapping change takes effect.\n+\n+Existing queries or visualizations in {kib} that rely on runtime fields can\n+fail if you change the `runtime_type`. For example, a bar chart visualization\n+that uses a runtime field of `ip` will fail if the `runtime_type` is changed\n+to `boolean`.\n+\n+****\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` data type.\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `runtime` section of the mapping\n+definition.\n+<2> Each runtime has its own field type, just like any other field.\n+<3> The script defines the evaluation to calculate at search time.\n+\n+[[runtime-search-request]]\n+==== Defining runtime fields in a search request\n+You can specify a `runtime_mappings` section in a search request to create\n+runtime fields that exist only as part of the query. You must specify a script\n+as part of the `runtime_mappings` section, just as you would if adding a\n+runtime field to the mappings.\n+\n+In the following request, the values for the `day_of_week` field are calculated\n+dynamically, and only within the context of this search request.\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"day_of_week\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"day_of_week\": {\n+      \"terms\": {\n+        \"field\": \"day_of_week\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+[[runtime-overriding-fields]]\n+===== Overriding fields in the search request\n+You can use the `runtime_mappings` section of the `_search` request to override\n+field values inside objects by naming the runtime fields with dot notation. For\n+example, index the following documents into `my-index`.\n+\n+[source, console]\n+----\n+POST my-index/_bulk?refresh=true\n+{\"index\":{}}\n+{\"name\":{\"first\":\"Jose\",\"last\":\"Hickman\"}}\n+{\"index\":{}}\n+{\"name\":{\"first\":\"India\",\"last\":\"Avila\",\"suffix\":\"II\"}}\n+----\n+\n+In the `runtime_mappings` section of the `_search` request, you can define a\n+script that operates on the `name.first` field. The values you specify will\n+override fields in `_source` for the duration of the query without modifying\n+the field itself.\n+\n+The following request evaluates the `name.last` field and overrides the\n+`name.first` field in the search request based on the script valuation.\n+\n+[source,console]\n+----\n+POST my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"name.first\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"if (\\\"Hickman\\\".equals(doc[\\\"name.last.keyword\\\"].value)) {emit(\\\"Guile\\\");} else if (\\\"Avila\\\".equals(doc[\\\"name.last.keyword\\\"].value)) {emit(\\\"Anastasia\\\");}\"\n+      }\n+    }\n+  },\n+  \"query\": {\n+    \"match\": {\n+      \"name.first\": \"Anastasia\"\n+    }\n+  }\n+}\n+----\n+\n+[[runtime-params]]\n+==== Parameters for runtime fields\n+Runtime fields accept the following parameters:\n+\n+[[runtime-params-type]]\n+`type`::\n+The type of runtime computation to perform at query time. Currently, runtime\n+fields only support the `runtime` data type.\n+\n+[[runtime-params-runtime-type]]\n+`runtime_type`::\n+The <<mapping-types,field type>> for each scripted field. {es}\n+supports `boolean`, `date`, `double`, `ip`, `keyword`, and `long`.\n++\n+Runtime fields with a `runtime_type` of `date` can accept the\n+<<mapping-date-format,`format`>> parameter exactly as the `date` field type.\n+\n+[[runtime-params-script]]\n+`script`::\n+The <<modules-scripting-using,painless script>> that is evaluated at search\n+time to produce the value of the runtime field.\n+\n+[[runtime-retrieving-fields]]\n+==== Retrieving a runtime field\n+Use the <<search-fields,`fields`>> parameter on the `_search` API to retrieve\n+the values of runtime fields. Runtime fields won't display in `_source`, but\n+the `fields` API works for all fields, even those that were not sent as part of\n+the original `_source`.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+The following request uses the search API to retrieve the `day_of_week` field\n+that the <<runtime-mapping-fields,previous request>> defined as a runtime field\n+in the mapping. The value for the `day_of_week` field is calculated dynamically\n+at search time, and the following search request retrieves any documents where\n+the calculated value is equal to `Thursday`.\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"query\": {\n+    \"match\": {\n+      \"day_of_week\": \"Thursday\"", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4NDI2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532784261", "bodyText": "Maybe remove the aliases line? I see you adding it with ....", "author": "nik9000", "createdAt": "2020-11-30T17:47:47Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With _runtime fields_ beta[], you can explicitly\n+define a field in the mapping and access it at search time without indexing\n+your data during ingest time.\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. Runtime fields are accessible\n+from the search API like any other field. The <<search-field-caps,field capabilities API>> returns runtime fields as both searchable and aggregatable.\n+\n+By dynamically evaluating runtime fields at search time, you can optimize disk\n+space by choosing which fields to index. If you later decide that a runtime\n+field is increasingly used for filtering or aggregation, you can add the field\n+to `_source` to gain faster search speed.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or override field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain performance at search time\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+NOTE: Computing values for runtime fields in each document that might match a\n+query impacts search speed. Use the <<async-search,asynchronous search API>>\n+to run searches that include runtime fields.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+entire context of a document, the original `_source`, and the mapped field plus\n+its values (`doc_values`). At search time, the script runs and generates values\n+for each scripted field.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request. You can retrieve the results of running a script, but\n+also make the script results available for queries and aggregations.\n+\n+[[runtime-updating-scripts]]\n+.Updating runtime scripts\n+****\n+\n+Updating a script while a dependent query is running can return\n+inconsistent results. Each shard might have access to different versions of the\n+script, depending on when the mapping change takes effect.\n+\n+Existing queries or visualizations in {kib} that rely on runtime fields can\n+fail if you change the `runtime_type`. For example, a bar chart visualization\n+that uses a runtime field of `ip` will fail if the `runtime_type` is changed\n+to `boolean`.\n+\n+****\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` data type.\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `runtime` section of the mapping\n+definition.\n+<2> Each runtime has its own field type, just like any other field.\n+<3> The script defines the evaluation to calculate at search time.\n+\n+[[runtime-search-request]]\n+==== Defining runtime fields in a search request\n+You can specify a `runtime_mappings` section in a search request to create\n+runtime fields that exist only as part of the query. You must specify a script\n+as part of the `runtime_mappings` section, just as you would if adding a\n+runtime field to the mappings.\n+\n+In the following request, the values for the `day_of_week` field are calculated\n+dynamically, and only within the context of this search request.\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"day_of_week\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"day_of_week\": {\n+      \"terms\": {\n+        \"field\": \"day_of_week\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+[[runtime-overriding-fields]]\n+===== Overriding fields in the search request\n+You can use the `runtime_mappings` section of the `_search` request to override\n+field values inside objects by naming the runtime fields with dot notation. For\n+example, index the following documents into `my-index`.\n+\n+[source, console]\n+----\n+POST my-index/_bulk?refresh=true\n+{\"index\":{}}\n+{\"name\":{\"first\":\"Jose\",\"last\":\"Hickman\"}}\n+{\"index\":{}}\n+{\"name\":{\"first\":\"India\",\"last\":\"Avila\",\"suffix\":\"II\"}}\n+----\n+\n+In the `runtime_mappings` section of the `_search` request, you can define a\n+script that operates on the `name.first` field. The values you specify will\n+override fields in `_source` for the duration of the query without modifying\n+the field itself.\n+\n+The following request evaluates the `name.last` field and overrides the\n+`name.first` field in the search request based on the script valuation.\n+\n+[source,console]\n+----\n+POST my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"name.first\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"if (\\\"Hickman\\\".equals(doc[\\\"name.last.keyword\\\"].value)) {emit(\\\"Guile\\\");} else if (\\\"Avila\\\".equals(doc[\\\"name.last.keyword\\\"].value)) {emit(\\\"Anastasia\\\");}\"\n+      }\n+    }\n+  },\n+  \"query\": {\n+    \"match\": {\n+      \"name.first\": \"Anastasia\"\n+    }\n+  }\n+}\n+----\n+\n+[[runtime-params]]\n+==== Parameters for runtime fields\n+Runtime fields accept the following parameters:\n+\n+[[runtime-params-type]]\n+`type`::\n+The type of runtime computation to perform at query time. Currently, runtime\n+fields only support the `runtime` data type.\n+\n+[[runtime-params-runtime-type]]\n+`runtime_type`::\n+The <<mapping-types,field type>> for each scripted field. {es}\n+supports `boolean`, `date`, `double`, `ip`, `keyword`, and `long`.\n++\n+Runtime fields with a `runtime_type` of `date` can accept the\n+<<mapping-date-format,`format`>> parameter exactly as the `date` field type.\n+\n+[[runtime-params-script]]\n+`script`::\n+The <<modules-scripting-using,painless script>> that is evaluated at search\n+time to produce the value of the runtime field.\n+\n+[[runtime-retrieving-fields]]\n+==== Retrieving a runtime field\n+Use the <<search-fields,`fields`>> parameter on the `_search` API to retrieve\n+the values of runtime fields. Runtime fields won't display in `_source`, but\n+the `fields` API works for all fields, even those that were not sent as part of\n+the original `_source`.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+The following request uses the search API to retrieve the `day_of_week` field\n+that the <<runtime-mapping-fields,previous request>> defined as a runtime field\n+in the mapping. The value for the `day_of_week` field is calculated dynamically\n+at search time, and the following search request retrieves any documents where\n+the calculated value is equal to `Thursday`.\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"query\": {\n+    \"match\": {\n+      \"day_of_week\": \"Thursday\"\n+    }\n+  },\n+  \"fields\": [\n+    \"@timestamp\", \"day_of_week\"\n+  ],\n+  \"_source\": false\n+}\n+----\n+// TEST[continued]\n+\n+[[runtime-examples]]\n+==== Examples\n+Consider a large set of log data that you want to extract fields from.\n+Indexing the data is time consuming and uses a lot of disk space, and you just\n+want to explore the data structure without committing to a schema up front.\n+\n+You know that your log data contains specific fields that you want to extract.\n+By using runtime fields, you can define scripts to calculate values at search\n+time for these fields.\n+\n+You can start with a simple example by adding the `@timestamp` and `message`\n+fields to the `my-index` mapping. To remain flexible, use `wildcard` as the\n+field type for `message`.\n+\n+[source,console]\n+----\n+PUT /my-index/\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"@timestamp\": {\n+        \"format\": \"strict_date_optional_time||epoch_second\",\n+        \"type\": \"date\"\n+      },\n+      \"message\": {\n+        \"type\": \"wildcard\"\n+      }\n+    }\n+  }\n+}\n+----\n+\n+After mapping the fields you want to retrieve, index a few records from\n+your log data into {es}. The following request uses the <<docs-bulk,bulk API>>\n+to index raw log data into `my-index`. Instead of indexing all of your log\n+data, you can use a small sample to experiment with runtime fields.\n+\n+[source,console]\n+----\n+POST /my-index/_bulk?refresh\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-06-21T15:00:01-05:00\", \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-06-21T15:00:01-05:00\", \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:30:17-05:00\", \"message\" : \"40.135.0.0 - - [2020-04-30T14:30:17-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:30:53-05:00\", \"message\" : \"232.0.0.0 - - [2020-04-30T14:30:53-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:12-05:00\", \"message\" : \"26.1.0.0 - - [2020-04-30T14:31:12-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:19-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:19-05:00] \\\"GET /french/splash_inet.html HTTP/1.0\\\" 200 3781\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:27-05:00\", \"message\" : \"252.0.0.0 - - [2020-04-30T14:31:27-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:29-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:29-05:00] \\\"GET /images/hm_brdl.gif HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:29-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:29-05:00] \\\"GET /images/hm_arw.gif HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:32-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:32-05:00] \\\"GET /images/nav_bg_top.gif HTTP/1.0\\\" 200 929\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:43-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:43-05:00] \\\"GET /french/images/nav_venue_off.gif HTTP/1.0\\\" 304 0\"}\n+----\n+// TEST[continued]\n+\n+At this point, you can view how {es} stores your raw data.\n+\n+[source,console]\n+----\n+GET /my-index\n+----\n+// TEST[continued]\n+\n+The mapping contains two fields: `@timestamp` and `message`.\n+\n+[source,console-result]\n+----\n+{\n+  \"my-index\" : {\n+    \"aliases\" : { },", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY4NjMyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r533686321", "bodyText": "Makes sense. I kept it there for completeness, but it doesn't really add anything.", "author": "lockewritesdocs", "createdAt": "2020-12-01T20:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4NDI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4NDY5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532784692", "bodyText": "I think it'd be best if the example only returned a single line because it'd be a little smaller on the screen and still show everything.", "author": "nik9000", "createdAt": "2020-11-30T17:48:28Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With _runtime fields_ beta[], you can explicitly\n+define a field in the mapping and access it at search time without indexing\n+your data during ingest time.\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. Runtime fields are accessible\n+from the search API like any other field. The <<search-field-caps,field capabilities API>> returns runtime fields as both searchable and aggregatable.\n+\n+By dynamically evaluating runtime fields at search time, you can optimize disk\n+space by choosing which fields to index. If you later decide that a runtime\n+field is increasingly used for filtering or aggregation, you can add the field\n+to `_source` to gain faster search speed.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or override field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain performance at search time\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+NOTE: Computing values for runtime fields in each document that might match a\n+query impacts search speed. Use the <<async-search,asynchronous search API>>\n+to run searches that include runtime fields.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+entire context of a document, the original `_source`, and the mapped field plus\n+its values (`doc_values`). At search time, the script runs and generates values\n+for each scripted field.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request. You can retrieve the results of running a script, but\n+also make the script results available for queries and aggregations.\n+\n+[[runtime-updating-scripts]]\n+.Updating runtime scripts\n+****\n+\n+Updating a script while a dependent query is running can return\n+inconsistent results. Each shard might have access to different versions of the\n+script, depending on when the mapping change takes effect.\n+\n+Existing queries or visualizations in {kib} that rely on runtime fields can\n+fail if you change the `runtime_type`. For example, a bar chart visualization\n+that uses a runtime field of `ip` will fail if the `runtime_type` is changed\n+to `boolean`.\n+\n+****\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` data type.\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `runtime` section of the mapping\n+definition.\n+<2> Each runtime has its own field type, just like any other field.\n+<3> The script defines the evaluation to calculate at search time.\n+\n+[[runtime-search-request]]\n+==== Defining runtime fields in a search request\n+You can specify a `runtime_mappings` section in a search request to create\n+runtime fields that exist only as part of the query. You must specify a script\n+as part of the `runtime_mappings` section, just as you would if adding a\n+runtime field to the mappings.\n+\n+In the following request, the values for the `day_of_week` field are calculated\n+dynamically, and only within the context of this search request.\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"day_of_week\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"day_of_week\": {\n+      \"terms\": {\n+        \"field\": \"day_of_week\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+[[runtime-overriding-fields]]\n+===== Overriding fields in the search request\n+You can use the `runtime_mappings` section of the `_search` request to override\n+field values inside objects by naming the runtime fields with dot notation. For\n+example, index the following documents into `my-index`.\n+\n+[source, console]\n+----\n+POST my-index/_bulk?refresh=true\n+{\"index\":{}}\n+{\"name\":{\"first\":\"Jose\",\"last\":\"Hickman\"}}\n+{\"index\":{}}\n+{\"name\":{\"first\":\"India\",\"last\":\"Avila\",\"suffix\":\"II\"}}\n+----\n+\n+In the `runtime_mappings` section of the `_search` request, you can define a\n+script that operates on the `name.first` field. The values you specify will\n+override fields in `_source` for the duration of the query without modifying\n+the field itself.\n+\n+The following request evaluates the `name.last` field and overrides the\n+`name.first` field in the search request based on the script valuation.\n+\n+[source,console]\n+----\n+POST my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"name.first\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"if (\\\"Hickman\\\".equals(doc[\\\"name.last.keyword\\\"].value)) {emit(\\\"Guile\\\");} else if (\\\"Avila\\\".equals(doc[\\\"name.last.keyword\\\"].value)) {emit(\\\"Anastasia\\\");}\"\n+      }\n+    }\n+  },\n+  \"query\": {\n+    \"match\": {\n+      \"name.first\": \"Anastasia\"\n+    }\n+  }\n+}\n+----\n+\n+[[runtime-params]]\n+==== Parameters for runtime fields\n+Runtime fields accept the following parameters:\n+\n+[[runtime-params-type]]\n+`type`::\n+The type of runtime computation to perform at query time. Currently, runtime\n+fields only support the `runtime` data type.\n+\n+[[runtime-params-runtime-type]]\n+`runtime_type`::\n+The <<mapping-types,field type>> for each scripted field. {es}\n+supports `boolean`, `date`, `double`, `ip`, `keyword`, and `long`.\n++\n+Runtime fields with a `runtime_type` of `date` can accept the\n+<<mapping-date-format,`format`>> parameter exactly as the `date` field type.\n+\n+[[runtime-params-script]]\n+`script`::\n+The <<modules-scripting-using,painless script>> that is evaluated at search\n+time to produce the value of the runtime field.\n+\n+[[runtime-retrieving-fields]]\n+==== Retrieving a runtime field\n+Use the <<search-fields,`fields`>> parameter on the `_search` API to retrieve\n+the values of runtime fields. Runtime fields won't display in `_source`, but\n+the `fields` API works for all fields, even those that were not sent as part of\n+the original `_source`.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+The following request uses the search API to retrieve the `day_of_week` field\n+that the <<runtime-mapping-fields,previous request>> defined as a runtime field\n+in the mapping. The value for the `day_of_week` field is calculated dynamically\n+at search time, and the following search request retrieves any documents where\n+the calculated value is equal to `Thursday`.\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"query\": {\n+    \"match\": {\n+      \"day_of_week\": \"Thursday\"\n+    }\n+  },\n+  \"fields\": [\n+    \"@timestamp\", \"day_of_week\"\n+  ],\n+  \"_source\": false\n+}\n+----\n+// TEST[continued]\n+\n+[[runtime-examples]]\n+==== Examples\n+Consider a large set of log data that you want to extract fields from.\n+Indexing the data is time consuming and uses a lot of disk space, and you just\n+want to explore the data structure without committing to a schema up front.\n+\n+You know that your log data contains specific fields that you want to extract.\n+By using runtime fields, you can define scripts to calculate values at search\n+time for these fields.\n+\n+You can start with a simple example by adding the `@timestamp` and `message`\n+fields to the `my-index` mapping. To remain flexible, use `wildcard` as the\n+field type for `message`.\n+\n+[source,console]\n+----\n+PUT /my-index/\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"@timestamp\": {\n+        \"format\": \"strict_date_optional_time||epoch_second\",\n+        \"type\": \"date\"\n+      },\n+      \"message\": {\n+        \"type\": \"wildcard\"\n+      }\n+    }\n+  }\n+}\n+----\n+\n+After mapping the fields you want to retrieve, index a few records from\n+your log data into {es}. The following request uses the <<docs-bulk,bulk API>>\n+to index raw log data into `my-index`. Instead of indexing all of your log\n+data, you can use a small sample to experiment with runtime fields.\n+\n+[source,console]\n+----\n+POST /my-index/_bulk?refresh\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-06-21T15:00:01-05:00\", \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-06-21T15:00:01-05:00\", \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:30:17-05:00\", \"message\" : \"40.135.0.0 - - [2020-04-30T14:30:17-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:30:53-05:00\", \"message\" : \"232.0.0.0 - - [2020-04-30T14:30:53-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:12-05:00\", \"message\" : \"26.1.0.0 - - [2020-04-30T14:31:12-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:19-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:19-05:00] \\\"GET /french/splash_inet.html HTTP/1.0\\\" 200 3781\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:27-05:00\", \"message\" : \"252.0.0.0 - - [2020-04-30T14:31:27-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:29-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:29-05:00] \\\"GET /images/hm_brdl.gif HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:29-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:29-05:00] \\\"GET /images/hm_arw.gif HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:32-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:32-05:00] \\\"GET /images/nav_bg_top.gif HTTP/1.0\\\" 200 929\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:43-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:43-05:00] \\\"GET /french/images/nav_venue_off.gif HTTP/1.0\\\" 304 0\"}\n+----\n+// TEST[continued]\n+\n+At this point, you can view how {es} stores your raw data.\n+\n+[source,console]\n+----\n+GET /my-index\n+----\n+// TEST[continued]\n+\n+The mapping contains two fields: `@timestamp` and `message`.\n+\n+[source,console-result]\n+----\n+{\n+  \"my-index\" : {\n+    \"aliases\" : { },\n+    \"mappings\" : {\n+      \"properties\" : {\n+        \"@timestamp\" : {\n+          \"type\" : \"date\",\n+          \"format\" : \"strict_date_optional_time||epoch_second\"\n+        },\n+        \"message\" : {\n+          \"type\" : \"wildcard\"\n+        }\n+      }\n+    },\n+    ...\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\\.\\.\\./\"aliases\": $body.my-index.aliases, \"settings\": $body.my-index.settings/]\n+\n+If you want to retrieve results that include `clientip`, you can add that field\n+as a runtime field in the mapping. The runtime script operates on the `clientip`\n+field at runtime to calculate values for that field.\n+\n+[source,console]\n+----\n+PUT /my-index/_mapping\n+{\n+  \"runtime\": {\n+    \"clientip\": {\n+      \"type\": \"ip\",\n+      \"script\" : {\n+      \"source\" : \"String m = doc[\\\"message\\\"].value; int end = m.indexOf(\\\" \\\"); emit(m.substring(0, end));\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+Using the `clientip` runtime field, you can define a simple query to run a\n+search for a specific IP address and return all related fields.\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"query\": {\n+    \"match\": {\n+      \"clientip\": \"211.11.9.0\"\n+    }\n+  },\n+  \"fields\" : [\"*\"]\n+}\n+----\n+// TEST[continued]\n+\n+The API returns the following result. Without building your data structure in\n+advance, you can search and explore your data in meaningful ways to experiment\n+and determine which fields to index.\n+\n+[source,console-result]\n+----\n+{\n+  ...\n+  \"hits\" : {\n+    \"total\" : {\n+      \"value\" : 2,\n+      \"relation\" : \"eq\"\n+    },\n+    \"max_score\" : 1.0,\n+    \"hits\" : [\n+      {\n+        \"_index\" : \"my-index\",\n+        \"_id\" : \"8Jh81nQBp2DRDXdiOxVt\",\n+        \"_score\" : 1.0,\n+        \"_source\" : {\n+          \"@timestamp\" : \"2020-06-21T15:00:01-05:00\",\n+          \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"\n+        },\n+        \"fields\" : {\n+          \"clientip\" : [\n+            \"211.11.9.0\"\n+          ],\n+          \"message\" : [\n+            \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"\n+          ],\n+          \"@timestamp\" : [\n+            \"2020-06-21T20:00:01.000Z\"\n+          ]\n+        }\n+      },\n+      {", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU5NjY3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r533596676", "bodyText": "@nik9000, do you mean return the same results but not formatted? If so, that means users have to scroll really far to the right, which I think is difficult to read.", "author": "lockewritesdocs", "createdAt": "2020-12-01T17:35:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4NDY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcwMDUyNw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r533700527", "bodyText": "sorry! I mean a single doc. formatted is just fine. You can certainly play with the formatting to make it smaller. The tests don't mind. It might be worth doing a little of that, but not much. Like, now that I think about it, maybe moving the arrays in fields to a single line each. But, yeah, I just meant one result.", "author": "nik9000", "createdAt": "2020-12-01T20:28:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4NDY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4NTUzNA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532785534", "bodyText": "I think you could show the actual mapping put to add day_of_week or whatever and keep the // TEST[continued] going.", "author": "nik9000", "createdAt": "2020-11-30T17:49:46Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With _runtime fields_ beta[], you can explicitly\n+define a field in the mapping and access it at search time without indexing\n+your data during ingest time.\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. Runtime fields are accessible\n+from the search API like any other field. The <<search-field-caps,field capabilities API>> returns runtime fields as both searchable and aggregatable.\n+\n+By dynamically evaluating runtime fields at search time, you can optimize disk\n+space by choosing which fields to index. If you later decide that a runtime\n+field is increasingly used for filtering or aggregation, you can add the field\n+to `_source` to gain faster search speed.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or override field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain performance at search time\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+NOTE: Computing values for runtime fields in each document that might match a\n+query impacts search speed. Use the <<async-search,asynchronous search API>>\n+to run searches that include runtime fields.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+entire context of a document, the original `_source`, and the mapped field plus\n+its values (`doc_values`). At search time, the script runs and generates values\n+for each scripted field.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request. You can retrieve the results of running a script, but\n+also make the script results available for queries and aggregations.\n+\n+[[runtime-updating-scripts]]\n+.Updating runtime scripts\n+****\n+\n+Updating a script while a dependent query is running can return\n+inconsistent results. Each shard might have access to different versions of the\n+script, depending on when the mapping change takes effect.\n+\n+Existing queries or visualizations in {kib} that rely on runtime fields can\n+fail if you change the `runtime_type`. For example, a bar chart visualization\n+that uses a runtime field of `ip` will fail if the `runtime_type` is changed\n+to `boolean`.\n+\n+****\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` data type.\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `runtime` section of the mapping\n+definition.\n+<2> Each runtime has its own field type, just like any other field.\n+<3> The script defines the evaluation to calculate at search time.\n+\n+[[runtime-search-request]]\n+==== Defining runtime fields in a search request\n+You can specify a `runtime_mappings` section in a search request to create\n+runtime fields that exist only as part of the query. You must specify a script\n+as part of the `runtime_mappings` section, just as you would if adding a\n+runtime field to the mappings.\n+\n+In the following request, the values for the `day_of_week` field are calculated\n+dynamically, and only within the context of this search request.\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"day_of_week\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"day_of_week\": {\n+      \"terms\": {\n+        \"field\": \"day_of_week\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+[[runtime-overriding-fields]]\n+===== Overriding fields in the search request\n+You can use the `runtime_mappings` section of the `_search` request to override\n+field values inside objects by naming the runtime fields with dot notation. For\n+example, index the following documents into `my-index`.\n+\n+[source, console]\n+----\n+POST my-index/_bulk?refresh=true\n+{\"index\":{}}\n+{\"name\":{\"first\":\"Jose\",\"last\":\"Hickman\"}}\n+{\"index\":{}}\n+{\"name\":{\"first\":\"India\",\"last\":\"Avila\",\"suffix\":\"II\"}}\n+----\n+\n+In the `runtime_mappings` section of the `_search` request, you can define a\n+script that operates on the `name.first` field. The values you specify will\n+override fields in `_source` for the duration of the query without modifying\n+the field itself.\n+\n+The following request evaluates the `name.last` field and overrides the\n+`name.first` field in the search request based on the script valuation.\n+\n+[source,console]\n+----\n+POST my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"name.first\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"if (\\\"Hickman\\\".equals(doc[\\\"name.last.keyword\\\"].value)) {emit(\\\"Guile\\\");} else if (\\\"Avila\\\".equals(doc[\\\"name.last.keyword\\\"].value)) {emit(\\\"Anastasia\\\");}\"\n+      }\n+    }\n+  },\n+  \"query\": {\n+    \"match\": {\n+      \"name.first\": \"Anastasia\"\n+    }\n+  }\n+}\n+----\n+\n+[[runtime-params]]\n+==== Parameters for runtime fields\n+Runtime fields accept the following parameters:\n+\n+[[runtime-params-type]]\n+`type`::\n+The type of runtime computation to perform at query time. Currently, runtime\n+fields only support the `runtime` data type.\n+\n+[[runtime-params-runtime-type]]\n+`runtime_type`::\n+The <<mapping-types,field type>> for each scripted field. {es}\n+supports `boolean`, `date`, `double`, `ip`, `keyword`, and `long`.\n++\n+Runtime fields with a `runtime_type` of `date` can accept the\n+<<mapping-date-format,`format`>> parameter exactly as the `date` field type.\n+\n+[[runtime-params-script]]\n+`script`::\n+The <<modules-scripting-using,painless script>> that is evaluated at search\n+time to produce the value of the runtime field.\n+\n+[[runtime-retrieving-fields]]\n+==== Retrieving a runtime field\n+Use the <<search-fields,`fields`>> parameter on the `_search` API to retrieve\n+the values of runtime fields. Runtime fields won't display in `_source`, but\n+the `fields` API works for all fields, even those that were not sent as part of\n+the original `_source`.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+The following request uses the search API to retrieve the `day_of_week` field\n+that the <<runtime-mapping-fields,previous request>> defined as a runtime field\n+in the mapping. The value for the `day_of_week` field is calculated dynamically\n+at search time, and the following search request retrieves any documents where\n+the calculated value is equal to `Thursday`.\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"query\": {\n+    \"match\": {\n+      \"day_of_week\": \"Thursday\"\n+    }\n+  },\n+  \"fields\": [\n+    \"@timestamp\", \"day_of_week\"\n+  ],\n+  \"_source\": false\n+}\n+----\n+// TEST[continued]\n+\n+[[runtime-examples]]\n+==== Examples\n+Consider a large set of log data that you want to extract fields from.\n+Indexing the data is time consuming and uses a lot of disk space, and you just\n+want to explore the data structure without committing to a schema up front.\n+\n+You know that your log data contains specific fields that you want to extract.\n+By using runtime fields, you can define scripts to calculate values at search\n+time for these fields.\n+\n+You can start with a simple example by adding the `@timestamp` and `message`\n+fields to the `my-index` mapping. To remain flexible, use `wildcard` as the\n+field type for `message`.\n+\n+[source,console]\n+----\n+PUT /my-index/\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"@timestamp\": {\n+        \"format\": \"strict_date_optional_time||epoch_second\",\n+        \"type\": \"date\"\n+      },\n+      \"message\": {\n+        \"type\": \"wildcard\"\n+      }\n+    }\n+  }\n+}\n+----\n+\n+After mapping the fields you want to retrieve, index a few records from\n+your log data into {es}. The following request uses the <<docs-bulk,bulk API>>\n+to index raw log data into `my-index`. Instead of indexing all of your log\n+data, you can use a small sample to experiment with runtime fields.\n+\n+[source,console]\n+----\n+POST /my-index/_bulk?refresh\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-06-21T15:00:01-05:00\", \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-06-21T15:00:01-05:00\", \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:30:17-05:00\", \"message\" : \"40.135.0.0 - - [2020-04-30T14:30:17-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:30:53-05:00\", \"message\" : \"232.0.0.0 - - [2020-04-30T14:30:53-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:12-05:00\", \"message\" : \"26.1.0.0 - - [2020-04-30T14:31:12-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:19-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:19-05:00] \\\"GET /french/splash_inet.html HTTP/1.0\\\" 200 3781\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:27-05:00\", \"message\" : \"252.0.0.0 - - [2020-04-30T14:31:27-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:29-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:29-05:00] \\\"GET /images/hm_brdl.gif HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:29-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:29-05:00] \\\"GET /images/hm_arw.gif HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:32-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:32-05:00] \\\"GET /images/nav_bg_top.gif HTTP/1.0\\\" 200 929\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:43-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:43-05:00] \\\"GET /french/images/nav_venue_off.gif HTTP/1.0\\\" 304 0\"}\n+----\n+// TEST[continued]\n+\n+At this point, you can view how {es} stores your raw data.\n+\n+[source,console]\n+----\n+GET /my-index\n+----\n+// TEST[continued]\n+\n+The mapping contains two fields: `@timestamp` and `message`.\n+\n+[source,console-result]\n+----\n+{\n+  \"my-index\" : {\n+    \"aliases\" : { },\n+    \"mappings\" : {\n+      \"properties\" : {\n+        \"@timestamp\" : {\n+          \"type\" : \"date\",\n+          \"format\" : \"strict_date_optional_time||epoch_second\"\n+        },\n+        \"message\" : {\n+          \"type\" : \"wildcard\"\n+        }\n+      }\n+    },\n+    ...\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\\.\\.\\./\"aliases\": $body.my-index.aliases, \"settings\": $body.my-index.settings/]\n+\n+If you want to retrieve results that include `clientip`, you can add that field\n+as a runtime field in the mapping. The runtime script operates on the `clientip`\n+field at runtime to calculate values for that field.\n+\n+[source,console]\n+----\n+PUT /my-index/_mapping\n+{\n+  \"runtime\": {\n+    \"clientip\": {\n+      \"type\": \"ip\",\n+      \"script\" : {\n+      \"source\" : \"String m = doc[\\\"message\\\"].value; int end = m.indexOf(\\\" \\\"); emit(m.substring(0, end));\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+Using the `clientip` runtime field, you can define a simple query to run a\n+search for a specific IP address and return all related fields.\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"query\": {\n+    \"match\": {\n+      \"clientip\": \"211.11.9.0\"\n+    }\n+  },\n+  \"fields\" : [\"*\"]\n+}\n+----\n+// TEST[continued]\n+\n+The API returns the following result. Without building your data structure in\n+advance, you can search and explore your data in meaningful ways to experiment\n+and determine which fields to index.\n+\n+[source,console-result]\n+----\n+{\n+  ...\n+  \"hits\" : {\n+    \"total\" : {\n+      \"value\" : 2,\n+      \"relation\" : \"eq\"\n+    },\n+    \"max_score\" : 1.0,\n+    \"hits\" : [\n+      {\n+        \"_index\" : \"my-index\",\n+        \"_id\" : \"8Jh81nQBp2DRDXdiOxVt\",\n+        \"_score\" : 1.0,\n+        \"_source\" : {\n+          \"@timestamp\" : \"2020-06-21T15:00:01-05:00\",\n+          \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"\n+        },\n+        \"fields\" : {\n+          \"clientip\" : [\n+            \"211.11.9.0\"\n+          ],\n+          \"message\" : [\n+            \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"\n+          ],\n+          \"@timestamp\" : [\n+            \"2020-06-21T20:00:01.000Z\"\n+          ]\n+        }\n+      },\n+      {\n+        \"_index\" : \"my-index\",\n+        \"_id\" : \"8Zh81nQBp2DRDXdiOxVu\",\n+        \"_score\" : 1.0,\n+        \"_source\" : {\n+          \"@timestamp\" : \"2020-06-21T15:00:01-05:00\",\n+          \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"\n+        },\n+        \"fields\" : {\n+          \"clientip\" : [\n+            \"211.11.9.0\"\n+          ],\n+          \"message\" : [\n+            \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"\n+          ],\n+          \"@timestamp\" : [\n+            \"2020-06-21T20:00:01.000Z\"\n+          ]\n+        }\n+      }\n+    ]\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\\.\\.\\./\"took\" : $body.took,\"timed_out\" : $body.timed_out,\"_shards\" : $body._shards,/]\n+// TESTRESPONSE[s/\"_id\" : \"8Jh81nQBp2DRDXdiOxVt\"/\"_id\": $body.hits.hits.0._id/]\n+// TESTRESPONSE[s/\"_id\" : \"8Zh81nQBp2DRDXdiOxVu\"/\"_id\": $body.hits.hits.1._id/]\n+\n+If you add the `day_of_week` field to the mapping using the request in\n+<<runtime-mapping-fields,mapping a runtime field>>, you can re-run the previous\n+search request and also retrieve the day of the week based on the `@timestamp`\n+field.\n+\n+The value for this field is calculated dynamically at runtime without\n+reindexing the document or adding the `day_of_week` field. This flexibility\n+allows you to modify the mapping without changing any field values.\n+\n+////\n+[source,console]\n+----\n+PUT /my-index/\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"@timestamp\": {\n+        \"format\": \"strict_date_optional_time||epoch_second\",\n+        \"type\": \"date\"\n+      },\n+      \"message\": {\n+        \"type\": \"wildcard\"\n+      }\n+    }\n+  }\n+}", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM4MzY3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r535383672", "bodyText": "Good call \ud83d\udc4d I removed the hidden test cases, added in the examples, and included //TEST[continued].", "author": "lockewritesdocs", "createdAt": "2020-12-03T16:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4NTUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwNTE0OA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532805148", "bodyText": "It is possible to include Painless script but it is also possible to relate to fields in _source without a script - see #64981", "author": "giladgal", "createdAt": "2020-11-30T18:21:26Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With _runtime fields_ beta[], you can explicitly\n+define a field in the mapping and access it at search time without indexing\n+your data during ingest time.\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. Runtime fields are accessible\n+from the search API like any other field. The <<search-field-caps,field capabilities API>> returns runtime fields as both searchable and aggregatable.\n+\n+By dynamically evaluating runtime fields at search time, you can optimize disk\n+space by choosing which fields to index. If you later decide that a runtime\n+field is increasingly used for filtering or aggregation, you can add the field\n+to `_source` to gain faster search speed.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or override field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain performance at search time\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Runtime fields incur performance costs at search time, depending\n+on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say\n+you created an anomaly detection job that operates on the `@timestamp` field.\n+If the `@timestamp` field is a runtime field, the search cost would be extremely\n+high because the data isn't indexed and {es} must compute the value for each\n+document that matches the query.\n+\n+NOTE: Computing values for runtime fields in each document that might match a\n+query impacts search speed. Use the <<async-search,asynchronous search API>>\n+to run searches that include runtime fields.\n+\n+Runtime fields are useful when working with log data, especially when you're\n+unsure about the data structure. Your search speed decreases, but your index\n+size is much smaller and you can more quickly process logs without having to\n+index them.\n+\n+[[runtime-mapping-fields]]\n+==== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM2NzIxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r534367215", "bodyText": "I pinged with @romseygeek about this capability included this note in Mapping a runtime field:\n\nNOTE: You can define a runtime field in the mapping definition without a\nscript. Elasticsearch will look in _source for a field with the same name as the\nruntime field and use values from that field at query time.", "author": "lockewritesdocs", "createdAt": "2020-12-02T17:54:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwNTE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwNjI1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532806253", "bodyText": "Still under evaluation. We may take release it in GA.", "author": "giladgal", "createdAt": "2020-11-30T18:23:12Z", "path": "docs/reference/mapping/types.asciidoc", "diffHunk": "@@ -126,6 +126,31 @@ the <<analysis-standard-analyzer,`standard` analyzer>>, the\n This is the purpose of _multi-fields_. Most field types support multi-fields\n via the <<multi-fields>> parameter.\n \n+[discrete]\n+[[types-runtime]]\n+=== Runtime\n+{es} indexes most field types by default to promote faster search. However,\n+indexing all of your data can be slow and requires more disk space. If you're\n+experimenting with your data or are unsure which fields you need for search,\n+use _runtime fields_ beta[].", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyNTI3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532825272", "bodyText": "Understanding you want to add a field after the documents are already indexed\nWanting to immediately start working on a new datastream, without fully understanding the data in it, and only while working on it (using runtime fields based on _source), understand what's the schema that will be most helpful and gradually adding it\nShadowing an indexed field with a runtime field to fix a mistake after the documents are indexed\nDefining fields that are only relevant for a particular context, e.g. a certain visualization, as ephemeral fields that are defined as part of the query, without influencing everyone's schema", "author": "giladgal", "createdAt": "2020-11-30T18:55:20Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With _runtime fields_ beta[], you can explicitly\n+define a field in the mapping and access it at search time without indexing\n+your data during ingest time.\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. Runtime fields are accessible\n+from the search API like any other field. The <<search-field-caps,field capabilities API>> returns runtime fields as both searchable and aggregatable.\n+\n+By dynamically evaluating runtime fields at search time, you can optimize disk\n+space by choosing which fields to index. If you later decide that a runtime\n+field is increasingly used for filtering or aggregation, you can add the field\n+to `_source` to gain faster search speed.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or override field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI3MzMyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r534273321", "bodyText": "Thanks for these @giladgal! I integrated these points into the use cases.", "author": "lockewritesdocs", "createdAt": "2020-12-02T15:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyNTI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyODEwNw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r532828107", "bodyText": "Consider discussing the correct choice instead, e.g. if you choose to index fields that you know you will filter, search and aggregate on, like timestamp, then Elasticsearch will automatically use these indexed fields first in the query execution process. The result will be that the system will end up calculating the value of the runtime fields for a relatively small subset of the documents, so although runtime fields are slower than indexed fields, the query performance degradation will be limited. Runtime fields and indexed fields complement each other and work best in tandem.", "author": "giladgal", "createdAt": "2020-11-30T18:59:56Z", "path": "docs/reference/mapping/types/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,585 @@\n+[[runtime]]\n+=== Runtime\n+Typically, you must index fields to {es} before they can be retrieved,\n+aggregated, or searched. With _runtime fields_ beta[], you can explicitly\n+define a field in the mapping and access it at search time without indexing\n+your data during ingest time.\n+\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. Runtime fields are accessible\n+from the search API like any other field. The <<search-field-caps,field capabilities API>> returns runtime fields as both searchable and aggregatable.\n+\n+By dynamically evaluating runtime fields at search time, you can optimize disk\n+space by choosing which fields to index. If you later decide that a runtime\n+field is increasingly used for filtering or aggregation, you can add the field\n+to `_source` to gain faster search speed.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or override field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+Runtime fields help to alleviate several common issues when using {es}:\n+\n+* Reindexing your data between development iterations is slow and can make\n+experimenting on large datasets difficult\n+* Indexing data before searching makes running one-off searches costly and\n+resource intensive\n+* Indexing all of your data instead of just the fields you want to search\n+requires more disk space to gain performance at search time\n+* Reindexing data for time-based indices to ensure that existing indices\n+include any new fields in the index template is slow\n+* Determining how a field is evaluated in {kib} at index or search time is\n+difficult for scripted fields because they have different needs based on where\n+they are implemented\n+\n+Runtime fields incur performance costs at search time, depending", "originalCommit": "72cf35429ec99c248e7b3f3e914931b0dc936a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1NDAzNA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r533754034", "bodyText": "@giladgal, I created a new Compromises section, which hopefully encompasses the sentiments that you're discussing. Please let me know if I missed anything in translation.", "author": "lockewritesdocs", "createdAt": "2020-12-01T22:09:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyODEwNw=="}], "type": "inlineReview"}, {"oid": "35d7b6a7a41c1af5395a7b2492445342cd6324c3", "url": "https://github.com/elastic/elasticsearch/commit/35d7b6a7a41c1af5395a7b2492445342cd6324c3", "message": "Incorporating feedback from reviewers.", "committedDate": "2020-11-30T22:10:55Z", "type": "commit"}, {"oid": "4cd5b20d1714587ca95f9719b89a86eea4c461a0", "url": "https://github.com/elastic/elasticsearch/commit/4cd5b20d1714587ca95f9719b89a86eea4c461a0", "message": "Minor changes from reviews.", "committedDate": "2020-12-01T20:21:30Z", "type": "commit"}, {"oid": "a2be37b9a1f3fdc8543d039e76d8146d8d752192", "url": "https://github.com/elastic/elasticsearch/commit/a2be37b9a1f3fdc8543d039e76d8146d8d752192", "message": "Merge branch 'master' into docs__add-runtime-fields", "committedDate": "2020-12-01T20:24:39Z", "type": "commit"}, {"oid": "99b2720ff878a45b64e6b2fed0846ac7c3833bc5", "url": "https://github.com/elastic/elasticsearch/commit/99b2720ff878a45b64e6b2fed0846ac7c3833bc5", "message": "Adding alias for test case.", "committedDate": "2020-12-01T20:43:13Z", "type": "commit"}, {"oid": "43dd29d804c3a789fead62faae4bae5f337b173d", "url": "https://github.com/elastic/elasticsearch/commit/43dd29d804c3a789fead62faae4bae5f337b173d", "message": "Adding aliases to PUT example.", "committedDate": "2020-12-01T20:55:28Z", "type": "commit"}, {"oid": "994b1c22d7e388718cad56b47cfcc651115641e1", "url": "https://github.com/elastic/elasticsearch/commit/994b1c22d7e388718cad56b47cfcc651115641e1", "message": "Fixing test cases, for real this time.", "committedDate": "2020-12-01T21:52:33Z", "type": "commit"}, {"oid": "38194b28817ba9d72ce119d86401347bb6ba661b", "url": "https://github.com/elastic/elasticsearch/commit/38194b28817ba9d72ce119d86401347bb6ba661b", "message": "Updating use cases and introducing overlay throughout.", "committedDate": "2020-12-01T22:42:27Z", "type": "commit"}, {"oid": "70a82e85987f974df55ace134e42b6f48a4da8d6", "url": "https://github.com/elastic/elasticsearch/commit/70a82e85987f974df55ace134e42b6f48a4da8d6", "message": "Edits, adding 'shadowing', and explaining shadowing better.", "committedDate": "2020-12-02T23:06:35Z", "type": "commit"}, {"oid": "c27ce4c177f14774bcdc4d616ff530d12c977cfb", "url": "https://github.com/elastic/elasticsearch/commit/c27ce4c177f14774bcdc4d616ff530d12c977cfb", "message": "Streamlining tests and other changes.", "committedDate": "2020-12-03T18:00:43Z", "type": "commit"}, {"oid": "d9a927167824d778de20c5db84f6701406ec5893", "url": "https://github.com/elastic/elasticsearch/commit/d9a927167824d778de20c5db84f6701406ec5893", "message": "Fix formatting in example for test.", "committedDate": "2020-12-03T19:45:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU3NzU4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537577585", "bodyText": "will this make user think that we do something magic with existing documents?", "author": "javanna", "createdAt": "2020-12-07T15:04:37Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. If you later decide that a runtime field is increasingly used\n+for filtering or aggregation, you can add the field to `_source` to gain faster\n+search speed.", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3OTMwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r538779305", "bodyText": "I'm rewriting a good portion of this section and will remove that sentence.", "author": "lockewritesdocs", "createdAt": "2020-12-08T20:21:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU3NzU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU3ODkyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537578925", "bodyText": "shadow existing fields? Shadowing is not specific to fields in _source, and actually from a search request you could even shadow an existing runtime field defined in the index mappings.", "author": "javanna", "createdAt": "2020-12-07T15:06:22Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. If you later decide that a runtime field is increasingly used\n+for filtering or aggregation, you can add the field to `_source` to gain faster\n+search speed.\n+\n+Instead of reindexing your data to add fields, add runtime fields to the\n+mapping definition. You can access runtime fields from the search API like any\n+other field, and {es} sees runtime fields no differently.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or shadow field values in `_source` for the", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ2OTIwNg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r539469206", "bodyText": "I updated the shadowing section, which discusses how to use shadowing in different capacities.", "author": "lockewritesdocs", "createdAt": "2020-12-09T16:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU3ODkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU4MDI5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537580293", "bodyText": "why is runtime within double quotes? on purpose?", "author": "javanna", "createdAt": "2020-12-07T15:08:01Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. If you later decide that a runtime field is increasingly used\n+for filtering or aggregation, you can add the field to `_source` to gain faster\n+search speed.\n+\n+Instead of reindexing your data to add fields, add runtime fields to the\n+mapping definition. You can access runtime fields from the search API like any\n+other field, and {es} sees runtime fields no differently.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or shadow field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+[discrete]\n+[[runtime-mapping-fields]]\n+=== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU4MjI3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537582276", "bodyText": "(the mapped field plus its values) => which field do you mean? I guess you mean doc_values for all fields that have them?", "author": "javanna", "createdAt": "2020-12-07T15:10:35Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. If you later decide that a runtime field is increasingly used\n+for filtering or aggregation, you can add the field to `_source` to gain faster\n+search speed.\n+\n+Instead of reindexing your data to add fields, add runtime fields to the\n+mapping definition. You can access runtime fields from the search API like any\n+other field, and {es} sees runtime fields no differently.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or shadow field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+[discrete]\n+[[runtime-mapping-fields]]\n+=== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+original `_source` and `doc_values` (the mapped field plus its values). At", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5MDYzNw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r538790637", "bodyText": "I think this makes more sense as:\n\n...which has access to the entire context of a document, including the original _source and any mapped fields plus their values.", "author": "lockewritesdocs", "createdAt": "2020-12-08T20:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU4MjI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU4MzExNg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537583116", "bodyText": "not for queries and aggregations, also sorting. Should rather say anywhere in a search request?", "author": "javanna", "createdAt": "2020-12-07T15:11:40Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. If you later decide that a runtime field is increasingly used\n+for filtering or aggregation, you can add the field to `_source` to gain faster\n+search speed.\n+\n+Instead of reindexing your data to add fields, add runtime fields to the\n+mapping definition. You can access runtime fields from the search API like any\n+other field, and {es} sees runtime fields no differently.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or shadow field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+[discrete]\n+[[runtime-mapping-fields]]\n+=== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+original `_source` and `doc_values` (the mapped field plus its values). At\n+search time, the script runs and generates values for each scripted field.\n+\n+NOTE: You can define a runtime field in the mapping definition without a\n+script. {es} will look in `_source` for a field with the same name as the\n+runtime field and use values from that field at query time.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request, but also make the script results available for\n+queries and aggregations.", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMTk2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537901967", "bodyText": "I'll change to, \"...make the script results available anywhere in a search request.\"", "author": "lockewritesdocs", "createdAt": "2020-12-07T23:08:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU4MzExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU4MzgzNg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537583836", "bodyText": "Each runtime field?", "author": "javanna", "createdAt": "2020-12-07T15:12:32Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. If you later decide that a runtime field is increasingly used\n+for filtering or aggregation, you can add the field to `_source` to gain faster\n+search speed.\n+\n+Instead of reindexing your data to add fields, add runtime fields to the\n+mapping definition. You can access runtime fields from the search API like any\n+other field, and {es} sees runtime fields no differently.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or shadow field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+[discrete]\n+[[runtime-mapping-fields]]\n+=== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+original `_source` and `doc_values` (the mapped field plus its values). At\n+search time, the script runs and generates values for each scripted field.\n+\n+NOTE: You can define a runtime field in the mapping definition without a\n+script. {es} will look in `_source` for a field with the same name as the\n+runtime field and use values from that field at query time.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request, but also make the script results available for\n+queries and aggregations.\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` type:\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `\"runtime\"` section of the mapping\n+definition.\n+<2> Each runtime has its own field type, just like any other field.", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg4NTQ4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537885485", "bodyText": "Yes \ud83d\ude04", "author": "lockewritesdocs", "createdAt": "2020-12-07T22:35:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU4MzgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU4NDEwMg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537584102", "bodyText": "geo_point is missing", "author": "javanna", "createdAt": "2020-12-07T15:12:52Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. If you later decide that a runtime field is increasingly used\n+for filtering or aggregation, you can add the field to `_source` to gain faster\n+search speed.\n+\n+Instead of reindexing your data to add fields, add runtime fields to the\n+mapping definition. You can access runtime fields from the search API like any\n+other field, and {es} sees runtime fields no differently.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or shadow field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+[discrete]\n+[[runtime-mapping-fields]]\n+=== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+original `_source` and `doc_values` (the mapped field plus its values). At\n+search time, the script runs and generates values for each scripted field.\n+\n+NOTE: You can define a runtime field in the mapping definition without a\n+script. {es} will look in `_source` for a field with the same name as the\n+runtime field and use values from that field at query time.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request, but also make the script results available for\n+queries and aggregations.\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` type:\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `\"runtime\"` section of the mapping\n+definition.\n+<2> Each runtime has its own field type, just like any other field.\n+<3> The script defines the evaluation to calculate at search time.\n+\n+The `\"runtime\"` section supports `boolean`, `date`, `double`, `ip`, `keyword`,\n+and `long` data types. Runtime fields with a `type` of `date` can accept the", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5MDU0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537890549", "bodyText": "Good catch -- I'll add it.", "author": "lockewritesdocs", "createdAt": "2020-12-07T22:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU4NDEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU4NjYxMA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537586610", "bodyText": "this makes it sound like a limitation, while it is not. I also don't understand the second part: you don't need to shadow, nor define the field in the search request if it is part of an object. I think that you are rather trying to explain that when you want to map a runtime field that is part of some object structure e.g. object.field , you don't need to recreate the object structure in the runtime field, but rather just define the leaf runtime field as object.field. Correct?", "author": "javanna", "createdAt": "2020-12-07T15:16:00Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. If you later decide that a runtime field is increasingly used\n+for filtering or aggregation, you can add the field to `_source` to gain faster\n+search speed.\n+\n+Instead of reindexing your data to add fields, add runtime fields to the\n+mapping definition. You can access runtime fields from the search API like any\n+other field, and {es} sees runtime fields no differently.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or shadow field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+[discrete]\n+[[runtime-mapping-fields]]\n+=== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+original `_source` and `doc_values` (the mapped field plus its values). At\n+search time, the script runs and generates values for each scripted field.\n+\n+NOTE: You can define a runtime field in the mapping definition without a\n+script. {es} will look in `_source` for a field with the same name as the\n+runtime field and use values from that field at query time.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request, but also make the script results available for\n+queries and aggregations.\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` type:\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `\"runtime\"` section of the mapping\n+definition.\n+<2> Each runtime has its own field type, just like any other field.\n+<3> The script defines the evaluation to calculate at search time.\n+\n+The `\"runtime\"` section supports `boolean`, `date`, `double`, `ip`, `keyword`,\n+and `long` data types. Runtime fields with a `type` of `date` can accept the\n+<<mapping-date-format,`format`>> parameter exactly as the `date` field type.\n+\n+IMPORTANT: Objects are not supported in the `\"runtime\"` section under the", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM5MDc4NA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r539390784", "bodyText": "I added a new section in Mapping runtime fields to include using dot notation when mapping runtime fields within objects. I included a heading to separate this information within the broader page for mapping a runtime field, and that heading will be included in the next commit:", "author": "lockewritesdocs", "createdAt": "2020-12-09T15:14:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU4NjYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU5Mjk2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537592962", "bodyText": "why is this section specifically on shadowing fields in the search request? Shadowing can also be done when defining runtime fields in the mappings, so I would expect shadowing to be documented as a feature of runtime fields in general", "author": "javanna", "createdAt": "2020-12-07T15:24:03Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. If you later decide that a runtime field is increasingly used\n+for filtering or aggregation, you can add the field to `_source` to gain faster\n+search speed.\n+\n+Instead of reindexing your data to add fields, add runtime fields to the\n+mapping definition. You can access runtime fields from the search API like any\n+other field, and {es} sees runtime fields no differently.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or shadow field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+[discrete]\n+[[runtime-mapping-fields]]\n+=== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+original `_source` and `doc_values` (the mapped field plus its values). At\n+search time, the script runs and generates values for each scripted field.\n+\n+NOTE: You can define a runtime field in the mapping definition without a\n+script. {es} will look in `_source` for a field with the same name as the\n+runtime field and use values from that field at query time.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request, but also make the script results available for\n+queries and aggregations.\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` type:\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `\"runtime\"` section of the mapping\n+definition.\n+<2> Each runtime has its own field type, just like any other field.\n+<3> The script defines the evaluation to calculate at search time.\n+\n+The `\"runtime\"` section supports `boolean`, `date`, `double`, `ip`, `keyword`,\n+and `long` data types. Runtime fields with a `type` of `date` can accept the\n+<<mapping-date-format,`format`>> parameter exactly as the `date` field type.\n+\n+IMPORTANT: Objects are not supported in the `\"runtime\"` section under the\n+mapping definition. If you want to map a runtime field under an object, you\n+can\n+<<runtime-shadowing-fields,shadow the field value in the search request>>.\n+\n+[[runtime-updating-scripts]]\n+.Updating runtime scripts\n+****\n+\n+Updating a script while a dependent query is running can return\n+inconsistent results. Each shard might have access to different versions of the\n+script, depending on when the mapping change takes effect.\n+\n+Existing queries or visualizations in {kib} that rely on runtime fields can\n+fail if you change the field type. For example, a bar chart visualization\n+that uses a runtime field of type `ip` will fail if the type is changed\n+to `boolean`.\n+\n+****\n+\n+[discrete]\n+[[runtime-search-request]]\n+=== Defining runtime fields in a search request\n+You can specify a `runtime_mappings` section in a search request to create\n+runtime fields that exist only as part of the query. You specify a script\n+as part of the `runtime_mappings` section, just as you would if adding a\n+runtime field to the mappings.\n+\n+In the following request, the values for the `day_of_week` field are calculated\n+dynamically, and only within the context of this search request:\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"day_of_week\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"day_of_week\": {\n+      \"terms\": {\n+        \"field\": \"day_of_week\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+[discrete]\n+[[runtime-shadowing-fields]]\n+==== Shadowing fields in the search request", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3NzE3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r539377177", "bodyText": "I've expanded the section on shadowing fields to include both scenarios \ud83d\udc4d", "author": "lockewritesdocs", "createdAt": "2020-12-09T14:58:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU5Mjk2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU5NDA4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537594087", "bodyText": "similar comment as above. Does it sound like a limitation? Defining fields that belong to an object, using the dot notation, does not necessarily mean that you are shadowing an existing field. It's two separate things.", "author": "javanna", "createdAt": "2020-12-07T15:25:33Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. If you later decide that a runtime field is increasingly used\n+for filtering or aggregation, you can add the field to `_source` to gain faster\n+search speed.\n+\n+Instead of reindexing your data to add fields, add runtime fields to the\n+mapping definition. You can access runtime fields from the search API like any\n+other field, and {es} sees runtime fields no differently.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or shadow field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+[discrete]\n+[[runtime-mapping-fields]]\n+=== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+original `_source` and `doc_values` (the mapped field plus its values). At\n+search time, the script runs and generates values for each scripted field.\n+\n+NOTE: You can define a runtime field in the mapping definition without a\n+script. {es} will look in `_source` for a field with the same name as the\n+runtime field and use values from that field at query time.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request, but also make the script results available for\n+queries and aggregations.\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` type:\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `\"runtime\"` section of the mapping\n+definition.\n+<2> Each runtime has its own field type, just like any other field.\n+<3> The script defines the evaluation to calculate at search time.\n+\n+The `\"runtime\"` section supports `boolean`, `date`, `double`, `ip`, `keyword`,\n+and `long` data types. Runtime fields with a `type` of `date` can accept the\n+<<mapping-date-format,`format`>> parameter exactly as the `date` field type.\n+\n+IMPORTANT: Objects are not supported in the `\"runtime\"` section under the\n+mapping definition. If you want to map a runtime field under an object, you\n+can\n+<<runtime-shadowing-fields,shadow the field value in the search request>>.\n+\n+[[runtime-updating-scripts]]\n+.Updating runtime scripts\n+****\n+\n+Updating a script while a dependent query is running can return\n+inconsistent results. Each shard might have access to different versions of the\n+script, depending on when the mapping change takes effect.\n+\n+Existing queries or visualizations in {kib} that rely on runtime fields can\n+fail if you change the field type. For example, a bar chart visualization\n+that uses a runtime field of type `ip` will fail if the type is changed\n+to `boolean`.\n+\n+****\n+\n+[discrete]\n+[[runtime-search-request]]\n+=== Defining runtime fields in a search request\n+You can specify a `runtime_mappings` section in a search request to create\n+runtime fields that exist only as part of the query. You specify a script\n+as part of the `runtime_mappings` section, just as you would if adding a\n+runtime field to the mappings.\n+\n+In the following request, the values for the `day_of_week` field are calculated\n+dynamically, and only within the context of this search request:\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"day_of_week\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"day_of_week\": {\n+      \"terms\": {\n+        \"field\": \"day_of_week\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+[discrete]\n+[[runtime-shadowing-fields]]\n+==== Shadowing fields in the search request\n+If you create a runtime field with the same name as a field that\n+already exists in the mapping, the runtime field shadows the mapped field. At\n+search time, {es} calculates the value of the runtime field and returns it as\n+part of the query. Because the runtime field shadows the mapped field, you can\n+modify the value returned in search without modifying the mapped field.\n+\n+Objects are not supported in the `\"runtime\"` section under the\n+mapping definition. However, you can use the `runtime_mappings` section of the\n+`_search` request to shadow field values inside objects. For", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2MzE5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r538863195", "bodyText": "I removed the mention about objects not being supported after our discussion.", "author": "lockewritesdocs", "createdAt": "2020-12-08T22:42:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU5NDA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU5NTE4NA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537595184", "bodyText": "I find this explanation too high-level: the field does not shadow field values in _source. It shadows most likely the indexed fields, depending on how they are mapped. It may be useful here to show the mappings to clarify what happens", "author": "javanna", "createdAt": "2020-12-07T15:26:52Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. If you later decide that a runtime field is increasingly used\n+for filtering or aggregation, you can add the field to `_source` to gain faster\n+search speed.\n+\n+Instead of reindexing your data to add fields, add runtime fields to the\n+mapping definition. You can access runtime fields from the search API like any\n+other field, and {es} sees runtime fields no differently.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or shadow field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+[discrete]\n+[[runtime-mapping-fields]]\n+=== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+original `_source` and `doc_values` (the mapped field plus its values). At\n+search time, the script runs and generates values for each scripted field.\n+\n+NOTE: You can define a runtime field in the mapping definition without a\n+script. {es} will look in `_source` for a field with the same name as the\n+runtime field and use values from that field at query time.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request, but also make the script results available for\n+queries and aggregations.\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` type:\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `\"runtime\"` section of the mapping\n+definition.\n+<2> Each runtime has its own field type, just like any other field.\n+<3> The script defines the evaluation to calculate at search time.\n+\n+The `\"runtime\"` section supports `boolean`, `date`, `double`, `ip`, `keyword`,\n+and `long` data types. Runtime fields with a `type` of `date` can accept the\n+<<mapping-date-format,`format`>> parameter exactly as the `date` field type.\n+\n+IMPORTANT: Objects are not supported in the `\"runtime\"` section under the\n+mapping definition. If you want to map a runtime field under an object, you\n+can\n+<<runtime-shadowing-fields,shadow the field value in the search request>>.\n+\n+[[runtime-updating-scripts]]\n+.Updating runtime scripts\n+****\n+\n+Updating a script while a dependent query is running can return\n+inconsistent results. Each shard might have access to different versions of the\n+script, depending on when the mapping change takes effect.\n+\n+Existing queries or visualizations in {kib} that rely on runtime fields can\n+fail if you change the field type. For example, a bar chart visualization\n+that uses a runtime field of type `ip` will fail if the type is changed\n+to `boolean`.\n+\n+****\n+\n+[discrete]\n+[[runtime-search-request]]\n+=== Defining runtime fields in a search request\n+You can specify a `runtime_mappings` section in a search request to create\n+runtime fields that exist only as part of the query. You specify a script\n+as part of the `runtime_mappings` section, just as you would if adding a\n+runtime field to the mappings.\n+\n+In the following request, the values for the `day_of_week` field are calculated\n+dynamically, and only within the context of this search request:\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"day_of_week\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"day_of_week\": {\n+      \"terms\": {\n+        \"field\": \"day_of_week\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+[discrete]\n+[[runtime-shadowing-fields]]\n+==== Shadowing fields in the search request\n+If you create a runtime field with the same name as a field that\n+already exists in the mapping, the runtime field shadows the mapped field. At\n+search time, {es} calculates the value of the runtime field and returns it as\n+part of the query. Because the runtime field shadows the mapped field, you can\n+modify the value returned in search without modifying the mapped field.\n+\n+Objects are not supported in the `\"runtime\"` section under the\n+mapping definition. However, you can use the `runtime_mappings` section of the\n+`_search` request to shadow field values inside objects. For\n+example, index the following documents into `my-index`:\n+\n+[source, console]\n+----\n+POST my-index/_bulk?refresh=true\n+{\"index\":{}}\n+{\"name\":{\"first\":\"Jose\",\"last\":\"Hickman\"}}\n+{\"index\":{}}\n+{\"name\":{\"first\":\"India\",\"last\":\"Avila\",\"suffix\":\"II\"}}\n+----\n+\n+In the `runtime_mappings` section of the `_search` request, you can define a\n+script that operates on the `name.first` field. The values you specify will\n+shadow field values in `_source` for the duration of the query without", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU5NjcxMA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537596710", "bodyText": "it does not evaluate the name.last field, but rather defines a runtime field that loads its values from its script and has logic around them.", "author": "javanna", "createdAt": "2020-12-07T15:28:43Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. If you later decide that a runtime field is increasingly used\n+for filtering or aggregation, you can add the field to `_source` to gain faster\n+search speed.\n+\n+Instead of reindexing your data to add fields, add runtime fields to the\n+mapping definition. You can access runtime fields from the search API like any\n+other field, and {es} sees runtime fields no differently.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or shadow field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+[discrete]\n+[[runtime-mapping-fields]]\n+=== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+original `_source` and `doc_values` (the mapped field plus its values). At\n+search time, the script runs and generates values for each scripted field.\n+\n+NOTE: You can define a runtime field in the mapping definition without a\n+script. {es} will look in `_source` for a field with the same name as the\n+runtime field and use values from that field at query time.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request, but also make the script results available for\n+queries and aggregations.\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` type:\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `\"runtime\"` section of the mapping\n+definition.\n+<2> Each runtime has its own field type, just like any other field.\n+<3> The script defines the evaluation to calculate at search time.\n+\n+The `\"runtime\"` section supports `boolean`, `date`, `double`, `ip`, `keyword`,\n+and `long` data types. Runtime fields with a `type` of `date` can accept the\n+<<mapping-date-format,`format`>> parameter exactly as the `date` field type.\n+\n+IMPORTANT: Objects are not supported in the `\"runtime\"` section under the\n+mapping definition. If you want to map a runtime field under an object, you\n+can\n+<<runtime-shadowing-fields,shadow the field value in the search request>>.\n+\n+[[runtime-updating-scripts]]\n+.Updating runtime scripts\n+****\n+\n+Updating a script while a dependent query is running can return\n+inconsistent results. Each shard might have access to different versions of the\n+script, depending on when the mapping change takes effect.\n+\n+Existing queries or visualizations in {kib} that rely on runtime fields can\n+fail if you change the field type. For example, a bar chart visualization\n+that uses a runtime field of type `ip` will fail if the type is changed\n+to `boolean`.\n+\n+****\n+\n+[discrete]\n+[[runtime-search-request]]\n+=== Defining runtime fields in a search request\n+You can specify a `runtime_mappings` section in a search request to create\n+runtime fields that exist only as part of the query. You specify a script\n+as part of the `runtime_mappings` section, just as you would if adding a\n+runtime field to the mappings.\n+\n+In the following request, the values for the `day_of_week` field are calculated\n+dynamically, and only within the context of this search request:\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"day_of_week\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"day_of_week\": {\n+      \"terms\": {\n+        \"field\": \"day_of_week\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+[discrete]\n+[[runtime-shadowing-fields]]\n+==== Shadowing fields in the search request\n+If you create a runtime field with the same name as a field that\n+already exists in the mapping, the runtime field shadows the mapped field. At\n+search time, {es} calculates the value of the runtime field and returns it as\n+part of the query. Because the runtime field shadows the mapped field, you can\n+modify the value returned in search without modifying the mapped field.\n+\n+Objects are not supported in the `\"runtime\"` section under the\n+mapping definition. However, you can use the `runtime_mappings` section of the\n+`_search` request to shadow field values inside objects. For\n+example, index the following documents into `my-index`:\n+\n+[source, console]\n+----\n+POST my-index/_bulk?refresh=true\n+{\"index\":{}}\n+{\"name\":{\"first\":\"Jose\",\"last\":\"Hickman\"}}\n+{\"index\":{}}\n+{\"name\":{\"first\":\"India\",\"last\":\"Avila\",\"suffix\":\"II\"}}\n+----\n+\n+In the `runtime_mappings` section of the `_search` request, you can define a\n+script that operates on the `name.first` field. The values you specify will\n+shadow field values in `_source` for the duration of the query without\n+modifying the field itself.\n+\n+The following request evaluates the `name.last` field and shadows the value for", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU5NzgwNw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537597807", "bodyText": "shadows the value for the name.first field in the search request: do you mean that the field defined in the search request shadows the field originally indexed as part of the execution of this search request?", "author": "javanna", "createdAt": "2020-12-07T15:29:58Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. If you later decide that a runtime field is increasingly used\n+for filtering or aggregation, you can add the field to `_source` to gain faster\n+search speed.\n+\n+Instead of reindexing your data to add fields, add runtime fields to the\n+mapping definition. You can access runtime fields from the search API like any\n+other field, and {es} sees runtime fields no differently.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or shadow field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+[discrete]\n+[[runtime-mapping-fields]]\n+=== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+original `_source` and `doc_values` (the mapped field plus its values). At\n+search time, the script runs and generates values for each scripted field.\n+\n+NOTE: You can define a runtime field in the mapping definition without a\n+script. {es} will look in `_source` for a field with the same name as the\n+runtime field and use values from that field at query time.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request, but also make the script results available for\n+queries and aggregations.\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` type:\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `\"runtime\"` section of the mapping\n+definition.\n+<2> Each runtime has its own field type, just like any other field.\n+<3> The script defines the evaluation to calculate at search time.\n+\n+The `\"runtime\"` section supports `boolean`, `date`, `double`, `ip`, `keyword`,\n+and `long` data types. Runtime fields with a `type` of `date` can accept the\n+<<mapping-date-format,`format`>> parameter exactly as the `date` field type.\n+\n+IMPORTANT: Objects are not supported in the `\"runtime\"` section under the\n+mapping definition. If you want to map a runtime field under an object, you\n+can\n+<<runtime-shadowing-fields,shadow the field value in the search request>>.\n+\n+[[runtime-updating-scripts]]\n+.Updating runtime scripts\n+****\n+\n+Updating a script while a dependent query is running can return\n+inconsistent results. Each shard might have access to different versions of the\n+script, depending on when the mapping change takes effect.\n+\n+Existing queries or visualizations in {kib} that rely on runtime fields can\n+fail if you change the field type. For example, a bar chart visualization\n+that uses a runtime field of type `ip` will fail if the type is changed\n+to `boolean`.\n+\n+****\n+\n+[discrete]\n+[[runtime-search-request]]\n+=== Defining runtime fields in a search request\n+You can specify a `runtime_mappings` section in a search request to create\n+runtime fields that exist only as part of the query. You specify a script\n+as part of the `runtime_mappings` section, just as you would if adding a\n+runtime field to the mappings.\n+\n+In the following request, the values for the `day_of_week` field are calculated\n+dynamically, and only within the context of this search request:\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"day_of_week\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"day_of_week\": {\n+      \"terms\": {\n+        \"field\": \"day_of_week\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+[discrete]\n+[[runtime-shadowing-fields]]\n+==== Shadowing fields in the search request\n+If you create a runtime field with the same name as a field that\n+already exists in the mapping, the runtime field shadows the mapped field. At\n+search time, {es} calculates the value of the runtime field and returns it as\n+part of the query. Because the runtime field shadows the mapped field, you can\n+modify the value returned in search without modifying the mapped field.\n+\n+Objects are not supported in the `\"runtime\"` section under the\n+mapping definition. However, you can use the `runtime_mappings` section of the\n+`_search` request to shadow field values inside objects. For\n+example, index the following documents into `my-index`:\n+\n+[source, console]\n+----\n+POST my-index/_bulk?refresh=true\n+{\"index\":{}}\n+{\"name\":{\"first\":\"Jose\",\"last\":\"Hickman\"}}\n+{\"index\":{}}\n+{\"name\":{\"first\":\"India\",\"last\":\"Avila\",\"suffix\":\"II\"}}\n+----\n+\n+In the `runtime_mappings` section of the `_search` request, you can define a\n+script that operates on the `name.first` field. The values you specify will\n+shadow field values in `_source` for the duration of the query without\n+modifying the field itself.\n+\n+The following request evaluates the `name.last` field and shadows the value for\n+the `name.first` field in the search request based on the script valuation:\n+", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYwMTg0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537601847", "bodyText": "should examples do more than just retrieving values for the field, to showcase the flexibility of runtime fields? We could for instance aggregate, filter docs etc.", "author": "javanna", "createdAt": "2020-12-07T15:35:13Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. If you later decide that a runtime field is increasingly used\n+for filtering or aggregation, you can add the field to `_source` to gain faster\n+search speed.\n+\n+Instead of reindexing your data to add fields, add runtime fields to the\n+mapping definition. You can access runtime fields from the search API like any\n+other field, and {es} sees runtime fields no differently.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or shadow field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+[discrete]\n+[[runtime-mapping-fields]]\n+=== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+original `_source` and `doc_values` (the mapped field plus its values). At\n+search time, the script runs and generates values for each scripted field.\n+\n+NOTE: You can define a runtime field in the mapping definition without a\n+script. {es} will look in `_source` for a field with the same name as the\n+runtime field and use values from that field at query time.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request, but also make the script results available for\n+queries and aggregations.\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` type:\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `\"runtime\"` section of the mapping\n+definition.\n+<2> Each runtime has its own field type, just like any other field.\n+<3> The script defines the evaluation to calculate at search time.\n+\n+The `\"runtime\"` section supports `boolean`, `date`, `double`, `ip`, `keyword`,\n+and `long` data types. Runtime fields with a `type` of `date` can accept the\n+<<mapping-date-format,`format`>> parameter exactly as the `date` field type.\n+\n+IMPORTANT: Objects are not supported in the `\"runtime\"` section under the\n+mapping definition. If you want to map a runtime field under an object, you\n+can\n+<<runtime-shadowing-fields,shadow the field value in the search request>>.\n+\n+[[runtime-updating-scripts]]\n+.Updating runtime scripts\n+****\n+\n+Updating a script while a dependent query is running can return\n+inconsistent results. Each shard might have access to different versions of the\n+script, depending on when the mapping change takes effect.\n+\n+Existing queries or visualizations in {kib} that rely on runtime fields can\n+fail if you change the field type. For example, a bar chart visualization\n+that uses a runtime field of type `ip` will fail if the type is changed\n+to `boolean`.\n+\n+****\n+\n+[discrete]\n+[[runtime-search-request]]\n+=== Defining runtime fields in a search request\n+You can specify a `runtime_mappings` section in a search request to create\n+runtime fields that exist only as part of the query. You specify a script\n+as part of the `runtime_mappings` section, just as you would if adding a\n+runtime field to the mappings.\n+\n+In the following request, the values for the `day_of_week` field are calculated\n+dynamically, and only within the context of this search request:\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"day_of_week\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"day_of_week\": {\n+      \"terms\": {\n+        \"field\": \"day_of_week\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+[discrete]\n+[[runtime-shadowing-fields]]\n+==== Shadowing fields in the search request\n+If you create a runtime field with the same name as a field that\n+already exists in the mapping, the runtime field shadows the mapped field. At\n+search time, {es} calculates the value of the runtime field and returns it as\n+part of the query. Because the runtime field shadows the mapped field, you can\n+modify the value returned in search without modifying the mapped field.\n+\n+Objects are not supported in the `\"runtime\"` section under the\n+mapping definition. However, you can use the `runtime_mappings` section of the\n+`_search` request to shadow field values inside objects. For\n+example, index the following documents into `my-index`:\n+\n+[source, console]\n+----\n+POST my-index/_bulk?refresh=true\n+{\"index\":{}}\n+{\"name\":{\"first\":\"Jose\",\"last\":\"Hickman\"}}\n+{\"index\":{}}\n+{\"name\":{\"first\":\"India\",\"last\":\"Avila\",\"suffix\":\"II\"}}\n+----\n+\n+In the `runtime_mappings` section of the `_search` request, you can define a\n+script that operates on the `name.first` field. The values you specify will\n+shadow field values in `_source` for the duration of the query without\n+modifying the field itself.\n+\n+The following request evaluates the `name.last` field and shadows the value for\n+the `name.first` field in the search request based on the script valuation:\n+\n+[source,console]\n+----\n+POST my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"name.first\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"if (\\\"Hickman\\\".equals(doc[\\\"name.last.keyword\\\"].value)) {emit(\\\"Guile\\\");} else if (\\\"Avila\\\".equals(doc[\\\"name.last.keyword\\\"].value)) {emit(\\\"Anastasia\\\");}\"\n+      }\n+    }\n+  },\n+  \"query\": {\n+    \"match\": {\n+      \"name.first\": \"Anastasia\"\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+[discrete]\n+[[runtime-retrieving-fields]]\n+==== Retrieving a runtime field\n+Use the <<search-fields,`fields`>> parameter on the `_search` API to retrieve\n+the values of runtime fields. Runtime fields won't display in `_source`, but\n+the `fields` API works for all fields, even those that were not sent as part of\n+the original `_source`.\n+\n+The following request uses the search API to retrieve the `day_of_week` field\n+that <<runtime-mapping-fields,this previous request>> defined as a runtime field\n+in the mapping. The value for the `day_of_week` field is calculated dynamically\n+at search time based on the evaluation of the defined script.\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"fields\": [\n+    \"@timestamp\",\n+    \"day_of_week\"\n+  ],\n+  \"_source\": false\n+}\n+----\n+// TEST[continued]\n+\n+[discrete]\n+[[runtime-examples]]\n+=== Examples\n+Consider a large set of log data that you want to extract fields from.\n+Indexing the data is time consuming and uses a lot of disk space, and you just\n+want to explore the data structure without committing to a schema up front.\n+\n+You know that your log data contains specific fields that you want to extract.\n+By using runtime fields, you can define scripts to calculate values at search\n+time for these fields.\n+\n+You can start with a simple example by adding the `@timestamp` and `message`\n+fields to the `my-index` mapping. To remain flexible, use `wildcard` as the\n+field type for `message`:\n+\n+[source,console]\n+----\n+PUT /my-index/\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"@timestamp\": {\n+        \"format\": \"strict_date_optional_time||epoch_second\",\n+        \"type\": \"date\"\n+      },\n+      \"message\": {\n+        \"type\": \"wildcard\"\n+      }\n+    }\n+  }\n+}\n+----\n+\n+After mapping the fields you want to retrieve, index a few records from\n+your log data into {es}. The following request uses the <<docs-bulk,bulk API>>\n+to index raw log data into `my-index`. Instead of indexing all of your log\n+data, you can use a small sample to experiment with runtime fields.\n+\n+[source,console]\n+----\n+POST /my-index/_bulk?refresh\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-06-21T15:00:01-05:00\", \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-06-21T15:00:01-05:00\", \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:30:17-05:00\", \"message\" : \"40.135.0.0 - - [2020-04-30T14:30:17-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:30:53-05:00\", \"message\" : \"232.0.0.0 - - [2020-04-30T14:30:53-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:12-05:00\", \"message\" : \"26.1.0.0 - - [2020-04-30T14:31:12-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:19-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:19-05:00] \\\"GET /french/splash_inet.html HTTP/1.0\\\" 200 3781\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:27-05:00\", \"message\" : \"252.0.0.0 - - [2020-04-30T14:31:27-05:00] \\\"GET /images/hm_bg.jpg HTTP/1.0\\\" 200 24736\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:29-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:29-05:00] \\\"GET /images/hm_brdl.gif HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:29-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:29-05:00] \\\"GET /images/hm_arw.gif HTTP/1.0\\\" 304 0\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:32-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:32-05:00] \\\"GET /images/nav_bg_top.gif HTTP/1.0\\\" 200 929\"}\n+{ \"index\": {}}\n+{ \"@timestamp\": \"2020-04-30T14:31:43-05:00\", \"message\" : \"247.37.0.0 - - [2020-04-30T14:31:43-05:00] \\\"GET /french/images/nav_venue_off.gif HTTP/1.0\\\" 304 0\"}\n+----\n+// TEST[continued]\n+\n+At this point, you can view how {es} stores your raw data.\n+\n+[source,console]\n+----\n+GET /my-index\n+----\n+// TEST[continued]\n+\n+The mapping contains two fields: `@timestamp` and `message`.\n+\n+[source,console-result]\n+----\n+{\n+  \"my-index\" : {\n+    \"aliases\" : { },\n+    \"mappings\" : {\n+      \"properties\" : {\n+        \"@timestamp\" : {\n+          \"type\" : \"date\",\n+          \"format\" : \"strict_date_optional_time||epoch_second\"\n+        },\n+        \"message\" : {\n+          \"type\" : \"wildcard\"\n+        }\n+      }\n+    },\n+    ...\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\\.\\.\\./\"settings\": $body.my-index.settings/]\n+\n+If you want to retrieve results that include `clientip`, you can add that field\n+as a runtime field in the mapping. The runtime script operates on the `clientip`\n+field at runtime to calculate values for that field.\n+\n+[source,console]\n+----\n+PUT /my-index/_mapping\n+{\n+  \"runtime\": {\n+    \"clientip\": {\n+      \"type\": \"ip\",\n+      \"script\" : {\n+      \"source\" : \"String m = doc[\\\"message\\\"].value; int end = m.indexOf(\\\" \\\"); emit(m.substring(0, end));\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+Using the `clientip` runtime field, you can define a simple query to run a\n+search for a specific IP address and return all related fields.\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"size\": 1,\n+  \"query\": {\n+    \"match\": {\n+      \"clientip\": \"211.11.9.0\"\n+    }\n+  },\n+  \"fields\" : [\"*\"]\n+}\n+----\n+// TEST[continued]\n+\n+The API returns the following result. Without building your data structure in\n+advance, you can search and explore your data in meaningful ways to experiment\n+and determine which fields to index.\n+\n+[source,console-result]\n+----\n+{\n+  ...\n+  \"hits\" : {\n+    \"total\" : {\n+      \"value\" : 2,\n+      \"relation\" : \"eq\"\n+    },\n+    \"max_score\" : 1.0,\n+    \"hits\" : [\n+      {\n+        \"_index\" : \"my-index\",\n+        \"_id\" : \"oWs5KXYB-XyJbifr9mrz\",\n+        \"_score\" : 1.0,\n+        \"_source\" : {\n+          \"@timestamp\" : \"2020-06-21T15:00:01-05:00\",\n+          \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"\n+        },\n+        \"fields\" : {\n+          \"@timestamp\" : [\n+            \"2020-06-21T20:00:01.000Z\"\n+          ],\n+          \"clientip\" : [\n+            \"211.11.9.0\"\n+          ],\n+          \"message\" : [\n+            \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"\n+          ]\n+        }\n+      }\n+    ]\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\\.\\.\\./\"took\" : $body.took,\"timed_out\" : $body.timed_out,\"_shards\" : $body._shards,/]\n+// TESTRESPONSE[s/\"_id\" : \"oWs5KXYB-XyJbifr9mrz\"/\"_id\": $body.hits.hits.0._id/]\n+\n+You can add the `day_of_week` field to the mapping using the request from\n+<<runtime-mapping-fields,mapping a runtime field>>:\n+\n+[source,console]\n+----\n+PUT /my-index/_mapping\n+{\n+  \"runtime\": {\n+    \"day_of_week\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  },\n+  \"properties\": {\n+    \"timestamp\": {\n+      \"type\": \"date\"\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+Then, you can re-run the previous search request and also retrieve the day of\n+the week based on the `@timestamp` field:\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"size\": 1,\n+  \"query\": {\n+    \"match\": {\n+      \"clientip\": \"211.11.9.0\"\n+    }\n+  },\n+  \"fields\" : [\"*\"]\n+}\n+----\n+// TEST[continued]\n+\n+The value for this field is calculated dynamically at runtime without\n+reindexing the document or adding the `day_of_week` field. This flexibility\n+allows you to modify the mapping without changing any field values.\n+\n+[source,console-result]\n+----\n+{\n+  ...\n+  \"hits\" : {\n+    \"total\" : {\n+      \"value\" : 2,\n+      \"relation\" : \"eq\"\n+    },\n+    \"max_score\" : 1.0,\n+    \"hits\" : [\n+      {\n+        \"_index\" : \"my-index\",\n+        \"_id\" : \"oWs5KXYB-XyJbifr9mrz\",\n+        \"_score\" : 1.0,\n+        \"_source\" : {\n+          \"@timestamp\" : \"2020-06-21T15:00:01-05:00\",\n+          \"message\" : \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"\n+        },\n+        \"fields\" : {\n+          \"@timestamp\" : [\n+            \"2020-06-21T20:00:01.000Z\"\n+          ],\n+          \"clientip\" : [\n+            \"211.11.9.0\"\n+          ],\n+          \"message\" : [\n+            \"211.11.9.0 - - [2020-06-21T15:00:01-05:00] \\\"GET /english/index.html HTTP/1.0\\\" 304 0\"\n+          ],\n+          \"day_of_week\" : [\n+            \"Sunday\" <1>\n+          ]\n+        }\n+      }\n+    ]\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\\.\\.\\./\"took\" : $body.took,\"timed_out\" : $body.timed_out,\"_shards\" : $body._shards,/]\n+// TESTRESPONSE[s/\"_id\" : \"oWs5KXYB-XyJbifr9mrz\"/\"_id\": $body.hits.hits.0._id/]\n+// TESTRESPONSE[s/\"day_of_week\" : \\[\\n\\s+\"Sunday\"\\n\\s\\]/\"day_of_week\": $body.hits.hits.0.fields.day_of_week/]\n+\n+<1> This value was calculated at search time using the runtime script defined", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5MTU5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537891592", "bodyText": "I wanted to show more of a complete example that walks users through a scenario. We can certainly include more examples for aggregating and filtering. I'll work with @nik9000 to help create those examples.", "author": "lockewritesdocs", "createdAt": "2020-12-07T22:47:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYwMTg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYwMjMyMA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537602320", "bodyText": "is returned?", "author": "javanna", "createdAt": "2020-12-07T15:35:52Z", "path": "docs/reference/search/field-caps.asciidoc", "diffHunk": "@@ -34,6 +34,10 @@ GET /_field_caps?fields=rating\n The field capabilities API returns the information about the capabilities of\n fields among multiple indices.\n \n+The field capabilities API returns <<runtime,runtime fields>> like any\n+other field. For example, a runtime field with a type of\n+`keyword` returns as any other field that belongs to the `keyword` family.", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYwMzI1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537603253", "bodyText": "This page is pretty long, would it make sense to split it into a couple of subpages/sections?", "author": "javanna", "createdAt": "2020-12-07T15:37:03Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMTA1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537901059", "bodyText": "I agree that it's a long page, but I don't want to chunk the content unnecessarily. I think there's a compromise of keeping Benefits, Use cases, and Compromises on the main page, and chunking the other sections to display in the right navigation.", "author": "lockewritesdocs", "createdAt": "2020-12-07T23:06:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYwMzI1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYwNTMwNw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537605307", "bodyText": "I wonder if runtime fields should appear last on the right. Maybe they should be close to field data types and metadata fields? Also, mapping parameters does not apply to runtime fields, does it mean that maybe we need to restructure things a bit? I am not extremely sure what the answer is but i was curious if you had thought about how the overall mappings docs may evolve with the introduction of runtime fields. Before them, there were only indexed fields.", "author": "javanna", "createdAt": "2020-12-07T15:39:41Z", "path": "docs/reference/mapping.asciidoc", "diffHunk": "@@ -262,3 +270,5 @@ include::mapping/fields.asciidoc[]\n include::mapping/params.asciidoc[]\n \n include::mapping/dynamic-mapping.asciidoc[]\n+\n+include::mapping/runtime.asciidoc[]", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxNzMyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537917321", "bodyText": "I moved Runtime fields up in the navigation, and also restructured the main Mappings page. I still think this section needs more work beyond the inclusion of runtime fields.", "author": "lockewritesdocs", "createdAt": "2020-12-07T23:36:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYwNTMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2NDkxOA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537764918", "bodyText": "The key benefit of runtime fields is the ability to add fields to documents after these documents were already ingested into Elasticsearch. In addition to that, adding a runtime field does not increase the index size and runtime fields do not require indexing, so the ingest process performs better.\nA user can define a runtime field initially, and after working with it for a while can decide to change that runtime field into an indexed field in the template, to obtain better query performance. The result will be that this field will be indexed for any new document to any index that will be generated from this template. Queries that will refer to the runtime field will not need to change to refer to the indexed field, and in fact can refer to some indices in which the field is a runtime field and to other indices in which the field is an indexed field.", "author": "giladgal", "createdAt": "2020-12-07T19:20:04Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, you can more quickly ingest raw data", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4NjQ4NA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r539386484", "bodyText": "Thanks for this explanation @giladgal! I updated the runtime fields overview and benefits sections to include this information. Let me know if you find anything lacking.", "author": "lockewritesdocs", "createdAt": "2020-12-09T15:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2NDkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2ODUyNg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537768526", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            of computing values for runtime fields in each document containing that field.\n          \n          \n            \n            of computing values for runtime fields in each document containing that field, because the user will get results asynchronously if the query cannot return the result set synchronously.", "author": "giladgal", "createdAt": "2020-12-07T19:25:46Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. If you later decide that a runtime field is increasingly used\n+for filtering or aggregation, you can add the field to `_source` to gain faster\n+search speed.\n+\n+Instead of reindexing your data to add fields, add runtime fields to the\n+mapping definition. You can access runtime fields from the search API like any\n+other field, and {es} sees runtime fields no differently.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or shadow field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY4NTQ5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r538685496", "bodyText": "I added another sentence at the end. This paragraph now reads as:\n\nUse the <<async-search,asynchronous search API>> to run searches that include\nruntime fields. This method of search helps to offset the performance impacts\nof computing values for runtime fields in each document containing that field.\nIf the query can't return the result set synchronously, you'll get results\nasynchronously as they become available.", "author": "lockewritesdocs", "createdAt": "2020-12-08T18:16:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2ODUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc3MDAxNw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537770017", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            search time, the script runs and generates values for each scripted field.\n          \n          \n            \n            search time, the script runs and generates values for each scripted field that is required for the query.", "author": "giladgal", "createdAt": "2020-12-07T19:28:01Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. If you later decide that a runtime field is increasingly used\n+for filtering or aggregation, you can add the field to `_source` to gain faster\n+search speed.\n+\n+Instead of reindexing your data to add fields, add runtime fields to the\n+mapping definition. You can access runtime fields from the search API like any\n+other field, and {es} sees runtime fields no differently.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or shadow field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+[discrete]\n+[[runtime-mapping-fields]]\n+=== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+original `_source` and `doc_values` (the mapped field plus its values). At\n+search time, the script runs and generates values for each scripted field.", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc3MTY0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r537771643", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <2> Each runtime has its own field type, just like any other field.\n          \n          \n            \n            <2> Each runtime field has its own field type, just like any other field.", "author": "giladgal", "createdAt": "2020-12-07T19:30:30Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,518 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, you can more quickly ingest raw data\n+into the Elastic Stack and access it immediately. By dynamically evaluating\n+runtime fields at search time, you can optimize disk space by choosing which\n+fields to index. If you later decide that a runtime field is increasingly used\n+for filtering or aggregation, you can add the field to `_source` to gain faster\n+search speed.\n+\n+Instead of reindexing your data to add fields, add runtime fields to the\n+mapping definition. You can access runtime fields from the search API like any\n+other field, and {es} sees runtime fields no differently.\n+\n+Alternatively, you can specify a `runtime_mappings` section in a search request\n+to use runtime fields that exist only as part of the query. This\n+flexibility allows you to create or shadow field values in `_source` for the\n+duration of the query without modifying the field itself.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+[discrete]\n+[[runtime-mapping-fields]]\n+=== Mapping a runtime field\n+You map runtime fields by adding a `\"runtime\"` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+original `_source` and `doc_values` (the mapped field plus its values). At\n+search time, the script runs and generates values for each scripted field.\n+\n+NOTE: You can define a runtime field in the mapping definition without a\n+script. {es} will look in `_source` for a field with the same name as the\n+runtime field and use values from that field at query time.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request, but also make the script results available for\n+queries and aggregations.\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` type:\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `\"runtime\"` section of the mapping\n+definition.\n+<2> Each runtime has its own field type, just like any other field.", "originalCommit": "d9a927167824d778de20c5db84f6701406ec5893", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4d5452d2840d25f9f0e1cf355bd14741c2a7c8f6", "url": "https://github.com/elastic/elasticsearch/commit/4d5452d2840d25f9f0e1cf355bd14741c2a7c8f6", "message": "Apply suggestions from code review\n\nCo-authored-by: Gilad Gal <gilad.gal@elastic.co>", "committedDate": "2020-12-07T22:36:42Z", "type": "commit"}, {"oid": "817591707969001ef5b9982efdedfdacb485ad02", "url": "https://github.com/elastic/elasticsearch/commit/817591707969001ef5b9982efdedfdacb485ad02", "message": "Incorporating reviewer feedback 7 Dec", "committedDate": "2020-12-07T23:44:58Z", "type": "commit"}, {"oid": "4e7b0b816bf9d1e50e9af4affd58adfa165b949d", "url": "https://github.com/elastic/elasticsearch/commit/4e7b0b816bf9d1e50e9af4affd58adfa165b949d", "message": "Merge branch 'master' into docs__add-runtime-fields", "committedDate": "2020-12-08T14:05:11Z", "type": "commit"}, {"oid": "b732ae2997f8abd4b812960b440f3e095eb120d7", "url": "https://github.com/elastic/elasticsearch/commit/b732ae2997f8abd4b812960b440f3e095eb120d7", "message": "Shifting structure of mapping page to fix cross links.", "committedDate": "2020-12-08T15:17:47Z", "type": "commit"}, {"oid": "1ea874f6535f91cd21efa6b4b870f5b454305acb", "url": "https://github.com/elastic/elasticsearch/commit/1ea874f6535f91cd21efa6b4b870f5b454305acb", "message": "Merge branch 'docs__add-runtime-fields' of github.com:lockewritesdocs/elasticsearch into docs__add-runtime-fields", "committedDate": "2020-12-08T15:18:16Z", "type": "commit"}, {"oid": "8870aabdbe3f3bc1b519bf042c473b81a37d0dc0", "url": "https://github.com/elastic/elasticsearch/commit/8870aabdbe3f3bc1b519bf042c473b81a37d0dc0", "message": "Revisions for shadowing, overview, and other sections.", "committedDate": "2020-12-08T23:17:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQyMjY1MA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r539422650", "bodyText": "you can add runtime fields ?", "author": "javanna", "createdAt": "2020-12-09T15:51:11Z", "path": "docs/reference/mapping.asciidoc", "diffHunk": "@@ -30,68 +30,34 @@ document. Each field has its own <<mapping-types, data type>>.\n NOTE: Before 7.0.0, the 'mappings' definition used to include a type name.\n For more details, please see <<removal-of-types>>.\n \n-[[mapping-limit-settings]]\n [discrete]\n-=== Settings to prevent mappings explosion\n-\n-Defining too many fields in an index can lead to a\n-mapping explosion, which can cause out of memory errors and difficult\n-situations to recover from.\n+[[mapping-limit-settings]]\n+== Settings to prevent mapping explosion\n+Defining too many fields in an index can lead to a mapping explosion, which can\n+cause out of memory errors and difficult situations to recover from.\n \n Consider a situation where every new document inserted\n introduces new fields, such as with <<dynamic-mapping,dynamic mapping>>.\n Each new field is added to the index mapping, which can become a\n problem as the mapping grows.\n \n-Use the following settings to limit the number of field mappings (created manually or dynamically) and prevent documents from causing a mapping explosion:\n-\n-`index.mapping.total_fields.limit`::\n-    The maximum number of fields in an index. Field and object mappings, as well as\n-    field aliases count towards this limit. The default value is `1000`.\n-+\n-[IMPORTANT]\n-====\n-The limit is in place to prevent mappings and searches from becoming too\n-large. Higher values can lead to performance degradations and memory issues,\n-especially in clusters with a high load or few resources.\n-\n-If you increase this setting, we recommend you also increase the\n-<<search-settings,`indices.query.bool.max_clause_count`>> setting, which\n-limits the maximum number of <<query-dsl-bool-query,boolean clauses>> in a query.\n-====\n-+\n-[TIP]\n-====\n-If your field mappings contain a large, arbitrary set of keys, consider using the <<flattened,flattened>> data type.\n-====\n-\n-`index.mapping.depth.limit`::\n-    The maximum depth for a field, which is measured as the number of inner\n-    objects. For instance, if all fields are defined at the root object level,\n-    then the depth is `1`. If there is one object mapping, then the depth is\n-    `2`, etc. Default is `20`.\n-\n-// tag::nested-fields-limit[]\n-`index.mapping.nested_fields.limit`::\n-    The maximum number of distinct `nested` mappings in an index. The `nested` type should only be used in special cases, when arrays of objects need to be queried independently of each other. To safeguard against poorly designed mappings, this setting\n-    limits the number of unique `nested` types per index. Default is `50`.\n-// end::nested-fields-limit[]\n-\n-// tag::nested-objects-limit[]\n-`index.mapping.nested_objects.limit`::\n-    The maximum number of nested JSON objects that a single document can contain across all\n-    `nested` types. This limit helps to prevent out of memory errors when a document contains too many nested\n-    objects. Default is `10000`.\n-// end::nested-objects-limit[]\n-\n-`index.mapping.field_name_length.limit`::\n-    Setting for the maximum length of a field name. This setting isn't really something that addresses\n-    mappings explosion but might still be useful if you want to limit the field length.\n-    It usually shouldn't be necessary to set this setting. The default is okay\n-    unless a user starts to add a huge number of fields with really long names. Default is\n-    `Long.MAX_VALUE` (no limit).\n+Use the <<mapping-settings-limit,mapping limit settings>> to limit the number\n+of field mappings (created manually or dynamically) and prevent documents from\n+causing a mapping explosion.\n+\n+[discrete]\n+[[runtime-fields]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents.\n+\n+<<runtime,Runtime fields>> are not indexed, which saves disk space and makes\n+data ingest faster. You can add fields to existing documents without reindexing", "originalCommit": "8870aabdbe3f3bc1b519bf042c473b81a37d0dc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQyNjE5MA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r539426190", "bodyText": "Is it important to specify that within the section you define the runtime fields, each of which are made of a painless script? Does the current text make users think that they only have to stick a script in the runtime section?", "author": "javanna", "createdAt": "2020-12-09T15:55:11Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,603 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+You access runtime fields from the search API like any other field, and {es}\n+sees runtime fields no differently.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, adding a runtime field doesn't increase\n+the index size. You define runtime fields directly in the index mapping, saving\n+storage costs and increasing ingestion speed. You can more quickly ingest\n+data into the Elastic Stack and access it right away.\n+\n+When you define a runtime field, you can immediately use it in search requests,\n+aggregations, filtering, and sorting. If you later decide that the runtime\n+field is increasingly used for filtering or aggregations, you can modify the\n+index template to make the runtime field an indexed field. You'll achieve better\n+query performance, and the field will be indexed for any new document matching\n+an index generated by the index template.\n+\n+If you make a runtime field an indexed field, you don't need to modify any\n+queries that refer to the runtime field. Better yet, you can refer to some\n+indices where the field is a runtime field, and other indices where the field\n+is an indexed field. You have the flexibility to choose which fields to index\n+and which ones to keep as runtime fields.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.\n+If the query can't return the result set synchronously, you'll get results\n+asynchronously as they become available.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+[[runtime-mapping-fields]]\n+=== Mapping a runtime field\n+You map runtime fields by adding a `runtime` section under the mapping\n+definition. Within that section, you", "originalCommit": "8870aabdbe3f3bc1b519bf042c473b81a37d0dc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQyNzExNA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r539427114", "bodyText": "missing comma after geo_point", "author": "javanna", "createdAt": "2020-12-09T15:56:11Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,603 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+You access runtime fields from the search API like any other field, and {es}\n+sees runtime fields no differently.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, adding a runtime field doesn't increase\n+the index size. You define runtime fields directly in the index mapping, saving\n+storage costs and increasing ingestion speed. You can more quickly ingest\n+data into the Elastic Stack and access it right away.\n+\n+When you define a runtime field, you can immediately use it in search requests,\n+aggregations, filtering, and sorting. If you later decide that the runtime\n+field is increasingly used for filtering or aggregations, you can modify the\n+index template to make the runtime field an indexed field. You'll achieve better\n+query performance, and the field will be indexed for any new document matching\n+an index generated by the index template.\n+\n+If you make a runtime field an indexed field, you don't need to modify any\n+queries that refer to the runtime field. Better yet, you can refer to some\n+indices where the field is a runtime field, and other indices where the field\n+is an indexed field. You have the flexibility to choose which fields to index\n+and which ones to keep as runtime fields.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.\n+If the query can't return the result set synchronously, you'll get results\n+asynchronously as they become available.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+[[runtime-mapping-fields]]\n+=== Mapping a runtime field\n+You map runtime fields by adding a `runtime` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+entire context of a document, including the original `_source` and any mapped\n+fields plus their values. At search time, the script runs and generates values\n+for each scripted field that is required for the query.\n+\n+NOTE: You can define a runtime field in the mapping definition without a\n+script. {es} will look in `_source` for a field with the same name as the\n+runtime field and use values from that field at query time.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request, but also make the script results available anywhere\n+in a search request.\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` type:\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `runtime` section of the mapping\n+definition.\n+<2> Each runtime field has its own field type, just like any other field.\n+<3> The script defines the evaluation to calculate at search time.\n+\n+The `runtime` section supports `boolean`, `date`, `double`, `geo_point` `ip`,", "originalCommit": "8870aabdbe3f3bc1b519bf042c473b81a37d0dc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQyOTk3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r539429977", "bodyText": "is it clear that these two mappings examples are not equivalent, in that one defines company.name as a text indexed field, while the other one defines it as a runtime field? Is it worth shortening this to using keyword for the name instead of a multi_field in the example above? Or possibly not even showing that mappings, but rather say: given this document, say you want to map company.name as a runtime field, here is how you do it:", "author": "javanna", "createdAt": "2020-12-09T15:59:25Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,603 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+You access runtime fields from the search API like any other field, and {es}\n+sees runtime fields no differently.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, adding a runtime field doesn't increase\n+the index size. You define runtime fields directly in the index mapping, saving\n+storage costs and increasing ingestion speed. You can more quickly ingest\n+data into the Elastic Stack and access it right away.\n+\n+When you define a runtime field, you can immediately use it in search requests,\n+aggregations, filtering, and sorting. If you later decide that the runtime\n+field is increasingly used for filtering or aggregations, you can modify the\n+index template to make the runtime field an indexed field. You'll achieve better\n+query performance, and the field will be indexed for any new document matching\n+an index generated by the index template.\n+\n+If you make a runtime field an indexed field, you don't need to modify any\n+queries that refer to the runtime field. Better yet, you can refer to some\n+indices where the field is a runtime field, and other indices where the field\n+is an indexed field. You have the flexibility to choose which fields to index\n+and which ones to keep as runtime fields.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.\n+If the query can't return the result set synchronously, you'll get results\n+asynchronously as they become available.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+[[runtime-mapping-fields]]\n+=== Mapping a runtime field\n+You map runtime fields by adding a `runtime` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+entire context of a document, including the original `_source` and any mapped\n+fields plus their values. At search time, the script runs and generates values\n+for each scripted field that is required for the query.\n+\n+NOTE: You can define a runtime field in the mapping definition without a\n+script. {es} will look in `_source` for a field with the same name as the\n+runtime field and use values from that field at query time.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request, but also make the script results available anywhere\n+in a search request.\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` type:\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `runtime` section of the mapping\n+definition.\n+<2> Each runtime field has its own field type, just like any other field.\n+<3> The script defines the evaluation to calculate at search time.\n+\n+The `runtime` section supports `boolean`, `date`, `double`, `geo_point` `ip`,\n+`keyword`, and `long` data types. Runtime fields with a `type` of `date` can\n+accept the <<mapping-date-format,`format`>> parameter exactly as the `date`\n+field type.\n+\n+You can define a runtime field that isn't at the top level of a document. If\n+you want to map a runtime field under an object, you can use dot notation\n+instead of recreating the entire object structure.\n+\n+For example, let's say you add the following document:\n+\n+[source, console]\n+----\n+POST my-index/_doc/1\n+{\n+  \"company\": {\n+    \"name\": \"Elastic\"\n+  }\n+}\n+----\n+\n+If you retrieve the mapping for that document, you'll see that the `name` field\n+is nested under the `company` object:\n+\n+[source, console]\n+----\n+GET my-index/_mapping\n+----\n+//TEST[continued]\n+\n+[source, console-result]\n+----\n+{\n+  \"my-index\" : {\n+    \"mappings\" : {\n+      \"properties\" : {\n+        \"company\" : {\n+          \"properties\" : {\n+            \"name\" : {\n+              \"type\" : \"text\",\n+              \"fields\" : {\n+                \"keyword\" : {\n+                  \"type\" : \"keyword\",\n+                  \"ignore_above\" : 256\n+                }\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+----\n+//TEST[continued]\n+\n+You could create a runtime field in the mapping using `company.name` instead of\n+recreating the object structure for that field:", "originalCommit": "8870aabdbe3f3bc1b519bf042c473b81a37d0dc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ0NzI3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r539447277", "bodyText": "After talking to Nik, I decided to remove this example and move this section under the Shadowing page, since we're effectively showing how to shadow a field that is part of an object.", "author": "lockewritesdocs", "createdAt": "2020-12-09T16:20:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQyOTk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ1Mjg3MA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r539452870", "bodyText": "I agree on the confusion, but not on the solution :) I think we can mention how to map runtime fields that belong to objects independently of shadowing. The point of this example should be to show how to map company.name as a runtime field, rather than how to shadow the existing indexed field.", "author": "javanna", "createdAt": "2020-12-09T16:26:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQyOTk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ1MzgxNA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r539453814", "bodyText": "Another idea, is to have runtime fields that belong to objects in most of our examples instead of at the top-level, and not mention the dot notation explicitly, because examples makes it clear how to do it.", "author": "javanna", "createdAt": "2020-12-09T16:27:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQyOTk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQzMjk3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r539432972", "bodyText": "shall we also add the response for this request, to show how the runtime field is returned? Or is that redundant?", "author": "javanna", "createdAt": "2020-12-09T16:02:57Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -0,0 +1,603 @@\n+[[runtime]]\n+== Runtime fields\n+Typically, you index data into {es} to promote faster search. However, indexing\n+can be slow and requires more disk space, and you have to reindex your data to\n+add fields to existing documents. With _runtime fields_, you can add\n+fields to documents already indexed to {es} without reindexing your data.\n+\n+You access runtime fields from the search API like any other field, and {es}\n+sees runtime fields no differently.\n+\n+[discrete]\n+[[runtime-benefits]]\n+=== Benefits\n+Because runtime fields aren't indexed, adding a runtime field doesn't increase\n+the index size. You define runtime fields directly in the index mapping, saving\n+storage costs and increasing ingestion speed. You can more quickly ingest\n+data into the Elastic Stack and access it right away.\n+\n+When you define a runtime field, you can immediately use it in search requests,\n+aggregations, filtering, and sorting. If you later decide that the runtime\n+field is increasingly used for filtering or aggregations, you can modify the\n+index template to make the runtime field an indexed field. You'll achieve better\n+query performance, and the field will be indexed for any new document matching\n+an index generated by the index template.\n+\n+If you make a runtime field an indexed field, you don't need to modify any\n+queries that refer to the runtime field. Better yet, you can refer to some\n+indices where the field is a runtime field, and other indices where the field\n+is an indexed field. You have the flexibility to choose which fields to index\n+and which ones to keep as runtime fields.\n+\n+[discrete]\n+[[runtime-use-cases]]\n+=== Use cases\n+Runtime fields are useful when working with log data\n+(see <<runtime-examples,examples>>), especially when you're unsure about the\n+data structure. Your search speed decreases, but your index size is much\n+smaller and you can more quickly process logs without having to index them.\n+\n+Runtime fields are especially useful in the following contexts:\n+\n+* Adding fields to documents that are already indexed without having to reindex\n+data\n+* Immediately begin working on a new data stream without fully understanding\n+the data it contains\n+* Shadowing an indexed field with a runtime field to fix a mistake after\n+indexing documents\n+* Defining fields that are only relevant for a particular context (such as a\n+visualization in {kib}) without influencing the underlying schema\n+\n+[discrete]\n+[[runtime-compromises]]\n+=== Compromises\n+Runtime fields use less disk space and provide flexibility in how you access\n+your data, but can impact search performance based on the computation defined in\n+the runtime script.\n+\n+To balance search performance and flexibility, index fields that you'll\n+commonly search for and filter on, such as a timestamp. {es} automatically uses\n+these indexed fields first when running a query, resulting in a fast response\n+time. You can then use runtime fields to limit the number of fields that {es}\n+needs to calculate values for. Using indexed fields in tandem with runtime\n+fields provides flexibility in the data that you index and how you define\n+queries for other fields.\n+\n+Use the <<async-search,asynchronous search API>> to run searches that include\n+runtime fields. This method of search helps to offset the performance impacts\n+of computing values for runtime fields in each document containing that field.\n+If the query can't return the result set synchronously, you'll get results\n+asynchronously as they become available.\n+\n+IMPORTANT: Queries against runtime fields are considered expensive. If\n+<<query-dsl-allow-expensive-queries,`search.allow_expensive_queries`>> is set\n+to `false`, expensive queries are not allowed and {es} will reject any queries\n+against runtime fields.\n+\n+[[runtime-mapping-fields]]\n+=== Mapping a runtime field\n+You map runtime fields by adding a `runtime` section under the mapping\n+definition. Within that section, you\n+<<modules-scripting-using,define a Painless script>>, which has access to the\n+entire context of a document, including the original `_source` and any mapped\n+fields plus their values. At search time, the script runs and generates values\n+for each scripted field that is required for the query.\n+\n+NOTE: You can define a runtime field in the mapping definition without a\n+script. {es} will look in `_source` for a field with the same name as the\n+runtime field and use values from that field at query time.\n+\n+Runtime fields are similar to the <<script-fields,`script_fields`>> parameter\n+of the `_search` request, but also make the script results available anywhere\n+in a search request.\n+\n+The script in the following request extracts the day of the week from the\n+`@timestamp` field, which is defined as a `date` type:\n+\n+[source,console]\n+----\n+PUT /my-index\n+{\n+  \"mappings\": {\n+    \"runtime\": { <1>\n+      \"day_of_week\": {\n+        \"type\": \"keyword\", <2>\n+        \"script\": { <3>\n+          \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+        }\n+      }\n+    },\n+    \"properties\": {\n+      \"timestamp\": {\"type\": \"date\"}\n+    }\n+  }\n+}\n+----\n+\n+<1> Runtime fields are defined in the `runtime` section of the mapping\n+definition.\n+<2> Each runtime field has its own field type, just like any other field.\n+<3> The script defines the evaluation to calculate at search time.\n+\n+The `runtime` section supports `boolean`, `date`, `double`, `geo_point` `ip`,\n+`keyword`, and `long` data types. Runtime fields with a `type` of `date` can\n+accept the <<mapping-date-format,`format`>> parameter exactly as the `date`\n+field type.\n+\n+You can define a runtime field that isn't at the top level of a document. If\n+you want to map a runtime field under an object, you can use dot notation\n+instead of recreating the entire object structure.\n+\n+For example, let's say you add the following document:\n+\n+[source, console]\n+----\n+POST my-index/_doc/1\n+{\n+  \"company\": {\n+    \"name\": \"Elastic\"\n+  }\n+}\n+----\n+\n+If you retrieve the mapping for that document, you'll see that the `name` field\n+is nested under the `company` object:\n+\n+[source, console]\n+----\n+GET my-index/_mapping\n+----\n+//TEST[continued]\n+\n+[source, console-result]\n+----\n+{\n+  \"my-index\" : {\n+    \"mappings\" : {\n+      \"properties\" : {\n+        \"company\" : {\n+          \"properties\" : {\n+            \"name\" : {\n+              \"type\" : \"text\",\n+              \"fields\" : {\n+                \"keyword\" : {\n+                  \"type\" : \"keyword\",\n+                  \"ignore_above\" : 256\n+                }\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+----\n+//TEST[continued]\n+\n+You could create a runtime field in the mapping using `company.name` instead of\n+recreating the object structure for that field:\n+\n+[source,console]\n+----\n+PUT my-index/_mapping\n+{\n+  \"runtime\": {\n+    \"company.name\": {\n+      \"type\": \"keyword\"\n+    }\n+  }\n+}\n+----\n+//TEST[continued]\n+\n+[[runtime-updating-scripts]]\n+.Updating runtime scripts\n+****\n+\n+Updating a script while a dependent query is running can return\n+inconsistent results. Each shard might have access to different versions of the\n+script, depending on when the mapping change takes effect.\n+\n+Existing queries or visualizations in {kib} that rely on runtime fields can\n+fail if you change the field type. For example, a bar chart visualization\n+that uses a runtime field of type `ip` will fail if the type is changed\n+to `boolean`.\n+\n+****\n+\n+[[runtime-search-request]]\n+=== Defining runtime fields in a search request\n+You can specify a `runtime_mappings` section in a search request to create\n+runtime fields that exist only as part of the query. You specify a script\n+as part of the `runtime_mappings` section, just as you would if adding a\n+runtime field to the mappings.\n+\n+Fields defined in the search request take precedence over fields defined with\n+the same name in the index mappings. This flexibility allows you to shadow\n+existing fields and calculate a different value in the search request, without\n+modifying the field itself. If you made a mistake in your index mapping, you\n+can use runtime fields to calculate values that override values in the mapping\n+during the search request.\n+\n+In the following request, the values for the `day_of_week` field are calculated\n+dynamically, and only within the context of this search request:\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"day_of_week\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"day_of_week\": {\n+      \"terms\": {\n+        \"field\": \"day_of_week\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+Defining a runtime field in a search request uses the same format as defining\n+a runtime field in the index mapping. That consistency means you can promote a\n+runtime field from a search request to the index mapping by moving the field\n+definition from `runtime_mappings` in the search request to the `runtime`\n+section of the index mapping.\n+\n+[[runtime-shadowing-fields]]\n+=== Shadowing fields\n+If you create a runtime field with the same name as a field that\n+already exists in the mapping, the runtime field shadows the mapped field. At\n+search time, {es} evaluates the runtime field, calculates a value based on the\n+script, and returns the value as part of the query. Because the runtime field\n+shadows the mapped field, you can modify the value returned in search without\n+modifying the mapped field.\n+\n+If you define a runtime field that does not include a script, {es} evaluates the\n+field at search time, looks at each document containing that field, retrieves\n+the `_source`, and returns a value if one exists.\n+\n+As mentioned in <<runtime-mapping-fields,mapping a runtime field>>, you can\n+shadow field values inside objects. For example, index the following documents into `my-index`:\n+\n+[source, console]\n+----\n+POST my-index/_bulk?refresh=true\n+{\"index\":{}}\n+{\"name\":{\"first\":\"Jose\",\"last\":\"Hickman\"}}\n+{\"index\":{}}\n+{\"name\":{\"first\":\"India\",\"last\":\"Avila\",\"suffix\":\"II\"}}\n+----\n+\n+In the `runtime_mappings` section of the `_search` request, you can define a\n+script that operates on the `name.first` field. The values you specify will\n+shadow field values in the index mapping for the duration of the query without\n+modifying the field itself.\n+\n+The following request defines a runtime field that retrieves values based on\n+the script valuation. The field defined in the search request shadows the\n+indexed `name.first` field and substitutes a value for that field based on the\n+logic defined in the script:\n+\n+[source,console]\n+----\n+POST my-index/_search\n+{\n+  \"runtime_mappings\": {\n+    \"name.first\": {\n+      \"type\": \"keyword\",\n+      \"script\": {\n+        \"source\": \"if (\\\"Hickman\\\".equals(doc[\\\"name.last.keyword\\\"].value)) {emit(\\\"Guile\\\");} else if (\\\"Avila\\\".equals(doc[\\\"name.last.keyword\\\"].value)) {emit(\\\"Anastasia\\\");}\"\n+      }\n+    }\n+  },\n+  \"query\": {\n+    \"match\": {\n+      \"name.first\": \"Anastasia\"\n+    }\n+  }\n+}\n+----\n+// TEST[continued]\n+\n+\n+[[runtime-retrieving-fields]]\n+=== Retrieving a runtime field\n+Use the <<search-fields,`fields`>> parameter on the `_search` API to retrieve\n+the values of runtime fields. Runtime fields won't display in `_source`, but\n+the `fields` API works for all fields, even those that were not sent as part of\n+the original `_source`.\n+\n+The following request uses the search API to retrieve the `day_of_week` field\n+that <<runtime-mapping-fields,this previous request>> defined as a runtime field\n+in the mapping. The value for the `day_of_week` field is calculated dynamically\n+at search time based on the evaluation of the defined script.\n+\n+[source,console]\n+----\n+GET my-index/_search\n+{\n+  \"fields\": [\n+    \"@timestamp\",\n+    \"day_of_week\"\n+  ],\n+  \"_source\": false\n+}", "originalCommit": "8870aabdbe3f3bc1b519bf042c473b81a37d0dc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1475e9de11530dc2a7531ba86be7105919f43625", "url": "https://github.com/elastic/elasticsearch/commit/1475e9de11530dc2a7531ba86be7105919f43625", "message": "Removing dot notation section and incorporating review changes.", "committedDate": "2020-12-09T17:15:57Z", "type": "commit"}, {"oid": "06241b7923628b7c4fc44728e86278afd770a920", "url": "https://github.com/elastic/elasticsearch/commit/06241b7923628b7c4fc44728e86278afd770a920", "message": "Adding updated example for shadowing.", "committedDate": "2020-12-09T22:00:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4MzE5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r539683192", "bodyText": "I'd make there be maybe 2 unique model_numbers, just to clarify that you get a lot of hits from one.", "author": "nik9000", "createdAt": "2020-12-09T22:05:45Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -193,48 +190,164 @@ script, and returns the value as part of the query. Because the runtime field\n shadows the mapped field, you can modify the value returned in search without\n modifying the mapped field.\n \n-For example, index the following documents into `my-index`:\n+For example, let's say you indexed the following documents into `my-index`:\n \n-[source, console]\n+[source,console]\n ----\n POST my-index/_bulk?refresh=true\n {\"index\":{}}\n-{\"name\":{\"first\":\"Jose\",\"last\":\"Hickman\"}}\n+{\"timestamp\":1516729294000,\"model_number\":\"QVKC92Q\",\"measures\":{\"voltage\":5.2}}\n+{\"index\":{}}\n+{\"timestamp\":1516642894000,\"model_number\":\"PW83H7X\",\"measures\":{\"voltage\":5.8}}\n+{\"index\":{}}\n+{\"timestamp\":1516556494000,\"model_number\":\"ELF7YV2\",\"measures\":{\"voltage\":5.1}}\n+{\"index\":{}}\n+{\"timestamp\":1516470094000,\"model_number\":\"5NMDTMF\",\"measures\":{\"voltage\":5.6}}\n {\"index\":{}}\n-{\"name\":{\"first\":\"India\",\"last\":\"Avila\",\"suffix\":\"II\"}}\n+{\"timestamp\":1516383694000,\"model_number\":\"1N0TH44\",\"measures\":{\"voltage\":4.2}}\n+{\"index\":{}}\n+{\"timestamp\":1516297294000,\"model_number\":\"HG537PU\",\"measures\":{\"voltage\":4.0}}", "originalCommit": "06241b7923628b7c4fc44728e86278afd770a920", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5NzA3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r539697076", "bodyText": "I'll whittle the example down to only use two model numbers and adjust the surrounding text accordingly.", "author": "lockewritesdocs", "createdAt": "2020-12-09T22:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4MzE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4MzgwOA==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r539683808", "bodyText": "I'd say something like \"Those darned HG537PUs report 90% of the real voltage\" or something like that. Sounds kind of believable.", "author": "nik9000", "createdAt": "2020-12-09T22:06:53Z", "path": "docs/reference/mapping/runtime.asciidoc", "diffHunk": "@@ -193,48 +190,164 @@ script, and returns the value as part of the query. Because the runtime field\n shadows the mapped field, you can modify the value returned in search without\n modifying the mapped field.\n \n-For example, index the following documents into `my-index`:\n+For example, let's say you indexed the following documents into `my-index`:\n \n-[source, console]\n+[source,console]\n ----\n POST my-index/_bulk?refresh=true\n {\"index\":{}}\n-{\"name\":{\"first\":\"Jose\",\"last\":\"Hickman\"}}\n+{\"timestamp\":1516729294000,\"model_number\":\"QVKC92Q\",\"measures\":{\"voltage\":5.2}}\n+{\"index\":{}}\n+{\"timestamp\":1516642894000,\"model_number\":\"PW83H7X\",\"measures\":{\"voltage\":5.8}}\n+{\"index\":{}}\n+{\"timestamp\":1516556494000,\"model_number\":\"ELF7YV2\",\"measures\":{\"voltage\":5.1}}\n+{\"index\":{}}\n+{\"timestamp\":1516470094000,\"model_number\":\"5NMDTMF\",\"measures\":{\"voltage\":5.6}}\n {\"index\":{}}\n-{\"name\":{\"first\":\"India\",\"last\":\"Avila\",\"suffix\":\"II\"}}\n+{\"timestamp\":1516383694000,\"model_number\":\"1N0TH44\",\"measures\":{\"voltage\":4.2}}\n+{\"index\":{}}\n+{\"timestamp\":1516297294000,\"model_number\":\"HG537PU\",\"measures\":{\"voltage\":4.0}}\n ----\n \n-In the `runtime_mappings` section of the `_search` request, you can define a\n-script that operates on the `name.first` field. The values you specify will\n-shadow field values in the index mapping for the duration of the query without\n-modifying the field itself.\n+You later realize that the voltage for the sensor matching model number\n+`HG537PU` is incorrect. The indexed value is `4.0`, but is supposed to be 1.7", "originalCommit": "06241b7923628b7c4fc44728e86278afd770a920", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwMDE1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62653#discussion_r539700151", "bodyText": "\"Sir, I was told these were quality sensors.\"", "author": "lockewritesdocs", "createdAt": "2020-12-09T22:36:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4MzgwOA=="}], "type": "inlineReview"}, {"oid": "c1b61ee1d709fa0b64699e88863bf4858651276d", "url": "https://github.com/elastic/elasticsearch/commit/c1b61ee1d709fa0b64699e88863bf4858651276d", "message": "Streamlining shadowing example and TESTRESPONSEs.", "committedDate": "2020-12-09T22:39:23Z", "type": "commit"}]}