{"pr_number": 52791, "pr_title": "EQL: Add IsNull/IsNotNull checks", "pr_createdAt": "2020-02-25T18:53:14Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52791", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczNTM2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52791#discussion_r384735361", "bodyText": "Better to check if the expression is foldable and its folded value contains (\"*\"):\nif (exp.foldable()) {\n   Object value = exp.fold();\n   return value instanceof String && value.toString().contains(\"*\");\n}\nreturn false;", "author": "costin", "createdAt": "2020-02-26T20:06:04Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "diffHunk": "@@ -45,4 +59,85 @@ public LogicalPlan optimize(LogicalPlan verified) {\n \n         return Arrays.asList(operators, label);\n     }\n+\n+\n+    private static class ReplaceWildcards extends OptimizerRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {", "originalCommit": "5bf18c8b49e4ad5c2de52fedfe1d4889cf581560", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczNTU0OA==", "url": "https://github.com/elastic/elasticsearch/pull/52791#discussion_r384735548", "bodyText": "eq.right().fold().toString()", "author": "costin", "createdAt": "2020-02-26T20:06:28Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "diffHunk": "@@ -45,4 +59,85 @@ public LogicalPlan optimize(LogicalPlan verified) {\n \n         return Arrays.asList(operators, label);\n     }\n+\n+\n+    private static class ReplaceWildcards extends OptimizerRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private static LikePattern toLikePattern(String s) {\n+            // pick a character that is guaranteed not to be in the string, because it isn't allowed to escape itself\n+            char escape = 1;\n+\n+            // replace wildcards with % and escape special characters\n+            String likeString = s.replace(\"%\", escape + \"%\")\n+                .replace(\"_\", escape + \"_\")\n+                .replace(\"*\", \"%\");\n+\n+            return new LikePattern(likeString, escape);\n+        }\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                // expr == \"wildcard*phrase\"\n+                if (e instanceof Equals) {\n+                    Equals eq = (Equals) e;\n+\n+                    if (isWildcard(eq.right())) {\n+                        String wcString = (String) eq.right().fold();", "originalCommit": "5bf18c8b49e4ad5c2de52fedfe1d4889cf581560", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczNzI2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52791#discussion_r384737263", "bodyText": "The blocks between Equals and NotEquals are the same and should be \"compressed\":\nif (e instanceof Equals || e instanceof NotEquals) {\n if (isWildcard ...) {\n  Like like = new Like()...\n  if (e instanceof NotEquals) {\n       like = new Not (...);\n   }\n   e = like\n}\nreturn e;", "author": "costin", "createdAt": "2020-02-26T20:09:44Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "diffHunk": "@@ -45,4 +59,85 @@ public LogicalPlan optimize(LogicalPlan verified) {\n \n         return Arrays.asList(operators, label);\n     }\n+\n+\n+    private static class ReplaceWildcards extends OptimizerRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private static LikePattern toLikePattern(String s) {\n+            // pick a character that is guaranteed not to be in the string, because it isn't allowed to escape itself\n+            char escape = 1;\n+\n+            // replace wildcards with % and escape special characters\n+            String likeString = s.replace(\"%\", escape + \"%\")\n+                .replace(\"_\", escape + \"_\")\n+                .replace(\"*\", \"%\");\n+\n+            return new LikePattern(likeString, escape);\n+        }\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                // expr == \"wildcard*phrase\"\n+                if (e instanceof Equals) {", "originalCommit": "5bf18c8b49e4ad5c2de52fedfe1d4889cf581560", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczNzU4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52791#discussion_r384737581", "bodyText": "wrong comment.", "author": "costin", "createdAt": "2020-02-26T20:10:27Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "diffHunk": "@@ -45,4 +59,85 @@ public LogicalPlan optimize(LogicalPlan verified) {\n \n         return Arrays.asList(operators, label);\n     }\n+\n+\n+    private static class ReplaceWildcards extends OptimizerRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private static LikePattern toLikePattern(String s) {\n+            // pick a character that is guaranteed not to be in the string, because it isn't allowed to escape itself\n+            char escape = 1;\n+\n+            // replace wildcards with % and escape special characters\n+            String likeString = s.replace(\"%\", escape + \"%\")\n+                .replace(\"_\", escape + \"_\")\n+                .replace(\"*\", \"%\");\n+\n+            return new LikePattern(likeString, escape);\n+        }\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                // expr == \"wildcard*phrase\"\n+                if (e instanceof Equals) {\n+                    Equals eq = (Equals) e;\n+\n+                    if (isWildcard(eq.right())) {\n+                        String wcString = (String) eq.right().fold();\n+                        e = new Like(e.source(), eq.left(), toLikePattern(wcString));\n+                    }\n+                }\n+\n+                // expr != \"wildcard*phrase\"\n+                else if (e instanceof NotEquals) {\n+                    NotEquals eq = (NotEquals) e;\n+\n+                    if (isWildcard(eq.right())) {\n+                        String wcString = (String) eq.right().fold();\n+                        Like inner = new Like(eq.source(), eq.left(), toLikePattern(wcString));\n+                        e = new Not(e.source(), inner);\n+                    }\n+                }\n+                return e;\n+            });\n+        }\n+    }\n+\n+    private static class ReplaceNullChecks extends OptimizerRule<Filter> {\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+\n+            return filter.transformExpressionsUp(e -> {\n+                // expr == \"wildcard*phrase\"", "originalCommit": "5bf18c8b49e4ad5c2de52fedfe1d4889cf581560", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczNzY3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52791#discussion_r384737679", "bodyText": "wrong comment.", "author": "costin", "createdAt": "2020-02-26T20:10:42Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "diffHunk": "@@ -45,4 +59,85 @@ public LogicalPlan optimize(LogicalPlan verified) {\n \n         return Arrays.asList(operators, label);\n     }\n+\n+\n+    private static class ReplaceWildcards extends OptimizerRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private static LikePattern toLikePattern(String s) {\n+            // pick a character that is guaranteed not to be in the string, because it isn't allowed to escape itself\n+            char escape = 1;\n+\n+            // replace wildcards with % and escape special characters\n+            String likeString = s.replace(\"%\", escape + \"%\")\n+                .replace(\"_\", escape + \"_\")\n+                .replace(\"*\", \"%\");\n+\n+            return new LikePattern(likeString, escape);\n+        }\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                // expr == \"wildcard*phrase\"\n+                if (e instanceof Equals) {\n+                    Equals eq = (Equals) e;\n+\n+                    if (isWildcard(eq.right())) {\n+                        String wcString = (String) eq.right().fold();\n+                        e = new Like(e.source(), eq.left(), toLikePattern(wcString));\n+                    }\n+                }\n+\n+                // expr != \"wildcard*phrase\"\n+                else if (e instanceof NotEquals) {\n+                    NotEquals eq = (NotEquals) e;\n+\n+                    if (isWildcard(eq.right())) {\n+                        String wcString = (String) eq.right().fold();\n+                        Like inner = new Like(eq.source(), eq.left(), toLikePattern(wcString));\n+                        e = new Not(e.source(), inner);\n+                    }\n+                }\n+                return e;\n+            });\n+        }\n+    }\n+\n+    private static class ReplaceNullChecks extends OptimizerRule<Filter> {\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+\n+            return filter.transformExpressionsUp(e -> {\n+                // expr == \"wildcard*phrase\"\n+                if (e instanceof Equals) {\n+                    Equals eq = (Equals) e;\n+                    if (Expressions.isNull(eq.right())) {\n+                        return new IsNull(e.source(), eq.left());\n+                    }\n+                }\n+\n+                // expr != \"wildcard*phrase\"", "originalCommit": "5bf18c8b49e4ad5c2de52fedfe1d4889cf581560", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczOTU5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52791#discussion_r384739593", "bodyText": "It's uncommon to inline a constant declaration within a for loop mainly because an increase in the number of arguments makes it impractical.\nTypically, declaring a method with varags and then passing the arguments inside its invocation or declaring the list/array in a variable is the way to go. (Arrays.asList is used a lot, potentially with a static imports - there's also List.of but that is not available in Java 8, used by ES 7.x).", "author": "costin", "createdAt": "2020-02-26T20:14:47Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/optimizer/OptimizerTests.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.optimizer;\n+\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.eql.analysis.Analyzer;\n+import org.elasticsearch.xpack.eql.analysis.PreAnalyzer;\n+import org.elasticsearch.xpack.eql.analysis.Verifier;\n+import org.elasticsearch.xpack.eql.expression.function.EqlFunctionRegistry;\n+import org.elasticsearch.xpack.eql.parser.EqlParser;\n+import org.elasticsearch.xpack.ql.expression.FieldAttribute;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.And;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Not;\n+import org.elasticsearch.xpack.ql.expression.predicate.nulls.IsNotNull;\n+import org.elasticsearch.xpack.ql.expression.predicate.nulls.IsNull;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.index.EsIndex;\n+import org.elasticsearch.xpack.ql.index.IndexResolution;\n+import org.elasticsearch.xpack.ql.plan.logical.Filter;\n+import org.elasticsearch.xpack.ql.plan.logical.LogicalPlan;\n+import org.elasticsearch.xpack.ql.type.EsField;\n+import org.elasticsearch.xpack.ql.type.TypesTests;\n+\n+import java.util.Map;\n+\n+public class OptimizerTests extends ESTestCase {\n+\n+\n+    private static final String INDEX_NAME = \"test\";\n+    private EqlParser parser = new EqlParser();\n+    private IndexResolution index = loadIndexResolution(\"mapping-default.json\");\n+\n+    private static Map<String, EsField> loadEqlMapping(String name) {\n+        return TypesTests.loadMapping(name);\n+    }\n+\n+    private IndexResolution loadIndexResolution(String name) {\n+        return IndexResolution.valid(new EsIndex(INDEX_NAME, loadEqlMapping(name)));\n+    }\n+\n+    private LogicalPlan accept(IndexResolution resolution, String eql) {\n+        PreAnalyzer preAnalyzer = new PreAnalyzer();\n+        Analyzer analyzer = new Analyzer(new EqlFunctionRegistry(), new Verifier());\n+        Optimizer optimizer = new Optimizer();\n+        return optimizer.optimize(analyzer.analyze(preAnalyzer.preAnalyze(parser.createStatement(eql), resolution)));\n+    }\n+\n+    private LogicalPlan accept(String eql) {\n+        return accept(index, eql);\n+    }\n+    \n+    public void testIsNull() {\n+        for (String q : new String[]{\"foo where command_line == null\", \"foo where null == command_line\"}) {", "originalCommit": "5bf18c8b49e4ad5c2de52fedfe1d4889cf581560", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczOTgxNw==", "url": "https://github.com/elastic/elasticsearch/pull/52791#discussion_r384739817", "bodyText": "\ud83d\udc4d", "author": "costin", "createdAt": "2020-02-26T20:15:17Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/optimizer/OptimizerTests.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.optimizer;\n+\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.eql.analysis.Analyzer;\n+import org.elasticsearch.xpack.eql.analysis.PreAnalyzer;\n+import org.elasticsearch.xpack.eql.analysis.Verifier;\n+import org.elasticsearch.xpack.eql.expression.function.EqlFunctionRegistry;\n+import org.elasticsearch.xpack.eql.parser.EqlParser;\n+import org.elasticsearch.xpack.ql.expression.FieldAttribute;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.And;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Not;\n+import org.elasticsearch.xpack.ql.expression.predicate.nulls.IsNotNull;\n+import org.elasticsearch.xpack.ql.expression.predicate.nulls.IsNull;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.index.EsIndex;\n+import org.elasticsearch.xpack.ql.index.IndexResolution;\n+import org.elasticsearch.xpack.ql.plan.logical.Filter;\n+import org.elasticsearch.xpack.ql.plan.logical.LogicalPlan;\n+import org.elasticsearch.xpack.ql.type.EsField;\n+import org.elasticsearch.xpack.ql.type.TypesTests;\n+\n+import java.util.Map;\n+\n+public class OptimizerTests extends ESTestCase {", "originalCommit": "5bf18c8b49e4ad5c2de52fedfe1d4889cf581560", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4c55e5f41dad57b484220f64fd60918ee4aad5d4", "url": "https://github.com/elastic/elasticsearch/commit/4c55e5f41dad57b484220f64fd60918ee4aad5d4", "message": "EQL: Add IsNull/IsNotNull checks", "committedDate": "2020-03-06T20:24:06Z", "type": "commit"}, {"oid": "00097cccc8a45acee0a40c4c83642f5de414ab21", "url": "https://github.com/elastic/elasticsearch/commit/00097cccc8a45acee0a40c4c83642f5de414ab21", "message": "EQL: Simplify IsNull/IsNotNull optimization", "committedDate": "2020-03-06T20:32:23Z", "type": "commit"}, {"oid": "00097cccc8a45acee0a40c4c83642f5de414ab21", "url": "https://github.com/elastic/elasticsearch/commit/00097cccc8a45acee0a40c4c83642f5de414ab21", "message": "EQL: Simplify IsNull/IsNotNull optimization", "committedDate": "2020-03-06T20:32:23Z", "type": "forcePushed"}, {"oid": "a24e19e2caaa6125b89b40c273540c9764f80c66", "url": "https://github.com/elastic/elasticsearch/commit/a24e19e2caaa6125b89b40c273540c9764f80c66", "message": "EQL: Split string tests over multiple lines", "committedDate": "2020-03-06T20:42:27Z", "type": "commit"}]}