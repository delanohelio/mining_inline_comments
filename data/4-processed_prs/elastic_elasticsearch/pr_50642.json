{"pr_number": 50642, "pr_title": "Add async dangling indices support", "pr_createdAt": "2020-01-06T09:20:34Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/50642", "timeline": [{"oid": "7d9e1d42832fc07b87d736b107a7029d5ac6d528", "url": "https://github.com/elastic/elasticsearch/commit/7d9e1d42832fc07b87d736b107a7029d5ac6d528", "message": "Add async dangling indices support", "committedDate": "2020-01-06T08:55:36Z", "type": "commit"}, {"oid": "e36f297362275eb8125dc19cffb30a044094a6e3", "url": "https://github.com/elastic/elasticsearch/commit/e36f297362275eb8125dc19cffb30a044094a6e3", "message": "Merge branch 'reduce-metadata-writes-master' into dangling-indices-v2", "committedDate": "2020-01-07T14:56:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3OTI0NA==", "url": "https://github.com/elastic/elasticsearch/pull/50642#discussion_r364179244", "bodyText": "Doing this before calling indexService.writeDanglingIndicesInfo() means that allPendingDanglingIndicesWritten() may return true while there's still a write in progress.", "author": "DaveCTurner", "createdAt": "2020-01-08T11:10:53Z", "path": "server/src/main/java/org/elasticsearch/indices/IndicesService.java", "diffHunk": "@@ -1487,4 +1529,48 @@ private void setIdFieldDataEnabled(boolean value) {\n         }\n         return Optional.empty();\n     }\n+\n+    private void updateDanglingIndicesInfo(Index index) {\n+        assert DiscoveryNode.isDataNode(settings) : \"dangling indices information should only be persisted on data nodes\";\n+        if (danglingIndicesToWrite.add(index)) {\n+            logger.trace(\"triggered dangling indices update for {}\", index);\n+            final long triggeredTimeMillis = threadPool.relativeTimeInMillis();\n+            try {\n+                danglingIndicesThreadPoolExecutor.execute(new AbstractRunnable() {\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        logger.info(() -> new ParameterizedMessage(\"failed to write dangling indices state for index {}\", index), e);\n+                    }\n+\n+                    @Override\n+                    protected void doRun() {\n+                        final boolean exists = danglingIndicesToWrite.remove(index);", "originalCommit": "7d9e1d42832fc07b87d736b107a7029d5ac6d528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIxNjM0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/50642#discussion_r364216347", "bodyText": "good catch. In an earlier iteration, I had allPendingDanglingIndicesWritten checking the executor as well, but I somehow thought this was unneeded later. I've reinstated the check in 3a7b656", "author": "ywelsch", "createdAt": "2020-01-08T12:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3OTI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE4MDY0NA==", "url": "https://github.com/elastic/elasticsearch/pull/50642#discussion_r364180644", "bodyText": "If gateway.write_dangling_indices_info is false I think we should avoid creating a thread here.", "author": "DaveCTurner", "createdAt": "2020-01-08T11:15:01Z", "path": "server/src/main/java/org/elasticsearch/indices/IndicesService.java", "diffHunk": "@@ -289,12 +306,25 @@ protected void closeInternal() {\n                 }\n             }\n         };\n+\n+        final String nodeName = Objects.requireNonNull(Node.NODE_NAME_SETTING.get(settings));\n+        danglingIndicesThreadPoolExecutor = EsExecutors.newScaling(\n+            nodeName + \"/\" + DANGLING_INDICES_UPDATE_THREAD_NAME,\n+            1, 1,", "originalCommit": "7d9e1d42832fc07b87d736b107a7029d5ac6d528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIxNjQ0MA==", "url": "https://github.com/elastic/elasticsearch/pull/50642#discussion_r364216440", "bodyText": "\ud83d\udc4d done in 3a7b656", "author": "ywelsch", "createdAt": "2020-01-08T12:55:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE4MDY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE5MTIyMA==", "url": "https://github.com/elastic/elasticsearch/pull/50642#discussion_r364191220", "bodyText": "Nice catch. Maybe call unreferenceAll() here instead?", "author": "DaveCTurner", "createdAt": "2020-01-08T11:43:23Z", "path": "server/src/main/java/org/elasticsearch/gateway/MetaStateService.java", "diffHunk": "@@ -264,15 +264,28 @@ public void cleanupIndex(Index index, long currentGeneration) {\n         INDEX_META_DATA_FORMAT.cleanupOldFiles(currentGeneration, nodeEnv.indexPaths(index));\n     }\n \n+    /**\n+     * Creates empty cluster state file on disk, deleting global metadata and unreferencing all index metadata\n+     * (only used for dangling indices at that point).\n+     */\n+    public void unreferenceAll() throws IOException {\n+        MANIFEST_FORMAT.writeAndCleanup(Manifest.empty(), nodeEnv.nodeDataPaths()); // write empty file so that indices become unreferenced\n+        META_DATA_FORMAT.cleanupOldFiles(Long.MAX_VALUE, nodeEnv.nodeDataPaths());\n+    }\n+\n     /**\n      * Removes manifest file, global metadata and all index metadata\n      */\n     public void deleteAll() throws IOException {\n-        MANIFEST_FORMAT.cleanupOldFiles(Long.MAX_VALUE, nodeEnv.nodeDataPaths());\n+        // To ensure that the metadata is never reimported by loadFullStateBWC in case where the deletions here fail mid-way through,\n+        // we first write an empty manifest file so that the indices become unreferenced, then clean up the indices, and only then delete\n+        // the manifest file.\n+        MANIFEST_FORMAT.writeAndCleanup(Manifest.empty(), nodeEnv.nodeDataPaths());", "originalCommit": "7d9e1d42832fc07b87d736b107a7029d5ac6d528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIxNjQ2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/50642#discussion_r364216469", "bodyText": "ok, done in 3a7b656", "author": "ywelsch", "createdAt": "2020-01-08T12:55:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE5MTIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE5MjEwMw==", "url": "https://github.com/elastic/elasticsearch/pull/50642#discussion_r364192103", "bodyText": "I think a failure here indicates a bad enough problem to warrant a WARN-level log.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(() -> new ParameterizedMessage(\"failed to write dangling indices state for index {}\", index()), e);\n          \n          \n            \n                        logger.warn(() -> new ParameterizedMessage(\"failed to write dangling indices state for index {}\", index()), e);", "author": "DaveCTurner", "createdAt": "2020-01-08T11:45:44Z", "path": "server/src/main/java/org/elasticsearch/index/IndexService.java", "diffHunk": "@@ -324,6 +327,29 @@ public synchronized void close(final String reason, boolean delete) throws IOExc\n         }\n     }\n \n+    // method is synchronized so that IndexService can't be closed while we're writing out dangling indices information\n+    public synchronized void writeDanglingIndicesInfo() {\n+        if (closed.get()) {\n+            return;\n+        }\n+        try {\n+            IndexMetaData.FORMAT.writeAndCleanup(getMetaData(), nodeEnv.indexPaths(index()));\n+        } catch (WriteStateException e) {\n+            logger.info(() -> new ParameterizedMessage(\"failed to write dangling indices state for index {}\", index()), e);", "originalCommit": "7d9e1d42832fc07b87d736b107a7029d5ac6d528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIxNjU3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/50642#discussion_r364216571", "bodyText": "3a7b656", "author": "ywelsch", "createdAt": "2020-01-08T12:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE5MjEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE5MjE2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/50642#discussion_r364192167", "bodyText": "I think a failure here indicates a bad enough problem to warrant a WARN-level log.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(() -> new ParameterizedMessage(\"failed to delete dangling indices state for index {}\", index()), e);\n          \n          \n            \n                        logger.warn(() -> new ParameterizedMessage(\"failed to delete dangling indices state for index {}\", index()), e);", "author": "DaveCTurner", "createdAt": "2020-01-08T11:45:54Z", "path": "server/src/main/java/org/elasticsearch/index/IndexService.java", "diffHunk": "@@ -324,6 +327,29 @@ public synchronized void close(final String reason, boolean delete) throws IOExc\n         }\n     }\n \n+    // method is synchronized so that IndexService can't be closed while we're writing out dangling indices information\n+    public synchronized void writeDanglingIndicesInfo() {\n+        if (closed.get()) {\n+            return;\n+        }\n+        try {\n+            IndexMetaData.FORMAT.writeAndCleanup(getMetaData(), nodeEnv.indexPaths(index()));\n+        } catch (WriteStateException e) {\n+            logger.info(() -> new ParameterizedMessage(\"failed to write dangling indices state for index {}\", index()), e);\n+        }\n+    }\n+\n+    // method is synchronized so that IndexService can't be closed while we're deleting dangling indices information\n+    public synchronized void deleteDanglingIndicesInfo() {\n+        if (closed.get()) {\n+            return;\n+        }\n+        try {\n+            MetaDataStateFormat.deleteMetaState(nodeEnv.indexPaths(index()));\n+        } catch (IOException e) {\n+            logger.info(() -> new ParameterizedMessage(\"failed to delete dangling indices state for index {}\", index()), e);", "originalCommit": "7d9e1d42832fc07b87d736b107a7029d5ac6d528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIxNjYxNA==", "url": "https://github.com/elastic/elasticsearch/pull/50642#discussion_r364216614", "bodyText": "3a7b656", "author": "ywelsch", "createdAt": "2020-01-08T12:56:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE5MjE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE5MzA0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/50642#discussion_r364193042", "bodyText": "\ud83d\udc4d noting that if dangling indices functionality is disabled then we delete the metadata as the indices are allocated, so if any indices are genuinely dangling at this point then we keep their metadata around.", "author": "DaveCTurner", "createdAt": "2020-01-08T11:48:28Z", "path": "server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java", "diffHunk": "@@ -109,7 +109,11 @@ public void start(Settings settings, TransportService transportService, ClusterS\n                             .build());\n                     lucenePersistedState = new LucenePersistedState(\n                         persistenceWriter, currentTerm, clusterState);\n-                    metaStateService.deleteAll(); // delete legacy files\n+                    if (DiscoveryNode.isDataNode(settings)) {\n+                        metaStateService.unreferenceAll(); // unreference legacy files (only keep them for dangling indices functionality)", "originalCommit": "7d9e1d42832fc07b87d736b107a7029d5ac6d528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIxNjc4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/50642#discussion_r364216781", "bodyText": "yup.", "author": "ywelsch", "createdAt": "2020-01-08T12:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE5MzA0Mg=="}], "type": "inlineReview"}, {"oid": "3a7b656f5ce344c3ee413a5a933d4f8fed34cf9a", "url": "https://github.com/elastic/elasticsearch/commit/3a7b656f5ce344c3ee413a5a933d4f8fed34cf9a", "message": "review feedback", "committedDate": "2020-01-08T12:54:03Z", "type": "commit"}]}