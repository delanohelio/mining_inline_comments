{"pr_number": 51821, "pr_title": "[DOCS] Add EQL syntax page", "pr_createdAt": "2020-02-03T17:04:20Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51821", "timeline": [{"oid": "8dbb2539d80eae7590190af2aecdd5e4520e46ca", "url": "https://github.com/elastic/elasticsearch/commit/8dbb2539d80eae7590190af2aecdd5e4520e46ca", "message": "[DOCS] Add EQL syntax page", "committedDate": "2020-02-03T16:57:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI4MjAyNg==", "url": "https://github.com/elastic/elasticsearch/pull/51821#discussion_r374282026", "bodyText": "not sure if this was intentional for the sake of simplicity, but if we do want to make these examples more ECS-compliant:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            process where name == \"svchost.exe\"\n          \n          \n            \n            process where process.name == \"svchost.exe\"", "author": "rw-access", "createdAt": "2020-02-03T19:02:24Z", "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -0,0 +1,224 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-syntax]]\n+== EQL syntax reference\n+\n+experimental::[]\n+\n+[IMPORTANT]\n+====\n+{es} supports a subset of EQL syntax.\n+====\n+\n+[discrete]\n+[[eql-basic-syntax]]\n+=== Basic syntax\n+\n+EQL queries require an event type and a matching condition. The `where` keyword connects them.\n+\n+[source,eql]\n+----\n+event_type where condition\n+----\n+\n+For example, the following EQL query matches `process` events with a `name`\n+field value of `svchost.exe`:\n+\n+[source,eql]\n+----\n+process where name == \"svchost.exe\"", "originalCommit": "8dbb2539d80eae7590190af2aecdd5e4520e46ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI4Mjc0MA==", "url": "https://github.com/elastic/elasticsearch/pull/51821#discussion_r374282740", "bodyText": "I don't know how the documents render and if this matters, but there's an extra space\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Divides the value to the left of the operator by the value to the right. Returns  only the remainder.\n          \n          \n            \n            Divides the value to the left of the operator by the value to the right. Returns only the remainder.", "author": "rw-access", "createdAt": "2020-02-03T19:03:55Z", "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -0,0 +1,224 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-syntax]]\n+== EQL syntax reference\n+\n+experimental::[]\n+\n+[IMPORTANT]\n+====\n+{es} supports a subset of EQL syntax.\n+====\n+\n+[discrete]\n+[[eql-basic-syntax]]\n+=== Basic syntax\n+\n+EQL queries require an event type and a matching condition. The `where` keyword connects them.\n+\n+[source,eql]\n+----\n+event_type where condition\n+----\n+\n+For example, the following EQL query matches `process` events with a `name`\n+field value of `svchost.exe`:\n+\n+[source,eql]\n+----\n+process where name == \"svchost.exe\"\n+----\n+\n+[discrete]\n+[[eql-syntax-conditions]]\n+==== Conditions\n+\n+A condition consists of one or more criteria an event must match.\n+You can specify and combine these criteria using the following operators:\n+\n+[discrete]\n+[[eql-syntax-comparison-operators]]\n+===== Comparison operators\n+\n+[source,eql]\n+----\n+<   <=   ==   !=   >=   >\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`<` (less than)::\n+Returns `true` if the value to the left of the operator is less than the value\n+to the right. Otherwise returns `false`.\n+\n+`<=` (less than or equal) ::\n+Returns `true` if the value to the left of the operator is less than or equal to\n+the value to the right. Otherwise returns `false`.\n+\n+`==` (equal)::\n+Returns `true` if the values to the left and right of the operator are equal.\n+Otherwise returns `false`.\n+\n+`!=` (not equal)::\n+Returns `true` if the values to the left and right of the operator are not\n+equal. Otherwise returns `false`.\n+\n+`>=` (greater than or equal) ::\n+Returns `true` if the value to the left of the operator is greater than or equal\n+to the value to the right. Otherwise returns `false`.\n+\n+`>` (greater than)::\n+Returns `true` if the value to the left of the operator is greater than the\n+value to the right. Otherwise returns `false`.\n+====\n+\n+[discrete]\n+[[eql-syntax-logical-operators]]\n+===== Logical operators\n+\n+[source,eql]\n+----\n+and  or  not\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`and`::\n+Returns `true` only if the condition to the left and right _both_ return `true`.\n+Otherwise returns `false.\n+\n+`or`::\n+Returns `true` if one of the conditions to the left or right `true`.\n+Otherwise returns `false.\n+\n+`not`::\n+Returns `true` if the condition to the right is `false`.\n+====\n+\n+[discrete]\n+[[eql-syntax-lookup-operators]]\n+===== Lookup operators\n+\n+[source,eql]\n+----\n+user.name in (\"Administrator\", \"SYSTEM\", \"NETWORK SERVICE\")\n+user.name not in (\"Administrator\", \"SYSTEM\", \"NETWORK SERVICE\")\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`in`::\n+Returns `true` if the value is contained in the provided list.\n+\n+`not in`::\n+Returns `true` if the value is not contained in the provided list.\n+====\n+\n+[discrete]\n+[[eql-syntax-math-operators]]\n+===== Math operators\n+\n+[source,eql]\n+----\n++  -  *  /  %\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`+` (add)::\n+Adds the values to the left and right of the operator.\n+\n+`-` (Subtract)::\n+Subtracts the value to the right of the operator from the value to the left.\n+\n+`*` (Subtract)::\n+Multiplies the values to the left and right of the operator.\n+\n+`/` (Divide)::\n+Divides the value to the left of the operator by the value to the right.\n+\n+`%` (modulo)::\n+Divides the value to the left of the operator by the value to the right. Returns  only the remainder.", "originalCommit": "8dbb2539d80eae7590190af2aecdd5e4520e46ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMwMzc0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51821#discussion_r374303745", "bodyText": "That would render. Thanks for catching this.", "author": "jrodewig", "createdAt": "2020-02-03T19:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI4Mjc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI4NDQ5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51821#discussion_r374284499", "bodyText": "This isn't currently escaped. I think these make sense, but we may have to come back later to add it.", "author": "rw-access", "createdAt": "2020-02-03T19:07:31Z", "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -0,0 +1,224 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-syntax]]\n+== EQL syntax reference\n+\n+experimental::[]\n+\n+[IMPORTANT]\n+====\n+{es} supports a subset of EQL syntax.\n+====\n+\n+[discrete]\n+[[eql-basic-syntax]]\n+=== Basic syntax\n+\n+EQL queries require an event type and a matching condition. The `where` keyword connects them.\n+\n+[source,eql]\n+----\n+event_type where condition\n+----\n+\n+For example, the following EQL query matches `process` events with a `name`\n+field value of `svchost.exe`:\n+\n+[source,eql]\n+----\n+process where name == \"svchost.exe\"\n+----\n+\n+[discrete]\n+[[eql-syntax-conditions]]\n+==== Conditions\n+\n+A condition consists of one or more criteria an event must match.\n+You can specify and combine these criteria using the following operators:\n+\n+[discrete]\n+[[eql-syntax-comparison-operators]]\n+===== Comparison operators\n+\n+[source,eql]\n+----\n+<   <=   ==   !=   >=   >\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`<` (less than)::\n+Returns `true` if the value to the left of the operator is less than the value\n+to the right. Otherwise returns `false`.\n+\n+`<=` (less than or equal) ::\n+Returns `true` if the value to the left of the operator is less than or equal to\n+the value to the right. Otherwise returns `false`.\n+\n+`==` (equal)::\n+Returns `true` if the values to the left and right of the operator are equal.\n+Otherwise returns `false`.\n+\n+`!=` (not equal)::\n+Returns `true` if the values to the left and right of the operator are not\n+equal. Otherwise returns `false`.\n+\n+`>=` (greater than or equal) ::\n+Returns `true` if the value to the left of the operator is greater than or equal\n+to the value to the right. Otherwise returns `false`.\n+\n+`>` (greater than)::\n+Returns `true` if the value to the left of the operator is greater than the\n+value to the right. Otherwise returns `false`.\n+====\n+\n+[discrete]\n+[[eql-syntax-logical-operators]]\n+===== Logical operators\n+\n+[source,eql]\n+----\n+and  or  not\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`and`::\n+Returns `true` only if the condition to the left and right _both_ return `true`.\n+Otherwise returns `false.\n+\n+`or`::\n+Returns `true` if one of the conditions to the left or right `true`.\n+Otherwise returns `false.\n+\n+`not`::\n+Returns `true` if the condition to the right is `false`.\n+====\n+\n+[discrete]\n+[[eql-syntax-lookup-operators]]\n+===== Lookup operators\n+\n+[source,eql]\n+----\n+user.name in (\"Administrator\", \"SYSTEM\", \"NETWORK SERVICE\")\n+user.name not in (\"Administrator\", \"SYSTEM\", \"NETWORK SERVICE\")\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`in`::\n+Returns `true` if the value is contained in the provided list.\n+\n+`not in`::\n+Returns `true` if the value is not contained in the provided list.\n+====\n+\n+[discrete]\n+[[eql-syntax-math-operators]]\n+===== Math operators\n+\n+[source,eql]\n+----\n++  -  *  /  %\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`+` (add)::\n+Adds the values to the left and right of the operator.\n+\n+`-` (Subtract)::\n+Subtracts the value to the right of the operator from the value to the left.\n+\n+`*` (Subtract)::\n+Multiplies the values to the left and right of the operator.\n+\n+`/` (Divide)::\n+Divides the value to the left of the operator by the value to the right.\n+\n+`%` (modulo)::\n+Divides the value to the left of the operator by the value to the right. Returns  only the remainder.\n+====\n+\n+[discrete]\n+[[eql-syntax-strings]]\n+==== Strings\n+\n+Strings are enclosed with double quotes (`\"`) or single quotes (`'`).\n+\n+[source,eql]\n+----\n+\"hello world\"\n+\"hello world with 'substring'\"\n+----\n+\n+[discrete]\n+[[eql-syntax-wildcards]]\n+===== Wildcards \n+\n+You can use the wildcard operator (`*`) within a string to match specific\n+patterns.\n+\n+The following example string matches any value that ends with `.txt`.\n+\n+[source,eql]\n+----\n+\"*.txt\"\n+----\n+\n+[discrete]\n+[[eql-syntax-escaped-characters]]\n+===== Escaped characters \n+\n+When used within a string, special characters, such as a carriage return or\n+double quote (`\"`), must be escaped with a preceding `\\`.\n+\n+[source,eql]\n+----\n+\"example \\t of \\n escaped \\r characters\"\n+----\n+\n+.*Escape sequences*\n+[%collapsible]\n+====\n+[options=\"header\"]\n+|====\n+| Escape sequence | Literal character\n+|`\\n`             | A newline (linefeed) character\n+|`\\r`             | A carriage return character\n+|`\\t`             | A tab character\n+|`\\\\`             | A backslash (`\\`) character\n+|`\\\"`             | A double quote (`\"`) character\n+|`\\'`             | A single quote (`'`) character\n+|`\\*`             | A wildcard (`*`) character", "originalCommit": "8dbb2539d80eae7590190af2aecdd5e4520e46ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMwNTM4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51821#discussion_r374305386", "bodyText": "Removed for now with 2827c20.", "author": "jrodewig", "createdAt": "2020-02-03T19:50:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI4NDQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI4NTcwNw==", "url": "https://github.com/elastic/elasticsearch/pull/51821#discussion_r374285707", "bodyText": "Nothing is actually escaped for raw strings, so this is basically identical behavior to https://www.journaldev.com/23598/python-raw-string, but with ? instead of r.\n\nPython raw string is created by prefixing a string literal with \u2018r\u2019 or \u2018R\u2019. Python raw string treats backslash () as a literal character. This is useful when we want to have a string that contains backslash and don\u2019t want it to be treated as an escape character.\n...\nWhen a backslash is followed by a quote in a raw string, it\u2019s escaped. However, the backslash also remains in the result. Because of this feature, we can\u2019t create a raw string of single backslash. Also, a raw string can\u2019t have an odd number of backslashes at the end.", "author": "rw-access", "createdAt": "2020-02-03T19:09:58Z", "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -0,0 +1,224 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-syntax]]\n+== EQL syntax reference\n+\n+experimental::[]\n+\n+[IMPORTANT]\n+====\n+{es} supports a subset of EQL syntax.\n+====\n+\n+[discrete]\n+[[eql-basic-syntax]]\n+=== Basic syntax\n+\n+EQL queries require an event type and a matching condition. The `where` keyword connects them.\n+\n+[source,eql]\n+----\n+event_type where condition\n+----\n+\n+For example, the following EQL query matches `process` events with a `name`\n+field value of `svchost.exe`:\n+\n+[source,eql]\n+----\n+process where name == \"svchost.exe\"\n+----\n+\n+[discrete]\n+[[eql-syntax-conditions]]\n+==== Conditions\n+\n+A condition consists of one or more criteria an event must match.\n+You can specify and combine these criteria using the following operators:\n+\n+[discrete]\n+[[eql-syntax-comparison-operators]]\n+===== Comparison operators\n+\n+[source,eql]\n+----\n+<   <=   ==   !=   >=   >\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`<` (less than)::\n+Returns `true` if the value to the left of the operator is less than the value\n+to the right. Otherwise returns `false`.\n+\n+`<=` (less than or equal) ::\n+Returns `true` if the value to the left of the operator is less than or equal to\n+the value to the right. Otherwise returns `false`.\n+\n+`==` (equal)::\n+Returns `true` if the values to the left and right of the operator are equal.\n+Otherwise returns `false`.\n+\n+`!=` (not equal)::\n+Returns `true` if the values to the left and right of the operator are not\n+equal. Otherwise returns `false`.\n+\n+`>=` (greater than or equal) ::\n+Returns `true` if the value to the left of the operator is greater than or equal\n+to the value to the right. Otherwise returns `false`.\n+\n+`>` (greater than)::\n+Returns `true` if the value to the left of the operator is greater than the\n+value to the right. Otherwise returns `false`.\n+====\n+\n+[discrete]\n+[[eql-syntax-logical-operators]]\n+===== Logical operators\n+\n+[source,eql]\n+----\n+and  or  not\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`and`::\n+Returns `true` only if the condition to the left and right _both_ return `true`.\n+Otherwise returns `false.\n+\n+`or`::\n+Returns `true` if one of the conditions to the left or right `true`.\n+Otherwise returns `false.\n+\n+`not`::\n+Returns `true` if the condition to the right is `false`.\n+====\n+\n+[discrete]\n+[[eql-syntax-lookup-operators]]\n+===== Lookup operators\n+\n+[source,eql]\n+----\n+user.name in (\"Administrator\", \"SYSTEM\", \"NETWORK SERVICE\")\n+user.name not in (\"Administrator\", \"SYSTEM\", \"NETWORK SERVICE\")\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`in`::\n+Returns `true` if the value is contained in the provided list.\n+\n+`not in`::\n+Returns `true` if the value is not contained in the provided list.\n+====\n+\n+[discrete]\n+[[eql-syntax-math-operators]]\n+===== Math operators\n+\n+[source,eql]\n+----\n++  -  *  /  %\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`+` (add)::\n+Adds the values to the left and right of the operator.\n+\n+`-` (Subtract)::\n+Subtracts the value to the right of the operator from the value to the left.\n+\n+`*` (Subtract)::\n+Multiplies the values to the left and right of the operator.\n+\n+`/` (Divide)::\n+Divides the value to the left of the operator by the value to the right.\n+\n+`%` (modulo)::\n+Divides the value to the left of the operator by the value to the right. Returns  only the remainder.\n+====\n+\n+[discrete]\n+[[eql-syntax-strings]]\n+==== Strings\n+\n+Strings are enclosed with double quotes (`\"`) or single quotes (`'`).\n+\n+[source,eql]\n+----\n+\"hello world\"\n+\"hello world with 'substring'\"\n+----\n+\n+[discrete]\n+[[eql-syntax-wildcards]]\n+===== Wildcards \n+\n+You can use the wildcard operator (`*`) within a string to match specific\n+patterns.\n+\n+The following example string matches any value that ends with `.txt`.\n+\n+[source,eql]\n+----\n+\"*.txt\"\n+----\n+\n+[discrete]\n+[[eql-syntax-escaped-characters]]\n+===== Escaped characters \n+\n+When used within a string, special characters, such as a carriage return or\n+double quote (`\"`), must be escaped with a preceding `\\`.\n+\n+[source,eql]\n+----\n+\"example \\t of \\n escaped \\r characters\"\n+----\n+\n+.*Escape sequences*\n+[%collapsible]\n+====\n+[options=\"header\"]\n+|====\n+| Escape sequence | Literal character\n+|`\\n`             | A newline (linefeed) character\n+|`\\r`             | A carriage return character\n+|`\\t`             | A tab character\n+|`\\\\`             | A backslash (`\\`) character\n+|`\\\"`             | A double quote (`\"`) character\n+|`\\'`             | A single quote (`'`) character\n+|`\\*`             | A wildcard (`*`) character\n+|====\n+====\n+\n+[discrete]\n+[[eql-syntax-raw-strings]]\n+===== Raw strings\n+\n+Raw strings are preceded by a question mark (`?`), which escapes all special", "originalCommit": "8dbb2539d80eae7590190af2aecdd5e4520e46ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMyMjk0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51821#discussion_r374322946", "bodyText": "I clarified this a bit more with c529f73.", "author": "jrodewig", "createdAt": "2020-02-03T20:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI4NTcwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI4Njc3MA==", "url": "https://github.com/elastic/elasticsearch/pull/51821#discussion_r374286770", "bodyText": "You don't need backticks to do nested fields, but if you start doing special/non-alphanumeric + underscore characters. Feel free to choose your own examples, but here's what I mean:\n`start-time`\n`field.start-time`\n`field with space in it`", "author": "rw-access", "createdAt": "2020-02-03T19:12:11Z", "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -0,0 +1,224 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-syntax]]\n+== EQL syntax reference\n+\n+experimental::[]\n+\n+[IMPORTANT]\n+====\n+{es} supports a subset of EQL syntax.\n+====\n+\n+[discrete]\n+[[eql-basic-syntax]]\n+=== Basic syntax\n+\n+EQL queries require an event type and a matching condition. The `where` keyword connects them.\n+\n+[source,eql]\n+----\n+event_type where condition\n+----\n+\n+For example, the following EQL query matches `process` events with a `name`\n+field value of `svchost.exe`:\n+\n+[source,eql]\n+----\n+process where name == \"svchost.exe\"\n+----\n+\n+[discrete]\n+[[eql-syntax-conditions]]\n+==== Conditions\n+\n+A condition consists of one or more criteria an event must match.\n+You can specify and combine these criteria using the following operators:\n+\n+[discrete]\n+[[eql-syntax-comparison-operators]]\n+===== Comparison operators\n+\n+[source,eql]\n+----\n+<   <=   ==   !=   >=   >\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`<` (less than)::\n+Returns `true` if the value to the left of the operator is less than the value\n+to the right. Otherwise returns `false`.\n+\n+`<=` (less than or equal) ::\n+Returns `true` if the value to the left of the operator is less than or equal to\n+the value to the right. Otherwise returns `false`.\n+\n+`==` (equal)::\n+Returns `true` if the values to the left and right of the operator are equal.\n+Otherwise returns `false`.\n+\n+`!=` (not equal)::\n+Returns `true` if the values to the left and right of the operator are not\n+equal. Otherwise returns `false`.\n+\n+`>=` (greater than or equal) ::\n+Returns `true` if the value to the left of the operator is greater than or equal\n+to the value to the right. Otherwise returns `false`.\n+\n+`>` (greater than)::\n+Returns `true` if the value to the left of the operator is greater than the\n+value to the right. Otherwise returns `false`.\n+====\n+\n+[discrete]\n+[[eql-syntax-logical-operators]]\n+===== Logical operators\n+\n+[source,eql]\n+----\n+and  or  not\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`and`::\n+Returns `true` only if the condition to the left and right _both_ return `true`.\n+Otherwise returns `false.\n+\n+`or`::\n+Returns `true` if one of the conditions to the left or right `true`.\n+Otherwise returns `false.\n+\n+`not`::\n+Returns `true` if the condition to the right is `false`.\n+====\n+\n+[discrete]\n+[[eql-syntax-lookup-operators]]\n+===== Lookup operators\n+\n+[source,eql]\n+----\n+user.name in (\"Administrator\", \"SYSTEM\", \"NETWORK SERVICE\")\n+user.name not in (\"Administrator\", \"SYSTEM\", \"NETWORK SERVICE\")\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`in`::\n+Returns `true` if the value is contained in the provided list.\n+\n+`not in`::\n+Returns `true` if the value is not contained in the provided list.\n+====\n+\n+[discrete]\n+[[eql-syntax-math-operators]]\n+===== Math operators\n+\n+[source,eql]\n+----\n++  -  *  /  %\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`+` (add)::\n+Adds the values to the left and right of the operator.\n+\n+`-` (Subtract)::\n+Subtracts the value to the right of the operator from the value to the left.\n+\n+`*` (Subtract)::\n+Multiplies the values to the left and right of the operator.\n+\n+`/` (Divide)::\n+Divides the value to the left of the operator by the value to the right.\n+\n+`%` (modulo)::\n+Divides the value to the left of the operator by the value to the right. Returns  only the remainder.\n+====\n+\n+[discrete]\n+[[eql-syntax-strings]]\n+==== Strings\n+\n+Strings are enclosed with double quotes (`\"`) or single quotes (`'`).\n+\n+[source,eql]\n+----\n+\"hello world\"\n+\"hello world with 'substring'\"\n+----\n+\n+[discrete]\n+[[eql-syntax-wildcards]]\n+===== Wildcards \n+\n+You can use the wildcard operator (`*`) within a string to match specific\n+patterns.\n+\n+The following example string matches any value that ends with `.txt`.\n+\n+[source,eql]\n+----\n+\"*.txt\"\n+----\n+\n+[discrete]\n+[[eql-syntax-escaped-characters]]\n+===== Escaped characters \n+\n+When used within a string, special characters, such as a carriage return or\n+double quote (`\"`), must be escaped with a preceding `\\`.\n+\n+[source,eql]\n+----\n+\"example \\t of \\n escaped \\r characters\"\n+----\n+\n+.*Escape sequences*\n+[%collapsible]\n+====\n+[options=\"header\"]\n+|====\n+| Escape sequence | Literal character\n+|`\\n`             | A newline (linefeed) character\n+|`\\r`             | A carriage return character\n+|`\\t`             | A tab character\n+|`\\\\`             | A backslash (`\\`) character\n+|`\\\"`             | A double quote (`\"`) character\n+|`\\'`             | A single quote (`'`) character\n+|`\\*`             | A wildcard (`*`) character\n+|====\n+====\n+\n+[discrete]\n+[[eql-syntax-raw-strings]]\n+===== Raw strings\n+\n+Raw strings are preceded by a question mark (`?`), which escapes all special\n+characters in the string except single quote (`'`) and double quote (`\"`).\n+\n+[source,eql]\n+----\n+?\"String with literal 'slash' \\ characters included\"\n+----\n+\n+[discrete]\n+[[eql-syntax-nested-fields]]\n+==== Nested fields\n+\n+When using dot notation to specify nested object fields, the field name and path\n+are escaped using backticks (+++`+++).", "originalCommit": "8dbb2539d80eae7590190af2aecdd5e4520e46ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMwODMwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/51821#discussion_r374308301", "bodyText": "Thanks for the correction. I've updated this section with e76900e.", "author": "jrodewig", "createdAt": "2020-02-03T19:55:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI4Njc3MA=="}], "type": "inlineReview"}, {"oid": "eae9c10cc5de12e0822ab837af08bcad2cd50fda", "url": "https://github.com/elastic/elasticsearch/commit/eae9c10cc5de12e0822ab837af08bcad2cd50fda", "message": "Update docs/reference/eql/syntax.asciidoc\n\nCo-Authored-By: Ross Wolf <31489089+rw-access@users.noreply.github.com>", "committedDate": "2020-02-03T19:46:17Z", "type": "commit"}, {"oid": "93ddab1982836201384477c1ca091086d7f701e5", "url": "https://github.com/elastic/elasticsearch/commit/93ddab1982836201384477c1ca091086d7f701e5", "message": "Update docs/reference/eql/syntax.asciidoc\n\nCo-Authored-By: Ross Wolf <31489089+rw-access@users.noreply.github.com>", "committedDate": "2020-02-03T19:46:42Z", "type": "commit"}, {"oid": "2827c20aed32602c0182b49cdb32c5fc91aa8862", "url": "https://github.com/elastic/elasticsearch/commit/2827c20aed32602c0182b49cdb32c5fc91aa8862", "message": "Remove escaped wildcard", "committedDate": "2020-02-03T19:49:19Z", "type": "commit"}, {"oid": "e76900ea8e9ab736b1821786424d891efd6ff1cf", "url": "https://github.com/elastic/elasticsearch/commit/e76900ea8e9ab736b1821786424d891efd6ff1cf", "message": "Field name correction", "committedDate": "2020-02-03T19:55:35Z", "type": "commit"}, {"oid": "c529f73ff08d43c1a07b1361072b5de4c41944dc", "url": "https://github.com/elastic/elasticsearch/commit/c529f73ff08d43c1a07b1361072b5de4c41944dc", "message": "Correct raw string section", "committedDate": "2020-02-03T20:26:03Z", "type": "commit"}, {"oid": "8097b414be6f45b54b35191ef799d380037581ce", "url": "https://github.com/elastic/elasticsearch/commit/8097b414be6f45b54b35191ef799d380037581ce", "message": "fix anchor", "committedDate": "2020-02-03T20:39:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM1OTU5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51821#discussion_r374359593", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For example, the following EQL query matches `process` events with a `name`\n          \n          \n            \n            For example, the following EQL query matches `process` events with a `process.name`", "author": "rw-access", "createdAt": "2020-02-03T21:47:11Z", "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -0,0 +1,240 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-syntax]]\n+== EQL syntax reference\n+\n+experimental::[]\n+\n+[IMPORTANT]\n+====\n+{es} supports a subset of EQL syntax.\n+====\n+\n+[discrete]\n+[[eql-basic-syntax]]\n+=== Basic syntax\n+\n+EQL queries require an event type and a matching condition. The `where` keyword connects them.\n+\n+[source,eql]\n+----\n+event_type where condition\n+----\n+\n+For example, the following EQL query matches `process` events with a `name`", "originalCommit": "8097b414be6f45b54b35191ef799d380037581ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3a1021c6a3198384a19bedcf0f11e50d1c3d1ec7", "url": "https://github.com/elastic/elasticsearch/commit/3a1021c6a3198384a19bedcf0f11e50d1c3d1ec7", "message": "Update docs/reference/eql/syntax.asciidoc\n\nCo-Authored-By: Ross Wolf <31489089+rw-access@users.noreply.github.com>", "committedDate": "2020-02-03T21:47:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM2MjIxNw==", "url": "https://github.com/elastic/elasticsearch/pull/51821#discussion_r374362217", "bodyText": "I think this could use an example of how it's used. Wildcards are interpreted if they are used with== or !=:\nfield == \"example*wildcard\"\nfield != \"example*wildcard\"", "author": "rw-access", "createdAt": "2020-02-03T21:53:06Z", "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -0,0 +1,240 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-syntax]]\n+== EQL syntax reference\n+\n+experimental::[]\n+\n+[IMPORTANT]\n+====\n+{es} supports a subset of EQL syntax.\n+====\n+\n+[discrete]\n+[[eql-basic-syntax]]\n+=== Basic syntax\n+\n+EQL queries require an event type and a matching condition. The `where` keyword connects them.\n+\n+[source,eql]\n+----\n+event_type where condition\n+----\n+\n+For example, the following EQL query matches `process` events with a `process.name`\n+field value of `svchost.exe`:\n+\n+[source,eql]\n+----\n+process where process.name == \"svchost.exe\"\n+----\n+\n+[discrete]\n+[[eql-syntax-conditions]]\n+==== Conditions\n+\n+A condition consists of one or more criteria an event must match.\n+You can specify and combine these criteria using the following operators:\n+\n+[discrete]\n+[[eql-syntax-comparison-operators]]\n+===== Comparison operators\n+\n+[source,eql]\n+----\n+<   <=   ==   !=   >=   >\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`<` (less than)::\n+Returns `true` if the value to the left of the operator is less than the value\n+to the right. Otherwise returns `false`.\n+\n+`<=` (less than or equal) ::\n+Returns `true` if the value to the left of the operator is less than or equal to\n+the value to the right. Otherwise returns `false`.\n+\n+`==` (equal)::\n+Returns `true` if the values to the left and right of the operator are equal.\n+Otherwise returns `false`.\n+\n+`!=` (not equal)::\n+Returns `true` if the values to the left and right of the operator are not\n+equal. Otherwise returns `false`.\n+\n+`>=` (greater than or equal) ::\n+Returns `true` if the value to the left of the operator is greater than or equal\n+to the value to the right. Otherwise returns `false`.\n+\n+`>` (greater than)::\n+Returns `true` if the value to the left of the operator is greater than the\n+value to the right. Otherwise returns `false`.\n+====\n+\n+[discrete]\n+[[eql-syntax-logical-operators]]\n+===== Logical operators\n+\n+[source,eql]\n+----\n+and  or  not\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`and`::\n+Returns `true` only if the condition to the left and right _both_ return `true`.\n+Otherwise returns `false.\n+\n+`or`::\n+Returns `true` if one of the conditions to the left or right `true`.\n+Otherwise returns `false.\n+\n+`not`::\n+Returns `true` if the condition to the right is `false`.\n+====\n+\n+[discrete]\n+[[eql-syntax-lookup-operators]]\n+===== Lookup operators\n+\n+[source,eql]\n+----\n+user.name in (\"Administrator\", \"SYSTEM\", \"NETWORK SERVICE\")\n+user.name not in (\"Administrator\", \"SYSTEM\", \"NETWORK SERVICE\")\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`in`::\n+Returns `true` if the value is contained in the provided list.\n+\n+`not in`::\n+Returns `true` if the value is not contained in the provided list.\n+====\n+\n+[discrete]\n+[[eql-syntax-math-operators]]\n+===== Math operators\n+\n+[source,eql]\n+----\n++  -  *  /  %\n+----\n+\n+.*Definitions*\n+[%collapsible]\n+====\n+`+` (add)::\n+Adds the values to the left and right of the operator.\n+\n+`-` (Subtract)::\n+Subtracts the value to the right of the operator from the value to the left.\n+\n+`*` (Subtract)::\n+Multiplies the values to the left and right of the operator.\n+\n+`/` (Divide)::\n+Divides the value to the left of the operator by the value to the right.\n+\n+`%` (modulo)::\n+Divides the value to the left of the operator by the value to the right. Returns only the remainder.\n+====\n+\n+[discrete]\n+[[eql-syntax-strings]]\n+==== Strings\n+\n+Strings are enclosed with double quotes (`\"`) or single quotes (`'`).\n+\n+[source,eql]\n+----\n+\"hello world\"\n+\"hello world with 'substring'\"\n+----\n+\n+[discrete]\n+[[eql-syntax-wildcards]]\n+===== Wildcards \n+\n+You can use the wildcard operator (`*`) within a string to match specific", "originalCommit": "3a1021c6a3198384a19bedcf0f11e50d1c3d1ec7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM2NDU0NA==", "url": "https://github.com/elastic/elasticsearch/pull/51821#discussion_r374364544", "bodyText": "Thanks. I swapped the example out with a4db068.", "author": "jrodewig", "createdAt": "2020-02-03T21:58:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM2MjIxNw=="}], "type": "inlineReview"}, {"oid": "a4db068dbd8a8750fd79af1b0adaa10904576415", "url": "https://github.com/elastic/elasticsearch/commit/a4db068dbd8a8750fd79af1b0adaa10904576415", "message": "change wildcard example", "committedDate": "2020-02-03T21:57:29Z", "type": "commit"}, {"oid": "27986af49ac2ab8f81e6237773c7e322123017cf", "url": "https://github.com/elastic/elasticsearch/commit/27986af49ac2ab8f81e6237773c7e322123017cf", "message": "reword", "committedDate": "2020-02-04T16:03:47Z", "type": "commit"}]}