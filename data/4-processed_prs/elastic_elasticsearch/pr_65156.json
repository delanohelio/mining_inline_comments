{"pr_number": 65156, "pr_title": "EQL: Fix aggressive/incorrect until policy in sequences", "pr_createdAt": "2020-11-17T18:21:35Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65156", "timeline": [{"oid": "604a5ee980f42e4ae8ef0418037d703025bd6aa7", "url": "https://github.com/elastic/elasticsearch/commit/604a5ee980f42e4ae8ef0418037d703025bd6aa7", "message": "EQL: Fix aggressive/incorrect until policy in sequences\n\nThe current until implementation in sequences is too optimistic, leading\nto an aggressive match that discards correct data leading to invalid\nresults.\nThis commit addresses this issue and also unifies the until usage inside\nTumblingWindow.\nFurther more it packs together the UntilGroup with SequenceGroup to\nminimize memory usage and improve clean-up.", "committedDate": "2020-11-17T18:11:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4NzEzOA==", "url": "https://github.com/elastic/elasticsearch/pull/65156#discussion_r525387138", "bodyText": "The cleanup is now done through the trim method.", "author": "costin", "createdAt": "2020-11-17T18:22:50Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/sequence/KeyToSequences.java", "diffHunk": "@@ -9,116 +9,128 @@\n import org.elasticsearch.common.logging.LoggerMessageFormat;\n import org.elasticsearch.xpack.eql.execution.search.Ordinal;\n \n+import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.Map;\n-import java.util.Map.Entry;\n \n /**\n  * Dedicated collection for mapping a key to a list of sequences\n  * The list represents the sequence for each stage (based on its index) and is fixed in size\n  */\n class KeyToSequences {\n \n+    /**\n+     * Utility class holding the sequencegroup/until tuple that also handles\n+     * lazy initialization.\n+     */\n+    private class SequenceEntry {\n+\n+        private final SequenceGroup[] groups;\n+        // created lazily\n+        private UntilGroup until;\n+\n+        SequenceEntry(int stages) {\n+            this.groups = new SequenceGroup[stages];\n+        }\n+\n+        void add(int stage, Sequence sequence) {\n+            // create the group on demand\n+            if (groups[stage] == null) {\n+                groups[stage] = new SequenceGroup();\n+            }\n+            groups[stage].add(sequence);\n+        }\n+\n+        public void remove(int stage) {\n+            groups[stage] = null;\n+        }\n+\n+        void until(Ordinal ordinal) {\n+            if (until == null) {\n+                until = new UntilGroup();\n+            }\n+            until.add(ordinal);\n+        }\n+    }\n+\n     private final int listSize;\n     /** for each key, associate the frame per state (determined by index) */\n-    private final Map<SequenceKey, SequenceGroup[]> keyToSequences;\n-    private final Map<SequenceKey, UntilGroup> keyToUntil;\n+    private final Map<SequenceKey, SequenceEntry> keyToSequences;\n \n     KeyToSequences(int listSize) {\n         this.listSize = listSize;\n         this.keyToSequences = new LinkedHashMap<>();\n-        this.keyToUntil = new LinkedHashMap<>();\n-    }\n-\n-    private SequenceGroup[] groups(SequenceKey key) {\n-        return keyToSequences.computeIfAbsent(key, k -> new SequenceGroup[listSize]);\n     }\n \n     SequenceGroup groupIfPresent(int stage, SequenceKey key) {\n-        SequenceGroup[] groups = keyToSequences.get(key);\n-        return groups == null ? null : groups[stage];\n+        SequenceEntry sequenceEntry = keyToSequences.get(key);\n+        return sequenceEntry == null ? null : sequenceEntry.groups[stage];\n     }\n \n     UntilGroup untilIfPresent(SequenceKey key) {\n-        return keyToUntil.get(key);\n+        SequenceEntry sequenceEntry = keyToSequences.get(key);\n+        return sequenceEntry == null ? null : sequenceEntry.until;\n     }\n \n     void add(int stage, Sequence sequence) {\n         SequenceKey key = sequence.key();\n-        SequenceGroup[] groups = groups(key);\n-        // create the group on demand\n-        if (groups[stage] == null) {\n-            groups[stage] = new SequenceGroup(key);\n-        }\n-        groups[stage].add(sequence);\n+        SequenceEntry info = keyToSequences.computeIfAbsent(key, k -> new SequenceEntry(listSize));\n+        info.add(stage, sequence);\n     }\n \n     void until(Iterable<KeyAndOrdinal> until) {\n         for (KeyAndOrdinal keyAndOrdinal : until) {\n             // ignore unknown keys\n             SequenceKey key = keyAndOrdinal.key();\n-            if (keyToSequences.containsKey(key)) {\n-                UntilGroup group = keyToUntil.computeIfAbsent(key, UntilGroup::new);\n-                group.add(keyAndOrdinal);\n+            SequenceEntry sequenceEntry = keyToSequences.get(key);\n+            if (sequenceEntry != null) {\n+                sequenceEntry.until(keyAndOrdinal.ordinal);\n             }\n         }\n     }\n \n-    void remove(int stage, SequenceGroup group) {\n-        SequenceKey key = group.key();\n-        SequenceGroup[] groups = keyToSequences.get(key);\n-        groups[stage] = null;\n-        // clean-up the key if all groups are empty\n-        boolean shouldRemoveKey = true;\n-        for (SequenceGroup gp : groups) {\n-            if (gp != null && gp.isEmpty() == false) {\n-                shouldRemoveKey = false;\n-                break;\n-            }\n-        }\n-        if (shouldRemoveKey) {\n-            keyToSequences.remove(key);\n-        }\n-    }", "originalCommit": "604a5ee980f42e4ae8ef0418037d703025bd6aa7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4NzU1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65156#discussion_r525387551", "bodyText": "This method has been removed as it discarded valid sequences when dealing with windows that completed before until occurred.", "author": "costin", "createdAt": "2020-11-17T18:23:32Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/sequence/KeyToSequences.java", "diffHunk": "@@ -9,116 +9,128 @@\n import org.elasticsearch.common.logging.LoggerMessageFormat;\n import org.elasticsearch.xpack.eql.execution.search.Ordinal;\n \n+import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.Map;\n-import java.util.Map.Entry;\n \n /**\n  * Dedicated collection for mapping a key to a list of sequences\n  * The list represents the sequence for each stage (based on its index) and is fixed in size\n  */\n class KeyToSequences {\n \n+    /**\n+     * Utility class holding the sequencegroup/until tuple that also handles\n+     * lazy initialization.\n+     */\n+    private class SequenceEntry {\n+\n+        private final SequenceGroup[] groups;\n+        // created lazily\n+        private UntilGroup until;\n+\n+        SequenceEntry(int stages) {\n+            this.groups = new SequenceGroup[stages];\n+        }\n+\n+        void add(int stage, Sequence sequence) {\n+            // create the group on demand\n+            if (groups[stage] == null) {\n+                groups[stage] = new SequenceGroup();\n+            }\n+            groups[stage].add(sequence);\n+        }\n+\n+        public void remove(int stage) {\n+            groups[stage] = null;\n+        }\n+\n+        void until(Ordinal ordinal) {\n+            if (until == null) {\n+                until = new UntilGroup();\n+            }\n+            until.add(ordinal);\n+        }\n+    }\n+\n     private final int listSize;\n     /** for each key, associate the frame per state (determined by index) */\n-    private final Map<SequenceKey, SequenceGroup[]> keyToSequences;\n-    private final Map<SequenceKey, UntilGroup> keyToUntil;\n+    private final Map<SequenceKey, SequenceEntry> keyToSequences;\n \n     KeyToSequences(int listSize) {\n         this.listSize = listSize;\n         this.keyToSequences = new LinkedHashMap<>();\n-        this.keyToUntil = new LinkedHashMap<>();\n-    }\n-\n-    private SequenceGroup[] groups(SequenceKey key) {\n-        return keyToSequences.computeIfAbsent(key, k -> new SequenceGroup[listSize]);\n     }\n \n     SequenceGroup groupIfPresent(int stage, SequenceKey key) {\n-        SequenceGroup[] groups = keyToSequences.get(key);\n-        return groups == null ? null : groups[stage];\n+        SequenceEntry sequenceEntry = keyToSequences.get(key);\n+        return sequenceEntry == null ? null : sequenceEntry.groups[stage];\n     }\n \n     UntilGroup untilIfPresent(SequenceKey key) {\n-        return keyToUntil.get(key);\n+        SequenceEntry sequenceEntry = keyToSequences.get(key);\n+        return sequenceEntry == null ? null : sequenceEntry.until;\n     }\n \n     void add(int stage, Sequence sequence) {\n         SequenceKey key = sequence.key();\n-        SequenceGroup[] groups = groups(key);\n-        // create the group on demand\n-        if (groups[stage] == null) {\n-            groups[stage] = new SequenceGroup(key);\n-        }\n-        groups[stage].add(sequence);\n+        SequenceEntry info = keyToSequences.computeIfAbsent(key, k -> new SequenceEntry(listSize));\n+        info.add(stage, sequence);\n     }\n \n     void until(Iterable<KeyAndOrdinal> until) {\n         for (KeyAndOrdinal keyAndOrdinal : until) {\n             // ignore unknown keys\n             SequenceKey key = keyAndOrdinal.key();\n-            if (keyToSequences.containsKey(key)) {\n-                UntilGroup group = keyToUntil.computeIfAbsent(key, UntilGroup::new);\n-                group.add(keyAndOrdinal);\n+            SequenceEntry sequenceEntry = keyToSequences.get(key);\n+            if (sequenceEntry != null) {\n+                sequenceEntry.until(keyAndOrdinal.ordinal);\n             }\n         }\n     }\n \n-    void remove(int stage, SequenceGroup group) {\n-        SequenceKey key = group.key();\n-        SequenceGroup[] groups = keyToSequences.get(key);\n-        groups[stage] = null;\n-        // clean-up the key if all groups are empty\n-        boolean shouldRemoveKey = true;\n-        for (SequenceGroup gp : groups) {\n-            if (gp != null && gp.isEmpty() == false) {\n-                shouldRemoveKey = false;\n-                break;\n-            }\n-        }\n-        if (shouldRemoveKey) {\n-            keyToSequences.remove(key);\n-        }\n-    }\n-\n-    void dropUntil() {\n-        // clean-up all candidates that occur before until\n-        for (Entry<SequenceKey, UntilGroup> entry : keyToUntil.entrySet()) {\n-            SequenceGroup[] groups = keyToSequences.get(entry.getKey());\n-            if (groups != null) {\n-                for (Ordinal o : entry.getValue()) {\n-                    for (SequenceGroup group : groups) {\n-                        if (group != null) {\n-                            group.trimBefore(o);\n-                        }\n-                    }\n-                }\n-            }\n-        }", "originalCommit": "604a5ee980f42e4ae8ef0418037d703025bd6aa7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4OTAyNg==", "url": "https://github.com/elastic/elasticsearch/pull/65156#discussion_r525389026", "bodyText": "The key was removed since all OrdinalGroups are now associated with one inside the tracking map. This reduces memory consumption due to keys using different strings that have the same content. When dealing with a large number of keys, this results in a lot of string repetitions.", "author": "costin", "createdAt": "2020-11-17T18:25:45Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/sequence/OrdinalGroup.java", "diffHunk": "@@ -32,15 +31,10 @@\n \n     private Ordinal start, stop;\n \n-    protected OrdinalGroup(SequenceKey key, Function<E, Ordinal> extractor) {\n-        this.key = key;\n+    protected OrdinalGroup(Function<E, Ordinal> extractor) {\n         this.extractor = extractor;\n     }\n \n-    SequenceKey key() {\n-        return key;\n-    }\n-", "originalCommit": "604a5ee980f42e4ae8ef0418037d703025bd6aa7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM5MDc2OA==", "url": "https://github.com/elastic/elasticsearch/pull/65156#discussion_r525390768", "bodyText": "The main change is here, where until gets called right after the first query runs but before the results are matched so that the until results are available for comparison.", "author": "costin", "createdAt": "2020-11-17T18:28:19Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/sequence/TumblingWindow.java", "diffHunk": "@@ -190,18 +187,19 @@ private void baseCriterion(int baseStage, SearchResponse r, ActionListener<Paylo\n             // always create an ASC window\n             info = new WindowInfo(baseStage, begin, end);\n \n-            log.trace(\"Found {}base [{}] window {}->{}\", base.descending() ? \"tail \": \"\", base.stage(), begin, end);\n+            log.trace(\"Found {}base [{}] window {}->{}\", base.descending() ? \"tail \" : \"\", base.stage(), begin, end);\n \n             // update current query for the next request\n             base.queryRequest().nextAfter(end);\n \n-            // early until check if dealing with a TAIL sequence\n             // execute UNTIL *before* matching the results\n+            // but after the window has been created\n+            //\n             // this is needed for TAIL sequences since the base of the window\n             // is called once with the DESC query, then with the ASC one\n             // thus UNTIL needs to be executed before matching the second query\n             // that is the ASC base of the window\n-            if (earlyUntil && until != null && baseStage == 1) {\n+            if (until != null && baseStage > 0) {", "originalCommit": "604a5ee980f42e4ae8ef0418037d703025bd6aa7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}