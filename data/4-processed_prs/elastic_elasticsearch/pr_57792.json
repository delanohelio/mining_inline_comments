{"pr_number": 57792, "pr_title": "Use clean thread context for transport and applier service", "pr_createdAt": "2020-06-08T07:43:12Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/57792", "timeline": [{"oid": "63087729a41b0937480430f6c557d803360763f6", "url": "https://github.com/elastic/elasticsearch/commit/63087729a41b0937480430f6c557d803360763f6", "message": "Use clean thread context for transport and applier service", "committedDate": "2020-06-08T07:41:37Z", "type": "commit"}, {"oid": "a4cb9c13ce631fead51da029a9049151f9d17b80", "url": "https://github.com/elastic/elasticsearch/commit/a4cb9c13ce631fead51da029a9049151f9d17b80", "message": "fix test", "committedDate": "2020-06-08T09:15:42Z", "type": "commit"}, {"oid": "cb869d1ec411b7d987dbdedd83cf3f779583991e", "url": "https://github.com/elastic/elasticsearch/commit/cb869d1ec411b7d987dbdedd83cf3f779583991e", "message": "Merge remote-tracking branch 'elastic/master' into clean-thread-context", "committedDate": "2020-06-08T09:15:57Z", "type": "commit"}, {"oid": "9ae9ad57ac28bfbd3b7357d4d01c92118ff15ca3", "url": "https://github.com/elastic/elasticsearch/commit/9ae9ad57ac28bfbd3b7357d4d01c92118ff15ca3", "message": "fix", "committedDate": "2020-06-08T09:52:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjczMTQwMg==", "url": "https://github.com/elastic/elasticsearch/pull/57792#discussion_r436731402", "bodyText": "Do we even need to do this? Now that we fixed NetworkMessage I think there are only two possible scenarios here:\n\nWe are running this on the IO thread for the channel we send to. In that case, the context was polluted elsewhere already and this isn't really safe in the first place (because under load the actions in Netty's flush might run after this block executed and restored the unclean context for example)?\nWe are running this off of the network thread of the channel, in which case switching the context here is just irrelevant?", "author": "original-brownbear", "createdAt": "2020-06-08T14:02:53Z", "path": "server/src/main/java/org/elasticsearch/transport/OutboundHandler.java", "diffHunk": "@@ -116,7 +117,8 @@ private void sendMessage(TcpChannel channel, OutboundMessage networkMessage, Act\n \n     private void internalSend(TcpChannel channel, SendContext sendContext) {\n         channel.getChannelStats().markAccessed(threadPool.relativeTimeInMillis());\n-        try {\n+        // stash thread context so that channel event loop is not polluted by thread context\n+        try (ThreadContext.StoredContext existing = threadPool.getThreadContext().stashContext()) {", "originalCommit": "9ae9ad57ac28bfbd3b7357d4d01c92118ff15ca3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc1NDczMg==", "url": "https://github.com/elastic/elasticsearch/pull/57792#discussion_r436754732", "bodyText": "This is specifically for case 1, yes. We're handing control over to the Netty library in this case, which, as you noted, can execute under a non-default thread context (e.g. in case where a message was received on the same thread that is now executing under SAME). We just have to make sure that whenever give control back to the Netty code (which is free to write/flush at its own pace) that we clean up the context. If Netty decides running this later, that's fine, any time we hand control to Netty code, we're making sure to clean up the context.", "author": "ywelsch", "createdAt": "2020-06-08T14:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjczMTQwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4MjY1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/57792#discussion_r436782655", "bodyText": "Makes sense thanks!", "author": "original-brownbear", "createdAt": "2020-06-08T15:09:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjczMTQwMg=="}], "type": "inlineReview"}]}