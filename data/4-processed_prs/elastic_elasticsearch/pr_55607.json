{"pr_number": 55607, "pr_title": "Merge V2 index/component template mappings in specific manner", "pr_createdAt": "2020-04-22T16:23:01Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55607", "timeline": [{"oid": "890db88d04254e8de43a515d7efdb0e02b19f7e4", "url": "https://github.com/elastic/elasticsearch/commit/890db88d04254e8de43a515d7efdb0e02b19f7e4", "message": "Merge V2 index/component template mappings in specific manner\n\nThis commit changes the way that V2 index, component, and request mappings are merged. Specifically:\n\n- Fields are merged in a \"replacement\" manner, meaning that the entire definition is replaced rather\nthan merging the interior configuration\n- Mapping metadata (all fields outside of `properties`) are merged recursively.\n\nThe merging for V1 templates does not change.\n\nRelates to #53101", "committedDate": "2020-04-22T16:19:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEzODY3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55607#discussion_r413138679", "bodyText": "innerTemplateMapping is only used to initialize innerTemplateNonProperties\nWould it make sense for these statements to be executed in reversed order to avoid over allocating innerTemplateNonProperties just to immediately remove \"properties\" ?\nie.\nMap<String, Object> maybeProperties = (Map<String, Object>) innerTemplateMapping.remove(\"properties\");\nMap<String, Object> innerTemplateNonProperties = new HashMap<>(innerTemplateMapping);", "author": "andreidan", "createdAt": "2020-04-22T16:38:53Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "diffHunk": "@@ -529,13 +537,76 @@ private ClusterState applyCreateIndexRequestWithExistingMetadata(final ClusterSt\n     }\n \n     /**\n-     * Parses the provided mappings json and the inheritable mappings from the templates (if any) into a map.\n+     * Parses the provided mappings json and the inheritable mappings from the templates (if any)\n+     * into a map.\n      *\n-     * The template mappings are applied in the order they are encountered in the list (clients should make sure the lower index, closer\n-     * to the head of the list, templates have the highest {@link IndexTemplateMetadata#order()})\n+     * The template mappings are applied in the order they are encountered in the list, with the\n+     * caveat that mapping fields are only merged at the top-level, meaning that field settings are\n+     * not merged, instead they replace any previous field definition.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static Map<String, Object> parseV2Mappings(String mappingsJson, List<CompressedXContent> templateMappings,\n+                                               NamedXContentRegistry xContentRegistry) throws Exception {\n+        Map<String, Object> requestMappings = MapperService.parseMapping(xContentRegistry, mappingsJson);\n+        // apply templates, merging the mappings into the request mapping if exists\n+        Map<String, Object> properties = new HashMap<>();\n+        Map<String, Object> nonProperties = new HashMap<>();\n+        for (CompressedXContent mapping : templateMappings) {\n+            if (mapping != null) {\n+                Map<String, Object> templateMapping = MapperService.parseMapping(xContentRegistry, mapping.string());\n+                if (templateMapping.isEmpty()) {\n+                    // Someone provided an empty '{}' for mappings, which is okay, but to avoid\n+                    // tripping the below assertion, we can safely ignore it\n+                    continue;\n+                }\n+                assert templateMapping.size() == 1 : \"expected exactly one mapping value, got: \" + templateMapping;\n+                if (templateMapping.get(MapperService.SINGLE_MAPPING_NAME) instanceof Map == false) {\n+                    throw new IllegalStateException(\"invalid mapping definition, expected a single map underneath [\" +\n+                        MapperService.SINGLE_MAPPING_NAME + \"] but it was: [\" + templateMapping + \"]\");\n+                }\n+\n+                Map<String, Object> innerTemplateMapping = (Map<String, Object>) templateMapping.get(MapperService.SINGLE_MAPPING_NAME);\n+                Map<String, Object> innerTemplateNonProperties = new HashMap<>(innerTemplateMapping);\n+                Map<String, Object> maybeProperties = (Map<String, Object>) innerTemplateNonProperties.remove(\"properties\");", "originalCommit": "890db88d04254e8de43a515d7efdb0e02b19f7e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE0NzY2OA==", "url": "https://github.com/elastic/elasticsearch/pull/55607#discussion_r413147668", "bodyText": "Ah, ignore this actually, as we'd be modifying a map we didn't create. It's fine as it is", "author": "andreidan", "createdAt": "2020-04-22T16:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEzODY3OQ=="}], "type": "inlineReview"}]}