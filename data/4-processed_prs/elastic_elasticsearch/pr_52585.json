{"pr_number": 52585, "pr_title": "ILM: add searchable snapshot action", "pr_createdAt": "2020-02-20T17:46:10Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52585", "timeline": [{"oid": "25cea2b5a66b66dd4caba5f29b8f1341490c4e7c", "url": "https://github.com/elastic/elasticsearch/commit/25cea2b5a66b66dd4caba5f29b8f1341490c4e7c", "message": "ILM: add searchable snapshot action", "committedDate": "2020-02-20T17:42:16Z", "type": "commit"}, {"oid": "3c32490f4582fa9e7539e89994c3bc26074e72c5", "url": "https://github.com/elastic/elasticsearch/commit/3c32490f4582fa9e7539e89994c3bc26074e72c5", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-02-21T14:38:22Z", "type": "commit"}, {"oid": "7dbc46e72be3abf9b9683595e39725a2af72f802", "url": "https://github.com/elastic/elasticsearch/commit/7dbc46e72be3abf9b9683595e39725a2af72f802", "message": "Add license header", "committedDate": "2020-02-21T14:50:01Z", "type": "commit"}, {"oid": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "url": "https://github.com/elastic/elasticsearch/commit/9881c44a001bfbc7dad787d97b6d8d329eca3916", "message": "Document why we don\u2019t restore the lifecycle setting", "committedDate": "2020-02-21T15:10:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIyNDU0MA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382224540", "bodyText": "I'd suggest maybe cleanup-searchable-snapshot in case we ever have a different snapshot task :)", "author": "dakrone", "createdAt": "2020-02-20T19:55:44Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.snapshots.SnapshotMissingException;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Deletes the snapshot designated by the snapshot name present in the lifecycle execution state, hosted in the configured repository.\n+ */\n+public class CleanupSnapshotStep extends AsyncActionStep {\n+    public static final String NAME = \"cleanup-snapshot\";", "originalCommit": "25cea2b5a66b66dd4caba5f29b8f1341490c4e7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM1NzI4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r383357283", "bodyText": "I think leaving it as \"cleanup-snapshot\" makes sense as the step is agnostic of searchable snapshots. It issues a \"delete snapshot\" request for a particular repository and snapshot name (and in our use case we're using it to clean up the regular repository, not the searchable one)", "author": "andreidan", "createdAt": "2020-02-24T16:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIyNDU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5OTc4OA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382299788", "bodyText": "Should we also catch RepositoryMissingException and re-throw a more helpful message? What do you think?", "author": "dakrone", "createdAt": "2020-02-20T22:42:21Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.snapshots.SnapshotMissingException;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Deletes the snapshot designated by the snapshot name present in the lifecycle execution state, hosted in the configured repository.\n+ */\n+public class CleanupSnapshotStep extends AsyncActionStep {\n+    public static final String NAME = \"cleanup-snapshot\";\n+\n+    private final String snapshotRepository;\n+\n+    public CleanupSnapshotStep(StepKey key, StepKey nextStepKey, Client client, String snapshotRepository) {\n+        super(key, nextStepKey, client);\n+        this.snapshotRepository = snapshotRepository;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer,\n+                              Listener listener) {\n+        final String indexName = indexMetaData.getIndex().getName();\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+        final String snapshotName = lifecycleState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            listener.onFailure(\n+                new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName + \"] and index [\" + indexName + \"]\")\n+            );\n+            return;\n+        }\n+        DeleteSnapshotRequest deleteSnapshotRequest = new DeleteSnapshotRequest(snapshotRepository, snapshotName);\n+        getClient().admin().cluster().deleteSnapshot(deleteSnapshotRequest, new ActionListener<>() {\n+\n+            @Override\n+            public void onResponse(AcknowledgedResponse acknowledgedResponse) {\n+                listener.onResponse(true);\n+            }\n+\n+            @Override\n+            public void onFailure(Exception e) {\n+                if (e instanceof SnapshotMissingException) {", "originalCommit": "25cea2b5a66b66dd4caba5f29b8f1341490c4e7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3MzA4MA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382673080", "bodyText": "Sure", "author": "andreidan", "createdAt": "2020-02-21T16:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5OTc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwMTMyNg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382301326", "bodyText": "These need to be Objects.requireNonNull, currently it just returns true or false but doesn't throw an exception.", "author": "dakrone", "createdAt": "2020-02-20T22:46:06Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Copy the provided settings from the source to the target index.\n+ * <p>\n+ * The target index is derived from the source index using the provided prefix.\n+ * This is useful for actions like shrink or searchable snapshot that create a new index and migrate the ILM execution from the source\n+ * to the target index.\n+ */\n+public class CopySettingsStep extends AsyncActionStep {\n+    public static final String NAME = \"copy-settings\";\n+\n+    private final String[] settingsKeys;\n+    private final String indexPrefix;\n+\n+    public CopySettingsStep(StepKey key, StepKey nextStepKey, Client client, String indexPrefix, String... settingsKeys) {\n+        super(key, nextStepKey, client);\n+        Objects.nonNull(indexPrefix);\n+        Objects.nonNull(settingsKeys);", "originalCommit": "25cea2b5a66b66dd4caba5f29b8f1341490c4e7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3Mzc1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382673752", "bodyText": "Good catch (I hadn't even acknowledged the existence of an API that just does obj != null - TIL :) )", "author": "andreidan", "createdAt": "2020-02-21T16:19:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwMTMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwMjI2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382302266", "bodyText": "Currently we do this as an AsyncActionStep, but should we rather do this as a ClusterStateActionStep to avoid having to actually issue the request and wait for it? I believe it would be a bit better then, and it would also allow us to copy settings that may not be settable (if we need that functionality in the future)", "author": "dakrone", "createdAt": "2020-02-20T22:48:30Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Copy the provided settings from the source to the target index.\n+ * <p>\n+ * The target index is derived from the source index using the provided prefix.\n+ * This is useful for actions like shrink or searchable snapshot that create a new index and migrate the ILM execution from the source\n+ * to the target index.\n+ */\n+public class CopySettingsStep extends AsyncActionStep {\n+    public static final String NAME = \"copy-settings\";\n+\n+    private final String[] settingsKeys;\n+    private final String indexPrefix;\n+\n+    public CopySettingsStep(StepKey key, StepKey nextStepKey, Client client, String indexPrefix, String... settingsKeys) {\n+        super(key, nextStepKey, client);\n+        Objects.nonNull(indexPrefix);\n+        Objects.nonNull(settingsKeys);\n+        this.indexPrefix = indexPrefix;\n+        this.settingsKeys = settingsKeys;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentState, ClusterStateObserver observer, Listener listener) {\n+        String indexName = indexPrefix + indexMetaData.getIndex().getName();\n+\n+        Settings.Builder settings = Settings.builder();\n+        for (String key : settingsKeys) {\n+            String value = indexMetaData.getSettings().get(key);\n+            settings.put(key, value);\n+        }\n+\n+        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(indexName)", "originalCommit": "25cea2b5a66b66dd4caba5f29b8f1341490c4e7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3NDc0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382674742", "bodyText": "Oh interesting. I agree it'd be a better avenue", "author": "andreidan", "createdAt": "2020-02-21T16:21:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwMjI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwNzgwOA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382307808", "bodyText": "Why are we generating the snapshot name twice here?", "author": "dakrone", "createdAt": "2020-02-20T23:02:53Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.index.Index;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.ILM_CUSTOM_METADATA_KEY;\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Generates a snapshot name for the given index and records it in the index metadata.\n+ */\n+public class GenerateSnapshotNameStep extends ClusterStateActionStep {\n+\n+    public static final String NAME = \"generate-snapshot-name\";\n+\n+    private static final Logger logger = LogManager.getLogger(TakeSnapshotStep.class);\n+\n+    private static final IndexNameExpressionResolver.DateMathExpressionResolver DATE_MATH_RESOLVER =\n+        new IndexNameExpressionResolver.DateMathExpressionResolver();\n+\n+    public GenerateSnapshotNameStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public ClusterState performAction(Index index, ClusterState clusterState) {\n+        IndexMetaData indexMetaData = clusterState.metaData().index(index);\n+        if (indexMetaData == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return clusterState;\n+        }\n+\n+        ClusterState.Builder newClusterStateBuilder = ClusterState.builder(clusterState);\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+        assert lifecycleState.getSnapshotName() == null : \"index \" + index.getName() + \" should not have a snapshot generated by \" +\n+            \"the ilm policy but has \" + lifecycleState.getSnapshotName();\n+        LifecycleExecutionState.Builder newCustomData = LifecycleExecutionState.builder(lifecycleState);\n+        String policy = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        String snapshotName = generateSnapshotName(generateSnapshotName(\"<{now/M}-\" + index.getName() + \"-\" + policy + \">\"));", "originalCommit": "25cea2b5a66b66dd4caba5f29b8f1341490c4e7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwODIzNw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382308237", "bodyText": "Also, do we think {now/M} is enough granularity? We could probably go with /d to be a bit more granular?", "author": "dakrone", "createdAt": "2020-02-20T23:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwNzgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwODcxNg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382308716", "bodyText": "Also, this should use the same validation that SnapshotLifecyclePolicy.validate() does for validating things (for example, no # in the name). We should factor that validation out into a method and use it here.", "author": "dakrone", "createdAt": "2020-02-20T23:05:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwNzgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwODkxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382308915", "bodyText": "We can make SnapshotLifecyclePolicy.generateSnapshotName static and use that instead I think?", "author": "dakrone", "createdAt": "2020-02-20T23:06:14Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.index.Index;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.ILM_CUSTOM_METADATA_KEY;\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Generates a snapshot name for the given index and records it in the index metadata.\n+ */\n+public class GenerateSnapshotNameStep extends ClusterStateActionStep {\n+\n+    public static final String NAME = \"generate-snapshot-name\";\n+\n+    private static final Logger logger = LogManager.getLogger(TakeSnapshotStep.class);\n+\n+    private static final IndexNameExpressionResolver.DateMathExpressionResolver DATE_MATH_RESOLVER =\n+        new IndexNameExpressionResolver.DateMathExpressionResolver();\n+\n+    public GenerateSnapshotNameStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public ClusterState performAction(Index index, ClusterState clusterState) {\n+        IndexMetaData indexMetaData = clusterState.metaData().index(index);\n+        if (indexMetaData == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return clusterState;\n+        }\n+\n+        ClusterState.Builder newClusterStateBuilder = ClusterState.builder(clusterState);\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+        assert lifecycleState.getSnapshotName() == null : \"index \" + index.getName() + \" should not have a snapshot generated by \" +\n+            \"the ilm policy but has \" + lifecycleState.getSnapshotName();\n+        LifecycleExecutionState.Builder newCustomData = LifecycleExecutionState.builder(lifecycleState);\n+        String policy = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        String snapshotName = generateSnapshotName(generateSnapshotName(\"<{now/M}-\" + index.getName() + \"-\" + policy + \">\"));\n+        newCustomData.setSnapshotName(snapshotName);\n+\n+        IndexMetaData.Builder indexMetadataBuilder = IndexMetaData.builder(indexMetaData);\n+        indexMetadataBuilder.putCustom(ILM_CUSTOM_METADATA_KEY, newCustomData.build().asMap());\n+        newClusterStateBuilder.metaData(MetaData.builder(clusterState.getMetaData()).put(indexMetadataBuilder));\n+        return newClusterStateBuilder.build();\n+    }\n+\n+    /**\n+     * Since snapshots need to be uniquely named, this method will resolve any date math used in\n+     * the provided name, as well as appending a unique identifier so expressions that may overlap\n+     * still result in unique snapshot names.\n+     */\n+    public static String generateSnapshotName(String name) {\n+        return generateSnapshotName(name, new ResolverContext());\n+    }\n+\n+    public static String generateSnapshotName(String name, IndexNameExpressionResolver.Context context) {", "originalCommit": "25cea2b5a66b66dd4caba5f29b8f1341490c4e7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxNDM3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r383414376", "bodyText": "I moved that snapshot generation method here (this is that essentially) as the line of dependency we have is SLM depends on ILM and I didn't want to make it circular.", "author": "andreidan", "createdAt": "2020-02-24T17:43:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwODkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwOTMwMg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382309302", "bodyText": "Javadocs?", "author": "dakrone", "createdAt": "2020-02-20T23:07:13Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/OnAsyncWaitBranchingStep.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+\n+import java.util.Objects;\n+\n+public class OnAsyncWaitBranchingStep extends AsyncWaitStep {", "originalCommit": "25cea2b5a66b66dd4caba5f29b8f1341490c4e7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjYzOTk3OA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382639978", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String NAME = \"restore-snapshot\";\n          \n          \n            \n                public static final String NAME = \"restore-searchable-snapshot\";", "author": "dakrone", "createdAt": "2020-02-21T15:21:32Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RestoreSnapshotStep.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Restores the snapshot created for the designated index via the ILM policy to an index named using the provided prefix appended to the\n+ * designated index name.\n+ */\n+public class RestoreSnapshotStep extends AsyncActionStep {\n+    public static final String NAME = \"restore-snapshot\";", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0NTQ2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382645466", "bodyText": "Should we do some special processing for an exception due to a snapshot or restore already being in progress?", "author": "dakrone", "createdAt": "2020-02-21T15:30:54Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RestoreSnapshotStep.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Restores the snapshot created for the designated index via the ILM policy to an index named using the provided prefix appended to the\n+ * designated index name.\n+ */\n+public class RestoreSnapshotStep extends AsyncActionStep {\n+    public static final String NAME = \"restore-snapshot\";\n+\n+    private final String snapshotRepository;\n+    private final String restoredIndexPrefix;\n+\n+    public RestoreSnapshotStep(StepKey key, StepKey nextStepKey, Client client, String snapshotRepository, String restoredIndexPrefix) {\n+        super(key, nextStepKey, client);\n+        this.snapshotRepository = snapshotRepository;\n+        this.restoredIndexPrefix = restoredIndexPrefix;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer,\n+                              Listener listener) {\n+        final String indexName = indexMetaData.getIndex().getName();\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+\n+        final String snapshotName = lifecycleState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            listener.onFailure(\n+                new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName + \"] and index [\" + indexName + \"]\"));\n+            return;\n+        }\n+        RestoreSnapshotRequest restoreSnapshotRequest = new RestoreSnapshotRequest(snapshotRepository, snapshotName);\n+        // we'll not wait for the snapshot to complete in this step as the async steps are executed from threads that shouldn't perform\n+        // expensive operations (ie. clusterStateProcessed)\n+        restoreSnapshotRequest.waitForCompletion(false);\n+        restoreSnapshotRequest.indices(indexName);\n+        restoreSnapshotRequest.renamePattern(indexName);\n+        restoreSnapshotRequest.renameReplacement(restoredIndexPrefix + indexName);\n+        // we captured the index metadata when we took the snapshot. the index likely had the ILM execution state in the metadata.\n+        // if we were to restore the lifecycle.name setting, the restored index would be captured by the ILM runner and, depending on what\n+        // ILM execution state was captured at snapshot time, make it's way forward from _that_ step forward in the ILM policy.\n+        // we'll re-set this setting on the restored index at a later step once we restored a deterministic execution state\n+        restoreSnapshotRequest.ignoreIndexSettings(LifecycleSettings.LIFECYCLE_NAME);\n+        restoreSnapshotRequest.includeAliases(false);\n+\n+        getClient().admin().cluster().restoreSnapshot(restoreSnapshotRequest, new ActionListener<>() {\n+            @Override\n+            public void onResponse(RestoreSnapshotResponse response) {\n+                listener.onResponse(true);\n+            }\n+\n+            @Override\n+            public void onFailure(Exception e) {", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3NTUzNw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382675537", "bodyText": "I thought we'd retry using our usual retry mechanism. Might be good to report we encountered this better though", "author": "andreidan", "createdAt": "2020-02-21T16:22:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0NTQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0NTcyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382645725", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String NAME = \"searchable_snapshot\";\n          \n          \n            \n                public static final String NAME = \"searchable-snapshot\";", "author": "dakrone", "createdAt": "2020-02-21T15:31:19Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.snapshots.SnapshotException;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable_snapshot\";", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA4ODM2MA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r401088360", "bodyText": "I think this one may have been lost in some of the other reviews, but I still think it should be changed (to searchable-snapshot)", "author": "dakrone", "createdAt": "2020-03-31T17:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0NTcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0NzI1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382647252", "bodyText": "We might want to discuss what we want the prefix to be, I'm not sure about \"ilm-restored-\" in case we ever have a different (non-searchable) ILM action to restore a snapshot, what do you think?", "author": "dakrone", "createdAt": "2020-02-21T15:33:50Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.snapshots.SnapshotException;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable_snapshot\";\n+\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot_repository\");\n+    public static final ParseField SEARCHABLE_REPOSITORY = new ParseField(\"searchable_repository\");\n+\n+    public static final String RESTORED_INDEX_PREFIX = \"ilm-restored-\";", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3NzI2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382677266", "bodyText": "Hm, I'm not sure I understand what you mean. The intention was to keep it \"searchable snapshot\" independent, which it is now. Do you have something specific in mind? (and this is also configurable in the RestoreSnapshotStep, in case we reuse it with regulard snapshot restores)", "author": "andreidan", "createdAt": "2020-02-21T16:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0NzI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NDA4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382684089", "bodyText": "What about restored-? I think that fits a little more with our shrink- prefix", "author": "dakrone", "createdAt": "2020-02-21T16:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0NzI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0OTM5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382649395", "bodyText": "Can you add javadocs to this method?", "author": "dakrone", "createdAt": "2020-02-21T15:37:40Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.snapshots.SnapshotException;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable_snapshot\";\n+\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot_repository\");\n+    public static final ParseField SEARCHABLE_REPOSITORY = new ParseField(\"searchable_repository\");\n+\n+    public static final String RESTORED_INDEX_PREFIX = \"ilm-restored-\";\n+\n+    private static final ConstructingObjectParser<SearchableSnapshotAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new SearchableSnapshotAction((String) a[0], (String) a[1]));\n+\n+    static {\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), SNAPSHOT_REPOSITORY);\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), SEARCHABLE_REPOSITORY);\n+    }\n+\n+    public static SearchableSnapshotAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    private final String snapshotRepository;\n+    private final String searchableRepository;\n+\n+    public SearchableSnapshotAction(String snapshotRepository, String searchableRepository) {\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            throw new IllegalArgumentException(\"the snapshot repository must be specified\");\n+        }\n+        if (Strings.hasText(searchableRepository) == false) {\n+            throw new IllegalArgumentException(\"the searchable repository must be specified\");\n+        }\n+        this.snapshotRepository = snapshotRepository;\n+        this.searchableRepository = searchableRepository;\n+    }\n+\n+    public SearchableSnapshotAction(StreamInput in) throws IOException {\n+        this(in.readString(), in.readString());\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        StepKey waitForNoFollowerStepKey = new StepKey(phase, NAME, WaitForNoFollowersStep.NAME);\n+        StepKey generateSnapshotNameKey = new StepKey(phase, NAME, GenerateSnapshotNameStep.NAME);\n+        StepKey cleanSnapshotKey = new StepKey(phase, NAME, CleanupSnapshotStep.NAME);\n+        StepKey takeSnapshotKey = new StepKey(phase, NAME, TakeSnapshotStep.NAME);\n+        StepKey waitForSnapshotInProgressKey = new StepKey(phase, NAME, WaitForSnapshotInProgressStep.NAME);\n+        StepKey verifySnapshotStatusBranchingKey = new StepKey(phase, NAME, OnAsyncWaitBranchingStep.NAME);\n+        StepKey restoreFromSearchableRepoKey = new StepKey(phase, NAME, RestoreSnapshotStep.NAME);\n+        StepKey waitForGreenRestoredIndexKey = new StepKey(phase, NAME, WaitForGreenIndexHealthStep.NAME);\n+        StepKey copyMetadataKey = new StepKey(phase, NAME, CopyExecutionStateStep.NAME);\n+        StepKey copyLifecyclePolicySettingKey = new StepKey(phase, NAME, CopySettingsStep.NAME);\n+        StepKey swapAliasesKey = new StepKey(phase, NAME, SwapAliasesAndDeleteSourceIndexStep.NAME);\n+\n+        WaitForNoFollowersStep waitForNoFollowersStep = new WaitForNoFollowersStep(waitForNoFollowerStepKey, generateSnapshotNameKey,\n+            client);\n+        GenerateSnapshotNameStep generateSnapshotNameStep = new GenerateSnapshotNameStep(generateSnapshotNameKey, cleanSnapshotKey);\n+        CleanupSnapshotStep cleanupSnapshotStep = new CleanupSnapshotStep(cleanSnapshotKey, takeSnapshotKey, client, snapshotRepository);\n+        TakeSnapshotStep takeSnapshotStep = new TakeSnapshotStep(takeSnapshotKey, waitForSnapshotInProgressKey, client, snapshotRepository);\n+        WaitForSnapshotInProgressStep waitForSnapshotInProgressStep = new WaitForSnapshotInProgressStep(waitForSnapshotInProgressKey,\n+            verifySnapshotStatusBranchingKey, snapshotRepository);\n+        OnAsyncWaitBranchingStep onAsyncWaitBranchingStep = new OnAsyncWaitBranchingStep(verifySnapshotStatusBranchingKey,\n+            cleanSnapshotKey, restoreFromSearchableRepoKey, client, getCheckSnapshotStatusAsyncAction(snapshotRepository));\n+        RestoreSnapshotStep restoreSnapshotStep = new RestoreSnapshotStep(restoreFromSearchableRepoKey, waitForGreenRestoredIndexKey,\n+            client, searchableRepository, RESTORED_INDEX_PREFIX);\n+        WaitForGreenIndexHealthStep waitForGreenIndexHealthStep = new WaitForGreenIndexHealthStep(waitForGreenRestoredIndexKey,\n+            copyMetadataKey, RESTORED_INDEX_PREFIX);\n+        CopyExecutionStateStep copyMetadataStep = new CopyExecutionStateStep(copyMetadataKey, copyLifecyclePolicySettingKey,\n+            RESTORED_INDEX_PREFIX, nextStepKey.getName());\n+        CopySettingsStep copySettingsStep = new CopySettingsStep(copyLifecyclePolicySettingKey, swapAliasesKey, client,\n+            RESTORED_INDEX_PREFIX, LifecycleSettings.LIFECYCLE_NAME);\n+        // sending this step to null as the restored index (which will after this step essentially be the source index) was sent to the next\n+        // key after we restored the lifecycle execution state\n+        SwapAliasesAndDeleteSourceIndexStep swapAliasesAndDeleteSourceIndexStep = new SwapAliasesAndDeleteSourceIndexStep(swapAliasesKey,\n+            null, client, RESTORED_INDEX_PREFIX);\n+\n+        return Arrays.asList(waitForNoFollowersStep, generateSnapshotNameStep, cleanupSnapshotStep, takeSnapshotStep,\n+            waitForSnapshotInProgressStep, onAsyncWaitBranchingStep, restoreSnapshotStep, waitForGreenIndexHealthStep,\n+            copyMetadataStep, copySettingsStep, swapAliasesAndDeleteSourceIndexStep);\n+    }\n+\n+    private TriConsumer<Client, IndexMetaData, AsyncWaitStep.Listener> getCheckSnapshotStatusAsyncAction(String snapshotRepository) {", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0OTkyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382649929", "bodyText": "And maybe this can be static? We could pass in the names of things, might make it easier to test?", "author": "dakrone", "createdAt": "2020-02-21T15:38:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0OTM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1MDUyMw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382650523", "bodyText": "Can you capture the snapshotState in this message also?", "author": "dakrone", "createdAt": "2020-02-21T15:39:34Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.snapshots.SnapshotException;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable_snapshot\";\n+\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot_repository\");\n+    public static final ParseField SEARCHABLE_REPOSITORY = new ParseField(\"searchable_repository\");\n+\n+    public static final String RESTORED_INDEX_PREFIX = \"ilm-restored-\";\n+\n+    private static final ConstructingObjectParser<SearchableSnapshotAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new SearchableSnapshotAction((String) a[0], (String) a[1]));\n+\n+    static {\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), SNAPSHOT_REPOSITORY);\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), SEARCHABLE_REPOSITORY);\n+    }\n+\n+    public static SearchableSnapshotAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    private final String snapshotRepository;\n+    private final String searchableRepository;\n+\n+    public SearchableSnapshotAction(String snapshotRepository, String searchableRepository) {\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            throw new IllegalArgumentException(\"the snapshot repository must be specified\");\n+        }\n+        if (Strings.hasText(searchableRepository) == false) {\n+            throw new IllegalArgumentException(\"the searchable repository must be specified\");\n+        }\n+        this.snapshotRepository = snapshotRepository;\n+        this.searchableRepository = searchableRepository;\n+    }\n+\n+    public SearchableSnapshotAction(StreamInput in) throws IOException {\n+        this(in.readString(), in.readString());\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        StepKey waitForNoFollowerStepKey = new StepKey(phase, NAME, WaitForNoFollowersStep.NAME);\n+        StepKey generateSnapshotNameKey = new StepKey(phase, NAME, GenerateSnapshotNameStep.NAME);\n+        StepKey cleanSnapshotKey = new StepKey(phase, NAME, CleanupSnapshotStep.NAME);\n+        StepKey takeSnapshotKey = new StepKey(phase, NAME, TakeSnapshotStep.NAME);\n+        StepKey waitForSnapshotInProgressKey = new StepKey(phase, NAME, WaitForSnapshotInProgressStep.NAME);\n+        StepKey verifySnapshotStatusBranchingKey = new StepKey(phase, NAME, OnAsyncWaitBranchingStep.NAME);\n+        StepKey restoreFromSearchableRepoKey = new StepKey(phase, NAME, RestoreSnapshotStep.NAME);\n+        StepKey waitForGreenRestoredIndexKey = new StepKey(phase, NAME, WaitForGreenIndexHealthStep.NAME);\n+        StepKey copyMetadataKey = new StepKey(phase, NAME, CopyExecutionStateStep.NAME);\n+        StepKey copyLifecyclePolicySettingKey = new StepKey(phase, NAME, CopySettingsStep.NAME);\n+        StepKey swapAliasesKey = new StepKey(phase, NAME, SwapAliasesAndDeleteSourceIndexStep.NAME);\n+\n+        WaitForNoFollowersStep waitForNoFollowersStep = new WaitForNoFollowersStep(waitForNoFollowerStepKey, generateSnapshotNameKey,\n+            client);\n+        GenerateSnapshotNameStep generateSnapshotNameStep = new GenerateSnapshotNameStep(generateSnapshotNameKey, cleanSnapshotKey);\n+        CleanupSnapshotStep cleanupSnapshotStep = new CleanupSnapshotStep(cleanSnapshotKey, takeSnapshotKey, client, snapshotRepository);\n+        TakeSnapshotStep takeSnapshotStep = new TakeSnapshotStep(takeSnapshotKey, waitForSnapshotInProgressKey, client, snapshotRepository);\n+        WaitForSnapshotInProgressStep waitForSnapshotInProgressStep = new WaitForSnapshotInProgressStep(waitForSnapshotInProgressKey,\n+            verifySnapshotStatusBranchingKey, snapshotRepository);\n+        OnAsyncWaitBranchingStep onAsyncWaitBranchingStep = new OnAsyncWaitBranchingStep(verifySnapshotStatusBranchingKey,\n+            cleanSnapshotKey, restoreFromSearchableRepoKey, client, getCheckSnapshotStatusAsyncAction(snapshotRepository));\n+        RestoreSnapshotStep restoreSnapshotStep = new RestoreSnapshotStep(restoreFromSearchableRepoKey, waitForGreenRestoredIndexKey,\n+            client, searchableRepository, RESTORED_INDEX_PREFIX);\n+        WaitForGreenIndexHealthStep waitForGreenIndexHealthStep = new WaitForGreenIndexHealthStep(waitForGreenRestoredIndexKey,\n+            copyMetadataKey, RESTORED_INDEX_PREFIX);\n+        CopyExecutionStateStep copyMetadataStep = new CopyExecutionStateStep(copyMetadataKey, copyLifecyclePolicySettingKey,\n+            RESTORED_INDEX_PREFIX, nextStepKey.getName());\n+        CopySettingsStep copySettingsStep = new CopySettingsStep(copyLifecyclePolicySettingKey, swapAliasesKey, client,\n+            RESTORED_INDEX_PREFIX, LifecycleSettings.LIFECYCLE_NAME);\n+        // sending this step to null as the restored index (which will after this step essentially be the source index) was sent to the next\n+        // key after we restored the lifecycle execution state\n+        SwapAliasesAndDeleteSourceIndexStep swapAliasesAndDeleteSourceIndexStep = new SwapAliasesAndDeleteSourceIndexStep(swapAliasesKey,\n+            null, client, RESTORED_INDEX_PREFIX);\n+\n+        return Arrays.asList(waitForNoFollowersStep, generateSnapshotNameStep, cleanupSnapshotStep, takeSnapshotStep,\n+            waitForSnapshotInProgressStep, onAsyncWaitBranchingStep, restoreSnapshotStep, waitForGreenIndexHealthStep,\n+            copyMetadataStep, copySettingsStep, swapAliasesAndDeleteSourceIndexStep);\n+    }\n+\n+    private TriConsumer<Client, IndexMetaData, AsyncWaitStep.Listener> getCheckSnapshotStatusAsyncAction(String snapshotRepository) {\n+        return (client, indexMetaData, listener) -> {\n+\n+            LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(indexMetaData);\n+\n+            String snapshotName = executionState.getSnapshotName();\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            final String indexName = indexMetaData.getIndex().getName();\n+            if (Strings.hasText(snapshotName) == false) {\n+                listener.onFailure(new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName + \"] and index \" +\n+                    \"[\" + indexName + \"]\"));\n+                return;\n+            }\n+            SnapshotsStatusRequest snapshotsStatusRequest = new SnapshotsStatusRequest(snapshotRepository, new String[]{snapshotName});\n+            client.admin().cluster().snapshotsStatus(snapshotsStatusRequest, new ActionListener<>() {\n+                @Override\n+                public void onResponse(SnapshotsStatusResponse snapshotsStatusResponse) {\n+                    List<SnapshotStatus> statuses = snapshotsStatusResponse.getSnapshots();\n+                    assert statuses.size() == 1 : \"we only requested the status info for one snapshot\";\n+                    SnapshotStatus snapshotStatus = statuses.get(0);\n+                    SnapshotsInProgress.State snapshotState = snapshotStatus.getState();\n+                    if (snapshotState.equals(SUCCESS)) {\n+                        listener.onResponse(true, null);\n+                    } else if (snapshotState.equals(ABORTED) || snapshotState.equals(FAILED) || snapshotState.equals(MISSING)) {\n+                        listener.onFailure(new SnapshotException(snapshotStatus.getSnapshot(),\n+                            \"unable to create snapshot [\" + snapshotName + \"] for index [ \" + indexName + \"] as part of policy [\" +\n+                                policyName + \"] execution\"));", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1NTk1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382655951", "bodyText": "I think we could probably switch this to just \"swap-aliases\"", "author": "dakrone", "createdAt": "2020-02-21T15:48:25Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Following a restore from snapshot operation this swaps all the aliases from the source index to the restored index and delete the\n+ * source index.\n+ */\n+public class SwapAliasesAndDeleteSourceIndexStep extends AsyncActionStep {\n+    public static final String NAME = \"swap-aliases-to-restored\";", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1NzMwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382657305", "bodyText": "There's a comment above this about inheriting everything except for the writeIndex, but this looks like we're inheriting the write index setting?", "author": "dakrone", "createdAt": "2020-02-21T15:50:52Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Following a restore from snapshot operation this swaps all the aliases from the source index to the restored index and delete the\n+ * source index.\n+ */\n+public class SwapAliasesAndDeleteSourceIndexStep extends AsyncActionStep {\n+    public static final String NAME = \"swap-aliases-to-restored\";\n+    private static final Logger logger = LogManager.getLogger(WaitForGreenIndexHealthStep.class);\n+\n+    private final String restoredIndexPrefix;\n+\n+    public SwapAliasesAndDeleteSourceIndexStep(StepKey key, StepKey nextStepKey, Client client, String restoredIndexPrefix) {\n+        super(key, nextStepKey, client);\n+        this.restoredIndexPrefix = restoredIndexPrefix;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer,\n+                              Listener listener) {\n+        String originalIndex = indexMetaData.getIndex().getName();\n+        final String restoredIndexName = restoredIndexPrefix + originalIndex;\n+        IndexMetaData restoredIndexMetaData = currentClusterState.metaData().index(restoredIndexName);\n+\n+        if (restoredIndexMetaData == null) {\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            String errorMessage = String.format(Locale.ROOT, \"restored index [%s] doesn't exist. stopping execution of lifecycle [%s] for\" +\n+                \" index [%s]\", restoredIndexName, policyName, originalIndex);\n+            logger.debug(errorMessage);\n+            listener.onFailure(new IllegalStateException(errorMessage));\n+            return;\n+        }\n+\n+        // TODO extract and reuse - also see {@link org.elasticsearch.xpack.core.ilm.ShrinkSetAliasStep}\n+        IndicesAliasesRequest aliasesRequest = new IndicesAliasesRequest()\n+            .masterNodeTimeout(getMasterTimeout(currentClusterState))\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.removeIndex().index(originalIndex))\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.add().index(restoredIndexName).alias(originalIndex));\n+        indexMetaData.getAliases().values().spliterator().forEachRemaining(aliasMetaDataObjectCursor -> {\n+            AliasMetaData aliasMetaDataToAdd = aliasMetaDataObjectCursor.value;\n+            // inherit all alias properties except `is_write_index`\n+            aliasesRequest.addAliasAction(IndicesAliasesRequest.AliasActions.add()\n+                .index(restoredIndexName).alias(aliasMetaDataToAdd.alias())\n+                .indexRouting(aliasMetaDataToAdd.indexRouting())\n+                .searchRouting(aliasMetaDataToAdd.searchRouting())\n+                .filter(aliasMetaDataToAdd.filter() == null ? null : aliasMetaDataToAdd.filter().string())\n+                .writeIndex(aliasMetaDataToAdd.writeIndex()));", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyMjM5MA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r383322390", "bodyText": "Ah, yes, I'm planning to refactor this into one component and reuse it in ShrinkSetAliasStep. It's not clear to me why we wouldn't want to inherit the write index (as we're deleting the original index in this one update). Do you know why we're skipping it in the shrink case?", "author": "andreidan", "createdAt": "2020-02-24T15:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1NzMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxMDgyMw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r383410823", "bodyText": "I don't think it's for a purposeful reason (at least I can't remember it being intentional)", "author": "dakrone", "createdAt": "2020-02-24T17:36:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1NzMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1ODI3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382658275", "bodyText": "If you want, in the future, you can use ActionListener.wrap(resp -> listener.onResponse(true), listener::onFailure) I believe, rather than a new anonymous class", "author": "dakrone", "createdAt": "2020-02-21T15:52:26Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Following a restore from snapshot operation this swaps all the aliases from the source index to the restored index and delete the\n+ * source index.\n+ */\n+public class SwapAliasesAndDeleteSourceIndexStep extends AsyncActionStep {\n+    public static final String NAME = \"swap-aliases-to-restored\";\n+    private static final Logger logger = LogManager.getLogger(WaitForGreenIndexHealthStep.class);\n+\n+    private final String restoredIndexPrefix;\n+\n+    public SwapAliasesAndDeleteSourceIndexStep(StepKey key, StepKey nextStepKey, Client client, String restoredIndexPrefix) {\n+        super(key, nextStepKey, client);\n+        this.restoredIndexPrefix = restoredIndexPrefix;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer,\n+                              Listener listener) {\n+        String originalIndex = indexMetaData.getIndex().getName();\n+        final String restoredIndexName = restoredIndexPrefix + originalIndex;\n+        IndexMetaData restoredIndexMetaData = currentClusterState.metaData().index(restoredIndexName);\n+\n+        if (restoredIndexMetaData == null) {\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            String errorMessage = String.format(Locale.ROOT, \"restored index [%s] doesn't exist. stopping execution of lifecycle [%s] for\" +\n+                \" index [%s]\", restoredIndexName, policyName, originalIndex);\n+            logger.debug(errorMessage);\n+            listener.onFailure(new IllegalStateException(errorMessage));\n+            return;\n+        }\n+\n+        // TODO extract and reuse - also see {@link org.elasticsearch.xpack.core.ilm.ShrinkSetAliasStep}\n+        IndicesAliasesRequest aliasesRequest = new IndicesAliasesRequest()\n+            .masterNodeTimeout(getMasterTimeout(currentClusterState))\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.removeIndex().index(originalIndex))\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.add().index(restoredIndexName).alias(originalIndex));\n+        indexMetaData.getAliases().values().spliterator().forEachRemaining(aliasMetaDataObjectCursor -> {\n+            AliasMetaData aliasMetaDataToAdd = aliasMetaDataObjectCursor.value;\n+            // inherit all alias properties except `is_write_index`\n+            aliasesRequest.addAliasAction(IndicesAliasesRequest.AliasActions.add()\n+                .index(restoredIndexName).alias(aliasMetaDataToAdd.alias())\n+                .indexRouting(aliasMetaDataToAdd.indexRouting())\n+                .searchRouting(aliasMetaDataToAdd.searchRouting())\n+                .filter(aliasMetaDataToAdd.filter() == null ? null : aliasMetaDataToAdd.filter().string())\n+                .writeIndex(aliasMetaDataToAdd.writeIndex()));\n+        });\n+\n+        getClient().admin().indices().aliases(aliasesRequest, new ActionListener<>() {", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1ODQ4NA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382658484", "bodyText": "We should check that the request was actually acknowledged and throw an exception if it wasn't so that it can be retried", "author": "dakrone", "createdAt": "2020-02-21T15:52:51Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Following a restore from snapshot operation this swaps all the aliases from the source index to the restored index and delete the\n+ * source index.\n+ */\n+public class SwapAliasesAndDeleteSourceIndexStep extends AsyncActionStep {\n+    public static final String NAME = \"swap-aliases-to-restored\";\n+    private static final Logger logger = LogManager.getLogger(WaitForGreenIndexHealthStep.class);\n+\n+    private final String restoredIndexPrefix;\n+\n+    public SwapAliasesAndDeleteSourceIndexStep(StepKey key, StepKey nextStepKey, Client client, String restoredIndexPrefix) {\n+        super(key, nextStepKey, client);\n+        this.restoredIndexPrefix = restoredIndexPrefix;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer,\n+                              Listener listener) {\n+        String originalIndex = indexMetaData.getIndex().getName();\n+        final String restoredIndexName = restoredIndexPrefix + originalIndex;\n+        IndexMetaData restoredIndexMetaData = currentClusterState.metaData().index(restoredIndexName);\n+\n+        if (restoredIndexMetaData == null) {\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            String errorMessage = String.format(Locale.ROOT, \"restored index [%s] doesn't exist. stopping execution of lifecycle [%s] for\" +\n+                \" index [%s]\", restoredIndexName, policyName, originalIndex);\n+            logger.debug(errorMessage);\n+            listener.onFailure(new IllegalStateException(errorMessage));\n+            return;\n+        }\n+\n+        // TODO extract and reuse - also see {@link org.elasticsearch.xpack.core.ilm.ShrinkSetAliasStep}\n+        IndicesAliasesRequest aliasesRequest = new IndicesAliasesRequest()\n+            .masterNodeTimeout(getMasterTimeout(currentClusterState))\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.removeIndex().index(originalIndex))\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.add().index(restoredIndexName).alias(originalIndex));\n+        indexMetaData.getAliases().values().spliterator().forEachRemaining(aliasMetaDataObjectCursor -> {\n+            AliasMetaData aliasMetaDataToAdd = aliasMetaDataObjectCursor.value;\n+            // inherit all alias properties except `is_write_index`\n+            aliasesRequest.addAliasAction(IndicesAliasesRequest.AliasActions.add()\n+                .index(restoredIndexName).alias(aliasMetaDataToAdd.alias())\n+                .indexRouting(aliasMetaDataToAdd.indexRouting())\n+                .searchRouting(aliasMetaDataToAdd.searchRouting())\n+                .filter(aliasMetaDataToAdd.filter() == null ? null : aliasMetaDataToAdd.filter().string())\n+                .writeIndex(aliasMetaDataToAdd.writeIndex()));\n+        });\n+\n+        getClient().admin().indices().aliases(aliasesRequest, new ActionListener<>() {\n+\n+            @Override\n+            public void onResponse(AcknowledgedResponse response) {", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1ODg0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382658846", "bodyText": "I think a better name might be CreateSnapshotStep", "author": "dakrone", "createdAt": "2020-02-21T15:53:28Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TakeSnapshotStep.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+public class TakeSnapshotStep extends AsyncActionStep {", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1OTUzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382659535", "bodyText": "I don't think we should expose this (meaning to hardcode it as false like you have), these are specific snapshots used only for searchable snapshots", "author": "dakrone", "createdAt": "2020-02-21T15:54:32Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TakeSnapshotStep.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+public class TakeSnapshotStep extends AsyncActionStep {\n+    public static final String NAME = \"take-snapshot\";\n+\n+    private final String snapshotRepository;\n+\n+    public TakeSnapshotStep(StepKey key, StepKey nextStepKey, Client client, String snapshotRepository) {\n+        super(key, nextStepKey, client);\n+        this.snapshotRepository = snapshotRepository;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer,\n+                              Listener listener) {\n+        final String indexName = indexMetaData.getIndex().getName();\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+\n+        final String snapshotName = lifecycleState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            listener.onFailure(\n+                new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName + \"] and index [\" + indexName + \"]\"));\n+            return;\n+        }\n+        CreateSnapshotRequest request = new CreateSnapshotRequest(snapshotRepository, snapshotName);\n+        // we'll not wait for the snapshot to complete in this step as the async steps are executed from threads that shouldn't perform\n+        // expensive operations (ie. clusterStateProcessed)\n+        request.waitForCompletion(false);\n+        // TODO should we expose this?\n+        request.includeGlobalState(false);", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2MDY0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382660645", "bodyText": "We should probably check the status() of the response, it's possible it could be a failure in which case I think we could retry again immediately?", "author": "dakrone", "createdAt": "2020-02-21T15:56:16Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TakeSnapshotStep.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+public class TakeSnapshotStep extends AsyncActionStep {\n+    public static final String NAME = \"take-snapshot\";\n+\n+    private final String snapshotRepository;\n+\n+    public TakeSnapshotStep(StepKey key, StepKey nextStepKey, Client client, String snapshotRepository) {\n+        super(key, nextStepKey, client);\n+        this.snapshotRepository = snapshotRepository;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer,\n+                              Listener listener) {\n+        final String indexName = indexMetaData.getIndex().getName();\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+\n+        final String snapshotName = lifecycleState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            listener.onFailure(\n+                new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName + \"] and index [\" + indexName + \"]\"));\n+            return;\n+        }\n+        CreateSnapshotRequest request = new CreateSnapshotRequest(snapshotRepository, snapshotName);\n+        // we'll not wait for the snapshot to complete in this step as the async steps are executed from threads that shouldn't perform\n+        // expensive operations (ie. clusterStateProcessed)\n+        request.waitForCompletion(false);\n+        // TODO should we expose this?\n+        request.includeGlobalState(false);\n+        getClient().admin().cluster().createSnapshot(request, new ActionListener<>() {\n+            @Override\n+            public void onResponse(CreateSnapshotResponse createSnapshotResponse) {\n+                listener.onResponse(true);", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2MTYwOA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382661608", "bodyText": "I think we could refactor the users of this class to use WaitForIndexColorStep and then we wouldn't need to add this class", "author": "dakrone", "createdAt": "2020-02-21T15:57:53Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForGreenIndexHealthStep.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.health.ClusterIndexHealth;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+/**\n+ * Optionally derives the index name using the provided prefix (if any) and waits for the status of the index to be GREEN.\n+ */\n+public class WaitForGreenIndexHealthStep extends ClusterStateWaitStep {", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3NzY3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382677673", "bodyText": "Totally, thanks for the tip. I didn't know of its existence", "author": "andreidan", "createdAt": "2020-02-21T16:26:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2MTYwOA=="}], "type": "inlineReview"}, {"oid": "a601dbf0383d7405411deafa412e8535035fc524", "url": "https://github.com/elastic/elasticsearch/commit/a601dbf0383d7405411deafa412e8535035fc524", "message": "Checkstyle", "committedDate": "2020-02-21T16:03:45Z", "type": "commit"}, {"oid": "f0a9da15368e3556022123d97a21060613734249", "url": "https://github.com/elastic/elasticsearch/commit/f0a9da15368e3556022123d97a21060613734249", "message": "Remove unused import", "committedDate": "2020-02-21T16:14:35Z", "type": "commit"}, {"oid": "dfec7c9344f703f83358c9f0e28f6cace9121a36", "url": "https://github.com/elastic/elasticsearch/commit/dfec7c9344f703f83358c9f0e28f6cace9121a36", "message": "Use WaitForIndexColorStep", "committedDate": "2020-02-24T16:04:03Z", "type": "commit"}, {"oid": "a6bc720e4b8b023a83bd765c1933f2e932a1d6d0", "url": "https://github.com/elastic/elasticsearch/commit/a6bc720e4b8b023a83bd765c1933f2e932a1d6d0", "message": "Use requireNonNull", "committedDate": "2020-02-24T16:04:13Z", "type": "commit"}, {"oid": "271fb540ae23cea9f781dba7c4b4a793814457d4", "url": "https://github.com/elastic/elasticsearch/commit/271fb540ae23cea9f781dba7c4b4a793814457d4", "message": "Refactorings and cleanups\n\n- renamed TakeSnapshotStep to CreateSnapshotStep\n- made the Create and RestoreSnapshotStep retry-able using the\nAsyncRetryDuringSnapshotActionStep infrastructure\n- CreateSnapshotStep checks the response status for internal server\nerror and fails the step in this case so we retry before we go to the\nnext steps that\u2019ll discover the snapshot was not created successfully\n- CleanupSnapshotStep reports missing repository in a more detailed way\n- CopySettingsStep copies the settings using the cluster state directly\n- GenerateSnapshotNameStep validates the snapshot name", "committedDate": "2020-02-25T17:48:06Z", "type": "commit"}, {"oid": "f6f7d29ff05d9e6ddb873f773a674f4ed2430a23", "url": "https://github.com/elastic/elasticsearch/commit/f6f7d29ff05d9e6ddb873f773a674f4ed2430a23", "message": "Make performAction final in AsyncRetryDuringSnapshotActionStep", "committedDate": "2020-02-25T17:48:06Z", "type": "commit"}, {"oid": "7075752601ee686fb756f412a1d5352152b80b5c", "url": "https://github.com/elastic/elasticsearch/commit/7075752601ee686fb756f412a1d5352152b80b5c", "message": "Add docs and redesign OnAsyncWaitBranchingStep\n\nThis redesign is meant to allow the client to specify that\nit wants to stop waiting and move to the \u201ccondition unfulfilled\u201d\nside of the branch.", "committedDate": "2020-02-26T17:23:53Z", "type": "commit"}, {"oid": "501dbaf02af9ddb40fc50c842ef423e9ceb04c2b", "url": "https://github.com/elastic/elasticsearch/commit/501dbaf02af9ddb40fc50c842ef423e9ceb04c2b", "message": "Rename BranchingStepListener onStopWaitingForCondition", "committedDate": "2020-02-27T20:25:26Z", "type": "commit"}, {"oid": "12229022b4ccbd970f54e177f07c9f775550059b", "url": "https://github.com/elastic/elasticsearch/commit/12229022b4ccbd970f54e177f07c9f775550059b", "message": "Extract and reuse the alias swap request", "committedDate": "2020-02-28T16:28:37Z", "type": "commit"}, {"oid": "faa2834adfa9b83de8925580fbf512f0b0f42ef8", "url": "https://github.com/elastic/elasticsearch/commit/faa2834adfa9b83de8925580fbf512f0b0f42ef8", "message": "Rename restoredIndexPrefix to targetIndexPrefix", "committedDate": "2020-03-02T10:19:00Z", "type": "commit"}, {"oid": "21d67cbf95514abd05f485d167bc07bdebe9005c", "url": "https://github.com/elastic/elasticsearch/commit/21d67cbf95514abd05f485d167bc07bdebe9005c", "message": "Fix tests", "committedDate": "2020-03-02T11:40:04Z", "type": "commit"}, {"oid": "7e0d5f7cecbcc377d9f3f60f55f4e1fcced43f09", "url": "https://github.com/elastic/elasticsearch/commit/7e0d5f7cecbcc377d9f3f60f55f4e1fcced43f09", "message": "Unused imports", "committedDate": "2020-03-02T11:52:16Z", "type": "commit"}, {"oid": "eafe3dea75c1f7304053a91ad54dcd12461f9b8e", "url": "https://github.com/elastic/elasticsearch/commit/eafe3dea75c1f7304053a91ad54dcd12461f9b8e", "message": "Handle null next step key", "committedDate": "2020-03-02T14:36:45Z", "type": "commit"}, {"oid": "bc91ae30a834878653b4dae73fa739bb97691621", "url": "https://github.com/elastic/elasticsearch/commit/bc91ae30a834878653b4dae73fa739bb97691621", "message": "Try with resources in test", "committedDate": "2020-03-02T15:47:30Z", "type": "commit"}, {"oid": "8520c7b11e48b9e5a5334906ebd5205ef19aaa83", "url": "https://github.com/elastic/elasticsearch/commit/8520c7b11e48b9e5a5334906ebd5205ef19aaa83", "message": "Rename originalIndex to sourceIndexName", "committedDate": "2020-03-02T16:10:27Z", "type": "commit"}, {"oid": "97356491a44242f0aed51c121bb7de87e8a492eb", "url": "https://github.com/elastic/elasticsearch/commit/97356491a44242f0aed51c121bb7de87e8a492eb", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-02T16:18:52Z", "type": "commit"}, {"oid": "d20cf52179651b72f7d23a7cc0572751bd46ce89", "url": "https://github.com/elastic/elasticsearch/commit/d20cf52179651b72f7d23a7cc0572751bd46ce89", "message": "More tests", "committedDate": "2020-03-02T17:58:55Z", "type": "commit"}, {"oid": "8a46d05f061479ddd3985e1696cae3ee47f646af", "url": "https://github.com/elastic/elasticsearch/commit/8a46d05f061479ddd3985e1696cae3ee47f646af", "message": "Add more steps tests", "committedDate": "2020-03-03T17:32:28Z", "type": "commit"}, {"oid": "12c1f5f9f174ee1f2f6969951e95d13f50f7f621", "url": "https://github.com/elastic/elasticsearch/commit/12c1f5f9f174ee1f2f6969951e95d13f50f7f621", "message": "Make method static", "committedDate": "2020-03-03T17:32:45Z", "type": "commit"}, {"oid": "3870388cf75a4f69469730dbc7ef86e633e2c9a5", "url": "https://github.com/elastic/elasticsearch/commit/3870388cf75a4f69469730dbc7ef86e633e2c9a5", "message": "Don\u2019t fail if the response isAck flag is false\n\nWe\u2019re deleting the original index as part of the alias swap so a\nretry of this step after the cluster state change has been committed\nwill fail", "committedDate": "2020-03-03T17:41:35Z", "type": "commit"}, {"oid": "d28557cde757850d0d1ccb26a2a9f28be20c5325", "url": "https://github.com/elastic/elasticsearch/commit/d28557cde757850d0d1ccb26a2a9f28be20c5325", "message": "Searchable action tests and more step tests", "committedDate": "2020-03-04T18:26:45Z", "type": "commit"}, {"oid": "357987be860954f2a61f8f77978bdc48f1a2c24e", "url": "https://github.com/elastic/elasticsearch/commit/357987be860954f2a61f8f77978bdc48f1a2c24e", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-04T18:27:42Z", "type": "commit"}, {"oid": "6960187cd4ad71d6dcf07c43b04fdfdd5790e41f", "url": "https://github.com/elastic/elasticsearch/commit/6960187cd4ad71d6dcf07c43b04fdfdd5790e41f", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-05T09:24:31Z", "type": "commit"}, {"oid": "9af943fab59b667e1a4c5d665b8bfb56ac0c0067", "url": "https://github.com/elastic/elasticsearch/commit/9af943fab59b667e1a4c5d665b8bfb56ac0c0067", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-06T15:09:18Z", "type": "commit"}, {"oid": "858e6a120a3ea037fef75049f7d3ffdcc6ab1b95", "url": "https://github.com/elastic/elasticsearch/commit/858e6a120a3ea037fef75049f7d3ffdcc6ab1b95", "message": "Store the snapshot name in the ILM execution state", "committedDate": "2020-03-06T15:09:31Z", "type": "commit"}, {"oid": "6edfcd09ea2c3b03fb90c6a60219e2163d5c9cab", "url": "https://github.com/elastic/elasticsearch/commit/6edfcd09ea2c3b03fb90c6a60219e2163d5c9cab", "message": "Remove import", "committedDate": "2020-03-06T15:32:18Z", "type": "commit"}, {"oid": "e4791b0176f446ea330ed9dd5f50e6c4ea4148dc", "url": "https://github.com/elastic/elasticsearch/commit/e4791b0176f446ea330ed9dd5f50e6c4ea4148dc", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-06T16:27:35Z", "type": "commit"}, {"oid": "63194eaca2a2028048408c4d73a5b3dff664b8b3", "url": "https://github.com/elastic/elasticsearch/commit/63194eaca2a2028048408c4d73a5b3dff664b8b3", "message": "Copy the repository and snapshot name", "committedDate": "2020-03-10T10:31:59Z", "type": "commit"}, {"oid": "a92463ffffc5370feb75b2ab2f887ca393347117", "url": "https://github.com/elastic/elasticsearch/commit/a92463ffffc5370feb75b2ab2f887ca393347117", "message": "Expose repo and snapshot name in the ILM explain response", "committedDate": "2020-03-10T10:32:39Z", "type": "commit"}, {"oid": "0f65ed7c891b97aa21678f788d7e0a89cc2c5fc1", "url": "https://github.com/elastic/elasticsearch/commit/0f65ed7c891b97aa21678f788d7e0a89cc2c5fc1", "message": "Explain lifecycle repo and snapshot in transport", "committedDate": "2020-03-10T10:44:30Z", "type": "commit"}, {"oid": "6e779b6d9b32279c76d1ebaf90bccd5d3f8d0f26", "url": "https://github.com/elastic/elasticsearch/commit/6e779b6d9b32279c76d1ebaf90bccd5d3f8d0f26", "message": "Delete action has an optional parameter delege_generated_snapshot\n\nThe parameter defaults to true but the users can configure the delete\naction to keep the snapshot they generated in the cold phase", "committedDate": "2020-03-10T11:11:22Z", "type": "commit"}, {"oid": "841f6bc6c4b050f72c0ec44421ea0bc3788803d9", "url": "https://github.com/elastic/elasticsearch/commit/841f6bc6c4b050f72c0ec44421ea0bc3788803d9", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-10T13:42:29Z", "type": "commit"}, {"oid": "da361b53ce1454a0b6116e49046d4ccf4a36af69", "url": "https://github.com/elastic/elasticsearch/commit/da361b53ce1454a0b6116e49046d4ccf4a36af69", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-11T11:51:20Z", "type": "commit"}, {"oid": "5eb524e7cb9ca567187922c2dc1bbfef5adeb87b", "url": "https://github.com/elastic/elasticsearch/commit/5eb524e7cb9ca567187922c2dc1bbfef5adeb87b", "message": "Drop the searchable repository action param", "committedDate": "2020-03-11T12:37:31Z", "type": "commit"}, {"oid": "8e8ff991dfc67ddccc8030bafe0ea8f91eeab32f", "url": "https://github.com/elastic/elasticsearch/commit/8e8ff991dfc67ddccc8030bafe0ea8f91eeab32f", "message": "Drop sys.out.println", "committedDate": "2020-03-11T14:10:30Z", "type": "commit"}, {"oid": "119c4394305056312146cbb16b2e6b5fcd49068d", "url": "https://github.com/elastic/elasticsearch/commit/119c4394305056312146cbb16b2e6b5fcd49068d", "message": "Fix docs tests", "committedDate": "2020-03-11T14:39:54Z", "type": "commit"}, {"oid": "064b4e7a27c361941fb6e0029f601debd863d61c", "url": "https://github.com/elastic/elasticsearch/commit/064b4e7a27c361941fb6e0029f601debd863d61c", "message": "BWC for DeleteAction delete generated snap flag", "committedDate": "2020-03-11T18:03:06Z", "type": "commit"}, {"oid": "1cb648098d2e7ea76987b90223d35b0bdb8225d0", "url": "https://github.com/elastic/elasticsearch/commit/1cb648098d2e7ea76987b90223d35b0bdb8225d0", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-11T19:11:57Z", "type": "commit"}, {"oid": "3a750e06c1aa2fc58851a30c4a9cf162526f11cd", "url": "https://github.com/elastic/elasticsearch/commit/3a750e06c1aa2fc58851a30c4a9cf162526f11cd", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-12T10:50:55Z", "type": "commit"}, {"oid": "0a797533739490be2395ecd6b15d3a9a87abb8f7", "url": "https://github.com/elastic/elasticsearch/commit/0a797533739490be2395ecd6b15d3a9a87abb8f7", "message": "Update settings version when copying settings", "committedDate": "2020-03-12T16:59:35Z", "type": "commit"}, {"oid": "013d4dfb800771d1c71af7920895b10095b8db54", "url": "https://github.com/elastic/elasticsearch/commit/013d4dfb800771d1c71af7920895b10095b8db54", "message": "Add test that deletes the snapshot", "committedDate": "2020-03-12T16:59:35Z", "type": "commit"}, {"oid": "aa098d27c2ecf655143dc5acf2362c369a9a51fb", "url": "https://github.com/elastic/elasticsearch/commit/aa098d27c2ecf655143dc5acf2362c369a9a51fb", "message": "Document step", "committedDate": "2020-03-12T16:59:36Z", "type": "commit"}, {"oid": "520d6bb95d77468b5303496a1336c4421ed7d86c", "url": "https://github.com/elastic/elasticsearch/commit/520d6bb95d77468b5303496a1336c4421ed7d86c", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-12T17:18:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1MzkzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r393353939", "bodyText": "Suuuper minor:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                          ClusterStateObserver observer, Listener listener) {\n          \n          \n            \n                                                ClusterStateObserver observer, Listener listener) {", "author": "dakrone", "createdAt": "2020-03-16T22:54:49Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/AsyncRetryDuringSnapshotActionStep.java", "diffHunk": "@@ -33,7 +33,7 @@ public AsyncRetryDuringSnapshotActionStep(StepKey key, StepKey nextStepKey, Clie\n     }\n \n     @Override\n-    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState,\n+    public final void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState,\n                               ClusterStateObserver observer, Listener listener) {", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1NDI3OA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r393354278", "bodyText": "Can you add a comment for future viewers for why this is not retryable? I already can't remember why it's not retryable :X", "author": "dakrone", "createdAt": "2020-03-16T22:55:47Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.repositories.RepositoryMissingException;\n+import org.elasticsearch.snapshots.SnapshotMissingException;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Deletes the snapshot designated by the repository and snapshot name present in the lifecycle execution state.\n+ */\n+public class CleanupSnapshotStep extends AsyncRetryDuringSnapshotActionStep {\n+    public static final String NAME = \"cleanup-snapshot\";\n+\n+    public CleanupSnapshotStep(StepKey key, StepKey nextStepKey, Client client) {\n+        super(key, nextStepKey, client);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return false;", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMyNjcyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r397326729", "bodyText": "I was thinking since we're retrying using the AsyncRetryDuringSnapshotActionStep we might not want to make the steps retryable as well, but on second thought I think we should (as we would indeed want to retry on rest api call failures for eg). I'll swap this to true.", "author": "andreidan", "createdAt": "2020-03-24T17:17:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1NDI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2MDUwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r393360505", "bodyText": "Another really minor nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(settingsKeys == null || settingsKeys.length == 0) {\n          \n          \n            \n                    if (settingsKeys == null || settingsKeys.length == 0) {", "author": "dakrone", "createdAt": "2020-03-16T23:07:52Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.Index;\n+\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+/**\n+ * Copy the provided settings from the source to the target index.\n+ * <p>\n+ * The target index is derived from the source index using the provided prefix.\n+ * This is useful for actions like shrink or searchable snapshot that create a new index and migrate the ILM execution from the source\n+ * to the target index.\n+ */\n+public class CopySettingsStep extends ClusterStateActionStep {\n+    public static final String NAME = \"copy-settings\";\n+\n+    private static final Logger logger = LogManager.getLogger(CopySettingsStep.class);\n+\n+    private final String[] settingsKeys;\n+    private final String indexPrefix;\n+\n+    public CopySettingsStep(StepKey key, StepKey nextStepKey, String indexPrefix, String... settingsKeys) {\n+        super(key, nextStepKey);\n+        Objects.requireNonNull(indexPrefix);\n+        Objects.requireNonNull(settingsKeys);\n+        this.indexPrefix = indexPrefix;\n+        this.settingsKeys = settingsKeys;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    public String[] getSettingsKeys() {\n+        return settingsKeys;\n+    }\n+\n+    public String getIndexPrefix() {\n+        return indexPrefix;\n+    }\n+\n+    @Override\n+    public ClusterState performAction(Index index, ClusterState clusterState) {\n+        String sourceIndexName = index.getName();\n+        IndexMetaData sourceIndexMetadata = clusterState.metaData().index(sourceIndexName);\n+        String targetIndexName = indexPrefix + sourceIndexName;\n+        IndexMetaData targetIndexMetadata = clusterState.metaData().index(targetIndexName);\n+\n+        if (sourceIndexMetadata == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), sourceIndexName);\n+            return clusterState;\n+        }\n+\n+        if (targetIndexMetadata == null) {\n+            String errorMessage = String.format(Locale.ROOT, \"index [%s] is being referenced by ILM action [%s] on step [%s] but \" +\n+                \"it doesn't exist\", targetIndexName, getKey().getAction(), getKey().getName());\n+            logger.debug(errorMessage);\n+            throw new IllegalStateException(errorMessage);\n+        }\n+\n+        if(settingsKeys == null || settingsKeys.length == 0) {", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2MTI5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r393361292", "bodyText": "I believe this needs to configure the request to only snapshot this particular index, currently this is snapshotting all indices in the cluster", "author": "dakrone", "createdAt": "2020-03-16T23:10:32Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStep.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.snapshots.SnapshotException;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Creates a snapshot of the managed index into the configured repository and snapshot name. The repository and snapshot names are expected\n+ * to be present in the lifecycle execution state (usually generated and stored by a different ILM step)\n+ */\n+public class CreateSnapshotStep extends AsyncRetryDuringSnapshotActionStep {\n+    public static final String NAME = \"create-snapshot\";\n+\n+    public CreateSnapshotStep(StepKey key, StepKey nextStepKey, Client client) {\n+        super(key, nextStepKey, client);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    void performDuringNoSnapshot(IndexMetaData indexMetaData, ClusterState currentClusterState, Listener listener) {\n+        final String indexName = indexMetaData.getIndex().getName();\n+\n+        final LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+\n+        final String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        final String snapshotRepository = lifecycleState.getSnapshotRepository();\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            listener.onFailure(new IllegalStateException(\"snapshot repository is not present for policy [\" + policyName + \"] and index [\" +\n+                indexName + \"]\"));\n+            return;\n+        }\n+\n+        final String snapshotName = lifecycleState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            listener.onFailure(\n+                new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName + \"] and index [\" + indexName + \"]\"));\n+            return;\n+        }\n+        CreateSnapshotRequest request = new CreateSnapshotRequest(snapshotRepository, snapshotName);\n+        // we'll not wait for the snapshot to complete in this step as the async steps are executed from threads that shouldn't perform\n+        // expensive operations (ie. clusterStateProcessed)\n+        request.waitForCompletion(false);\n+        request.includeGlobalState(false);\n+        request.masterNodeTimeout(getMasterTimeout(currentClusterState));\n+        getClient().admin().cluster().createSnapshot(request,", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMyODU5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r397328595", "bodyText": "Great catch @dakrone, thank you", "author": "andreidan", "createdAt": "2020-03-24T17:20:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2MTI5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2MTgyOA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r393361828", "bodyText": "I think this name would be clearer if it were \"delete_searchable_snapshot\", right now I don't want administrators to thing this means all snapshots containing this index would be deleted. What do you think?", "author": "dakrone", "createdAt": "2020-03-16T23:12:20Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/DeleteAction.java", "diffHunk": "@@ -5,38 +5,63 @@\n  */\n package org.elasticsearch.xpack.core.ilm;\n \n+import org.elasticsearch.Version;\n import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.ParseField;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n-import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n import org.elasticsearch.common.xcontent.XContentParser;\n \n import java.io.IOException;\n import java.util.Arrays;\n import java.util.List;\n+import java.util.Objects;\n \n /**\n  * A {@link LifecycleAction} which deletes the index.\n  */\n public class DeleteAction implements LifecycleAction {\n     public static final String NAME = \"delete\";\n \n-    private static final ObjectParser<DeleteAction, Void> PARSER = new ObjectParser<>(NAME, DeleteAction::new);\n+    public static final ParseField DELETE_GENERATED_SNAPSHOT_FIELD = new ParseField(\"delete_generated_snapshot\");", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzMDg4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r397330889", "bodyText": "I agree. I didn't use this name before because it was sort of tied to the searchable repository, but that's not an issue anymore.", "author": "andreidan", "createdAt": "2020-03-24T17:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2MTgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2MzAyMw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r393363023", "bodyText": "This should probably be at warn level", "author": "dakrone", "createdAt": "2020-03-16T23:16:09Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.index.Index;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.ILM_CUSTOM_METADATA_KEY;\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Generates a snapshot name for the given index and records it in the index metadata along with the provided snapshot repository.\n+ */\n+public class GenerateSnapshotNameStep extends ClusterStateActionStep {\n+\n+    public static final String NAME = \"generate-snapshot-name\";\n+\n+    private static final Logger logger = LogManager.getLogger(CreateSnapshotStep.class);\n+\n+    private static final IndexNameExpressionResolver.DateMathExpressionResolver DATE_MATH_RESOLVER =\n+        new IndexNameExpressionResolver.DateMathExpressionResolver();\n+\n+    private final String snapshotRepository;\n+\n+    public GenerateSnapshotNameStep(StepKey key, StepKey nextStepKey, String snapshotRepository) {\n+        super(key, nextStepKey);\n+        this.snapshotRepository = snapshotRepository;\n+    }\n+\n+    public String getSnapshotRepository() {\n+        return snapshotRepository;\n+    }\n+\n+    @Override\n+    public ClusterState performAction(Index index, ClusterState clusterState) {\n+        IndexMetaData indexMetaData = clusterState.metaData().index(index);\n+        if (indexMetaData == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return clusterState;\n+        }\n+\n+        ClusterState.Builder newClusterStateBuilder = ClusterState.builder(clusterState);\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+        assert lifecycleState.getSnapshotName() == null : \"index \" + index.getName() + \" should not have a snapshot generated by \" +\n+            \"the ilm policy but has \" + lifecycleState.getSnapshotName();\n+        LifecycleExecutionState.Builder newCustomData = LifecycleExecutionState.builder(lifecycleState);\n+        String policy = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        String snapshotNamePrefix = (\"<{now/d}-\" + index.getName() + \"-\" + policy + \">\").toLowerCase(Locale.ROOT);\n+        String snapshotName = generateSnapshotName(snapshotNamePrefix);\n+        ActionRequestValidationException validationException = validateGeneratedSnapshotName(snapshotNamePrefix, snapshotName);\n+        if (validationException != null) {\n+            logger.debug(\"unable to generate a snapshot name as part of policy [{}] for index [{}] due to [{}]\",", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxNTA1OA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r394015058", "bodyText": "Should we at least warn/log if the response were not acknowledged? I am thinking since this is retryable we should no-op for an existing index that contains the mounted settings, and throw an error for unacknowledged responses so we retry in ~10 minutes.", "author": "dakrone", "createdAt": "2020-03-17T22:49:03Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MountSnapshotStep.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n+\n+import java.util.Objects;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Restores the snapshot created for the designated index via the ILM policy to an index named using the provided prefix appended to the\n+ * designated index name.\n+ */\n+public class MountSnapshotStep extends AsyncRetryDuringSnapshotActionStep {\n+    public static final String NAME = \"mount-snapshot\";\n+\n+    private final String restoredIndexPrefix;\n+\n+    public MountSnapshotStep(StepKey key, StepKey nextStepKey, Client client, String restoredIndexPrefix) {\n+        super(key, nextStepKey, client);\n+        this.restoredIndexPrefix = restoredIndexPrefix;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    public String getRestoredIndexPrefix() {\n+        return restoredIndexPrefix;\n+    }\n+\n+    @Override\n+    void performDuringNoSnapshot(IndexMetaData indexMetaData, ClusterState currentClusterState, Listener listener) {\n+        final String indexName = indexMetaData.getIndex().getName();\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+\n+        String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        final String snapshotRepository = lifecycleState.getSnapshotRepository();\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            listener.onFailure(new IllegalStateException(\"snapshot repository is not present for policy [\" + policyName + \"] and index [\" +\n+                indexName + \"]\"));\n+            return;\n+        }\n+\n+        final String snapshotName = lifecycleState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            listener.onFailure(\n+                new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName + \"] and index [\" + indexName + \"]\"));\n+            return;\n+        }\n+\n+        final MountSearchableSnapshotRequest mountSearchableSnapshotRequest =\n+            new MountSearchableSnapshotRequest(restoredIndexPrefix + indexName,\n+                snapshotRepository, snapshotName, indexName, Settings.builder()\n+                .put(IndexSettings.INDEX_CHECK_ON_STARTUP.getKey(), Boolean.FALSE.toString())\n+                .build(),\n+                // we captured the index metadata when we took the snapshot. the index likely had the ILM execution state in the metadata.\n+                // if we were to restore the lifecycle.name setting, the restored index would be captured by the ILM runner and,\n+                // depending on what ILM execution state was captured at snapshot time, make it's way forward from _that_ step forward in\n+                // the ILM policy.\n+                // we'll re-set this setting on the restored index at a later step once we restored a deterministic execution state\n+                new String[]{LifecycleSettings.LIFECYCLE_NAME},\n+                // we'll not wait for the snapshot to complete in this step as the async steps are executed from threads that shouldn't\n+                // perform expensive operations (ie. clusterStateProcessed)\n+                false);\n+        getClient().execute(MountSearchableSnapshotAction.INSTANCE, mountSearchableSnapshotRequest,\n+            ActionListener.wrap(response -> listener.onResponse(true), listener::onFailure));", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxNjQ5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r394016499", "bodyText": "I believe this should be snapshot_repository since we use underscores for our JSON parsing", "author": "dakrone", "createdAt": "2020-03-17T22:53:11Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.OnAsyncWaitBranchingStep.BranchingStepListener;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable-snapshot\";\n+\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot-repository\");", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxNzc0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r394017749", "bodyText": "I might be paranoid here, but can you add some logging to this method (and onResponse) at trace or debug level so we have some feedback in the event we need to debug this?", "author": "dakrone", "createdAt": "2020-03-17T22:56:44Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/OnAsyncWaitBranchingStep.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+\n+import java.util.Objects;\n+\n+/**\n+ * This step changes its {@link #getNextStepKey()} depending on the result of an {@link AsyncWaitStep}.\n+ * <p>\n+ * The next step key will point towards the \"wait action fulfilled\" step when the condition of the async action is met, and towards the\n+ * \"wait action unfulfilled\" step when the client instructs they'd like to stop waiting for the condition using the\n+ * {@link BranchingStepListener#onStopWaitingAndMoveToNextKey(ToXContentObject)}.\n+ * <p>\n+ * If the async action that's branching the execution results in a failure, the {@link #getNextStepKey()} is not set (as ILM would move\n+ * into the {@link ErrorStep} step).\n+ */\n+public class OnAsyncWaitBranchingStep extends AsyncWaitStep {\n+    public static final String NAME = \"async-branch\";\n+\n+    private StepKey nextStepKeyUnfulfilledWaitAction;\n+    private StepKey nextStepKeyFulfilledWaitAction;\n+    private TriConsumer<Client, IndexMetaData, BranchingStepListener> asyncWaitAction;\n+    private SetOnce<Boolean> onCompleteConditionMet;\n+\n+    /**\n+     * {@link BranchingStep} is a step whose next step is based on the {@link #asyncWaitAction} condition being met or not.\n+     *\n+     * @param key                                the step's key\n+     * @param nextStepKeyUnfulfilledWaitAction the key of the step to run if the client decides to stop waiting for the condition to be\n+     *                                           via {@link BranchingStepListener#onStopWaitingAndMoveToNextKey(ToXContentObject)}\n+     * @param nextStepKeyFulfilledWaitAction   the key of the step to run if the {@link #asyncWaitAction} condition is met\n+     * @param asyncWaitAction                    the action to execute, would usually be similar to an instance of {@link AsyncWaitStep}\n+     *                                           but the user has the option to decide to stop waiting for the condition to be fulfilled\n+     */\n+    public OnAsyncWaitBranchingStep(StepKey key, StepKey nextStepKeyUnfulfilledWaitAction, StepKey nextStepKeyFulfilledWaitAction,\n+                                    Client client, TriConsumer<Client, IndexMetaData, BranchingStepListener> asyncWaitAction) {\n+        // super.nextStepKey is set to null since it is not used by this step\n+        super(key, null, client);\n+        this.nextStepKeyUnfulfilledWaitAction = nextStepKeyUnfulfilledWaitAction;\n+        this.nextStepKeyFulfilledWaitAction = nextStepKeyFulfilledWaitAction;\n+        this.asyncWaitAction = asyncWaitAction;\n+        this.onCompleteConditionMet = new SetOnce<>();\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void evaluateCondition(IndexMetaData indexMetaData, Listener listener, TimeValue masterTimeout) {\n+        asyncWaitAction.apply(getClient(), indexMetaData, new BranchingStepListener() {\n+            @Override\n+            public void onResponse(boolean conditionMet, ToXContentObject informationContext) {\n+                onCompleteConditionMet.set(true);\n+                listener.onResponse(conditionMet, informationContext);\n+            }\n+\n+            @Override\n+            public void onFailure(Exception e) {\n+                listener.onFailure(e);\n+            }\n+\n+            @Override\n+            public void onStopWaitingAndMoveToNextKey(ToXContentObject informationContext) {\n+                onCompleteConditionMet.set(false);\n+                // to the \"outside\" world the condition was met (as the user decided so) and we're ready to move to the next step.\n+                // {@link #getNextStepKey} will now point towards {@link #nextStepKeyUnfulfilledWaitAction)\n+                listener.onResponse(true, informationContext);", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxOTIzMA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r394019230", "bodyText": "Can you add a comment about the use of nextStepKey here? I had to look at the code a couple of times to see why it should be null in some cases (now I understand, but a comment would be useful)", "author": "dakrone", "createdAt": "2020-03-17T23:00:47Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.OnAsyncWaitBranchingStep.BranchingStepListener;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable-snapshot\";\n+\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot-repository\");\n+\n+    public static final String RESTORED_INDEX_PREFIX = \"restored-\";\n+\n+    private static final ConstructingObjectParser<SearchableSnapshotAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new SearchableSnapshotAction((String) a[0]));\n+\n+    static {\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), SNAPSHOT_REPOSITORY);\n+    }\n+\n+    public static SearchableSnapshotAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    private final String snapshotRepository;\n+\n+    public SearchableSnapshotAction(String snapshotRepository) {\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            throw new IllegalArgumentException(\"the snapshot repository must be specified\");\n+        }\n+        this.snapshotRepository = snapshotRepository;\n+    }\n+\n+    public SearchableSnapshotAction(StreamInput in) throws IOException {\n+        this(in.readString());\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        StepKey waitForNoFollowerStepKey = new StepKey(phase, NAME, WaitForNoFollowersStep.NAME);\n+        StepKey generateSnapshotNameKey = new StepKey(phase, NAME, GenerateSnapshotNameStep.NAME);\n+        StepKey cleanSnapshotKey = new StepKey(phase, NAME, CleanupSnapshotStep.NAME);\n+        StepKey createSnapshotKey = new StepKey(phase, NAME, CreateSnapshotStep.NAME);\n+        StepKey waitForSnapshotInProgressKey = new StepKey(phase, NAME, WaitForSnapshotInProgressStep.NAME);\n+        StepKey verifySnapshotStatusBranchingKey = new StepKey(phase, NAME, OnAsyncWaitBranchingStep.NAME);\n+        StepKey mountSnapshotKey = new StepKey(phase, NAME, MountSnapshotStep.NAME);\n+        StepKey waitForGreenRestoredIndexKey = new StepKey(phase, NAME, WaitForIndexColorStep.NAME);\n+        StepKey copyMetadataKey = new StepKey(phase, NAME, CopyExecutionStateStep.NAME);\n+        StepKey copyLifecyclePolicySettingKey = new StepKey(phase, NAME, CopySettingsStep.NAME);\n+        StepKey swapAliasesKey = new StepKey(phase, NAME, SwapAliasesAndDeleteSourceIndexStep.NAME);\n+\n+        WaitForNoFollowersStep waitForNoFollowersStep = new WaitForNoFollowersStep(waitForNoFollowerStepKey, generateSnapshotNameKey,\n+            client);\n+        GenerateSnapshotNameStep generateSnapshotNameStep = new GenerateSnapshotNameStep(generateSnapshotNameKey, cleanSnapshotKey,\n+            snapshotRepository);\n+        CleanupSnapshotStep cleanupSnapshotStep = new CleanupSnapshotStep(cleanSnapshotKey, createSnapshotKey, client);\n+        CreateSnapshotStep createSnapshotStep = new CreateSnapshotStep(createSnapshotKey, waitForSnapshotInProgressKey, client);\n+        WaitForSnapshotInProgressStep waitForSnapshotInProgressStep = new WaitForSnapshotInProgressStep(waitForSnapshotInProgressKey,\n+            verifySnapshotStatusBranchingKey);\n+        OnAsyncWaitBranchingStep onAsyncWaitBranchingStep = new OnAsyncWaitBranchingStep(verifySnapshotStatusBranchingKey,\n+            cleanSnapshotKey, mountSnapshotKey, client, getCheckSnapshotStatusAsyncAction());\n+        MountSnapshotStep mountSnapshotStep = new MountSnapshotStep(mountSnapshotKey, waitForGreenRestoredIndexKey,\n+            client, RESTORED_INDEX_PREFIX);\n+        WaitForIndexColorStep waitForGreenIndexHealthStep = new WaitForIndexColorStep(waitForGreenRestoredIndexKey,\n+            copyMetadataKey, ClusterHealthStatus.GREEN, RESTORED_INDEX_PREFIX);\n+        CopyExecutionStateStep copyMetadataStep = new CopyExecutionStateStep(copyMetadataKey, copyLifecyclePolicySettingKey,\n+            RESTORED_INDEX_PREFIX, nextStepKey != null ? nextStepKey.getName() : \"null\");", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxOTg4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r394019883", "bodyText": "The grammar is a little weird:\nsnapshot [foo] for index [bar] as part of policy [baz] is cannot complete as it is in state [FAILED]\n\nThe \"is cannot complete\" needs the \"is\" taken out I think", "author": "dakrone", "createdAt": "2020-03-17T23:02:52Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.OnAsyncWaitBranchingStep.BranchingStepListener;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable-snapshot\";\n+\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot-repository\");\n+\n+    public static final String RESTORED_INDEX_PREFIX = \"restored-\";\n+\n+    private static final ConstructingObjectParser<SearchableSnapshotAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new SearchableSnapshotAction((String) a[0]));\n+\n+    static {\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), SNAPSHOT_REPOSITORY);\n+    }\n+\n+    public static SearchableSnapshotAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    private final String snapshotRepository;\n+\n+    public SearchableSnapshotAction(String snapshotRepository) {\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            throw new IllegalArgumentException(\"the snapshot repository must be specified\");\n+        }\n+        this.snapshotRepository = snapshotRepository;\n+    }\n+\n+    public SearchableSnapshotAction(StreamInput in) throws IOException {\n+        this(in.readString());\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        StepKey waitForNoFollowerStepKey = new StepKey(phase, NAME, WaitForNoFollowersStep.NAME);\n+        StepKey generateSnapshotNameKey = new StepKey(phase, NAME, GenerateSnapshotNameStep.NAME);\n+        StepKey cleanSnapshotKey = new StepKey(phase, NAME, CleanupSnapshotStep.NAME);\n+        StepKey createSnapshotKey = new StepKey(phase, NAME, CreateSnapshotStep.NAME);\n+        StepKey waitForSnapshotInProgressKey = new StepKey(phase, NAME, WaitForSnapshotInProgressStep.NAME);\n+        StepKey verifySnapshotStatusBranchingKey = new StepKey(phase, NAME, OnAsyncWaitBranchingStep.NAME);\n+        StepKey mountSnapshotKey = new StepKey(phase, NAME, MountSnapshotStep.NAME);\n+        StepKey waitForGreenRestoredIndexKey = new StepKey(phase, NAME, WaitForIndexColorStep.NAME);\n+        StepKey copyMetadataKey = new StepKey(phase, NAME, CopyExecutionStateStep.NAME);\n+        StepKey copyLifecyclePolicySettingKey = new StepKey(phase, NAME, CopySettingsStep.NAME);\n+        StepKey swapAliasesKey = new StepKey(phase, NAME, SwapAliasesAndDeleteSourceIndexStep.NAME);\n+\n+        WaitForNoFollowersStep waitForNoFollowersStep = new WaitForNoFollowersStep(waitForNoFollowerStepKey, generateSnapshotNameKey,\n+            client);\n+        GenerateSnapshotNameStep generateSnapshotNameStep = new GenerateSnapshotNameStep(generateSnapshotNameKey, cleanSnapshotKey,\n+            snapshotRepository);\n+        CleanupSnapshotStep cleanupSnapshotStep = new CleanupSnapshotStep(cleanSnapshotKey, createSnapshotKey, client);\n+        CreateSnapshotStep createSnapshotStep = new CreateSnapshotStep(createSnapshotKey, waitForSnapshotInProgressKey, client);\n+        WaitForSnapshotInProgressStep waitForSnapshotInProgressStep = new WaitForSnapshotInProgressStep(waitForSnapshotInProgressKey,\n+            verifySnapshotStatusBranchingKey);\n+        OnAsyncWaitBranchingStep onAsyncWaitBranchingStep = new OnAsyncWaitBranchingStep(verifySnapshotStatusBranchingKey,\n+            cleanSnapshotKey, mountSnapshotKey, client, getCheckSnapshotStatusAsyncAction());\n+        MountSnapshotStep mountSnapshotStep = new MountSnapshotStep(mountSnapshotKey, waitForGreenRestoredIndexKey,\n+            client, RESTORED_INDEX_PREFIX);\n+        WaitForIndexColorStep waitForGreenIndexHealthStep = new WaitForIndexColorStep(waitForGreenRestoredIndexKey,\n+            copyMetadataKey, ClusterHealthStatus.GREEN, RESTORED_INDEX_PREFIX);\n+        CopyExecutionStateStep copyMetadataStep = new CopyExecutionStateStep(copyMetadataKey, copyLifecyclePolicySettingKey,\n+            RESTORED_INDEX_PREFIX, nextStepKey != null ? nextStepKey.getName() : \"null\");\n+        CopySettingsStep copySettingsStep = new CopySettingsStep(copyLifecyclePolicySettingKey, swapAliasesKey, RESTORED_INDEX_PREFIX,\n+            LifecycleSettings.LIFECYCLE_NAME);\n+        // sending this step to null as the restored index (which will after this step essentially be the source index) was sent to the next\n+        // key after we restored the lifecycle execution state\n+        SwapAliasesAndDeleteSourceIndexStep swapAliasesAndDeleteSourceIndexStep = new SwapAliasesAndDeleteSourceIndexStep(swapAliasesKey,\n+            null, client, RESTORED_INDEX_PREFIX);\n+\n+        return Arrays.asList(waitForNoFollowersStep, generateSnapshotNameStep, cleanupSnapshotStep, createSnapshotStep,\n+            waitForSnapshotInProgressStep, onAsyncWaitBranchingStep, mountSnapshotStep, waitForGreenIndexHealthStep,\n+            copyMetadataStep, copySettingsStep, swapAliasesAndDeleteSourceIndexStep);\n+    }\n+\n+    /**\n+     * Creates a consumer to evaluate the ILM generated snapshot status in the provided snapshotRepository in an async way, akin to an\n+     * equivalent {@link AsyncWaitStep} implementation.\n+     */\n+    static TriConsumer<Client, IndexMetaData, BranchingStepListener> getCheckSnapshotStatusAsyncAction() {\n+        return (client, indexMetaData, branchingStepListener) -> {\n+\n+            LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(indexMetaData);\n+\n+            String snapshotName = executionState.getSnapshotName();\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            final String indexName = indexMetaData.getIndex().getName();\n+            final String repositoryName = executionState.getSnapshotRepository();\n+            if (Strings.hasText(repositoryName) == false) {\n+                branchingStepListener.onFailure(\n+                    new IllegalStateException(\"snapshot repository is not present for policy [\" + policyName + \"] and index [\" + indexName +\n+                        \"]\"));\n+                return;\n+            }\n+            if (Strings.hasText(snapshotName) == false) {\n+                branchingStepListener.onFailure(new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName +\n+                    \"] and index [\" + indexName + \"]\"));\n+                return;\n+            }\n+            SnapshotsStatusRequest snapshotsStatusRequest = new SnapshotsStatusRequest(repositoryName, new String[]{snapshotName});\n+            client.admin().cluster().snapshotsStatus(snapshotsStatusRequest, new ActionListener<>() {\n+                @Override\n+                public void onResponse(SnapshotsStatusResponse snapshotsStatusResponse) {\n+                    List<SnapshotStatus> statuses = snapshotsStatusResponse.getSnapshots();\n+                    assert statuses.size() == 1 : \"we only requested the status info for one snapshot\";\n+                    SnapshotStatus snapshotStatus = statuses.get(0);\n+                    SnapshotsInProgress.State snapshotState = snapshotStatus.getState();\n+                    if (snapshotState.equals(SUCCESS)) {\n+                        branchingStepListener.onResponse(true, null);\n+                    } else if (snapshotState.equals(ABORTED) || snapshotState.equals(FAILED) || snapshotState.equals(MISSING)) {\n+                        branchingStepListener.onStopWaitingAndMoveToNextKey(new Info(\n+                            \"snapshot [\" + snapshotName + \"] for index [ \" + indexName + \"] as part of policy [\" + policyName + \"] is \" +\n+                                \"cannot complete as it is in state [\" + snapshotState + \"]\"));", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAyMDM2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r394020362", "bodyText": "This should include INCOMPATIBLE and PARTIAL, otherwise we'd spin forever in those cases", "author": "dakrone", "createdAt": "2020-03-17T23:04:10Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.OnAsyncWaitBranchingStep.BranchingStepListener;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable-snapshot\";\n+\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot-repository\");\n+\n+    public static final String RESTORED_INDEX_PREFIX = \"restored-\";\n+\n+    private static final ConstructingObjectParser<SearchableSnapshotAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new SearchableSnapshotAction((String) a[0]));\n+\n+    static {\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), SNAPSHOT_REPOSITORY);\n+    }\n+\n+    public static SearchableSnapshotAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    private final String snapshotRepository;\n+\n+    public SearchableSnapshotAction(String snapshotRepository) {\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            throw new IllegalArgumentException(\"the snapshot repository must be specified\");\n+        }\n+        this.snapshotRepository = snapshotRepository;\n+    }\n+\n+    public SearchableSnapshotAction(StreamInput in) throws IOException {\n+        this(in.readString());\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        StepKey waitForNoFollowerStepKey = new StepKey(phase, NAME, WaitForNoFollowersStep.NAME);\n+        StepKey generateSnapshotNameKey = new StepKey(phase, NAME, GenerateSnapshotNameStep.NAME);\n+        StepKey cleanSnapshotKey = new StepKey(phase, NAME, CleanupSnapshotStep.NAME);\n+        StepKey createSnapshotKey = new StepKey(phase, NAME, CreateSnapshotStep.NAME);\n+        StepKey waitForSnapshotInProgressKey = new StepKey(phase, NAME, WaitForSnapshotInProgressStep.NAME);\n+        StepKey verifySnapshotStatusBranchingKey = new StepKey(phase, NAME, OnAsyncWaitBranchingStep.NAME);\n+        StepKey mountSnapshotKey = new StepKey(phase, NAME, MountSnapshotStep.NAME);\n+        StepKey waitForGreenRestoredIndexKey = new StepKey(phase, NAME, WaitForIndexColorStep.NAME);\n+        StepKey copyMetadataKey = new StepKey(phase, NAME, CopyExecutionStateStep.NAME);\n+        StepKey copyLifecyclePolicySettingKey = new StepKey(phase, NAME, CopySettingsStep.NAME);\n+        StepKey swapAliasesKey = new StepKey(phase, NAME, SwapAliasesAndDeleteSourceIndexStep.NAME);\n+\n+        WaitForNoFollowersStep waitForNoFollowersStep = new WaitForNoFollowersStep(waitForNoFollowerStepKey, generateSnapshotNameKey,\n+            client);\n+        GenerateSnapshotNameStep generateSnapshotNameStep = new GenerateSnapshotNameStep(generateSnapshotNameKey, cleanSnapshotKey,\n+            snapshotRepository);\n+        CleanupSnapshotStep cleanupSnapshotStep = new CleanupSnapshotStep(cleanSnapshotKey, createSnapshotKey, client);\n+        CreateSnapshotStep createSnapshotStep = new CreateSnapshotStep(createSnapshotKey, waitForSnapshotInProgressKey, client);\n+        WaitForSnapshotInProgressStep waitForSnapshotInProgressStep = new WaitForSnapshotInProgressStep(waitForSnapshotInProgressKey,\n+            verifySnapshotStatusBranchingKey);\n+        OnAsyncWaitBranchingStep onAsyncWaitBranchingStep = new OnAsyncWaitBranchingStep(verifySnapshotStatusBranchingKey,\n+            cleanSnapshotKey, mountSnapshotKey, client, getCheckSnapshotStatusAsyncAction());\n+        MountSnapshotStep mountSnapshotStep = new MountSnapshotStep(mountSnapshotKey, waitForGreenRestoredIndexKey,\n+            client, RESTORED_INDEX_PREFIX);\n+        WaitForIndexColorStep waitForGreenIndexHealthStep = new WaitForIndexColorStep(waitForGreenRestoredIndexKey,\n+            copyMetadataKey, ClusterHealthStatus.GREEN, RESTORED_INDEX_PREFIX);\n+        CopyExecutionStateStep copyMetadataStep = new CopyExecutionStateStep(copyMetadataKey, copyLifecyclePolicySettingKey,\n+            RESTORED_INDEX_PREFIX, nextStepKey != null ? nextStepKey.getName() : \"null\");\n+        CopySettingsStep copySettingsStep = new CopySettingsStep(copyLifecyclePolicySettingKey, swapAliasesKey, RESTORED_INDEX_PREFIX,\n+            LifecycleSettings.LIFECYCLE_NAME);\n+        // sending this step to null as the restored index (which will after this step essentially be the source index) was sent to the next\n+        // key after we restored the lifecycle execution state\n+        SwapAliasesAndDeleteSourceIndexStep swapAliasesAndDeleteSourceIndexStep = new SwapAliasesAndDeleteSourceIndexStep(swapAliasesKey,\n+            null, client, RESTORED_INDEX_PREFIX);\n+\n+        return Arrays.asList(waitForNoFollowersStep, generateSnapshotNameStep, cleanupSnapshotStep, createSnapshotStep,\n+            waitForSnapshotInProgressStep, onAsyncWaitBranchingStep, mountSnapshotStep, waitForGreenIndexHealthStep,\n+            copyMetadataStep, copySettingsStep, swapAliasesAndDeleteSourceIndexStep);\n+    }\n+\n+    /**\n+     * Creates a consumer to evaluate the ILM generated snapshot status in the provided snapshotRepository in an async way, akin to an\n+     * equivalent {@link AsyncWaitStep} implementation.\n+     */\n+    static TriConsumer<Client, IndexMetaData, BranchingStepListener> getCheckSnapshotStatusAsyncAction() {\n+        return (client, indexMetaData, branchingStepListener) -> {\n+\n+            LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(indexMetaData);\n+\n+            String snapshotName = executionState.getSnapshotName();\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            final String indexName = indexMetaData.getIndex().getName();\n+            final String repositoryName = executionState.getSnapshotRepository();\n+            if (Strings.hasText(repositoryName) == false) {\n+                branchingStepListener.onFailure(\n+                    new IllegalStateException(\"snapshot repository is not present for policy [\" + policyName + \"] and index [\" + indexName +\n+                        \"]\"));\n+                return;\n+            }\n+            if (Strings.hasText(snapshotName) == false) {\n+                branchingStepListener.onFailure(new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName +\n+                    \"] and index [\" + indexName + \"]\"));\n+                return;\n+            }\n+            SnapshotsStatusRequest snapshotsStatusRequest = new SnapshotsStatusRequest(repositoryName, new String[]{snapshotName});\n+            client.admin().cluster().snapshotsStatus(snapshotsStatusRequest, new ActionListener<>() {\n+                @Override\n+                public void onResponse(SnapshotsStatusResponse snapshotsStatusResponse) {\n+                    List<SnapshotStatus> statuses = snapshotsStatusResponse.getSnapshots();\n+                    assert statuses.size() == 1 : \"we only requested the status info for one snapshot\";\n+                    SnapshotStatus snapshotStatus = statuses.get(0);\n+                    SnapshotsInProgress.State snapshotState = snapshotStatus.getState();\n+                    if (snapshotState.equals(SUCCESS)) {\n+                        branchingStepListener.onResponse(true, null);\n+                    } else if (snapshotState.equals(ABORTED) || snapshotState.equals(FAILED) || snapshotState.equals(MISSING)) {", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAyMDU4NA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r394020584", "bodyText": "This should explicitly check for IN_PROGRESS, it might be easier to flip the if statement to only check for SUCCESS or IN_PROGRESS and do the onStopWaitingAndMoveToNextKey if there is any other state", "author": "dakrone", "createdAt": "2020-03-17T23:04:56Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.OnAsyncWaitBranchingStep.BranchingStepListener;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable-snapshot\";\n+\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot-repository\");\n+\n+    public static final String RESTORED_INDEX_PREFIX = \"restored-\";\n+\n+    private static final ConstructingObjectParser<SearchableSnapshotAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new SearchableSnapshotAction((String) a[0]));\n+\n+    static {\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), SNAPSHOT_REPOSITORY);\n+    }\n+\n+    public static SearchableSnapshotAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    private final String snapshotRepository;\n+\n+    public SearchableSnapshotAction(String snapshotRepository) {\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            throw new IllegalArgumentException(\"the snapshot repository must be specified\");\n+        }\n+        this.snapshotRepository = snapshotRepository;\n+    }\n+\n+    public SearchableSnapshotAction(StreamInput in) throws IOException {\n+        this(in.readString());\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        StepKey waitForNoFollowerStepKey = new StepKey(phase, NAME, WaitForNoFollowersStep.NAME);\n+        StepKey generateSnapshotNameKey = new StepKey(phase, NAME, GenerateSnapshotNameStep.NAME);\n+        StepKey cleanSnapshotKey = new StepKey(phase, NAME, CleanupSnapshotStep.NAME);\n+        StepKey createSnapshotKey = new StepKey(phase, NAME, CreateSnapshotStep.NAME);\n+        StepKey waitForSnapshotInProgressKey = new StepKey(phase, NAME, WaitForSnapshotInProgressStep.NAME);\n+        StepKey verifySnapshotStatusBranchingKey = new StepKey(phase, NAME, OnAsyncWaitBranchingStep.NAME);\n+        StepKey mountSnapshotKey = new StepKey(phase, NAME, MountSnapshotStep.NAME);\n+        StepKey waitForGreenRestoredIndexKey = new StepKey(phase, NAME, WaitForIndexColorStep.NAME);\n+        StepKey copyMetadataKey = new StepKey(phase, NAME, CopyExecutionStateStep.NAME);\n+        StepKey copyLifecyclePolicySettingKey = new StepKey(phase, NAME, CopySettingsStep.NAME);\n+        StepKey swapAliasesKey = new StepKey(phase, NAME, SwapAliasesAndDeleteSourceIndexStep.NAME);\n+\n+        WaitForNoFollowersStep waitForNoFollowersStep = new WaitForNoFollowersStep(waitForNoFollowerStepKey, generateSnapshotNameKey,\n+            client);\n+        GenerateSnapshotNameStep generateSnapshotNameStep = new GenerateSnapshotNameStep(generateSnapshotNameKey, cleanSnapshotKey,\n+            snapshotRepository);\n+        CleanupSnapshotStep cleanupSnapshotStep = new CleanupSnapshotStep(cleanSnapshotKey, createSnapshotKey, client);\n+        CreateSnapshotStep createSnapshotStep = new CreateSnapshotStep(createSnapshotKey, waitForSnapshotInProgressKey, client);\n+        WaitForSnapshotInProgressStep waitForSnapshotInProgressStep = new WaitForSnapshotInProgressStep(waitForSnapshotInProgressKey,\n+            verifySnapshotStatusBranchingKey);\n+        OnAsyncWaitBranchingStep onAsyncWaitBranchingStep = new OnAsyncWaitBranchingStep(verifySnapshotStatusBranchingKey,\n+            cleanSnapshotKey, mountSnapshotKey, client, getCheckSnapshotStatusAsyncAction());\n+        MountSnapshotStep mountSnapshotStep = new MountSnapshotStep(mountSnapshotKey, waitForGreenRestoredIndexKey,\n+            client, RESTORED_INDEX_PREFIX);\n+        WaitForIndexColorStep waitForGreenIndexHealthStep = new WaitForIndexColorStep(waitForGreenRestoredIndexKey,\n+            copyMetadataKey, ClusterHealthStatus.GREEN, RESTORED_INDEX_PREFIX);\n+        CopyExecutionStateStep copyMetadataStep = new CopyExecutionStateStep(copyMetadataKey, copyLifecyclePolicySettingKey,\n+            RESTORED_INDEX_PREFIX, nextStepKey != null ? nextStepKey.getName() : \"null\");\n+        CopySettingsStep copySettingsStep = new CopySettingsStep(copyLifecyclePolicySettingKey, swapAliasesKey, RESTORED_INDEX_PREFIX,\n+            LifecycleSettings.LIFECYCLE_NAME);\n+        // sending this step to null as the restored index (which will after this step essentially be the source index) was sent to the next\n+        // key after we restored the lifecycle execution state\n+        SwapAliasesAndDeleteSourceIndexStep swapAliasesAndDeleteSourceIndexStep = new SwapAliasesAndDeleteSourceIndexStep(swapAliasesKey,\n+            null, client, RESTORED_INDEX_PREFIX);\n+\n+        return Arrays.asList(waitForNoFollowersStep, generateSnapshotNameStep, cleanupSnapshotStep, createSnapshotStep,\n+            waitForSnapshotInProgressStep, onAsyncWaitBranchingStep, mountSnapshotStep, waitForGreenIndexHealthStep,\n+            copyMetadataStep, copySettingsStep, swapAliasesAndDeleteSourceIndexStep);\n+    }\n+\n+    /**\n+     * Creates a consumer to evaluate the ILM generated snapshot status in the provided snapshotRepository in an async way, akin to an\n+     * equivalent {@link AsyncWaitStep} implementation.\n+     */\n+    static TriConsumer<Client, IndexMetaData, BranchingStepListener> getCheckSnapshotStatusAsyncAction() {\n+        return (client, indexMetaData, branchingStepListener) -> {\n+\n+            LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(indexMetaData);\n+\n+            String snapshotName = executionState.getSnapshotName();\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            final String indexName = indexMetaData.getIndex().getName();\n+            final String repositoryName = executionState.getSnapshotRepository();\n+            if (Strings.hasText(repositoryName) == false) {\n+                branchingStepListener.onFailure(\n+                    new IllegalStateException(\"snapshot repository is not present for policy [\" + policyName + \"] and index [\" + indexName +\n+                        \"]\"));\n+                return;\n+            }\n+            if (Strings.hasText(snapshotName) == false) {\n+                branchingStepListener.onFailure(new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName +\n+                    \"] and index [\" + indexName + \"]\"));\n+                return;\n+            }\n+            SnapshotsStatusRequest snapshotsStatusRequest = new SnapshotsStatusRequest(repositoryName, new String[]{snapshotName});\n+            client.admin().cluster().snapshotsStatus(snapshotsStatusRequest, new ActionListener<>() {\n+                @Override\n+                public void onResponse(SnapshotsStatusResponse snapshotsStatusResponse) {\n+                    List<SnapshotStatus> statuses = snapshotsStatusResponse.getSnapshots();\n+                    assert statuses.size() == 1 : \"we only requested the status info for one snapshot\";\n+                    SnapshotStatus snapshotStatus = statuses.get(0);\n+                    SnapshotsInProgress.State snapshotState = snapshotStatus.getState();\n+                    if (snapshotState.equals(SUCCESS)) {\n+                        branchingStepListener.onResponse(true, null);\n+                    } else if (snapshotState.equals(ABORTED) || snapshotState.equals(FAILED) || snapshotState.equals(MISSING)) {\n+                        branchingStepListener.onStopWaitingAndMoveToNextKey(new Info(\n+                            \"snapshot [\" + snapshotName + \"] for index [ \" + indexName + \"] as part of policy [\" + policyName + \"] is \" +\n+                                \"cannot complete as it is in state [\" + snapshotState + \"]\"));\n+                    } else {", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1Nzg3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395357872", "bodyText": "This isn't a WaitForIndexColorStep.Info class, I think this needs to be changed to just Info", "author": "dakrone", "createdAt": "2020-03-19T22:37:15Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.OnAsyncWaitBranchingStep.BranchingStepListener;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable-snapshot\";\n+\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot-repository\");\n+\n+    public static final String RESTORED_INDEX_PREFIX = \"restored-\";\n+\n+    private static final ConstructingObjectParser<SearchableSnapshotAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new SearchableSnapshotAction((String) a[0]));\n+\n+    static {\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), SNAPSHOT_REPOSITORY);\n+    }\n+\n+    public static SearchableSnapshotAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    private final String snapshotRepository;\n+\n+    public SearchableSnapshotAction(String snapshotRepository) {\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            throw new IllegalArgumentException(\"the snapshot repository must be specified\");\n+        }\n+        this.snapshotRepository = snapshotRepository;\n+    }\n+\n+    public SearchableSnapshotAction(StreamInput in) throws IOException {\n+        this(in.readString());\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        StepKey waitForNoFollowerStepKey = new StepKey(phase, NAME, WaitForNoFollowersStep.NAME);\n+        StepKey generateSnapshotNameKey = new StepKey(phase, NAME, GenerateSnapshotNameStep.NAME);\n+        StepKey cleanSnapshotKey = new StepKey(phase, NAME, CleanupSnapshotStep.NAME);\n+        StepKey createSnapshotKey = new StepKey(phase, NAME, CreateSnapshotStep.NAME);\n+        StepKey waitForSnapshotInProgressKey = new StepKey(phase, NAME, WaitForSnapshotInProgressStep.NAME);\n+        StepKey verifySnapshotStatusBranchingKey = new StepKey(phase, NAME, OnAsyncWaitBranchingStep.NAME);\n+        StepKey mountSnapshotKey = new StepKey(phase, NAME, MountSnapshotStep.NAME);\n+        StepKey waitForGreenRestoredIndexKey = new StepKey(phase, NAME, WaitForIndexColorStep.NAME);\n+        StepKey copyMetadataKey = new StepKey(phase, NAME, CopyExecutionStateStep.NAME);\n+        StepKey copyLifecyclePolicySettingKey = new StepKey(phase, NAME, CopySettingsStep.NAME);\n+        StepKey swapAliasesKey = new StepKey(phase, NAME, SwapAliasesAndDeleteSourceIndexStep.NAME);\n+\n+        WaitForNoFollowersStep waitForNoFollowersStep = new WaitForNoFollowersStep(waitForNoFollowerStepKey, generateSnapshotNameKey,\n+            client);\n+        GenerateSnapshotNameStep generateSnapshotNameStep = new GenerateSnapshotNameStep(generateSnapshotNameKey, cleanSnapshotKey,\n+            snapshotRepository);\n+        CleanupSnapshotStep cleanupSnapshotStep = new CleanupSnapshotStep(cleanSnapshotKey, createSnapshotKey, client);\n+        CreateSnapshotStep createSnapshotStep = new CreateSnapshotStep(createSnapshotKey, waitForSnapshotInProgressKey, client);\n+        WaitForSnapshotInProgressStep waitForSnapshotInProgressStep = new WaitForSnapshotInProgressStep(waitForSnapshotInProgressKey,\n+            verifySnapshotStatusBranchingKey);\n+        OnAsyncWaitBranchingStep onAsyncWaitBranchingStep = new OnAsyncWaitBranchingStep(verifySnapshotStatusBranchingKey,\n+            cleanSnapshotKey, mountSnapshotKey, client, getCheckSnapshotStatusAsyncAction());\n+        MountSnapshotStep mountSnapshotStep = new MountSnapshotStep(mountSnapshotKey, waitForGreenRestoredIndexKey,\n+            client, RESTORED_INDEX_PREFIX);\n+        WaitForIndexColorStep waitForGreenIndexHealthStep = new WaitForIndexColorStep(waitForGreenRestoredIndexKey,\n+            copyMetadataKey, ClusterHealthStatus.GREEN, RESTORED_INDEX_PREFIX);\n+        CopyExecutionStateStep copyMetadataStep = new CopyExecutionStateStep(copyMetadataKey, copyLifecyclePolicySettingKey,\n+            RESTORED_INDEX_PREFIX, nextStepKey != null ? nextStepKey.getName() : \"null\");\n+        CopySettingsStep copySettingsStep = new CopySettingsStep(copyLifecyclePolicySettingKey, swapAliasesKey, RESTORED_INDEX_PREFIX,\n+            LifecycleSettings.LIFECYCLE_NAME);\n+        // sending this step to null as the restored index (which will after this step essentially be the source index) was sent to the next\n+        // key after we restored the lifecycle execution state\n+        SwapAliasesAndDeleteSourceIndexStep swapAliasesAndDeleteSourceIndexStep = new SwapAliasesAndDeleteSourceIndexStep(swapAliasesKey,\n+            null, client, RESTORED_INDEX_PREFIX);\n+\n+        return Arrays.asList(waitForNoFollowersStep, generateSnapshotNameStep, cleanupSnapshotStep, createSnapshotStep,\n+            waitForSnapshotInProgressStep, onAsyncWaitBranchingStep, mountSnapshotStep, waitForGreenIndexHealthStep,\n+            copyMetadataStep, copySettingsStep, swapAliasesAndDeleteSourceIndexStep);\n+    }\n+\n+    /**\n+     * Creates a consumer to evaluate the ILM generated snapshot status in the provided snapshotRepository in an async way, akin to an\n+     * equivalent {@link AsyncWaitStep} implementation.\n+     */\n+    static TriConsumer<Client, IndexMetaData, BranchingStepListener> getCheckSnapshotStatusAsyncAction() {\n+        return (client, indexMetaData, branchingStepListener) -> {\n+\n+            LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(indexMetaData);\n+\n+            String snapshotName = executionState.getSnapshotName();\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            final String indexName = indexMetaData.getIndex().getName();\n+            final String repositoryName = executionState.getSnapshotRepository();\n+            if (Strings.hasText(repositoryName) == false) {\n+                branchingStepListener.onFailure(\n+                    new IllegalStateException(\"snapshot repository is not present for policy [\" + policyName + \"] and index [\" + indexName +\n+                        \"]\"));\n+                return;\n+            }\n+            if (Strings.hasText(snapshotName) == false) {\n+                branchingStepListener.onFailure(new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName +\n+                    \"] and index [\" + indexName + \"]\"));\n+                return;\n+            }\n+            SnapshotsStatusRequest snapshotsStatusRequest = new SnapshotsStatusRequest(repositoryName, new String[]{snapshotName});\n+            client.admin().cluster().snapshotsStatus(snapshotsStatusRequest, new ActionListener<>() {\n+                @Override\n+                public void onResponse(SnapshotsStatusResponse snapshotsStatusResponse) {\n+                    List<SnapshotStatus> statuses = snapshotsStatusResponse.getSnapshots();\n+                    assert statuses.size() == 1 : \"we only requested the status info for one snapshot\";\n+                    SnapshotStatus snapshotStatus = statuses.get(0);\n+                    SnapshotsInProgress.State snapshotState = snapshotStatus.getState();\n+                    if (snapshotState.equals(SUCCESS)) {\n+                        branchingStepListener.onResponse(true, null);\n+                    } else if (snapshotState.equals(ABORTED) || snapshotState.equals(FAILED) || snapshotState.equals(MISSING)) {\n+                        branchingStepListener.onStopWaitingAndMoveToNextKey(new Info(\n+                            \"snapshot [\" + snapshotName + \"] for index [ \" + indexName + \"] as part of policy [\" + policyName + \"] is \" +\n+                                \"cannot complete as it is in state [\" + snapshotState + \"]\"));\n+                    } else {\n+                        branchingStepListener.onResponse(false, new Info(\n+                            \"snapshot [\" + snapshotName + \"] for index [ \" + indexName + \"] as part of policy [\" + policyName + \"] is \" +\n+                                \"in state [\" + snapshotState + \"]. waiting for SUCCESS\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    branchingStepListener.onFailure(e);\n+                }\n+\n+                final class Info implements ToXContentObject {\n+\n+                    final ParseField MESSAGE_FIELD = new ParseField(\"message\");\n+\n+                    private final String message;\n+\n+                    Info(String message) {\n+                        this.message = message;\n+                    }\n+\n+                    String getMessage() {\n+                        return message;\n+                    }\n+\n+                    @Override\n+                    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+                        builder.startObject();\n+                        builder.field(MESSAGE_FIELD.getPreferredName(), message);\n+                        builder.endObject();\n+                        return builder;\n+                    }\n+\n+                    @Override\n+                    public boolean equals(Object o) {\n+                        if (o == null) {\n+                            return false;\n+                        }\n+                        if (getClass() != o.getClass()) {\n+                            return false;\n+                        }\n+                        WaitForIndexColorStep.Info info = (WaitForIndexColorStep.Info) o;", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1OTE5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395359195", "bodyText": "I think this should probably check the response and at least log/warn about an unacknowledged request?", "author": "dakrone", "createdAt": "2020-03-19T22:41:08Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+/**\n+ * This step swaps all the aliases from the source index to the restored index and deletes the source index. This is useful in scenarios\n+ * following a restore from snapshot operation where the restored index will take the place of the source index in the ILM lifecycle.\n+ */\n+public class SwapAliasesAndDeleteSourceIndexStep extends AsyncActionStep {\n+    public static final String NAME = \"swap-aliases\";\n+    private static final Logger logger = LogManager.getLogger(SwapAliasesAndDeleteSourceIndexStep.class);\n+\n+    private final String targetIndexPrefix;\n+\n+    public SwapAliasesAndDeleteSourceIndexStep(StepKey key, StepKey nextStepKey, Client client, String targetIndexPrefix) {\n+        super(key, nextStepKey, client);\n+        this.targetIndexPrefix = targetIndexPrefix;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    public String getTargetIndexPrefix() {\n+        return targetIndexPrefix;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer,\n+                              Listener listener) {\n+        String originalIndex = indexMetaData.getIndex().getName();\n+        final String targetIndexName = targetIndexPrefix + originalIndex;\n+        IndexMetaData targetIndexMetadata = currentClusterState.metaData().index(targetIndexName);\n+\n+        if (targetIndexMetadata == null) {\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            String errorMessage = String.format(Locale.ROOT, \"target index [%s] doesn't exist. stopping execution of lifecycle [%s] for\" +\n+                \" index [%s]\", targetIndexName, policyName, originalIndex);\n+            logger.debug(errorMessage);\n+            listener.onFailure(new IllegalStateException(errorMessage));\n+            return;\n+        }\n+\n+        deleteSourceIndexAndTransferAliases(getClient(), indexMetaData, getMasterTimeout(currentClusterState), targetIndexName, listener);\n+    }\n+\n+    /**\n+     * Executes an {@link IndicesAliasesRequest} to copy over all the aliases from the source to the target index, and remove the source\n+     * index.\n+     * <p>\n+     * The is_write_index will *not* be set on the target index as this operation is currently executed on read-only indices.\n+     */\n+    static void deleteSourceIndexAndTransferAliases(Client client, IndexMetaData sourceIndex, TimeValue masterTimeoutValue,\n+                                                    String targetIndex, Listener listener) {\n+        String sourceIndexName = sourceIndex.getIndex().getName();\n+        IndicesAliasesRequest aliasesRequest = new IndicesAliasesRequest()\n+            .masterNodeTimeout(masterTimeoutValue)\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.removeIndex().index(sourceIndexName))\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.add().index(targetIndex).alias(sourceIndexName));\n+        // copy over other aliases from source index\n+        sourceIndex.getAliases().values().spliterator().forEachRemaining(aliasMetaDataObjectCursor -> {\n+            AliasMetaData aliasMetaDataToAdd = aliasMetaDataObjectCursor.value;\n+            // inherit all alias properties except `is_write_index`\n+            aliasesRequest.addAliasAction(IndicesAliasesRequest.AliasActions.add()\n+                .index(targetIndex).alias(aliasMetaDataToAdd.alias())\n+                .indexRouting(aliasMetaDataToAdd.indexRouting())\n+                .searchRouting(aliasMetaDataToAdd.searchRouting())\n+                .filter(aliasMetaDataToAdd.filter() == null ? null : aliasMetaDataToAdd.filter().string())\n+                .writeIndex(null));\n+        });\n+\n+        client.admin().indices().aliases(aliasesRequest,\n+            ActionListener.wrap(openIndexResponse -> {\n+                listener.onResponse(true);", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1OTM2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395359361", "bodyText": "This openIndexResponse should probably be aliasResponse since it's not opening an index", "author": "dakrone", "createdAt": "2020-03-19T22:41:33Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+/**\n+ * This step swaps all the aliases from the source index to the restored index and deletes the source index. This is useful in scenarios\n+ * following a restore from snapshot operation where the restored index will take the place of the source index in the ILM lifecycle.\n+ */\n+public class SwapAliasesAndDeleteSourceIndexStep extends AsyncActionStep {\n+    public static final String NAME = \"swap-aliases\";\n+    private static final Logger logger = LogManager.getLogger(SwapAliasesAndDeleteSourceIndexStep.class);\n+\n+    private final String targetIndexPrefix;\n+\n+    public SwapAliasesAndDeleteSourceIndexStep(StepKey key, StepKey nextStepKey, Client client, String targetIndexPrefix) {\n+        super(key, nextStepKey, client);\n+        this.targetIndexPrefix = targetIndexPrefix;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    public String getTargetIndexPrefix() {\n+        return targetIndexPrefix;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer,\n+                              Listener listener) {\n+        String originalIndex = indexMetaData.getIndex().getName();\n+        final String targetIndexName = targetIndexPrefix + originalIndex;\n+        IndexMetaData targetIndexMetadata = currentClusterState.metaData().index(targetIndexName);\n+\n+        if (targetIndexMetadata == null) {\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            String errorMessage = String.format(Locale.ROOT, \"target index [%s] doesn't exist. stopping execution of lifecycle [%s] for\" +\n+                \" index [%s]\", targetIndexName, policyName, originalIndex);\n+            logger.debug(errorMessage);\n+            listener.onFailure(new IllegalStateException(errorMessage));\n+            return;\n+        }\n+\n+        deleteSourceIndexAndTransferAliases(getClient(), indexMetaData, getMasterTimeout(currentClusterState), targetIndexName, listener);\n+    }\n+\n+    /**\n+     * Executes an {@link IndicesAliasesRequest} to copy over all the aliases from the source to the target index, and remove the source\n+     * index.\n+     * <p>\n+     * The is_write_index will *not* be set on the target index as this operation is currently executed on read-only indices.\n+     */\n+    static void deleteSourceIndexAndTransferAliases(Client client, IndexMetaData sourceIndex, TimeValue masterTimeoutValue,\n+                                                    String targetIndex, Listener listener) {\n+        String sourceIndexName = sourceIndex.getIndex().getName();\n+        IndicesAliasesRequest aliasesRequest = new IndicesAliasesRequest()\n+            .masterNodeTimeout(masterTimeoutValue)\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.removeIndex().index(sourceIndexName))\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.add().index(targetIndex).alias(sourceIndexName));\n+        // copy over other aliases from source index\n+        sourceIndex.getAliases().values().spliterator().forEachRemaining(aliasMetaDataObjectCursor -> {\n+            AliasMetaData aliasMetaDataToAdd = aliasMetaDataObjectCursor.value;\n+            // inherit all alias properties except `is_write_index`\n+            aliasesRequest.addAliasAction(IndicesAliasesRequest.AliasActions.add()\n+                .index(targetIndex).alias(aliasMetaDataToAdd.alias())\n+                .indexRouting(aliasMetaDataToAdd.indexRouting())\n+                .searchRouting(aliasMetaDataToAdd.searchRouting())\n+                .filter(aliasMetaDataToAdd.filter() == null ? null : aliasMetaDataToAdd.filter().string())\n+                .writeIndex(null));\n+        });\n+\n+        client.admin().indices().aliases(aliasesRequest,\n+            ActionListener.wrap(openIndexResponse -> {", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2MDAxMw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395360013", "bodyText": "It was unclear where we wanted this to live, but I'm pretty sure that all the conversations I've heard have mentioned it being in the warm phase, @DaveCTurner was there ever a consensus on where it should go, warm/cold, or just cold?", "author": "dakrone", "createdAt": "2020-03-19T22:43:16Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -41,7 +41,7 @@\n     static final List<String> ORDERED_VALID_WARM_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, ReadOnlyAction.NAME,\n         AllocateAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME);\n     static final List<String> ORDERED_VALID_COLD_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, AllocateAction.NAME,\n-        FreezeAction.NAME);\n+        FreezeAction.NAME, SearchableSnapshotAction.NAME);", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2MTM2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395361365", "bodyText": "I'm not sure, but can clusterState.custom(SnapshotsInProgress.TYPE) return null if there have never been any snapshots? Perhaps we should add a null check?", "author": "dakrone", "createdAt": "2020-03-19T22:47:26Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForSnapshotInProgressStep.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.snapshots.SnapshotsService;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * After we triggered a snapshot we'll wait until the snapshot is not executing anymore (ie. the SnapshotInProgress meta data doesn't\n+ * contain an entry for the snapshot we've triggered)\n+ */\n+public class WaitForSnapshotInProgressStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-snapshot\";\n+    private static final Logger logger = LogManager.getLogger(WaitForSnapshotInProgressStep.class);\n+\n+    WaitForSnapshotInProgressStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData indexMetaData = clusterState.metaData().index(index);\n+        String indexName = index.getName();\n+\n+        if (indexMetaData == null) {\n+            String errorMessage = String.format(Locale.ROOT, \"[%s] lifecycle action for index [%s] executed but index no longer exists\",\n+                getKey().getAction(), indexName);\n+            // Index must have been since deleted\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+\n+        String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(indexMetaData);\n+        final String snapshotRepository = executionState.getSnapshotRepository();\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            String errorMessage = String.format(Locale.ROOT, \"snapshot repository is not present for policy [%s] and index [%s]\",\n+                policyName, indexName);\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+        final String snapshotName = executionState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            String errorMessage = String.format(Locale.ROOT, \"snapshot name was not generated for policy [%s] and index [%s]\",\n+                policyName, indexName);\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+        final SnapshotsInProgress snapshotsInProgress = clusterState.custom(SnapshotsInProgress.TYPE);", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2MTg4MA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395361880", "bodyText": "I'm starting to think we should add a GenericILMInfo class that is just a message field so we don't end up having to duplicate this class over and over in each step (not necessarily in this PR)", "author": "dakrone", "createdAt": "2020-03-19T22:48:41Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForSnapshotInProgressStep.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.snapshots.SnapshotsService;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * After we triggered a snapshot we'll wait until the snapshot is not executing anymore (ie. the SnapshotInProgress meta data doesn't\n+ * contain an entry for the snapshot we've triggered)\n+ */\n+public class WaitForSnapshotInProgressStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-snapshot\";\n+    private static final Logger logger = LogManager.getLogger(WaitForSnapshotInProgressStep.class);\n+\n+    WaitForSnapshotInProgressStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData indexMetaData = clusterState.metaData().index(index);\n+        String indexName = index.getName();\n+\n+        if (indexMetaData == null) {\n+            String errorMessage = String.format(Locale.ROOT, \"[%s] lifecycle action for index [%s] executed but index no longer exists\",\n+                getKey().getAction(), indexName);\n+            // Index must have been since deleted\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+\n+        String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(indexMetaData);\n+        final String snapshotRepository = executionState.getSnapshotRepository();\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            String errorMessage = String.format(Locale.ROOT, \"snapshot repository is not present for policy [%s] and index [%s]\",\n+                policyName, indexName);\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+        final String snapshotName = executionState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            String errorMessage = String.format(Locale.ROOT, \"snapshot name was not generated for policy [%s] and index [%s]\",\n+                policyName, indexName);\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+        final SnapshotsInProgress snapshotsInProgress = clusterState.custom(SnapshotsInProgress.TYPE);\n+        List<SnapshotInfo> repositorySnapshots = SnapshotsService.currentSnapshots(snapshotsInProgress, snapshotRepository);\n+        List<SnapshotInfo> configuredSnapshotInProgress =\n+            repositorySnapshots.stream().filter(si -> si.snapshotId().getName().equals(snapshotName)).collect(Collectors.toList());\n+\n+        if (configuredSnapshotInProgress.isEmpty()) {\n+            return new Result(true, null);\n+        } else {\n+            return new Result(false, new Info(String.format(Locale.ROOT,\n+                \"snapshot [%s] generated by policy [%s] for index [%s] is still in progress\", snapshotName, policyName, indexName)));\n+        }\n+    }\n+\n+    static final class Info implements ToXContentObject {", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwODUwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395908505", "bodyText": "Super minor nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \" is no snapshot to deleter\");\n          \n          \n            \n                                    \" is no snapshot to delete\");", "author": "dakrone", "createdAt": "2020-03-20T22:00:02Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStepTests.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotAction;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.test.client.NoOpClient;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.core.ilm.AbstractStepMasterTimeoutTestCase.emptyClusterState;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+\n+public class CleanupSnapshotStepTests extends AbstractStepTestCase<CleanupSnapshotStep> {\n+\n+    @Override\n+    public CleanupSnapshotStep createRandomInstance() {\n+        StepKey stepKey = randomStepKey();\n+        StepKey nextStepKey = randomStepKey();\n+        return new CleanupSnapshotStep(stepKey, nextStepKey, client);\n+    }\n+\n+    @Override\n+    protected CleanupSnapshotStep copyInstance(CleanupSnapshotStep instance) {\n+        return new CleanupSnapshotStep(instance.getKey(), instance.getNextStepKey(), instance.getClient());\n+    }\n+\n+    @Override\n+    public CleanupSnapshotStep mutateInstance(CleanupSnapshotStep instance) {\n+        StepKey key = instance.getKey();\n+        StepKey nextKey = instance.getNextStepKey();\n+        switch (between(0, 1)) {\n+            case 0:\n+                key = new StepKey(key.getPhase(), key.getAction(), key.getName() + randomAlphaOfLength(5));\n+                break;\n+            case 1:\n+                nextKey = new StepKey(key.getPhase(), key.getAction(), key.getName() + randomAlphaOfLength(5));\n+                break;\n+            default:\n+                throw new AssertionError(\"Illegal randomisation branch\");\n+        }\n+        return new CleanupSnapshotStep(key, nextKey, instance.getClient());\n+    }\n+\n+    public void testPerformActionDoesntFailIfSnapshotInfoIsMissing() {\n+        String indexName = randomAlphaOfLength(10);\n+        String policyName = \"test-ilm-policy\";\n+\n+        {\n+            IndexMetaData.Builder indexMetadataBuilder =\n+                IndexMetaData.builder(indexName).settings(settings(Version.CURRENT).put(LifecycleSettings.LIFECYCLE_NAME, policyName))\n+                    .numberOfShards(randomIntBetween(1, 5)).numberOfReplicas(randomIntBetween(0, 5));\n+\n+            IndexMetaData indexMetaData = indexMetadataBuilder.build();\n+\n+            ClusterState clusterState =\n+                ClusterState.builder(emptyClusterState()).metaData(MetaData.builder().put(indexMetaData, true).build()).build();\n+\n+            CleanupSnapshotStep cleanupSnapshotStep = createRandomInstance();\n+            cleanupSnapshotStep.performAction(indexMetaData, clusterState, null, new AsyncActionStep.Listener() {\n+                @Override\n+                public void onResponse(boolean complete) {\n+                    assertThat(complete, is(true));\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    fail(\"expecting the step to report success if repository information is missing from the ILM execution state as there\" +\n+                        \" is no snapshot to deleter\");", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwODk5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395908997", "bodyText": "Could probably add assertTrue(complete) here", "author": "dakrone", "createdAt": "2020-03-20T22:01:46Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStepTests.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotAction;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.test.client.NoOpClient;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.core.ilm.AbstractStepMasterTimeoutTestCase.emptyClusterState;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+\n+public class CleanupSnapshotStepTests extends AbstractStepTestCase<CleanupSnapshotStep> {\n+\n+    @Override\n+    public CleanupSnapshotStep createRandomInstance() {\n+        StepKey stepKey = randomStepKey();\n+        StepKey nextStepKey = randomStepKey();\n+        return new CleanupSnapshotStep(stepKey, nextStepKey, client);\n+    }\n+\n+    @Override\n+    protected CleanupSnapshotStep copyInstance(CleanupSnapshotStep instance) {\n+        return new CleanupSnapshotStep(instance.getKey(), instance.getNextStepKey(), instance.getClient());\n+    }\n+\n+    @Override\n+    public CleanupSnapshotStep mutateInstance(CleanupSnapshotStep instance) {\n+        StepKey key = instance.getKey();\n+        StepKey nextKey = instance.getNextStepKey();\n+        switch (between(0, 1)) {\n+            case 0:\n+                key = new StepKey(key.getPhase(), key.getAction(), key.getName() + randomAlphaOfLength(5));\n+                break;\n+            case 1:\n+                nextKey = new StepKey(key.getPhase(), key.getAction(), key.getName() + randomAlphaOfLength(5));\n+                break;\n+            default:\n+                throw new AssertionError(\"Illegal randomisation branch\");\n+        }\n+        return new CleanupSnapshotStep(key, nextKey, instance.getClient());\n+    }\n+\n+    public void testPerformActionDoesntFailIfSnapshotInfoIsMissing() {\n+        String indexName = randomAlphaOfLength(10);\n+        String policyName = \"test-ilm-policy\";\n+\n+        {\n+            IndexMetaData.Builder indexMetadataBuilder =\n+                IndexMetaData.builder(indexName).settings(settings(Version.CURRENT).put(LifecycleSettings.LIFECYCLE_NAME, policyName))\n+                    .numberOfShards(randomIntBetween(1, 5)).numberOfReplicas(randomIntBetween(0, 5));\n+\n+            IndexMetaData indexMetaData = indexMetadataBuilder.build();\n+\n+            ClusterState clusterState =\n+                ClusterState.builder(emptyClusterState()).metaData(MetaData.builder().put(indexMetaData, true).build()).build();\n+\n+            CleanupSnapshotStep cleanupSnapshotStep = createRandomInstance();\n+            cleanupSnapshotStep.performAction(indexMetaData, clusterState, null, new AsyncActionStep.Listener() {\n+                @Override\n+                public void onResponse(boolean complete) {\n+                    assertThat(complete, is(true));\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    fail(\"expecting the step to report success if repository information is missing from the ILM execution state as there\" +\n+                        \" is no snapshot to deleter\");\n+                }\n+            });\n+        }\n+\n+        {\n+            IndexMetaData.Builder indexMetadataBuilder =\n+                IndexMetaData.builder(indexName).settings(settings(Version.CURRENT).put(LifecycleSettings.LIFECYCLE_NAME, policyName))\n+                    .numberOfShards(randomIntBetween(1, 5)).numberOfReplicas(randomIntBetween(0, 5));\n+            Map<String, String> ilmCustom = Map.of(\"snapshot_repository\", \"repository_name\");\n+            indexMetadataBuilder.putCustom(LifecycleExecutionState.ILM_CUSTOM_METADATA_KEY, ilmCustom);\n+\n+            IndexMetaData indexMetaData = indexMetadataBuilder.build();\n+\n+            ClusterState clusterState =\n+                ClusterState.builder(emptyClusterState()).metaData(MetaData.builder().put(indexMetaData, true).build()).build();\n+\n+            CleanupSnapshotStep cleanupSnapshotStep = createRandomInstance();\n+            cleanupSnapshotStep.performAction(indexMetaData, clusterState, null, new AsyncActionStep.Listener() {\n+                @Override\n+                public void onResponse(boolean complete) {\n+                    assertThat(complete, is(true));\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    fail(\"expecting the step to report success if the snapshot name is missing from the ILM execution state as there is \" +\n+                        \"no snapshot to delete\");\n+                }\n+            });\n+        }\n+    }\n+\n+    public void testPerformAction() {\n+        String indexName = randomAlphaOfLength(10);\n+        String policyName = \"test-ilm-policy\";\n+        String snapshotName = indexName + \"-\" + policyName;\n+        Map<String, String> ilmCustom = Map.of(\"snapshot_name\", snapshotName);\n+\n+        IndexMetaData.Builder indexMetadataBuilder =\n+            IndexMetaData.builder(indexName).settings(settings(Version.CURRENT).put(LifecycleSettings.LIFECYCLE_NAME, policyName))\n+                .putCustom(LifecycleExecutionState.ILM_CUSTOM_METADATA_KEY, ilmCustom)\n+                .numberOfShards(randomIntBetween(1, 5)).numberOfReplicas(randomIntBetween(0, 5));\n+        IndexMetaData indexMetaData = indexMetadataBuilder.build();\n+\n+        ClusterState clusterState =\n+            ClusterState.builder(emptyClusterState()).metaData(MetaData.builder().put(indexMetaData, true).build()).build();\n+\n+        try (NoOpClient client = getDeleteSnapshotRequestAssertingClient(snapshotName)) {\n+            CleanupSnapshotStep step = new CleanupSnapshotStep(randomStepKey(), randomStepKey(), client);\n+            step.performAction(indexMetaData, clusterState, null, new AsyncActionStep.Listener() {\n+                @Override\n+                public void onResponse(boolean complete) {\n+                }", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwOTMwOA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395909308", "bodyText": "Can add assertTrue(complete) here as well (and a fail clause in the onFailure below)", "author": "dakrone", "createdAt": "2020-03-20T22:02:50Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStepTests.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotAction;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.test.client.NoOpClient;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.core.ilm.AbstractStepMasterTimeoutTestCase.emptyClusterState;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+\n+public class CreateSnapshotStepTests extends AbstractStepTestCase<CreateSnapshotStep> {\n+\n+    @Override\n+    public CreateSnapshotStep createRandomInstance() {\n+        StepKey stepKey = randomStepKey();\n+        StepKey nextStepKey = randomStepKey();\n+        return new CreateSnapshotStep(stepKey, nextStepKey, client);\n+    }\n+\n+    @Override\n+    protected CreateSnapshotStep copyInstance(CreateSnapshotStep instance) {\n+        return new CreateSnapshotStep(instance.getKey(), instance.getNextStepKey(), instance.getClient());\n+    }\n+\n+    @Override\n+    public CreateSnapshotStep mutateInstance(CreateSnapshotStep instance) {\n+        StepKey key = instance.getKey();\n+        StepKey nextKey = instance.getNextStepKey();\n+        switch (between(0, 1)) {\n+            case 0:\n+                key = new StepKey(key.getPhase(), key.getAction(), key.getName() + randomAlphaOfLength(5));\n+                break;\n+            case 1:\n+                nextKey = new StepKey(key.getPhase(), key.getAction(), key.getName() + randomAlphaOfLength(5));\n+                break;\n+            default:\n+                throw new AssertionError(\"Illegal randomisation branch\");\n+        }\n+        return new CreateSnapshotStep(key, nextKey, instance.getClient());\n+    }\n+\n+    public void testPerformActionFailure() {\n+        String indexName = randomAlphaOfLength(10);\n+        String policyName = \"test-ilm-policy\";\n+\n+        {\n+            IndexMetaData.Builder indexMetadataBuilder =\n+                IndexMetaData.builder(indexName).settings(settings(Version.CURRENT).put(LifecycleSettings.LIFECYCLE_NAME, policyName))\n+                    .numberOfShards(randomIntBetween(1, 5)).numberOfReplicas(randomIntBetween(0, 5));\n+            Map<String, String> ilmCustom = new HashMap<>();\n+            String repository = \"repository\";\n+            ilmCustom.put(\"snapshot_repository\", repository);\n+            indexMetadataBuilder.putCustom(LifecycleExecutionState.ILM_CUSTOM_METADATA_KEY, ilmCustom);\n+\n+            IndexMetaData indexMetaData = indexMetadataBuilder.build();\n+\n+            ClusterState clusterState =\n+                ClusterState.builder(emptyClusterState()).metaData(MetaData.builder().put(indexMetaData, true).build()).build();\n+\n+            CreateSnapshotStep createSnapshotStep = createRandomInstance();\n+            createSnapshotStep.performAction(indexMetaData, clusterState, null, new AsyncActionStep.Listener() {\n+                @Override\n+                public void onResponse(boolean complete) {\n+                    fail(\"expecting a failure as the index doesn't have any snapshot name in its ILM execution state\");\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    assertThat(e, instanceOf(IllegalStateException.class));\n+                    assertThat(e.getMessage(),\n+                        is(\"snapshot name was not generated for policy [\" + policyName + \"] and index [\" + indexName + \"]\"));\n+                }\n+            });\n+        }\n+\n+        {\n+            IndexMetaData.Builder indexMetadataBuilder =\n+                IndexMetaData.builder(indexName).settings(settings(Version.CURRENT).put(LifecycleSettings.LIFECYCLE_NAME, policyName))\n+                    .numberOfShards(randomIntBetween(1, 5)).numberOfReplicas(randomIntBetween(0, 5));\n+            IndexMetaData indexMetaData = indexMetadataBuilder.build();\n+\n+            ClusterState clusterState =\n+                ClusterState.builder(emptyClusterState()).metaData(MetaData.builder().put(indexMetaData, true).build()).build();\n+\n+            CreateSnapshotStep createSnapshotStep = createRandomInstance();\n+            createSnapshotStep.performAction(indexMetaData, clusterState, null, new AsyncActionStep.Listener() {\n+                @Override\n+                public void onResponse(boolean complete) {\n+                    fail(\"expecting a failure as the index doesn't have any snapshot name in its ILM execution state\");\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    assertThat(e, instanceOf(IllegalStateException.class));\n+                    assertThat(e.getMessage(),\n+                        is(\"snapshot repository is not present for policy [\" + policyName + \"] and index [\" + indexName + \"]\"));\n+                }\n+            });\n+        }\n+    }\n+\n+    public void testPerformAction() {\n+        String indexName = randomAlphaOfLength(10);\n+        String policyName = \"test-ilm-policy\";\n+        Map<String, String> ilmCustom = new HashMap<>();\n+        String snapshotName = indexName + \"-\" + policyName;\n+        ilmCustom.put(\"snapshot_name\", snapshotName);\n+        String repository = \"repository\";\n+        ilmCustom.put(\"snapshot_repository\", repository);\n+\n+        IndexMetaData.Builder indexMetadataBuilder =\n+            IndexMetaData.builder(indexName).settings(settings(Version.CURRENT).put(LifecycleSettings.LIFECYCLE_NAME, policyName))\n+                .putCustom(LifecycleExecutionState.ILM_CUSTOM_METADATA_KEY, ilmCustom)\n+                .numberOfShards(randomIntBetween(1, 5)).numberOfReplicas(randomIntBetween(0, 5));\n+        IndexMetaData indexMetaData = indexMetadataBuilder.build();\n+\n+        ClusterState clusterState =\n+            ClusterState.builder(emptyClusterState()).metaData(MetaData.builder().put(indexMetaData, true).build()).build();\n+\n+        try (NoOpClient client = getCreateSnapshotRequestAssertingClient(repository, snapshotName)) {\n+            CreateSnapshotStep step = new CreateSnapshotStep(randomStepKey(), randomStepKey(), client);\n+            step.performAction(indexMetaData, clusterState, null, new AsyncActionStep.Listener() {\n+                @Override\n+                public void onResponse(boolean complete) {", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxMDE0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395910145", "bodyText": "We could probably put these somewhere else to start splitting this apart similar to #53488 (up to you of course)", "author": "dakrone", "createdAt": "2020-03-20T22:05:43Z", "path": "x-pack/plugin/ilm/qa/multi-node/src/test/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java", "diffHunk": "@@ -1545,6 +1548,145 @@ public void testHaltAtEndOfPhase() throws Exception {\n         assertBusy(() -> assertFalse(\"expected \" + index + \" to be deleted by ILM\", indexExists(index)));\n     }\n \n+    public void testSearchableSnapshotAction() throws Exception {", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzNjAzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r397336031", "bodyText": "Yes, totally, I am about to start doing that on master (and will backport here with the appropriate conflict fixes) as I think the scope of this PR is already quite large and some infrastructure needs to be extracted from TimeSeriesLifecycleActionsIT to be reused across the various new test classes.", "author": "andreidan", "createdAt": "2020-03-24T17:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxMDE0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxMTA5MA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395911090", "bodyText": "Isn't this index going to be deleted by the policy (time value of 0 to delete), so we should probably just check that the index is missing and then make sure the snapshot still exists?", "author": "dakrone", "createdAt": "2020-03-20T22:09:04Z", "path": "x-pack/plugin/ilm/qa/multi-node/src/test/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java", "diffHunk": "@@ -1545,6 +1548,145 @@ public void testHaltAtEndOfPhase() throws Exception {\n         assertBusy(() -> assertFalse(\"expected \" + index + \" to be deleted by ILM\", indexExists(index)));\n     }\n \n+    public void testSearchableSnapshotAction() throws Exception {\n+        String snapshotRepo = createSnapshotRepo();\n+        createNewSingletonPolicy(\"cold\", new SearchableSnapshotAction(snapshotRepo));\n+\n+        createIndexWithSettings(index,\n+            Settings.builder()\n+                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n+                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n+                .put(LifecycleSettings.LIFECYCLE_NAME, policy),\n+            randomBoolean());\n+\n+        String restoredIndexName = SearchableSnapshotAction.RESTORED_INDEX_PREFIX + this.index;\n+        assertTrue(waitUntil(() -> {\n+            try {\n+                return indexExists(restoredIndexName);\n+            } catch (IOException e) {\n+                return false;\n+            }\n+        }, 30, TimeUnit.SECONDS));\n+\n+        assertBusy(() -> assertThat(explainIndex(restoredIndexName).get(\"step\"), is(PhaseCompleteStep.NAME)), 30, TimeUnit.SECONDS);\n+    }\n+\n+    public void testDeleteActionDeletesGeneratedSnapshot() throws Exception {\n+        String snapshotRepo = createSnapshotRepo();\n+\n+        // create policy with cold and delete phases\n+        Map<String, LifecycleAction> coldActions =\n+            Map.of(SearchableSnapshotAction.NAME, new SearchableSnapshotAction(snapshotRepo));\n+        Map<String, Phase> phases = new HashMap<>();\n+        phases.put(\"cold\", new Phase(\"cold\", TimeValue.ZERO, coldActions));\n+        phases.put(\"delete\", new Phase(\"delete\", TimeValue.ZERO, singletonMap(DeleteAction.NAME, new DeleteAction(true))));\n+        LifecyclePolicy lifecyclePolicy = new LifecyclePolicy(policy, phases);\n+        // PUT policy\n+        XContentBuilder builder = jsonBuilder();\n+        lifecyclePolicy.toXContent(builder, null);\n+        final StringEntity entity = new StringEntity(\n+            \"{ \\\"policy\\\":\" + Strings.toString(builder) + \"}\", ContentType.APPLICATION_JSON);\n+        Request createPolicyRequest = new Request(\"PUT\", \"_ilm/policy/\" + policy);\n+        createPolicyRequest.setEntity(entity);\n+        assertOK(client().performRequest(createPolicyRequest));\n+\n+        createIndexWithSettings(index,\n+            Settings.builder()\n+                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n+                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n+                .put(LifecycleSettings.LIFECYCLE_NAME, policy),\n+            randomBoolean());\n+\n+        String restoredIndexName = SearchableSnapshotAction.RESTORED_INDEX_PREFIX + this.index;\n+        String[] snapshotName = new String[1];\n+        assertTrue(waitUntil(() -> {\n+            try {\n+                Map<String, Object> explainIndex = explainIndex(restoredIndexName);\n+                String action = (String) explainIndex.get(\"action\");\n+                snapshotName[0] = (String) explainIndex.get(\"snapshot_name\");\n+                return DeleteAction.NAME.equals(action);\n+            } catch (IOException e) {\n+                return false;\n+            }\n+        }, 60, TimeUnit.SECONDS));\n+\n+        assertTrue(\"the snapshot we generate in the cold phase should be deleted by the delete phase\", waitUntil(() -> {\n+            try {\n+                Request getSnapshotsRequest = new Request(\"GET\", \"_snapshot/\" + snapshotRepo + \"/\" + snapshotName[0]);\n+                Response getSnapshotsResponse = client().performRequest(getSnapshotsRequest);\n+                return EntityUtils.toString(getSnapshotsResponse.getEntity()).contains(\"snapshot_missing_exception\");\n+            } catch (IOException e) {\n+                return false;\n+            }\n+        }, 30, TimeUnit.SECONDS));\n+    }\n+\n+    public void testDeleteActionDoesntDeleteGeneratedSnapshot() throws Exception {\n+        String snapshotRepo = createSnapshotRepo();\n+\n+        // create policy with cold and delete phases\n+        Map<String, LifecycleAction> coldActions =\n+            Map.of(SearchableSnapshotAction.NAME, new SearchableSnapshotAction(snapshotRepo));\n+        Map<String, Phase> phases = new HashMap<>();\n+        phases.put(\"cold\", new Phase(\"cold\", TimeValue.ZERO, coldActions));\n+        phases.put(\"delete\", new Phase(\"delete\", TimeValue.ZERO, singletonMap(DeleteAction.NAME, new DeleteAction(false))));\n+        LifecyclePolicy lifecyclePolicy = new LifecyclePolicy(policy, phases);\n+        // PUT policy\n+        XContentBuilder builder = jsonBuilder();\n+        lifecyclePolicy.toXContent(builder, null);\n+        final StringEntity entity = new StringEntity(\n+            \"{ \\\"policy\\\":\" + Strings.toString(builder) + \"}\", ContentType.APPLICATION_JSON);\n+        Request createPolicyRequest = new Request(\"PUT\", \"_ilm/policy/\" + policy);\n+        createPolicyRequest.setEntity(entity);\n+        assertOK(client().performRequest(createPolicyRequest));\n+\n+        createIndexWithSettings(index,\n+            Settings.builder()\n+                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n+                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n+                .put(LifecycleSettings.LIFECYCLE_NAME, policy),\n+            randomBoolean());\n+\n+        String restoredIndexName = SearchableSnapshotAction.RESTORED_INDEX_PREFIX + this.index;\n+        String[] snapshotName = new String[1];\n+        assertTrue(waitUntil(() -> {\n+            try {\n+                Map<String, Object> explainIndex = explainIndex(restoredIndexName);\n+                String action = (String) explainIndex.get(\"action\");\n+                snapshotName[0] = (String) explainIndex.get(\"snapshot_name\");\n+                return DeleteAction.NAME.equals(action);", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5e4cf55259fb38419ccfd09de8babbf734d485d9", "url": "https://github.com/elastic/elasticsearch/commit/5e4cf55259fb38419ccfd09de8babbf734d485d9", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-24T14:09:07Z", "type": "commit"}, {"oid": "32e3371870bfe0a8ff2517f338f62792225d64fb", "url": "https://github.com/elastic/elasticsearch/commit/32e3371870bfe0a8ff2517f338f62792225d64fb", "message": "Format code\n\nCo-Authored-By: Lee Hinman <dakrone@users.noreply.github.com>", "committedDate": "2020-03-24T17:16:13Z", "type": "commit"}, {"oid": "ac9e9c3c18c8c39aab98b2ca79bb4d9e71168c28", "url": "https://github.com/elastic/elasticsearch/commit/ac9e9c3c18c8c39aab98b2ca79bb4d9e71168c28", "message": "Make CleanupSnapshotStep retryable", "committedDate": "2020-03-24T17:19:20Z", "type": "commit"}, {"oid": "b68b61c1cc6a969d9092f093c8aa543645baf7d9", "url": "https://github.com/elastic/elasticsearch/commit/b68b61c1cc6a969d9092f093c8aa543645baf7d9", "message": "Fix typo\n\nCo-Authored-By: Lee Hinman <dakrone@users.noreply.github.com>", "committedDate": "2020-03-24T17:28:38Z", "type": "commit"}, {"oid": "374e50d9c557ce31c51ba998382db2ad7ebc6027", "url": "https://github.com/elastic/elasticsearch/commit/374e50d9c557ce31c51ba998382db2ad7ebc6027", "message": "Format code\n\nCo-Authored-By: Lee Hinman <dakrone@users.noreply.github.com>", "committedDate": "2020-03-25T11:21:54Z", "type": "commit"}, {"oid": "4f25ce948ef0b3208e268f9ab6b1552a5781afc4", "url": "https://github.com/elastic/elasticsearch/commit/4f25ce948ef0b3208e268f9ab6b1552a5781afc4", "message": "CreateSnapshotStep request specifies index name", "committedDate": "2020-03-25T11:22:36Z", "type": "commit"}, {"oid": "0f6f3719e35e43de3e214d3a3c0de86fec9834fe", "url": "https://github.com/elastic/elasticsearch/commit/0f6f3719e35e43de3e214d3a3c0de86fec9834fe", "message": "Rename delete action field to delete_searchable_snapshot", "committedDate": "2020-03-25T12:11:44Z", "type": "commit"}, {"oid": "15d39edb48c381e38287d5e6760bc71f9e9db6d9", "url": "https://github.com/elastic/elasticsearch/commit/15d39edb48c381e38287d5e6760bc71f9e9db6d9", "message": "Rename SSA repo field to snapshot_repository (underscore)", "committedDate": "2020-03-25T12:12:15Z", "type": "commit"}, {"oid": "e76ff6c8c6df3921f9c2f01d7a1a68dcbbe5ede3", "url": "https://github.com/elastic/elasticsearch/commit/e76ff6c8c6df3921f9c2f01d7a1a68dcbbe5ede3", "message": "Fix delete action test assertions", "committedDate": "2020-03-25T12:12:32Z", "type": "commit"}, {"oid": "ff7623fb9188f6fd1542194a1c5beef70bd74df5", "url": "https://github.com/elastic/elasticsearch/commit/ff7623fb9188f6fd1542194a1c5beef70bd74df5", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-25T12:38:10Z", "type": "commit"}, {"oid": "3c56f7373603b542a73e8400b77dbe0a9a4f55f7", "url": "https://github.com/elastic/elasticsearch/commit/3c56f7373603b542a73e8400b77dbe0a9a4f55f7", "message": "Fix doc tests", "committedDate": "2020-03-25T15:36:12Z", "type": "commit"}, {"oid": "06bf054c65fb19193f6fba1e77ec76e2211fe2f7", "url": "https://github.com/elastic/elasticsearch/commit/06bf054c65fb19193f6fba1e77ec76e2211fe2f7", "message": "Change debug level to warn", "committedDate": "2020-03-25T15:36:25Z", "type": "commit"}, {"oid": "c3d785e495cf2fa2c2ad2b4958c8e2f1954970e3", "url": "https://github.com/elastic/elasticsearch/commit/c3d785e495cf2fa2c2ad2b4958c8e2f1954970e3", "message": "Log when we stop waiting for the branch condition", "committedDate": "2020-03-25T15:36:41Z", "type": "commit"}, {"oid": "9d37f78069d40d85d80cca566f150420d12b1fd1", "url": "https://github.com/elastic/elasticsearch/commit/9d37f78069d40d85d80cca566f150420d12b1fd1", "message": "MountSnapshotStep is retries when response is not acked", "committedDate": "2020-03-25T15:37:16Z", "type": "commit"}, {"oid": "985477e2ef48121864bf5e5d840d8134f101d3f9", "url": "https://github.com/elastic/elasticsearch/commit/985477e2ef48121864bf5e5d840d8134f101d3f9", "message": "Doc null handling", "committedDate": "2020-03-25T15:45:04Z", "type": "commit"}, {"oid": "2e4bd2bc1b4a78db0b2009e5e8d14b467667adf6", "url": "https://github.com/elastic/elasticsearch/commit/2e4bd2bc1b4a78db0b2009e5e8d14b467667adf6", "message": "Update info message to be good english", "committedDate": "2020-03-25T15:46:01Z", "type": "commit"}, {"oid": "cd73bd6e97678ead8e4fc814ec86ce6ccbdadd05", "url": "https://github.com/elastic/elasticsearch/commit/cd73bd6e97678ead8e4fc814ec86ce6ccbdadd05", "message": "Use the correct Info class Luke", "committedDate": "2020-03-25T15:48:14Z", "type": "commit"}, {"oid": "0ca1db0ebb4701cade33f9f3fd552887355c5fc4", "url": "https://github.com/elastic/elasticsearch/commit/0ca1db0ebb4701cade33f9f3fd552887355c5fc4", "message": "Cleanup if/else branches that check the snapshot state", "committedDate": "2020-03-25T15:50:31Z", "type": "commit"}, {"oid": "2b467cfa615748b08763476902eacf034a79fe5d", "url": "https://github.com/elastic/elasticsearch/commit/2b467cfa615748b08763476902eacf034a79fe5d", "message": "Log that the swap aliases response was not acked", "committedDate": "2020-03-25T15:57:36Z", "type": "commit"}, {"oid": "5f506ee67070eac1bfd7dc6d381ef27caf879d13", "url": "https://github.com/elastic/elasticsearch/commit/5f506ee67070eac1bfd7dc6d381ef27caf879d13", "message": "SnapshotInProgress null check", "committedDate": "2020-03-25T16:01:47Z", "type": "commit"}, {"oid": "80c9a451b6a6c56bafc3404fc02376941546cf4d", "url": "https://github.com/elastic/elasticsearch/commit/80c9a451b6a6c56bafc3404fc02376941546cf4d", "message": "Fix test", "committedDate": "2020-03-25T21:20:35Z", "type": "commit"}, {"oid": "8ed70c88271aa0c3ebd2707875f9fb9d8e8972e8", "url": "https://github.com/elastic/elasticsearch/commit/8ed70c88271aa0c3ebd2707875f9fb9d8e8972e8", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-26T09:52:26Z", "type": "commit"}, {"oid": "c38e081f076bd2fd1ba618fdea52278206b0ed74", "url": "https://github.com/elastic/elasticsearch/commit/c38e081f076bd2fd1ba618fdea52278206b0ed74", "message": "Delete phase min_age after 5 seconds", "committedDate": "2020-03-26T11:46:02Z", "type": "commit"}, {"oid": "c032d3aee7b2c5852745adb0849573628b0b8b7c", "url": "https://github.com/elastic/elasticsearch/commit/c032d3aee7b2c5852745adb0849573628b0b8b7c", "message": "Checkstyle", "committedDate": "2020-03-26T12:19:34Z", "type": "commit"}, {"oid": "7107b1a0a51aad5cb26ac476120a8acf7e829f27", "url": "https://github.com/elastic/elasticsearch/commit/7107b1a0a51aad5cb26ac476120a8acf7e829f27", "message": "Use underscore in action name too", "committedDate": "2020-03-26T14:53:03Z", "type": "commit"}, {"oid": "5bc6df22a6d9790164185bffcd4be43ca15f20b1", "url": "https://github.com/elastic/elasticsearch/commit/5bc6df22a6d9790164185bffcd4be43ca15f20b1", "message": "Get the generated snapshot name from the original index in test\n\nThis speeds up the test a bit and also avoids a race condition where the\nexplain API will not get a response as the ILM is busy executing cluster\naction steps for the restored index.", "committedDate": "2020-03-27T12:16:19Z", "type": "commit"}, {"oid": "5b7f599156c2eef415cf00a529f359a328c9b62a", "url": "https://github.com/elastic/elasticsearch/commit/5b7f599156c2eef415cf00a529f359a328c9b62a", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-27T12:32:09Z", "type": "commit"}, {"oid": "7f1940d48e19cb0abef12d59f06f4932754a422c", "url": "https://github.com/elastic/elasticsearch/commit/7f1940d48e19cb0abef12d59f06f4932754a422c", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-27T12:47:26Z", "type": "commit"}, {"oid": "879e7d601828d03e36337363701f1bc9ae4aafab", "url": "https://github.com/elastic/elasticsearch/commit/879e7d601828d03e36337363701f1bc9ae4aafab", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-27T12:58:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1Mjg3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r399352879", "bodyText": "Should we check the acknowledgedResponse here and retry (throw an error) if the request wasn't acknowledged? I think we should", "author": "dakrone", "createdAt": "2020-03-27T15:35:12Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.repositories.RepositoryMissingException;\n+import org.elasticsearch.snapshots.SnapshotMissingException;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Deletes the snapshot designated by the repository and snapshot name present in the lifecycle execution state.\n+ */\n+public class CleanupSnapshotStep extends AsyncRetryDuringSnapshotActionStep {\n+    public static final String NAME = \"cleanup-snapshot\";\n+\n+    public CleanupSnapshotStep(StepKey key, StepKey nextStepKey, Client client) {\n+        super(key, nextStepKey, client);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    void performDuringNoSnapshot(IndexMetaData indexMetaData, ClusterState currentClusterState, Listener listener) {\n+        final String indexName = indexMetaData.getIndex().getName();\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+        final String repositoryName = lifecycleState.getSnapshotRepository();\n+        // if the snapshot information is missing from the ILM execution state there is nothing to delete so we move on\n+        if (Strings.hasText(repositoryName) == false) {\n+            listener.onResponse(true);\n+            return;\n+        }\n+        final String snapshotName = lifecycleState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            listener.onResponse(true);\n+            return;\n+        }\n+        DeleteSnapshotRequest deleteSnapshotRequest = new DeleteSnapshotRequest(repositoryName, snapshotName);\n+        getClient().admin().cluster().deleteSnapshot(deleteSnapshotRequest, new ActionListener<>() {\n+\n+            @Override\n+            public void onResponse(AcknowledgedResponse acknowledgedResponse) {\n+                listener.onResponse(true);", "originalCommit": "879e7d601828d03e36337363701f1bc9ae4aafab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQxNTYzMg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r399415632", "bodyText": "Super minor, but we can probably stick this before the targetIndexMetadata == null check to avoid an error where no settings are copied?", "author": "dakrone", "createdAt": "2020-03-27T17:08:51Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.Index;\n+\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+/**\n+ * Copy the provided settings from the source to the target index.\n+ * <p>\n+ * The target index is derived from the source index using the provided prefix.\n+ * This is useful for actions like shrink or searchable snapshot that create a new index and migrate the ILM execution from the source\n+ * to the target index.\n+ */\n+public class CopySettingsStep extends ClusterStateActionStep {\n+    public static final String NAME = \"copy-settings\";\n+\n+    private static final Logger logger = LogManager.getLogger(CopySettingsStep.class);\n+\n+    private final String[] settingsKeys;\n+    private final String indexPrefix;\n+\n+    public CopySettingsStep(StepKey key, StepKey nextStepKey, String indexPrefix, String... settingsKeys) {\n+        super(key, nextStepKey);\n+        Objects.requireNonNull(indexPrefix);\n+        Objects.requireNonNull(settingsKeys);\n+        this.indexPrefix = indexPrefix;\n+        this.settingsKeys = settingsKeys;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    public String[] getSettingsKeys() {\n+        return settingsKeys;\n+    }\n+\n+    public String getIndexPrefix() {\n+        return indexPrefix;\n+    }\n+\n+    @Override\n+    public ClusterState performAction(Index index, ClusterState clusterState) {\n+        String sourceIndexName = index.getName();\n+        IndexMetaData sourceIndexMetadata = clusterState.metaData().index(sourceIndexName);\n+        String targetIndexName = indexPrefix + sourceIndexName;\n+        IndexMetaData targetIndexMetadata = clusterState.metaData().index(targetIndexName);\n+\n+        if (sourceIndexMetadata == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), sourceIndexName);\n+            return clusterState;\n+        }\n+\n+        if (targetIndexMetadata == null) {\n+            String errorMessage = String.format(Locale.ROOT, \"index [%s] is being referenced by ILM action [%s] on step [%s] but \" +\n+                \"it doesn't exist\", targetIndexName, getKey().getAction(), getKey().getName());\n+            logger.debug(errorMessage);\n+            throw new IllegalStateException(errorMessage);\n+        }\n+\n+        if (settingsKeys == null || settingsKeys.length == 0) {\n+            return clusterState;\n+        }", "originalCommit": "879e7d601828d03e36337363701f1bc9ae4aafab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQxNzIzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r399417239", "bodyText": "It might be worth having a separate discussion (I can't remember if we discussed it) with David & Co about whether we want the default for this to be true or false (can be had after this PR)", "author": "dakrone", "createdAt": "2020-03-27T17:11:37Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/DeleteAction.java", "diffHunk": "@@ -5,38 +5,63 @@\n  */\n package org.elasticsearch.xpack.core.ilm;\n \n+import org.elasticsearch.Version;\n import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.ParseField;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n-import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n import org.elasticsearch.common.xcontent.XContentParser;\n \n import java.io.IOException;\n import java.util.Arrays;\n import java.util.List;\n+import java.util.Objects;\n \n /**\n  * A {@link LifecycleAction} which deletes the index.\n  */\n public class DeleteAction implements LifecycleAction {\n     public static final String NAME = \"delete\";\n \n-    private static final ObjectParser<DeleteAction, Void> PARSER = new ObjectParser<>(NAME, DeleteAction::new);\n+    public static final ParseField DELETE_SEARCHABLE_SNAPSHOT_FIELD = new ParseField(\"delete_searchable_snapshot\");\n+\n+    private static final ConstructingObjectParser<DeleteAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new DeleteAction(a[0] == null ? true : (boolean) a[0]));\n+\n+    static {\n+        PARSER.declareBoolean(ConstructingObjectParser.optionalConstructorArg(), DELETE_SEARCHABLE_SNAPSHOT_FIELD);\n+    }\n \n     public static DeleteAction parse(XContentParser parser) {\n         return PARSER.apply(parser, null);\n     }\n \n+    private final boolean deleteSearchableSnapshot;\n+\n     public DeleteAction() {\n+        this(true);", "originalCommit": "879e7d601828d03e36337363701f1bc9ae4aafab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQxODEzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r399418139", "bodyText": "Super minor, but can you put an example name in the docs here like \"for example, the snapshot will be named '2020-01-02-myindex-mypolicy-randomuuid'\"?", "author": "dakrone", "createdAt": "2020-03-27T17:13:10Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.index.Index;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.ILM_CUSTOM_METADATA_KEY;\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Generates a snapshot name for the given index and records it in the index metadata along with the provided snapshot repository.", "originalCommit": "879e7d601828d03e36337363701f1bc9ae4aafab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyMDc1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r399420759", "bodyText": "Super minor change:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                throw new ElasticsearchException(\"mount snapshot response failed to complete\");\n          \n          \n            \n                                throw new ElasticsearchException(\"mount snapshot response failed to complete, got response \" + response.status());", "author": "dakrone", "createdAt": "2020-03-27T17:17:31Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MountSnapshotStep.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n+\n+import java.util.Objects;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Restores the snapshot created for the designated index via the ILM policy to an index named using the provided prefix appended to the\n+ * designated index name.\n+ */\n+public class MountSnapshotStep extends AsyncRetryDuringSnapshotActionStep {\n+    public static final String NAME = \"mount-snapshot\";\n+\n+    private static final Logger logger = LogManager.getLogger(MountSnapshotStep.class);\n+\n+    private final String restoredIndexPrefix;\n+\n+    public MountSnapshotStep(StepKey key, StepKey nextStepKey, Client client, String restoredIndexPrefix) {\n+        super(key, nextStepKey, client);\n+        this.restoredIndexPrefix = restoredIndexPrefix;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    public String getRestoredIndexPrefix() {\n+        return restoredIndexPrefix;\n+    }\n+\n+    @Override\n+    void performDuringNoSnapshot(IndexMetaData indexMetaData, ClusterState currentClusterState, Listener listener) {\n+        final String indexName = indexMetaData.getIndex().getName();\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+\n+        String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        final String snapshotRepository = lifecycleState.getSnapshotRepository();\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            listener.onFailure(new IllegalStateException(\"snapshot repository is not present for policy [\" + policyName + \"] and index [\" +\n+                indexName + \"]\"));\n+            return;\n+        }\n+\n+        final String snapshotName = lifecycleState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            listener.onFailure(\n+                new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName + \"] and index [\" + indexName + \"]\"));\n+            return;\n+        }\n+\n+        String mountedIndexName = restoredIndexPrefix + indexName;\n+        if(currentClusterState.metaData().index(mountedIndexName) != null) {\n+            logger.debug(\"mounted index [{}] for policy [{}] and index [{}] already exists. will not attempt to mount the index again\",\n+                mountedIndexName, policyName, indexName);\n+            listener.onResponse(true);\n+            return;\n+        }\n+\n+        final MountSearchableSnapshotRequest mountSearchableSnapshotRequest = new MountSearchableSnapshotRequest(mountedIndexName,\n+            snapshotRepository, snapshotName, indexName, Settings.builder()\n+            .put(IndexSettings.INDEX_CHECK_ON_STARTUP.getKey(), Boolean.FALSE.toString())\n+            .build(),\n+            // we captured the index metadata when we took the snapshot. the index likely had the ILM execution state in the metadata.\n+            // if we were to restore the lifecycle.name setting, the restored index would be captured by the ILM runner and,\n+            // depending on what ILM execution state was captured at snapshot time, make it's way forward from _that_ step forward in\n+            // the ILM policy.\n+            // we'll re-set this setting on the restored index at a later step once we restored a deterministic execution state\n+            new String[]{LifecycleSettings.LIFECYCLE_NAME},\n+            // we'll not wait for the snapshot to complete in this step as the async steps are executed from threads that shouldn't\n+            // perform expensive operations (ie. clusterStateProcessed)\n+            false);\n+        getClient().execute(MountSearchableSnapshotAction.INSTANCE, mountSearchableSnapshotRequest,\n+            ActionListener.wrap(response -> {\n+                if (response.status() != RestStatus.OK) {\n+                    logger.debug(\"mount snapshot response failed to complete\");\n+                    throw new ElasticsearchException(\"mount snapshot response failed to complete\");", "originalCommit": "879e7d601828d03e36337363701f1bc9ae4aafab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyMTMyNg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r399421326", "bodyText": "I think this might be linking to the wrong thing, maybe\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * {@link BranchingStep} is a step whose next step is based on the {@link #asyncWaitAction} condition being met or not.\n          \n          \n            \n                 * {@link OnAsyncWaitBranchingStep} is a step whose next step is based on the {@link #asyncWaitAction} condition being met or not.", "author": "dakrone", "createdAt": "2020-03-27T17:18:34Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/OnAsyncWaitBranchingStep.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+\n+import java.util.Objects;\n+\n+/**\n+ * This step changes its {@link #getNextStepKey()} depending on the result of an {@link AsyncWaitStep}.\n+ * <p>\n+ * The next step key will point towards the \"wait action fulfilled\" step when the condition of the async action is met, and towards the\n+ * \"wait action unfulfilled\" step when the client instructs they'd like to stop waiting for the condition using the\n+ * {@link BranchingStepListener#onStopWaitingAndMoveToNextKey(ToXContentObject)}.\n+ * <p>\n+ * If the async action that's branching the execution results in a failure, the {@link #getNextStepKey()} is not set (as ILM would move\n+ * into the {@link ErrorStep} step).\n+ */\n+public class OnAsyncWaitBranchingStep extends AsyncWaitStep {\n+    public static final String NAME = \"async-branch\";\n+\n+    private static final Logger logger = LogManager.getLogger(OnAsyncWaitBranchingStep.class);\n+\n+    private StepKey nextStepKeyUnfulfilledWaitAction;\n+    private StepKey nextStepKeyFulfilledWaitAction;\n+    private TriConsumer<Client, IndexMetaData, BranchingStepListener> asyncWaitAction;\n+    private SetOnce<Boolean> onCompleteConditionMet;\n+\n+    /**\n+     * {@link BranchingStep} is a step whose next step is based on the {@link #asyncWaitAction} condition being met or not.", "originalCommit": "879e7d601828d03e36337363701f1bc9ae4aafab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyNjU0NA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r399426544", "bodyText": "I actually think we need to return true here, it's possible that the snapshot was taken and completed (prior to the step being updated), and then the cluster was restarted, so the SnapshotsInProgress is null and won't ever exist because the snapshot was successful, best to err on the side of moving forward and doing a check than be wedged I think", "author": "dakrone", "createdAt": "2020-03-27T17:27:15Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForSnapshotInProgressStep.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.snapshots.SnapshotsService;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * After we triggered a snapshot we'll wait until the snapshot is not executing anymore (ie. the SnapshotInProgress meta data doesn't\n+ * contain an entry for the snapshot we've triggered)\n+ */\n+public class WaitForSnapshotInProgressStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-snapshot\";\n+    private static final Logger logger = LogManager.getLogger(WaitForSnapshotInProgressStep.class);\n+\n+    WaitForSnapshotInProgressStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData indexMetaData = clusterState.metaData().index(index);\n+        String indexName = index.getName();\n+\n+        if (indexMetaData == null) {\n+            String errorMessage = String.format(Locale.ROOT, \"[%s] lifecycle action for index [%s] executed but index no longer exists\",\n+                getKey().getAction(), indexName);\n+            // Index must have been since deleted\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+\n+        String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(indexMetaData);\n+        final String snapshotRepository = executionState.getSnapshotRepository();\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            String errorMessage = String.format(Locale.ROOT, \"snapshot repository is not present for policy [%s] and index [%s]\",\n+                policyName, indexName);\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+        final String snapshotName = executionState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            String errorMessage = String.format(Locale.ROOT, \"snapshot name was not generated for policy [%s] and index [%s]\",\n+                policyName, indexName);\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+        final SnapshotsInProgress snapshotsInProgress = clusterState.custom(SnapshotsInProgress.TYPE);\n+        // we got here before the cluster state was updated with the (or any) snapshot being started, so we'll wait\n+        if (snapshotsInProgress == null) {\n+            return new Result(false, new Info(String.format(Locale.ROOT,\n+                \"snapshot [%s] generated by policy [%s] for index [%s] is still in progress\", snapshotName, policyName, indexName)));", "originalCommit": "879e7d601828d03e36337363701f1bc9ae4aafab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA1MzYxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r401053611", "bodyText": "Deleted the WaitForSnapshotInProgressStep altogether as we'll design a step that waits for a generation change in the repo metadata in a subsequent PR.", "author": "andreidan", "createdAt": "2020-03-31T16:34:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyNjU0NA=="}], "type": "inlineReview"}, {"oid": "01222af9d73ca08f70b7a0c19b6223994b746588", "url": "https://github.com/elastic/elasticsearch/commit/01222af9d73ca08f70b7a0c19b6223994b746588", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-30T15:53:12Z", "type": "commit"}, {"oid": "64a903d5bd9234e1f985c15ec0b1389738d1ab9e", "url": "https://github.com/elastic/elasticsearch/commit/64a903d5bd9234e1f985c15ec0b1389738d1ab9e", "message": "Update exception message\n\nCo-Authored-By: Lee Hinman <dakrone@users.noreply.github.com>", "committedDate": "2020-03-30T15:57:41Z", "type": "commit"}, {"oid": "6e4ede4c8d37e4f57615bc22a432d6dc9c206bc9", "url": "https://github.com/elastic/elasticsearch/commit/6e4ede4c8d37e4f57615bc22a432d6dc9c206bc9", "message": "Update javadoc\n\nCo-Authored-By: Lee Hinman <dakrone@users.noreply.github.com>", "committedDate": "2020-03-30T15:58:21Z", "type": "commit"}, {"oid": "864f4c320c4933b1a0320586cb68c7cc762aa1b4", "url": "https://github.com/elastic/elasticsearch/commit/864f4c320c4933b1a0320586cb68c7cc762aa1b4", "message": "Add example of generated snapshot name", "committedDate": "2020-03-30T16:08:06Z", "type": "commit"}, {"oid": "9bbb9dfd0575cb880a5d30a4dd0eb08867a823fb", "url": "https://github.com/elastic/elasticsearch/commit/9bbb9dfd0575cb880a5d30a4dd0eb08867a823fb", "message": "Fail CleanupSnapshotStep if the request is not acked", "committedDate": "2020-03-30T16:35:35Z", "type": "commit"}, {"oid": "2c61f0063170ca84ffe1db811a49fa00fd7be9fc", "url": "https://github.com/elastic/elasticsearch/commit/2c61f0063170ca84ffe1db811a49fa00fd7be9fc", "message": "Move empty settings check before target index check", "committedDate": "2020-03-30T16:39:21Z", "type": "commit"}, {"oid": "ac574b218493a9436f398882224b35da55bf89fd", "url": "https://github.com/elastic/elasticsearch/commit/ac574b218493a9436f398882224b35da55bf89fd", "message": "Delete WaitForSnapshotInProgressStepTests\n\nWe'll add a new way to save snapshot status api calls based on the\nrepository data generation in a future PR.", "committedDate": "2020-03-31T16:06:23Z", "type": "commit"}, {"oid": "567d067c116e335f97bbb5decf64c7623a78dcc4", "url": "https://github.com/elastic/elasticsearch/commit/567d067c116e335f97bbb5decf64c7623a78dcc4", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-31T16:11:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA4OTA5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r401089093", "bodyText": "Super minor, but there's a typo here (and in the name of the file):\nSearchableSnaposhotActionTests vs\nSearchableSnapshotActionTests", "author": "dakrone", "createdAt": "2020-03-31T17:29:16Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/SearchableSnaposhotActionTests.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusAction;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.test.client.NoOpClient;\n+import org.elasticsearch.xpack.core.ilm.OnAsyncWaitBranchingStep.BranchingStepListener;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.core.ilm.SearchableSnapshotAction.NAME;\n+import static org.elasticsearch.xpack.core.ilm.SearchableSnapshotAction.getCheckSnapshotStatusAsyncAction;\n+import static org.hamcrest.Matchers.is;\n+\n+public class SearchableSnaposhotActionTests extends AbstractActionTestCase<SearchableSnapshotAction> {", "originalCommit": "567d067c116e335f97bbb5decf64c7623a78dcc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1NzM4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r401157382", "bodyText": "Ah, it was hard to spot the typo, great eyes, thanks @dakrone !\nRegarding the action name, I renamed it to \"searchable_snapshot\" (lowercase) on purpose when we renamed \"snapshot-repository\" to \"snapshot_repository\" as I thought it was confusing to have a configuration that mixes scores and underscores eg.:\n  \"searchable-snapshot\" : { \n    \"snapshot_repository\" : \"snapshotRepositoryName\"\n  }\n\nI using underscores everywhere employs less cognitive load:\n  \"searchable_snapshot\" : { \n    \"snapshot_repository\" : \"snapshotRepositoryName\"\n  }", "author": "andreidan", "createdAt": "2020-03-31T19:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA4OTA5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1OTIzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r401159235", "bodyText": "The other \"composed\" action we have is set_priority so it would be inconsistent to use scores. If you don't have a strong opinion on this, I think I'd prefer we use underscores everywhere.", "author": "andreidan", "createdAt": "2020-03-31T19:25:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA4OTA5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE5MDk5NA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r401190994", "bodyText": "I read the other one as the step name rather than the action name, I agree that the action name should use underscores (like our other ones), sorry about that!", "author": "dakrone", "createdAt": "2020-03-31T20:22:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA4OTA5Mw=="}], "type": "inlineReview"}, {"oid": "b766806365d2a48157207275c3ca48f85c95fb8b", "url": "https://github.com/elastic/elasticsearch/commit/b766806365d2a48157207275c3ca48f85c95fb8b", "message": "Fix typo", "committedDate": "2020-03-31T19:23:45Z", "type": "commit"}]}