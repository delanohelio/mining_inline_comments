{"pr_number": 56734, "pr_title": "Ensure that .watcher-history-11* template is in installed prior to use", "pr_createdAt": "2020-05-14T01:28:58Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/56734", "timeline": [{"oid": "fd67002dc0c125883dc96a440f10fbc3e9af8308", "url": "https://github.com/elastic/elasticsearch/commit/fd67002dc0c125883dc96a440f10fbc3e9af8308", "message": "Ensure that .watcher-history-11* template is in installed prior to use\n\n[WatcherIndexTemplateRegistry](https://github.com/elastic/elasticsearch/blob/7.7/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/support/WatcherIndexTemplateRegistry.java#L74)\nas of https://github.com/elastic/elasticsearch/pull/52962 requires all nodes\nto be on 7.7.0 before it allows the version 11 index template to be installed.\n\nWhile in a mixed cluster, nothing prevents Watcher from running on the new\nhost before the all of the nodes are on 7.7.0. This will result in the\n.watcher-history-11* index without the proper mappings. Without the proper\nmapping a single document (for a large watch) can exceed the default 1000 field\nlimit and cause error to show in the logs.\n\nThis commit ensures the same logic for writing to the index is applied as for\ninstalling the template. In a mixed cluster, the `10` index template will continue\nto be written. Only once all of nodes are on 7.7.0+ will the `11` index template\nbe installed and used.\n\nNote - this PR targets 7.x and will be back ported to 7.7.next. This conditional\ninstallation of the template is not present in master.\n\ncloses #56732", "committedDate": "2020-05-14T01:26:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyMjIyOA==", "url": "https://github.com/elastic/elasticsearch/pull/56734#discussion_r424822228", "bodyText": "I bumped this up to info to better match the upgrading index template message. The adding of the template gets logged on the master node (at info level) but having this at info level helps to make the upgrade/add consistent (since this doesn't always happen on master).", "author": "jakelandis", "createdAt": "2020-05-14T01:34:44Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/template/IndexTemplateRegistry.java", "diffHunk": "@@ -154,7 +154,7 @@ private void addTemplatesIfMissing(ClusterState state) {\n             if (creationCheck.compareAndSet(false, true)) {\n                 IndexTemplateMetadata currentTemplate = state.metadata().getTemplates().get(templateName);\n                 if (Objects.isNull(currentTemplate)) {\n-                    logger.debug(\"adding index template [{}] for [{}], because it doesn't exist\", templateName, getOrigin());\n+                    logger.info(\"adding index template [{}] for [{}], because it doesn't exist\", templateName, getOrigin());", "originalCommit": "fd67002dc0c125883dc96a440f10fbc3e9af8308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ1NzM3OA==", "url": "https://github.com/elastic/elasticsearch/pull/56734#discussion_r425457378", "bodyText": "Why don't we about we extract this boolean to a parameter and always run both, rather than randomizing? This is a unit test, so it should be too expensive to do so, and that way the suite is guaranteed to catch breakage in a single test run.", "author": "gwbrown", "createdAt": "2020-05-14T22:05:33Z", "path": "x-pack/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/history/HistoryStoreTests.java", "diffHunk": "@@ -105,14 +120,21 @@ public void testPut() throws Exception {\n     }\n \n     public void testIndexNameGeneration() {\n-        String indexTemplateVersion = Integer.toString(INDEX_TEMPLATE_VERSION);\n-        assertThat(getHistoryIndexNameForTime(Instant.ofEpochMilli((long) 0).atZone(ZoneOffset.UTC)),\n-            equalTo(\".watcher-history-\"+ indexTemplateVersion +\"-1970.01.01\"));\n-        assertThat(getHistoryIndexNameForTime(Instant.ofEpochMilli(100000000000L).atZone(ZoneOffset.UTC)),\n+        String indexTemplateVersion;\n+        if (randomBoolean()) {", "originalCommit": "fd67002dc0c125883dc96a440f10fbc3e9af8308", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg0NTI2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/56734#discussion_r425845261", "bodyText": "done", "author": "jakelandis", "createdAt": "2020-05-15T14:36:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ1NzM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ1OTgxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/56734#discussion_r425459819", "bodyText": "Do you think it might be better to change this to a Supplier<ClusterState> so that it's clearer that we just need to access the current ClusterState? That would let us simplify the mocking a bit and make it clearer that we're not e.g. adding listeners here.", "author": "gwbrown", "createdAt": "2020-05-14T22:11:29Z", "path": "x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/history/HistoryStore.java", "diffHunk": "@@ -31,17 +32,19 @@\n     private static final Logger logger = LogManager.getLogger(HistoryStore.class);\n \n     private final BulkProcessor bulkProcessor;\n+    private final ClusterService clusterService;\n \n-    public HistoryStore(BulkProcessor bulkProcessor) {\n+    public HistoryStore(BulkProcessor bulkProcessor, ClusterService clusterService) {", "originalCommit": "fd67002dc0c125883dc96a440f10fbc3e9af8308", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg0NTI1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/56734#discussion_r425845253", "bodyText": "done", "author": "jakelandis", "createdAt": "2020-05-15T14:36:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ1OTgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ2MDY2MA==", "url": "https://github.com/elastic/elasticsearch/pull/56734#discussion_r425460660", "bodyText": "We should get the state once and pass the same state to each check, to ensure the behavior is consistent if the state changes out from under us.", "author": "gwbrown", "createdAt": "2020-05-14T22:13:43Z", "path": "x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/Watcher.java", "diffHunk": "@@ -623,14 +623,14 @@ static void validAutoCreateIndex(Settings settings, Logger logger) {\n         indices.add(\".watches\");\n         indices.add(\".triggered_watches\");\n         ZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\n-        indices.add(HistoryStoreField.getHistoryIndexNameForTime(now));\n-        indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusDays(1)));\n-        indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusMonths(1)));\n-        indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusMonths(2)));\n-        indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusMonths(3)));\n-        indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusMonths(4)));\n-        indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusMonths(5)));\n-        indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusMonths(6)));\n+        indices.add(HistoryStoreField.getHistoryIndexNameForTime(now, clusterService.state()));\n+        indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusDays(1), clusterService.state()));\n+        indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusMonths(1), clusterService.state()));\n+        indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusMonths(2), clusterService.state()));\n+        indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusMonths(3), clusterService.state()));\n+        indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusMonths(4), clusterService.state()));\n+        indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusMonths(5), clusterService.state()));\n+        indices.add(HistoryStoreField.getHistoryIndexNameForTime(now.plusMonths(6), clusterService.state()));", "originalCommit": "fd67002dc0c125883dc96a440f10fbc3e9af8308", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg0NTI4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/56734#discussion_r425845285", "bodyText": "done", "author": "jakelandis", "createdAt": "2020-05-15T14:36:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ2MDY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ2MzQzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/56734#discussion_r425463431", "bodyText": "Just double checking: This doesn't result in different behavior, right? Just makes the failure occur (if it occurs) at a different time during node startup.\n(also, my assumption is that this moved because at the time the constructor is called we don't have a cluster state yet, correct?)", "author": "gwbrown", "createdAt": "2020-05-14T22:21:11Z", "path": "x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/Watcher.java", "diffHunk": "@@ -259,6 +255,10 @@ public Watcher(final Settings settings) {\n                                                NodeEnvironment nodeEnvironment, NamedWriteableRegistry namedWriteableRegistry,\n                                                IndexNameExpressionResolver expressionResolver,\n                                                Supplier<RepositoriesService> repositoriesServiceSupplier) {\n+        if (enabled && transportClient == false) {\n+            validAutoCreateIndex(settings, logger, clusterService);\n+        }", "originalCommit": "fd67002dc0c125883dc96a440f10fbc3e9af8308", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgzNzQ5NA==", "url": "https://github.com/elastic/elasticsearch/pull/56734#discussion_r425837494", "bodyText": "correct, same behavior and moved to allow access the the cluster state.", "author": "jakelandis", "createdAt": "2020-05-15T14:24:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ2MzQzMQ=="}], "type": "inlineReview"}, {"oid": "123453ccfff325b6fa364944dd19a37bc7e789c2", "url": "https://github.com/elastic/elasticsearch/commit/123453ccfff325b6fa364944dd19a37bc7e789c2", "message": "review changes", "committedDate": "2020-05-15T14:31:19Z", "type": "commit"}, {"oid": "92a3622bd913e453cf5d10bdc70d2f8d2d6e3462", "url": "https://github.com/elastic/elasticsearch/commit/92a3622bd913e453cf5d10bdc70d2f8d2d6e3462", "message": "Merge branch '7.x' into fix/56732", "committedDate": "2020-05-15T15:06:21Z", "type": "commit"}, {"oid": "7a8006806fcb03b60544804986fb5f9d856c6f34", "url": "https://github.com/elastic/elasticsearch/commit/7a8006806fcb03b60544804986fb5f9d856c6f34", "message": "remove premature cluster state read", "committedDate": "2020-05-15T15:23:52Z", "type": "commit"}, {"oid": "05e28754f697b437dcf673b3ab048438cfe3c9f5", "url": "https://github.com/elastic/elasticsearch/commit/05e28754f697b437dcf673b3ab048438cfe3c9f5", "message": "fix precommit", "committedDate": "2020-05-15T15:41:32Z", "type": "commit"}]}