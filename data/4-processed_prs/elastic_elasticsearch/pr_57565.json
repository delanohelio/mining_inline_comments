{"pr_number": 57565, "pr_title": "[DOCS] Editorial ILM cleanup", "pr_createdAt": "2020-06-02T21:53:30Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/57565", "timeline": [{"oid": "d2dea49ef29bb3ca43cbf31954b65babf42a9d4a", "url": "https://github.com/elastic/elasticsearch/commit/d2dea49ef29bb3ca43cbf31954b65babf42a9d4a", "message": "[DOCS] Editorial cleanup", "committedDate": "2020-06-02T21:48:49Z", "type": "commit"}, {"oid": "ed1aa27e1f6fc742fd76bc15e2b3d7a0d8f6fdc2", "url": "https://github.com/elastic/elasticsearch/commit/ed1aa27e1f6fc742fd76bc15e2b3d7a0d8f6fdc2", "message": "Moved example of applying a template to multiple indices.", "committedDate": "2020-06-02T22:07:53Z", "type": "commit"}, {"oid": "0691bd7455f65c7abdd668e939c6b0bcfed6391e", "url": "https://github.com/elastic/elasticsearch/commit/0691bd7455f65c7abdd668e939c6b0bcfed6391e", "message": "Combine existing indices topics", "committedDate": "2020-06-02T22:22:42Z", "type": "commit"}, {"oid": "d79b91be9e8d55a22d547480be8c6e12d4d62017", "url": "https://github.com/elastic/elasticsearch/commit/d79b91be9e8d55a22d547480be8c6e12d4d62017", "message": "Fixed test", "committedDate": "2020-06-02T23:16:41Z", "type": "commit"}, {"oid": "d79b91be9e8d55a22d547480be8c6e12d4d62017", "url": "https://github.com/elastic/elasticsearch/commit/d79b91be9e8d55a22d547480be8c6e12d4d62017", "message": "Fixed test", "committedDate": "2020-06-02T23:16:41Z", "type": "forcePushed"}, {"oid": "453e8ad99497f9e4b1134579a14c0ab6429210cc", "url": "https://github.com/elastic/elasticsearch/commit/453e8ad99497f9e4b1134579a14c0ab6429210cc", "message": "Add skip rollover file.", "committedDate": "2020-06-02T23:25:56Z", "type": "commit"}, {"oid": "e452932c22cea6de876d8ca266ee9c40d688937e", "url": "https://github.com/elastic/elasticsearch/commit/e452932c22cea6de876d8ca266ee9c40d688937e", "message": "Revert rename.", "committedDate": "2020-06-02T23:54:26Z", "type": "commit"}, {"oid": "ea1a3fa54db169481dff79cd6a17e11355cc1af6", "url": "https://github.com/elastic/elasticsearch/commit/ea1a3fa54db169481dff79cd6a17e11355cc1af6", "message": "Update include.", "committedDate": "2020-06-02T23:55:03Z", "type": "commit"}, {"oid": "129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "url": "https://github.com/elastic/elasticsearch/commit/129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "message": "Revert rename", "committedDate": "2020-06-02T23:56:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxOTg5MA==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r434619890", "bodyText": "Minor nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can restart or stop {ilm-init} with the\n          \n          \n            \n            You can start or stop {ilm-init} with the\n          \n      \n    \n    \n  \n\nbecause we don't have an API to go from STARTED -> STOPPING -> STOPPED -> STARTED in one go", "author": "dakrone", "createdAt": "2020-06-03T14:40:31Z", "path": "docs/reference/ilm/apis/get-status.asciidoc", "diffHunk": "@@ -25,9 +25,10 @@ Retrieves the current {ilm} ({ilm-init}) status.\n [[ilm-get-status-desc]]\n ==== {api-description-title}\n \n-Returns the status of the {ilm-init} plugin. The `operation_mode` field in the\n-response shows one of three states: `STARTED`, `STOPPING`,\n-or `STOPPED`. You can change the status of the {ilm-init} plugin with the\n+[[ilm-operating-modes]]\n+Returns the status of the {ilm-init} plugin. \n+The `operation_mode` in the response shows one of three states: `STARTED`, `STOPPING`,or `STOPPED`. \n+You can restart or stop {ilm-init} with the", "originalCommit": "129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyMDgzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r434620839", "bodyText": "This line is outdated now, because ILM does automatically retry some steps, not sure what the best way to encapsulate that is however.", "author": "dakrone", "createdAt": "2020-06-03T14:41:51Z", "path": "docs/reference/ilm/error-handling.asciidoc", "diffHunk": "@@ -1,20 +1,20 @@\n [role=\"xpack\"]\n [testenv=\"basic\"]\n [[index-lifecycle-error-handling]]\n-== Index lifecycle error handling\n+== Resolve lifecycle policy execution errors\n \n-During Index Lifecycle Management's execution of the policy for an index, it's\n-possible for a step to encounter an error during its execution. When this\n-happens, {ilm-init} will move the management state into an \"error\" step. This halts\n-further execution of the policy and gives an administrator the chance to address\n-any issues with the policy, index, or cluster.\n+When {ilm-init} executes a lifecycle policy, it's possible for errors to occur\n+while performing the necessary index operations for a step. \n+When this happens, {ilm-init} moves the index to an `ERROR` step. \n+This halts execution of the policy until you resolve the underlying\n+issues with the policy, index, or cluster.", "originalCommit": "129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyMjA1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r434622057", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            you need to explicitly tell {ilm-init} to retry the step:\n          \n          \n            \n            you may need to explicitly tell {ilm-init} to retry the step:\n          \n      \n    \n    \n  \n\nBecause some steps will be automatically retried", "author": "dakrone", "createdAt": "2020-06-03T14:43:36Z", "path": "docs/reference/ilm/error-handling.asciidoc", "diffHunk": "@@ -141,19 +135,16 @@ PUT _ilm/policy/shrink-the-index\n // TEST[continued]\n \n [discrete]\n-=== Retrying failed index lifecycle management steps\n+=== Retrying failed lifecycle policy steps\n \n-Once the underlying issue that caused an index to move to the error step has\n-been corrected, index lifecycle management must be told to retry the step to see\n-if it can progress further. This is accomplished by invoking the retry API\n+Once you fix the problem that put an index in the `ERROR` step, \n+you need to explicitly tell {ilm-init} to retry the step:", "originalCommit": "129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MzM0MA==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r436193340", "bodyText": "Fixed.", "author": "debadair", "createdAt": "2020-06-05T22:33:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyMjA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyNDE5NA==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r434624194", "bodyText": "This actually is misleading, because it's the size of primary shards, so the elision of \"index\" is intentional. I think we should either take it out or change it to \"shard\"", "author": "dakrone", "createdAt": "2020-06-03T14:46:32Z", "path": "docs/reference/ilm/ilm-overview.asciidoc", "diffHunk": "@@ -11,22 +11,22 @@ You can create and apply {ilm-cap} ({ilm-init}) policies to automatically manage\n according to your performance, resiliency, and retention requirements. \n Index lifecycle policies can trigger actions such as:\n \n-* **Rollover** - \n+* **Rollover**: \n include::../glossary.asciidoc[tag=rollover-def-short]\n-* **Shrink** - \n+* **Shrink**: \n include::../glossary.asciidoc[tag=shrink-def-short]\n-* **Force merge** - \n+* **Force merge**: \n include::../glossary.asciidoc[tag=force-merge-def-short]\n-* **Freeze** -\n+* **Freeze**:\n include::../glossary.asciidoc[tag=freeze-def-short]\n-* **Delete** - Permanently remove an index, including all of its data and metadata.\n+* **Delete**: Permanently remove an index, including all of its data and metadata.\n \n {ilm-init} makes it easier to manage indices in hot-warm-cold architectures,\n which are common when you're working with time-series data such as logs and metrics.\n \n You can specify:\n \n-* The maximum size, number of documents, or age at which you want to roll over to a new index.\n+* The maximum index size, number of documents, or age at which you want to roll over to a new index.", "originalCommit": "129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyNzAzNA==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r434627034", "bodyText": "It might be worth mentioning that if the index is manually rolled over (with the rollover API for instance), you don't need to set this setting", "author": "dakrone", "createdAt": "2020-06-03T14:50:16Z", "path": "docs/reference/ilm/ilm-skip-rollover.asciidoc", "diffHunk": "@@ -0,0 +1,33 @@\n+[[skipping-rollover]]\n+== Skip rollover\n+\n+When `index.lifecycle.indexing_complete` is set to `true`, \n+{ilm-init} won't perform the rollover action on an index, \n+even if it otherwise meets the rollover criteria. \n+It's set automatically by {ilm-init} when the rollover action completes successfully.\n+\n+You can set it manually to skip rollover if you need to make an exception\n+to your normal lifecycle policy and update the alias to force a roll over, \n+but want {ilm-init} to continue to manage the index.", "originalCommit": "129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyODUxMg==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r434628512", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            NOTE: Starting in version 5.7, Curator ignores {ilm-init} managed indices.\n          \n          \n            \n            NOTE: Starting in Curator version 5.7, Curator ignores {ilm-init} managed indices.\n          \n      \n    \n    \n  \n\nOtherwise it's ambiguous whether it's ES or Curator version", "author": "dakrone", "createdAt": "2020-06-03T14:52:15Z", "path": "docs/reference/ilm/ilm-with-existing-indices.asciidoc", "diffHunk": "@@ -3,293 +3,109 @@\n [[ilm-with-existing-indices]]\n == Manage existing indices\n \n-NOTE:  If migrating from Curator, ensure you are running Curator version 5.7 or greater\n-so that Curator will ignore ILM managed indices.\n+If you've been using Curator or some other mechanism to manage periodic indices,\n+you have a couple options when migrating to {ilm-init}:\n \n-While it is recommended to use {ilm-init} to manage the index lifecycle from\n-start to finish, it may be useful to use {ilm-init} with existing indices,\n-for example, when migrating from daily indices to rollover-based indices. \n-Such use cases are fully supported, but there are some configuration differences \n-from when {ilm-init} can manage the complete index lifecycle.\n+* Set up your index templates to use an {ilm-init} policy to manage your new indices. \n+Once {ilm-init} is managing your current write index, you can apply an appropriate policy to your old indices.\n \n-This section describes strategies to leverage {ilm-init} for existing periodic\n-indices when migrating to fully {ilm-init}-manged indices, which can be done in\n-a few different ways, each providing different tradeoffs. As an example, we'll\n-walk through a use case of a very simple logging index with just a field for the\n-log message and a timestamp.\n+* Reindex into an {ilm-init}-managed index. \n \n-First, we need to create a template for these indices:\n+NOTE: Starting in version 5.7, Curator ignores {ilm-init} managed indices.", "originalCommit": "129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyOTMwMA==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r434629300", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            or set the <<index-lifecycle-origination-date, `index.lifecycle.origination_date`>> \n          \n          \n            \n            or set <<index-lifecycle-origination-date, `index.lifecycle.origination_date`>>", "author": "dakrone", "createdAt": "2020-06-03T14:53:23Z", "path": "docs/reference/ilm/ilm-with-existing-indices.asciidoc", "diffHunk": "@@ -3,293 +3,109 @@\n [[ilm-with-existing-indices]]\n == Manage existing indices\n \n-NOTE:  If migrating from Curator, ensure you are running Curator version 5.7 or greater\n-so that Curator will ignore ILM managed indices.\n+If you've been using Curator or some other mechanism to manage periodic indices,\n+you have a couple options when migrating to {ilm-init}:\n \n-While it is recommended to use {ilm-init} to manage the index lifecycle from\n-start to finish, it may be useful to use {ilm-init} with existing indices,\n-for example, when migrating from daily indices to rollover-based indices. \n-Such use cases are fully supported, but there are some configuration differences \n-from when {ilm-init} can manage the complete index lifecycle.\n+* Set up your index templates to use an {ilm-init} policy to manage your new indices. \n+Once {ilm-init} is managing your current write index, you can apply an appropriate policy to your old indices.\n \n-This section describes strategies to leverage {ilm-init} for existing periodic\n-indices when migrating to fully {ilm-init}-manged indices, which can be done in\n-a few different ways, each providing different tradeoffs. As an example, we'll\n-walk through a use case of a very simple logging index with just a field for the\n-log message and a timestamp.\n+* Reindex into an {ilm-init}-managed index. \n \n-First, we need to create a template for these indices:\n+NOTE: Starting in version 5.7, Curator ignores {ilm-init} managed indices.\n \n-[source,console]\n------------------------\n-PUT _template/mylogs_template\n-{\n-  \"index_patterns\": [\n-    \"mylogs-*\"\n-  ],\n-  \"settings\": {\n-    \"number_of_shards\": 1,\n-    \"number_of_replicas\": 1\n-  },\n-  \"mappings\": {\n-    \"properties\": {\n-      \"message\": {\n-        \"type\": \"text\"\n-      },\n-      \"@timestamp\": {\n-        \"type\": \"date\"\n-      }\n-    }\n-  }\n-}\n------------------------\n-\n-And we'll ingest a few documents to create a few daily indices:\n-\n-[source,console]\n------------------------\n-POST mylogs-pre-ilm-2019.06.24/_doc\n-{\n-  \"@timestamp\": \"2019-06-24T10:34:00\",\n-  \"message\": \"this is one log message\"\n-}\n------------------------\n-// TEST[continued]\n-\n-[source,console]\n------------------------\n-POST mylogs-pre-ilm-2019.06.25/_doc\n-{\n-  \"@timestamp\": \"2019-06-25T17:42:00\",\n-  \"message\": \"this is another log message\"\n-}\n------------------------\n-// TEST[continued]\n-\n-//////////////////////////\n-\n-[source,console]\n---------------------------------------------------\n-DELETE _template/mylogs_template\n---------------------------------------------------\n-// TEST[continued]\n-\n-//////////////////////////\n-\n-Now that we have these indices, we'll look at a few different ways of migrating\n-these indices to {ilm-init}.\n-\n-[[ilm-with-existing-periodic-indices]]\n-=== Managing existing periodic indices with {ilm-init}\n-\n-NOTE: The examples in this section assume daily indices as set up in\n-<<ilm-with-existing-indices,the previous section>>.\n-\n-The simplest way to manage existing indices while transitioning to fully\n-{ilm-init}-managed indices is to allow all new indices to be fully managed by\n-{ilm-init} before attaching {ilm-init} policies to existing indices. To do this,\n-all new documents should be directed to {ilm-init}-managed indices - if you are\n-using Beats or Logstash data shippers, upgrading all of those shippers to\n-version 7.0.0 or higher will take care of that part for you. If you are not\n-using Beats or Logstash, you may need to set up {ilm-init} for new indices yourself as\n-demonstrated in the <<getting-started-index-lifecycle-management,{ilm-init} tutorial>>.\n-\n-NOTE: If you are using Beats through Logstash, you may need to change your\n-Logstash output configuration and invoke the Beats setup to use {ilm-init} for new\n-data.\n-\n-Once all new documents are being written to fully {ilm-init}-managed indices, it\n-is easy to add an {ilm-init} policy to existing indices. However, there are two\n-things to keep in mind when doing this, and a trick that makes those two things\n-much easier to handle.\n-\n-The two biggest things to keep in mind are:\n-\n-1. Existing periodic indices shouldn't use policies with rollover, because\n-rollover is used to manage where new data goes. Since existing indices should no\n-longer be receiving new documents, there is no point to using rollover for them.\n-\n-2. {ilm-init} policies attached to existing indices will compare the `min_age`\n-for each phase to the original creation date of the index, and so might proceed\n-through multiple phases immediately.\n-\n-The first one is the most important, because it makes it difficult to use the\n-same policy for new and existing periodic indices. But that's easy to solve\n-with one simple trick: Create a second policy for existing indices, in addition\n-to the one for new indices. {ilm-init} policies are cheap to create, so don't be\n-afraid to have more than one. Modifying a policy designed for new indices to be\n-used on existing indices is generally very simple: just remove the `rollover`\n-action.\n-\n-For example, if you created a policy for your new indices with each phase\n-like so:\n-\n-[source,console]\n------------------------\n-PUT _ilm/policy/mylogs_policy\n-{\n-  \"policy\": {\n-    \"phases\": {\n-      \"hot\": {\n-        \"actions\": {\n-          \"rollover\": {\n-            \"max_size\": \"25GB\"\n-          }\n-        }\n-      },\n-      \"warm\": {\n-        \"min_age\": \"1d\",\n-        \"actions\": {\n-          \"forcemerge\": {\n-            \"max_num_segments\": 1\n-          }\n-        }\n-      },\n-      \"cold\": {\n-        \"min_age\": \"7d\",\n-        \"actions\": {\n-          \"freeze\": {}\n-        }\n-      },\n-      \"delete\": {\n-        \"min_age\": \"30d\",\n-        \"actions\": {\n-          \"delete\": {}\n-        }\n-      }\n-    }\n-  }\n-}\n------------------------\n-// TEST[continued]\n+[discrete]\n+[[ilm-existing-indices-apply]]\n+=== Apply policies to existing time series indices \n \n-You can create a policy for pre-existing indices by removing the `rollover`\n-action, and in this case, the `hot` phase is now empty so we can remove that\n-too:\n+The simplest way to transition to managing your periodic indices with {ilm-init} is\n+to <<apply-policy-template, configure an index template>> to apply a lifecycle policy to new indices. \n+Once the index you are writing to is being managed by {ilm-init}, \n+you can <<apply-policy-multiple, manually apply a policy>> to your older indices.\n \n-[source,console]\n------------------------\n-PUT _ilm/policy/mylogs_policy_existing\n-{\n-  \"policy\": {\n-    \"phases\": {\n-      \"warm\": {\n-        \"min_age\": \"1d\",\n-        \"actions\": {\n-          \"forcemerge\": {\n-            \"max_num_segments\": 1\n-          }\n-        }\n-      },\n-      \"cold\": {\n-        \"min_age\": \"7d\",\n-        \"actions\": {\n-          \"freeze\": {}\n-        }\n-      },\n-      \"delete\": {\n-        \"min_age\": \"30d\",\n-        \"actions\": {\n-          \"delete\": {}\n-        }\n-      }\n-    }\n-  }\n-}\n------------------------\n-// TEST[continued]\n+Define a separate policy for your older indices that omits the rollover action. \n+Rollover is used to manage where new data goes, so isn't applicable. \n \n-Creating a separate policy for existing indices will also allow using different\n-`min_age` values. You may want to use higher values to prevent many indices from\n-running through the policy at once, which may be important if your policy\n-includes potentially resource-intensive operations like force merge.\n+Keep in mind that policies applied to existing indices compare the `min_age` for each phase to \n+the original creation date of the index, and might proceed through multiple phases immediately.\n+If your policy performs resource-intensive operations like force merge, \n+you don't want to have a lot of indices performing those operations all at once\n+when you switch over to {ilm-init}. \n \n-You can configure the lifecycle for many indices at once by using wildcards in\n-the index name when calling the <<indices-update-settings,Update Settings API>>\n-to set the policy name, but be careful that you don't include any indices that\n-you don't want to change the policy for:\n+You can specify different `min_age` values in the policy you use for existing indices, \n+or set the <<index-lifecycle-origination-date, `index.lifecycle.origination_date`>> ", "originalCommit": "129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzMjA1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r434632059", "bodyText": "This can be misleading in that it is not a rollover-specific setting, so maybe:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <1> Check for rollover conditions every minute.\n          \n          \n            \n            <1> Check for ILM actions (rollover conditions, for example) every minute.", "author": "dakrone", "createdAt": "2020-06-03T14:57:12Z", "path": "docs/reference/ilm/ilm-with-existing-indices.asciidoc", "diffHunk": "@@ -3,293 +3,109 @@\n [[ilm-with-existing-indices]]\n == Manage existing indices\n \n-NOTE:  If migrating from Curator, ensure you are running Curator version 5.7 or greater\n-so that Curator will ignore ILM managed indices.\n+If you've been using Curator or some other mechanism to manage periodic indices,\n+you have a couple options when migrating to {ilm-init}:\n \n-While it is recommended to use {ilm-init} to manage the index lifecycle from\n-start to finish, it may be useful to use {ilm-init} with existing indices,\n-for example, when migrating from daily indices to rollover-based indices. \n-Such use cases are fully supported, but there are some configuration differences \n-from when {ilm-init} can manage the complete index lifecycle.\n+* Set up your index templates to use an {ilm-init} policy to manage your new indices. \n+Once {ilm-init} is managing your current write index, you can apply an appropriate policy to your old indices.\n \n-This section describes strategies to leverage {ilm-init} for existing periodic\n-indices when migrating to fully {ilm-init}-manged indices, which can be done in\n-a few different ways, each providing different tradeoffs. As an example, we'll\n-walk through a use case of a very simple logging index with just a field for the\n-log message and a timestamp.\n+* Reindex into an {ilm-init}-managed index. \n \n-First, we need to create a template for these indices:\n+NOTE: Starting in version 5.7, Curator ignores {ilm-init} managed indices.\n \n-[source,console]\n------------------------\n-PUT _template/mylogs_template\n-{\n-  \"index_patterns\": [\n-    \"mylogs-*\"\n-  ],\n-  \"settings\": {\n-    \"number_of_shards\": 1,\n-    \"number_of_replicas\": 1\n-  },\n-  \"mappings\": {\n-    \"properties\": {\n-      \"message\": {\n-        \"type\": \"text\"\n-      },\n-      \"@timestamp\": {\n-        \"type\": \"date\"\n-      }\n-    }\n-  }\n-}\n------------------------\n-\n-And we'll ingest a few documents to create a few daily indices:\n-\n-[source,console]\n------------------------\n-POST mylogs-pre-ilm-2019.06.24/_doc\n-{\n-  \"@timestamp\": \"2019-06-24T10:34:00\",\n-  \"message\": \"this is one log message\"\n-}\n------------------------\n-// TEST[continued]\n-\n-[source,console]\n------------------------\n-POST mylogs-pre-ilm-2019.06.25/_doc\n-{\n-  \"@timestamp\": \"2019-06-25T17:42:00\",\n-  \"message\": \"this is another log message\"\n-}\n------------------------\n-// TEST[continued]\n-\n-//////////////////////////\n-\n-[source,console]\n---------------------------------------------------\n-DELETE _template/mylogs_template\n---------------------------------------------------\n-// TEST[continued]\n-\n-//////////////////////////\n-\n-Now that we have these indices, we'll look at a few different ways of migrating\n-these indices to {ilm-init}.\n-\n-[[ilm-with-existing-periodic-indices]]\n-=== Managing existing periodic indices with {ilm-init}\n-\n-NOTE: The examples in this section assume daily indices as set up in\n-<<ilm-with-existing-indices,the previous section>>.\n-\n-The simplest way to manage existing indices while transitioning to fully\n-{ilm-init}-managed indices is to allow all new indices to be fully managed by\n-{ilm-init} before attaching {ilm-init} policies to existing indices. To do this,\n-all new documents should be directed to {ilm-init}-managed indices - if you are\n-using Beats or Logstash data shippers, upgrading all of those shippers to\n-version 7.0.0 or higher will take care of that part for you. If you are not\n-using Beats or Logstash, you may need to set up {ilm-init} for new indices yourself as\n-demonstrated in the <<getting-started-index-lifecycle-management,{ilm-init} tutorial>>.\n-\n-NOTE: If you are using Beats through Logstash, you may need to change your\n-Logstash output configuration and invoke the Beats setup to use {ilm-init} for new\n-data.\n-\n-Once all new documents are being written to fully {ilm-init}-managed indices, it\n-is easy to add an {ilm-init} policy to existing indices. However, there are two\n-things to keep in mind when doing this, and a trick that makes those two things\n-much easier to handle.\n-\n-The two biggest things to keep in mind are:\n-\n-1. Existing periodic indices shouldn't use policies with rollover, because\n-rollover is used to manage where new data goes. Since existing indices should no\n-longer be receiving new documents, there is no point to using rollover for them.\n-\n-2. {ilm-init} policies attached to existing indices will compare the `min_age`\n-for each phase to the original creation date of the index, and so might proceed\n-through multiple phases immediately.\n-\n-The first one is the most important, because it makes it difficult to use the\n-same policy for new and existing periodic indices. But that's easy to solve\n-with one simple trick: Create a second policy for existing indices, in addition\n-to the one for new indices. {ilm-init} policies are cheap to create, so don't be\n-afraid to have more than one. Modifying a policy designed for new indices to be\n-used on existing indices is generally very simple: just remove the `rollover`\n-action.\n-\n-For example, if you created a policy for your new indices with each phase\n-like so:\n-\n-[source,console]\n------------------------\n-PUT _ilm/policy/mylogs_policy\n-{\n-  \"policy\": {\n-    \"phases\": {\n-      \"hot\": {\n-        \"actions\": {\n-          \"rollover\": {\n-            \"max_size\": \"25GB\"\n-          }\n-        }\n-      },\n-      \"warm\": {\n-        \"min_age\": \"1d\",\n-        \"actions\": {\n-          \"forcemerge\": {\n-            \"max_num_segments\": 1\n-          }\n-        }\n-      },\n-      \"cold\": {\n-        \"min_age\": \"7d\",\n-        \"actions\": {\n-          \"freeze\": {}\n-        }\n-      },\n-      \"delete\": {\n-        \"min_age\": \"30d\",\n-        \"actions\": {\n-          \"delete\": {}\n-        }\n-      }\n-    }\n-  }\n-}\n------------------------\n-// TEST[continued]\n+[discrete]\n+[[ilm-existing-indices-apply]]\n+=== Apply policies to existing time series indices \n \n-You can create a policy for pre-existing indices by removing the `rollover`\n-action, and in this case, the `hot` phase is now empty so we can remove that\n-too:\n+The simplest way to transition to managing your periodic indices with {ilm-init} is\n+to <<apply-policy-template, configure an index template>> to apply a lifecycle policy to new indices. \n+Once the index you are writing to is being managed by {ilm-init}, \n+you can <<apply-policy-multiple, manually apply a policy>> to your older indices.\n \n-[source,console]\n------------------------\n-PUT _ilm/policy/mylogs_policy_existing\n-{\n-  \"policy\": {\n-    \"phases\": {\n-      \"warm\": {\n-        \"min_age\": \"1d\",\n-        \"actions\": {\n-          \"forcemerge\": {\n-            \"max_num_segments\": 1\n-          }\n-        }\n-      },\n-      \"cold\": {\n-        \"min_age\": \"7d\",\n-        \"actions\": {\n-          \"freeze\": {}\n-        }\n-      },\n-      \"delete\": {\n-        \"min_age\": \"30d\",\n-        \"actions\": {\n-          \"delete\": {}\n-        }\n-      }\n-    }\n-  }\n-}\n------------------------\n-// TEST[continued]\n+Define a separate policy for your older indices that omits the rollover action. \n+Rollover is used to manage where new data goes, so isn't applicable. \n \n-Creating a separate policy for existing indices will also allow using different\n-`min_age` values. You may want to use higher values to prevent many indices from\n-running through the policy at once, which may be important if your policy\n-includes potentially resource-intensive operations like force merge.\n+Keep in mind that policies applied to existing indices compare the `min_age` for each phase to \n+the original creation date of the index, and might proceed through multiple phases immediately.\n+If your policy performs resource-intensive operations like force merge, \n+you don't want to have a lot of indices performing those operations all at once\n+when you switch over to {ilm-init}. \n \n-You can configure the lifecycle for many indices at once by using wildcards in\n-the index name when calling the <<indices-update-settings,Update Settings API>>\n-to set the policy name, but be careful that you don't include any indices that\n-you don't want to change the policy for:\n+You can specify different `min_age` values in the policy you use for existing indices, \n+or set the <<index-lifecycle-origination-date, `index.lifecycle.origination_date`>> \n+to control how the index age is calculated. \n \n-[source,console]\n------------------------\n-PUT mylogs-pre-ilm*/_settings <1>\n-{\n-  \"index\": {\n-    \"lifecycle\": {\n-      \"name\": \"mylogs_policy_existing\"\n-    }\n-  }\n-}\n------------------------\n-// TEST[continued]\n+Once all pre-{ilm-init} indices have been aged out and removed, \n+you can delete the policy you used to manage them.\n \n-<1> This pattern will match all indices with names that start with\n-`mylogs-pre-ilm`\n+NOTE: If you are using {beats} or {ls}, enabling {ilm-init} in version 7.0 and onward\n+sets up {ilm-init} to manage new indices automatically. \n+If you are using {beats} through {ls}, \n+you might need to change your {ls} output configuration and invoke the {beats} setup \n+to use {ilm-init} for new data.\n \n-Once all pre-{ilm-init} indices have aged out and been deleted, the policy for\n-older periodic indices can be deleted.\n+[discrete]\n+[[ilm-existing-indices-reindex]]\n+=== Reindex into a managed index\n \n-[[ilm-reindexing-into-rollover]]\n-=== Reindexing via {ilm-init}\n+An alternative to <<ilm-with-existing-periodic-indices,applying policies to existing indices>> is to \n+reindex your data into an {ilm-init}-managed index.\n+You might want to do this if creating periodic indices with very small amounts of data  \n+has led to excessive shard counts, or if continually indexing into the same index has led to large shards\n+and performance issues.\n \n-NOTE: The examples in this section assume daily indices as set up in\n-<<ilm-with-existing-indices,the previous section>>.\n+First, you need to set up the new {ilm-init}-managed index:\n \n-In some cases, it may be useful to reindex data into {ilm-init}-managed indices.\n-This is more complex than simply attaching policies to existing indices as\n-described in <<ilm-with-existing-periodic-indices,the previous section>>, and\n-requires pausing indexing during the reindexing process. However, this technique\n-may be useful in cases where periodic indices were created with very small\n-amounts of data leading to excessive shard counts, or for indices which grow\n-steadily over time, but have not been broken up into time-series indices leading\n-to shards which are much too large, situations that cause significant\n-performance problems.\n+. Update your index template to include the necessary {ilm-init} settings.\n+. Bootstrap an initial index as the write index.\n+. Stop writing to the old indices and index new documents using the alias that points to bootstrapped index. \n \n-Before getting started with reindexing data, the new index structure should be\n-set up. For this section, we'll be using the same setup described in\n-<<ilm-with-existing-indices,{ilm-imit} with existing indices>>.\n+To reindex into the managed index:\n \n-First, we'll set up a policy with rollover, and can include any additional\n-phases required. For simplicity, we'll just use rollover:\n+. Pause indexing new documents if you do not want to mix new and old data in the {ilm-init}-managed index.\n+Mixing old and new data in one index is safe, \n+but a combined index needs to be retained until you are ready to delete the new data.\n \n+. Reduce the {ilm-init} poll interval to ensure that the index doesn't \n+grow too large while waiting for the rollover check.\n+By default, {ilm-init} checks rollover conditions every 10 minutes. \n++\n+--\n [source,console]\n -----------------------\n-PUT _ilm/policy/mylogs_condensed_policy\n+PUT _cluster/settings\n {\n-  \"policy\": {\n-    \"phases\": {\n-      \"hot\": {\n-        \"actions\": {\n-          \"rollover\": {\n-            \"max_age\": \"7d\",\n-            \"max_size\": \"50G\"\n-          }\n-        }\n-      }\n-    }\n+  \"transient\": {\n+    \"indices.lifecycle.poll_interval\": \"1m\" <1>\n   }\n }\n -----------------------\n-// TEST[continued]\n-\n-And now we'll update the index template for our indices to include the relevant\n-{ilm-init} settings:\n+// TEST[skip:don't want to overwrite this setting for other tests]\n+<1> Check for rollover conditions every minute.", "originalCommit": "129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5NjAxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r436196011", "bodyText": "Fixed.", "author": "debadair", "createdAt": "2020-06-05T22:44:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzMjA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzMzgyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r434633825", "bodyText": "Why was this policy removed? It seems strange since the point is to reindex into an index using ILM", "author": "dakrone", "createdAt": "2020-06-03T14:59:32Z", "path": "docs/reference/ilm/ilm-with-existing-indices.asciidoc", "diffHunk": "@@ -3,293 +3,109 @@\n [[ilm-with-existing-indices]]\n == Manage existing indices\n \n-NOTE:  If migrating from Curator, ensure you are running Curator version 5.7 or greater\n-so that Curator will ignore ILM managed indices.\n+If you've been using Curator or some other mechanism to manage periodic indices,\n+you have a couple options when migrating to {ilm-init}:\n \n-While it is recommended to use {ilm-init} to manage the index lifecycle from\n-start to finish, it may be useful to use {ilm-init} with existing indices,\n-for example, when migrating from daily indices to rollover-based indices. \n-Such use cases are fully supported, but there are some configuration differences \n-from when {ilm-init} can manage the complete index lifecycle.\n+* Set up your index templates to use an {ilm-init} policy to manage your new indices. \n+Once {ilm-init} is managing your current write index, you can apply an appropriate policy to your old indices.\n \n-This section describes strategies to leverage {ilm-init} for existing periodic\n-indices when migrating to fully {ilm-init}-manged indices, which can be done in\n-a few different ways, each providing different tradeoffs. As an example, we'll\n-walk through a use case of a very simple logging index with just a field for the\n-log message and a timestamp.\n+* Reindex into an {ilm-init}-managed index. \n \n-First, we need to create a template for these indices:\n+NOTE: Starting in version 5.7, Curator ignores {ilm-init} managed indices.\n \n-[source,console]\n------------------------\n-PUT _template/mylogs_template\n-{\n-  \"index_patterns\": [\n-    \"mylogs-*\"\n-  ],\n-  \"settings\": {\n-    \"number_of_shards\": 1,\n-    \"number_of_replicas\": 1\n-  },\n-  \"mappings\": {\n-    \"properties\": {\n-      \"message\": {\n-        \"type\": \"text\"\n-      },\n-      \"@timestamp\": {\n-        \"type\": \"date\"\n-      }\n-    }\n-  }\n-}\n------------------------\n-\n-And we'll ingest a few documents to create a few daily indices:\n-\n-[source,console]\n------------------------\n-POST mylogs-pre-ilm-2019.06.24/_doc\n-{\n-  \"@timestamp\": \"2019-06-24T10:34:00\",\n-  \"message\": \"this is one log message\"\n-}\n------------------------\n-// TEST[continued]\n-\n-[source,console]\n------------------------\n-POST mylogs-pre-ilm-2019.06.25/_doc\n-{\n-  \"@timestamp\": \"2019-06-25T17:42:00\",\n-  \"message\": \"this is another log message\"\n-}\n------------------------\n-// TEST[continued]\n-\n-//////////////////////////\n-\n-[source,console]\n---------------------------------------------------\n-DELETE _template/mylogs_template\n---------------------------------------------------\n-// TEST[continued]\n-\n-//////////////////////////\n-\n-Now that we have these indices, we'll look at a few different ways of migrating\n-these indices to {ilm-init}.\n-\n-[[ilm-with-existing-periodic-indices]]\n-=== Managing existing periodic indices with {ilm-init}\n-\n-NOTE: The examples in this section assume daily indices as set up in\n-<<ilm-with-existing-indices,the previous section>>.\n-\n-The simplest way to manage existing indices while transitioning to fully\n-{ilm-init}-managed indices is to allow all new indices to be fully managed by\n-{ilm-init} before attaching {ilm-init} policies to existing indices. To do this,\n-all new documents should be directed to {ilm-init}-managed indices - if you are\n-using Beats or Logstash data shippers, upgrading all of those shippers to\n-version 7.0.0 or higher will take care of that part for you. If you are not\n-using Beats or Logstash, you may need to set up {ilm-init} for new indices yourself as\n-demonstrated in the <<getting-started-index-lifecycle-management,{ilm-init} tutorial>>.\n-\n-NOTE: If you are using Beats through Logstash, you may need to change your\n-Logstash output configuration and invoke the Beats setup to use {ilm-init} for new\n-data.\n-\n-Once all new documents are being written to fully {ilm-init}-managed indices, it\n-is easy to add an {ilm-init} policy to existing indices. However, there are two\n-things to keep in mind when doing this, and a trick that makes those two things\n-much easier to handle.\n-\n-The two biggest things to keep in mind are:\n-\n-1. Existing periodic indices shouldn't use policies with rollover, because\n-rollover is used to manage where new data goes. Since existing indices should no\n-longer be receiving new documents, there is no point to using rollover for them.\n-\n-2. {ilm-init} policies attached to existing indices will compare the `min_age`\n-for each phase to the original creation date of the index, and so might proceed\n-through multiple phases immediately.\n-\n-The first one is the most important, because it makes it difficult to use the\n-same policy for new and existing periodic indices. But that's easy to solve\n-with one simple trick: Create a second policy for existing indices, in addition\n-to the one for new indices. {ilm-init} policies are cheap to create, so don't be\n-afraid to have more than one. Modifying a policy designed for new indices to be\n-used on existing indices is generally very simple: just remove the `rollover`\n-action.\n-\n-For example, if you created a policy for your new indices with each phase\n-like so:\n-\n-[source,console]\n------------------------\n-PUT _ilm/policy/mylogs_policy\n-{\n-  \"policy\": {\n-    \"phases\": {\n-      \"hot\": {\n-        \"actions\": {\n-          \"rollover\": {\n-            \"max_size\": \"25GB\"\n-          }\n-        }\n-      },\n-      \"warm\": {\n-        \"min_age\": \"1d\",\n-        \"actions\": {\n-          \"forcemerge\": {\n-            \"max_num_segments\": 1\n-          }\n-        }\n-      },\n-      \"cold\": {\n-        \"min_age\": \"7d\",\n-        \"actions\": {\n-          \"freeze\": {}\n-        }\n-      },\n-      \"delete\": {\n-        \"min_age\": \"30d\",\n-        \"actions\": {\n-          \"delete\": {}\n-        }\n-      }\n-    }\n-  }\n-}\n------------------------\n-// TEST[continued]\n+[discrete]\n+[[ilm-existing-indices-apply]]\n+=== Apply policies to existing time series indices \n \n-You can create a policy for pre-existing indices by removing the `rollover`\n-action, and in this case, the `hot` phase is now empty so we can remove that\n-too:\n+The simplest way to transition to managing your periodic indices with {ilm-init} is\n+to <<apply-policy-template, configure an index template>> to apply a lifecycle policy to new indices. \n+Once the index you are writing to is being managed by {ilm-init}, \n+you can <<apply-policy-multiple, manually apply a policy>> to your older indices.\n \n-[source,console]\n------------------------\n-PUT _ilm/policy/mylogs_policy_existing\n-{\n-  \"policy\": {\n-    \"phases\": {\n-      \"warm\": {\n-        \"min_age\": \"1d\",\n-        \"actions\": {\n-          \"forcemerge\": {\n-            \"max_num_segments\": 1\n-          }\n-        }\n-      },\n-      \"cold\": {\n-        \"min_age\": \"7d\",\n-        \"actions\": {\n-          \"freeze\": {}\n-        }\n-      },\n-      \"delete\": {\n-        \"min_age\": \"30d\",\n-        \"actions\": {\n-          \"delete\": {}\n-        }\n-      }\n-    }\n-  }\n-}\n------------------------\n-// TEST[continued]\n+Define a separate policy for your older indices that omits the rollover action. \n+Rollover is used to manage where new data goes, so isn't applicable. \n \n-Creating a separate policy for existing indices will also allow using different\n-`min_age` values. You may want to use higher values to prevent many indices from\n-running through the policy at once, which may be important if your policy\n-includes potentially resource-intensive operations like force merge.\n+Keep in mind that policies applied to existing indices compare the `min_age` for each phase to \n+the original creation date of the index, and might proceed through multiple phases immediately.\n+If your policy performs resource-intensive operations like force merge, \n+you don't want to have a lot of indices performing those operations all at once\n+when you switch over to {ilm-init}. \n \n-You can configure the lifecycle for many indices at once by using wildcards in\n-the index name when calling the <<indices-update-settings,Update Settings API>>\n-to set the policy name, but be careful that you don't include any indices that\n-you don't want to change the policy for:\n+You can specify different `min_age` values in the policy you use for existing indices, \n+or set the <<index-lifecycle-origination-date, `index.lifecycle.origination_date`>> \n+to control how the index age is calculated. \n \n-[source,console]\n------------------------\n-PUT mylogs-pre-ilm*/_settings <1>\n-{\n-  \"index\": {\n-    \"lifecycle\": {\n-      \"name\": \"mylogs_policy_existing\"\n-    }\n-  }\n-}\n------------------------\n-// TEST[continued]\n+Once all pre-{ilm-init} indices have been aged out and removed, \n+you can delete the policy you used to manage them.\n \n-<1> This pattern will match all indices with names that start with\n-`mylogs-pre-ilm`\n+NOTE: If you are using {beats} or {ls}, enabling {ilm-init} in version 7.0 and onward\n+sets up {ilm-init} to manage new indices automatically. \n+If you are using {beats} through {ls}, \n+you might need to change your {ls} output configuration and invoke the {beats} setup \n+to use {ilm-init} for new data.\n \n-Once all pre-{ilm-init} indices have aged out and been deleted, the policy for\n-older periodic indices can be deleted.\n+[discrete]\n+[[ilm-existing-indices-reindex]]\n+=== Reindex into a managed index\n \n-[[ilm-reindexing-into-rollover]]\n-=== Reindexing via {ilm-init}\n+An alternative to <<ilm-with-existing-periodic-indices,applying policies to existing indices>> is to \n+reindex your data into an {ilm-init}-managed index.\n+You might want to do this if creating periodic indices with very small amounts of data  \n+has led to excessive shard counts, or if continually indexing into the same index has led to large shards\n+and performance issues.\n \n-NOTE: The examples in this section assume daily indices as set up in\n-<<ilm-with-existing-indices,the previous section>>.\n+First, you need to set up the new {ilm-init}-managed index:\n \n-In some cases, it may be useful to reindex data into {ilm-init}-managed indices.\n-This is more complex than simply attaching policies to existing indices as\n-described in <<ilm-with-existing-periodic-indices,the previous section>>, and\n-requires pausing indexing during the reindexing process. However, this technique\n-may be useful in cases where periodic indices were created with very small\n-amounts of data leading to excessive shard counts, or for indices which grow\n-steadily over time, but have not been broken up into time-series indices leading\n-to shards which are much too large, situations that cause significant\n-performance problems.\n+. Update your index template to include the necessary {ilm-init} settings.\n+. Bootstrap an initial index as the write index.\n+. Stop writing to the old indices and index new documents using the alias that points to bootstrapped index. \n \n-Before getting started with reindexing data, the new index structure should be\n-set up. For this section, we'll be using the same setup described in\n-<<ilm-with-existing-indices,{ilm-imit} with existing indices>>.\n+To reindex into the managed index:\n \n-First, we'll set up a policy with rollover, and can include any additional\n-phases required. For simplicity, we'll just use rollover:\n+. Pause indexing new documents if you do not want to mix new and old data in the {ilm-init}-managed index.\n+Mixing old and new data in one index is safe, \n+but a combined index needs to be retained until you are ready to delete the new data.\n \n+. Reduce the {ilm-init} poll interval to ensure that the index doesn't \n+grow too large while waiting for the rollover check.\n+By default, {ilm-init} checks rollover conditions every 10 minutes. \n++\n+--\n [source,console]\n -----------------------\n-PUT _ilm/policy/mylogs_condensed_policy\n+PUT _cluster/settings\n {\n-  \"policy\": {\n-    \"phases\": {\n-      \"hot\": {\n-        \"actions\": {\n-          \"rollover\": {\n-            \"max_age\": \"7d\",\n-            \"max_size\": \"50G\"\n-          }\n-        }\n-      }\n-    }\n+  \"transient\": {\n+    \"indices.lifecycle.poll_interval\": \"1m\" <1>\n   }\n }\n -----------------------\n-// TEST[continued]\n-\n-And now we'll update the index template for our indices to include the relevant\n-{ilm-init} settings:\n+// TEST[skip:don't want to overwrite this setting for other tests]\n+<1> Check for rollover conditions every minute.\n+--\n+\n+. Reindex your data using the <<docs-reindex,reindex API>>. \n+If you want to partition the data in the order in which it was originally indexed, \n+you can run separate reindex requests. \n++\n+--\n+IMPORTANT: Documents retain their original IDs. If you don't use automatically generated document IDs, \n+and are reindexing from multiple source indices, you might need to do additional processing to \n+ensure that document IDs don't conflict. One way to do this is to use a\n+<<reindex-scripts,script>> in the reindex call to append the original index name\n+to the document ID.\n \n+//////////////////////////\n [source,console]\n -----------------------\n PUT _template/mylogs_template\n {\n   \"index_patterns\": [\n-    \"ilm-mylogs-*\" <1>\n+    \"mylogs-*\"\n   ],\n   \"settings\": {\n     \"number_of_shards\": 1,\n-    \"number_of_replicas\": 1,\n-    \"index\": {\n-      \"lifecycle\": {\n-        \"name\": \"mylogs_condensed_policy\", <2>\n-        \"rollover_alias\": \"mylogs\" <3>\n-      }\n-    }", "originalCommit": "129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzNTAzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r434635031", "bodyText": "This is a bit misleading to me, because it's only policies that have the same names that are overwritten, policies that exist locally but not in the snapshot are not removed. Maybe we can clarify it a little bit?", "author": "dakrone", "createdAt": "2020-06-03T15:01:01Z", "path": "docs/reference/ilm/set-up-lifecycle-policy.asciidoc", "diffHunk": "@@ -1,23 +1,27 @@\n [role=\"xpack\"]\n [testenv=\"basic\"]\n [[set-up-lifecycle-policy]]\n-== Configure lifecycle policy [[ilm-policy-definition]]\n+== Configure a lifecycle policy [[ilm-policy-definition]]\n \n For {ilm-init} to manage an index, a valid policy \n must be specified in the `index.lifecycle.name` index setting. \n \n-To configure a lifecycle policy for rolling indices, \n-you create the policy and add it to the index template.\n+To configure a lifecycle policy for <<index-rollover, rolling indices>>, \n+you create the policy and add it to the <<indices-templates, index template>>.\n \n To use a policy to manage an index that doesn't roll over,\n-you can specify the policy directly when you create it.\n+you can specify a lifecycle policy when you create it.\n+\n+{ilm-init} policies are stored in the global cluster state and can be included in snapshots\n+by setting `include_global_state` to `true` when you <<snapshots-take-snapshot, take the snapshot>>. \n+Restoring {ilm-init} policies from a snapshot is all-or-nothing. \n+The entire global state, including all policies, is overwritten when you restore a snapshot.", "originalCommit": "129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzNTU1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r434635555", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `operation_mode` in the response shows one of three states: `STARTED`, `STOPPING`,or `STOPPED`. \n          \n          \n            \n            The `operation_mode` in the response shows one of three states: `STARTED`, `STOPPING`, or `STOPPED`.", "author": "lockewritesdocs", "createdAt": "2020-06-03T15:01:46Z", "path": "docs/reference/ilm/apis/get-status.asciidoc", "diffHunk": "@@ -25,9 +25,10 @@ Retrieves the current {ilm} ({ilm-init}) status.\n [[ilm-get-status-desc]]\n ==== {api-description-title}\n \n-Returns the status of the {ilm-init} plugin. The `operation_mode` field in the\n-response shows one of three states: `STARTED`, `STOPPING`,\n-or `STOPPED`. You can change the status of the {ilm-init} plugin with the\n+[[ilm-operating-modes]]\n+Returns the status of the {ilm-init} plugin. \n+The `operation_mode` in the response shows one of three states: `STARTED`, `STOPPING`,or `STOPPED`. ", "originalCommit": "129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0MzU0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r434643545", "bodyText": "The associated number for this line (8) cannot be viewed unless you scroll the example. Is it worth adding a hard return after \"...target shards\" to wrap the line?", "author": "lockewritesdocs", "createdAt": "2020-06-03T15:12:37Z", "path": "docs/reference/ilm/error-handling.asciidoc", "diffHunk": "@@ -70,24 +68,24 @@ Which returns the following information:\n   \"indices\" : {\n     \"myindex\" : {\n       \"index\" : \"myindex\",\n-      \"managed\" : true,                         <1>\n-      \"policy\" : \"shrink-the-index\",            <2>\n+      \"managed\" : true,                         \n+      \"policy\" : \"shrink-index\",                <1>\n       \"lifecycle_date_millis\" : 1541717265865,\n-      \"age\": \"5.1d\",                            <3>\n-      \"phase\" : \"warm\",                         <4>\n+      \"age\": \"5.1d\",                            <2>\n+      \"phase\" : \"warm\",                         <3>\n       \"phase_time_millis\" : 1541717272601,\n-      \"action\" : \"shrink\",                      <5>\n+      \"action\" : \"shrink\",                      <4>\n       \"action_time_millis\" : 1541717272601,\n-      \"step\" : \"ERROR\",                         <6>\n+      \"step\" : \"ERROR\",                         <5>\n       \"step_time_millis\" : 1541717272688,\n-      \"failed_step\" : \"shrink\",                 <7>\n+      \"failed_step\" : \"shrink\",                 <6>\n       \"step_info\" : {\n-        \"type\" : \"illegal_argument_exception\",   <8>\n-        \"reason\" : \"the number of target shards [4] must be less that the number of source shards [2]\" <9>\n+        \"type\" : \"illegal_argument_exception\",  <7>\n+        \"reason\" : \"the number of target shards [4] must be less that the number of source shards [2]\" <8>", "originalCommit": "129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5NjIyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r436196225", "bodyText": "Fixed.", "author": "debadair", "createdAt": "2020-06-05T22:45:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0MzU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0NDIwMg==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r434644202", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To resolve this, you could update the policy to shrink the index to a single shard after 5 days:\n          \n          \n            \n            To resolve this issue, update the policy to shrink the index to a single shard after 5 days:", "author": "lockewritesdocs", "createdAt": "2020-06-03T15:13:29Z", "path": "docs/reference/ilm/error-handling.asciidoc", "diffHunk": "@@ -104,25 +102,21 @@ Which returns the following information:\n --------------------------------------------------\n // TESTRESPONSE[skip:no way to know if we will get this response immediately]\n \n-<1> this index is managed by {ilm-init}\n-<2> the policy in question, in this case, \"shrink-the-index\"\n-<3> the current age for the index\n-<4> what phase the index is currently in\n-<5> what action the index is currently on\n-<6> what step the index is currently on, in this case, because there is an error, the index is in the \"ERROR\" step\n-<7> the name of the step that failed to execute, in this case \"shrink\"\n-<8> the error class that occurred during this step\n-<9> the error message that occurred during the execution failure\n-<10> the definition of the phase (in this case, the \"warm\" phase) that the index is currently on\n-\n-The index here has been moved to the error step because the shrink definition in\n-the policy is using an incorrect number of shards. So rectifying that in the\n-policy entails updating the existing policy to use one instead of four for\n-the targeted number of shards.\n+<1> The policy being used to manage the index: `shrink-index`\n+<2> The index age: 5.1 days\n+<3> The phase the index is currently in: `warm`\n+<4> The current action: `shrink`\n+<5> THe step the index is currently in: `ERROR`\n+<6> The step that failed to execute: `shrink`\n+<7> The type of error that occurred: `illegal_argument_exception`\n+<8> The error message that describes what went wrong\n+<9> The definition of the current phase from the `shrink-index` policy\n+\n+To resolve this, you could update the policy to shrink the index to a single shard after 5 days:", "originalCommit": "129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MTgyNw==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r436191827", "bodyText": "I'm going to stet this one since it's one possible way to resolve the issue for this particular scenario.", "author": "debadair", "createdAt": "2020-06-05T22:27:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0NDIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MDkwOA==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r434650908", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            {ilm} continues to manage the old index in accordance with your existing policy. \n          \n          \n            \n            {ilm-init} continues to manage the old index in accordance with your existing policy.", "author": "lockewritesdocs", "createdAt": "2020-06-03T15:22:34Z", "path": "docs/reference/ilm/ilm-skip-rollover.asciidoc", "diffHunk": "@@ -0,0 +1,33 @@\n+[[skipping-rollover]]\n+== Skip rollover\n+\n+When `index.lifecycle.indexing_complete` is set to `true`, \n+{ilm-init} won't perform the rollover action on an index, \n+even if it otherwise meets the rollover criteria. \n+It's set automatically by {ilm-init} when the rollover action completes successfully.\n+\n+You can set it manually to skip rollover if you need to make an exception\n+to your normal lifecycle policy and update the alias to force a roll over, \n+but want {ilm-init} to continue to manage the index.\n+\n+If an index's lifecycle policy is removed, this setting is also removed.\n+\n+IMPORTANT: When `index.lifecycle.indexing_complete` is `true`, \n+{ilm-init} verifies that the index is no longer the write index \n+for the alias specified by `index.lifecycle.rollover_alias`.\n+If the index is still the write index or the rollover alias is not set,\n+the index is moved to the <<index-lifecycle-error-handling,`ERROR` step>>.\n+\n+For example, if you need to change the name of new indices in a series while retaining\n+previously-indexed data in accordance with your configured policy, you can:\n+\n+. Create a template for the new index pattern that uses the same policy. \n+. Bootstrap the initial index.\n+. Change the write index for the alias to the bootstrapped index \n+using the <<indices-aliases, index aliases>> API.\n+. Set `index.lifecycle.indexing_complete` to `true` on the old index to indicate \n+that it does not need to be rolled over.\n+\n+{ilm} continues to manage the old index in accordance with your existing policy. ", "originalCommit": "129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MTYwOA==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r434651608", "bodyText": "The {ilm} variable renders as \"index lifecycle management\", which doesn't work at the beginning of the sentence:\n\nindex lifecycle management continues...", "author": "lockewritesdocs", "createdAt": "2020-06-03T15:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MDkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgxOTU1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r434819557", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            you need to explicitly tell {ilm-init} to retry the step:\n          \n          \n            \n            you might need to explicitly tell {ilm-init} to retry the step:", "author": "debadair", "createdAt": "2020-06-03T19:58:51Z", "path": "docs/reference/ilm/error-handling.asciidoc", "diffHunk": "@@ -141,19 +135,16 @@ PUT _ilm/policy/shrink-the-index\n // TEST[continued]\n \n [discrete]\n-=== Retrying failed index lifecycle management steps\n+=== Retrying failed lifecycle policy steps\n \n-Once the underlying issue that caused an index to move to the error step has\n-been corrected, index lifecycle management must be told to retry the step to see\n-if it can progress further. This is accomplished by invoking the retry API\n+Once you fix the problem that put an index in the `ERROR` step, \n+you need to explicitly tell {ilm-init} to retry the step:", "originalCommit": "129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4OTEwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r436189101", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can set it manually to skip rollover if you need to make an exception\n          \n          \n            \n            to your normal lifecycle policy and update the alias to force a roll over, \n          \n          \n            \n            but want {ilm-init} to continue to manage the index.\n          \n          \n            \n            You can set it manually to skip rollover if you need to make an exception\n          \n          \n            \n            to your normal lifecycle policy and update the alias to force a roll over, \n          \n          \n            \n            but want {ilm-init} to continue to manage the index. \n          \n          \n            \n            If you use the rollover API. It is not necessary to  configure this setting manually.", "author": "debadair", "createdAt": "2020-06-05T22:17:37Z", "path": "docs/reference/ilm/ilm-skip-rollover.asciidoc", "diffHunk": "@@ -0,0 +1,33 @@\n+[[skipping-rollover]]\n+== Skip rollover\n+\n+When `index.lifecycle.indexing_complete` is set to `true`, \n+{ilm-init} won't perform the rollover action on an index, \n+even if it otherwise meets the rollover criteria. \n+It's set automatically by {ilm-init} when the rollover action completes successfully.\n+\n+You can set it manually to skip rollover if you need to make an exception\n+to your normal lifecycle policy and update the alias to force a roll over, \n+but want {ilm-init} to continue to manage the index.", "originalCommit": "129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MDk2OA==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r436190968", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Restoring {ilm-init} policies from a snapshot is all-or-nothing. \n          \n          \n            \n            The entire global state, including all policies, is overwritten when you restore a snapshot.\n          \n          \n            \n            When the snapshot is restored, all of the policies in the global state are restored and any local policies with the same names are overwritten.", "author": "debadair", "createdAt": "2020-06-05T22:24:39Z", "path": "docs/reference/ilm/set-up-lifecycle-policy.asciidoc", "diffHunk": "@@ -1,23 +1,27 @@\n [role=\"xpack\"]\n [testenv=\"basic\"]\n [[set-up-lifecycle-policy]]\n-== Configure lifecycle policy [[ilm-policy-definition]]\n+== Configure a lifecycle policy [[ilm-policy-definition]]\n \n For {ilm-init} to manage an index, a valid policy \n must be specified in the `index.lifecycle.name` index setting. \n \n-To configure a lifecycle policy for rolling indices, \n-you create the policy and add it to the index template.\n+To configure a lifecycle policy for <<index-rollover, rolling indices>>, \n+you create the policy and add it to the <<indices-templates, index template>>.\n \n To use a policy to manage an index that doesn't roll over,\n-you can specify the policy directly when you create it.\n+you can specify a lifecycle policy when you create it.\n+\n+{ilm-init} policies are stored in the global cluster state and can be included in snapshots\n+by setting `include_global_state` to `true` when you <<snapshots-take-snapshot, take the snapshot>>. \n+Restoring {ilm-init} policies from a snapshot is all-or-nothing. \n+The entire global state, including all policies, is overwritten when you restore a snapshot.", "originalCommit": "129f0dcd4b203314ca1fa6b1bac3805c93e9eae1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3ad8cbcda13e87f8ca689de33f1c569142566956", "url": "https://github.com/elastic/elasticsearch/commit/3ad8cbcda13e87f8ca689de33f1c569142566956", "message": "Apply suggestions from code review\n\nCo-authored-by: Adam Locke <adam.locke@elastic.co>\nCo-authored-by: Lee Hinman <dakrone@users.noreply.github.com>", "committedDate": "2020-06-05T22:25:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MTQ4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r436191485", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This halts execution of the policy until you resolve the underlying\n          \n          \n            \n            issues with the policy, index, or cluster.\n          \n          \n            \n            If {ilm-init] cannot resolve the error automatically, execution is halted  \n          \n          \n            \n            until you resolve the underlying issues with the policy, index, or cluster.", "author": "debadair", "createdAt": "2020-06-05T22:26:32Z", "path": "docs/reference/ilm/error-handling.asciidoc", "diffHunk": "@@ -1,20 +1,20 @@\n [role=\"xpack\"]\n [testenv=\"basic\"]\n [[index-lifecycle-error-handling]]\n-== Index lifecycle error handling\n+== Resolve lifecycle policy execution errors\n \n-During Index Lifecycle Management's execution of the policy for an index, it's\n-possible for a step to encounter an error during its execution. When this\n-happens, {ilm-init} will move the management state into an \"error\" step. This halts\n-further execution of the policy and gives an administrator the chance to address\n-any issues with the policy, index, or cluster.\n+When {ilm-init} executes a lifecycle policy, it's possible for errors to occur\n+while performing the necessary index operations for a step. \n+When this happens, {ilm-init} moves the index to an `ERROR` step. \n+This halts execution of the policy until you resolve the underlying\n+issues with the policy, index, or cluster.", "originalCommit": "3ad8cbcda13e87f8ca689de33f1c569142566956", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MjAzNg==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r436192036", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * The maximum index size, number of documents, or age at which you want to roll over to a new index.\n          \n          \n            \n            * The maximum shard size, number of documents, or age at which you want to roll over to a new index.", "author": "debadair", "createdAt": "2020-06-05T22:28:40Z", "path": "docs/reference/ilm/ilm-overview.asciidoc", "diffHunk": "@@ -11,22 +11,22 @@ You can create and apply {ilm-cap} ({ilm-init}) policies to automatically manage\n according to your performance, resiliency, and retention requirements. \n Index lifecycle policies can trigger actions such as:\n \n-* **Rollover** - \n+* **Rollover**: \n include::../glossary.asciidoc[tag=rollover-def-short]\n-* **Shrink** - \n+* **Shrink**: \n include::../glossary.asciidoc[tag=shrink-def-short]\n-* **Force merge** - \n+* **Force merge**: \n include::../glossary.asciidoc[tag=force-merge-def-short]\n-* **Freeze** -\n+* **Freeze**:\n include::../glossary.asciidoc[tag=freeze-def-short]\n-* **Delete** - Permanently remove an index, including all of its data and metadata.\n+* **Delete**: Permanently remove an index, including all of its data and metadata.\n \n {ilm-init} makes it easier to manage indices in hot-warm-cold architectures,\n which are common when you're working with time-series data such as logs and metrics.\n \n You can specify:\n \n-* The maximum size, number of documents, or age at which you want to roll over to a new index.\n+* The maximum index size, number of documents, or age at which you want to roll over to a new index.", "originalCommit": "3ad8cbcda13e87f8ca689de33f1c569142566956", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4c296b2d964f306377bee9166862297bbc2ab94d", "url": "https://github.com/elastic/elasticsearch/commit/4c296b2d964f306377bee9166862297bbc2ab94d", "message": "Apply suggestions from code review", "committedDate": "2020-06-05T22:29:08Z", "type": "commit"}, {"oid": "f5557fc25086ffb445be42d97eba66a87a8d60a6", "url": "https://github.com/elastic/elasticsearch/commit/f5557fc25086ffb445be42d97eba66a87a8d60a6", "message": "Fixed callout", "committedDate": "2020-06-05T22:32:23Z", "type": "commit"}, {"oid": "d6061539097a92e837fa4462fc740fdb6f2b5bb8", "url": "https://github.com/elastic/elasticsearch/commit/d6061539097a92e837fa4462fc740fdb6f2b5bb8", "message": "Update docs/reference/ilm/ilm-with-existing-indices.asciidoc\n\nCo-authored-by: Lee Hinman <dakrone@users.noreply.github.com>", "committedDate": "2020-06-05T22:36:05Z", "type": "commit"}, {"oid": "9b5c5c5e6618df0429e6c292220b7098d40f926a", "url": "https://github.com/elastic/elasticsearch/commit/9b5c5c5e6618df0429e6c292220b7098d40f926a", "message": "Update docs/reference/ilm/ilm-with-existing-indices.asciidoc\n\nCo-authored-by: Lee Hinman <dakrone@users.noreply.github.com>", "committedDate": "2020-06-05T22:36:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5NTM2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57565#discussion_r436195369", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <1> Check for rollover conditions every minute.\n          \n          \n            \n            <1> Check once a minute to see if {ilm-init} actions such as rollover need to be performed.", "author": "debadair", "createdAt": "2020-06-05T22:41:15Z", "path": "docs/reference/ilm/ilm-with-existing-indices.asciidoc", "diffHunk": "@@ -3,293 +3,109 @@\n [[ilm-with-existing-indices]]\n == Manage existing indices\n \n-NOTE:  If migrating from Curator, ensure you are running Curator version 5.7 or greater\n-so that Curator will ignore ILM managed indices.\n+If you've been using Curator or some other mechanism to manage periodic indices,\n+you have a couple options when migrating to {ilm-init}:\n \n-While it is recommended to use {ilm-init} to manage the index lifecycle from\n-start to finish, it may be useful to use {ilm-init} with existing indices,\n-for example, when migrating from daily indices to rollover-based indices. \n-Such use cases are fully supported, but there are some configuration differences \n-from when {ilm-init} can manage the complete index lifecycle.\n+* Set up your index templates to use an {ilm-init} policy to manage your new indices. \n+Once {ilm-init} is managing your current write index, you can apply an appropriate policy to your old indices.\n \n-This section describes strategies to leverage {ilm-init} for existing periodic\n-indices when migrating to fully {ilm-init}-manged indices, which can be done in\n-a few different ways, each providing different tradeoffs. As an example, we'll\n-walk through a use case of a very simple logging index with just a field for the\n-log message and a timestamp.\n+* Reindex into an {ilm-init}-managed index. \n \n-First, we need to create a template for these indices:\n+NOTE: Starting in Curator version 5.7, Curator ignores {ilm-init} managed indices.\n \n-[source,console]\n------------------------\n-PUT _template/mylogs_template\n-{\n-  \"index_patterns\": [\n-    \"mylogs-*\"\n-  ],\n-  \"settings\": {\n-    \"number_of_shards\": 1,\n-    \"number_of_replicas\": 1\n-  },\n-  \"mappings\": {\n-    \"properties\": {\n-      \"message\": {\n-        \"type\": \"text\"\n-      },\n-      \"@timestamp\": {\n-        \"type\": \"date\"\n-      }\n-    }\n-  }\n-}\n------------------------\n-\n-And we'll ingest a few documents to create a few daily indices:\n-\n-[source,console]\n------------------------\n-POST mylogs-pre-ilm-2019.06.24/_doc\n-{\n-  \"@timestamp\": \"2019-06-24T10:34:00\",\n-  \"message\": \"this is one log message\"\n-}\n------------------------\n-// TEST[continued]\n-\n-[source,console]\n------------------------\n-POST mylogs-pre-ilm-2019.06.25/_doc\n-{\n-  \"@timestamp\": \"2019-06-25T17:42:00\",\n-  \"message\": \"this is another log message\"\n-}\n------------------------\n-// TEST[continued]\n-\n-//////////////////////////\n-\n-[source,console]\n---------------------------------------------------\n-DELETE _template/mylogs_template\n---------------------------------------------------\n-// TEST[continued]\n-\n-//////////////////////////\n-\n-Now that we have these indices, we'll look at a few different ways of migrating\n-these indices to {ilm-init}.\n-\n-[[ilm-with-existing-periodic-indices]]\n-=== Managing existing periodic indices with {ilm-init}\n-\n-NOTE: The examples in this section assume daily indices as set up in\n-<<ilm-with-existing-indices,the previous section>>.\n-\n-The simplest way to manage existing indices while transitioning to fully\n-{ilm-init}-managed indices is to allow all new indices to be fully managed by\n-{ilm-init} before attaching {ilm-init} policies to existing indices. To do this,\n-all new documents should be directed to {ilm-init}-managed indices - if you are\n-using Beats or Logstash data shippers, upgrading all of those shippers to\n-version 7.0.0 or higher will take care of that part for you. If you are not\n-using Beats or Logstash, you may need to set up {ilm-init} for new indices yourself as\n-demonstrated in the <<getting-started-index-lifecycle-management,{ilm-init} tutorial>>.\n-\n-NOTE: If you are using Beats through Logstash, you may need to change your\n-Logstash output configuration and invoke the Beats setup to use {ilm-init} for new\n-data.\n-\n-Once all new documents are being written to fully {ilm-init}-managed indices, it\n-is easy to add an {ilm-init} policy to existing indices. However, there are two\n-things to keep in mind when doing this, and a trick that makes those two things\n-much easier to handle.\n-\n-The two biggest things to keep in mind are:\n-\n-1. Existing periodic indices shouldn't use policies with rollover, because\n-rollover is used to manage where new data goes. Since existing indices should no\n-longer be receiving new documents, there is no point to using rollover for them.\n-\n-2. {ilm-init} policies attached to existing indices will compare the `min_age`\n-for each phase to the original creation date of the index, and so might proceed\n-through multiple phases immediately.\n-\n-The first one is the most important, because it makes it difficult to use the\n-same policy for new and existing periodic indices. But that's easy to solve\n-with one simple trick: Create a second policy for existing indices, in addition\n-to the one for new indices. {ilm-init} policies are cheap to create, so don't be\n-afraid to have more than one. Modifying a policy designed for new indices to be\n-used on existing indices is generally very simple: just remove the `rollover`\n-action.\n-\n-For example, if you created a policy for your new indices with each phase\n-like so:\n-\n-[source,console]\n------------------------\n-PUT _ilm/policy/mylogs_policy\n-{\n-  \"policy\": {\n-    \"phases\": {\n-      \"hot\": {\n-        \"actions\": {\n-          \"rollover\": {\n-            \"max_size\": \"25GB\"\n-          }\n-        }\n-      },\n-      \"warm\": {\n-        \"min_age\": \"1d\",\n-        \"actions\": {\n-          \"forcemerge\": {\n-            \"max_num_segments\": 1\n-          }\n-        }\n-      },\n-      \"cold\": {\n-        \"min_age\": \"7d\",\n-        \"actions\": {\n-          \"freeze\": {}\n-        }\n-      },\n-      \"delete\": {\n-        \"min_age\": \"30d\",\n-        \"actions\": {\n-          \"delete\": {}\n-        }\n-      }\n-    }\n-  }\n-}\n------------------------\n-// TEST[continued]\n+[discrete]\n+[[ilm-existing-indices-apply]]\n+=== Apply policies to existing time series indices \n \n-You can create a policy for pre-existing indices by removing the `rollover`\n-action, and in this case, the `hot` phase is now empty so we can remove that\n-too:\n+The simplest way to transition to managing your periodic indices with {ilm-init} is\n+to <<apply-policy-template, configure an index template>> to apply a lifecycle policy to new indices. \n+Once the index you are writing to is being managed by {ilm-init}, \n+you can <<apply-policy-multiple, manually apply a policy>> to your older indices.\n \n-[source,console]\n------------------------\n-PUT _ilm/policy/mylogs_policy_existing\n-{\n-  \"policy\": {\n-    \"phases\": {\n-      \"warm\": {\n-        \"min_age\": \"1d\",\n-        \"actions\": {\n-          \"forcemerge\": {\n-            \"max_num_segments\": 1\n-          }\n-        }\n-      },\n-      \"cold\": {\n-        \"min_age\": \"7d\",\n-        \"actions\": {\n-          \"freeze\": {}\n-        }\n-      },\n-      \"delete\": {\n-        \"min_age\": \"30d\",\n-        \"actions\": {\n-          \"delete\": {}\n-        }\n-      }\n-    }\n-  }\n-}\n------------------------\n-// TEST[continued]\n+Define a separate policy for your older indices that omits the rollover action. \n+Rollover is used to manage where new data goes, so isn't applicable. \n \n-Creating a separate policy for existing indices will also allow using different\n-`min_age` values. You may want to use higher values to prevent many indices from\n-running through the policy at once, which may be important if your policy\n-includes potentially resource-intensive operations like force merge.\n+Keep in mind that policies applied to existing indices compare the `min_age` for each phase to \n+the original creation date of the index, and might proceed through multiple phases immediately.\n+If your policy performs resource-intensive operations like force merge, \n+you don't want to have a lot of indices performing those operations all at once\n+when you switch over to {ilm-init}. \n \n-You can configure the lifecycle for many indices at once by using wildcards in\n-the index name when calling the <<indices-update-settings,Update Settings API>>\n-to set the policy name, but be careful that you don't include any indices that\n-you don't want to change the policy for:\n+You can specify different `min_age` values in the policy you use for existing indices, \n+or set <<index-lifecycle-origination-date, `index.lifecycle.origination_date`>> \n+to control how the index age is calculated. \n \n-[source,console]\n------------------------\n-PUT mylogs-pre-ilm*/_settings <1>\n-{\n-  \"index\": {\n-    \"lifecycle\": {\n-      \"name\": \"mylogs_policy_existing\"\n-    }\n-  }\n-}\n------------------------\n-// TEST[continued]\n+Once all pre-{ilm-init} indices have been aged out and removed, \n+you can delete the policy you used to manage them.\n \n-<1> This pattern will match all indices with names that start with\n-`mylogs-pre-ilm`\n+NOTE: If you are using {beats} or {ls}, enabling {ilm-init} in version 7.0 and onward\n+sets up {ilm-init} to manage new indices automatically. \n+If you are using {beats} through {ls}, \n+you might need to change your {ls} output configuration and invoke the {beats} setup \n+to use {ilm-init} for new data.\n \n-Once all pre-{ilm-init} indices have aged out and been deleted, the policy for\n-older periodic indices can be deleted.\n+[discrete]\n+[[ilm-existing-indices-reindex]]\n+=== Reindex into a managed index\n \n-[[ilm-reindexing-into-rollover]]\n-=== Reindexing via {ilm-init}\n+An alternative to <<ilm-with-existing-periodic-indices,applying policies to existing indices>> is to \n+reindex your data into an {ilm-init}-managed index.\n+You might want to do this if creating periodic indices with very small amounts of data  \n+has led to excessive shard counts, or if continually indexing into the same index has led to large shards\n+and performance issues.\n \n-NOTE: The examples in this section assume daily indices as set up in\n-<<ilm-with-existing-indices,the previous section>>.\n+First, you need to set up the new {ilm-init}-managed index:\n \n-In some cases, it may be useful to reindex data into {ilm-init}-managed indices.\n-This is more complex than simply attaching policies to existing indices as\n-described in <<ilm-with-existing-periodic-indices,the previous section>>, and\n-requires pausing indexing during the reindexing process. However, this technique\n-may be useful in cases where periodic indices were created with very small\n-amounts of data leading to excessive shard counts, or for indices which grow\n-steadily over time, but have not been broken up into time-series indices leading\n-to shards which are much too large, situations that cause significant\n-performance problems.\n+. Update your index template to include the necessary {ilm-init} settings.\n+. Bootstrap an initial index as the write index.\n+. Stop writing to the old indices and index new documents using the alias that points to bootstrapped index. \n \n-Before getting started with reindexing data, the new index structure should be\n-set up. For this section, we'll be using the same setup described in\n-<<ilm-with-existing-indices,{ilm-imit} with existing indices>>.\n+To reindex into the managed index:\n \n-First, we'll set up a policy with rollover, and can include any additional\n-phases required. For simplicity, we'll just use rollover:\n+. Pause indexing new documents if you do not want to mix new and old data in the {ilm-init}-managed index.\n+Mixing old and new data in one index is safe, \n+but a combined index needs to be retained until you are ready to delete the new data.\n \n+. Reduce the {ilm-init} poll interval to ensure that the index doesn't \n+grow too large while waiting for the rollover check.\n+By default, {ilm-init} checks rollover conditions every 10 minutes. \n++\n+--\n [source,console]\n -----------------------\n-PUT _ilm/policy/mylogs_condensed_policy\n+PUT _cluster/settings\n {\n-  \"policy\": {\n-    \"phases\": {\n-      \"hot\": {\n-        \"actions\": {\n-          \"rollover\": {\n-            \"max_age\": \"7d\",\n-            \"max_size\": \"50G\"\n-          }\n-        }\n-      }\n-    }\n+  \"transient\": {\n+    \"indices.lifecycle.poll_interval\": \"1m\" <1>\n   }\n }\n -----------------------\n-// TEST[continued]\n-\n-And now we'll update the index template for our indices to include the relevant\n-{ilm-init} settings:\n+// TEST[skip:don't want to overwrite this setting for other tests]\n+<1> Check for rollover conditions every minute.", "originalCommit": "9b5c5c5e6618df0429e6c292220b7098d40f926a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a294f9c9fcd6dafbc9493c3e620dfcf92a4fe4ff", "url": "https://github.com/elastic/elasticsearch/commit/a294f9c9fcd6dafbc9493c3e620dfcf92a4fe4ff", "message": "Apply suggestions from code review", "committedDate": "2020-06-05T22:42:37Z", "type": "commit"}, {"oid": "66dd4e796803a031301c48bce76320150d6e585c", "url": "https://github.com/elastic/elasticsearch/commit/66dd4e796803a031301c48bce76320150d6e585c", "message": "Restored policy to template example.", "committedDate": "2020-06-05T22:51:08Z", "type": "commit"}, {"oid": "a0f8b5cb12e6223300a111782aee25e229a45fc0", "url": "https://github.com/elastic/elasticsearch/commit/a0f8b5cb12e6223300a111782aee25e229a45fc0", "message": "Fixed JSON parse error", "committedDate": "2020-06-05T23:01:50Z", "type": "commit"}]}