{"pr_number": 56727, "pr_title": "Move publishing configuration to a separate plugin", "pr_createdAt": "2020-05-13T23:17:25Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/56727", "timeline": [{"oid": "5d13de23fc693235b31ad4f8e3658fa81de3a4d2", "url": "https://github.com/elastic/elasticsearch/commit/5d13de23fc693235b31ad4f8e3658fa81de3a4d2", "message": "Move publishing configuration to a separate plugin\n\nThis is another part of the breakup of the massive BuildPlugin. This PR\nmoves the code for configuring publications to a separate plugin. Most\nof the time these publications are jar files, but this also supports the\nzip publication we have for integ tests.", "committedDate": "2020-05-13T23:15:50Z", "type": "commit"}, {"oid": "6acfa7a460bc3fae85874b78c2d2dc4caf4dba19", "url": "https://github.com/elastic/elasticsearch/commit/6acfa7a460bc3fae85874b78c2d2dc4caf4dba19", "message": "checkstyle", "committedDate": "2020-05-14T00:11:00Z", "type": "commit"}, {"oid": "cbd5357b0feef0471e658e76724261c10e253b03", "url": "https://github.com/elastic/elasticsearch/commit/cbd5357b0feef0471e658e76724261c10e253b03", "message": "move manifest stuff", "committedDate": "2020-05-14T01:09:28Z", "type": "commit"}, {"oid": "07b800f022f8752be175d8767c549d399cdf13fc", "url": "https://github.com/elastic/elasticsearch/commit/07b800f022f8752be175d8767c549d399cdf13fc", "message": "spotless", "committedDate": "2020-05-14T01:19:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4MjUyOA==", "url": "https://github.com/elastic/elasticsearch/pull/56727#discussion_r425382528", "bodyText": "I think this should better live in the ElasticsearchJavaPlugin. This is dealing with the actual generation of javadocs, not creating an artifact to publish. Every java project gets the javadoc task created for it, so due to that, I think we should have consistent behavior there, even if we rarely if ever generate javadocs for modules that aren't also published.", "author": "mark-vieira", "createdAt": "2020-05-14T19:34:58Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/PublishPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import com.github.jengelman.gradle.plugins.shadow.ShadowExtension;\n+import groovy.util.Node;\n+import groovy.util.NodeList;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.XmlProvider;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.plugins.BasePlugin;\n+import org.gradle.api.plugins.BasePluginConvention;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.publish.PublishingExtension;\n+import org.gradle.api.publish.maven.MavenPublication;\n+import org.gradle.api.publish.maven.tasks.GenerateMavenPom;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.tasks.bundling.Jar;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.javadoc.Javadoc;\n+import org.gradle.external.javadoc.CoreJavadocOptions;\n+import org.gradle.internal.jvm.Jvm;\n+import org.gradle.language.base.plugins.LifecycleBasePlugin;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+public class PublishPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getPluginManager().apply(\"nebula.maven-base-publish\");\n+\n+        configureJavadoc(project);\n+        configureJavadocJar(project);\n+        configureSourcesJar(project);\n+        configurePomGeneration(project);\n+\n+    }\n+\n+    private static String getArchivesBaseName(Project project) {\n+        return project.getConvention().getPlugin(BasePluginConvention.class).getArchivesBaseName();\n+    }\n+\n+    /**Configuration generation of maven poms. */\n+    private static void configurePomGeneration(Project project) {\n+\n+        TaskProvider<Task> generatePomTask = project.getTasks().register(\"generatePom\");\n+        // generatePomTask.configure(t -> t.dependsOn(\"generatePomFileForNebulaPublication\"));\n+\n+        maybeConfigure(project.getTasks(), LifecycleBasePlugin.ASSEMBLE_TASK_NAME, assemble -> assemble.dependsOn(generatePomTask));\n+\n+        project.getTasks().withType(GenerateMavenPom.class).configureEach(pomTask -> pomTask.setDestination(new Callable<String>() {\n+            @Override\n+            public String call() throws Exception {\n+                return String.format(\n+                    \"%s/distributions/%s-%s.pom\",\n+                    project.getBuildDir(),\n+                    getArchivesBaseName(project),\n+                    project.getVersion()\n+                );\n+            }\n+        }));\n+\n+        PublishingExtension publishing = project.getExtensions().getByType(PublishingExtension.class);\n+\n+        project.getPluginManager().withPlugin(\"com.github.johnrengelman.shadow\", plugin -> {\n+            MavenPublication publication = publishing.getPublications().maybeCreate(\"shadow\", MavenPublication.class);\n+            ShadowExtension shadow = project.getExtensions().getByType(ShadowExtension.class);\n+            shadow.component(publication);\n+            // Workaround for https://github.com/johnrengelman/shadow/issues/334\n+            // Here we manually add any project dependencies in the \"shadow\" configuration to our generated POM\n+            publication.getPom().withXml(xml -> {\n+                Node root = xml.asNode();\n+                root.appendNode(\"name\", project.getName());\n+                root.appendNode(\"description\", project.getDescription());\n+                Node dependenciesNode = (Node) ((NodeList) root.get(\"dependencies\")).get(0);\n+                project.getConfigurations().getByName(ShadowBasePlugin.getCONFIGURATION_NAME()).getAllDependencies().all(dependency -> {\n+                    if (dependency instanceof ProjectDependency) {\n+                        Node dependencyNode = dependenciesNode.appendNode(\"dependency\");\n+                        dependencyNode.appendNode(\"groupId\", dependency.getGroup());\n+                        ProjectDependency projectDependency = (ProjectDependency) dependency;\n+                        String artifactId = getArchivesBaseName(projectDependency.getDependencyProject());\n+                        dependencyNode.appendNode(\"artifactId\", artifactId);\n+                        dependencyNode.appendNode(\"version\", dependency.getVersion());\n+                        dependencyNode.appendNode(\"scope\", \"compile\");\n+                    }\n+                });\n+            });\n+        });\n+\n+        // Add git origin info to generated POM files\n+        publishing.getPublications().withType(MavenPublication.class, publication -> {\n+            publication.getPom().withXml(PublishPlugin::addScmInfo);\n+\n+            // have to defer this until archivesBaseName is set\n+            project.afterEvaluate(p -> publication.setArtifactId(getArchivesBaseName(project)));\n+\n+            generatePomTask.configure(\n+                t -> t.dependsOn(String.format(\"generatePomFileFor%sPublication\", Util.capitalize(publication.getName())))\n+            );\n+        });\n+\n+    }\n+\n+    private static void addScmInfo(XmlProvider xml) {\n+        Node root = xml.asNode();\n+        root.appendNode(\"url\", Util.urlFromOrigin(BuildParams.getGitOrigin()));\n+        Node scmNode = root.appendNode(\"scm\");\n+        scmNode.appendNode(\"url\", BuildParams.getGitOrigin());\n+    }\n+\n+    private static void configureJavadoc(Project project) {", "originalCommit": "07b800f022f8752be175d8767c549d399cdf13fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4MzA5MA==", "url": "https://github.com/elastic/elasticsearch/pull/56727#discussion_r425383090", "bodyText": "Perhaps this bit we leave in the publish plugin, as we don't necessarily want to fail builds for javadoc errors on unpublished modules.", "author": "mark-vieira", "createdAt": "2020-05-14T19:35:56Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/PublishPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import com.github.jengelman.gradle.plugins.shadow.ShadowExtension;\n+import groovy.util.Node;\n+import groovy.util.NodeList;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.XmlProvider;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.plugins.BasePlugin;\n+import org.gradle.api.plugins.BasePluginConvention;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.publish.PublishingExtension;\n+import org.gradle.api.publish.maven.MavenPublication;\n+import org.gradle.api.publish.maven.tasks.GenerateMavenPom;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.tasks.bundling.Jar;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.javadoc.Javadoc;\n+import org.gradle.external.javadoc.CoreJavadocOptions;\n+import org.gradle.internal.jvm.Jvm;\n+import org.gradle.language.base.plugins.LifecycleBasePlugin;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+public class PublishPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getPluginManager().apply(\"nebula.maven-base-publish\");\n+\n+        configureJavadoc(project);\n+        configureJavadocJar(project);\n+        configureSourcesJar(project);\n+        configurePomGeneration(project);\n+\n+    }\n+\n+    private static String getArchivesBaseName(Project project) {\n+        return project.getConvention().getPlugin(BasePluginConvention.class).getArchivesBaseName();\n+    }\n+\n+    /**Configuration generation of maven poms. */\n+    private static void configurePomGeneration(Project project) {\n+\n+        TaskProvider<Task> generatePomTask = project.getTasks().register(\"generatePom\");\n+        // generatePomTask.configure(t -> t.dependsOn(\"generatePomFileForNebulaPublication\"));\n+\n+        maybeConfigure(project.getTasks(), LifecycleBasePlugin.ASSEMBLE_TASK_NAME, assemble -> assemble.dependsOn(generatePomTask));\n+\n+        project.getTasks().withType(GenerateMavenPom.class).configureEach(pomTask -> pomTask.setDestination(new Callable<String>() {\n+            @Override\n+            public String call() throws Exception {\n+                return String.format(\n+                    \"%s/distributions/%s-%s.pom\",\n+                    project.getBuildDir(),\n+                    getArchivesBaseName(project),\n+                    project.getVersion()\n+                );\n+            }\n+        }));\n+\n+        PublishingExtension publishing = project.getExtensions().getByType(PublishingExtension.class);\n+\n+        project.getPluginManager().withPlugin(\"com.github.johnrengelman.shadow\", plugin -> {\n+            MavenPublication publication = publishing.getPublications().maybeCreate(\"shadow\", MavenPublication.class);\n+            ShadowExtension shadow = project.getExtensions().getByType(ShadowExtension.class);\n+            shadow.component(publication);\n+            // Workaround for https://github.com/johnrengelman/shadow/issues/334\n+            // Here we manually add any project dependencies in the \"shadow\" configuration to our generated POM\n+            publication.getPom().withXml(xml -> {\n+                Node root = xml.asNode();\n+                root.appendNode(\"name\", project.getName());\n+                root.appendNode(\"description\", project.getDescription());\n+                Node dependenciesNode = (Node) ((NodeList) root.get(\"dependencies\")).get(0);\n+                project.getConfigurations().getByName(ShadowBasePlugin.getCONFIGURATION_NAME()).getAllDependencies().all(dependency -> {\n+                    if (dependency instanceof ProjectDependency) {\n+                        Node dependencyNode = dependenciesNode.appendNode(\"dependency\");\n+                        dependencyNode.appendNode(\"groupId\", dependency.getGroup());\n+                        ProjectDependency projectDependency = (ProjectDependency) dependency;\n+                        String artifactId = getArchivesBaseName(projectDependency.getDependencyProject());\n+                        dependencyNode.appendNode(\"artifactId\", artifactId);\n+                        dependencyNode.appendNode(\"version\", dependency.getVersion());\n+                        dependencyNode.appendNode(\"scope\", \"compile\");\n+                    }\n+                });\n+            });\n+        });\n+\n+        // Add git origin info to generated POM files\n+        publishing.getPublications().withType(MavenPublication.class, publication -> {\n+            publication.getPom().withXml(PublishPlugin::addScmInfo);\n+\n+            // have to defer this until archivesBaseName is set\n+            project.afterEvaluate(p -> publication.setArtifactId(getArchivesBaseName(project)));\n+\n+            generatePomTask.configure(\n+                t -> t.dependsOn(String.format(\"generatePomFileFor%sPublication\", Util.capitalize(publication.getName())))\n+            );\n+        });\n+\n+    }\n+\n+    private static void addScmInfo(XmlProvider xml) {\n+        Node root = xml.asNode();\n+        root.appendNode(\"url\", Util.urlFromOrigin(BuildParams.getGitOrigin()));\n+        Node scmNode = root.appendNode(\"scm\");\n+        scmNode.appendNode(\"url\", BuildParams.getGitOrigin());\n+    }\n+\n+    private static void configureJavadoc(Project project) {\n+        // remove compiled classes from the Javadoc classpath: http://mail.openjdk.java.net/pipermail/javadoc-dev/2018-January/000400.html\n+        final List<File> classes = new ArrayList<>();\n+        project.getTasks().withType(JavaCompile.class).configureEach(javaCompile -> classes.add(javaCompile.getDestinationDir()));\n+        project.getTasks().withType(Javadoc.class).configureEach(javadoc -> {\n+            // only explicitly set javadoc executable if compiler JDK is different from Gradle\n+            // this ensures better cacheability as setting ths input to an absolute path breaks portability\n+            Path compilerJvm = BuildParams.getCompilerJavaHome().toPath();\n+            Path gradleJvm = Jvm.current().getJavaHome().toPath();\n+            try {\n+                if (Files.isSameFile(compilerJvm, gradleJvm) == false) {\n+                    javadoc.setExecutable(compilerJvm.resolve(\"bin/javadoc\").toString());\n+                }\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+            javadoc.setClasspath(javadoc.getClasspath().filter(f -> classes.contains(f) == false));\n+            /*\n+             * Generate docs using html5 to suppress a warning from `javadoc`\n+             * that the default will change to html5 in the future.\n+             */\n+            CoreJavadocOptions javadocOptions = (CoreJavadocOptions) javadoc.getOptions();\n+            javadocOptions.addBooleanOption(\"html5\", true);\n+        });\n+        // ensure javadoc task is run with 'check'\n+        project.getTasks()", "originalCommit": "07b800f022f8752be175d8767c549d399cdf13fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ5NzI1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/56727#discussion_r425497255", "bodyText": "I think we do still want this in those cases. If we are writing javadocs, we should make sure they are valid.", "author": "rjernst", "createdAt": "2020-05-15T00:12:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4MzA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4MzY4MA==", "url": "https://github.com/elastic/elasticsearch/pull/56727#discussion_r425383680", "bodyText": "Should this be commented out?", "author": "mark-vieira", "createdAt": "2020-05-14T19:37:05Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/PublishPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import com.github.jengelman.gradle.plugins.shadow.ShadowExtension;\n+import groovy.util.Node;\n+import groovy.util.NodeList;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.XmlProvider;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.plugins.BasePlugin;\n+import org.gradle.api.plugins.BasePluginConvention;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.publish.PublishingExtension;\n+import org.gradle.api.publish.maven.MavenPublication;\n+import org.gradle.api.publish.maven.tasks.GenerateMavenPom;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.tasks.bundling.Jar;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.javadoc.Javadoc;\n+import org.gradle.external.javadoc.CoreJavadocOptions;\n+import org.gradle.internal.jvm.Jvm;\n+import org.gradle.language.base.plugins.LifecycleBasePlugin;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+public class PublishPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getPluginManager().apply(\"nebula.maven-base-publish\");\n+\n+        configureJavadoc(project);\n+        configureJavadocJar(project);\n+        configureSourcesJar(project);\n+        configurePomGeneration(project);\n+\n+    }\n+\n+    private static String getArchivesBaseName(Project project) {\n+        return project.getConvention().getPlugin(BasePluginConvention.class).getArchivesBaseName();\n+    }\n+\n+    /**Configuration generation of maven poms. */\n+    private static void configurePomGeneration(Project project) {\n+\n+        TaskProvider<Task> generatePomTask = project.getTasks().register(\"generatePom\");\n+        // generatePomTask.configure(t -> t.dependsOn(\"generatePomFileForNebulaPublication\"));", "originalCommit": "07b800f022f8752be175d8767c549d399cdf13fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ5MjU2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/56727#discussion_r425492566", "bodyText": "Nope this can be deleted. It's handled by the last block for all publishing tasks.", "author": "rjernst", "createdAt": "2020-05-14T23:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4MzY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4NzQzMw==", "url": "https://github.com/elastic/elasticsearch/pull/56727#discussion_r425387433", "bodyText": "I see we no longer do this explicitly after applying the shadow plugin. I put that there to workaround some very specific configuration ordering issues. Please confirm that the artifact id for the poms generated for the HLRC and JDBC drive are correct. They should be elasticsearch-rest-high-level-client and x-pack-sql-jdbc, respectively.\nTo be even more thorough its probably worth doing a diff on all POMs, given we fuck something up every time we touch publishing code. When I was testing this I ran ./gradlew generatePom copied all the files to a folder, applied my changes, generated again, then did a diff to manually confirm my PR didn't change how POMs were generated.", "author": "mark-vieira", "createdAt": "2020-05-14T19:44:03Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/PublishPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import com.github.jengelman.gradle.plugins.shadow.ShadowExtension;\n+import groovy.util.Node;\n+import groovy.util.NodeList;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.XmlProvider;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.plugins.BasePlugin;\n+import org.gradle.api.plugins.BasePluginConvention;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.publish.PublishingExtension;\n+import org.gradle.api.publish.maven.MavenPublication;\n+import org.gradle.api.publish.maven.tasks.GenerateMavenPom;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.tasks.bundling.Jar;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.javadoc.Javadoc;\n+import org.gradle.external.javadoc.CoreJavadocOptions;\n+import org.gradle.internal.jvm.Jvm;\n+import org.gradle.language.base.plugins.LifecycleBasePlugin;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+public class PublishPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getPluginManager().apply(\"nebula.maven-base-publish\");\n+\n+        configureJavadoc(project);\n+        configureJavadocJar(project);\n+        configureSourcesJar(project);\n+        configurePomGeneration(project);\n+\n+    }\n+\n+    private static String getArchivesBaseName(Project project) {\n+        return project.getConvention().getPlugin(BasePluginConvention.class).getArchivesBaseName();\n+    }\n+\n+    /**Configuration generation of maven poms. */\n+    private static void configurePomGeneration(Project project) {\n+\n+        TaskProvider<Task> generatePomTask = project.getTasks().register(\"generatePom\");\n+        // generatePomTask.configure(t -> t.dependsOn(\"generatePomFileForNebulaPublication\"));\n+\n+        maybeConfigure(project.getTasks(), LifecycleBasePlugin.ASSEMBLE_TASK_NAME, assemble -> assemble.dependsOn(generatePomTask));\n+\n+        project.getTasks().withType(GenerateMavenPom.class).configureEach(pomTask -> pomTask.setDestination(new Callable<String>() {\n+            @Override\n+            public String call() throws Exception {\n+                return String.format(\n+                    \"%s/distributions/%s-%s.pom\",\n+                    project.getBuildDir(),\n+                    getArchivesBaseName(project),\n+                    project.getVersion()\n+                );\n+            }\n+        }));\n+\n+        PublishingExtension publishing = project.getExtensions().getByType(PublishingExtension.class);\n+\n+        project.getPluginManager().withPlugin(\"com.github.johnrengelman.shadow\", plugin -> {\n+            MavenPublication publication = publishing.getPublications().maybeCreate(\"shadow\", MavenPublication.class);\n+            ShadowExtension shadow = project.getExtensions().getByType(ShadowExtension.class);\n+            shadow.component(publication);\n+            // Workaround for https://github.com/johnrengelman/shadow/issues/334\n+            // Here we manually add any project dependencies in the \"shadow\" configuration to our generated POM\n+            publication.getPom().withXml(xml -> {\n+                Node root = xml.asNode();\n+                root.appendNode(\"name\", project.getName());\n+                root.appendNode(\"description\", project.getDescription());\n+                Node dependenciesNode = (Node) ((NodeList) root.get(\"dependencies\")).get(0);\n+                project.getConfigurations().getByName(ShadowBasePlugin.getCONFIGURATION_NAME()).getAllDependencies().all(dependency -> {\n+                    if (dependency instanceof ProjectDependency) {\n+                        Node dependencyNode = dependenciesNode.appendNode(\"dependency\");\n+                        dependencyNode.appendNode(\"groupId\", dependency.getGroup());\n+                        ProjectDependency projectDependency = (ProjectDependency) dependency;\n+                        String artifactId = getArchivesBaseName(projectDependency.getDependencyProject());\n+                        dependencyNode.appendNode(\"artifactId\", artifactId);\n+                        dependencyNode.appendNode(\"version\", dependency.getVersion());\n+                        dependencyNode.appendNode(\"scope\", \"compile\");\n+                    }\n+                });\n+            });\n+        });\n+\n+        // Add git origin info to generated POM files\n+        publishing.getPublications().withType(MavenPublication.class, publication -> {\n+            publication.getPom().withXml(PublishPlugin::addScmInfo);\n+\n+            // have to defer this until archivesBaseName is set\n+            project.afterEvaluate(p -> publication.setArtifactId(getArchivesBaseName(project)));", "originalCommit": "07b800f022f8752be175d8767c549d399cdf13fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ5OTA4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/56727#discussion_r425499083", "bodyText": "I double checked both those poms and they are correct. I will do a diff as you suggested.", "author": "rjernst", "createdAt": "2020-05-15T00:19:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4NzQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM5MDI0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/56727#discussion_r425390243", "bodyText": "We can simplify this a lot. If all we want is the compile class minus the source set output we can just use the main source set's getCompileClasspath().", "author": "mark-vieira", "createdAt": "2020-05-14T19:49:27Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/PublishPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import com.github.jengelman.gradle.plugins.shadow.ShadowExtension;\n+import groovy.util.Node;\n+import groovy.util.NodeList;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.XmlProvider;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.plugins.BasePlugin;\n+import org.gradle.api.plugins.BasePluginConvention;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.publish.PublishingExtension;\n+import org.gradle.api.publish.maven.MavenPublication;\n+import org.gradle.api.publish.maven.tasks.GenerateMavenPom;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.tasks.bundling.Jar;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.javadoc.Javadoc;\n+import org.gradle.external.javadoc.CoreJavadocOptions;\n+import org.gradle.internal.jvm.Jvm;\n+import org.gradle.language.base.plugins.LifecycleBasePlugin;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+public class PublishPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getPluginManager().apply(\"nebula.maven-base-publish\");\n+\n+        configureJavadoc(project);\n+        configureJavadocJar(project);\n+        configureSourcesJar(project);\n+        configurePomGeneration(project);\n+\n+    }\n+\n+    private static String getArchivesBaseName(Project project) {\n+        return project.getConvention().getPlugin(BasePluginConvention.class).getArchivesBaseName();\n+    }\n+\n+    /**Configuration generation of maven poms. */\n+    private static void configurePomGeneration(Project project) {\n+\n+        TaskProvider<Task> generatePomTask = project.getTasks().register(\"generatePom\");\n+        // generatePomTask.configure(t -> t.dependsOn(\"generatePomFileForNebulaPublication\"));\n+\n+        maybeConfigure(project.getTasks(), LifecycleBasePlugin.ASSEMBLE_TASK_NAME, assemble -> assemble.dependsOn(generatePomTask));\n+\n+        project.getTasks().withType(GenerateMavenPom.class).configureEach(pomTask -> pomTask.setDestination(new Callable<String>() {\n+            @Override\n+            public String call() throws Exception {\n+                return String.format(\n+                    \"%s/distributions/%s-%s.pom\",\n+                    project.getBuildDir(),\n+                    getArchivesBaseName(project),\n+                    project.getVersion()\n+                );\n+            }\n+        }));\n+\n+        PublishingExtension publishing = project.getExtensions().getByType(PublishingExtension.class);\n+\n+        project.getPluginManager().withPlugin(\"com.github.johnrengelman.shadow\", plugin -> {\n+            MavenPublication publication = publishing.getPublications().maybeCreate(\"shadow\", MavenPublication.class);\n+            ShadowExtension shadow = project.getExtensions().getByType(ShadowExtension.class);\n+            shadow.component(publication);\n+            // Workaround for https://github.com/johnrengelman/shadow/issues/334\n+            // Here we manually add any project dependencies in the \"shadow\" configuration to our generated POM\n+            publication.getPom().withXml(xml -> {\n+                Node root = xml.asNode();\n+                root.appendNode(\"name\", project.getName());\n+                root.appendNode(\"description\", project.getDescription());\n+                Node dependenciesNode = (Node) ((NodeList) root.get(\"dependencies\")).get(0);\n+                project.getConfigurations().getByName(ShadowBasePlugin.getCONFIGURATION_NAME()).getAllDependencies().all(dependency -> {\n+                    if (dependency instanceof ProjectDependency) {\n+                        Node dependencyNode = dependenciesNode.appendNode(\"dependency\");\n+                        dependencyNode.appendNode(\"groupId\", dependency.getGroup());\n+                        ProjectDependency projectDependency = (ProjectDependency) dependency;\n+                        String artifactId = getArchivesBaseName(projectDependency.getDependencyProject());\n+                        dependencyNode.appendNode(\"artifactId\", artifactId);\n+                        dependencyNode.appendNode(\"version\", dependency.getVersion());\n+                        dependencyNode.appendNode(\"scope\", \"compile\");\n+                    }\n+                });\n+            });\n+        });\n+\n+        // Add git origin info to generated POM files\n+        publishing.getPublications().withType(MavenPublication.class, publication -> {\n+            publication.getPom().withXml(PublishPlugin::addScmInfo);\n+\n+            // have to defer this until archivesBaseName is set\n+            project.afterEvaluate(p -> publication.setArtifactId(getArchivesBaseName(project)));\n+\n+            generatePomTask.configure(\n+                t -> t.dependsOn(String.format(\"generatePomFileFor%sPublication\", Util.capitalize(publication.getName())))\n+            );\n+        });\n+\n+    }\n+\n+    private static void addScmInfo(XmlProvider xml) {\n+        Node root = xml.asNode();\n+        root.appendNode(\"url\", Util.urlFromOrigin(BuildParams.getGitOrigin()));\n+        Node scmNode = root.appendNode(\"scm\");\n+        scmNode.appendNode(\"url\", BuildParams.getGitOrigin());\n+    }\n+\n+    private static void configureJavadoc(Project project) {\n+        // remove compiled classes from the Javadoc classpath: http://mail.openjdk.java.net/pipermail/javadoc-dev/2018-January/000400.html\n+        final List<File> classes = new ArrayList<>();\n+        project.getTasks().withType(JavaCompile.class).configureEach(javaCompile -> classes.add(javaCompile.getDestinationDir()));\n+        project.getTasks().withType(Javadoc.class).configureEach(javadoc -> {\n+            // only explicitly set javadoc executable if compiler JDK is different from Gradle\n+            // this ensures better cacheability as setting ths input to an absolute path breaks portability\n+            Path compilerJvm = BuildParams.getCompilerJavaHome().toPath();\n+            Path gradleJvm = Jvm.current().getJavaHome().toPath();\n+            try {\n+                if (Files.isSameFile(compilerJvm, gradleJvm) == false) {\n+                    javadoc.setExecutable(compilerJvm.resolve(\"bin/javadoc\").toString());\n+                }\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+            javadoc.setClasspath(javadoc.getClasspath().filter(f -> classes.contains(f) == false));", "originalCommit": "07b800f022f8752be175d8767c549d399cdf13fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ5OTk1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/56727#discussion_r425499951", "bodyText": "I think this is a bit different. See http://mail.openjdk.java.net/pipermail/javadoc-dev/2018-January/000400.html", "author": "rjernst", "createdAt": "2020-05-15T00:23:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM5MDI0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUwMDY5OA==", "url": "https://github.com/elastic/elasticsearch/pull/56727#discussion_r425500698", "bodyText": "Oh I see what you mean now. Done.", "author": "rjernst", "createdAt": "2020-05-15T00:25:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM5MDI0Mw=="}], "type": "inlineReview"}, {"oid": "d13d26f3265cbd38db93005c587d821d64c7dcfd", "url": "https://github.com/elastic/elasticsearch/commit/d13d26f3265cbd38db93005c587d821d64c7dcfd", "message": "fix testkit", "committedDate": "2020-05-14T20:07:20Z", "type": "commit"}, {"oid": "a34883e2698694bbde316810458afce43664837a", "url": "https://github.com/elastic/elasticsearch/commit/a34883e2698694bbde316810458afce43664837a", "message": "Merge branch 'master' into buildsplit6", "committedDate": "2020-05-14T23:46:08Z", "type": "commit"}, {"oid": "10bd8d2798eeb6be122a9e7774be5e3efd87daa1", "url": "https://github.com/elastic/elasticsearch/commit/10bd8d2798eeb6be122a9e7774be5e3efd87daa1", "message": "address feedback", "committedDate": "2020-05-15T00:25:11Z", "type": "commit"}, {"oid": "0758d4c4a888d7c809890dccff2f7143d2fe257a", "url": "https://github.com/elastic/elasticsearch/commit/0758d4c4a888d7c809890dccff2f7143d2fe257a", "message": "checkstyle", "committedDate": "2020-05-15T00:34:47Z", "type": "commit"}]}