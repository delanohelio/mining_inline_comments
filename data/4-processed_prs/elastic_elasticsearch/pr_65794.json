{"pr_number": 65794, "pr_title": "[DOCS] EQL: Document how sequence queries handle matches", "pr_createdAt": "2020-12-02T23:49:58Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65794", "timeline": [{"oid": "ed2ee6c60dea7d4d66ca7d4e5466f59a2193624a", "url": "https://github.com/elastic/elasticsearch/commit/ed2ee6c60dea7d4d66ca7d4e5466f59a2193624a", "message": "[DOCS] EQL: Document sequence matching", "committedDate": "2020-12-02T23:51:59Z", "type": "forcePushed"}, {"oid": "51e310d2f5b983e61c6bb3d17696981253c09db1", "url": "https://github.com/elastic/elasticsearch/commit/51e310d2f5b983e61c6bb3d17696981253c09db1", "message": "[DOCS] EQL: Document sequence matching", "committedDate": "2020-12-02T23:54:07Z", "type": "forcePushed"}, {"oid": "a4e21d19cee00c10f7d11e30987de9e64db8bed0", "url": "https://github.com/elastic/elasticsearch/commit/a4e21d19cee00c10f7d11e30987de9e64db8bed0", "message": "[DOCS] EQL: Document sequence matching", "committedDate": "2020-12-02T23:55:11Z", "type": "forcePushed"}, {"oid": "45ddbd2a86bf76320bf0a2c2077bb47b6d89c70b", "url": "https://github.com/elastic/elasticsearch/commit/45ddbd2a86bf76320bf0a2c2077bb47b6d89c70b", "message": "Fix snippet again", "committedDate": "2020-12-03T03:04:41Z", "type": "forcePushed"}, {"oid": "f2f52f1c69e49d27be82c8c5d4cbe3a112596971", "url": "https://github.com/elastic/elasticsearch/commit/f2f52f1c69e49d27be82c8c5d4cbe3a112596971", "message": "[DOCS] EQL: Document sequence matching", "committedDate": "2020-12-03T03:05:03Z", "type": "forcePushed"}, {"oid": "eaf86cf51ed9244ef12a6f896b3f63a63a239dc9", "url": "https://github.com/elastic/elasticsearch/commit/eaf86cf51ed9244ef12a6f896b3f63a63a239dc9", "message": "[DOCS] EQL: Document sequence matching", "committedDate": "2020-12-03T03:11:11Z", "type": "forcePushed"}, {"oid": "5841410cd07b112ea32b120307e98ac55b0e933b", "url": "https://github.com/elastic/elasticsearch/commit/5841410cd07b112ea32b120307e98ac55b0e933b", "message": "[DOCS] EQL: Document sequence matching", "committedDate": "2020-12-03T03:12:23Z", "type": "forcePushed"}, {"oid": "da750cbb20af7268a9a0a19f63059427ff9150be", "url": "https://github.com/elastic/elasticsearch/commit/da750cbb20af7268a9a0a19f63059427ff9150be", "message": "[DOCS] EQL: Document sequence matching", "committedDate": "2020-12-03T03:12:54Z", "type": "forcePushed"}, {"oid": "7932ca2ce3ddbd0a04b991654f65f0130805b68e", "url": "https://github.com/elastic/elasticsearch/commit/7932ca2ce3ddbd0a04b991654f65f0130805b68e", "message": "[DOCS] EQL: Document sequence matching", "committedDate": "2020-12-03T03:19:02Z", "type": "forcePushed"}, {"oid": "a113a0a54a863cbe86f253c7ade28034a2c8ef73", "url": "https://github.com/elastic/elasticsearch/commit/a113a0a54a863cbe86f253c7ade28034a2c8ef73", "message": "[DOCS] EQL: Document how sequence queries find matches", "committedDate": "2020-12-03T14:35:42Z", "type": "forcePushed"}, {"oid": "bda543777a50649fa014e9d12964b239b7c3da75", "url": "https://github.com/elastic/elasticsearch/commit/bda543777a50649fa014e9d12964b239b7c3da75", "message": "[DOCS] EQL: Document how sequence queries find matches", "committedDate": "2020-12-03T14:36:52Z", "type": "commit"}, {"oid": "bda543777a50649fa014e9d12964b239b7c3da75", "url": "https://github.com/elastic/elasticsearch/commit/bda543777a50649fa014e9d12964b239b7c3da75", "message": "[DOCS] EQL: Document how sequence queries find matches", "committedDate": "2020-12-03T14:36:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMxOTA2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535319065", "bodyText": "is _id sorted by default? i can't remember how it fits into the sequence ordering. i think this is right, just want to double check", "author": "rw-access", "createdAt": "2020-12-03T15:14:12Z", "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }", "originalCommit": "bda543777a50649fa014e9d12964b239b7c3da75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMxOTYxNw==", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535319617", "bodyText": "A data set contains the following process events in ascending chronological\norder: ...\n\nah, this is more of an abstraction and deliberately not filled in .... in that case i think we're good", "author": "rw-access", "createdAt": "2020-12-03T15:14:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMxOTA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyMDYzMw==", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535320633", "bodyText": "Yeah. I originally included the @timestamp but it looked kinda noisy.", "author": "jrodewig", "createdAt": "2020-12-03T15:16:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMxOTA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyMjM2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535322365", "bodyText": "I'm not 100% sure if \"doesn't match state A\" will be immediately clear to users reading the docs.\nI'm wondering if we could say something more like this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // Nothing happens. This event doesn't match state A for the \"elkbee\" user.\n          \n          \n            \n            // Nothing happens. The \"elkbee\" user has no pending sequence to move from state A to state B", "author": "rw-access", "createdAt": "2020-12-03T15:18:17Z", "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]\n+----\n+\n+The query's event items correspond to the following states:\n+\n+* State A:  `[process where process.name == \"whoami\"]`\n+* State B:  `[process where process.name == \"hostname\"]`\n+* Complete: `[process where process.name == \"ifconfig\"]`\n+\n+To find matching sequences, the query uses separate state machines for each\n+unique `user.name` value. Pending sequence matches move through each machine's\n+states as follows:\n+\n+[source,txt]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [1] in state A for the \"root\" user.\n+\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [2] in state A for \"root\", overwriting sequence [1].\n+\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+// Nothing happens. This event doesn't match state A for the \"elkbee\" user.", "originalCommit": "bda543777a50649fa014e9d12964b239b7c3da75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyMzc5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535323792", "bodyText": "Thanks for raising this. I incorporated your change with a minor update.", "author": "jrodewig", "createdAt": "2020-12-03T15:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyMjM2NQ=="}], "type": "inlineReview"}, {"oid": "d9e14734d0c8dad8be1676591f3594eeb1580bcb", "url": "https://github.com/elastic/elasticsearch/commit/d9e14734d0c8dad8be1676591f3594eeb1580bcb", "message": "Update docs/reference/eql/syntax.asciidoc\n\nCo-authored-by: Ross Wolf <31489089+rw-access@users.noreply.github.com>", "committedDate": "2020-12-03T15:19:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyNTQzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535325431", "bodyText": "since this is the first state transition, maybe we could be extra clear that we're moving the pending sequence out of state A, and appending a new event as part of the transition.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // Sequence [2, 4] moves to state B for \"root\".\n          \n          \n            \n            // Sequence [2] moves out of state A for \"root\". State B for \"root\" now contains [2, 4]\n          \n          \n            \n            \n          \n      \n    \n    \n  \n\nI recently was walking through the algorithm with another engineer and I think these were some of the points of confusion", "author": "rw-access", "createdAt": "2020-12-03T15:21:59Z", "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]\n+----\n+\n+The query's event items correspond to the following states:\n+\n+* State A:  `[process where process.name == \"whoami\"]`\n+* State B:  `[process where process.name == \"hostname\"]`\n+* Complete: `[process where process.name == \"ifconfig\"]`\n+\n+To find matching sequences, the query uses separate state machines for each\n+unique `user.name` value. Pending sequence matches move through each machine's\n+states as follows:\n+\n+[source,txt]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [1] in state A for the \"root\" user.\n+\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [2] in state A for \"root\", overwriting sequence [1].\n+\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+// Nothing happens. This event doesn't match state A for the \"elkbee\" user.\n+\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+// Sequence [2, 4] moves to state B for \"root\".", "originalCommit": "bda543777a50649fa014e9d12964b239b7c3da75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMjQwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535332409", "bodyText": "// root: B=[2,4]", "author": "rw-access", "createdAt": "2020-12-03T15:30:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyNTQzMQ=="}], "type": "inlineReview"}, {"oid": "cd5599742a290aac7d8db05413b8240a7af9f2bf", "url": "https://github.com/elastic/elasticsearch/commit/cd5599742a290aac7d8db05413b8240a7af9f2bf", "message": "Update docs/reference/eql/syntax.asciidoc\n\nCo-authored-by: Ross Wolf <31489089+rw-access@users.noreply.github.com>", "committedDate": "2020-12-03T15:25:35Z", "type": "commit"}, {"oid": "e67a8c48bfe926a664c915a441455688351e8fe9", "url": "https://github.com/elastic/elasticsearch/commit/e67a8c48bfe926a664c915a441455688351e8fe9", "message": "Fix whitespace", "committedDate": "2020-12-03T15:26:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMDM4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535330389", "bodyText": "Do you think it could make sense to change the query so the ordering is more obvious?\nLike process.name == \"process1\", process.name == \"process2\", etc. It makes it a little bit more clear what's happening, because it's not totally easy to remember which command matches which state. Unfortunately it does make the dataset more abstract.\nWhat about a middle ground, like...\n\nattrib -> state A\nbash -> state B\ncat  -> state C", "author": "rw-access", "createdAt": "2020-12-03T15:27:49Z", "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]", "originalCommit": "bda543777a50649fa014e9d12964b239b7c3da75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0OTM5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535349391", "bodyText": "I like the middle ground idea. Pretty clever. I swapped out the process.name values for those with 9066d78. Let me know if you think they work.", "author": "jrodewig", "createdAt": "2020-12-03T15:45:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMDM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMTk3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535331977", "bodyText": "I'm also wondering if a visual representation could make it more digestible. Could be in addition to what's already there\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // Creates sequence [1] in state A for the \"root\" user.\n          \n          \n            \n            // Creates sequence [1] in state A for the \"root\" user.\n          \n          \n            \n            //\n          \n          \n            \n            // root: A=[1]", "author": "rw-access", "createdAt": "2020-12-03T15:29:43Z", "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]\n+----\n+\n+The query's event items correspond to the following states:\n+\n+* State A:  `[process where process.name == \"whoami\"]`\n+* State B:  `[process where process.name == \"hostname\"]`\n+* Complete: `[process where process.name == \"ifconfig\"]`\n+\n+To find matching sequences, the query uses separate state machines for each\n+unique `user.name` value. Pending sequence matches move through each machine's\n+states as follows:\n+\n+[source,txt]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [1] in state A for the \"root\" user.", "originalCommit": "bda543777a50649fa014e9d12964b239b7c3da75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1MDUyOA==", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535350528", "bodyText": "+1. This is a great idea. Added with 9066d78.", "author": "jrodewig", "createdAt": "2020-12-03T15:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMTk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMjIwNg==", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535332206", "bodyText": "// root: A=[2]\n```", "author": "rw-access", "createdAt": "2020-12-03T15:29:59Z", "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]\n+----\n+\n+The query's event items correspond to the following states:\n+\n+* State A:  `[process where process.name == \"whoami\"]`\n+* State B:  `[process where process.name == \"hostname\"]`\n+* Complete: `[process where process.name == \"ifconfig\"]`\n+\n+To find matching sequences, the query uses separate state machines for each\n+unique `user.name` value. Pending sequence matches move through each machine's\n+states as follows:\n+\n+[source,txt]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [1] in state A for the \"root\" user.\n+\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [2] in state A for \"root\", overwriting sequence [1].", "originalCommit": "bda543777a50649fa014e9d12964b239b7c3da75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9066d7887b64ef6d21524debeee87580ee2f959d", "url": "https://github.com/elastic/elasticsearch/commit/9066d7887b64ef6d21524debeee87580ee2f959d", "message": "Replace process.name vals. Add state comments", "committedDate": "2020-12-03T15:43:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA0NDUzNw==", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r536044537", "bodyText": "This can be a follow-up ticket; having a visual representation of the events, the potential sequences and the final sequences helps a lot in understanding how this works vs just the test description.\nIt doesn't have to be something fancy, a basic diagram or even ascii art would go a long way.", "author": "costin", "createdAt": "2020-12-04T11:51:35Z", "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,147 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"cat\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"cat\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"cat\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:", "originalCommit": "9066d7887b64ef6d21524debeee87580ee2f959d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0MTk2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r536141966", "bodyText": "Sounds good. I'll get this merged in and work on adding some diagrams as part of a separate PR.", "author": "jrodewig", "createdAt": "2020-12-04T14:34:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA0NDUzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0NDcwNg==", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r536144706", "bodyText": "Related issue: #65888", "author": "jrodewig", "createdAt": "2020-12-04T14:38:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA0NDUzNw=="}], "type": "inlineReview"}]}