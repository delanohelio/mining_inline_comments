{"pr_number": 53230, "pr_title": "Enrich documents with inference results at Fetch", "pr_createdAt": "2020-03-06T15:50:44Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53230", "timeline": [{"oid": "333ba97db0bdb6819a70e966d3d6014fbae654e7", "url": "https://github.com/elastic/elasticsearch/commit/333ba97db0bdb6819a70e966d3d6014fbae654e7", "message": "add disclaimer", "committedDate": "2020-03-09T11:38:31Z", "type": "forcePushed"}, {"oid": "0d3aa044392420cdb0c9f751aa4db3c94f915658", "url": "https://github.com/elastic/elasticsearch/commit/0d3aa044392420cdb0c9f751aa4db3c94f915658", "message": "Blacklist tests that fail security checks", "committedDate": "2020-03-10T11:04:59Z", "type": "forcePushed"}, {"oid": "1cdea63e53040fa73c33a8ace4b71f11070a99d4", "url": "https://github.com/elastic/elasticsearch/commit/1cdea63e53040fa73c33a8ace4b71f11070a99d4", "message": "Sketch out how to pass a service to a FetchSubPhase.", "committedDate": "2020-03-10T12:37:47Z", "type": "commit"}, {"oid": "c5e61c434101885fbbe3e8b592131a600d8f2af5", "url": "https://github.com/elastic/elasticsearch/commit/c5e61c434101885fbbe3e8b592131a600d8f2af5", "message": "Make sure to lazily access ModelLoadingService.", "committedDate": "2020-03-10T12:37:47Z", "type": "commit"}, {"oid": "f6b27255905b69d9b6a9a19aff00071928a05ad2", "url": "https://github.com/elastic/elasticsearch/commit/f6b27255905b69d9b6a9a19aff00071928a05ad2", "message": "Use search ext", "committedDate": "2020-03-10T12:37:47Z", "type": "commit"}, {"oid": "de90bae18010f7449454448214c03b9c0995e414", "url": "https://github.com/elastic/elasticsearch/commit/de90bae18010f7449454448214c03b9c0995e414", "message": "Inference at fetch", "committedDate": "2020-03-10T12:37:48Z", "type": "commit"}, {"oid": "818ac7d69b8c76cfd39f4ed5c83a38539ca3ec7f", "url": "https://github.com/elastic/elasticsearch/commit/818ac7d69b8c76cfd39f4ed5c83a38539ca3ec7f", "message": " Add target field", "committedDate": "2020-03-10T12:37:48Z", "type": "commit"}, {"oid": "66f6b051aa67fd371b00d27cb4de89c7c355ce0e", "url": "https://github.com/elastic/elasticsearch/commit/66f6b051aa67fd371b00d27cb4de89c7c355ce0e", "message": "add disclaimer", "committedDate": "2020-03-10T12:37:48Z", "type": "commit"}, {"oid": "3088b85f5e19cde7d62913288ec9774f578819b8", "url": "https://github.com/elastic/elasticsearch/commit/3088b85f5e19cde7d62913288ec9774f578819b8", "message": "Blacklist tests that fail security checks", "committedDate": "2020-03-10T12:37:48Z", "type": "commit"}, {"oid": "3088b85f5e19cde7d62913288ec9774f578819b8", "url": "https://github.com/elastic/elasticsearch/commit/3088b85f5e19cde7d62913288ec9774f578819b8", "message": "Blacklist tests that fail security checks", "committedDate": "2020-03-10T12:37:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ0Njg5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53230#discussion_r390446896", "bodyText": "I wonder if we should implement ToXContentObject instead of having a bespoke method that creates a map.", "author": "benwtrent", "createdAt": "2020-03-10T16:30:06Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/results/InferenceResults.java", "diffHunk": "@@ -8,8 +8,11 @@\n import org.elasticsearch.common.io.stream.NamedWriteable;\n import org.elasticsearch.ingest.IngestDocument;\n \n+import java.util.Map;\n+\n public interface InferenceResults extends NamedWriteable {\n \n     void writeResult(IngestDocument document, String parentResultField);\n \n+    Map<String, Object> writeResultToMap(String parentResultField);", "originalCommit": "3088b85f5e19cde7d62913288ec9774f578819b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyMjYxNA==", "url": "https://github.com/elastic/elasticsearch/pull/53230#discussion_r390522614", "bodyText": "The map is converted to DocumentFields we couldn't do that with ToXContentObject", "author": "davidkyle", "createdAt": "2020-03-10T18:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ0Njg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU1OTU1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53230#discussion_r390559552", "bodyText": "Cool :D", "author": "benwtrent", "createdAt": "2020-03-10T19:29:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ0Njg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ0OTEwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/53230#discussion_r390449101", "bodyText": "I think this is backwards.\nWe should have the synchronous method call the asynchronous method. This is the prevelant pattern everywhere else. Also, it is possible to make something asynchronous -> synchronous, not really the other way around.", "author": "benwtrent", "createdAt": "2020-03-10T16:33:16Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java", "diffHunk": "@@ -53,23 +57,18 @@ public String getResultsType() {\n                 return RegressionInferenceResults.NAME;\n             default:\n                 throw ExceptionsHelper.badRequestException(\"Model [{}] has unsupported target type [{}]\",\n-                    modelId,\n-                    trainedModelDefinition.getTrainedModel().targetType());\n+                        modelId,\n+                        trainedModelDefinition.getTrainedModel().targetType());\n         }\n     }\n \n     @Override\n-    public void infer(Map<String, Object> fields, InferenceConfig config, ActionListener<InferenceResults> listener) {\n-        try {\n-            if (fieldNames.stream().allMatch(f -> MapHelper.dig(f, fields) == null)) {\n-                listener.onResponse(new WarningInferenceResults(Messages.getMessage(INFERENCE_WARNING_ALL_FIELDS_MISSING, modelId)));\n-                return;\n-            }\n-\n-            listener.onResponse(trainedModelDefinition.infer(fields, config));\n-        } catch (Exception e) {\n-            listener.onFailure(e);\n+    public InferenceResults infer(Map<String, Object> fields, InferenceConfig config) {", "originalCommit": "3088b85f5e19cde7d62913288ec9774f578819b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUzMTE4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53230#discussion_r390531182", "bodyText": "Yes it is backwards.\nThe function called by LocalModel::infer is TrainedModelDefinition::infer which does not have an async version. In this case we want to work to be done in the calling thread because the model is local to the call, for single threaded models I can't think of a situation where we would want to spawn another thread to do the work as we know inference is cheap. For models that could be parallelised and the work split over multiple threads then yes you would want to make it async.\nDo we even need the async method right now? It is only called by TransportInternalInferModelAction and could easily be changed.\nI removed the default method because it is backwards and wrong then implemented it in LocalModel.", "author": "davidkyle", "createdAt": "2020-03-10T18:39:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ0OTEwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU2MTY2MA==", "url": "https://github.com/elastic/elasticsearch/pull/53230#discussion_r390561660", "bodyText": "Do we even need the async method right now?\n\nMaybe not, but it is much more difficult to make things asynchronous once they are synchronous.\nAssumptions are made about where the model lives when it is synchronous.\nWhat if this was a natively loaded model?\nWould we pause the calling thread for the data to be serialized down the native process?\nI am not sure about this, but I did not want to paint us in a corner.", "author": "benwtrent", "createdAt": "2020-03-10T19:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ0OTEwMQ=="}], "type": "inlineReview"}, {"oid": "6a102b9f3a4902c1f8459b813dbd8eb09eb04091", "url": "https://github.com/elastic/elasticsearch/commit/6a102b9f3a4902c1f8459b813dbd8eb09eb04091", "message": "remove default sync method", "committedDate": "2020-03-10T18:37:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU2MjY4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53230#discussion_r390562687", "bodyText": "agreed :D. We may want this call to fail if the model is not deployed in the provided model service. Especially since there is no way to load it just in time :/", "author": "benwtrent", "createdAt": "2020-03-10T19:35:10Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/search/InferencePhase.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.inference.search;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.common.document.DocumentField;\n+import org.elasticsearch.search.SearchExtBuilder;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.fetch.FetchSubPhase;\n+import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.xpack.core.ml.inference.results.InferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfig;\n+import org.elasticsearch.xpack.core.ml.utils.MapHelper;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.ModelLoadingService;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+\n+/**\n+ * A very rough sketch of a fetch sub phase that performs inference on each search hit,\n+ * then augments the hit with the result.\n+ */\n+public class InferencePhase implements FetchSubPhase {\n+\n+    private final SetOnce<ModelLoadingService> modelLoadingService;\n+\n+    public InferencePhase(SetOnce<ModelLoadingService> modelLoadingService) {\n+        this.modelLoadingService = modelLoadingService;\n+    }\n+\n+    @Override\n+    public void hitsExecute(SearchContext searchContext, SearchHit[] hits) {\n+        SearchExtBuilder inferenceBuilder = searchContext.getSearchExt(InferenceSearchExtBuilder.NAME);\n+        if (inferenceBuilder == null) {\n+            return;\n+        }\n+\n+        InferenceSearchExtBuilder infBuilder = (InferenceSearchExtBuilder)inferenceBuilder;\n+\n+        SetOnce<Model> model = new SetOnce<>();\n+        CountDownLatch latch = new CountDownLatch(1);\n+        ActionListener<Model> listener = new LatchedActionListener<>(\n+                ActionListener.wrap(model::set, e -> { throw new RuntimeException();}), latch);\n+\n+        modelLoadingService.get().getModel(infBuilder.getModelId(), listener);\n+        try {\n+            // Eeek blocking on a latch we can't be doing that", "originalCommit": "6a102b9f3a4902c1f8459b813dbd8eb09eb04091", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}