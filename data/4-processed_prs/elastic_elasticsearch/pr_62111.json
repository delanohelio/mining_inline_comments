{"pr_number": 62111, "pr_title": "Async search: don't track fetch failures", "pr_createdAt": "2020-09-08T15:21:02Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62111", "timeline": [{"oid": "652b5d5c59718671fd12f2442424e27781749b66", "url": "https://github.com/elastic/elasticsearch/commit/652b5d5c59718671fd12f2442424e27781749b66", "message": "Async search: don't track fetch failures\n\nFetch failures are currently tracked byy AsyncSearchTask like ordinary shard failures. Though they should be treated differently or they end up causing weird scenarios like total=num_shards and successful=num_shards as the query phase ran fine yet the failed count would reflect the number of shards where fetch failed.\n\nGiven that partial results only include aggs for now and are complete even if fetch fails, we can ignore fetch failures in async search, as they will be anyways included in the response. They are in fact either received as a failure when all shards fail during fetch, or as part of the final response when only some shards fail during fetch.", "committedDate": "2020-09-08T15:16:51Z", "type": "commit"}, {"oid": "e436e5d8a0c058d017521f2336151f43097c69ac", "url": "https://github.com/elastic/elasticsearch/commit/e436e5d8a0c058d017521f2336151f43097c69ac", "message": "adjust AsyncSearchTaskTests", "committedDate": "2020-09-08T16:09:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1NjY4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62111#discussion_r485156681", "bodyText": "Can we keep the name as is for now. I understand that we want to call it query failures after this change but we may also want to provide a way to return partial top hits in the future. My point being that we might reintroduce fetch failures when they make sense.", "author": "jimczi", "createdAt": "2020-09-08T19:46:31Z", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -35,7 +35,7 @@\n     private final int totalShards;\n     private final int skippedShards;\n     private final Clusters clusters;\n-    private final AtomicArray<ShardSearchFailure> shardFailures;\n+    private final AtomicArray<ShardSearchFailure> queryFailures;", "originalCommit": "e436e5d8a0c058d017521f2336151f43097c69ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM5OTA5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62111#discussion_r485399092", "bodyText": "this is not a huge deal, but can we not rename it back to shardFailures in the future once we introduce a way to return partial top hits?", "author": "javanna", "createdAt": "2020-09-09T07:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1NjY4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQwOTYwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62111#discussion_r485409605", "bodyText": "As you want, that's not a big deal I agree but I wanted to raise the awareness that returning partial top hits is still in the air.", "author": "jimczi", "createdAt": "2020-09-09T07:51:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1NjY4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQyMzE5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62111#discussion_r485423199", "bodyText": "Thanks, I am aware, and I probably would have made the same comment if you had made this same change :)", "author": "javanna", "createdAt": "2020-09-09T08:14:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1NjY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1OTY3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62111#discussion_r485159677", "bodyText": "nit: you could derive it from the index name instead ?", "author": "jimczi", "createdAt": "2020-09-08T19:52:20Z", "path": "x-pack/plugin/async-search/src/test/java/org/elasticsearch/xpack/search/AsyncSearchSingleNodeTests.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.search;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshRequest;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.search.SearchPhaseExecutionException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.search.ShardSearchFailure;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.plugins.SearchPlugin;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.fetch.FetchSubPhase;\n+import org.elasticsearch.search.fetch.FetchSubPhaseProcessor;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n+import org.elasticsearch.xpack.core.search.action.AsyncSearchResponse;\n+import org.elasticsearch.xpack.core.search.action.SubmitAsyncSearchAction;\n+import org.elasticsearch.xpack.core.search.action.SubmitAsyncSearchRequest;\n+import org.hamcrest.CoreMatchers;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public class AsyncSearchSingleNodeTests extends ESSingleNodeTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> getPlugins() {\n+        return List.of(AsyncSearch.class, SubFetchPhasePlugin.class);\n+    }\n+\n+    public void testFetchFailuresAllShards() throws Exception {\n+        for (int i = 0; i < 10; i++) {\n+            IndexResponse indexResponse = client().index(new IndexRequest(\"boom\" + i).id(\"boom\" + i).source(\"text\", \"value\")).get();\n+            assertEquals(RestStatus.CREATED, indexResponse.status());\n+        }\n+        client().admin().indices().refresh(new RefreshRequest()).get();\n+\n+        TermsAggregationBuilder agg = new TermsAggregationBuilder(\"text\").field(\"text.keyword\");\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().aggregation(agg);\n+        SubmitAsyncSearchRequest submitAsyncSearchRequest = new SubmitAsyncSearchRequest(sourceBuilder);\n+        submitAsyncSearchRequest.setWaitForCompletionTimeout(TimeValue.timeValueSeconds(10));\n+        AsyncSearchResponse asyncSearchResponse = client().execute(SubmitAsyncSearchAction.INSTANCE, submitAsyncSearchRequest).actionGet();\n+\n+        assertFalse(asyncSearchResponse.isRunning());\n+        assertTrue(asyncSearchResponse.isPartial());\n+        SearchResponse searchResponse = asyncSearchResponse.getSearchResponse();\n+        assertEquals(10, searchResponse.getTotalShards());\n+        assertEquals(10, searchResponse.getSuccessfulShards());\n+        assertEquals(0, searchResponse.getFailedShards());\n+        assertEquals(0, searchResponse.getShardFailures().length);\n+        assertEquals(10, searchResponse.getHits().getTotalHits().value);\n+        assertEquals(0, searchResponse.getHits().getHits().length);\n+        StringTerms terms = searchResponse.getAggregations().get(\"text\");\n+        assertEquals(1, terms.getBuckets().size());\n+        assertEquals(10, terms.getBucketByKey(\"value\").getDocCount());\n+        assertNotNull(asyncSearchResponse.getFailure());\n+        assertThat(asyncSearchResponse.getFailure(), CoreMatchers.instanceOf(ElasticsearchStatusException.class));\n+        ElasticsearchStatusException statusException = (ElasticsearchStatusException) asyncSearchResponse.getFailure();\n+        assertEquals(RestStatus.INTERNAL_SERVER_ERROR, statusException.status());\n+        assertThat(asyncSearchResponse.getFailure().getCause(), CoreMatchers.instanceOf(SearchPhaseExecutionException.class));\n+        SearchPhaseExecutionException phaseExecutionException = (SearchPhaseExecutionException) asyncSearchResponse.getFailure().getCause();\n+        assertEquals(\"fetch\", phaseExecutionException.getPhaseName());\n+        assertEquals(\"boom\", phaseExecutionException.getCause().getMessage());\n+        assertEquals(10, phaseExecutionException.shardFailures().length);\n+        for (ShardSearchFailure shardSearchFailure : phaseExecutionException.shardFailures()) {\n+            assertEquals(\"boom\", shardSearchFailure.getCause().getMessage());\n+        }\n+    }\n+\n+    public void testFetchFailuresOnlySomeShards() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            IndexResponse indexResponse = client().index(new IndexRequest(\"boom\" + i).id(\"boom\" + i).source(\"text\", \"value\")).get();\n+            assertEquals(RestStatus.CREATED, indexResponse.status());\n+        }\n+        for (int i = 0; i < 5; i++) {\n+            IndexResponse indexResponse = client().index(new IndexRequest(\"index\" + i).id(\"index\" + i).source(\"text\", \"value\")).get();\n+            assertEquals(RestStatus.CREATED, indexResponse.status());\n+        }\n+        client().admin().indices().refresh(new RefreshRequest()).get();\n+\n+        TermsAggregationBuilder agg = new TermsAggregationBuilder(\"text\").field(\"text.keyword\");\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().aggregation(agg);\n+        SubmitAsyncSearchRequest submitAsyncSearchRequest = new SubmitAsyncSearchRequest(sourceBuilder);\n+        submitAsyncSearchRequest.setWaitForCompletionTimeout(TimeValue.timeValueSeconds(10));\n+        AsyncSearchResponse asyncSearchResponse = client().execute(SubmitAsyncSearchAction.INSTANCE, submitAsyncSearchRequest).actionGet();\n+\n+        assertFalse(asyncSearchResponse.isRunning());\n+        assertFalse(asyncSearchResponse.isPartial());\n+        assertNull(asyncSearchResponse.getFailure());\n+        SearchResponse searchResponse = asyncSearchResponse.getSearchResponse();\n+        assertEquals(10, searchResponse.getTotalShards());\n+        assertEquals(5, searchResponse.getSuccessfulShards());\n+        assertEquals(5, searchResponse.getFailedShards());\n+        assertEquals(10, searchResponse.getHits().getTotalHits().value);\n+        assertEquals(5, searchResponse.getHits().getHits().length);\n+        StringTerms terms = searchResponse.getAggregations().get(\"text\");\n+        assertEquals(1, terms.getBuckets().size());\n+        assertEquals(10, terms.getBucketByKey(\"value\").getDocCount());\n+        assertEquals(5, searchResponse.getShardFailures().length);\n+        for (ShardSearchFailure shardFailure : searchResponse.getShardFailures()) {\n+            assertEquals(\"boom\", shardFailure.getCause().getMessage());\n+        }\n+    }\n+\n+    public static final class SubFetchPhasePlugin extends Plugin implements SearchPlugin {\n+        @Override\n+        public List<FetchSubPhase> getFetchSubPhases(FetchPhaseConstructionContext context) {\n+            return Collections.singletonList(searchContext -> new FetchSubPhaseProcessor() {\n+                @Override\n+                public void setNextReader(LeafReaderContext readerContext) {}\n+\n+                @Override\n+                public void process(FetchSubPhase.HitContext hitContext) {\n+                    if (hitContext.hit().getId().startsWith(\"boom\")) {", "originalCommit": "e436e5d8a0c058d017521f2336151f43097c69ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM5ODQwNg==", "url": "https://github.com/elastic/elasticsearch/pull/62111#discussion_r485398406", "bodyText": "that is what I thought too but it turns out the index is null, no idea why.", "author": "javanna", "createdAt": "2020-09-09T07:32:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1OTY3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQxMTY4NA==", "url": "https://github.com/elastic/elasticsearch/pull/62111#discussion_r485411684", "bodyText": "do you mean hitContext.hit().getIndex() is null ?", "author": "jimczi", "createdAt": "2020-09-09T07:55:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1OTY3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQyMzM2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62111#discussion_r485423366", "bodyText": "yes pretty much everything is null in the hit besides the id", "author": "javanna", "createdAt": "2020-09-09T08:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1OTY3Nw=="}], "type": "inlineReview"}, {"oid": "6bc90828544faf23a28c1c058660113f2b03367d", "url": "https://github.com/elastic/elasticsearch/commit/6bc90828544faf23a28c1c058660113f2b03367d", "message": "Merge branch 'master' into enhancement/async_search_fetch_failures", "committedDate": "2020-09-09T07:36:44Z", "type": "commit"}]}