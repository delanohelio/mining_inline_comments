{"pr_number": 58090, "pr_title": "Improve threadpool usage and error handling for API key validation", "pr_createdAt": "2020-06-15T06:33:50Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58090", "timeline": [{"oid": "801852211544dd2f617abae3db203b26da0fe34b", "url": "https://github.com/elastic/elasticsearch/commit/801852211544dd2f617abae3db203b26da0fe34b", "message": "Add separat thread pool for API key hashing\n\nAlso return 429 when either GET or the hashing thread pool is saturated.", "committedDate": "2020-06-15T06:11:41Z", "type": "commit"}, {"oid": "85ff0354ba2b38f648446b19d7bab9c63a440c4a", "url": "https://github.com/elastic/elasticsearch/commit/85ff0354ba2b38f648446b19d7bab9c63a440c4a", "message": "Fix bug where threadpool size can be 0", "committedDate": "2020-06-15T07:57:04Z", "type": "commit"}, {"oid": "202a5a8b0fc8ce7f137bcebd29b3c6de68c06549", "url": "https://github.com/elastic/elasticsearch/commit/202a5a8b0fc8ce7f137bcebd29b3c6de68c06549", "message": "Fix test threadpool", "committedDate": "2020-06-15T08:33:02Z", "type": "commit"}, {"oid": "121581e65300e4572456216f1310e83ae612130f", "url": "https://github.com/elastic/elasticsearch/commit/121581e65300e4572456216f1310e83ae612130f", "message": "Only push expansive hash computation to new thread pool", "committedDate": "2020-06-15T11:53:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEzOTMxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r440139319", "bodyText": "The specified executor will only be used when the future is being computed, i.e. expensive hashing is underway. In this case, the API key is not yet cached, so change it to use the separate hashing pool which are dedicated to uncached API keys. If the future is already computed, it is handled in the same thread and the executor will not be used at all (i.e. does not affect cached API key auth).", "author": "ywangd", "createdAt": "2020-06-15T12:27:19Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -466,25 +480,33 @@ void validateApiKeyCredentials(String docId, Map<String, Object> source, ApiKeyC\n                                 validateApiKeyCredentials(docId, source, credentials, clock, listener);\n                             }\n                         }, listener::onFailure),\n-                        threadPool.generic(), threadPool.getThreadContext());\n+                        threadPool.executor(THREAD_POOL_NAME), threadPool.getThreadContext());", "originalCommit": "121581e65300e4572456216f1310e83ae612130f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc3ODUyNw==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r440778527", "bodyText": "It's a bit of a grey area, but I would lean more on using the generic threadPool for these lightweight listeners. The purpose of using a dedicated bounded work queue and thread pool is to limit the amount of expensive tasks, otherwise it would be reasonable to enqueue unlimited requests (they are limited by other considerations such as memory). I feel like these small tasks add noise to the work queue dedicated to expensive tasks.", "author": "albertzaharovits", "createdAt": "2020-06-16T11:26:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEzOTMxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI5MTAyMA==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r441291020", "bodyText": "Reverted it back to use generic pool. I don't know exactly the best practice of using generic pool. I think what you said makes sense. But on the other hand, generic pool being unbounded is likely an issue by itself. It is likely a bad circuit breaker. Anyway, we have been using generic pool here for a while now, so it is safe to keep it untouched.", "author": "ywangd", "createdAt": "2020-06-17T05:37:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEzOTMxOQ=="}], "type": "inlineReview"}, {"oid": "aac19ad3c5513e25616ac2653a0326949c0346ce", "url": "https://github.com/elastic/elasticsearch/commit/aac19ad3c5513e25616ac2653a0326949c0346ce", "message": "Avoid forking if current thread is already for api-key", "committedDate": "2020-06-15T12:37:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDcyMzc1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r440723753", "bodyText": "GH doesn't allow me to comment on the line above. My intention is to comment on:\nvalidateApiKeyCredentials(docId, source, credentials, clock, listener);\n\n\nIn general I think it is very tricky to decide between listener.onFailure, listener.onRestponse(AuthenticationResult.unsuccessful and listener.onRestponse(AuthenticationResult.terminate and I think you did a good job of not changing existing behaviour unless necessary.\nWhat I would suggest is that we \"contain\" the if (ExceptionsHelper.unwrapCause(e) instanceof EsRejectedExecutionException) { as much as possible. There are conflicting goals at play, but I would prefer :\n         executeAsyncWithOrigin(ctx, SECURITY_ORIGIN, getRequest, ActionListener.<GetResponse>wrap(response -> {\n                 if (response.isExists()) {\n                     final Map<String, Object> source = response.getSource();\n-                    validateApiKeyCredentials(docId, source, credentials, clock, listener);\n+                    validateApiKeyCredentials(docId, source, credentials, clock, ActionListener.delegateResponse(listener,\n+                            (l, e) -> {\n+                                if (ExceptionsHelper.unwrapCause(e) instanceof EsRejectedExecutionException) {\n+                                    listener.onResponse(AuthenticationResult.terminate(\"server is too busy to respond\", e));\n+                                } else {\n+                                    listener.onResponse(AuthenticationResult.unsuccessful(\n+                                            \"apikey authentication for id \" + credentials.getId() + \" encountered a failure\",e));\n+                                }\n+                            }));\n                 } else {\n                     listener.onResponse(\n                         AuthenticationResult.unsuccessful(\"unable to find apikey with id \" + credentials.getId(), null));\n\nbecause this way we contain this particular exception handling only to a single method loadApiKeyAndValidateCredentials which I think is a reasonable place (i.e. it's a method that returns response failures ).", "author": "albertzaharovits", "createdAt": "2020-06-16T09:44:04Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -334,8 +342,14 @@ private void loadApiKeyAndValidateCredentials(ThreadContext ctx, ApiKeyCredentia\n                         AuthenticationResult.unsuccessful(\"unable to find apikey with id \" + credentials.getId(), null));", "originalCommit": "aac19ad3c5513e25616ac2653a0326949c0346ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI4NjU2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r441286562", "bodyText": "You are right. It is better to confine the special handling in a single method. Updated as you suggested with one modification: instead of calling listener.onResponse(AuthenticationResult.unsuccessful(...)) on the else branch, I think it is better to call listener.onFailure(e) which is consistent with original logic. We might wanna change how unsuccessful and terminate are determined in the future, but I feel it deserves a separate PR.", "author": "ywangd", "createdAt": "2020-06-17T05:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDcyMzc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyMjY3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r442122673", "bodyText": "instead of calling listener.onResponse(AuthenticationResult.unsuccessful(...)) on the else branch, I think it is better to call listener.onFailure(e) which is consistent with original logic\n\nGreat, it was my intention to maintain the original behavior.\n\nWe might wanna change how unsuccessful and terminate are determined in the future, but I feel it deserves a separate PR.\n\nYeah, I believe we should do that.", "author": "albertzaharovits", "createdAt": "2020-06-18T10:18:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDcyMzc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDcyNTg1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r440725855", "bodyText": "I would avoid this special handling at this level because I believe it's relatively difficult to figure out the cases this branch covers. It would be OKish if this were the only place, but it's not. Please see comment below for my suggestion.", "author": "albertzaharovits", "createdAt": "2020-06-16T09:47:40Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -307,7 +311,11 @@ void authenticateWithApiKeyIfPresent(ThreadContext ctx, ActionListener<Authentic\n                     },\n                     e -> {\n                         credentials.close();\n-                        listener.onFailure(e);\n+                        if (ExceptionsHelper.unwrapCause(e) instanceof EsRejectedExecutionException) {\n+                            listener.onResponse(AuthenticationResult.terminate(\"server is too busy to respond\", e));\n+                        } else {\n+                            listener.onFailure(e);\n+                        }", "originalCommit": "aac19ad3c5513e25616ac2653a0326949c0346ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI4NjY2MA==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r441286660", "bodyText": "Agreed. See above. Thanks", "author": "ywangd", "createdAt": "2020-06-17T05:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDcyNTg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc4MzIyNg==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r440783226", "bodyText": "Personal preference, move this inside the listener, so it's closer to the use and destroy place.", "author": "albertzaharovits", "createdAt": "2020-06-16T11:36:18Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -552,14 +574,17 @@ static ApiKeyCredentials getCredentialsFromHeader(ThreadContext threadContext) {\n     }\n \n     // Protected instance method so this can be mocked\n-    protected boolean verifyKeyAgainstHash(String apiKeyHash, ApiKeyCredentials credentials) {\n+    protected void verifyKeyAgainstHash(String apiKeyHash, ApiKeyCredentials credentials, ActionListener<Boolean> listener) {\n         final char[] apiKeyHashChars = apiKeyHash.toCharArray();", "originalCommit": "aac19ad3c5513e25616ac2653a0326949c0346ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI4NzIxMg==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r441287212", "bodyText": "I think this is a subtle but great suggestion. We want minimize the duration a secret stay in memory. When it is outside of the runnable, it could stay in memory for very long if thread pool is busy. Moved it into the runnable as you suggested.", "author": "ywangd", "createdAt": "2020-06-17T05:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc4MzIyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc5MjM5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r440792399", "bodyText": "This optimisation is a nice touch, but it doesn't jibe with my comment above about only keeping expensive hashing on the dedicated thread pool.", "author": "albertzaharovits", "createdAt": "2020-06-16T11:54:46Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -552,14 +574,17 @@ static ApiKeyCredentials getCredentialsFromHeader(ThreadContext threadContext) {\n     }\n \n     // Protected instance method so this can be mocked\n-    protected boolean verifyKeyAgainstHash(String apiKeyHash, ApiKeyCredentials credentials) {\n+    protected void verifyKeyAgainstHash(String apiKeyHash, ApiKeyCredentials credentials, ActionListener<Boolean> listener) {\n         final char[] apiKeyHashChars = apiKeyHash.toCharArray();\n-        try {\n-            Hasher hasher = Hasher.resolveFromHash(apiKeyHash.toCharArray());\n-            return hasher.verify(credentials.getKey(), apiKeyHashChars);\n-        } finally {\n-            Arrays.fill(apiKeyHashChars, (char) 0);\n-        }\n+        Hasher hasher = Hasher.resolveFromHash(apiKeyHash.toCharArray());\n+        final String executorName = Thread.currentThread().getName().contains(THREAD_POOL_NAME) ? ThreadPool.Names.SAME : THREAD_POOL_NAME;", "originalCommit": "aac19ad3c5513e25616ac2653a0326949c0346ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI5MTMwMg==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r441291302", "bodyText": "Thanks. Removed since the generic pool usage is now restored.", "author": "ywangd", "createdAt": "2020-06-17T05:37:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc5MjM5OQ=="}], "type": "inlineReview"}, {"oid": "a56927ff1d445c34e920ba920a3eb24930c23885", "url": "https://github.com/elastic/elasticsearch/commit/a56927ff1d445c34e920ba920a3eb24930c23885", "message": "Address feedback", "committedDate": "2020-06-17T05:13:18Z", "type": "commit"}, {"oid": "770b2467c297e2634448f77983870b5ece258889", "url": "https://github.com/elastic/elasticsearch/commit/770b2467c297e2634448f77983870b5ece258889", "message": "Minor tweak", "committedDate": "2020-06-17T05:26:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM0ODYxOA==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r441348618", "bodyText": "Note by using half of the allocated processors, initial authentiation of API keys, i.e. warming up the cache, could be up to twice as slow as current implemention.", "author": "ywangd", "createdAt": "2020-06-17T07:47:45Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/Security.java", "diffHunk": "@@ -992,9 +993,14 @@ public AsyncSender interceptSender(AsyncSender sender) {\n     @Override\n     public List<ExecutorBuilder<?>> getExecutorBuilders(final Settings settings) {\n         if (enabled) {\n-            return Collections.singletonList(\n-                    new FixedExecutorBuilder(settings, TokenService.THREAD_POOL_NAME, 1, 1000, \"xpack.security.authc.token.thread_pool\",\n-                        false));\n+            final int allocatedProcessors = EsExecutors.allocatedProcessors(settings);\n+            return List.of(\n+                new FixedExecutorBuilder(settings, TokenService.THREAD_POOL_NAME, 1, 1000,\n+                    \"xpack.security.authc.token.thread_pool\", false),\n+                new FixedExecutorBuilder(settings, ApiKeyService.THREAD_POOL_NAME,\n+                    (allocatedProcessors + 1) / 2, 1000,", "originalCommit": "770b2467c297e2634448f77983870b5ece258889", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE5MTExNQ==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r442191115", "bodyText": "The maximum theoretical throughput of new (previously unseen) API key validations will indeed halve, but I'm not personally worried about it. We're talking about the theoretical maximum throughput which, because of the contention on the get threadpool, and because there are many thread pools overbooking the available processors, it's not something I would consider practically important.\nYet, a possible mitigation would be to decrease (halve) the default hashing cost factor for API Keys. GIven the length of the random api key secret that we generate, we would still remain out of the brute force plausibility range.", "author": "albertzaharovits", "createdAt": "2020-06-18T12:33:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM0ODYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYxMjcyNg==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r444612726", "bodyText": "That's quite a large number of new threads to be adding to the system, especially threads that could end up all being busy at once for a long time authenticating a lot of clients. They're then stealing CPU time from other components of the system. What work have we done to justify that the thread pool needs to be this large (the ceiling of half the number of cores)?", "author": "jasontedor", "createdAt": "2020-06-24T02:40:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM0ODYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4MjE0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r444882146", "bodyText": "A few reasons:\n\nIt has fewer threads than the GET thread pool - the current code performs the hashing in the GET thread pool, which has number of threads equals to number of cores. The new thread pool should in fact help with resource stealing. Besides, saturation of GET thread pool has wider negative impacts to both uncached and cached authentication. A new pool helps isolate the impact to only new clients trying to connect.\nBalance between throughput and resource contention - the expensive hashing operations are unavoidable. Performance tests show about 5000 authentications per minute (8 cores). With half of the threads, the number will be halved as well. Assuming a 25K clients (50K keys) use case, it will take 20 min for all keys to be cached. Reducing the number of threads too much would push the warm up time even higher. Therefore using half number of the cores feels like a reasonable middle ground.\nHashing in the generic thread pool (which uses all cores) does not have obvious performance hit - I tried simply pushing the hashing to the generic thread pool, which then used all cores for the hashing. I didn't observe any obivious performance issue with it. In fact, the initial warm up stage is smoother and has a better throughput than using the GET thread pool. Therefore it feels that using half of the cores should be relatively safe and also performant. I do plan to run a few more rounds of performance tests after all scheduled v7.9 API key improvements. So we can be confident on this.\nThe new thread pool will be shared by all security related expensive operations - currently its only usage is for hashing of API key auth, so it is not a very good reason. But it could soon see another use case: the API key creation also requires expensive hashing which currently runs in the transport_worker thread. I need to do some more investigation, but the result is very likely that we need move it to this new thread pool as well.", "author": "ywangd", "createdAt": "2020-06-24T13:12:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM0ODYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY4NzIwNw==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r445687207", "bodyText": "My thoughts  for approving the PR were that we operate under some desired rough approximation for the rate of authentication using keys (what Yang is describing on the second point above) and so by switching to a new pool (given that the get operation is so much faster than the hash, and that the new pool is smaller than the get pool) all the threads in the new pool will be busy at peak rate, so that we can estimate that peak rate (assuming a relatively tranquil system where the pool threads stay running). The original peak rate (using the get pool) was noisy because any get requests in the system interfered with it (in addition to the obvious flip side that authn hashing interfered with get requests in the system).\nWhen the system is busy and all threads are working at the pool queues and no queue is empty, it all boils down to the processors' queue. In a sense all thread pool queues \"merge\" into processor queues, with the priority given by the relative number of threads ascribed to each pool. So introducing a new pool will decrease the throughput of existing pools, proportionate to relative sizes, in exchange of a guaranteed minimum throughput on the new pool ,because the new queue is not populated with any other types of work (compared to reusing an existing pool that contains other work types).\nTo summarise, I would generally introduce a thread pool when I want more control over the rate of some work (both the minimum and the maximum rate).\nThat's my thought process about thread pool queues upon which I've approved the PR. I believe a new thread pool is the right decision, but I concede that we've informed the sizing decision on rough external authn rates without also consulting with folks that tune the existing thread pools.", "author": "albertzaharovits", "createdAt": "2020-06-25T16:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM0ODYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODcxMzkxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r448713919", "bodyText": "Okay, thanks for the great explanations to help me understand the perspective here. One more question: is it enough to have a simple \"security\" thread pool? Do we need a token and a crypto thread pool and maybe another thread pool for other security aspects in the future?", "author": "jasontedor", "createdAt": "2020-07-02T02:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM0ODYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyMzk0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r449023945", "bodyText": "TL;DR: We are not considering another thread pool for other security aspects.\nOur intention for the new thread pool is to focus on \"cpu-intensive\" security computations, namely hashing and encryption, especially in the scope of authentication. Given their expensiveness and importance, we'd like to control their impact both ways: they should not take over all system resources but in the mean time should maintain a reasonable level of throughput. We use following criteria to justify whether an operation should be added to this pool:\n\nIs it expensive? The standard here is somewhat subjective. Based on performance tests, I personally would eye on anything longer than 1 ms.\nIs it authentication/authorization related? We'd like to prioritize these operations since they usually need to complete in a timely manner.\nDoes it need to scale? i.e. potential burst in volume? When there is a large increase in concurrency, we'd like to protect the system from being completely flooded.\n\nWith above criteria, we can come up with the followings:\n\nHashing for uncached results are great candidates. These include API Key auth (current PR, v7.9), API Key creation (v7.9?), tokens, username/password (planned, v7.10)\nSigning and cryption for SAML assertions and odic claims are potential candidates (pending further performance check)\nHashing for cached result is not qualified for the new thread pool since it is fast (sha256, ~3 microseconds).\nManipulations of security documents are not qualified either\nEncrypted snapshot, though potentially expensive, is not auth related and unlikely needs to scale. Hence it is also not qualified.\nAn interesting case is read/write of the security index. When the index is not on the local node, these operations can be expensive (above 1 ms) and it also matches the two other criteria. However the system indices work (#57936) is supposed to cover it. Hence we are not considering it either.\nAny other security aspects that are not qualified\n\nNow the question is: whether above unqualified security operations worth to have their own separate thread pool?\nWhen security is enabled, security related operations are ubiquitous, e.g. every request needs to go through authentication and authorization flow. Currently our general practice is to \"just let them run in the same thread\", which could be get, transport_worker etc. This strategy has served us reasonally well so far. But with the upcoming change to expose the service to unprecedented large number of clients, we started noticing some issues revealed by the performance tests, which in turn leads to this PR and a few other work in the pipeline. At this stage, based on what we know, we still believe the existing strategy works fine for security operations that are not qualified for the new thread pool. Hence we do not plan to add another one.\nFor the sake of completeness, there are exceptions to the existing strategy. Outbound LDAP calls are submitted via the generic pool to avoid risks of deadlocking if they are submitted via the same pool used by the outbound requests. There is no sign for this being an issue so far. We had brief discussion about it and decided to evaluate it more closely at a later time.", "author": "ywangd", "createdAt": "2020-07-02T14:01:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM0ODYxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE4NTA0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r442185046", "bodyText": "This is not how the EsThreadPoolExecutor handles over-capacity. The test below as well.", "author": "albertzaharovits", "createdAt": "2020-06-18T12:22:59Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "diffHunk": "@@ -602,6 +610,83 @@ public void testWillGetLookedUpByRealmTypeIfExists() {\n         assertEquals(\"looked_up_by_type\", ApiKeyService.getCreatorRealmType(authentication));\n     }\n \n+    public void testAuthWillTerminateIfGetThreadPoolIsSaturated() throws ExecutionException, InterruptedException {\n+        final String apiKey = randomAlphaOfLength(16);\n+        final ApiKeyCredentials creds = new ApiKeyCredentials(randomAlphaOfLength(12), new SecureString(apiKey.toCharArray()));\n+        writeCredentialsToThreadContext(creds);\n+        SecurityMocks.mockGetRequestException(client, new EsRejectedExecutionException(\"rejected\"));\n+        ApiKeyService service = createApiKeyService(Settings.EMPTY);\n+        final PlainActionFuture<AuthenticationResult> future = new PlainActionFuture<>();\n+        service.authenticateWithApiKeyIfPresent(threadPool.getThreadContext(), future);\n+        final AuthenticationResult authenticationResult = future.get();\n+        assertEquals(AuthenticationResult.Status.TERMINATE, authenticationResult.getStatus());\n+        assertThat(authenticationResult.getMessage(), containsString(\"server is too busy to respond\"));\n+    }\n+\n+    public void testAuthWillTerminateIfHashingThreadPoolIsSaturated() throws IOException, ExecutionException, InterruptedException {\n+        final String apiKey = randomAlphaOfLength(16);\n+        final ApiKeyCredentials creds = new ApiKeyCredentials(randomAlphaOfLength(12), new SecureString(apiKey.toCharArray()));\n+        writeCredentialsToThreadContext(creds);\n+\n+        Hasher hasher = randomFrom(Hasher.PBKDF2, Hasher.BCRYPT4, Hasher.BCRYPT);\n+        final char[] hash = hasher.hash(new SecureString(apiKey.toCharArray()));\n+        Map<String, Object> sourceMap = buildApiKeySourceDoc(hash);\n+        mockSourceDocument(creds.getId(), sourceMap);\n+        final ExecutorService mockExecutorService = mock(ExecutorService.class);\n+        when(threadPool.executor(ApiKeyService.THREAD_POOL_NAME)).thenReturn(mockExecutorService);\n+        Mockito.doThrow(new EsRejectedExecutionException(\"rejected\")).when(mockExecutorService).execute(any(Runnable.class));", "originalCommit": "770b2467c297e2634448f77983870b5ece258889", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg4MTEzOA==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r443881138", "bodyText": "Thanks for the great attention to details! \ud83d\udc4d  It's now corrected.", "author": "ywangd", "createdAt": "2020-06-22T23:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE4NTA0Ng=="}], "type": "inlineReview"}, {"oid": "4c1c27f6103fec620a267c0b89899457fda807ed", "url": "https://github.com/elastic/elasticsearch/commit/4c1c27f6103fec620a267c0b89899457fda807ed", "message": "Address feedback", "committedDate": "2020-06-22T23:36:11Z", "type": "commit"}, {"oid": "06baa99c601c6592f6ea243e787233ff908193e0", "url": "https://github.com/elastic/elasticsearch/commit/06baa99c601c6592f6ea243e787233ff908193e0", "message": "Merge remote-tracking branch 'origin/master' into es-58088-hashing-thread-pool", "committedDate": "2020-06-22T23:36:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5ODczMg==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r444598732", "bodyText": "I think we should name this thread pool in a more generic way to reflect the intent that it be used for all password hashing.\nSomething like security-password-hash feels better to me than security-api-key", "author": "tvernum", "createdAt": "2020-06-24T01:46:56Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/Security.java", "diffHunk": "@@ -992,9 +993,14 @@ public AsyncSender interceptSender(AsyncSender sender) {\n     @Override\n     public List<ExecutorBuilder<?>> getExecutorBuilders(final Settings settings) {\n         if (enabled) {\n-            return Collections.singletonList(\n-                    new FixedExecutorBuilder(settings, TokenService.THREAD_POOL_NAME, 1, 1000, \"xpack.security.authc.token.thread_pool\",\n-                        false));\n+            final int allocatedProcessors = EsExecutors.allocatedProcessors(settings);\n+            return List.of(\n+                new FixedExecutorBuilder(settings, TokenService.THREAD_POOL_NAME, 1, 1000,\n+                    \"xpack.security.authc.token.thread_pool\", false),\n+                new FixedExecutorBuilder(settings, ApiKeyService.THREAD_POOL_NAME,", "originalCommit": "06baa99c601c6592f6ea243e787233ff908193e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgwNTc1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r446805759", "bodyText": "As discussed, renamed it to security-crypto.", "author": "ywangd", "createdAt": "2020-06-29T06:46:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5ODczMg=="}], "type": "inlineReview"}, {"oid": "57ec11fea59945c7cc5f150578a3a7bb55a1d2ce", "url": "https://github.com/elastic/elasticsearch/commit/57ec11fea59945c7cc5f150578a3a7bb55a1d2ce", "message": "Address feedback to add 429 status code test", "committedDate": "2020-06-29T06:45:59Z", "type": "commit"}, {"oid": "39ed0ed44f896d41b907037f97c7eb7cb81e01d1", "url": "https://github.com/elastic/elasticsearch/commit/39ed0ed44f896d41b907037f97c7eb7cb81e01d1", "message": "Merge remote-tracking branch 'origin/master' into es-58088-hashing-thread-pool", "committedDate": "2020-06-29T06:46:06Z", "type": "commit"}, {"oid": "c71e2d45ab114142e26f98d5f176e7190778ff01", "url": "https://github.com/elastic/elasticsearch/commit/c71e2d45ab114142e26f98d5f176e7190778ff01", "message": "CheckStyle", "committedDate": "2020-06-29T06:51:52Z", "type": "commit"}, {"oid": "8c4e560389a906fa8ff5dff87a40adadb5470199", "url": "https://github.com/elastic/elasticsearch/commit/8c4e560389a906fa8ff5dff87a40adadb5470199", "message": "checkstyle", "committedDate": "2020-06-29T08:15:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM0Mzk1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r449343957", "bodyText": "This 1000 is based on the SECURITY_CRYPTO_THREAD_POOL_NAME queue size, correct?\nCan we extract it to a variable so that its meaning is clear?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    IntStream.range(0, 1000).forEach(i -> executorService.submit(() -> {}));\n          \n          \n            \n                    // Fill the whole queue for the crypto thread pool\n          \n          \n            \n                    final int queueSize = 1000;\n          \n          \n            \n                    IntStream.range(0, queueSize).forEach(i -> executorService.submit(() -> {}));", "author": "tvernum", "createdAt": "2020-07-03T02:18:33Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java", "diffHunk": "@@ -823,6 +833,60 @@ public void testDerivedKeys() throws ExecutionException, InterruptedException {\n         assertApiKeyNotCreated(client, \"key-5\");\n     }\n \n+    public void testAuthenticationReturns429WhenThreadPoolIsSaturated() throws IOException, InterruptedException {\n+        final String nodeName = randomFrom(internalCluster().getNodeNames());\n+        final Settings settings = internalCluster().getInstance(Settings.class, nodeName);\n+        final ThreadPool threadPool = internalCluster().getInstance(ThreadPool.class, nodeName);\n+\n+        final RoleDescriptor descriptor = new RoleDescriptor(\"auth_only\", new String[] { }, null, null);\n+        final Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\",\n+            UsernamePasswordToken.basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER,\n+                SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        final CreateApiKeyResponse createApiKeyResponse = new CreateApiKeyRequestBuilder(client)\n+            .setName(\"auth only key\")\n+            .setRoleDescriptors(Collections.singletonList(descriptor))\n+            .get();\n+\n+        assertNotNull(createApiKeyResponse.getId());\n+        assertNotNull(createApiKeyResponse.getKey());\n+\n+        final List<NodeInfo> nodeInfos = client().admin().cluster().prepareNodesInfo().get().getNodes().stream()\n+            .filter(nodeInfo -> nodeInfo.getNode().getName().equals(nodeName))\n+            .collect(Collectors.toList());\n+\n+        final ExecutorService executorService = threadPool.executor(SECURITY_CRYPTO_THREAD_POOL_NAME);\n+        final int allocatedProcessors = EsExecutors.allocatedProcessors(settings);\n+        final int numberOfThreads = (allocatedProcessors + 1) / 2;\n+        final CountDownLatch blockingLatch = new CountDownLatch(1);\n+        final CountDownLatch readyLatch = new CountDownLatch(numberOfThreads);\n+\n+        for (int i = 0; i < numberOfThreads; i++) {\n+            executorService.submit(() -> {\n+                readyLatch.countDown();\n+                try {\n+                    blockingLatch.await();\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+        }\n+        IntStream.range(0, 1000).forEach(i -> executorService.submit(() -> {}));", "originalCommit": "8c4e560389a906fa8ff5dff87a40adadb5470199", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM0NDI5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/58090#discussion_r449344293", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        assertThat(responseException.getMessage(), containsString(\"429 Too Many Requests\"));\n          \n          \n            \n                        assertThat(responseException.getMessage(), containsString(\"429 Too Many Requests\"));\n          \n          \n            \n                        assertThat(responseException.getResponse().getStatusLine().getStatusCode(), is(429));", "author": "tvernum", "createdAt": "2020-07-03T02:19:55Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java", "diffHunk": "@@ -823,6 +833,60 @@ public void testDerivedKeys() throws ExecutionException, InterruptedException {\n         assertApiKeyNotCreated(client, \"key-5\");\n     }\n \n+    public void testAuthenticationReturns429WhenThreadPoolIsSaturated() throws IOException, InterruptedException {\n+        final String nodeName = randomFrom(internalCluster().getNodeNames());\n+        final Settings settings = internalCluster().getInstance(Settings.class, nodeName);\n+        final ThreadPool threadPool = internalCluster().getInstance(ThreadPool.class, nodeName);\n+\n+        final RoleDescriptor descriptor = new RoleDescriptor(\"auth_only\", new String[] { }, null, null);\n+        final Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\",\n+            UsernamePasswordToken.basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER,\n+                SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        final CreateApiKeyResponse createApiKeyResponse = new CreateApiKeyRequestBuilder(client)\n+            .setName(\"auth only key\")\n+            .setRoleDescriptors(Collections.singletonList(descriptor))\n+            .get();\n+\n+        assertNotNull(createApiKeyResponse.getId());\n+        assertNotNull(createApiKeyResponse.getKey());\n+\n+        final List<NodeInfo> nodeInfos = client().admin().cluster().prepareNodesInfo().get().getNodes().stream()\n+            .filter(nodeInfo -> nodeInfo.getNode().getName().equals(nodeName))\n+            .collect(Collectors.toList());\n+\n+        final ExecutorService executorService = threadPool.executor(SECURITY_CRYPTO_THREAD_POOL_NAME);\n+        final int allocatedProcessors = EsExecutors.allocatedProcessors(settings);\n+        final int numberOfThreads = (allocatedProcessors + 1) / 2;\n+        final CountDownLatch blockingLatch = new CountDownLatch(1);\n+        final CountDownLatch readyLatch = new CountDownLatch(numberOfThreads);\n+\n+        for (int i = 0; i < numberOfThreads; i++) {\n+            executorService.submit(() -> {\n+                readyLatch.countDown();\n+                try {\n+                    blockingLatch.await();\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+        }\n+        IntStream.range(0, 1000).forEach(i -> executorService.submit(() -> {}));\n+        readyLatch.await();\n+\n+        try (RestClient restClient = createRestClient(nodeInfos, null, \"http\")) {\n+            final String base64ApiKeyKeyValue = Base64.getEncoder().encodeToString(\n+                (createApiKeyResponse.getId() + \":\" + createApiKeyResponse.getKey().toString()).getBytes(StandardCharsets.UTF_8));\n+\n+            final Request authRequest = new Request(\"GET\", \"_security/_authenticate\");\n+            authRequest.setOptions(RequestOptions.DEFAULT.toBuilder().addHeader(\n+                \"Authorization\", \"ApiKey \" + base64ApiKeyKeyValue).build());\n+            final ResponseException responseException = expectThrows(ResponseException.class, () -> restClient.performRequest(authRequest));\n+            assertThat(responseException.getMessage(), containsString(\"429 Too Many Requests\"));", "originalCommit": "8c4e560389a906fa8ff5dff87a40adadb5470199", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d44caad09375fd78afa3814d7e89a28e040b6620", "url": "https://github.com/elastic/elasticsearch/commit/d44caad09375fd78afa3814d7e89a28e040b6620", "message": "Apply suggestions from code review\n\nCo-authored-by: Tim Vernum <tim@adjective.org>", "committedDate": "2020-07-03T04:39:53Z", "type": "commit"}, {"oid": "99a8fafeabb66030ce6b18927e656dcef8e3e643", "url": "https://github.com/elastic/elasticsearch/commit/99a8fafeabb66030ce6b18927e656dcef8e3e643", "message": "Merge remote-tracking branch 'origin/master' into es-58088-hashing-thread-pool", "committedDate": "2020-07-03T05:13:27Z", "type": "commit"}, {"oid": "867a35bb95a49a5bd6a7a45c78ccff30fca28ab4", "url": "https://github.com/elastic/elasticsearch/commit/867a35bb95a49a5bd6a7a45c78ccff30fca28ab4", "message": "Merge remote-tracking branch 'origin/master' into es-58088-hashing-thread-pool", "committedDate": "2020-07-03T06:51:54Z", "type": "commit"}, {"oid": "1f71f47e7dee3f404568cb499dacec4f38bf94c9", "url": "https://github.com/elastic/elasticsearch/commit/1f71f47e7dee3f404568cb499dacec4f38bf94c9", "message": "Merge remote-tracking branch 'origin/master' into es-58088-hashing-thread-pool", "committedDate": "2020-07-06T04:23:44Z", "type": "commit"}]}