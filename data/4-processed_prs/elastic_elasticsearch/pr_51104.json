{"pr_number": 51104, "pr_title": "Refactor ForEachProcessor to use iteration instead of recursion", "pr_createdAt": "2020-01-16T14:34:58Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51104", "timeline": [{"oid": "6ecd379cd3b1484ecc42f9efbac5857f511d81a6", "url": "https://github.com/elastic/elasticsearch/commit/6ecd379cd3b1484ecc42f9efbac5857f511d81a6", "message": "Refactor ForEachProcessor to use iteration instead of recursion\n\nThis change makes ForEachProcessor iterative and still non-blocking.\nIn case of non-async processors we use single for loop and no recursion at all.\nIn case of async processors we continue work on either current thread or thread\nstarted by downstream processor, whichever is slower (usually processor thread).\nEverything is synchronised by single atomic variable.\n\nRelates #50514", "committedDate": "2020-01-16T11:57:16Z", "type": "commit"}, {"oid": "0d9276d5a4dd868fefa90a071f572920c3cf4535", "url": "https://github.com/elastic/elasticsearch/commit/0d9276d5a4dd868fefa90a071f572920c3cf4535", "message": "Unused imports removed", "committedDate": "2020-01-16T15:02:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUzODY3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51104#discussion_r367538679", "bodyText": "I like this approach. In the case of inner processor going async; whichever thread sets this atomic boolean last should continue with the next value.\nAnd in the case inner processor doesn't go async then on the second getAndSet(...) the current thread continues with the next value.\nI do wonder if this variable can be renamed to describe this beter.", "author": "martijnvg", "createdAt": "2020-01-16T17:00:57Z", "path": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/ForEachProcessor.java", "diffHunk": "@@ -79,41 +76,35 @@ public void execute(IngestDocument ingestDocument, BiConsumer<IngestDocument, Ex\n                 handler.accept(null, new IllegalArgumentException(\"field [\" + field + \"] is null, cannot loop over its elements.\"));\n             }\n         } else {\n-            List<Object> newValues = new CopyOnWriteArrayList<>();\n-            innerExecute(0, values, newValues, ingestDocument, handler);\n+            innerExecute(0, values, Collections.synchronizedList(new ArrayList<>(values.size())), ingestDocument, handler);\n         }\n     }\n \n     void innerExecute(int index, List<?> values, List<Object> newValues, IngestDocument document,\n                       BiConsumer<IngestDocument, Exception> handler) {\n+        for (; index < values.size(); index++) {\n+            AtomicBoolean shouldContinueHere = new AtomicBoolean();", "originalCommit": "0d9276d5a4dd868fefa90a071f572920c3cf4535", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg1MDIzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/51104#discussion_r367850231", "bodyText": "I wonder about this scenario:\n\nThe current thread sets shouldContinueHere first.\nNext value is handled  and also manages to set shouldContinueHere first.\nBoth async call manage to return and update newValues simultaneously.\n\nIs this scenario possible? And if so should have protection against this?", "author": "martijnvg", "createdAt": "2020-01-17T09:50:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUzODY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4MjM3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51104#discussion_r368082377", "bodyText": "If current thread hits shouldContinueHere first, then it sees false and ends the loop (returns).\nIf it hits it second that means it's after async call already finished and other thread updated newValues already.\nAs you mentioned in first comment only thread that checks shouldContinueHere last actually proceeds\nDoes it answer your question or did I misunderstand the scenario?", "author": "probakowski", "createdAt": "2020-01-17T18:47:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUzODY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODExOTAxOA==", "url": "https://github.com/elastic/elasticsearch/pull/51104#discussion_r368119018", "bodyText": "Thanks for clarifying. I misinterpreted the if statement on line 98 when looking at it this morning.\nIt is not possible that multiple values from the list are handled concurrently.", "author": "martijnvg", "createdAt": "2020-01-17T20:18:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUzODY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUzOTI2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51104#discussion_r367539263", "bodyText": "In this case recursion does happen, but we're not risking a SO here, because it always a different thread would get here.", "author": "martijnvg", "createdAt": "2020-01-16T17:02:09Z", "path": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/ForEachProcessor.java", "diffHunk": "@@ -79,41 +76,35 @@ public void execute(IngestDocument ingestDocument, BiConsumer<IngestDocument, Ex\n                 handler.accept(null, new IllegalArgumentException(\"field [\" + field + \"] is null, cannot loop over its elements.\"));\n             }\n         } else {\n-            List<Object> newValues = new CopyOnWriteArrayList<>();\n-            innerExecute(0, values, newValues, ingestDocument, handler);\n+            innerExecute(0, values, Collections.synchronizedList(new ArrayList<>(values.size())), ingestDocument, handler);\n         }\n     }\n \n     void innerExecute(int index, List<?> values, List<Object> newValues, IngestDocument document,\n                       BiConsumer<IngestDocument, Exception> handler) {\n+        for (; index < values.size(); index++) {\n+            AtomicBoolean shouldContinueHere = new AtomicBoolean();\n+            Object value = values.get(index);\n+            Object previousValue = document.getIngestMetadata().put(\"_value\", value);\n+            int nextIndex = index + 1;\n+            processor.execute(document, (result, e) -> {\n+                newValues.add(document.getIngestMetadata().put(\"_value\", previousValue));\n+                if (e != null || result == null) {\n+                    handler.accept(result, e);\n+                } else if (shouldContinueHere.getAndSet(true)) {\n+                    innerExecute(nextIndex, values, newValues, document, handler);", "originalCommit": "0d9276d5a4dd868fefa90a071f572920c3cf4535", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "089fca096833c79cfc442e0e4cd81babb555d204", "url": "https://github.com/elastic/elasticsearch/commit/089fca096833c79cfc442e0e4cd81babb555d204", "message": "Removed unnecessary synchronization, tests refactorings", "committedDate": "2020-01-16T20:28:26Z", "type": "commit"}, {"oid": "03b0ab63c96e8ae783e0463c4554f6d4fdfed17c", "url": "https://github.com/elastic/elasticsearch/commit/03b0ab63c96e8ae783e0463c4554f6d4fdfed17c", "message": "Unused import removed", "committedDate": "2020-01-16T20:39:09Z", "type": "commit"}, {"oid": "bf8fdc201bf3497005cf291da1b40848f96c3a65", "url": "https://github.com/elastic/elasticsearch/commit/bf8fdc201bf3497005cf291da1b40848f96c3a65", "message": "Unused import removed", "committedDate": "2020-01-16T20:53:36Z", "type": "commit"}]}