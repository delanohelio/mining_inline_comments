{"pr_number": 58413, "pr_title": "[ML] Fix wire serialization for flush acknowledgements", "pr_createdAt": "2020-06-23T09:28:35Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58413", "timeline": [{"oid": "c90c99050b45292f8c6f665331b53795578f642f", "url": "https://github.com/elastic/elasticsearch/commit/c90c99050b45292f8c6f665331b53795578f642f", "message": "[ML] Fix wire serialization for flush acknowledgements\n\nThere was a discrepancy in the implementation of flush\nacknowledgements: most of the class was designed on the\nbasis that the \"last finalized bucket time\" could be null\nbut the wire serialization assumed that it was never\nnull.  This works because, the C++ sends zero \"last\nfinalized bucket time\" when it is not known or not\nrelevant.  But then the Java code will print that to\nXContent as it is assuming null represents not known or\nnot relevant.\n\nThis change corrects the discrepancies.  Internally within\nthe class null represents not known or not relevant, but\nthis is translated from/to 0 for communications from the\nC++ and old nodes that have the bug.\n\nAdditionally I switched from Date to Instant for this\nclass and made the member variables final to modernise it\na bit.", "committedDate": "2020-06-23T09:24:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEyMzg0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/58413#discussion_r444123843", "bodyText": "Could you re-use the same pattern as in FlushJobAction.Response here?\n            this.lastFinalizedBucketEnd =\n                (lastFinalizedBucketEnd != null) ? Instant.ofEpochMilli(lastFinalizedBucketEnd.toEpochMilli()) : null;", "author": "przemekwitek", "createdAt": "2020-06-23T10:29:08Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/process/autodetect/output/FlushAcknowledgement.java", "diffHunk": "@@ -31,39 +32,54 @@\n     public static final ParseField LAST_FINALIZED_BUCKET_END = new ParseField(\"last_finalized_bucket_end\");\n \n     public static final ConstructingObjectParser<FlushAcknowledgement, Void> PARSER = new ConstructingObjectParser<>(\n-            TYPE.getPreferredName(), a -> new FlushAcknowledgement((String) a[0], (Date) a[1]));\n+            TYPE.getPreferredName(), a -> new FlushAcknowledgement((String) a[0], (Instant) a[1]));\n \n     static {\n         PARSER.declareString(ConstructingObjectParser.constructorArg(), ID);\n         PARSER.declareField(ConstructingObjectParser.optionalConstructorArg(),\n-                p -> TimeUtils.parseTimeField(p, LAST_FINALIZED_BUCKET_END.getPreferredName()),\n+                p -> TimeUtils.parseTimeFieldToInstant(p, LAST_FINALIZED_BUCKET_END.getPreferredName()),\n                 LAST_FINALIZED_BUCKET_END, ObjectParser.ValueType.VALUE);\n     }\n \n-    private String id;\n-    private Date lastFinalizedBucketEnd;\n+    private final String id;\n+    private final Instant lastFinalizedBucketEnd;\n \n-    public FlushAcknowledgement(String id, Date lastFinalizedBucketEnd) {\n+    public FlushAcknowledgement(String id, Instant lastFinalizedBucketEnd) {\n         this.id = id;\n-        this.lastFinalizedBucketEnd = lastFinalizedBucketEnd;\n+        // The C++ passes 0 when last finalized bucket end is not available\n+        long epochMillis = (lastFinalizedBucketEnd != null) ? lastFinalizedBucketEnd.toEpochMilli() : 0;", "originalCommit": "c90c99050b45292f8c6f665331b53795578f642f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEzNDgzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/58413#discussion_r444134835", "bodyText": "It's slightly different as this one can be parsing output from the C++, which writes 0 instead of null.  So this one needs to convert 0 to null.", "author": "droberts195", "createdAt": "2020-06-23T10:50:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEyMzg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEzNDQzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/58413#discussion_r444134431", "bodyText": "nit: Is the autodetect output an epoch number or a string? If it is a long it seems a bit silly to parse it as an Instant (Date previously) then convert back to a long then back to an Instant.", "author": "davidkyle", "createdAt": "2020-06-23T10:49:44Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/process/autodetect/output/FlushAcknowledgement.java", "diffHunk": "@@ -31,39 +32,54 @@\n     public static final ParseField LAST_FINALIZED_BUCKET_END = new ParseField(\"last_finalized_bucket_end\");\n \n     public static final ConstructingObjectParser<FlushAcknowledgement, Void> PARSER = new ConstructingObjectParser<>(\n-            TYPE.getPreferredName(), a -> new FlushAcknowledgement((String) a[0], (Date) a[1]));\n+            TYPE.getPreferredName(), a -> new FlushAcknowledgement((String) a[0], (Instant) a[1]));\n \n     static {\n         PARSER.declareString(ConstructingObjectParser.constructorArg(), ID);\n         PARSER.declareField(ConstructingObjectParser.optionalConstructorArg(),\n-                p -> TimeUtils.parseTimeField(p, LAST_FINALIZED_BUCKET_END.getPreferredName()),\n+                p -> TimeUtils.parseTimeFieldToInstant(p, LAST_FINALIZED_BUCKET_END.getPreferredName()),\n                 LAST_FINALIZED_BUCKET_END, ObjectParser.ValueType.VALUE);\n     }\n \n-    private String id;\n-    private Date lastFinalizedBucketEnd;\n+    private final String id;\n+    private final Instant lastFinalizedBucketEnd;\n \n-    public FlushAcknowledgement(String id, Date lastFinalizedBucketEnd) {\n+    public FlushAcknowledgement(String id, Instant lastFinalizedBucketEnd) {", "originalCommit": "c90c99050b45292f8c6f665331b53795578f642f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEzNjY0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58413#discussion_r444136647", "bodyText": "Good point.  It's written as a long by the C++.  And it's also a long in the XContent representation too, so the round-tripping tests will also work if it's parsed as a long.  I'll change it to do that.", "author": "droberts195", "createdAt": "2020-06-23T10:54:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEzNDQzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE0NjI4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/58413#discussion_r444146282", "bodyText": "Actually, on trying this while just having one constructor it makes the tests a lot less clear, as they'd all have a number as the second argument.\nSo I'll introduce another constructor that takes a Long and use that in the parser but keep the Instant constructor so that tests can use it to make clear that the second argument is a time.", "author": "droberts195", "createdAt": "2020-06-23T11:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEzNDQzMQ=="}], "type": "inlineReview"}, {"oid": "a68c164e37486e44843471959bded3bbc48ea65c", "url": "https://github.com/elastic/elasticsearch/commit/a68c164e37486e44843471959bded3bbc48ea65c", "message": "Address review comments and fix YAML test", "committedDate": "2020-06-23T11:30:58Z", "type": "commit"}, {"oid": "25db594d03d5dc7a9b5c7962731600bdd2599713", "url": "https://github.com/elastic/elasticsearch/commit/25db594d03d5dc7a9b5c7962731600bdd2599713", "message": "Merge branch 'master' into fix_flush_wire_serialization", "committedDate": "2020-06-23T13:17:43Z", "type": "commit"}]}