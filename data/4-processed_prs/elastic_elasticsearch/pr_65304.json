{"pr_number": 65304, "pr_title": "[Transform] Implement latest function for Transform", "pr_createdAt": "2020-11-20T09:20:46Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65304", "timeline": [{"oid": "8f9c85b88863433ed3be46f07d88467217f73ac4", "url": "https://github.com/elastic/elasticsearch/commit/8f9c85b88863433ed3be46f07d88467217f73ac4", "message": "Implement latest_doc function", "committedDate": "2020-11-20T09:49:36Z", "type": "forcePushed"}, {"oid": "cf53f8dd50db46098735b7fcac5f3641a3833325", "url": "https://github.com/elastic/elasticsearch/commit/cf53f8dd50db46098735b7fcac5f3641a3833325", "message": "Implement latest_doc function", "committedDate": "2020-11-23T09:32:31Z", "type": "forcePushed"}, {"oid": "62b199c877200b6314546062a3465504259b924b", "url": "https://github.com/elastic/elasticsearch/commit/62b199c877200b6314546062a3465504259b924b", "message": "Implement latest_doc function", "committedDate": "2020-11-23T10:42:41Z", "type": "forcePushed"}, {"oid": "d9af463d07140982911f4928cf7386ba3b628fb3", "url": "https://github.com/elastic/elasticsearch/commit/d9af463d07140982911f4928cf7386ba3b628fb3", "message": "Implement latest_doc function", "committedDate": "2020-11-23T11:53:02Z", "type": "forcePushed"}, {"oid": "c382ab404d769fc7c07a545e9b24b44b500a28f2", "url": "https://github.com/elastic/elasticsearch/commit/c382ab404d769fc7c07a545e9b24b44b500a28f2", "message": "Implement latest_doc function", "committedDate": "2020-11-23T13:01:12Z", "type": "forcePushed"}, {"oid": "f67ca63c4f2688fcdbf7659ab89dd0ce7151e9da", "url": "https://github.com/elastic/elasticsearch/commit/f67ca63c4f2688fcdbf7659ab89dd0ce7151e9da", "message": "Implement latest_doc function", "committedDate": "2020-11-23T14:49:06Z", "type": "forcePushed"}, {"oid": "e3086b31d6cbf353d3e74029fd29bd739f4e028e", "url": "https://github.com/elastic/elasticsearch/commit/e3086b31d6cbf353d3e74029fd29bd739f4e028e", "message": "Implement latest_doc function", "committedDate": "2020-11-25T06:28:20Z", "type": "forcePushed"}, {"oid": "aa8c507441a4ddaa7f642b1e04d3b58d7de6d2b0", "url": "https://github.com/elastic/elasticsearch/commit/aa8c507441a4ddaa7f642b1e04d3b58d7de6d2b0", "message": "Implement latest_doc function", "committedDate": "2020-11-25T07:15:12Z", "type": "forcePushed"}, {"oid": "31610548bd30cb1b0edd44218a265499f5ad516a", "url": "https://github.com/elastic/elasticsearch/commit/31610548bd30cb1b0edd44218a265499f5ad516a", "message": "Implement latest function", "committedDate": "2020-11-25T07:38:05Z", "type": "forcePushed"}, {"oid": "c2ce81641a8e85f4cd6c18141b468e97ade642c3", "url": "https://github.com/elastic/elasticsearch/commit/c2ce81641a8e85f4cd6c18141b468e97ade642c3", "message": "Implement latest function", "committedDate": "2020-11-25T08:48:37Z", "type": "forcePushed"}, {"oid": "57d8fe809c3d269a0addeae272bb1fe972c464f5", "url": "https://github.com/elastic/elasticsearch/commit/57d8fe809c3d269a0addeae272bb1fe972c464f5", "message": "Implement latest function", "committedDate": "2020-11-25T08:58:56Z", "type": "forcePushed"}, {"oid": "8285d15abaa4bd5e014013557bb02a1ca6de2af3", "url": "https://github.com/elastic/elasticsearch/commit/8285d15abaa4bd5e014013557bb02a1ca6de2af3", "message": "Implement latest function", "committedDate": "2020-11-25T13:35:21Z", "type": "forcePushed"}, {"oid": "2a7ce85fafe7a471c486d9328b05c32390e1e744", "url": "https://github.com/elastic/elasticsearch/commit/2a7ce85fafe7a471c486d9328b05c32390e1e744", "message": "Implement latest function", "committedDate": "2020-11-25T13:54:53Z", "type": "forcePushed"}, {"oid": "bc4727dda72be041ef0830b0e69aa06a47c16aea", "url": "https://github.com/elastic/elasticsearch/commit/bc4727dda72be041ef0830b0e69aa06a47c16aea", "message": "Implement latest function", "committedDate": "2020-11-25T14:26:53Z", "type": "forcePushed"}, {"oid": "588b2f0ebc45876725b472d121c39395e96c6895", "url": "https://github.com/elastic/elasticsearch/commit/588b2f0ebc45876725b472d121c39395e96c6895", "message": "Implement latest function", "committedDate": "2020-11-26T07:12:22Z", "type": "forcePushed"}, {"oid": "1022c4ee85ddc4afb1f0720d14c69a671c050cce", "url": "https://github.com/elastic/elasticsearch/commit/1022c4ee85ddc4afb1f0720d14c69a671c050cce", "message": "Implement latest function", "committedDate": "2020-11-26T07:14:06Z", "type": "forcePushed"}, {"oid": "bc74f3eee61e1a8291143034da04a8256eb6a297", "url": "https://github.com/elastic/elasticsearch/commit/bc74f3eee61e1a8291143034da04a8256eb6a297", "message": "Implement latest function", "committedDate": "2020-11-26T07:23:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg4ODgzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r530888839", "bodyText": "pivot and latest should be mutually exclusive.\nI think in the client we can check and throw in the constructor.", "author": "hendrikmuhs", "createdAt": "2020-11-26T09:30:45Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/transform/transforms/TransformConfig.java", "diffHunk": "@@ -162,6 +184,7 @@ public static TransformConfig forPreview(final SourceConfig source, final PivotC\n         this.frequency = frequency;\n         this.syncConfig = syncConfig;\n         this.pivotConfig = pivotConfig;\n+        this.latestDocConfig = latestDocConfig;", "originalCommit": "bc74f3eee61e1a8291143034da04a8256eb6a297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQyNDEyMg==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r533424122", "bodyText": "Shouldn't we validate on the server-side only and make the client more of a pass-through for anything user provides?\nThere already is a validation for mutually-exclusive functions in org.elasticsearch.xpack.core.transform.transforms.TransformConfig class.", "author": "przemekwitek", "createdAt": "2020-12-01T13:55:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg4ODgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEyNjMxMg==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534126312", "bodyText": "I agree, the validation should be backend only. Especially since the validation would run against a GET and the HLRC needs to be forwards compatible.", "author": "benwtrent", "createdAt": "2020-12-02T12:23:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg4ODgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkwNDM1MA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534904350", "bodyText": "I don't think we will ever support both, but it's ok.", "author": "hendrikmuhs", "createdAt": "2020-12-03T08:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg4ODgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTEzNzIyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535137225", "bodyText": "The other possibility is to pass Function function. That would be the most object-oriented solution. TBH I haven't looked closely what changes would be needed to make this change.\nI think there are some dependencies on the function being pivot so I'll leave that out of this PR as a possible refactoring.", "author": "przemekwitek", "createdAt": "2020-12-03T11:32:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg4ODgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg5NDgxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r530894815", "bodyText": "we haven't decided yet, what we do with missing_bucket. We should bring that up in the design discussion again.\nDefault terms that have no value are omitted, with missing_bucket: true they are returned as null value.\nI wonder if this should be:\n\na per field setting\na setting for all fields together\nnot have a setting but internally default to true\n\nI rule out the option to not have a setting but internally default to false as this seems strange to me.", "author": "hendrikmuhs", "createdAt": "2020-11-26T09:39:42Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/transform/transforms/latest/LatestDocConfig.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.transform.transforms.latest;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+\n+/**\n+ * Class describing how to compute latest doc for every unique key\n+ */\n+public class LatestDocConfig implements ToXContentObject {\n+\n+    private static final ParseField UNIQUE_KEY = new ParseField(\"unique_key\");\n+    private static final ParseField SORT = new ParseField(\"sort\");\n+\n+    private final List<String> uniqueKey;\n+    private final List<SortBuilder<?>> sort;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<LatestDocConfig, Void> PARSER =\n+        new ConstructingObjectParser<>(\n+            \"latest_doc_config\", true, args -> new LatestDocConfig((List<String>) args[0], (List<SortBuilder<?>>) args[1]));\n+\n+    static {\n+        PARSER.declareStringArray(constructorArg(), UNIQUE_KEY);", "originalCommit": "bc74f3eee61e1a8291143034da04a8256eb6a297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkyNjUwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r530926501", "bodyText": "the more I think about it, the more I think we should take option 3 (no setting, default true).", "author": "hendrikmuhs", "createdAt": "2020-11-26T10:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg5NDgxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk2NzcwNg==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r533967706", "bodyText": "Agree.\nOption 3 is the simplest one and gives sensible default.\nIn case users need more customization, we can always introduce per-field setting later.", "author": "przemekwitek", "createdAt": "2020-12-02T08:09:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg5NDgxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE4NTI0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535185249", "bodyText": "the more I think about it, the more I think we should take option 3 (no setting, default true).\n\nDone.", "author": "przemekwitek", "createdAt": "2020-12-03T12:24:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg5NDgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwMzkwMg==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r530903902", "bodyText": "do we support all options? This seems problematic for continuous. Maybe we should start simple and only allow strings? I think however it is a good idea to internally use List<SortBuilder<?>>. If you look at TopHitsAggregationBuilder it contains convenience methods that take a string build the SortBuilder internally. I think that would be good.\nLet's maybe revisit after you have a 1st implementation for continuous and after we know what is possible or not. Maybe its better to reduce the number options.", "author": "hendrikmuhs", "createdAt": "2020-11-26T09:53:18Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/transform/transforms/latest/LatestDocConfig.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.transform.transforms.latest;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+\n+/**\n+ * Class describing how to compute latest doc for every unique key\n+ */\n+public class LatestDocConfig implements ToXContentObject {\n+\n+    private static final ParseField UNIQUE_KEY = new ParseField(\"unique_key\");\n+    private static final ParseField SORT = new ParseField(\"sort\");\n+\n+    private final List<String> uniqueKey;\n+    private final List<SortBuilder<?>> sort;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<LatestDocConfig, Void> PARSER =\n+        new ConstructingObjectParser<>(\n+            \"latest_doc_config\", true, args -> new LatestDocConfig((List<String>) args[0], (List<SortBuilder<?>>) args[1]));\n+\n+    static {\n+        PARSER.declareStringArray(constructorArg(), UNIQUE_KEY);\n+        PARSER.declareField(constructorArg(), (p, c) -> SortBuilder.fromXContent(p), SORT, ObjectParser.ValueType.OBJECT_ARRAY_OR_STRING);\n+    }\n+\n+    public static LatestDocConfig fromXContent(final XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    LatestDocConfig(List<String> uniqueKey, List<SortBuilder<?>> sort) {\n+        this.uniqueKey = uniqueKey;\n+        this.sort = sort;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(UNIQUE_KEY.getPreferredName(), uniqueKey);\n+        builder.field(SORT.getPreferredName(), sort);\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public List<String> getUniqueKey() {\n+        return uniqueKey;\n+    }\n+\n+    public List<SortBuilder<?>> getSort() {\n+        return sort;\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (other == null || getClass() != other.getClass()) {\n+            return false;\n+        }\n+        LatestDocConfig that = (LatestDocConfig) other;\n+        return Objects.equals(this.uniqueKey, that.uniqueKey) && Objects.equals(this.sort, that.sort);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(uniqueKey, sort);\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static class Builder {\n+        private List<String> uniqueKey;\n+        private List<SortBuilder<?>> sort;\n+\n+        /**\n+         * Set how to group the source data\n+         * @param uniqueKey The configuration describing how to group the source data\n+         * @return the {@link Builder} with the interval set.\n+         */\n+        public Builder setUniqueKey(String... uniqueKey) {\n+            return setUniqueKey(Arrays.asList(uniqueKey));\n+        }\n+\n+        public Builder setUniqueKey(List<String> uniqueKey) {\n+            this.uniqueKey = uniqueKey;\n+            return this;\n+        }\n+\n+        public Builder setSort(FieldSortBuilder sort) {", "originalCommit": "bc74f3eee61e1a8291143034da04a8256eb6a297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk3MDU2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r533970561", "bodyText": "do we support all options? This seems problematic for continuous. Maybe we should start simple and only allow strings?\n\nMy intention is to allow strings rather than (in addition to) full sort spec. Let me verify that but IIUC an array of strings will be parsed correctly by this line:\n        PARSER.declareField(constructorArg(), (p, c) -> SortBuilder.fromXContent(p), SORT, ObjectParser.ValueType.OBJECT_ARRAY_OR_STRING);\n\nIn the fullness of time I think we should support both ASC and  DESC as latest could work for any monotonic function (either increasing or decreasing).\nBut in the first version we can prevent that and require that the only sort field is SyncConfig.timestamp and always use order of DESC", "author": "przemekwitek", "createdAt": "2020-12-02T08:14:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwMzkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwNTQxMA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r530905410", "bodyText": "a test for expectThrows if both are given, to test mutual exclusiveness", "author": "hendrikmuhs", "createdAt": "2020-11-26T09:55:25Z", "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/transform/transforms/TransformConfigTests.java", "diffHunk": "@@ -41,13 +44,23 @@\n public class TransformConfigTests extends AbstractXContentTestCase<TransformConfig> {\n \n     public static TransformConfig randomTransformConfig() {\n+        PivotConfig pivotConfig;\n+        LatestDocConfig latestDocConfig;\n+        if (randomBoolean()) {\n+            pivotConfig = PivotConfigTests.randomPivotConfig();\n+            latestDocConfig = null;\n+        } else {\n+            pivotConfig = null;\n+            latestDocConfig = LatestDocConfigTests.randomLatestDocConfig();\n+        }", "originalCommit": "bc74f3eee61e1a8291143034da04a8256eb6a297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQyNTkxNA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r533425914", "bodyText": "Please see my comment in client/rest-high-level/src/main/java/org/elasticsearch/client/transform/transforms/TransformConfig.java.\nIf we decide to validate in the client code, I'll definitely add a test here.", "author": "przemekwitek", "createdAt": "2020-12-01T13:57:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwNTQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwOTExOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r530909119", "bodyText": "same remark: we need to sort out what we do with missing_bucket", "author": "hendrikmuhs", "createdAt": "2020-11-26T10:00:44Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/transform/transforms/latest/LatestDocConfig.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.transform.transforms.latest;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortBuilder;\n+import org.elasticsearch.xpack.core.transform.utils.ExceptionsHelper;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+\n+public class LatestDocConfig implements Writeable, ToXContentObject {\n+\n+    private static final String NAME = \"transform_latest_doc\";\n+\n+    private static final ParseField UNIQUE_KEY = new ParseField(\"unique_key\");\n+    private static final ParseField SORT = new ParseField(\"sort\");", "originalCommit": "bc74f3eee61e1a8291143034da04a8256eb6a297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk2Nzk2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r533967963", "bodyText": "Please see my other comment.", "author": "przemekwitek", "createdAt": "2020-12-02T08:09:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwOTExOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkzNjA4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534936083", "bodyText": "\ud83d\udc4d lets omit missing_bucket but hard code it to true in the implementation of latest", "author": "hendrikmuhs", "createdAt": "2020-12-03T08:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwOTExOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE4MDcyNw==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535180727", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-12-03T12:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwOTExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkxMTAzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r530911031", "bodyText": "there are also test classes for hlrc <-> server and back in the hlrc sub package. Every new class should implement this, although we haven't reached full coverage yet. Adding support for latest should be easy.", "author": "hendrikmuhs", "createdAt": "2020-11-26T10:03:41Z", "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/transform/transforms/latest/LatestDocConfigTests.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.transform.transforms.latest;\n+\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.sort.SortBuilders;\n+import org.elasticsearch.test.AbstractXContentTestCase;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.function.Predicate;\n+\n+public class LatestDocConfigTests extends AbstractXContentTestCase<LatestDocConfig> {", "originalCommit": "bc74f3eee61e1a8291143034da04a8256eb6a297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzMjY5NA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r533432694", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-12-01T14:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkxMTAzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkxNDUwNg==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r530914506", "bodyText": "do we have an idea about this default? I agree that we should have a higher default than pivot.\nshould make this a constant which can be overridden with config.getMaxPageSearchSize()", "author": "hendrikmuhs", "createdAt": "2020-11-26T10:09:07Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/latest/LatestDoc.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.transform.transforms.latest;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.fieldcaps.FieldCapabilitiesAction;\n+import org.elasticsearch.action.fieldcaps.FieldCapabilitiesRequest;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.search.SearchAction;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.aggregations.Aggregation;\n+import org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.elasticsearch.search.aggregations.Aggregations;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregation;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.metrics.TopHits;\n+import org.elasticsearch.search.aggregations.metrics.TopHitsAggregationBuilder;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.core.transform.TransformMessages;\n+import org.elasticsearch.xpack.core.transform.transforms.SourceConfig;\n+import org.elasticsearch.xpack.core.transform.transforms.TransformIndexerStats;\n+import org.elasticsearch.xpack.core.transform.transforms.TransformProgress;\n+import org.elasticsearch.xpack.core.transform.transforms.latest.LatestDocConfig;\n+import org.elasticsearch.xpack.transform.transforms.Function;\n+import org.elasticsearch.xpack.transform.transforms.pivot.SchemaUtil;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.util.function.Predicate.not;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+\n+public class LatestDoc implements Function {\n+\n+    public static final int TEST_QUERY_PAGE_SIZE = 50;\n+\n+    private static final String COMPOSITE_AGGREGATION_NAME = \"_transform\";\n+    private static final String LATEST_AGGREGATION_NAME = \"_latest\";\n+    private static final Logger logger = LogManager.getLogger(LatestDoc.class);\n+\n+    private final LatestDocConfig config;\n+\n+    // objects for re-using\n+    private final CompositeAggregationBuilder cachedCompositeAggregation;\n+\n+    public LatestDoc(LatestDocConfig config) {\n+        if (config.getSort().size() != 1) {\n+            throw new ElasticsearchException(\"sort must specify exactly one sorting field\");\n+        }\n+        this.config = config;\n+        this.cachedCompositeAggregation = createCompositeAggregation(config);\n+    }\n+\n+    private static CompositeAggregationBuilder createCompositeAggregation(LatestDocConfig config) {\n+        assert config.getSort().size() >= 1 && config.getSort().get(0) instanceof FieldSortBuilder;\n+\n+        CompositeAggregationBuilder compositeAggregation;\n+        try (XContentBuilder builder = jsonBuilder()) {\n+            config.toCompositeAggXContent(builder);\n+            XContentParser parser = builder.generator()\n+                .contentType()\n+                .xContent()\n+                .createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, BytesReference.bytes(builder).streamInput());\n+            compositeAggregation = CompositeAggregationBuilder.PARSER.parse(parser, COMPOSITE_AGGREGATION_NAME);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\n+                TransformMessages.getMessage(TransformMessages.TRANSFORM_FAILED_TO_CREATE_COMPOSITE_AGGREGATION, \"latest_doc\"), e);\n+        }\n+        TopHitsAggregationBuilder topHitsAgg = AggregationBuilders.topHits(LATEST_AGGREGATION_NAME).size(1).sort(config.getSort().get(0));\n+        compositeAggregation.subAggregation(topHitsAgg);\n+        return compositeAggregation;\n+    }\n+\n+    @Override\n+    public int getInitialPageSize() {\n+        return 5000;", "originalCommit": "bc74f3eee61e1a8291143034da04a8256eb6a297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk2MTEwMw==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r533961103", "bodyText": "do we have an idea about this default?\n\nTBH 5000 is an arbitrary number, not backed by any experiments.\n\nshould make this a constant which can be overridden with config.getMaxPageSearchSize()\n\nShould I add LatestDoc.getMaxPageSearchSize or maybe move PivotConfig.getMaxPageSearchSize out of pivot (but this requires BWC code...)?", "author": "przemekwitek", "createdAt": "2020-12-02T07:55:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkxNDUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkyMzk0OA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r530923948", "bodyText": "this is used for latest? In this case we should think about moving SchemaUtil out of the pivot package.", "author": "hendrikmuhs", "createdAt": "2020-11-26T10:23:48Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/SchemaUtil.java", "diffHunk": "@@ -265,7 +265,7 @@ private static void getSourceFieldMappings(\n         );\n     }\n \n-    private static Map<String, String> extractFieldMappings(FieldCapabilitiesResponse response) {\n+    public static Map<String, String> extractFieldMappings(FieldCapabilitiesResponse response) {", "originalCommit": "bc74f3eee61e1a8291143034da04a8256eb6a297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ2NjgxNA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r533466814", "bodyText": "this is used for latest?\n\nYes\n\nIn this case we should think about moving SchemaUtil out of the pivot package.\n\nAgree. I need to figure out the best class layout for that. latest only needs this small method and there are dependencies SchemaUtil -> pivot in other methods.", "author": "przemekwitek", "createdAt": "2020-12-01T14:46:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkyMzk0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5OTY5MA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535999690", "bodyText": "I've moved the extractFieldMappings method to common.DocumentConversionUtils class so that it is accessible from both pivot and latest packages.\nThis way there are no more dependencies from latest to pivot.", "author": "przemekwitek", "createdAt": "2020-12-04T10:33:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkyMzk0OA=="}], "type": "inlineReview"}, {"oid": "e288a71e2175f930287b62e1cdaf7ff6ddc12bb2", "url": "https://github.com/elastic/elasticsearch/commit/e288a71e2175f930287b62e1cdaf7ff6ddc12bb2", "message": "Implement change collector for latest function", "committedDate": "2020-12-01T09:51:38Z", "type": "forcePushed"}, {"oid": "a45fbd2358b8b493f323b446a2ff9e56ce2c0c55", "url": "https://github.com/elastic/elasticsearch/commit/a45fbd2358b8b493f323b446a2ff9e56ce2c0c55", "message": "Verify optimization in LatestDocContinuousIT", "committedDate": "2020-12-02T07:47:14Z", "type": "forcePushed"}, {"oid": "87f900d8d94a4be35af6fb91a24b8086f14b44fa", "url": "https://github.com/elastic/elasticsearch/commit/87f900d8d94a4be35af6fb91a24b8086f14b44fa", "message": "Add validations with unit tests", "committedDate": "2020-12-02T11:10:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEyNzg3MA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534127870", "bodyText": "TRANSFORM_CONFIGURATION_NO_TRANSFORM could you rename this message constant? I know the message is probably OK (since it says \"exactly 1\") but the constant name implies something else.", "author": "benwtrent", "createdAt": "2020-12-02T12:26:25Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/transform/transforms/TransformConfig.java", "diffHunk": "@@ -176,11 +183,12 @@ public static String documentId(String transformId) {\n         this.syncConfig = syncConfig;\n         this.setHeaders(headers == null ? Collections.emptyMap() : headers);\n         this.pivotConfig = pivotConfig;\n+        this.latestDocConfig = latestDocConfig;\n         this.description = description;\n         this.settings = settings == null ? new SettingsConfig() : settings;\n \n-        // at least one function must be defined\n-        if (this.pivotConfig == null) {\n+        // exactly one function must be defined\n+        if ((this.pivotConfig == null) == (this.latestDocConfig == null)) {\n             throw new IllegalArgumentException(TransformMessages.TRANSFORM_CONFIGURATION_NO_TRANSFORM);", "originalCommit": "a02238850f4cee7ac1f9e332656abc4304cb066e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE1Nzk3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534157972", "bodyText": "Done (changed to TRANSFORM_CONFIGURATION_BAD_FUNCTION_COUNT).", "author": "przemekwitek", "createdAt": "2020-12-02T13:16:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEyNzg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEyOTM0OA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534129348", "bodyText": "Is there a chance that an API caller would see this?\nIf so, we definitely need to adjust this from FieldSortBuilder to something API friendly.", "author": "benwtrent", "createdAt": "2020-12-02T12:28:54Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/transform/transforms/latest/LatestDocConfig.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.transform.transforms.latest;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortBuilder;\n+import org.elasticsearch.xpack.core.transform.utils.ExceptionsHelper;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+\n+public class LatestDocConfig implements Writeable, ToXContentObject {\n+\n+    private static final String NAME = \"transform_latest_doc\";\n+\n+    private static final ParseField UNIQUE_KEY = new ParseField(\"unique_key\");\n+    private static final ParseField SORT = new ParseField(\"sort\");\n+\n+    private final List<String> uniqueKey;\n+    private final List<SortBuilder<?>> sort;\n+\n+    private static final ConstructingObjectParser<LatestDocConfig, Void> STRICT_PARSER = createParser(false);\n+    private static final ConstructingObjectParser<LatestDocConfig, Void> LENIENT_PARSER = createParser(true);\n+\n+    private static ConstructingObjectParser<LatestDocConfig, Void> createParser(boolean lenient) {\n+        ConstructingObjectParser<LatestDocConfig, Void> parser =\n+            new ConstructingObjectParser<>(\n+                NAME, lenient, args -> new LatestDocConfig((List<String>) args[0], (List<SortBuilder<?>>) args[1]));\n+\n+        parser.declareStringArray(constructorArg(), UNIQUE_KEY);\n+        parser.declareField(constructorArg(), (p, c) -> SortBuilder.fromXContent(p), SORT, ObjectParser.ValueType.OBJECT_ARRAY_OR_STRING);\n+\n+        return parser;\n+    }\n+\n+    public static LatestDocConfig fromXContent(final XContentParser parser, boolean lenient) throws IOException {\n+        return lenient ? LENIENT_PARSER.apply(parser, null) : STRICT_PARSER.apply(parser, null);\n+    }\n+\n+    public LatestDocConfig(List<String> uniqueKey, List<SortBuilder<?>> sort) {\n+        this.uniqueKey = ExceptionsHelper.requireNonNull(uniqueKey, UNIQUE_KEY.getPreferredName());\n+        this.sort = ExceptionsHelper.requireNonNull(sort, SORT.getPreferredName());\n+    }\n+\n+    public LatestDocConfig(StreamInput in) throws IOException {\n+        this.uniqueKey = in.readStringList();\n+        this.sort = in.readList(FieldSortBuilder::new);\n+    }\n+\n+    public List<String> getUniqueKey() {\n+        return uniqueKey;\n+    }\n+\n+    public List<SortBuilder<?>> getSort() {\n+        return sort;\n+    }\n+\n+    public ActionRequestValidationException validate(ActionRequestValidationException validationException) {\n+        if (uniqueKey.isEmpty()) {\n+            validationException = addValidationError(\"latest_doc.unique_key must be non-empty\", validationException);\n+        } else {\n+            for (int i = 0; i < uniqueKey.size(); ++i) {\n+                if (Strings.isNullOrEmpty(uniqueKey.get(i))) {\n+                    validationException =\n+                        addValidationError(\"latest_doc.unique_key[\" + i + \"] element must be non-empty\", validationException);\n+                }\n+            }\n+        }\n+\n+        if (sort.size() != 1) {\n+            validationException = addValidationError(\"latest_doc.sort must have exactly one element\", validationException);\n+        } else {\n+            SortBuilder<?> theOnlySort = sort.get(0);\n+            if (theOnlySort instanceof FieldSortBuilder == false) {\n+                validationException =\n+                    addValidationError(\n+                        \"latest_doc.sort[0] must be of type FieldSortBuilder, was: \" + theOnlySort.getClass().getSimpleName(),", "originalCommit": "a02238850f4cee7ac1f9e332656abc4304cb066e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE2NDg5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534164899", "bodyText": "Done.\nThe message will be:\nlatest_doc.sort[0] must be sorting based on a document field, was: _script\n\nif the caller specifies _script sort. Similarly for other sort types.", "author": "przemekwitek", "createdAt": "2020-12-02T13:26:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEyOTM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzMTM0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534131346", "bodyText": "I am not 100% sure about this. Is it valid for a user to have their OWN field that starts with _?", "author": "benwtrent", "createdAt": "2020-12-02T12:32:16Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/common/DocumentConversionUtils.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.transform.transforms.common;\n+\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.transform.TransformField;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Map;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+\n+public class DocumentConversionUtils {\n+\n+    public static IndexRequest convertDocumentToIndexRequest(Map<String, Object> document,\n+                                                             String destinationIndex,\n+                                                             String destinationPipeline) {\n+        String id = (String) document.get(TransformField.DOCUMENT_ID_FIELD);\n+        if (id == null) {\n+            throw new RuntimeException(\"Expected a document id but got null.\");\n+        }\n+\n+        XContentBuilder builder = skipInternalFields(document);\n+        IndexRequest request = new IndexRequest(destinationIndex).source(builder).id(id);\n+        if (destinationPipeline != null) {\n+            request.setPipeline(destinationPipeline);\n+        }\n+        return request;\n+    }\n+\n+    private static XContentBuilder skipInternalFields(Map<String, Object> document) {\n+        XContentBuilder builder;\n+        try {\n+            builder = jsonBuilder();\n+            builder.startObject();\n+            for (Map.Entry<String, ?> value : document.entrySet()) {\n+                // skip all internal fields\n+                if (value.getKey().startsWith(\"_\") == false) {\n+                    builder.field(value.getKey(), value.getValue());\n+                }\n+            }", "originalCommit": "a02238850f4cee7ac1f9e332656abc4304cb066e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAyMjMyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535022329", "bodyText": "_ is supposed to be reserved for internal usage, but I am not sure if we are strict on it everywhere. Might be worth a follow up issue.\nWe could disallow _ prefixes in the transform config, it seems indexing allows _ as long as you do not try to set reserved fields like _index, _source, etc.\nFor aggs it is valid to start with _.\nIt seems e.g. > is invalid for aggs, so it might be better to use >. As its completely internal and not stored anywhere, we can change it without any BWC issues.", "author": "hendrikmuhs", "createdAt": "2020-12-03T09:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzMTM0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE3NDQ4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535174482", "bodyText": "OK, sounds good. I do think we will want to investigate this. It seems weird to not use _ fields if it is possible for valid data to have that prefix.", "author": "benwtrent", "createdAt": "2020-12-03T12:11:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzMTM0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxMjE5NA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r536012194", "bodyText": "I agree, this needs investigation.\nI've added TODO in the DocumentConversionUtils.removeInternalFields method comment (this method now is the only place we filter based on the '_' prefix).", "author": "przemekwitek", "createdAt": "2020-12-04T10:53:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzMTM0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzMjI5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534132295", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.trace(\"Search request: {}\", searchRequest);\n          \n          \n            \n                    logger.trace(() -> new ParameterizedMessage(\"Search request: {}\", searchRequest));", "author": "benwtrent", "createdAt": "2020-12-02T12:34:00Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/latest/LatestDoc.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.transform.transforms.latest;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.fieldcaps.FieldCapabilitiesAction;\n+import org.elasticsearch.action.fieldcaps.FieldCapabilitiesRequest;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.search.SearchAction;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.elasticsearch.search.aggregations.Aggregations;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregation;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.metrics.TopHits;\n+import org.elasticsearch.search.aggregations.metrics.TopHitsAggregationBuilder;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.core.transform.TransformField;\n+import org.elasticsearch.xpack.core.transform.TransformMessages;\n+import org.elasticsearch.xpack.core.transform.transforms.SourceConfig;\n+import org.elasticsearch.xpack.core.transform.transforms.TransformIndexerStats;\n+import org.elasticsearch.xpack.core.transform.transforms.TransformProgress;\n+import org.elasticsearch.xpack.core.transform.transforms.latest.LatestDocConfig;\n+import org.elasticsearch.xpack.transform.transforms.Function;\n+import org.elasticsearch.xpack.transform.transforms.IDGenerator;\n+import org.elasticsearch.xpack.transform.transforms.pivot.SchemaUtil;\n+import org.elasticsearch.xpack.transform.transforms.common.DocumentConversionUtils;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.util.function.Predicate.not;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+\n+public class LatestDoc implements Function {\n+\n+    public static final int DEFAULT_INITIAL_MAX_PAGE_SEARCH_SIZE = 5000;\n+    public static final int TEST_QUERY_PAGE_SIZE = 50;\n+\n+    private static final String COMPOSITE_AGGREGATION_NAME = \"_transform\";\n+    private static final String TOP_HITS_AGGREGATION_NAME = \"_top_hits\";\n+    private static final Logger logger = LogManager.getLogger(LatestDoc.class);\n+\n+    private final LatestDocConfig config;\n+\n+    // objects for re-using\n+    private final CompositeAggregationBuilder cachedCompositeAggregation;\n+\n+    public LatestDoc(LatestDocConfig config) {\n+        this.config = config;\n+        this.cachedCompositeAggregation = createCompositeAggregation(config);\n+    }\n+\n+    private static CompositeAggregationBuilder createCompositeAggregation(LatestDocConfig config) {\n+        assert config.getSort().size() == 1 && config.getSort().get(0) instanceof FieldSortBuilder;\n+\n+        CompositeAggregationBuilder compositeAggregation;\n+        try (XContentBuilder builder = jsonBuilder()) {\n+            config.toCompositeAggXContent(builder);\n+            XContentParser parser = builder.generator()\n+                .contentType()\n+                .xContent()\n+                .createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, BytesReference.bytes(builder).streamInput());\n+            compositeAggregation = CompositeAggregationBuilder.PARSER.parse(parser, COMPOSITE_AGGREGATION_NAME);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\n+                TransformMessages.getMessage(TransformMessages.TRANSFORM_FAILED_TO_CREATE_COMPOSITE_AGGREGATION, \"latest_doc\"), e);\n+        }\n+        TopHitsAggregationBuilder topHitsAgg =\n+            AggregationBuilders.topHits(TOP_HITS_AGGREGATION_NAME)\n+                .size(1)  // we are only interested in the top-1\n+                .sorts(config.getSort());  // we copy the sort config directly from the function config\n+        compositeAggregation.subAggregation(topHitsAgg);\n+        return compositeAggregation;\n+    }\n+\n+    @Override\n+    public int getInitialPageSize() {\n+        return DEFAULT_INITIAL_MAX_PAGE_SEARCH_SIZE;\n+    }\n+\n+    private SearchRequest buildSearchRequest(SourceConfig sourceConfig, Map<String, Object> position, int pageSize) {\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();\n+        buildSearchQuery(sourceBuilder, null, pageSize);\n+        sourceBuilder.query(sourceConfig.getQueryConfig().getQuery());\n+        SearchRequest searchRequest =\n+            new SearchRequest(sourceConfig.getIndex())\n+                .source(sourceBuilder)\n+                .indicesOptions(IndicesOptions.LENIENT_EXPAND_OPEN);\n+        logger.trace(\"Search request: {}\", searchRequest);", "originalCommit": "a02238850f4cee7ac1f9e332656abc4304cb066e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE1Njc4NA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534156784", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-12-02T13:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzMjI5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA0ODQyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535048421", "bodyText": "as a result of my other comment, I wonder if this trace is useless. We have much better logging in the indexer and that's what people should use for debugging a transform problem. This is only called in validation and preview.", "author": "hendrikmuhs", "createdAt": "2020-12-03T10:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzMjI5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE1OTkyNg==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535159926", "bodyText": "I've just removed this trace altogether.", "author": "przemekwitek", "createdAt": "2020-12-03T11:55:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzMjI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzMzYyMg==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534133622", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \"Unexpected status from response of test query: \" + response.status(),\n          \n          \n            \n                                    response.status()\n          \n          \n            \n                                    \"Unexpected status from response of test query: {}\",\n          \n          \n            \n                                    response.status(),\n          \n          \n            \n                                    response.status()\n          \n      \n    \n    \n  \n\nDoesn't this work?", "author": "benwtrent", "createdAt": "2020-12-02T12:36:14Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/latest/LatestDoc.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.transform.transforms.latest;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.fieldcaps.FieldCapabilitiesAction;\n+import org.elasticsearch.action.fieldcaps.FieldCapabilitiesRequest;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.search.SearchAction;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.elasticsearch.search.aggregations.Aggregations;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregation;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.metrics.TopHits;\n+import org.elasticsearch.search.aggregations.metrics.TopHitsAggregationBuilder;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.core.transform.TransformField;\n+import org.elasticsearch.xpack.core.transform.TransformMessages;\n+import org.elasticsearch.xpack.core.transform.transforms.SourceConfig;\n+import org.elasticsearch.xpack.core.transform.transforms.TransformIndexerStats;\n+import org.elasticsearch.xpack.core.transform.transforms.TransformProgress;\n+import org.elasticsearch.xpack.core.transform.transforms.latest.LatestDocConfig;\n+import org.elasticsearch.xpack.transform.transforms.Function;\n+import org.elasticsearch.xpack.transform.transforms.IDGenerator;\n+import org.elasticsearch.xpack.transform.transforms.pivot.SchemaUtil;\n+import org.elasticsearch.xpack.transform.transforms.common.DocumentConversionUtils;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.util.function.Predicate.not;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+\n+public class LatestDoc implements Function {\n+\n+    public static final int DEFAULT_INITIAL_MAX_PAGE_SEARCH_SIZE = 5000;\n+    public static final int TEST_QUERY_PAGE_SIZE = 50;\n+\n+    private static final String COMPOSITE_AGGREGATION_NAME = \"_transform\";\n+    private static final String TOP_HITS_AGGREGATION_NAME = \"_top_hits\";\n+    private static final Logger logger = LogManager.getLogger(LatestDoc.class);\n+\n+    private final LatestDocConfig config;\n+\n+    // objects for re-using\n+    private final CompositeAggregationBuilder cachedCompositeAggregation;\n+\n+    public LatestDoc(LatestDocConfig config) {\n+        this.config = config;\n+        this.cachedCompositeAggregation = createCompositeAggregation(config);\n+    }\n+\n+    private static CompositeAggregationBuilder createCompositeAggregation(LatestDocConfig config) {\n+        assert config.getSort().size() == 1 && config.getSort().get(0) instanceof FieldSortBuilder;\n+\n+        CompositeAggregationBuilder compositeAggregation;\n+        try (XContentBuilder builder = jsonBuilder()) {\n+            config.toCompositeAggXContent(builder);\n+            XContentParser parser = builder.generator()\n+                .contentType()\n+                .xContent()\n+                .createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, BytesReference.bytes(builder).streamInput());\n+            compositeAggregation = CompositeAggregationBuilder.PARSER.parse(parser, COMPOSITE_AGGREGATION_NAME);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\n+                TransformMessages.getMessage(TransformMessages.TRANSFORM_FAILED_TO_CREATE_COMPOSITE_AGGREGATION, \"latest_doc\"), e);\n+        }\n+        TopHitsAggregationBuilder topHitsAgg =\n+            AggregationBuilders.topHits(TOP_HITS_AGGREGATION_NAME)\n+                .size(1)  // we are only interested in the top-1\n+                .sorts(config.getSort());  // we copy the sort config directly from the function config\n+        compositeAggregation.subAggregation(topHitsAgg);\n+        return compositeAggregation;\n+    }\n+\n+    @Override\n+    public int getInitialPageSize() {\n+        return DEFAULT_INITIAL_MAX_PAGE_SEARCH_SIZE;\n+    }\n+\n+    private SearchRequest buildSearchRequest(SourceConfig sourceConfig, Map<String, Object> position, int pageSize) {\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();\n+        buildSearchQuery(sourceBuilder, null, pageSize);\n+        sourceBuilder.query(sourceConfig.getQueryConfig().getQuery());\n+        SearchRequest searchRequest =\n+            new SearchRequest(sourceConfig.getIndex())\n+                .source(sourceBuilder)\n+                .indicesOptions(IndicesOptions.LENIENT_EXPAND_OPEN);\n+        logger.trace(\"Search request: {}\", searchRequest);\n+        return searchRequest;\n+    }\n+\n+    @Override\n+    public SearchSourceBuilder buildSearchQuery(SearchSourceBuilder builder, Map<String, Object> position, int pageSize) {\n+        cachedCompositeAggregation.aggregateAfter(position);\n+        cachedCompositeAggregation.size(pageSize);\n+        return builder.size(0).aggregation(cachedCompositeAggregation);\n+    }\n+\n+    @Override\n+    public ChangeCollector buildChangeCollector(String synchronizationField) {\n+        return new LatestDocChangeCollector(synchronizationField);\n+    }\n+\n+    private Stream<Map<String, Object>> extractResults(CompositeAggregation compositeAgg, TransformIndexerStats transformIndexerStats) {\n+        return compositeAgg.getBuckets().stream()\n+            .map(bucket -> {\n+                transformIndexerStats.incrementNumDocuments(bucket.getDocCount());\n+                TopHits topHits = bucket.getAggregations().get(TOP_HITS_AGGREGATION_NAME);\n+                assert topHits.getHits().getHits().length == 1;\n+                Map<String, Object> document = topHits.getHits().getHits()[0].getSourceAsMap();\n+\n+                // generator to create unique but deterministic document ids, so we\n+                // - do not create duplicates if we re-run after failure\n+                // - update documents\n+                IDGenerator idGen = new IDGenerator();\n+                config.getUniqueKey().forEach(field -> idGen.add(field, bucket.getKey().get(field)));\n+\n+                document.put(TransformField.DOCUMENT_ID_FIELD, idGen.getID());\n+                return document;\n+            });\n+    }\n+\n+    @Override\n+    public Tuple<Stream<IndexRequest>, Map<String, Object>> processSearchResponse(\n+        SearchResponse searchResponse,\n+        String destinationIndex,\n+        String destinationPipeline,\n+        Map<String, String> fieldTypeMap,\n+        TransformIndexerStats stats\n+    ) {\n+        Aggregations aggregations = searchResponse.getAggregations();\n+\n+        // Treat this as a \"we reached the end\".\n+        // This should only happen when all underlying indices have gone away. Consequently, there is no more data to read.\n+        if (aggregations == null) {\n+            return null;\n+        }\n+\n+        CompositeAggregation compositeAgg = aggregations.get(COMPOSITE_AGGREGATION_NAME);\n+        if (compositeAgg == null || compositeAgg.getBuckets().isEmpty()) {\n+            return null;\n+        }\n+\n+        Stream<IndexRequest> indexRequestStream =\n+            extractResults(compositeAgg, stats)\n+                .map(document -> DocumentConversionUtils.convertDocumentToIndexRequest(document, destinationIndex, destinationPipeline));\n+        return Tuple.tuple(indexRequestStream, compositeAgg.afterKey());\n+    }\n+\n+    @Override\n+    public void validateQuery(Client client, SourceConfig sourceConfig, ActionListener<Boolean> listener) {\n+        SearchRequest searchRequest = buildSearchRequest(sourceConfig, null, TEST_QUERY_PAGE_SIZE);\n+\n+        client.execute(SearchAction.INSTANCE, searchRequest, ActionListener.wrap(response -> {\n+            if (response == null) {\n+                listener.onFailure(\n+                    new ElasticsearchStatusException(\"Unexpected null response from test query\", RestStatus.SERVICE_UNAVAILABLE)\n+                );\n+                return;\n+            }\n+            if (response.status() != RestStatus.OK) {\n+                listener.onFailure(\n+                    new ElasticsearchStatusException(\n+                        \"Unexpected status from response of test query: \" + response.status(),\n+                        response.status()", "originalCommit": "a02238850f4cee7ac1f9e332656abc4304cb066e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE1NTk5NA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534155994", "bodyText": "I've copied this line from Pivot. Your suggestion is perfectly valid.\nI've just changed it both here and in Pivot.", "author": "przemekwitek", "createdAt": "2020-12-02T13:13:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzMzYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzNDA4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534134082", "bodyText": "same concern as before around user defined fields that start with _", "author": "benwtrent", "createdAt": "2020-12-02T12:37:06Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/latest/LatestDoc.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.transform.transforms.latest;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.fieldcaps.FieldCapabilitiesAction;\n+import org.elasticsearch.action.fieldcaps.FieldCapabilitiesRequest;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.search.SearchAction;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.elasticsearch.search.aggregations.Aggregations;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregation;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.metrics.TopHits;\n+import org.elasticsearch.search.aggregations.metrics.TopHitsAggregationBuilder;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.core.transform.TransformField;\n+import org.elasticsearch.xpack.core.transform.TransformMessages;\n+import org.elasticsearch.xpack.core.transform.transforms.SourceConfig;\n+import org.elasticsearch.xpack.core.transform.transforms.TransformIndexerStats;\n+import org.elasticsearch.xpack.core.transform.transforms.TransformProgress;\n+import org.elasticsearch.xpack.core.transform.transforms.latest.LatestDocConfig;\n+import org.elasticsearch.xpack.transform.transforms.Function;\n+import org.elasticsearch.xpack.transform.transforms.IDGenerator;\n+import org.elasticsearch.xpack.transform.transforms.pivot.SchemaUtil;\n+import org.elasticsearch.xpack.transform.transforms.common.DocumentConversionUtils;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.util.function.Predicate.not;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+\n+public class LatestDoc implements Function {\n+\n+    public static final int DEFAULT_INITIAL_MAX_PAGE_SEARCH_SIZE = 5000;\n+    public static final int TEST_QUERY_PAGE_SIZE = 50;\n+\n+    private static final String COMPOSITE_AGGREGATION_NAME = \"_transform\";\n+    private static final String TOP_HITS_AGGREGATION_NAME = \"_top_hits\";\n+    private static final Logger logger = LogManager.getLogger(LatestDoc.class);\n+\n+    private final LatestDocConfig config;\n+\n+    // objects for re-using\n+    private final CompositeAggregationBuilder cachedCompositeAggregation;\n+\n+    public LatestDoc(LatestDocConfig config) {\n+        this.config = config;\n+        this.cachedCompositeAggregation = createCompositeAggregation(config);\n+    }\n+\n+    private static CompositeAggregationBuilder createCompositeAggregation(LatestDocConfig config) {\n+        assert config.getSort().size() == 1 && config.getSort().get(0) instanceof FieldSortBuilder;\n+\n+        CompositeAggregationBuilder compositeAggregation;\n+        try (XContentBuilder builder = jsonBuilder()) {\n+            config.toCompositeAggXContent(builder);\n+            XContentParser parser = builder.generator()\n+                .contentType()\n+                .xContent()\n+                .createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, BytesReference.bytes(builder).streamInput());\n+            compositeAggregation = CompositeAggregationBuilder.PARSER.parse(parser, COMPOSITE_AGGREGATION_NAME);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\n+                TransformMessages.getMessage(TransformMessages.TRANSFORM_FAILED_TO_CREATE_COMPOSITE_AGGREGATION, \"latest_doc\"), e);\n+        }\n+        TopHitsAggregationBuilder topHitsAgg =\n+            AggregationBuilders.topHits(TOP_HITS_AGGREGATION_NAME)\n+                .size(1)  // we are only interested in the top-1\n+                .sorts(config.getSort());  // we copy the sort config directly from the function config\n+        compositeAggregation.subAggregation(topHitsAgg);\n+        return compositeAggregation;\n+    }\n+\n+    @Override\n+    public int getInitialPageSize() {\n+        return DEFAULT_INITIAL_MAX_PAGE_SEARCH_SIZE;\n+    }\n+\n+    private SearchRequest buildSearchRequest(SourceConfig sourceConfig, Map<String, Object> position, int pageSize) {\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();\n+        buildSearchQuery(sourceBuilder, null, pageSize);\n+        sourceBuilder.query(sourceConfig.getQueryConfig().getQuery());\n+        SearchRequest searchRequest =\n+            new SearchRequest(sourceConfig.getIndex())\n+                .source(sourceBuilder)\n+                .indicesOptions(IndicesOptions.LENIENT_EXPAND_OPEN);\n+        logger.trace(\"Search request: {}\", searchRequest);\n+        return searchRequest;\n+    }\n+\n+    @Override\n+    public SearchSourceBuilder buildSearchQuery(SearchSourceBuilder builder, Map<String, Object> position, int pageSize) {\n+        cachedCompositeAggregation.aggregateAfter(position);\n+        cachedCompositeAggregation.size(pageSize);\n+        return builder.size(0).aggregation(cachedCompositeAggregation);\n+    }\n+\n+    @Override\n+    public ChangeCollector buildChangeCollector(String synchronizationField) {\n+        return new LatestDocChangeCollector(synchronizationField);\n+    }\n+\n+    private Stream<Map<String, Object>> extractResults(CompositeAggregation compositeAgg, TransformIndexerStats transformIndexerStats) {\n+        return compositeAgg.getBuckets().stream()\n+            .map(bucket -> {\n+                transformIndexerStats.incrementNumDocuments(bucket.getDocCount());\n+                TopHits topHits = bucket.getAggregations().get(TOP_HITS_AGGREGATION_NAME);\n+                assert topHits.getHits().getHits().length == 1;\n+                Map<String, Object> document = topHits.getHits().getHits()[0].getSourceAsMap();\n+\n+                // generator to create unique but deterministic document ids, so we\n+                // - do not create duplicates if we re-run after failure\n+                // - update documents\n+                IDGenerator idGen = new IDGenerator();\n+                config.getUniqueKey().forEach(field -> idGen.add(field, bucket.getKey().get(field)));\n+\n+                document.put(TransformField.DOCUMENT_ID_FIELD, idGen.getID());\n+                return document;\n+            });\n+    }\n+\n+    @Override\n+    public Tuple<Stream<IndexRequest>, Map<String, Object>> processSearchResponse(\n+        SearchResponse searchResponse,\n+        String destinationIndex,\n+        String destinationPipeline,\n+        Map<String, String> fieldTypeMap,\n+        TransformIndexerStats stats\n+    ) {\n+        Aggregations aggregations = searchResponse.getAggregations();\n+\n+        // Treat this as a \"we reached the end\".\n+        // This should only happen when all underlying indices have gone away. Consequently, there is no more data to read.\n+        if (aggregations == null) {\n+            return null;\n+        }\n+\n+        CompositeAggregation compositeAgg = aggregations.get(COMPOSITE_AGGREGATION_NAME);\n+        if (compositeAgg == null || compositeAgg.getBuckets().isEmpty()) {\n+            return null;\n+        }\n+\n+        Stream<IndexRequest> indexRequestStream =\n+            extractResults(compositeAgg, stats)\n+                .map(document -> DocumentConversionUtils.convertDocumentToIndexRequest(document, destinationIndex, destinationPipeline));\n+        return Tuple.tuple(indexRequestStream, compositeAgg.afterKey());\n+    }\n+\n+    @Override\n+    public void validateQuery(Client client, SourceConfig sourceConfig, ActionListener<Boolean> listener) {\n+        SearchRequest searchRequest = buildSearchRequest(sourceConfig, null, TEST_QUERY_PAGE_SIZE);\n+\n+        client.execute(SearchAction.INSTANCE, searchRequest, ActionListener.wrap(response -> {\n+            if (response == null) {\n+                listener.onFailure(\n+                    new ElasticsearchStatusException(\"Unexpected null response from test query\", RestStatus.SERVICE_UNAVAILABLE)\n+                );\n+                return;\n+            }\n+            if (response.status() != RestStatus.OK) {\n+                listener.onFailure(\n+                    new ElasticsearchStatusException(\n+                        \"Unexpected status from response of test query: \" + response.status(),\n+                        response.status()\n+                    )\n+                );\n+                return;\n+            }\n+            listener.onResponse(true);\n+        }, e -> {\n+            Throwable unwrapped = ExceptionsHelper.unwrapCause(e);\n+            RestStatus status = unwrapped instanceof ElasticsearchException\n+                ? ((ElasticsearchException) unwrapped).status()\n+                : RestStatus.SERVICE_UNAVAILABLE;\n+            listener.onFailure(new ElasticsearchStatusException(\"Failed to test query\", status, unwrapped));\n+        }));\n+    }\n+\n+    @Override\n+    public void validateConfig(ActionListener<Boolean> listener) {\n+        listener.onResponse(true);\n+    }\n+\n+    @Override\n+    public void deduceMappings(Client client, SourceConfig sourceConfig, ActionListener<Map<String, String>> listener) {\n+        FieldCapabilitiesRequest fieldCapabilitiesRequest =\n+            new FieldCapabilitiesRequest().indices(sourceConfig.getIndex())\n+                .fields(\"*\")\n+                .indicesOptions(IndicesOptions.LENIENT_EXPAND_OPEN);\n+        client.execute(\n+            FieldCapabilitiesAction.INSTANCE,\n+            fieldCapabilitiesRequest,\n+            ActionListener.wrap(\n+                response -> listener.onResponse(\n+                    SchemaUtil.extractFieldMappings(response).entrySet().stream()\n+                        .filter(not(e -> e.getKey().startsWith(\"_\")))\n+                        .collect(toMap(Map.Entry::getKey, Map.Entry::getValue))", "originalCommit": "a02238850f4cee7ac1f9e332656abc4304cb066e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxMTM1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r536011357", "bodyText": "Needs investigation, added TODO in the DocumentConversionUtils.removeInternalFields method comment.", "author": "przemekwitek", "createdAt": "2020-12-04T10:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzNDA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzNTc4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534135781", "bodyText": "Ah, I see the pivot was already doing this. But it is still a concern. Especially since now as we are copying the doc directly.", "author": "benwtrent", "createdAt": "2020-12-02T12:40:02Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/Pivot.java", "diffHunk": "@@ -142,17 +136,17 @@ public void preview(\n                     final Aggregations aggregations = r.getAggregations();\n                     if (aggregations == null) {\n                         listener.onFailure(\n-                            new ElasticsearchStatusException(\"Source indices have been deleted or closed.\", RestStatus.BAD_REQUEST)\n-                        );\n+                            new ElasticsearchStatusException(\"Source indices have been deleted or closed.\", RestStatus.BAD_REQUEST));\n                         return;\n                     }\n                     final CompositeAggregation agg = aggregations.get(COMPOSITE_AGGREGATION_NAME);\n                     TransformIndexerStats stats = new TransformIndexerStats();\n-                    // remove all internal fields\n \n-                    List<Map<String, Object>> docs = extractResults(agg, fieldTypeMap, stats).peek(\n-                        doc -> doc.keySet().removeIf(k -> k.startsWith(\"_\"))\n-                    ).collect(Collectors.toList());", "originalCommit": "a02238850f4cee7ac1f9e332656abc4304cb066e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxMTU2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r536011565", "bodyText": "Needs investigation, added TODO in the DocumentConversionUtils.removeInternalFields method comment.", "author": "przemekwitek", "createdAt": "2020-12-04T10:52:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzNTc4MQ=="}], "type": "inlineReview"}, {"oid": "ffbe53da6cde7fd7d4749165df4f527cf8eb27ec", "url": "https://github.com/elastic/elasticsearch/commit/ffbe53da6cde7fd7d4749165df4f527cf8eb27ec", "message": "Use \"latest\" rather than \"latest_doc\" as the function name.\nMake \"sort\" a simple string.", "committedDate": "2020-12-03T07:22:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg5NzE2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534897169", "bodyText": "rename if we settle on latest", "author": "hendrikmuhs", "createdAt": "2020-12-03T08:21:01Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/transform/transforms/TransformConfig.java", "diffHunk": "@@ -61,6 +63,7 @@\n     private final SyncConfig syncConfig;\n     private final SettingsConfig settings;\n     private final PivotConfig pivotConfig;\n+    private final LatestDocConfig latestDocConfig;", "originalCommit": "ffbe53da6cde7fd7d4749165df4f527cf8eb27ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTEyNDgzNA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535124834", "bodyText": "Done (for variable names and method names).\nI'll rename classes (LatestDocConfig, LatestDoc) closer to the end of review not to break continuity of comments in GitHub history.", "author": "przemekwitek", "createdAt": "2020-12-03T11:20:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg5NzE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkzMTk3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534931976", "bodyText": "nit: although I think it will never be possible, it would be more correct to move this into the if below line 103.", "author": "hendrikmuhs", "createdAt": "2020-12-03T08:42:17Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/transform/transforms/TransformConfig.java", "diffHunk": "@@ -176,12 +183,13 @@ public static String documentId(String transformId) {\n         this.syncConfig = syncConfig;\n         this.setHeaders(headers == null ? Collections.emptyMap() : headers);\n         this.pivotConfig = pivotConfig;\n+        this.latestDocConfig = latestDocConfig;\n         this.description = description;\n         this.settings = settings == null ? new SettingsConfig() : settings;\n \n-        // at least one function must be defined\n-        if (this.pivotConfig == null) {\n-            throw new IllegalArgumentException(TransformMessages.TRANSFORM_CONFIGURATION_NO_TRANSFORM);\n+        // exactly one function must be defined\n+        if ((this.pivotConfig == null) == (this.latestDocConfig == null)) {", "originalCommit": "ffbe53da6cde7fd7d4749165df4f527cf8eb27ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE0MTI4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535141286", "bodyText": "Done.\nBut what if lenient == true? Should I also add a validation in validate() method?", "author": "przemekwitek", "createdAt": "2020-12-03T11:36:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkzMTk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkzNDY5NA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534934694", "bodyText": "could be a set?", "author": "hendrikmuhs", "createdAt": "2020-12-03T08:43:54Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/transform/transforms/latest/LatestDocConfig.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.transform.transforms.latest;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.sort.SortBuilder;\n+import org.elasticsearch.search.sort.SortBuilders;\n+import org.elasticsearch.search.sort.SortOrder;\n+import org.elasticsearch.xpack.core.transform.utils.ExceptionsHelper;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+\n+public class LatestDocConfig implements Writeable, ToXContentObject {\n+\n+    private static final String NAME = \"latest_config\";\n+\n+    private static final ParseField UNIQUE_KEY = new ParseField(\"unique_key\");\n+    private static final ParseField SORT = new ParseField(\"sort\");\n+\n+    private final List<String> uniqueKey;", "originalCommit": "ffbe53da6cde7fd7d4749165df4f527cf8eb27ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE0Mzc0MA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535143740", "bodyText": "I'm wondering if there will be cases where the user will want to influence the order of fields in case they know composite aggregation is used internally by transform. Having deterministic order of items in this collection would help them achieve that.\nWDYT?", "author": "przemekwitek", "createdAt": "2020-12-03T11:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkzNDY5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIwMzcwNg==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r538203706", "bodyText": "good point, there is the case where index sort matters, so lets keep List", "author": "hendrikmuhs", "createdAt": "2020-12-08T10:07:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkzNDY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk1MzUzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534953531", "bodyText": "it should not be possible (for strict) to allow unique_key double entries (see my comment regarding using set). To be able to use a set, it seems ok to de-dedup on lenient and throw on strict.\n(same for sort)", "author": "hendrikmuhs", "createdAt": "2020-12-03T08:53:24Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/transform/transforms/latest/LatestDocConfig.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.transform.transforms.latest;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.sort.SortBuilder;\n+import org.elasticsearch.search.sort.SortBuilders;\n+import org.elasticsearch.search.sort.SortOrder;\n+import org.elasticsearch.xpack.core.transform.utils.ExceptionsHelper;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+\n+public class LatestDocConfig implements Writeable, ToXContentObject {\n+\n+    private static final String NAME = \"latest_config\";\n+\n+    private static final ParseField UNIQUE_KEY = new ParseField(\"unique_key\");\n+    private static final ParseField SORT = new ParseField(\"sort\");\n+\n+    private final List<String> uniqueKey;\n+    private final String sort;\n+\n+    private static final ConstructingObjectParser<LatestDocConfig, Void> STRICT_PARSER = createParser(false);\n+    private static final ConstructingObjectParser<LatestDocConfig, Void> LENIENT_PARSER = createParser(true);\n+\n+    private static ConstructingObjectParser<LatestDocConfig, Void> createParser(boolean lenient) {\n+        ConstructingObjectParser<LatestDocConfig, Void> parser =\n+            new ConstructingObjectParser<>(NAME, lenient, args -> new LatestDocConfig((List<String>) args[0], (String) args[1]));", "originalCommit": "ffbe53da6cde7fd7d4749165df4f527cf8eb27ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI1NTg3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535255876", "bodyText": "it should not be possible (for strict) to allow unique_key double entries (see my comment regarding using set). To be able to use a set, it seems ok to de-dedup on lenient and throw on strict.\n\nOk, Im a bit lost on what to consider a parsing failure (throw from fromXContent()) vs validation failure (throw from validate()).\nCurrently validate() method has the following checks:\n\nnon-empty unique_key array\nnon-empty unique_key elements\nnon-empty sort field\n\nI've just also added a check for duplicate elements to validate().\nWhich of the checks mentioned above should be moved to parser? Could you give me some guidance on how do I decide that on a per-check basis?\n\n(same for sort)\n\nsort is now a singular field (not an array) so I think this comment no longer applies.", "author": "przemekwitek", "createdAt": "2020-12-03T14:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk1MzUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk3MjI2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534972261", "bodyText": "add missing_bucket here", "author": "hendrikmuhs", "createdAt": "2020-12-03T09:04:05Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/transform/transforms/latest/LatestDocConfig.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.transform.transforms.latest;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.sort.SortBuilder;\n+import org.elasticsearch.search.sort.SortBuilders;\n+import org.elasticsearch.search.sort.SortOrder;\n+import org.elasticsearch.xpack.core.transform.utils.ExceptionsHelper;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+\n+public class LatestDocConfig implements Writeable, ToXContentObject {\n+\n+    private static final String NAME = \"latest_config\";\n+\n+    private static final ParseField UNIQUE_KEY = new ParseField(\"unique_key\");\n+    private static final ParseField SORT = new ParseField(\"sort\");\n+\n+    private final List<String> uniqueKey;\n+    private final String sort;\n+\n+    private static final ConstructingObjectParser<LatestDocConfig, Void> STRICT_PARSER = createParser(false);\n+    private static final ConstructingObjectParser<LatestDocConfig, Void> LENIENT_PARSER = createParser(true);\n+\n+    private static ConstructingObjectParser<LatestDocConfig, Void> createParser(boolean lenient) {\n+        ConstructingObjectParser<LatestDocConfig, Void> parser =\n+            new ConstructingObjectParser<>(NAME, lenient, args -> new LatestDocConfig((List<String>) args[0], (String) args[1]));\n+\n+        parser.declareStringArray(constructorArg(), UNIQUE_KEY);\n+        parser.declareString(constructorArg(), SORT);\n+\n+        return parser;\n+    }\n+\n+    public static LatestDocConfig fromXContent(final XContentParser parser, boolean lenient) throws IOException {\n+        return lenient ? LENIENT_PARSER.apply(parser, null) : STRICT_PARSER.apply(parser, null);\n+    }\n+\n+    public LatestDocConfig(List<String> uniqueKey, String sort) {\n+        this.uniqueKey = ExceptionsHelper.requireNonNull(uniqueKey, UNIQUE_KEY.getPreferredName());\n+        this.sort = ExceptionsHelper.requireNonNull(sort, SORT.getPreferredName());\n+    }\n+\n+    public LatestDocConfig(StreamInput in) throws IOException {\n+        this.uniqueKey = in.readStringList();\n+        this.sort = in.readString();\n+    }\n+\n+    public List<String> getUniqueKey() {\n+        return uniqueKey;\n+    }\n+\n+    public String getSort() {\n+        return sort;\n+    }\n+\n+    public List<SortBuilder<?>> getSorts() {\n+        return Collections.singletonList(SortBuilders.fieldSort(sort).order(SortOrder.DESC));\n+    }\n+\n+    public ActionRequestValidationException validate(ActionRequestValidationException validationException) {\n+        if (uniqueKey.isEmpty()) {\n+            validationException = addValidationError(\"latest.unique_key must be non-empty\", validationException);\n+        } else {\n+            for (int i = 0; i < uniqueKey.size(); ++i) {\n+                if (uniqueKey.get(i).isEmpty()) {\n+                    validationException =\n+                        addValidationError(\"latest.unique_key[\" + i + \"] element must be non-empty\", validationException);\n+                }\n+            }\n+        }\n+\n+        if (sort.isEmpty()) {\n+            validationException = addValidationError(\"latest.sort must be non-empty\", validationException);\n+        }\n+\n+        return validationException;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(UNIQUE_KEY.getPreferredName(), uniqueKey);\n+        builder.field(SORT.getPreferredName(), sort);\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public void toCompositeAggXContent(XContentBuilder builder) throws IOException {\n+        builder.startObject();\n+        builder.field(CompositeAggregationBuilder.SOURCES_FIELD_NAME.getPreferredName());\n+\n+        builder.startArray();\n+        for (String field : uniqueKey) {\n+            builder.startObject();\n+            builder.startObject(field);\n+            builder.startObject(TermsAggregationBuilder.NAME);\n+            builder.field(\"field\", field);", "originalCommit": "ffbe53da6cde7fd7d4749165df4f527cf8eb27ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE4MDgyMw==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535180823", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-12-03T12:17:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk3MjI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4OTY4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534989685", "bodyText": "see below, you also need to implement isValid(). This is some legacy code, #59588 is a todo to clean this up. The difference between the 2:\n\nvalidate is used for actions\nisValid is called when a transform starts as a check before the task runs, so this is not part of an action\n\nWe should consolidate this, for now try to reuse validate. Maybe you can just call validate and check for !null (no need to copy bad code). Long term we should change validate to return ValidationException and translate it to ActionRequestValidationException on the outer layer. ActionRequestValidationException is just a facade.", "author": "hendrikmuhs", "createdAt": "2020-12-03T09:20:58Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/transform/transforms/TransformConfig.java", "diffHunk": "@@ -297,8 +300,10 @@ public ActionRequestValidationException validate(ActionRequestValidationExceptio\n         if (pivotConfig != null) {\n             validationException = pivotConfig.validate(validationException);\n         }\n+        if (latestDocConfig != null) {\n+            validationException = latestDocConfig.validate(validationException);\n+        }\n         validationException = settings.validate(validationException);\n-\n         return validationException;\n     }\n ", "originalCommit": "ffbe53da6cde7fd7d4749165df4f527cf8eb27ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI0OTc0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535249747", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-12-03T14:00:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4OTY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk5ODI4MA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r534998280", "bodyText": "can you add sparse data, so we cover missing_bucket?", "author": "hendrikmuhs", "createdAt": "2020-12-03T09:27:16Z", "path": "x-pack/plugin/transform/qa/multi-node-tests/src/javaRestTest/java/org/elasticsearch/xpack/transform/integration/LatestDocIT.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.transform.integration;\n+\n+import org.elasticsearch.action.admin.indices.refresh.RefreshRequest;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.client.indices.GetMappingsRequest;\n+import org.elasticsearch.client.indices.GetMappingsResponse;\n+import org.elasticsearch.client.transform.PreviewTransformRequest;\n+import org.elasticsearch.client.transform.PreviewTransformResponse;\n+import org.elasticsearch.client.transform.transforms.TransformConfig;\n+import org.elasticsearch.client.transform.transforms.latest.LatestDocConfig;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.junit.After;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+public class LatestDocIT extends TransformIntegTestCase {", "originalCommit": "ffbe53da6cde7fd7d4749165df4f527cf8eb27ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE5NjM1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535196352", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-12-03T12:42:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk5ODI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAwOTgwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535009805", "bodyText": "this conflicts with my PR, where I use addCommonSetings. Maybe it is better to remove addCommonBuilderParameters instead.\nHowever as we are working in parallel on this, I think it is best to avoid changing this for now, but in a follow up PR.", "author": "hendrikmuhs", "createdAt": "2020-12-03T09:35:29Z", "path": "x-pack/plugin/transform/qa/single-node-tests/src/javaRestTest/java/org/elasticsearch/xpack/transform/integration/continuous/ContinuousTestCase.java", "diffHunk": "@@ -75,28 +76,29 @@\n      * Test results after 1 iteration in the test runner.\n      *\n      * @param iteration the current iteration\n+     * @param modifiedEvents set of events modified in the current iteration\n      */\n-    public abstract void testIteration(int iteration) throws IOException;\n+    public abstract void testIteration(int iteration, Set<String> modifiedEvents) throws IOException;\n \n     protected TransformConfig.Builder addCommonBuilderParameters(TransformConfig.Builder builder) {\n-        return builder.setSyncConfig(getSyncConfig())\n-            .setSettings(addCommonSetings(new SettingsConfig.Builder()).build())\n+        return builder\n+            .setSyncConfig(getSyncConfig())\n+            .setSettings(", "originalCommit": "ffbe53da6cde7fd7d4749165df4f527cf8eb27ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI1MjA4NA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535252084", "bodyText": "Fair enough, reverted.", "author": "przemekwitek", "createdAt": "2020-12-03T14:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAwOTgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAxMTc3MA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535011770", "bodyText": "good idea!", "author": "hendrikmuhs", "createdAt": "2020-12-03T09:37:09Z", "path": "x-pack/plugin/transform/qa/single-node-tests/src/javaRestTest/java/org/elasticsearch/xpack/transform/integration/continuous/TransformContinuousIT.java", "diffHunk": "@@ -208,10 +211,12 @@ public void testContinousEvents() throws Exception {\n             BulkRequest bulkRequest = new BulkRequest(sourceIndexName);\n \n             int numDocs = randomIntBetween(1000, 20000);\n+            Set<String> modifiedEvents = new HashSet<>();", "originalCommit": "ffbe53da6cde7fd7d4749165df4f527cf8eb27ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE0NTEyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535145125", "bodyText": "Thanks!", "author": "przemekwitek", "createdAt": "2020-12-03T11:40:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAxMTc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAzNjMyMA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535036320", "bodyText": "we could move this method into this class and make the config class more lightweight. It looks like a legacy code smell in pivot, we should not copy.", "author": "hendrikmuhs", "createdAt": "2020-12-03T09:59:19Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/latest/LatestDoc.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.transform.transforms.latest;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.fieldcaps.FieldCapabilitiesAction;\n+import org.elasticsearch.action.fieldcaps.FieldCapabilitiesRequest;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.search.SearchAction;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.elasticsearch.search.aggregations.Aggregations;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregation;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.metrics.TopHits;\n+import org.elasticsearch.search.aggregations.metrics.TopHitsAggregationBuilder;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.core.transform.TransformField;\n+import org.elasticsearch.xpack.core.transform.TransformMessages;\n+import org.elasticsearch.xpack.core.transform.transforms.SourceConfig;\n+import org.elasticsearch.xpack.core.transform.transforms.TransformIndexerStats;\n+import org.elasticsearch.xpack.core.transform.transforms.TransformProgress;\n+import org.elasticsearch.xpack.core.transform.transforms.latest.LatestDocConfig;\n+import org.elasticsearch.xpack.transform.transforms.Function;\n+import org.elasticsearch.xpack.transform.transforms.IDGenerator;\n+import org.elasticsearch.xpack.transform.transforms.common.DocumentConversionUtils;\n+import org.elasticsearch.xpack.transform.transforms.pivot.SchemaUtil;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.util.function.Predicate.not;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+\n+public class LatestDoc implements Function {\n+\n+    public static final int DEFAULT_INITIAL_MAX_PAGE_SEARCH_SIZE = 5000;\n+    public static final int TEST_QUERY_PAGE_SIZE = 50;\n+\n+    private static final String COMPOSITE_AGGREGATION_NAME = \"_transform\";\n+    private static final String TOP_HITS_AGGREGATION_NAME = \"_top_hits\";\n+    private static final Logger logger = LogManager.getLogger(LatestDoc.class);\n+\n+    private final LatestDocConfig config;\n+\n+    // objects for re-using\n+    private final CompositeAggregationBuilder cachedCompositeAggregation;\n+\n+    public LatestDoc(LatestDocConfig config) {\n+        this.config = config;\n+        this.cachedCompositeAggregation = createCompositeAggregation(config);\n+    }\n+\n+    private static CompositeAggregationBuilder createCompositeAggregation(LatestDocConfig config) {\n+        CompositeAggregationBuilder compositeAggregation;\n+        try (XContentBuilder builder = jsonBuilder()) {\n+            config.toCompositeAggXContent(builder);", "originalCommit": "ffbe53da6cde7fd7d4749165df4f527cf8eb27ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE0NjM3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535146377", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-12-03T11:41:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAzNjMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAzNzc3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535037779", "bodyText": "\ud83d\udc4d another indicator that config.toCompositeAggXContent should not exist", "author": "hendrikmuhs", "createdAt": "2020-12-03T10:00:37Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/latest/LatestDoc.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.transform.transforms.latest;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.fieldcaps.FieldCapabilitiesAction;\n+import org.elasticsearch.action.fieldcaps.FieldCapabilitiesRequest;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.search.SearchAction;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.elasticsearch.search.aggregations.Aggregations;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregation;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.metrics.TopHits;\n+import org.elasticsearch.search.aggregations.metrics.TopHitsAggregationBuilder;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.core.transform.TransformField;\n+import org.elasticsearch.xpack.core.transform.TransformMessages;\n+import org.elasticsearch.xpack.core.transform.transforms.SourceConfig;\n+import org.elasticsearch.xpack.core.transform.transforms.TransformIndexerStats;\n+import org.elasticsearch.xpack.core.transform.transforms.TransformProgress;\n+import org.elasticsearch.xpack.core.transform.transforms.latest.LatestDocConfig;\n+import org.elasticsearch.xpack.transform.transforms.Function;\n+import org.elasticsearch.xpack.transform.transforms.IDGenerator;\n+import org.elasticsearch.xpack.transform.transforms.common.DocumentConversionUtils;\n+import org.elasticsearch.xpack.transform.transforms.pivot.SchemaUtil;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.util.function.Predicate.not;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+\n+public class LatestDoc implements Function {\n+\n+    public static final int DEFAULT_INITIAL_MAX_PAGE_SEARCH_SIZE = 5000;\n+    public static final int TEST_QUERY_PAGE_SIZE = 50;\n+\n+    private static final String COMPOSITE_AGGREGATION_NAME = \"_transform\";\n+    private static final String TOP_HITS_AGGREGATION_NAME = \"_top_hits\";\n+    private static final Logger logger = LogManager.getLogger(LatestDoc.class);\n+\n+    private final LatestDocConfig config;\n+\n+    // objects for re-using\n+    private final CompositeAggregationBuilder cachedCompositeAggregation;\n+\n+    public LatestDoc(LatestDocConfig config) {\n+        this.config = config;\n+        this.cachedCompositeAggregation = createCompositeAggregation(config);\n+    }\n+\n+    private static CompositeAggregationBuilder createCompositeAggregation(LatestDocConfig config) {\n+        CompositeAggregationBuilder compositeAggregation;\n+        try (XContentBuilder builder = jsonBuilder()) {\n+            config.toCompositeAggXContent(builder);\n+            XContentParser parser = builder.generator()\n+                .contentType()\n+                .xContent()\n+                .createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, BytesReference.bytes(builder).streamInput());\n+            compositeAggregation = CompositeAggregationBuilder.PARSER.parse(parser, COMPOSITE_AGGREGATION_NAME);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\n+                TransformMessages.getMessage(TransformMessages.TRANSFORM_FAILED_TO_CREATE_COMPOSITE_AGGREGATION, \"latest\"), e);\n+        }\n+        TopHitsAggregationBuilder topHitsAgg =", "originalCommit": "ffbe53da6cde7fd7d4749165df4f527cf8eb27ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA0NTI1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535045253", "bodyText": "you might get rid of this method or at least rename it. Another example of legacy in pivot, better not to copy (in pivot we ended up with this after several re-factorings, it should be fixed there, too!).\nThe name is misleading, this is called for validation and preview, maybe you can name it accordingly. Or if you think re-usage makes no sense inline it.", "author": "hendrikmuhs", "createdAt": "2020-12-03T10:07:41Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/latest/LatestDoc.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.transform.transforms.latest;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.fieldcaps.FieldCapabilitiesAction;\n+import org.elasticsearch.action.fieldcaps.FieldCapabilitiesRequest;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.search.SearchAction;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.elasticsearch.search.aggregations.Aggregations;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregation;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.metrics.TopHits;\n+import org.elasticsearch.search.aggregations.metrics.TopHitsAggregationBuilder;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.core.transform.TransformField;\n+import org.elasticsearch.xpack.core.transform.TransformMessages;\n+import org.elasticsearch.xpack.core.transform.transforms.SourceConfig;\n+import org.elasticsearch.xpack.core.transform.transforms.TransformIndexerStats;\n+import org.elasticsearch.xpack.core.transform.transforms.TransformProgress;\n+import org.elasticsearch.xpack.core.transform.transforms.latest.LatestDocConfig;\n+import org.elasticsearch.xpack.transform.transforms.Function;\n+import org.elasticsearch.xpack.transform.transforms.IDGenerator;\n+import org.elasticsearch.xpack.transform.transforms.common.DocumentConversionUtils;\n+import org.elasticsearch.xpack.transform.transforms.pivot.SchemaUtil;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.util.function.Predicate.not;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+\n+public class LatestDoc implements Function {\n+\n+    public static final int DEFAULT_INITIAL_MAX_PAGE_SEARCH_SIZE = 5000;\n+    public static final int TEST_QUERY_PAGE_SIZE = 50;\n+\n+    private static final String COMPOSITE_AGGREGATION_NAME = \"_transform\";\n+    private static final String TOP_HITS_AGGREGATION_NAME = \"_top_hits\";\n+    private static final Logger logger = LogManager.getLogger(LatestDoc.class);\n+\n+    private final LatestDocConfig config;\n+\n+    // objects for re-using\n+    private final CompositeAggregationBuilder cachedCompositeAggregation;\n+\n+    public LatestDoc(LatestDocConfig config) {\n+        this.config = config;\n+        this.cachedCompositeAggregation = createCompositeAggregation(config);\n+    }\n+\n+    private static CompositeAggregationBuilder createCompositeAggregation(LatestDocConfig config) {\n+        CompositeAggregationBuilder compositeAggregation;\n+        try (XContentBuilder builder = jsonBuilder()) {\n+            config.toCompositeAggXContent(builder);\n+            XContentParser parser = builder.generator()\n+                .contentType()\n+                .xContent()\n+                .createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, BytesReference.bytes(builder).streamInput());\n+            compositeAggregation = CompositeAggregationBuilder.PARSER.parse(parser, COMPOSITE_AGGREGATION_NAME);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\n+                TransformMessages.getMessage(TransformMessages.TRANSFORM_FAILED_TO_CREATE_COMPOSITE_AGGREGATION, \"latest\"), e);\n+        }\n+        TopHitsAggregationBuilder topHitsAgg =\n+            AggregationBuilders.topHits(TOP_HITS_AGGREGATION_NAME)\n+                .size(1)  // we are only interested in the top-1\n+                .sorts(config.getSorts());  // we copy the sort config directly from the function config\n+        compositeAggregation.subAggregation(topHitsAgg);\n+        return compositeAggregation;\n+    }\n+\n+    @Override\n+    public int getInitialPageSize() {\n+        return DEFAULT_INITIAL_MAX_PAGE_SEARCH_SIZE;\n+    }\n+\n+    private SearchRequest buildSearchRequest(SourceConfig sourceConfig, Map<String, Object> position, int pageSize) {", "originalCommit": "ffbe53da6cde7fd7d4749165df4f527cf8eb27ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE2NTMzNA==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r535165334", "bodyText": "The method turned out to only consist of 3 statements so I've inlined it.", "author": "przemekwitek", "createdAt": "2020-12-03T12:02:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA0NTI1Mw=="}], "type": "inlineReview"}, {"oid": "d80a607104ace330bab5bef2ebd4982057f0b581", "url": "https://github.com/elastic/elasticsearch/commit/d80a607104ace330bab5bef2ebd4982057f0b581", "message": "Move extractFieldMappings method to DocumentConversionUtils and add a unit test\nRe-use removeInternalFields method where applicable", "committedDate": "2020-12-04T10:53:44Z", "type": "forcePushed"}, {"oid": "290c62e2e6deba27b226c3558b437ade0482e5d8", "url": "https://github.com/elastic/elasticsearch/commit/290c62e2e6deba27b226c3558b437ade0482e5d8", "message": "Implement latest function", "committedDate": "2020-12-08T08:19:07Z", "type": "commit"}, {"oid": "d18c67544c207d826fe9fff6495d534e5b8a8949", "url": "https://github.com/elastic/elasticsearch/commit/d18c67544c207d826fe9fff6495d534e5b8a8949", "message": "Implement change collector for latest function", "committedDate": "2020-12-08T08:19:09Z", "type": "commit"}, {"oid": "6d448da1c15a0210e6e589e39919e3323e8a6d13", "url": "https://github.com/elastic/elasticsearch/commit/6d448da1c15a0210e6e589e39919e3323e8a6d13", "message": "Apply review comments", "committedDate": "2020-12-08T08:19:09Z", "type": "commit"}, {"oid": "4816d83582dc213d176b2294a91788e6004d1ef3", "url": "https://github.com/elastic/elasticsearch/commit/4816d83582dc213d176b2294a91788e6004d1ef3", "message": "Verify optimization in LatestDocContinuousIT", "committedDate": "2020-12-08T08:19:09Z", "type": "commit"}, {"oid": "2de8669e228d1d2a2bf620deb458300b689d739f", "url": "https://github.com/elastic/elasticsearch/commit/2de8669e228d1d2a2bf620deb458300b689d739f", "message": "Introduce constant instead of magic number in the code.", "committedDate": "2020-12-08T08:19:10Z", "type": "commit"}, {"oid": "36973784863c3fb2b17e45ff94931cfdf8584acb", "url": "https://github.com/elastic/elasticsearch/commit/36973784863c3fb2b17e45ff94931cfdf8584acb", "message": "Add validations with unit tests", "committedDate": "2020-12-08T08:19:10Z", "type": "commit"}, {"oid": "838116ad667fad0309894acd913f2d7a6e34ee21", "url": "https://github.com/elastic/elasticsearch/commit/838116ad667fad0309894acd913f2d7a6e34ee21", "message": "Validate sort type", "committedDate": "2020-12-08T08:19:10Z", "type": "commit"}, {"oid": "0bca2e9e402958152142ecfdecbbc456a2973a15", "url": "https://github.com/elastic/elasticsearch/commit/0bca2e9e402958152142ecfdecbbc456a2973a15", "message": "Add comments in LatestDocChangeCollector's methods", "committedDate": "2020-12-08T08:19:10Z", "type": "commit"}, {"oid": "fa9f5ea50bfaff85097b6bd9dbcaf26ee2cda3bb", "url": "https://github.com/elastic/elasticsearch/commit/fa9f5ea50bfaff85097b6bd9dbcaf26ee2cda3bb", "message": "Apply review comments", "committedDate": "2020-12-08T08:19:10Z", "type": "commit"}, {"oid": "90523fb9cadfce968dc4266fb356fa3ba77f5d73", "url": "https://github.com/elastic/elasticsearch/commit/90523fb9cadfce968dc4266fb356fa3ba77f5d73", "message": "Use \"latest\" rather than \"latest_doc\" as the function name.\nMake \"sort\" a simple string.", "committedDate": "2020-12-08T08:19:10Z", "type": "commit"}, {"oid": "31fe6eb96a7ca888e04521f9e9fd20fc70ac37d5", "url": "https://github.com/elastic/elasticsearch/commit/31fe6eb96a7ca888e04521f9e9fd20fc70ac37d5", "message": "Apply review comments", "committedDate": "2020-12-08T08:20:56Z", "type": "commit"}, {"oid": "2439e957173adc701b0bfe6990aec87856540fc1", "url": "https://github.com/elastic/elasticsearch/commit/2439e957173adc701b0bfe6990aec87856540fc1", "message": "Move extractFieldMappings method to DocumentConversionUtils and add a unit test\nRe-use removeInternalFields method where applicable", "committedDate": "2020-12-08T08:20:58Z", "type": "commit"}, {"oid": "2439e957173adc701b0bfe6990aec87856540fc1", "url": "https://github.com/elastic/elasticsearch/commit/2439e957173adc701b0bfe6990aec87856540fc1", "message": "Move extractFieldMappings method to DocumentConversionUtils and add a unit test\nRe-use removeInternalFields method where applicable", "committedDate": "2020-12-08T08:20:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIwOTIyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r538209229", "bodyText": "lets remove that, too", "author": "hendrikmuhs", "createdAt": "2020-12-08T10:14:43Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/Pivot.java", "diffHunk": "@@ -197,7 +191,7 @@ public SearchRequest buildSearchRequest(SourceConfig sourceConfig, Map<String, O\n         searchRequest.source(sourceBuilder);\n         searchRequest.indicesOptions(IndicesOptions.LENIENT_EXPAND_OPEN);\n \n-        logger.trace(\"Search request: {}\", searchRequest);\n+        logger.trace(() -> new ParameterizedMessage(\"Search request: {}\", searchRequest));", "originalCommit": "2439e957173adc701b0bfe6990aec87856540fc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIxNjk0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65304#discussion_r538216945", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-12-08T10:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIwOTIyOQ=="}], "type": "inlineReview"}, {"oid": "a0ab9d51743428ebe3566d552888ff556d3fb80c", "url": "https://github.com/elastic/elasticsearch/commit/a0ab9d51743428ebe3566d552888ff556d3fb80c", "message": "Rename classes from `LatestDoc*` to `Latest*`", "committedDate": "2020-12-08T10:36:21Z", "type": "commit"}, {"oid": "a887d1cd8808a45e5daff01e81fc9b73f16a9bfe", "url": "https://github.com/elastic/elasticsearch/commit/a887d1cd8808a45e5daff01e81fc9b73f16a9bfe", "message": "Rename classes from `LatestDoc*` to `Latest*`", "committedDate": "2020-12-08T11:23:53Z", "type": "commit"}, {"oid": "abaf2bf73c48ec6fde02a8f16d2e0f77b56fcbc3", "url": "https://github.com/elastic/elasticsearch/commit/abaf2bf73c48ec6fde02a8f16d2e0f77b56fcbc3", "message": "Fix handling null keys by Collectors.toMap", "committedDate": "2020-12-08T11:25:41Z", "type": "commit"}]}