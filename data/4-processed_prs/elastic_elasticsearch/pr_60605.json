{"pr_number": 60605, "pr_title": "Provide option to allow writes when master is down", "pr_createdAt": "2020-08-03T15:50:21Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/60605", "timeline": [{"oid": "060c3793ec5fba4b450c94f587d0aae7fa8403d1", "url": "https://github.com/elastic/elasticsearch/commit/060c3793ec5fba4b450c94f587d0aae7fa8403d1", "message": "Provide option to allow writes when master is down", "committedDate": "2020-08-03T15:40:12Z", "type": "commit"}, {"oid": "75a3bb06f5d516e469b1e08e05fb884d1ac2f248", "url": "https://github.com/elastic/elasticsearch/commit/75a3bb06f5d516e469b1e08e05fb884d1ac2f248", "message": "quality", "committedDate": "2020-08-03T16:11:08Z", "type": "commit"}, {"oid": "f88f832266c084ebeaff46281d39147215fb8c23", "url": "https://github.com/elastic/elasticsearch/commit/f88f832266c084ebeaff46281d39147215fb8c23", "message": "search throws all kinds of exceptions", "committedDate": "2020-08-04T07:17:13Z", "type": "commit"}, {"oid": "1caccd61a917779e9552a52e731f8dbe9248d76a", "url": "https://github.com/elastic/elasticsearch/commit/1caccd61a917779e9552a52e731f8dbe9248d76a", "message": "Randomization", "committedDate": "2020-08-10T11:12:54Z", "type": "commit"}, {"oid": "ed66cf81f7de239916521ad95f351a94c56b507d", "url": "https://github.com/elastic/elasticsearch/commit/ed66cf81f7de239916521ad95f351a94c56b507d", "message": "Merge remote-tracking branch 'elastic/master' into no_master_metadata_writes", "committedDate": "2020-08-10T11:15:53Z", "type": "commit"}, {"oid": "0703a26a0b39ca29e114e4eedb34701e4da02c71", "url": "https://github.com/elastic/elasticsearch/commit/0703a26a0b39ca29e114e4eedb34701e4da02c71", "message": "random != random", "committedDate": "2020-08-11T07:16:39Z", "type": "commit"}, {"oid": "97b9b68215e6e8b3ba54c4f78b06ad3040f1a2fb", "url": "https://github.com/elastic/elasticsearch/commit/97b9b68215e6e8b3ba54c4f78b06ad3040f1a2fb", "message": "Merge remote-tracking branch 'elastic/master' into no_master_metadata_writes", "committedDate": "2020-08-11T07:18:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY5NTEwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/60605#discussion_r468695105", "bodyText": "I wonder if we should add integration tests for the two primary ways indexing can fail with the new block:\n\nAn index or data-stream is to be auto-created.\nA dynamic mapping update is done.\n\nAFAICS, this will work out fine though.", "author": "henningandersen", "createdAt": "2020-08-11T16:05:48Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/NoMasterNodeIT.java", "diffHunk": "@@ -261,4 +266,74 @@ public void testNoMasterActionsWriteMasterBlock() throws Exception {\n \n         internalCluster().clearDisruptionScheme(true);\n     }\n+\n+    public void testNoMasterActionsMetadataWriteMasterBlock() throws Exception {\n+        Settings settings = Settings.builder()\n+            .put(AutoCreateIndex.AUTO_CREATE_INDEX_SETTING.getKey(), false)\n+            .put(NoMasterBlockService.NO_MASTER_BLOCK_SETTING.getKey(), \"metadata_write\")\n+            .build();\n+\n+        final List<String> nodes = internalCluster().startNodes(3, settings);\n+\n+        prepareCreate(\"test1\").setSettings(\n+            Settings.builder().put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1)).get();\n+        client().admin().cluster().prepareHealth(\"_all\").setWaitForGreenStatus().get();\n+        client().prepareIndex(\"test1\").setId(\"1\").setSource(\"field\", \"value1\").get();\n+        refresh();\n+\n+        ensureGreen(\"test1\");\n+\n+        ClusterStateResponse clusterState = client().admin().cluster().prepareState().get();\n+        logger.info(\"Cluster state:\\n{}\", clusterState.getState());\n+\n+        final List<String> nodesWithShards = clusterState.getState().routingTable().index(\"test1\").shard(0).activeShards().stream()\n+            .map(shardRouting -> shardRouting.currentNodeId()).map(nodeId -> clusterState.getState().nodes().resolveNode(nodeId))\n+            .map(DiscoveryNode::getName).collect(Collectors.toList());\n+\n+        client().execute(AddVotingConfigExclusionsAction.INSTANCE,\n+            new AddVotingConfigExclusionsRequest(nodesWithShards.toArray(new String[0]))).get();\n+        ensureGreen(\"test1\");\n+\n+        String partitionedNode = nodes.stream().filter(n -> nodesWithShards.contains(n) == false).findFirst().get();\n+\n+        final NetworkDisruption disruptionScheme\n+            = new NetworkDisruption(new NetworkDisruption.TwoPartitions(Collections.singleton(partitionedNode),\n+            new HashSet<>(nodesWithShards)), NetworkDisruption.DISCONNECT);\n+        internalCluster().setDisruptionScheme(disruptionScheme);\n+        disruptionScheme.startDisrupting();\n+\n+        assertBusy(() -> {\n+            for (String node : nodesWithShards) {\n+                ClusterState state = client(node).admin().cluster().prepareState().setLocal(true).get().getState();\n+                assertTrue(state.blocks().hasGlobalBlockWithId(NoMasterBlockService.NO_MASTER_BLOCK_ID));\n+            }\n+        });\n+\n+        GetResponse getResponse = client(randomFrom(nodesWithShards)).prepareGet(\"test1\", \"1\").get();\n+        assertExists(getResponse);\n+\n+        expectThrows(Exception.class, () -> client(partitionedNode).prepareGet(\"test1\", \"1\").get());\n+\n+        SearchResponse countResponse = client(randomFrom(nodesWithShards)).prepareSearch(\"test1\")\n+            .setAllowPartialSearchResults(true).setSize(0).get();\n+        assertHitCount(countResponse, 1L);\n+\n+        expectThrows(Exception.class, () -> client(partitionedNode).prepareSearch(\"test1\")\n+            .setAllowPartialSearchResults(true).setSize(0).get());\n+\n+        TimeValue timeout = TimeValue.timeValueMillis(200);\n+        client(randomFrom(nodesWithShards)).prepareUpdate(\"test1\", \"1\")\n+            .setDoc(Requests.INDEX_CONTENT_TYPE, \"field\", \"value2\").setTimeout(timeout).get();\n+\n+        expectThrows(UnavailableShardsException.class, () -> client(partitionedNode).prepareUpdate(\"test1\", \"1\")\n+            .setDoc(Requests.INDEX_CONTENT_TYPE, \"field\", \"value2\").setTimeout(timeout).get());\n+\n+        client(randomFrom(nodesWithShards)).prepareIndex(\"test1\").setId(\"1\")\n+            .setSource(XContentFactory.jsonBuilder().startObject().endObject()).setTimeout(timeout).get();\n+\n+        expectThrows(UnavailableShardsException.class, () -> client(partitionedNode).prepareIndex(\"test1\").setId(\"1\")\n+            .setSource(XContentFactory.jsonBuilder().startObject().endObject()).setTimeout(timeout).get());\n+", "originalCommit": "97b9b68215e6e8b3ba54c4f78b06ad3040f1a2fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MzI3OA==", "url": "https://github.com/elastic/elasticsearch/pull/60605#discussion_r469053278", "bodyText": "added in d9d2e10", "author": "ywelsch", "createdAt": "2020-08-12T07:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY5NTEwNQ=="}], "type": "inlineReview"}, {"oid": "d9d2e10f07e921fd3c71ab9579e7158a1f836182", "url": "https://github.com/elastic/elasticsearch/commit/d9d2e10f07e921fd3c71ab9579e7158a1f836182", "message": "extend test with dynamic index creation and dynamic mappings", "committedDate": "2020-08-12T07:14:29Z", "type": "commit"}, {"oid": "51f5b5351325c44300e7c1eed49ce8ba59c5a741", "url": "https://github.com/elastic/elasticsearch/commit/51f5b5351325c44300e7c1eed49ce8ba59c5a741", "message": "Merge remote-tracking branch 'elastic/master' into no_master_metadata_writes", "committedDate": "2020-08-12T07:14:55Z", "type": "commit"}]}