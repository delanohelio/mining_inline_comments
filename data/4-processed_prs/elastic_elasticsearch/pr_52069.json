{"pr_number": 52069, "pr_title": "QL: move query AST from SQL to QL", "pr_createdAt": "2020-02-07T17:57:45Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52069", "timeline": [{"oid": "e37f54dbbb38ff2369e9df39c9a74190458d2aa1", "url": "https://github.com/elastic/elasticsearch/commit/e37f54dbbb38ff2369e9df39c9a74190458d2aa1", "message": "QL: move query AST from SQL to QL", "committedDate": "2020-02-07T17:55:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUyODU1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52069#discussion_r376528555", "bodyText": "I guess this would be the case of something like:\nSELECT * FROM test WHERE test.a = test.b\n\n\nIsn't this caught earlier?\n\nShould we add a test for this exception?", "author": "matriv", "createdAt": "2020-02-07T18:04:17Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/querydsl/query/TermsQuery.java", "diffHunk": "@@ -31,7 +34,16 @@ public TermsQuery(Source source, String term, List<Expression> values) {\n         if (values.isEmpty()) {\n             this.values = Collections.emptySet();\n         } else {\n-            this.values = new LinkedHashSet<>(Foldables.valuesOf(values, values.get(0).dataType()));\n+            DataType dt = values.get(0).dataType();\n+            Set<Object> set = new LinkedHashSet<>(CollectionUtils.mapSize(values.size()));\n+            for (Expression e : values) {\n+                if (e.foldable()) {\n+                    set.add(DataTypeConverter.convert(e.fold(), dt));\n+                } else {\n+                    throw new QlIllegalArgumentException(\"Cannot determine value for {}\", e);", "originalCommit": "e37f54dbbb38ff2369e9df39c9a74190458d2aa1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUzOTMxMA==", "url": "https://github.com/elastic/elasticsearch/pull/52069#discussion_r376539310", "bodyText": "This is the intermediate query AST - in this case terms will be more like A in (1, 2).\nThe check there is a translation of the existing code - which is defensive - if one of the values cannot be folded and it hasn't been caught, bail out.\nAn alternative would be to simply add the folded values directly.", "author": "costin", "createdAt": "2020-02-07T18:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUyODU1NQ=="}], "type": "inlineReview"}, {"oid": "fb55e153029c955a734324592b516503efd1782e", "url": "https://github.com/elastic/elasticsearch/commit/fb55e153029c955a734324592b516503efd1782e", "message": "Rework TermsQuery translation", "committedDate": "2020-02-07T19:59:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU4MjAxMg==", "url": "https://github.com/elastic/elasticsearch/pull/52069#discussion_r376582012", "bodyText": "@matriv This case of eliminating nulls need to be moved from the query to the optimizer (maybe in a dedicated rule).\nIt seems to be inconsistent with the foldable method - currently In has a fairly scattered behavior when it comes to list that would be good to centralize.", "author": "costin", "createdAt": "2020-02-07T20:03:15Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/planner/QueryTranslator.java", "diffHunk": "@@ -584,9 +590,17 @@ protected QueryTranslation asQuery(In in, boolean onAggs) {\n             else {\n                 Query q = null;\n                 if (in.value() instanceof FieldAttribute) {\n-                    FieldAttribute fa = (FieldAttribute) in.value();\n                     // equality should always be against an exact match (which is important for strings)\n-                    q = new TermsQuery(in.source(), fa.exactAttribute().name(), in.list());\n+                    FieldAttribute fa = (FieldAttribute) in.value();\n+                    List<Expression> list = in.list();\n+                    // TODO: this needs to be handled inside the optimizer", "originalCommit": "fb55e153029c955a734324592b516503efd1782e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU5MDA3NA==", "url": "https://github.com/elastic/elasticsearch/pull/52069#discussion_r376590074", "bodyText": "What was the issue? which tests were failing?\nThe In uses a HashSet to eliminate duplicates but if there are nulls in the list of values it keeps at list one, in order to implement the following behavior (adopted from Postgres):\npostgres=# select 1 IN (2, 3, null);\n ?column?\n----------\n\n(1 row)\n\npostgres=# select 1 IN (1, 2, 3, null);\n ?column?\n----------\n t\n(1 row)\n\npostgres=# select 1 IN (2, 3);\n ?column?\n----------\n f\n(1 row)\n\nSo if there is no match in the list, and there a null in the list, we should return null instead of false.", "author": "matriv", "createdAt": "2020-02-07T20:23:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU4MjAxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcyMjg4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52069#discussion_r376722885", "bodyText": "Eliminating the null from the list of values before doing the translation. This logic should be externalized from the query translation which should only worry about that not do any clean-up.", "author": "costin", "createdAt": "2020-02-08T17:39:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU4MjAxMg=="}], "type": "inlineReview"}]}