{"pr_number": 62974, "pr_title": "Move FieldMapper#valueFetcher to MappedFieldType", "pr_createdAt": "2020-09-28T17:41:38Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62974", "timeline": [{"oid": "5b74dde6424c6392f787148e7b9330dc28f8d516", "url": "https://github.com/elastic/elasticsearch/commit/5b74dde6424c6392f787148e7b9330dc28f8d516", "message": "WIP", "committedDate": "2020-09-28T10:14:43Z", "type": "commit"}, {"oid": "5b13f4c56c2177ff581933a150a4652e2ad4766d", "url": "https://github.com/elastic/elasticsearch/commit/5b13f4c56c2177ff581933a150a4652e2ad4766d", "message": "Move valueFetcher() from FieldMapper to MappedFieldType", "committedDate": "2020-09-28T15:15:22Z", "type": "commit"}, {"oid": "0f750b9cb5fcedc9f43bd4511b771d6369e6cda1", "url": "https://github.com/elastic/elasticsearch/commit/0f750b9cb5fcedc9f43bd4511b771d6369e6cda1", "message": "Merge remote-tracking branch 'origin/master' into mapper/valuefetcher-ft", "committedDate": "2020-09-28T15:16:34Z", "type": "commit"}, {"oid": "d450600079f018d18f130178bad6bc63546daf99", "url": "https://github.com/elastic/elasticsearch/commit/d450600079f018d18f130178bad6bc63546daf99", "message": "tests", "committedDate": "2020-09-28T17:35:55Z", "type": "commit"}, {"oid": "1d4ec994bddc44f59d835cd695fe20b7a7724580", "url": "https://github.com/elastic/elasticsearch/commit/1d4ec994bddc44f59d835cd695fe20b7a7724580", "message": "test jar hell; unsigned long null values", "committedDate": "2020-09-29T07:58:59Z", "type": "commit"}, {"oid": "4cfc51ddd1772c18e3100d9988942dd851f2744e", "url": "https://github.com/elastic/elasticsearch/commit/4cfc51ddd1772c18e3100d9988942dd851f2744e", "message": "spotless", "committedDate": "2020-09-29T08:05:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNzc0NA==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496127744", "bodyText": "These telescoping constructors are getting too complicated now - one idea I have for a follow-up is to add a FieldCharacteristics wrapper object that takes the (indexed, docvales, stored, meta) tuple, analogous to TextSearchInfo, and give both of these 'holder' objects constructors that take Parameter sets directly, so that you can go FieldCharacteristics.build(index, hasDocValues, stored, meta) directly in build and remove some of the ceremony.", "author": "romseygeek", "createdAt": "2020-09-28T17:46:53Z", "path": "modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/ScaledFloatFieldMapper.java", "diffHunk": "@@ -122,7 +122,7 @@ Builder nullValue(double nullValue) {\n         @Override\n         public ScaledFloatFieldMapper build(BuilderContext context) {\n             ScaledFloatFieldType type = new ScaledFloatFieldType(buildFullName(context), indexed.getValue(), stored.getValue(),\n-                hasDocValues.getValue(), meta.getValue(), scalingFactor.getValue());\n+                hasDocValues.getValue(), meta.getValue(), scalingFactor.getValue(), nullValue.getValue());", "originalCommit": "d450600079f018d18f130178bad6bc63546daf99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyOTI5NA==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496129294", "bodyText": "I think we can wrap this up more nicely as well in a followup, passing a Function<Object, String> parsing object here that is shared with the FieldMapper impl so that we don't need to a) pass nullValue and ignoreAbove and b) duplicate the relevant logic.", "author": "romseygeek", "createdAt": "2020-09-28T17:49:45Z", "path": "plugins/analysis-icu/src/main/java/org/elasticsearch/index/mapper/ICUCollationKeywordFieldMapper.java", "diffHunk": "@@ -68,31 +68,52 @@\n             FIELD_TYPE.freeze();\n         }\n \n-        public static final String NULL_VALUE = null;\n         public static final int IGNORE_ABOVE = Integer.MAX_VALUE;\n     }\n \n     public static final class CollationFieldType extends StringFieldType {\n         private final Collator collator;\n+        private final String nullValue;\n+        private final int ignoreAbove;\n \n         public CollationFieldType(String name, boolean isSearchable, boolean isStored, boolean hasDocValues,\n-                                  Collator collator, Map<String, String> meta) {\n+                                  Collator collator, String nullValue, int ignoreAbove, Map<String, String> meta) {\n             super(name, isSearchable, isStored, hasDocValues, TextSearchInfo.SIMPLE_MATCH_ONLY, meta);", "originalCommit": "d450600079f018d18f130178bad6bc63546daf99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyOTg2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496129863", "bodyText": "And indeed, we can probably add a factory function to SourceValueFetcher that takes a parsing function as well and further reduce the boilerplate.", "author": "romseygeek", "createdAt": "2020-09-28T17:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyOTI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1NDczNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r499754735", "bodyText": "I tried this out when initially designing the change, and it proved difficult to share the parsing logic. I wrote up the details in this draft PR: #56473. But I would love to discuss further if you find a way forward!", "author": "jtibshirani", "createdAt": "2020-10-05T17:21:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyOTI5NA=="}], "type": "inlineReview"}, {"oid": "3a7494a436e07f31cdcf081c1f5acb4f2c633ccd", "url": "https://github.com/elastic/elasticsearch/commit/3a7494a436e07f31cdcf081c1f5acb4f2c633ccd", "message": "const keyword tests", "committedDate": "2020-09-29T08:34:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc2MzI3NA==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496763274", "bodyText": "how have we replaced three methods that throw with two that throw and one that does stuff?", "author": "javanna", "createdAt": "2020-09-29T14:27:16Z", "path": "modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/SearchAsYouTypeFieldMapper.java", "diffHunk": "@@ -270,6 +270,19 @@ private ShingleFieldType shingleFieldForPositions(int positions) {\n             return shingleFields[Math.min(indexFromShingleSize, shingleFields.length - 1)];\n         }\n \n+        @Override\n+        public ValueFetcher valueFetcher(MapperService mapperService, SearchLookup searchLookup, String format) {\n+            if (format != null) {\n+                throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] doesn't support formats.\");\n+            }\n+            return new SourceValueFetcher(name(), mapperService, false) {\n+                @Override\n+                protected Object parseSourceValue(Object value) {\n+                    return value.toString();\n+                }\n+            };\n+        }", "originalCommit": "3a7494a436e07f31cdcf081c1f5acb4f2c633ccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5NzcwMg==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496797702", "bodyText": "We can actually return the initial value for the main field here; but I can change it to just move the existing change and then we can implement it properly in a followup?", "author": "romseygeek", "createdAt": "2020-09-29T15:09:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc2MzI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwMTAwNA==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496801004", "bodyText": "We can actually return the initial value for the main field here; but I can change it to just move the existing change and then we can implement it properly in a followup?", "author": "romseygeek", "createdAt": "2020-09-29T15:14:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc2MzI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwNDAzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496804031", "bodyText": "I wonder what Julie will think of this, so maybe it makes sense to do it separately, if you don't mind.", "author": "javanna", "createdAt": "2020-09-29T15:18:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc2MzI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0ODY3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r499748673", "bodyText": "Sounds good to me to discuss/ implement in a follow-up!", "author": "jtibshirani", "createdAt": "2020-10-05T17:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc2MzI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3MDM2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496770365", "bodyText": "this is an existing issue, so I would not address it now and you are probably already on it, but it looks like this same implementation is duplicated in quite some places? Or are there subtle differences?", "author": "javanna", "createdAt": "2020-09-29T14:36:00Z", "path": "plugins/mapper-murmur3/src/main/java/org/elasticsearch/index/mapper/murmur3/Murmur3FieldMapper.java", "diffHunk": "@@ -111,6 +111,19 @@ public String typeName() {\n             return new SortedNumericIndexFieldData.Builder(name(), NumericType.LONG);\n         }\n \n+        @Override\n+        public ValueFetcher valueFetcher(MapperService mapperService, SearchLookup searchLookup, String format) {\n+            if (format != null) {\n+                throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] doesn't support formats.\");\n+            }\n+            return new SourceValueFetcher(name(), mapperService, false) {\n+                @Override\n+                protected String parseSourceValue(Object value) {\n+                    return value.toString();\n+                }\n+            };\n+        }", "originalCommit": "3a7494a436e07f31cdcf081c1f5acb4f2c633ccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5ODMwOA==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496798308", "bodyText": "Yes, this can definitely be replaced with a common implementation in a lot of cases.  I didn't want to do that in this case because the PR is big enough as it is...", "author": "romseygeek", "createdAt": "2020-09-29T15:10:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3MDM2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwNDE5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496804191", "bodyText": "makes sense", "author": "javanna", "createdAt": "2020-09-29T15:18:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3MDM2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1MDM3OA==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r499750378", "bodyText": "+1 we could certainly add some shared SourceValueFetcher implementations, for example an 'identity' fetcher and a 'string' fetcher. When introducing the feature I just tried to keep the design as minimal as possible.", "author": "jtibshirani", "createdAt": "2020-10-05T17:13:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3MDM2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3NDAxNw==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496774017", "bodyText": "we don't have a base class for metadata field types, yet they have commonalities, is it worth to add one at some point? Thinking out loud, not sure about it.", "author": "javanna", "createdAt": "2020-09-29T14:40:33Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldNamesFieldMapper.java", "diffHunk": "@@ -129,6 +130,11 @@ public boolean isEnabled() {\n             return enabled;\n         }\n \n+        @Override\n+        public ValueFetcher valueFetcher(MapperService mapperService, SearchLookup lookup, String format) {\n+            throw new UnsupportedOperationException(\"Cannot fetch values for internal field [\" + name() + \"].\");", "originalCommit": "3a7494a436e07f31cdcf081c1f5acb4f2c633ccd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3NTAwOA==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496775008", "bodyText": "wasn't this throwing before based on MetadataFieldMapper#valueFetcher ?", "author": "javanna", "createdAt": "2020-09-29T14:41:44Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/IndexFieldMapper.java", "diffHunk": "@@ -71,6 +71,11 @@ public Query existsQuery(QueryShardContext context) {\n         public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName, Supplier<SearchLookup> searchLookup) {\n             return new ConstantIndexFieldData.Builder(mapperService -> fullyQualifiedIndexName, name(), CoreValuesSourceType.BYTES);\n         }\n+\n+        @Override\n+        public ValueFetcher valueFetcher(MapperService mapperService, SearchLookup searchLookup, String format) {\n+            return lookup -> Collections.singletonList(mapperService.index().getName());\n+        }", "originalCommit": "3a7494a436e07f31cdcf081c1f5acb4f2c633ccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5ODk4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496798983", "bodyText": "It was, I implemented it because it can be implemented but as you point out later on we don't actually try and fetch values from metadata fields so it should go back to throwing a UOE", "author": "romseygeek", "createdAt": "2020-09-29T15:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3NTAwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwNDYyNg==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496804626", "bodyText": "sounds good thanks, maybe we should re-discuss whether fetching metadata fields should be possible.", "author": "javanna", "createdAt": "2020-09-29T15:19:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3NTAwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1MjI4OA==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r499752288", "bodyText": "We're tracking the meta field question in #60985, it would be great to discuss and maybe implement this in a follow-up.\nMy intuition is that users will want to fetch metadata fields. One example is _size, whose values aren't easy to pull off the response.", "author": "jtibshirani", "createdAt": "2020-10-05T17:16:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3NTAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4MjMyNw==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496782327", "bodyText": "could this be fetched before?", "author": "javanna", "createdAt": "2020-09-29T14:50:34Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/SeqNoFieldMapper.java", "diffHunk": "@@ -121,6 +122,11 @@ private long parse(Object value) {\n             return Long.parseLong(value.toString());\n         }\n \n+        @Override\n+        public ValueFetcher valueFetcher(MapperService mapperService, SearchLookup lookup, String format) {\n+            return new DocValueFetcher(DocValueFormat.RAW, lookup.doc().getForField(this));", "originalCommit": "3a7494a436e07f31cdcf081c1f5acb4f2c633ccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5OTI4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496799283", "bodyText": "Will change it back", "author": "romseygeek", "createdAt": "2020-09-29T15:11:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4MjMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4NDE5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496784197", "bodyText": "weren't these two throwing exception before?", "author": "javanna", "createdAt": "2020-09-29T14:52:52Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/TextFieldMapper.java", "diffHunk": "@@ -415,6 +420,11 @@ public Query existsQuery(QueryShardContext context) {\n             this.hasPositions = hasPositions;\n         }\n \n+        @Override\n+        public ValueFetcher valueFetcher(MapperService mapperService, SearchLookup searchLookup, String format) {\n+            return parentField.valueFetcher(mapperService, searchLookup, format);\n+        }", "originalCommit": "3a7494a436e07f31cdcf081c1f5acb4f2c633ccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwMDI3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496800272", "bodyText": "They were; I think this impl is in fact the correct one, but I can change it back and we can look at it separately?", "author": "romseygeek", "createdAt": "2020-09-29T15:13:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4NDE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwNTc5OA==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496805798", "bodyText": "I have no strong opinion, maybe highlight in the description that this change is also made while at it, or do it separately?", "author": "javanna", "createdAt": "2020-09-29T15:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4NDE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4NDU3MA==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496784570", "bodyText": "could this be fetched before?", "author": "javanna", "createdAt": "2020-09-29T14:53:21Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java", "diffHunk": "@@ -76,6 +76,11 @@ public Query existsQuery(QueryShardContext context) {\n             return new ConstantIndexFieldData.Builder(typeFunction, name(), CoreValuesSourceType.BYTES);\n         }\n \n+        @Override\n+        public ValueFetcher valueFetcher(MapperService mapperService, SearchLookup searchLookup, String format) {\n+            return lookup -> Collections.singletonList(mapperService.documentMapper().type());", "originalCommit": "3a7494a436e07f31cdcf081c1f5acb4f2c633ccd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4NDk3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496784971", "bodyText": "could this be fetched before?", "author": "javanna", "createdAt": "2020-09-29T14:53:49Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/VersionFieldMapper.java", "diffHunk": "@@ -53,6 +55,11 @@ public String typeName() {\n         public Query termQuery(Object value, QueryShardContext context) {\n             throw new QueryShardException(context, \"The _version field is not searchable\");\n         }\n+\n+        @Override\n+        public ValueFetcher valueFetcher(MapperService mapperService, SearchLookup lookup, String format) {\n+            return new DocValueFetcher(DocValueFormat.RAW, lookup.doc().getForField(this));", "originalCommit": "3a7494a436e07f31cdcf081c1f5acb4f2c633ccd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4NjI0NA==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496786244", "bodyText": "so, we skip metadata fields but some of them are now supporting fetch? What am I missing?", "author": "javanna", "createdAt": "2020-09-29T14:55:18Z", "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -55,19 +52,11 @@ public static FieldFetcher create(MapperService mapperService,\n \n             Collection<String> concreteFields = mapperService.simpleMatchToFullName(fieldPattern);\n             for (String field : concreteFields) {\n-                Mapper mapper = fieldMappers.getMapper(field);\n-                if (mapper == null || mapperService.isMetadataField(field)) {\n+                MappedFieldType ft = mapperService.fieldType(field);\n+                if (ft == null || mapperService.isMetadataField(field)) {\n                     continue;", "originalCommit": "3a7494a436e07f31cdcf081c1f5acb4f2c633ccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwMDYyMg==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496800622", "bodyText": "I missed that we skipped the metadata fields, I'll change them all to throw instead.", "author": "romseygeek", "createdAt": "2020-09-29T15:13:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4NjI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5MTY0MA==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r496791640", "bodyText": "I was wondering the same, or even if we should do so. when would this field type be looked up compared to the other one that implements valueFetcher?", "author": "javanna", "createdAt": "2020-09-29T15:01:57Z", "path": "x-pack/plugin/mapper-flattened/src/main/java/org/elasticsearch/xpack/flattened/mapper/FlatObjectFieldMapper.java", "diffHunk": "@@ -319,6 +320,11 @@ public BytesRef indexedValueForSearch(Object value) {\n             failIfNoDocValues();\n             return new KeyedFlatObjectFieldData.Builder(name(), key, CoreValuesSourceType.BYTES);\n         }\n+\n+        @Override\n+        public ValueFetcher valueFetcher(MapperService mapperService, SearchLookup searchLookup, String format) {\n+            throw new UnsupportedOperationException();  // TODO can we implement this?", "originalCommit": "3a7494a436e07f31cdcf081c1f5acb4f2c633ccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczOTUzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r499739531", "bodyText": "This is a good question, I'll propose an idea in a follow-up PR.", "author": "jtibshirani", "createdAt": "2020-10-05T16:53:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5MTY0MA=="}], "type": "inlineReview"}, {"oid": "ab26af50462ac7b678c3d37db3c21fd157b54449", "url": "https://github.com/elastic/elasticsearch/commit/ab26af50462ac7b678c3d37db3c21fd157b54449", "message": "Merge remote-tracking branch 'origin/master' into mapper/valuefetcher-ft", "committedDate": "2020-09-29T16:18:14Z", "type": "commit"}, {"oid": "477b48bc93e4cbd9c921f29bf52c9113a30a8639", "url": "https://github.com/elastic/elasticsearch/commit/477b48bc93e4cbd9c921f29bf52c9113a30a8639", "message": "feedback", "committedDate": "2020-09-29T16:23:14Z", "type": "commit"}, {"oid": "11c4fb17cee43cb62097f314a143a5577f12ff78", "url": "https://github.com/elastic/elasticsearch/commit/11c4fb17cee43cb62097f314a143a5577f12ff78", "message": "Merge remote-tracking branch 'origin/master' into mapper/valuefetcher-ft", "committedDate": "2020-09-29T19:53:58Z", "type": "commit"}, {"oid": "adc8b9a315fef4cc37fe7fcc3ba4ebe9af56015b", "url": "https://github.com/elastic/elasticsearch/commit/adc8b9a315fef4cc37fe7fcc3ba4ebe9af56015b", "message": "compilation", "committedDate": "2020-09-30T08:07:51Z", "type": "commit"}, {"oid": "1d25eeb733a36fab6525f5bd03f5c59136f96118", "url": "https://github.com/elastic/elasticsearch/commit/1d25eeb733a36fab6525f5bd03f5c59136f96118", "message": "Merge remote-tracking branch 'origin/master' into mapper/valuefetcher-ft", "committedDate": "2020-10-03T15:50:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2NzUzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r499767531", "bodyText": "After this change, I think value parsing will always fail -- since it uses NumberFieldType, it will attempt to parse a piece of text as a number.", "author": "jtibshirani", "createdAt": "2020-10-05T17:45:13Z", "path": "modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/TokenCountFieldMapper.java", "diffHunk": "@@ -129,20 +130,6 @@ protected void parseCreateField(ParseContext context) throws IOException {\n         );\n     }\n \n-    @Override", "originalCommit": "1d25eeb733a36fab6525f5bd03f5c59136f96118", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2ODA4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r499768087", "bodyText": "Very happy we removed this \ud83c\udf89", "author": "jtibshirani", "createdAt": "2020-10-05T17:46:15Z", "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -55,19 +52,11 @@ public static FieldFetcher create(MapperService mapperService,\n \n             Collection<String> concreteFields = mapperService.simpleMatchToFullName(fieldPattern);\n             for (String field : concreteFields) {\n-                Mapper mapper = fieldMappers.getMapper(field);\n-                if (mapper == null || mapperService.isMetadataField(field)) {\n+                MappedFieldType ft = mapperService.fieldType(field);\n+                if (ft == null || mapperService.isMetadataField(field)) {\n                     continue;\n                 }\n-\n-                if (mapper instanceof FieldAliasMapper) {", "originalCommit": "1d25eeb733a36fab6525f5bd03f5c59136f96118", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5NzIwNA==", "url": "https://github.com/elastic/elasticsearch/pull/62974#discussion_r500497204", "bodyText": "One other change I noticed -- previously we always passed the result of FieldMapper#parsesArrayValue instead of hard-coding the booleans. Now there is nothing really tying this to parsesArrayValue and it could be easily overlooked. I wonder how we could make this more robust.\nAn update: I opened #63354 with a small improvement.", "author": "jtibshirani", "createdAt": "2020-10-06T18:08:33Z", "path": "modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/RankFeatureFieldMapper.java", "diffHunk": "@@ -113,6 +113,19 @@ public Query existsQuery(QueryShardContext context) {\n             throw new IllegalArgumentException(\"[rank_feature] fields do not support sorting, scripting or aggregating\");\n         }\n \n+        @Override\n+        public ValueFetcher valueFetcher(MapperService mapperService, SearchLookup searchLookup, String format) {\n+            if (format != null) {\n+                throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] doesn't support formats.\");\n+            }\n+            return new SourceValueFetcher(name(), mapperService, false) {", "originalCommit": "1d25eeb733a36fab6525f5bd03f5c59136f96118", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}