{"pr_number": 58663, "pr_title": "Add declarative parameters to FieldMappers", "pr_createdAt": "2020-06-29T12:05:31Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58663", "timeline": [{"oid": "9dda2f32b990cf2b35885e058d6c03e14a35bd60", "url": "https://github.com/elastic/elasticsearch/commit/9dda2f32b990cf2b35885e058d6c03e14a35bd60", "message": "First go: need to fix merging with BuilderContext", "committedDate": "2020-06-23T09:12:08Z", "type": "commit"}, {"oid": "6c118f36f0d1a78a80a4b2a1a621efb1ac55a392", "url": "https://github.com/elastic/elasticsearch/commit/6c118f36f0d1a78a80a4b2a1a621efb1ac55a392", "message": "Merge remote-tracking branch 'origin/master' into mapper/mergebuilders", "committedDate": "2020-06-28T11:41:39Z", "type": "commit"}, {"oid": "56ad229abe0592f771626c5ea076894841680085", "url": "https://github.com/elastic/elasticsearch/commit/56ad229abe0592f771626c5ea076894841680085", "message": "dedicated tests for parametrized mapper", "committedDate": "2020-06-29T11:24:58Z", "type": "commit"}, {"oid": "da0aca5066de8525dd97a03a76265e351566c021", "url": "https://github.com/elastic/elasticsearch/commit/da0aca5066de8525dd97a03a76265e351566c021", "message": "tests", "committedDate": "2020-06-29T11:45:21Z", "type": "commit"}, {"oid": "6e99626bb19412788cb6f08a61291c7e573f1579", "url": "https://github.com/elastic/elasticsearch/commit/6e99626bb19412788cb6f08a61291c7e573f1579", "message": "precommit", "committedDate": "2020-06-29T11:53:00Z", "type": "commit"}, {"oid": "7326c49ec1bee5377382e200f3489b86909b36d9", "url": "https://github.com/elastic/elasticsearch/commit/7326c49ec1bee5377382e200f3489b86909b36d9", "message": "meta parsing", "committedDate": "2020-06-29T12:58:42Z", "type": "commit"}, {"oid": "ae14ac5a30c1ccf9e448d7713943e46381abcebb", "url": "https://github.com/elastic/elasticsearch/commit/ae14ac5a30c1ccf9e448d7713943e46381abcebb", "message": "Merge remote-tracking branch 'origin/master' into mapper/mergebuilders", "committedDate": "2020-06-29T12:58:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2NjEzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447066131", "bodyText": "Note to self - these were the defaults so they are safe to drop.", "author": "nik9000", "createdAt": "2020-06-29T15:38:47Z", "path": "modules/percolator/src/main/java/org/elasticsearch/percolator/PercolatorFieldMapper.java", "diffHunk": "@@ -157,8 +157,6 @@ static KeywordFieldMapper createExtractQueryFieldBuilder(String name, BuilderCon\n         static BinaryFieldMapper createQueryBuilderFieldBuilder(BuilderContext context) {\n             BinaryFieldMapper.Builder builder = new BinaryFieldMapper.Builder(QUERY_BUILDER_FIELD_NAME);\n             builder.docValues(true);\n-            builder.indexOptions(IndexOptions.NONE);", "originalCommit": "ae14ac5a30c1ccf9e448d7713943e46381abcebb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3MDEyMA==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447070120", "bodyText": "I think I'd import the inner class to make these a little shorter.", "author": "nik9000", "createdAt": "2020-06-29T15:44:21Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/ParametrizedMapperTests.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class ParametrizedMapperTests extends ESTestCase {\n+\n+    private static TestMapper toType(Mapper in) {\n+        return (TestMapper) in;\n+    }\n+\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        final ParametrizedFieldMapper.Parameter<Boolean> fixed", "originalCommit": "ae14ac5a30c1ccf9e448d7713943e46381abcebb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3MDM5OA==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447070398", "bodyText": "I know some folks hate importing inner classes but I don't really have hard and fast rules and think in this case it'd be easier to read.", "author": "nik9000", "createdAt": "2020-06-29T15:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3MDEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3NTI1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447075255", "bodyText": "These smell a little like our settings which have grown a bit difficult to read over the years. There, I think a builder pattern would have helped deal with how many optional things there are. But here I dunno.\nI think merger might need to take the current value so it can make a call on more complex stuff, right?\nIf a value isn't updateable do you need to define a merger at all?", "author": "nik9000", "createdAt": "2020-06-29T15:51:58Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/ParametrizedFieldMapper.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import joptsimple.internal.Strings;\n+import org.apache.lucene.document.FieldType;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+public abstract class ParametrizedFieldMapper extends FieldMapper {\n+\n+    protected ParametrizedFieldMapper(String simpleName, MappedFieldType mappedFieldType, MultiFields multiFields, CopyTo copyTo) {\n+        super(simpleName, new FieldType(), mappedFieldType, multiFields, copyTo);\n+    }\n+\n+    public abstract ParametrizedFieldMapper.Builder getMergeBuilder();\n+\n+    @Override\n+    public final ParametrizedFieldMapper merge(Mapper mergeWith) {\n+\n+        if (mergeWith instanceof FieldMapper == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + mergeWith.getClass().getSimpleName() + \"]\");\n+        }\n+        if (Objects.equals(this.getClass(), mergeWith.getClass()) == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + ((FieldMapper) mergeWith).contentType() + \"]\");\n+        }\n+\n+        ParametrizedFieldMapper.Builder builder = getMergeBuilder();\n+        Conflicts conflicts = new Conflicts(name());\n+        builder.merge((FieldMapper) mergeWith, conflicts);\n+        conflicts.check();\n+        return builder.build(new BuilderContext(Settings.EMPTY, parentPath(name())));\n+    }\n+\n+    private static ContentPath parentPath(String name) {\n+        int endPos = name.lastIndexOf(\".\");\n+        if (endPos == -1) {\n+            return new ContentPath(0);\n+        }\n+        return new ContentPath(name.substring(endPos));\n+    }\n+\n+    @Override\n+    protected final void mergeOptions(FieldMapper other, List<String> conflicts) {\n+        // TODO remove when everything is parametrized\n+    }\n+\n+    @Override\n+    public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject(simpleName());\n+        builder.field(\"type\", contentType());\n+        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n+        getMergeBuilder().toXContent(builder, includeDefaults);\n+        multiFields.toXContent(builder, params);\n+        copyTo.toXContent(builder, params);\n+        return builder.endObject();\n+    }\n+\n+    public static final class Parameter<T> {\n+\n+        private final T defaultValue;\n+        private final BiFunction<String, Object, T> parser;\n+        private final Function<FieldMapper, T> merger;\n+        public final String name;\n+        public final boolean updateable;\n+        private boolean acceptsNull = false;\n+        private T value;\n+        private boolean frozen = false;\n+\n+        public Parameter(String name, boolean updateable, T defaultValue,\n+                         BiFunction<String, Object, T> parser, Function<FieldMapper, T> merger) {\n+            this.name = name;\n+            this.defaultValue = defaultValue;\n+            this.value = defaultValue;\n+            this.parser = parser;\n+            this.merger = merger;\n+            this.updateable = updateable;\n+        }\n+\n+        public T getValue() {\n+            return value;\n+        }\n+\n+        public Parameter<T> acceptsNull() {\n+            this.acceptsNull = true;\n+            return this;\n+        }\n+\n+        public Parameter<T> init(FieldMapper toInit) {\n+            assert frozen == false;\n+            this.value = merger.apply(toInit);\n+            return this;\n+        }\n+\n+        public Parameter<T> update(T value) {\n+            this.value = value;\n+            return this;\n+        }\n+\n+        public Parameter<T> parse(String field, Object in) {\n+            assert frozen == false;\n+            this.value = parser.apply(field, in);\n+            return this;\n+        }\n+\n+        public Parameter<T> merge(FieldMapper toMerge, Conflicts conflicts) {\n+            T value = merger.apply(toMerge);\n+            if (frozen && Objects.equals(this.value, value) == false) {\n+                conflicts.addConflict(name, this.value.toString(), value.toString());\n+            } else {\n+                this.value = value;\n+            }\n+            return this;\n+        }\n+\n+        public Parameter<T> freeze() {\n+            this.frozen = true;\n+            return this;\n+        }\n+\n+        public XContentBuilder toXContent(XContentBuilder builder, boolean includeDefaults) throws IOException {\n+            if (includeDefaults || (Objects.equals(defaultValue, value) == false)) {\n+                builder.field(name, value);\n+            }\n+            return builder;\n+        }\n+\n+        public static Parameter<Boolean> boolParam(String name, boolean updateable,", "originalCommit": "ae14ac5a30c1ccf9e448d7713943e46381abcebb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3OTk5MA==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447079990", "bodyText": "Actually, looking above you use acceptsNull in a very bulder like way, which I'm cool with.\nI think it'd be good to make the \"for declaration\" method public with javadoc. And the \"for use by ParameterizedFieldMapper\" methods private or at least package private. That way it is more obvious what we can call when building the mappers.\nI'm sort of sad that this is bit of a parallel world to the xcontent parsers that we already have, but I know how we got here. And it is where we are. So, yeah, I'm +1 on building it.", "author": "nik9000", "createdAt": "2020-06-29T15:58:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3NTI1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY2ODQyMw==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447668423", "bodyText": "++ to making the 'used internally only' methods private.  I've renamed 'merger' to 'initializer' as that's what it does, takes an initial value from an existing mapper.", "author": "romseygeek", "createdAt": "2020-06-30T13:09:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3NTI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3NjE0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447076142", "bodyText": "Do you think it'd be clearer if merge checked for updateable?", "author": "nik9000", "createdAt": "2020-06-29T15:53:24Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/ParametrizedFieldMapper.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import joptsimple.internal.Strings;\n+import org.apache.lucene.document.FieldType;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+public abstract class ParametrizedFieldMapper extends FieldMapper {\n+\n+    protected ParametrizedFieldMapper(String simpleName, MappedFieldType mappedFieldType, MultiFields multiFields, CopyTo copyTo) {\n+        super(simpleName, new FieldType(), mappedFieldType, multiFields, copyTo);\n+    }\n+\n+    public abstract ParametrizedFieldMapper.Builder getMergeBuilder();\n+\n+    @Override\n+    public final ParametrizedFieldMapper merge(Mapper mergeWith) {\n+\n+        if (mergeWith instanceof FieldMapper == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + mergeWith.getClass().getSimpleName() + \"]\");\n+        }\n+        if (Objects.equals(this.getClass(), mergeWith.getClass()) == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + ((FieldMapper) mergeWith).contentType() + \"]\");\n+        }\n+\n+        ParametrizedFieldMapper.Builder builder = getMergeBuilder();\n+        Conflicts conflicts = new Conflicts(name());\n+        builder.merge((FieldMapper) mergeWith, conflicts);\n+        conflicts.check();\n+        return builder.build(new BuilderContext(Settings.EMPTY, parentPath(name())));\n+    }\n+\n+    private static ContentPath parentPath(String name) {\n+        int endPos = name.lastIndexOf(\".\");\n+        if (endPos == -1) {\n+            return new ContentPath(0);\n+        }\n+        return new ContentPath(name.substring(endPos));\n+    }\n+\n+    @Override\n+    protected final void mergeOptions(FieldMapper other, List<String> conflicts) {\n+        // TODO remove when everything is parametrized\n+    }\n+\n+    @Override\n+    public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject(simpleName());\n+        builder.field(\"type\", contentType());\n+        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n+        getMergeBuilder().toXContent(builder, includeDefaults);\n+        multiFields.toXContent(builder, params);\n+        copyTo.toXContent(builder, params);\n+        return builder.endObject();\n+    }\n+\n+    public static final class Parameter<T> {\n+\n+        private final T defaultValue;\n+        private final BiFunction<String, Object, T> parser;\n+        private final Function<FieldMapper, T> merger;\n+        public final String name;\n+        public final boolean updateable;\n+        private boolean acceptsNull = false;\n+        private T value;\n+        private boolean frozen = false;\n+\n+        public Parameter(String name, boolean updateable, T defaultValue,\n+                         BiFunction<String, Object, T> parser, Function<FieldMapper, T> merger) {\n+            this.name = name;\n+            this.defaultValue = defaultValue;\n+            this.value = defaultValue;\n+            this.parser = parser;\n+            this.merger = merger;\n+            this.updateable = updateable;\n+        }\n+\n+        public T getValue() {\n+            return value;\n+        }\n+\n+        public Parameter<T> acceptsNull() {\n+            this.acceptsNull = true;\n+            return this;\n+        }\n+\n+        public Parameter<T> init(FieldMapper toInit) {\n+            assert frozen == false;\n+            this.value = merger.apply(toInit);\n+            return this;\n+        }\n+\n+        public Parameter<T> update(T value) {\n+            this.value = value;\n+            return this;\n+        }\n+\n+        public Parameter<T> parse(String field, Object in) {\n+            assert frozen == false;\n+            this.value = parser.apply(field, in);\n+            return this;\n+        }\n+\n+        public Parameter<T> merge(FieldMapper toMerge, Conflicts conflicts) {\n+            T value = merger.apply(toMerge);\n+            if (frozen && Objects.equals(this.value, value) == false) {\n+                conflicts.addConflict(name, this.value.toString(), value.toString());\n+            } else {\n+                this.value = value;\n+            }\n+            return this;\n+        }\n+\n+        public Parameter<T> freeze() {\n+            this.frozen = true;\n+            return this;\n+        }\n+\n+        public XContentBuilder toXContent(XContentBuilder builder, boolean includeDefaults) throws IOException {\n+            if (includeDefaults || (Objects.equals(defaultValue, value) == false)) {\n+                builder.field(name, value);\n+            }\n+            return builder;\n+        }\n+\n+        public static Parameter<Boolean> boolParam(String name, boolean updateable,\n+                                                   Function<FieldMapper, Boolean> merger, boolean defaultValue) {\n+            return new Parameter<>(name, updateable, defaultValue, (n, o) -> XContentMapValues.nodeBooleanValue(o), merger);\n+        }\n+\n+        public static Parameter<Float> floatParam(String name, boolean updateable,\n+                                                  Function<FieldMapper, Float> merger, float defaultValue) {\n+            return new Parameter<>(name, updateable, defaultValue, (n, o) -> XContentMapValues.nodeFloatValue(o), merger);\n+        }\n+\n+        public static Parameter<String> stringParam(String name, boolean updateable,\n+                                                    Function<FieldMapper, String> merger, String defaultValue) {\n+            return new Parameter<>(name, updateable, defaultValue, (n, o) -> XContentMapValues.nodeStringValue(o, defaultValue), merger);\n+        }\n+    }\n+\n+    public static final class Conflicts {\n+\n+        private final String mapperName;\n+        private final List<String> conflicts = new ArrayList<>();\n+\n+        public Conflicts(String mapperName) {\n+            this.mapperName = mapperName;\n+        }\n+\n+        public void addConflict(String parameter, String existing, String toMerge) {\n+            conflicts.add(\"Cannot update parameter [\" + parameter + \"] from [\" + existing + \"] to [\" + toMerge + \"]\");\n+        }\n+\n+        public void check() {\n+            if (conflicts.isEmpty()) {\n+                return;\n+            }\n+            String message = \"Mapper for [\" + mapperName + \"] conflicts with existing mapper:\\n\\t\"\n+                + Strings.join(conflicts, \"\\n\\t\");\n+            throw new IllegalArgumentException(message);\n+        }\n+\n+    }\n+\n+    public abstract static class Builder extends Mapper.Builder<Builder> {\n+\n+        protected final MultiFields.Builder multiFieldsBuilder = new MultiFields.Builder();\n+        protected CopyTo.Builder copyTo = new CopyTo.Builder();\n+\n+        protected final Parameter<Map<String, String>> meta\n+            = new Parameter<>(\"meta\", true, Collections.emptyMap(), TypeParsers::parseMeta, m -> m.fieldType().meta());\n+\n+        protected Builder(String name) {\n+            super(name);\n+        }\n+\n+        protected Builder init(FieldMapper base) {\n+            for (Parameter<?> param : getParameters()) {\n+                param.init(base);\n+            }\n+            for (Mapper subField : base.multiFields) {\n+                multiFieldsBuilder.add(subField);\n+            }\n+            return this;\n+        }\n+\n+        public final void merge(FieldMapper in, Conflicts conflicts) {\n+            for (Parameter<?> param : getParameters()) {\n+                if (param.updateable == false) {", "originalCommit": "ae14ac5a30c1ccf9e448d7713943e46381abcebb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcwMDQ4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447700486", "bodyText": "Definitely, good spot.  Begone, freeze", "author": "romseygeek", "createdAt": "2020-06-30T13:53:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3NjE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3ODQxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447078419", "bodyText": "This makes me think merger isn't really the right name for this, actually - it is more like read.", "author": "nik9000", "createdAt": "2020-06-29T15:56:39Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/ParametrizedFieldMapper.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import joptsimple.internal.Strings;\n+import org.apache.lucene.document.FieldType;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+public abstract class ParametrizedFieldMapper extends FieldMapper {\n+\n+    protected ParametrizedFieldMapper(String simpleName, MappedFieldType mappedFieldType, MultiFields multiFields, CopyTo copyTo) {\n+        super(simpleName, new FieldType(), mappedFieldType, multiFields, copyTo);\n+    }\n+\n+    public abstract ParametrizedFieldMapper.Builder getMergeBuilder();\n+\n+    @Override\n+    public final ParametrizedFieldMapper merge(Mapper mergeWith) {\n+\n+        if (mergeWith instanceof FieldMapper == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + mergeWith.getClass().getSimpleName() + \"]\");\n+        }\n+        if (Objects.equals(this.getClass(), mergeWith.getClass()) == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + ((FieldMapper) mergeWith).contentType() + \"]\");\n+        }\n+\n+        ParametrizedFieldMapper.Builder builder = getMergeBuilder();\n+        Conflicts conflicts = new Conflicts(name());\n+        builder.merge((FieldMapper) mergeWith, conflicts);\n+        conflicts.check();\n+        return builder.build(new BuilderContext(Settings.EMPTY, parentPath(name())));\n+    }\n+\n+    private static ContentPath parentPath(String name) {\n+        int endPos = name.lastIndexOf(\".\");\n+        if (endPos == -1) {\n+            return new ContentPath(0);\n+        }\n+        return new ContentPath(name.substring(endPos));\n+    }\n+\n+    @Override\n+    protected final void mergeOptions(FieldMapper other, List<String> conflicts) {\n+        // TODO remove when everything is parametrized\n+    }\n+\n+    @Override\n+    public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject(simpleName());\n+        builder.field(\"type\", contentType());\n+        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n+        getMergeBuilder().toXContent(builder, includeDefaults);\n+        multiFields.toXContent(builder, params);\n+        copyTo.toXContent(builder, params);\n+        return builder.endObject();\n+    }\n+\n+    public static final class Parameter<T> {\n+\n+        private final T defaultValue;\n+        private final BiFunction<String, Object, T> parser;\n+        private final Function<FieldMapper, T> merger;\n+        public final String name;\n+        public final boolean updateable;\n+        private boolean acceptsNull = false;\n+        private T value;\n+        private boolean frozen = false;\n+\n+        public Parameter(String name, boolean updateable, T defaultValue,\n+                         BiFunction<String, Object, T> parser, Function<FieldMapper, T> merger) {\n+            this.name = name;\n+            this.defaultValue = defaultValue;\n+            this.value = defaultValue;\n+            this.parser = parser;\n+            this.merger = merger;\n+            this.updateable = updateable;\n+        }\n+\n+        public T getValue() {\n+            return value;\n+        }\n+\n+        public Parameter<T> acceptsNull() {\n+            this.acceptsNull = true;\n+            return this;\n+        }\n+\n+        public Parameter<T> init(FieldMapper toInit) {\n+            assert frozen == false;\n+            this.value = merger.apply(toInit);", "originalCommit": "ae14ac5a30c1ccf9e448d7713943e46381abcebb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcwMDIxNg==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447700216", "bodyText": "++ I've used initializer", "author": "romseygeek", "createdAt": "2020-06-30T13:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3ODQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA4MTMxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447081319", "bodyText": "If you make them package private that does a pretty good job implying they are only exposed for testing.", "author": "nik9000", "createdAt": "2020-06-29T16:00:44Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/BinaryFieldMapper.java", "diffHunk": "@@ -63,26 +61,34 @@\n         }\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n+    private static BinaryFieldMapper toType(FieldMapper in) {\n+        return (BinaryFieldMapper) in;\n+    }\n+\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        final Parameter<Boolean> stored = Parameter.boolParam(\"store\", false, m -> toType(m).stored, false);\n+        final Parameter<Boolean> hasDocValues = Parameter.boolParam(\"doc_values\", false, m -> toType(m).hasDocValues,  false);\n \n         public Builder(String name) {\n-            super(name, Defaults.FIELD_TYPE);\n-            hasDocValues = false;\n-            builder = this;\n+            super(name);\n+        }\n+\n+        // For testing", "originalCommit": "ae14ac5a30c1ccf9e448d7713943e46381abcebb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcwMDEwMg==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447700102", "bodyText": "It's used outside the package, annoyingly.  I've changed it so that if you need to set it programmatically you can use a constructor parameter.", "author": "romseygeek", "createdAt": "2020-06-30T13:53:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA4MTMxOQ=="}], "type": "inlineReview"}, {"oid": "5bb39b2de4645b21b88b06959e24a1ccdbb0aadb", "url": "https://github.com/elastic/elasticsearch/commit/5bb39b2de4645b21b88b06959e24a1ccdbb0aadb", "message": "Use simple name in merge builder", "committedDate": "2020-06-30T09:03:24Z", "type": "commit"}, {"oid": "a31b1a61c004292f517e70312c781ac8a0735262", "url": "https://github.com/elastic/elasticsearch/commit/a31b1a61c004292f517e70312c781ac8a0735262", "message": "Merge remote-tracking branch 'origin/master' into mapper/mergebuilders", "committedDate": "2020-06-30T12:51:45Z", "type": "commit"}, {"oid": "928a15f9cb2ab75d65c1448d7d32c490abf32b93", "url": "https://github.com/elastic/elasticsearch/commit/928a15f9cb2ab75d65c1448d7d32c490abf32b93", "message": "feedback", "committedDate": "2020-06-30T13:53:54Z", "type": "commit"}, {"oid": "47c17e4f522674030e4262425849411e60dc37ab", "url": "https://github.com/elastic/elasticsearch/commit/47c17e4f522674030e4262425849411e60dc37ab", "message": "checkstyle", "committedDate": "2020-06-30T14:04:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyMTc4MA==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447921780", "bodyText": "Without this we don't test store and stuff like that, right?", "author": "nik9000", "createdAt": "2020-06-30T19:16:44Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/BinaryFieldMapperTests.java", "diffHunk": "@@ -32,28 +32,18 @@\n import org.elasticsearch.common.xcontent.XContentFactory;\n import org.elasticsearch.common.xcontent.XContentType;\n import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n import org.elasticsearch.test.InternalSettingsPlugin;\n \n import java.io.IOException;\n import java.util.Arrays;\n import java.util.Collection;\n-import java.util.Set;\n \n import static org.hamcrest.Matchers.containsString;\n import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.Matchers.instanceOf;\n \n-public class BinaryFieldMapperTests extends FieldMapperTestCase<BinaryFieldMapper.Builder> {", "originalCommit": "47c17e4f522674030e4262425849411e60dc37ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyMjkwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447922909", "bodyText": "Ah! So you have the tests in ParameterizedFieldTest for things like this. Do you think it is important to also test that the field merges here too? I guess not, but I'm worried about dropping something accidentally.", "author": "nik9000", "createdAt": "2020-06-30T19:19:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyMTc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExMzMxNg==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r449113316", "bodyText": "The idea would be that we don't have 'common' fields any more - all mappers declare all their parameters outright (I am sharing the 'meta' parameter at the moment, but I think I'm going to stop doing that).  So the tests for each field mapper should cover all the parameters that they declare, but general things like 'this parameter can't be updated so it should throw an error on merge' are tested in ParametrizedFieldTest.", "author": "romseygeek", "createdAt": "2020-07-02T15:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyMTc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyMTkyMw==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r447921923", "bodyText": "Same here, right?", "author": "nik9000", "createdAt": "2020-06-30T19:17:03Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/BooleanFieldMapperTests.java", "diffHunk": "@@ -41,25 +41,21 @@\n import org.elasticsearch.index.mapper.MapperService.MergeReason;\n import org.elasticsearch.index.mapper.ParseContext.Document;\n import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n import org.elasticsearch.test.InternalSettingsPlugin;\n import org.junit.Before;\n \n import java.io.IOException;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Set;\n \n import static org.hamcrest.Matchers.containsString;\n \n-public class BooleanFieldMapperTests extends FieldMapperTestCase<BooleanFieldMapper.Builder> {", "originalCommit": "47c17e4f522674030e4262425849411e60dc37ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4bf93273e7d22d56fd37e8fa15d8e2a75c713711", "url": "https://github.com/elastic/elasticsearch/commit/4bf93273e7d22d56fd37e8fa15d8e2a75c713711", "message": "wut", "committedDate": "2020-07-01T12:26:36Z", "type": "commit"}, {"oid": "3011064d8afe48485056fe7cc11ca36d50901749", "url": "https://github.com/elastic/elasticsearch/commit/3011064d8afe48485056fe7cc11ca36d50901749", "message": "Merge remote-tracking branch 'origin/master' into mapper/mergebuilders", "committedDate": "2020-07-02T14:00:41Z", "type": "commit"}, {"oid": "bb35edaf9b835bb2ecfa561983b0f2e81d5f008f", "url": "https://github.com/elastic/elasticsearch/commit/bb35edaf9b835bb2ecfa561983b0f2e81d5f008f", "message": "fix object serialization; javadocs", "committedDate": "2020-07-02T16:33:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4NTYzMg==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r450085632", "bodyText": "seems like if the field is searchable and stored too, we end up adding two fields, while before we would only add one?", "author": "javanna", "createdAt": "2020-07-06T09:06:15Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/BooleanFieldMapper.java", "diffHunk": "@@ -250,8 +249,11 @@ protected void parseCreateField(ParseContext context) throws IOException {\n         if (value == null) {\n             return;\n         }\n-        if (fieldType().isSearchable() || fieldType.stored()) {\n-            context.doc().add(new Field(fieldType().name(), value ? \"T\" : \"F\", fieldType));\n+        if (fieldType().isSearchable()) {\n+            context.doc().add(new Field(fieldType().name(), value ? \"T\" : \"F\", Defaults.FIELD_TYPE));\n+        }\n+        if (stored) {\n+            context.doc().add(new StoredField(fieldType().name(), value ? \"T\" : \"F\"));", "originalCommit": "bb35edaf9b835bb2ecfa561983b0f2e81d5f008f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEwMTQ3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r450101471", "bodyText": "Adding a field with a FieldType that has stored set to true and adding a separate StoredField amount to the same thing.  This way, we don't need to change the field type at all, and it's clearer what's happening at the point where we're adding documents.", "author": "romseygeek", "createdAt": "2020-07-06T09:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4NTYzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxOTcwMw==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r451019703", "bodyText": "It was odd that we were using Field to get stored fields but doc values. Field just does a bunch of stuff.", "author": "nik9000", "createdAt": "2020-07-07T17:13:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4NTYzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4Nzk1OA==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r450087958", "bodyText": "I get confused here  that stored seems to be treated differently from e.g. doc_values. Why is that?", "author": "javanna", "createdAt": "2020-07-06T09:10:15Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/BooleanFieldMapper.java", "diffHunk": "@@ -71,25 +68,37 @@\n         public static final BytesRef FALSE = new BytesRef(\"F\");\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n+    private static BooleanFieldMapper toType(FieldMapper in) {\n+        return (BooleanFieldMapper) in;\n+    }\n+\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n \n-        private Boolean nullValue;\n+        private final Parameter<Float> boost = Parameter.floatParam(\"boost\", true, m -> m.fieldType().boost(), 1.0f);\n+        private final Parameter<Boolean> docValues\n+            = Parameter.boolParam(\"doc_values\", false, m -> m.fieldType().hasDocValues(),  true);\n+        private final Parameter<Boolean> indexed\n+            = Parameter.boolParam(\"index\", false, m -> m.fieldType().isSearchable(), true);\n+        private final Parameter<Boolean> nullValue\n+            = new Parameter<>(\"null_value\", false, null, (n, o) -> XContentMapValues.nodeBooleanValue(o), m -> toType(m).nullValue);\n+        private final Parameter<Boolean> stored = Parameter.boolParam(\"store\", false, m -> toType(m).stored, false);\n+        private final Parameter<Map<String, String>> meta\n+            = new Parameter<>(\"meta\", true, Collections.emptyMap(), TypeParsers::parseMeta, m -> m.fieldType().meta());", "originalCommit": "bb35edaf9b835bb2ecfa561983b0f2e81d5f008f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEwMjM3OA==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r450102378", "bodyText": "Convenience, mainly - doc_values and index can be derived from the field type values, but stored can't be.  I can change it so that doc_values and index are fields directly on the mapper as well if you think that's clearer?  Certainly for things like searchable docvalues fields then we'll need to distinguish between whether or not something is indexed and whether it's searchable.", "author": "romseygeek", "createdAt": "2020-07-06T09:36:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4Nzk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEwNzk0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r450107946", "bodyText": "I guess I am trying to see what the difference is between stored and indexed/doc_values. I would expect them to be treated in the same way/same place. Why can't stored be derived from the field type values?", "author": "javanna", "createdAt": "2020-07-06T09:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4Nzk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEwOTM0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r450109341", "bodyText": "As it stands, MappedFieldType doesn't have anything that tells you if the field is stored or not.", "author": "romseygeek", "createdAt": "2020-07-06T09:48:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4Nzk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxNTYwNw==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r451015607", "bodyText": "You made a boolean hasDocValues on BinaryFieldMapper for this. Is it worth making one here too?", "author": "nik9000", "createdAt": "2020-07-07T17:06:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4Nzk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3NDQxMA==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r451374410", "bodyText": "I'll add indexed and hasDocValues directly to the mappers as it sounds as though that will be less confusing.", "author": "romseygeek", "createdAt": "2020-07-08T08:31:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4Nzk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5MDIyOA==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r450090228", "bodyText": "this means that every field supports multi fields and copy_to, I think. But I think that runtime fields won't?", "author": "javanna", "createdAt": "2020-07-06T09:14:24Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/ParametrizedFieldMapper.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+/**\n+ * Defines how a particular field should be indexed and searched\n+ *\n+ * Configuration {@link Parameter}s for the mapper are defined on a {@link Builder} subclass,\n+ * and returned by its {@link Builder#getParameters()} method.  Merging, serialization\n+ * and parsing of the mapper are all mediated through this set of parameters.\n+ *\n+ * Subclasses should implement a {@link Builder} that is returned from the\n+ * {@link #getMergeBuilder()} method, initialised with the existing builder.\n+ */\n+public abstract class ParametrizedFieldMapper extends FieldMapper {\n+\n+    /**\n+     * Creates a new ParametrizedFieldMapper\n+     */\n+    protected ParametrizedFieldMapper(String simpleName, MappedFieldType mappedFieldType, MultiFields multiFields, CopyTo copyTo) {\n+        super(simpleName, new FieldType(), mappedFieldType, multiFields, copyTo);\n+    }\n+\n+    /**\n+     * Returns a {@link Builder} to be used for merging and serialization\n+     *\n+     * Implement as follows:\n+     * {@code return new MyBuilder(simpleName()).init(this); }\n+     */\n+    public abstract ParametrizedFieldMapper.Builder getMergeBuilder();\n+\n+    @Override\n+    public final ParametrizedFieldMapper merge(Mapper mergeWith) {\n+\n+        if (mergeWith instanceof FieldMapper == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + mergeWith.getClass().getSimpleName() + \"]\");\n+        }\n+        if (Objects.equals(this.getClass(), mergeWith.getClass()) == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + name() + \"] cannot be changed from type [\"\n+                + contentType() + \"] to [\" + ((FieldMapper) mergeWith).contentType() + \"]\");\n+        }\n+\n+        ParametrizedFieldMapper.Builder builder = getMergeBuilder();\n+        Conflicts conflicts = new Conflicts(name());\n+        builder.merge((FieldMapper) mergeWith, conflicts);\n+        conflicts.check();\n+        return builder.build(new BuilderContext(Settings.EMPTY, parentPath(name())));\n+    }\n+\n+    private static ContentPath parentPath(String name) {\n+        int endPos = name.lastIndexOf(\".\");\n+        if (endPos == -1) {\n+            return new ContentPath(0);\n+        }\n+        return new ContentPath(name.substring(0, endPos));\n+    }\n+\n+    @Override\n+    protected final void mergeOptions(FieldMapper other, List<String> conflicts) {\n+        // TODO remove when everything is parametrized\n+    }\n+\n+    @Override\n+    public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject(simpleName());\n+        builder.field(\"type\", contentType());\n+        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n+        getMergeBuilder().toXContent(builder, includeDefaults);\n+        multiFields.toXContent(builder, params);\n+        copyTo.toXContent(builder, params);\n+        return builder.endObject();\n+    }\n+\n+    /**\n+     * A configurable parameter for a field mapper\n+     * @param <T> the type of the value the parameter holds\n+     */\n+    public static final class Parameter<T> {\n+\n+        public final String name;\n+        private final T defaultValue;\n+        private final BiFunction<String, Object, T> parser;\n+        private final Function<FieldMapper, T> initializer;\n+        private final boolean updateable;\n+        private boolean acceptsNull = false;\n+        private T value;\n+\n+        /**\n+         * Creates a new Parameter\n+         * @param name          the parameter name, used in parsing and serialization\n+         * @param updateable    whether the parameter can be updated with a new value during a mapping update\n+         * @param defaultValue  the default value for the parameter, used if unspecified in mappings\n+         * @param parser        a function that converts an object to a parameter value\n+         * @param initializer   a function that reads a parameter value from an existing mapper\n+         */\n+        public Parameter(String name, boolean updateable, T defaultValue,\n+                         BiFunction<String, Object, T> parser, Function<FieldMapper, T> initializer) {\n+            this.name = name;\n+            this.defaultValue = defaultValue;\n+            this.value = defaultValue;\n+            this.parser = parser;\n+            this.initializer = initializer;\n+            this.updateable = updateable;\n+        }\n+\n+        /**\n+         * Returns the current value of the parameter\n+         */\n+        public T getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * Sets the current value of the parameter\n+         */\n+        public void setValue(T value) {\n+            this.value = value;\n+        }\n+\n+        /**\n+         * Allows the parameter to accept a {@code null} value\n+         */\n+        public Parameter<T> acceptsNull() {\n+            this.acceptsNull = true;\n+            return this;\n+        }\n+\n+        private void init(FieldMapper toInit) {\n+            this.value = initializer.apply(toInit);\n+        }\n+\n+        private void parse(String field, Object in) {\n+            this.value = parser.apply(field, in);\n+        }\n+\n+        private void merge(FieldMapper toMerge, Conflicts conflicts) {\n+            T value = initializer.apply(toMerge);\n+            if (updateable == false && Objects.equals(this.value, value) == false) {\n+                conflicts.addConflict(name, this.value.toString(), value.toString());\n+            } else {\n+                this.value = value;\n+            }\n+        }\n+\n+        private void toXContent(XContentBuilder builder, boolean includeDefaults) throws IOException {\n+            if (includeDefaults || (Objects.equals(defaultValue, value) == false)) {\n+                builder.field(name, value);\n+            }\n+        }\n+\n+        /**\n+         * Defines a parameter that takes the values {@code true} or {@code false}\n+         * @param name          the parameter name\n+         * @param updateable    whether the parameter can be changed by a mapping update\n+         * @param initializer   a function that reads the parameter value from an existing mapper\n+         * @param defaultValue  the default value, to be used if the parameter is undefined in a mapping\n+         */\n+        public static Parameter<Boolean> boolParam(String name, boolean updateable,\n+                                                   Function<FieldMapper, Boolean> initializer, boolean defaultValue) {\n+            return new Parameter<>(name, updateable, defaultValue, (n, o) -> XContentMapValues.nodeBooleanValue(o), initializer);\n+        }\n+\n+        /**\n+         * Defines a parameter that takes a float value\n+         * @param name          the parameter name\n+         * @param updateable    whether the parameter can be changed by a mapping update\n+         * @param initializer   a function that reads the parameter value from an existing mapper\n+         * @param defaultValue  the default value, to be used if the parameter is undefined in a mapping\n+         */\n+        public static Parameter<Float> floatParam(String name, boolean updateable,\n+                                                  Function<FieldMapper, Float> initializer, float defaultValue) {\n+            return new Parameter<>(name, updateable, defaultValue, (n, o) -> XContentMapValues.nodeFloatValue(o), initializer);\n+        }\n+\n+        /**\n+         * Defines a parameter that takes a string value\n+         * @param name          the parameter name\n+         * @param updateable    whether the parameter can be changed by a mapping update\n+         * @param initializer   a function that reads the parameter value from an existing mapper\n+         * @param defaultValue  the default value, to be used if the parameter is undefined in a mapping\n+         */\n+        public static Parameter<String> stringParam(String name, boolean updateable,\n+                                                    Function<FieldMapper, String> initializer, String defaultValue) {\n+            return new Parameter<>(name, updateable, defaultValue,\n+                (n, o) -> XContentMapValues.nodeStringValue(o), initializer);\n+        }\n+    }\n+\n+    private static final class Conflicts {\n+\n+        private final String mapperName;\n+        private final List<String> conflicts = new ArrayList<>();\n+\n+        Conflicts(String mapperName) {\n+            this.mapperName = mapperName;\n+        }\n+\n+        void addConflict(String parameter, String existing, String toMerge) {\n+            conflicts.add(\"Cannot update parameter [\" + parameter + \"] from [\" + existing + \"] to [\" + toMerge + \"]\");\n+        }\n+\n+        void check() {\n+            if (conflicts.isEmpty()) {\n+                return;\n+            }\n+            String message = \"Mapper for [\" + mapperName + \"] conflicts with existing mapper:\\n\\t\"\n+                + String.join(\"\\n\\t\", conflicts);\n+            throw new IllegalArgumentException(message);\n+        }\n+\n+    }\n+\n+    /**\n+     * A Builder for a ParametrizedFieldMapper\n+     */\n+    public abstract static class Builder extends Mapper.Builder<Builder> {\n+\n+        protected final MultiFields.Builder multiFieldsBuilder = new MultiFields.Builder();\n+        protected final CopyTo.Builder copyTo = new CopyTo.Builder();\n+\n+        /**\n+         * Creates a new Builder with a field name\n+         */\n+        protected Builder(String name) {\n+            super(name);\n+        }\n+\n+        /**\n+         * Initialises all parameters from an existing mapper\n+         */\n+        public Builder init(FieldMapper initializer) {\n+            for (Parameter<?> param : getParameters()) {\n+                param.init(initializer);\n+            }\n+            for (Mapper subField : initializer.multiFields) {\n+                multiFieldsBuilder.add(subField);\n+            }\n+            return this;\n+        }\n+\n+        private void merge(FieldMapper in, Conflicts conflicts) {\n+            for (Parameter<?> param : getParameters()) {\n+                param.merge(in, conflicts);\n+            }\n+            for (Mapper newSubField : in.multiFields) {\n+                multiFieldsBuilder.update(newSubField, parentPath(newSubField.name()));\n+            }\n+            this.copyTo.reset(in.copyTo);\n+        }\n+\n+        /**\n+         * @return the list of parameters defined for this mapper\n+         */\n+        protected abstract List<Parameter<?>> getParameters();\n+\n+        @Override\n+        public abstract ParametrizedFieldMapper build(BuilderContext context);\n+\n+        /**\n+         * Builds the full name of the field, taking into account parent objects\n+         */\n+        protected String buildFullName(BuilderContext context) {\n+            return context.path().pathAsText(name);\n+        }\n+\n+        private void toXContent(XContentBuilder builder, boolean includeDefaults) throws IOException {\n+            for (Parameter<?> parameter : getParameters()) {\n+                parameter.toXContent(builder, includeDefaults);\n+            }\n+        }\n+\n+        /**\n+         * Parse mapping parameters from a map of mappings\n+         * @param name              the field mapper name\n+         * @param parserContext     the parser context\n+         * @param fieldNode         the root node of the map of mappings for this field\n+         */\n+        public final void parse(String name, TypeParser.ParserContext parserContext, Map<String, Object> fieldNode) {\n+            Map<String, Parameter<?>> paramsMap = new HashMap<>();\n+            for (Parameter<?> param : getParameters()) {\n+                paramsMap.put(param.name, param);\n+            }\n+            String type = (String) fieldNode.remove(\"type\");\n+            for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                final String propName = entry.getKey();\n+                final Object propNode = entry.getValue();\n+                if (Objects.equals(\"fields\", propName)) {", "originalCommit": "bb35edaf9b835bb2ecfa561983b0f2e81d5f008f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEwMjc5OA==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r450102798", "bodyText": "We can add disabling feature flags later if we need to.", "author": "romseygeek", "createdAt": "2020-07-06T09:37:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5MDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAyMTExNg==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r451021116", "bodyText": "Every field does support multi fields and copy_to right now. I'm happy to juggle things for runtime fields in a follow up.", "author": "nik9000", "createdAt": "2020-07-07T17:15:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5MDIyOA=="}], "type": "inlineReview"}, {"oid": "b9dd287be2fa6d88e53a6508906ebf6c275321c4", "url": "https://github.com/elastic/elasticsearch/commit/b9dd287be2fa6d88e53a6508906ebf6c275321c4", "message": "Merge branch 'master' into mapper/mergebuilders", "committedDate": "2020-07-07T13:40:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxMzU4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r451013581", "bodyText": "Its probably worth adding javadoc about how this is different from Objects.toString.", "author": "nik9000", "createdAt": "2020-07-07T17:03:09Z", "path": "server/src/main/java/org/elasticsearch/common/xcontent/support/XContentMapValues.java", "diffHunk": "@@ -332,6 +332,13 @@ public static String nodeStringValue(Object node, String defaultValue) {\n         return node.toString();\n     }\n \n+    public static String nodeStringValue(Object node) {", "originalCommit": "b9dd287be2fa6d88e53a6508906ebf6c275321c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MjgyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r451372821", "bodyText": "++", "author": "romseygeek", "createdAt": "2020-07-08T08:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxMzU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxNDI0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r451014243", "bodyText": "Do we plan to eventually move meta over to the FieldMapper?", "author": "nik9000", "createdAt": "2020-07-07T17:04:16Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/BinaryFieldMapper.java", "diffHunk": "@@ -48,42 +46,39 @@\n import java.util.List;\n import java.util.Map;\n \n-import static org.elasticsearch.index.mapper.TypeParsers.parseField;\n-\n-public class BinaryFieldMapper extends FieldMapper {\n+public class BinaryFieldMapper extends ParametrizedFieldMapper {\n \n     public static final String CONTENT_TYPE = \"binary\";\n \n-    public static class Defaults {\n-        public static final FieldType FIELD_TYPE = new FieldType();\n-\n-        static {\n-            FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n-            FIELD_TYPE.setOmitNorms(true);\n-            FIELD_TYPE.freeze();\n-        }\n+    private static BinaryFieldMapper toType(FieldMapper in) {\n+        return (BinaryFieldMapper) in;\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        private final Parameter<Boolean> stored = Parameter.boolParam(\"store\", false, m -> toType(m).stored, false);\n+        private final Parameter<Boolean> hasDocValues = Parameter.boolParam(\"doc_values\", false, m -> toType(m).hasDocValues,  false);\n+        private final Parameter<Map<String, String>> meta\n+            = new Parameter<>(\"meta\", true, Collections.emptyMap(), TypeParsers::parseMeta, m -> m.fieldType().meta());", "originalCommit": "b9dd287be2fa6d88e53a6508906ebf6c275321c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MzE0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/58663#discussion_r451373141", "bodyText": "meta is used in field caps, which currently are based off MappedFieldType so I think it will probably stay there?", "author": "romseygeek", "createdAt": "2020-07-08T08:29:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxNDI0Mw=="}], "type": "inlineReview"}, {"oid": "8f1853f6dfbb45168d12e18a0ad994e094a83d0d", "url": "https://github.com/elastic/elasticsearch/commit/8f1853f6dfbb45168d12e18a0ad994e094a83d0d", "message": "Merge remote-tracking branch 'origin/master' into mapper/mergebuilders", "committedDate": "2020-07-08T08:27:42Z", "type": "commit"}, {"oid": "37ea8d669e95c7d3311218779d1f525ccaa224f6", "url": "https://github.com/elastic/elasticsearch/commit/37ea8d669e95c7d3311218779d1f525ccaa224f6", "message": "feedback", "committedDate": "2020-07-08T08:54:33Z", "type": "commit"}]}