{"pr_number": 53084, "pr_title": "Add API to mount a snapshot as a searchable index", "pr_createdAt": "2020-03-03T21:16:54Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53084", "timeline": [{"oid": "c847e035baa2e0b370808aa7a52a6d59c5256a44", "url": "https://github.com/elastic/elasticsearch/commit/c847e035baa2e0b370808aa7a52a6d59c5256a44", "message": "Add API to mount a snapshot as a searchable index\n\nThis commit adds an API for mounting a snapshot as a searchable index.\n\nInternally, a request is made to the repository to fetch metadata information necessary from the\nsnapshot in question, which is then passed to the regular snapshot restore mechanism with some\nspecialized settings.\n\nAssume you have an existing snapshot repository and snapshot, the API looks like:\n\n```json\nPOST /my-new-index/_snapshot/mount?wait_for_completion=true\n{\n  \"repository\": \"my-s3-repo\",\n  \"snapshot\": \"production-2019-12-11-aoeufao\",\n  \"snapshot_index\": \"important-data\",\n  \"index_settings\": {\n    \"index.number_of_replicas\": 2\n  },\n  \"ignore_index_settings\": [\"index.refresh_interval\"]\n}\n```\n\nWhile the request may appear similar to a snapshot restore request, it has slight differences. The\n`repository`, `snapshot`, and `snapshot_index` fields are required (all other fields are optional).\n\nThe response is identical to the response when restoring a snapshot.\n\nRelates to #50999", "committedDate": "2020-03-03T21:08:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0MjA2NA==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387542064", "bodyText": "This is \"disrupting\" the usual lifecycle of Repository. On the other hand, SearchableSnapshotRepository was useful when the searchable repository was explicitly registered as a delegating repository. I don't think it's needed anymore: the  DirectoryFactory logic can be moved back to the plugin class, and instead of passing directly a BlobContainer instance to the SearchableSnapshotDirectory it could use the RepositoriesService to retrieve it on demande. This way we get rid of a class and we take care of reloading the BlobStoreRepository instance that could have changed. WDYT?", "author": "tlrx", "createdAt": "2020-03-04T09:27:59Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotRepository.java", "diffHunk": "@@ -160,16 +164,17 @@ public Repository create(RepositoryMetaData metaData, Function<String, Factory>\n         return (indexSettings, shardPath) -> {\n             final RepositoriesService repositories = repositoriesService.get();\n             assert repositories != null;\n-\n-            final Repository repository = repositories.repository(SNAPSHOT_REPOSITORY_SETTING.get(indexSettings.getSettings()));\n-            if (repository instanceof SearchableSnapshotRepository == false) {\n-                throw new IllegalArgumentException(\"Repository [\" + repository + \"] is not searchable\");\n-            }\n-\n             final CacheService cache = cacheService.get();\n             assert cache != null;\n \n-            return ((SearchableSnapshotRepository) repository).makeDirectory(indexSettings, shardPath, cache, currentTimeNanosSupplier);\n+            final Repository repository = repositories.repository(SNAPSHOT_REPOSITORY_SETTING.get(indexSettings.getSettings()));\n+            // TODO: is this okay?\n+//            if (repository instanceof SearchableSnapshotRepository == false) {\n+//                throw new IllegalArgumentException(\"Repository [\" + repository + \"] is not searchable\");\n+//            }\n+\n+            SearchableSnapshotRepository searchableRepo = new SearchableSnapshotRepository(repository);", "originalCommit": "c847e035baa2e0b370808aa7a52a6d59c5256a44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1OTk5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387859999", "bodyText": "I would leave that up to you and David. I agree this is not the \"right\" way to do it since there is no longer a need for a SearchableSnapshotRepository, I agree that the directory logic can be moved elsewhere when the SearchableSnapshotRepository repository type is removed. For now, I was trying to make as small a change as possible to code outside of the scope of the actual request/response/transport.", "author": "dakrone", "createdAt": "2020-03-04T18:42:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0MjA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE3NDg0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r388174849", "bodyText": "I'm with Tanguy here, I think it would be good to remove SearchableSnapshotRepository in this PR.", "author": "DaveCTurner", "createdAt": "2020-03-05T09:35:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0MjA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0NDk5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387544992", "bodyText": "Should we make this uniform with other searchable snapshots related actions?", "author": "tlrx", "createdAt": "2020-03-04T09:33:07Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+\n+public class MountSearchableSnapshotAction extends ActionType<RestoreSnapshotResponse> {\n+\n+    public static final MountSearchableSnapshotAction INSTANCE = new MountSearchableSnapshotAction();\n+    public static final String NAME = \"cluster:admin/snapshot/mount\";", "originalCommit": "c847e035baa2e0b370808aa7a52a6d59c5256a44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1NTAxNw==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387855017", "bodyText": "I think it's either conform to the searchable snapshot actions, or treat it more like the snapshot action. Here I decided to treat it like a \"snapshot\" action (a \"mount\" action) so people could grant cluster:admin/snapshot/* and be able to mount searchable snapshots (since it's essentially a specialized restore)", "author": "dakrone", "createdAt": "2020-03-04T18:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0NDk5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUyNjQwMg==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389526402", "bodyText": "Thanks Lee, I do agree with your reasoning here.", "author": "tlrx", "createdAt": "2020-03-09T08:52:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0NDk5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0NTQ5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387545497", "bodyText": "This doc needs to be updated", "author": "tlrx", "createdAt": "2020-03-04T09:34:01Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotRequest.java", "diffHunk": "@@ -0,0 +1,435 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchGenerationException;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.MasterNodeRequest;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+import static org.elasticsearch.common.settings.Settings.Builder.EMPTY_SETTINGS;\n+import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;\n+import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;\n+\n+public class MountSearchableSnapshotRequest extends MasterNodeRequest<MountSearchableSnapshotRequest> implements ToXContentObject {\n+\n+    private final String mountedIndex;\n+    private String snapshot;\n+    private String repository;\n+    private String snapshotIndex;\n+    private Boolean waitForCompletion;\n+    private Settings settings = EMPTY_SETTINGS;\n+    private Settings indexSettings = EMPTY_SETTINGS;\n+    private String[] ignoreIndexSettings = Strings.EMPTY_ARRAY;\n+\n+    /**\n+     * Constructs a new put repository request with the provided repository and snapshot names.", "originalCommit": "c847e035baa2e0b370808aa7a52a6d59c5256a44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0ODI4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387548286", "bodyText": "Should we use indices or index?", "author": "tlrx", "createdAt": "2020-03-04T09:39:01Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotRequest.java", "diffHunk": "@@ -0,0 +1,435 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchGenerationException;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.MasterNodeRequest;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+import static org.elasticsearch.common.settings.Settings.Builder.EMPTY_SETTINGS;\n+import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;\n+import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;\n+\n+public class MountSearchableSnapshotRequest extends MasterNodeRequest<MountSearchableSnapshotRequest> implements ToXContentObject {\n+\n+    private final String mountedIndex;\n+    private String snapshot;\n+    private String repository;\n+    private String snapshotIndex;\n+    private Boolean waitForCompletion;\n+    private Settings settings = EMPTY_SETTINGS;\n+    private Settings indexSettings = EMPTY_SETTINGS;\n+    private String[] ignoreIndexSettings = Strings.EMPTY_ARRAY;\n+\n+    /**\n+     * Constructs a new put repository request with the provided repository and snapshot names.\n+     */\n+    public MountSearchableSnapshotRequest(String mountedIndex) {\n+        this.mountedIndex = mountedIndex;\n+    }\n+\n+    public MountSearchableSnapshotRequest(StreamInput in) throws IOException {\n+        super(in);\n+        this.snapshot = in.readString();\n+        this.repository = in.readString();\n+        this.snapshotIndex = in.readString();\n+        this.mountedIndex = in.readString();\n+        this.waitForCompletion = in.readOptionalBoolean();\n+        this.settings = readSettingsFromStream(in);\n+        this.indexSettings = readSettingsFromStream(in);\n+        this.ignoreIndexSettings = in.readStringArray();\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeString(snapshot);\n+        out.writeString(repository);\n+        out.writeString(snapshotIndex);\n+        out.writeString(mountedIndex);\n+        out.writeOptionalBoolean(waitForCompletion);\n+        writeSettingsToStream(settings, out);\n+        writeSettingsToStream(indexSettings, out);\n+        out.writeStringArray(ignoreIndexSettings);\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = null;\n+        if (snapshot == null) {\n+            validationException = addValidationError(\"snapshot name is missing\", validationException);\n+        }\n+        if (repository == null) {\n+            validationException = addValidationError(\"repository is missing\", validationException);\n+        }\n+        if (snapshotIndex == null) {\n+            validationException = addValidationError(\"index name from snapshot is missing\", validationException);\n+        }\n+        if (mountedIndex == null) {\n+            validationException = addValidationError(\"index name to mount is missing\", validationException);\n+        }\n+        if (settings == null) {\n+            validationException = addValidationError(\"settings are missing\", validationException);\n+        }\n+        if (indexSettings == null) {\n+            validationException = addValidationError(\"indexSettings are missing\", validationException);\n+        }\n+        return validationException;\n+    }\n+\n+    /**\n+     * Sets the name of the snapshot.\n+     *\n+     * @param snapshot snapshot name\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest snapshot(String snapshot) {\n+        this.snapshot = snapshot;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns the name of the snapshot.\n+     *\n+     * @return snapshot name\n+     */\n+    public String snapshot() {\n+        return this.snapshot;\n+    }\n+\n+    /**\n+     * Sets repository name\n+     *\n+     * @param repository repository name\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest repository(String repository) {\n+        this.repository = repository;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns repository name\n+     *\n+     * @return repository name\n+     */\n+    public String repository() {\n+        return this.repository;\n+    }\n+\n+    /**\n+     * Sets the name of the index that should be restored from snapshot\n+     */\n+    public MountSearchableSnapshotRequest snapshotIndex(String indexName) {\n+        this.snapshotIndex = indexName;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns index that should be restored from snapshot\n+     */\n+    public String snapshotIndex() {\n+        return snapshotIndex;\n+    }\n+\n+    /**\n+     * Returns new index name after the snapshot has been mounted\n+     */\n+    public String mountedIndex() {\n+        return mountedIndex;\n+    }\n+\n+    /**\n+     * If this parameter is set to true the operation will wait for completion of restore process before returning.\n+     *\n+     * @param waitForCompletion if true the operation will wait for completion\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest waitForCompletion(boolean waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns wait for completion setting\n+     *\n+     * @return true if the operation will wait for completion\n+     */\n+    public boolean waitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets repository-specific restore settings.\n+     * <p>\n+     * See repository documentation for more information.\n+     *\n+     * @param settings repository-specific snapshot settings\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest settings(Settings settings) {\n+        this.settings = settings;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets repository-specific restore settings.\n+     * <p>\n+     * See repository documentation for more information.\n+     *\n+     * @param settings repository-specific snapshot settings\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest settings(Settings.Builder settings) {\n+        this.settings = settings.build();\n+        return this;\n+    }\n+\n+    /**\n+     * Sets repository-specific restore settings in JSON or YAML format\n+     * <p>\n+     * See repository documentation for more information.\n+     *\n+     * @param source repository-specific snapshot settings\n+     * @param xContentType the content type of the source\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest settings(String source, XContentType xContentType) {\n+        this.settings = Settings.builder().loadFromSource(source, xContentType).build();\n+        return this;\n+    }\n+\n+    /**\n+     * Sets repository-specific restore settings\n+     * <p>\n+     * See repository documentation for more information.\n+     *\n+     * @param source repository-specific snapshot settings\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest settings(Map<String, Object> source) {\n+        try {\n+            XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);\n+            builder.map(source);\n+            settings(Strings.toString(builder), builder.contentType());\n+        } catch (IOException e) {\n+            throw new ElasticsearchGenerationException(\"Failed to generate [\" + source + \"]\", e);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Returns repository-specific restore settings\n+     *\n+     * @return restore settings\n+     */\n+    public Settings settings() {\n+        return this.settings;\n+    }\n+\n+    /**\n+     * Sets the list of index settings and index settings groups that shouldn't be restored from snapshot\n+     */\n+    public MountSearchableSnapshotRequest ignoreIndexSettings(String... ignoreIndexSettings) {\n+        this.ignoreIndexSettings = ignoreIndexSettings;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the list of index settings and index settings groups that shouldn't be restored from snapshot\n+     */\n+    public MountSearchableSnapshotRequest ignoreIndexSettings(List<String> ignoreIndexSettings) {\n+        this.ignoreIndexSettings = ignoreIndexSettings.toArray(new String[ignoreIndexSettings.size()]);\n+        return this;\n+    }\n+\n+    /**\n+     * Returns the list of index settings and index settings groups that shouldn't be restored from snapshot\n+     */\n+    public String[] ignoreIndexSettings() {\n+        return ignoreIndexSettings;\n+    }\n+\n+    /**\n+     * Sets settings that should be added/changed for restored index\n+     */\n+    public MountSearchableSnapshotRequest indexSettings(Settings settings) {\n+        this.indexSettings = settings;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets settings that should be added/changed for restored index\n+     */\n+    public MountSearchableSnapshotRequest indexSettings(Settings.Builder settings) {\n+        this.indexSettings = settings.build();\n+        return this;\n+    }\n+\n+    /**\n+     * Sets settings that should be added/changed for restored index\n+     */\n+    public MountSearchableSnapshotRequest indexSettings(String source, XContentType xContentType) {\n+        this.indexSettings = Settings.builder().loadFromSource(source, xContentType).build();\n+        return this;\n+    }\n+\n+    /**\n+     * Sets settings that should be added/changed for restored index\n+     */\n+    public MountSearchableSnapshotRequest indexSettings(Map<String, Object> source) {\n+        try {\n+            XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);\n+            builder.map(source);\n+            indexSettings(Strings.toString(builder), builder.contentType());\n+        } catch (IOException e) {\n+            throw new ElasticsearchGenerationException(\"Failed to generate [\" + source + \"]\", e);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Returns settings that should be added/changed for restored index\n+     */\n+    public Settings indexSettings() {\n+        return this.indexSettings;\n+    }\n+\n+    /**\n+     * Parses mount definition\n+     *\n+     * @param source mount definition\n+     * @return this request\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MountSearchableSnapshotRequest source(Map<String, Object> source) {\n+        // TODO: this could be rewritten with a Constructing Object Parser rather than manually\n+        //  parsing the XContent, this was copied/modified from RestoreSnapshotRequest\n+        for (Map.Entry<String, Object> entry : source.entrySet()) {\n+            String name = entry.getKey();\n+            if (name.equals(\"snapshot_index\")) {", "originalCommit": "c847e035baa2e0b370808aa7a52a6d59c5256a44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1ODY3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387858672", "bodyText": "index I think. We can't actually support restoring multiple indices currently, as there's no way to specify index-specific settings when restoring multiple indices (ie, restore foo, bar, and baz, but have different index_settings for each of them).", "author": "dakrone", "createdAt": "2020-03-04T18:40:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0ODI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0OTA1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387549051", "bodyText": "Nit: extra line", "author": "tlrx", "createdAt": "2020-03-04T09:40:27Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportMountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.StepListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.RepositoryData;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+\n+public class TransportMountSearchableSnapshotAction\n+    extends TransportMasterNodeAction<MountSearchableSnapshotRequest, RestoreSnapshotResponse> {\n+\n+    private final Client client;\n+    private final RepositoriesService repositoriesService;\n+\n+    @Inject\n+    public TransportMountSearchableSnapshotAction(TransportService transportService, ClusterService clusterService, Client client,\n+                                                  ThreadPool threadPool, RepositoriesService repositoriesService,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MountSearchableSnapshotAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MountSearchableSnapshotRequest::new, indexNameExpressionResolver);\n+        this.client = client;\n+        this.repositoriesService = repositoriesService;\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        // Using the generic instead of the snapshot threadpool here as the snapshot threadpool might be blocked on long running tasks\n+        // which would block the request from getting an error response because of the ongoing task\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    @Override\n+    protected RestoreSnapshotResponse read(StreamInput in) throws IOException {\n+        return new RestoreSnapshotResponse(in);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkBlock(MountSearchableSnapshotRequest request, ClusterState state) {\n+        // Restoring a snapshot might change the global state and create/change an index,\n+        // so we need to check for METADATA_WRITE and WRITE blocks\n+        ClusterBlockException blockException = state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE);\n+        if (blockException != null) {\n+            return blockException;\n+        }\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.WRITE);\n+", "originalCommit": "c847e035baa2e0b370808aa7a52a6d59c5256a44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1MDk2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387550969", "bodyText": "This throws a RepositoryMissingException which must be caught and passed to the listener.onFailure() method", "author": "tlrx", "createdAt": "2020-03-04T09:43:47Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportMountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.StepListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.RepositoryData;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+\n+public class TransportMountSearchableSnapshotAction\n+    extends TransportMasterNodeAction<MountSearchableSnapshotRequest, RestoreSnapshotResponse> {\n+\n+    private final Client client;\n+    private final RepositoriesService repositoriesService;\n+\n+    @Inject\n+    public TransportMountSearchableSnapshotAction(TransportService transportService, ClusterService clusterService, Client client,\n+                                                  ThreadPool threadPool, RepositoriesService repositoriesService,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MountSearchableSnapshotAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MountSearchableSnapshotRequest::new, indexNameExpressionResolver);\n+        this.client = client;\n+        this.repositoriesService = repositoriesService;\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        // Using the generic instead of the snapshot threadpool here as the snapshot threadpool might be blocked on long running tasks\n+        // which would block the request from getting an error response because of the ongoing task\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    @Override\n+    protected RestoreSnapshotResponse read(StreamInput in) throws IOException {\n+        return new RestoreSnapshotResponse(in);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkBlock(MountSearchableSnapshotRequest request, ClusterState state) {\n+        // Restoring a snapshot might change the global state and create/change an index,\n+        // so we need to check for METADATA_WRITE and WRITE blocks\n+        ClusterBlockException blockException = state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE);\n+        if (blockException != null) {\n+            return blockException;\n+        }\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.WRITE);\n+\n+    }\n+\n+    /**\n+     * Return the index settings required to make a snapshot searchable\n+     */\n+    private static Settings getIndexSettings(String repoName, SnapshotId snapshotId, IndexId indexId) {\n+        return Settings.builder()\n+            .put(SearchableSnapshotRepository.SNAPSHOT_REPOSITORY_SETTING.getKey(), repoName)\n+            .put(SearchableSnapshotRepository.SNAPSHOT_SNAPSHOT_NAME_SETTING.getKey(), snapshotId.getName())\n+            .put(SearchableSnapshotRepository.SNAPSHOT_SNAPSHOT_ID_SETTING.getKey(), snapshotId.getUUID())\n+            .put(SearchableSnapshotRepository.SNAPSHOT_INDEX_ID_SETTING.getKey(), indexId.getId())\n+            .put(INDEX_STORE_TYPE_SETTING.getKey(), SearchableSnapshotRepository.SNAPSHOT_DIRECTORY_FACTORY_KEY)\n+            .put(IndexMetaData.SETTING_BLOCKS_WRITE, true)\n+            .build();\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, final MountSearchableSnapshotRequest request, final ClusterState state,\n+                                   final ActionListener<RestoreSnapshotResponse> listener) {\n+        final String repoName = request.repository();\n+        final String snapName = request.snapshot();\n+        final String indexName = request.snapshotIndex();\n+\n+        // Retrieve IndexId and SnapshotId instances, which are then used to create a new restore\n+        // request, which is then sent on to the actual snapshot restore mechanism\n+        final Repository repository = repositoriesService.repository(repoName);", "originalCommit": "c847e035baa2e0b370808aa7a52a6d59c5256a44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkxODU3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r388918571", "bodyText": "I think throwing is fine, we're inside an ActionRunnable?", "author": "DaveCTurner", "createdAt": "2020-03-06T14:02:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1MDk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzNjAwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389536001", "bodyText": "Good point @DaveCTurner, but I still think that mixing listener and throwing exception is confusing", "author": "tlrx", "createdAt": "2020-03-09T09:13:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1MDk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwODcyNg==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389608726", "bodyText": "I prefer to throw. The try/catch is unnecessary and meant I felt compelled to investigate whether the framework was missing something.", "author": "DaveCTurner", "createdAt": "2020-03-09T11:43:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1MDk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYxNzgxNA==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389617814", "bodyText": "Okay. I've checked other places and it seems it also throws in some cases.", "author": "tlrx", "createdAt": "2020-03-09T12:04:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1MDk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1MzkxNg==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387553916", "bodyText": "What are these exactly?", "author": "tlrx", "createdAt": "2020-03-04T09:48:46Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotRequest.java", "diffHunk": "@@ -0,0 +1,435 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchGenerationException;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.MasterNodeRequest;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+import static org.elasticsearch.common.settings.Settings.Builder.EMPTY_SETTINGS;\n+import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;\n+import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;\n+\n+public class MountSearchableSnapshotRequest extends MasterNodeRequest<MountSearchableSnapshotRequest> implements ToXContentObject {\n+\n+    private final String mountedIndex;\n+    private String snapshot;\n+    private String repository;\n+    private String snapshotIndex;\n+    private Boolean waitForCompletion;\n+    private Settings settings = EMPTY_SETTINGS;\n+    private Settings indexSettings = EMPTY_SETTINGS;\n+    private String[] ignoreIndexSettings = Strings.EMPTY_ARRAY;\n+\n+    /**\n+     * Constructs a new put repository request with the provided repository and snapshot names.\n+     */\n+    public MountSearchableSnapshotRequest(String mountedIndex) {\n+        this.mountedIndex = mountedIndex;\n+    }\n+\n+    public MountSearchableSnapshotRequest(StreamInput in) throws IOException {\n+        super(in);\n+        this.snapshot = in.readString();\n+        this.repository = in.readString();\n+        this.snapshotIndex = in.readString();\n+        this.mountedIndex = in.readString();\n+        this.waitForCompletion = in.readOptionalBoolean();\n+        this.settings = readSettingsFromStream(in);\n+        this.indexSettings = readSettingsFromStream(in);\n+        this.ignoreIndexSettings = in.readStringArray();\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeString(snapshot);\n+        out.writeString(repository);\n+        out.writeString(snapshotIndex);\n+        out.writeString(mountedIndex);\n+        out.writeOptionalBoolean(waitForCompletion);\n+        writeSettingsToStream(settings, out);\n+        writeSettingsToStream(indexSettings, out);\n+        out.writeStringArray(ignoreIndexSettings);\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = null;\n+        if (snapshot == null) {\n+            validationException = addValidationError(\"snapshot name is missing\", validationException);\n+        }\n+        if (repository == null) {\n+            validationException = addValidationError(\"repository is missing\", validationException);\n+        }\n+        if (snapshotIndex == null) {\n+            validationException = addValidationError(\"index name from snapshot is missing\", validationException);\n+        }\n+        if (mountedIndex == null) {\n+            validationException = addValidationError(\"index name to mount is missing\", validationException);\n+        }\n+        if (settings == null) {\n+            validationException = addValidationError(\"settings are missing\", validationException);\n+        }\n+        if (indexSettings == null) {\n+            validationException = addValidationError(\"indexSettings are missing\", validationException);\n+        }\n+        return validationException;\n+    }\n+\n+    /**\n+     * Sets the name of the snapshot.\n+     *\n+     * @param snapshot snapshot name\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest snapshot(String snapshot) {\n+        this.snapshot = snapshot;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns the name of the snapshot.\n+     *\n+     * @return snapshot name\n+     */\n+    public String snapshot() {\n+        return this.snapshot;\n+    }\n+\n+    /**\n+     * Sets repository name\n+     *\n+     * @param repository repository name\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest repository(String repository) {\n+        this.repository = repository;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns repository name\n+     *\n+     * @return repository name\n+     */\n+    public String repository() {\n+        return this.repository;\n+    }\n+\n+    /**\n+     * Sets the name of the index that should be restored from snapshot\n+     */\n+    public MountSearchableSnapshotRequest snapshotIndex(String indexName) {\n+        this.snapshotIndex = indexName;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns index that should be restored from snapshot\n+     */\n+    public String snapshotIndex() {\n+        return snapshotIndex;\n+    }\n+\n+    /**\n+     * Returns new index name after the snapshot has been mounted\n+     */\n+    public String mountedIndex() {\n+        return mountedIndex;\n+    }\n+\n+    /**\n+     * If this parameter is set to true the operation will wait for completion of restore process before returning.\n+     *\n+     * @param waitForCompletion if true the operation will wait for completion\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest waitForCompletion(boolean waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns wait for completion setting\n+     *\n+     * @return true if the operation will wait for completion\n+     */\n+    public boolean waitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets repository-specific restore settings.\n+     * <p>\n+     * See repository documentation for more information.\n+     *\n+     * @param settings repository-specific snapshot settings\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest settings(Settings settings) {", "originalCommit": "c847e035baa2e0b370808aa7a52a6d59c5256a44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1NzIyNg==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387857226", "bodyText": "I believe you can override repository-specific settings on a restore (things like speed), these are passed through to the settings that RestoreSnapshotRequest takes", "author": "dakrone", "createdAt": "2020-03-04T18:37:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1MzkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkxNzMzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r388917335", "bodyText": "It looks like these settings are unused. I have removed them from the API here, and in the  future we can remove them from the usual restore process too.", "author": "DaveCTurner", "createdAt": "2020-03-06T14:00:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1MzkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1ODI3MA==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387558270", "bodyText": "I'm wondering if we need these verification - maybe we could just let the Restore action do it for us? (and configure appropriate indices options like ignore_unavailable: false)", "author": "tlrx", "createdAt": "2020-03-04T09:56:28Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportMountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.StepListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.RepositoryData;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+\n+public class TransportMountSearchableSnapshotAction\n+    extends TransportMasterNodeAction<MountSearchableSnapshotRequest, RestoreSnapshotResponse> {\n+\n+    private final Client client;\n+    private final RepositoriesService repositoriesService;\n+\n+    @Inject\n+    public TransportMountSearchableSnapshotAction(TransportService transportService, ClusterService clusterService, Client client,\n+                                                  ThreadPool threadPool, RepositoriesService repositoriesService,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MountSearchableSnapshotAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MountSearchableSnapshotRequest::new, indexNameExpressionResolver);\n+        this.client = client;\n+        this.repositoriesService = repositoriesService;\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        // Using the generic instead of the snapshot threadpool here as the snapshot threadpool might be blocked on long running tasks\n+        // which would block the request from getting an error response because of the ongoing task\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    @Override\n+    protected RestoreSnapshotResponse read(StreamInput in) throws IOException {\n+        return new RestoreSnapshotResponse(in);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkBlock(MountSearchableSnapshotRequest request, ClusterState state) {\n+        // Restoring a snapshot might change the global state and create/change an index,\n+        // so we need to check for METADATA_WRITE and WRITE blocks\n+        ClusterBlockException blockException = state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE);\n+        if (blockException != null) {\n+            return blockException;\n+        }\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.WRITE);\n+\n+    }\n+\n+    /**\n+     * Return the index settings required to make a snapshot searchable\n+     */\n+    private static Settings getIndexSettings(String repoName, SnapshotId snapshotId, IndexId indexId) {\n+        return Settings.builder()\n+            .put(SearchableSnapshotRepository.SNAPSHOT_REPOSITORY_SETTING.getKey(), repoName)\n+            .put(SearchableSnapshotRepository.SNAPSHOT_SNAPSHOT_NAME_SETTING.getKey(), snapshotId.getName())\n+            .put(SearchableSnapshotRepository.SNAPSHOT_SNAPSHOT_ID_SETTING.getKey(), snapshotId.getUUID())\n+            .put(SearchableSnapshotRepository.SNAPSHOT_INDEX_ID_SETTING.getKey(), indexId.getId())\n+            .put(INDEX_STORE_TYPE_SETTING.getKey(), SearchableSnapshotRepository.SNAPSHOT_DIRECTORY_FACTORY_KEY)\n+            .put(IndexMetaData.SETTING_BLOCKS_WRITE, true)\n+            .build();\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, final MountSearchableSnapshotRequest request, final ClusterState state,\n+                                   final ActionListener<RestoreSnapshotResponse> listener) {\n+        final String repoName = request.repository();\n+        final String snapName = request.snapshot();\n+        final String indexName = request.snapshotIndex();\n+\n+        // Retrieve IndexId and SnapshotId instances, which are then used to create a new restore\n+        // request, which is then sent on to the actual snapshot restore mechanism\n+        final Repository repository = repositoriesService.repository(repoName);\n+        final StepListener<RepositoryData> repositoryDataListener = new StepListener<>();\n+        repository.getRepositoryData(repositoryDataListener);\n+        repositoryDataListener.whenComplete(repoData -> {\n+            final Map<String, IndexId> indexIds = repoData.getIndices();\n+\n+            if (indexIds.containsKey(indexName) == false && indexIds.get(indexName) != null) {", "originalCommit": "c847e035baa2e0b370808aa7a52a6d59c5256a44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1ODA5MA==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387858090", "bodyText": "If we don't have these then we can't fetch the IndexId, so essentially we'd be sending a half-broken restore (because it would be missing crucial index settings required for searchable snapshots to work) in order to push the error elsewhere, I'd rather do the verification as soon as possible so we don't pass around half-broken requests (and do one fewer internal transport requests)", "author": "dakrone", "createdAt": "2020-03-04T18:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1ODI3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzNzE1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389537155", "bodyText": "Yes, sorry for the noise. I've been too quick at commenting here.", "author": "tlrx", "createdAt": "2020-03-09T09:15:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1ODI3MA=="}], "type": "inlineReview"}, {"oid": "0cd28a37065b221b124d3e890f94cd6d0943023d", "url": "https://github.com/elastic/elasticsearch/commit/0cd28a37065b221b124d3e890f94cd6d0943023d", "message": "Update docstring for MountSearchableSnapshotRequest constructor", "committedDate": "2020-03-04T18:34:09Z", "type": "commit"}, {"oid": "2bcab06cc58edf8981945f408dee83b40a8fecd0", "url": "https://github.com/elastic/elasticsearch/commit/2bcab06cc58edf8981945f408dee83b40a8fecd0", "message": "Remove extra line", "committedDate": "2020-03-04T18:34:40Z", "type": "commit"}, {"oid": "000ee16dffa1b1b82fc4f7f6bc444677c932db53", "url": "https://github.com/elastic/elasticsearch/commit/000ee16dffa1b1b82fc4f7f6bc444677c932db53", "message": "Wrap repository fetching in try/catch", "committedDate": "2020-03-04T18:36:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE3MzExMA==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r388173110", "bodyText": "I'd prefer we did this TODO in this PR, since I think it would mean we could drop the need for validation and make all the required fields into constructor args (and final) instead.", "author": "DaveCTurner", "createdAt": "2020-03-05T09:32:35Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotRequest.java", "diffHunk": "@@ -0,0 +1,435 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchGenerationException;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.MasterNodeRequest;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+import static org.elasticsearch.common.settings.Settings.Builder.EMPTY_SETTINGS;\n+import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;\n+import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;\n+\n+public class MountSearchableSnapshotRequest extends MasterNodeRequest<MountSearchableSnapshotRequest> implements ToXContentObject {\n+\n+    private final String mountedIndex;\n+    private String snapshot;\n+    private String repository;\n+    private String snapshotIndex;\n+    private Boolean waitForCompletion;\n+    private Settings settings = EMPTY_SETTINGS;\n+    private Settings indexSettings = EMPTY_SETTINGS;\n+    private String[] ignoreIndexSettings = Strings.EMPTY_ARRAY;\n+\n+    /**\n+     * Constructs a new mount searchable snapshot request, restoring an index under the given mountedIndex name\n+     */\n+    public MountSearchableSnapshotRequest(String mountedIndex) {\n+        this.mountedIndex = mountedIndex;\n+    }\n+\n+    public MountSearchableSnapshotRequest(StreamInput in) throws IOException {\n+        super(in);\n+        this.snapshot = in.readString();\n+        this.repository = in.readString();\n+        this.snapshotIndex = in.readString();\n+        this.mountedIndex = in.readString();\n+        this.waitForCompletion = in.readOptionalBoolean();\n+        this.settings = readSettingsFromStream(in);\n+        this.indexSettings = readSettingsFromStream(in);\n+        this.ignoreIndexSettings = in.readStringArray();\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeString(snapshot);\n+        out.writeString(repository);\n+        out.writeString(snapshotIndex);\n+        out.writeString(mountedIndex);\n+        out.writeOptionalBoolean(waitForCompletion);\n+        writeSettingsToStream(settings, out);\n+        writeSettingsToStream(indexSettings, out);\n+        out.writeStringArray(ignoreIndexSettings);\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = null;\n+        if (snapshot == null) {\n+            validationException = addValidationError(\"snapshot name is missing\", validationException);\n+        }\n+        if (repository == null) {\n+            validationException = addValidationError(\"repository is missing\", validationException);\n+        }\n+        if (snapshotIndex == null) {\n+            validationException = addValidationError(\"index name from snapshot is missing\", validationException);\n+        }\n+        if (mountedIndex == null) {\n+            validationException = addValidationError(\"index name to mount is missing\", validationException);\n+        }\n+        if (settings == null) {\n+            validationException = addValidationError(\"settings are missing\", validationException);\n+        }\n+        if (indexSettings == null) {\n+            validationException = addValidationError(\"indexSettings are missing\", validationException);\n+        }\n+        return validationException;\n+    }\n+\n+    /**\n+     * Sets the name of the snapshot.\n+     *\n+     * @param snapshot snapshot name\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest snapshot(String snapshot) {\n+        this.snapshot = snapshot;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns the name of the snapshot.\n+     *\n+     * @return snapshot name\n+     */\n+    public String snapshot() {\n+        return this.snapshot;\n+    }\n+\n+    /**\n+     * Sets repository name\n+     *\n+     * @param repository repository name\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest repository(String repository) {\n+        this.repository = repository;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns repository name\n+     *\n+     * @return repository name\n+     */\n+    public String repository() {\n+        return this.repository;\n+    }\n+\n+    /**\n+     * Sets the name of the index that should be restored from snapshot\n+     */\n+    public MountSearchableSnapshotRequest snapshotIndex(String indexName) {\n+        this.snapshotIndex = indexName;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns index that should be restored from snapshot\n+     */\n+    public String snapshotIndex() {\n+        return snapshotIndex;\n+    }\n+\n+    /**\n+     * Returns new index name after the snapshot has been mounted\n+     */\n+    public String mountedIndex() {\n+        return mountedIndex;\n+    }\n+\n+    /**\n+     * If this parameter is set to true the operation will wait for completion of restore process before returning.\n+     *\n+     * @param waitForCompletion if true the operation will wait for completion\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest waitForCompletion(boolean waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns wait for completion setting\n+     *\n+     * @return true if the operation will wait for completion\n+     */\n+    public boolean waitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets repository-specific restore settings.\n+     * <p>\n+     * See repository documentation for more information.\n+     *\n+     * @param settings repository-specific snapshot settings\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest settings(Settings settings) {\n+        this.settings = settings;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets repository-specific restore settings.\n+     * <p>\n+     * See repository documentation for more information.\n+     *\n+     * @param settings repository-specific snapshot settings\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest settings(Settings.Builder settings) {\n+        this.settings = settings.build();\n+        return this;\n+    }\n+\n+    /**\n+     * Sets repository-specific restore settings in JSON or YAML format\n+     * <p>\n+     * See repository documentation for more information.\n+     *\n+     * @param source repository-specific snapshot settings\n+     * @param xContentType the content type of the source\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest settings(String source, XContentType xContentType) {\n+        this.settings = Settings.builder().loadFromSource(source, xContentType).build();\n+        return this;\n+    }\n+\n+    /**\n+     * Sets repository-specific restore settings\n+     * <p>\n+     * See repository documentation for more information.\n+     *\n+     * @param source repository-specific snapshot settings\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest settings(Map<String, Object> source) {\n+        try {\n+            XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);\n+            builder.map(source);\n+            settings(Strings.toString(builder), builder.contentType());\n+        } catch (IOException e) {\n+            throw new ElasticsearchGenerationException(\"Failed to generate [\" + source + \"]\", e);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Returns repository-specific restore settings\n+     *\n+     * @return restore settings\n+     */\n+    public Settings settings() {\n+        return this.settings;\n+    }\n+\n+    /**\n+     * Sets the list of index settings and index settings groups that shouldn't be restored from snapshot\n+     */\n+    public MountSearchableSnapshotRequest ignoreIndexSettings(String... ignoreIndexSettings) {\n+        this.ignoreIndexSettings = ignoreIndexSettings;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the list of index settings and index settings groups that shouldn't be restored from snapshot\n+     */\n+    public MountSearchableSnapshotRequest ignoreIndexSettings(List<String> ignoreIndexSettings) {\n+        this.ignoreIndexSettings = ignoreIndexSettings.toArray(new String[ignoreIndexSettings.size()]);\n+        return this;\n+    }\n+\n+    /**\n+     * Returns the list of index settings and index settings groups that shouldn't be restored from snapshot\n+     */\n+    public String[] ignoreIndexSettings() {\n+        return ignoreIndexSettings;\n+    }\n+\n+    /**\n+     * Sets settings that should be added/changed for restored index\n+     */\n+    public MountSearchableSnapshotRequest indexSettings(Settings settings) {\n+        this.indexSettings = settings;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets settings that should be added/changed for restored index\n+     */\n+    public MountSearchableSnapshotRequest indexSettings(Settings.Builder settings) {\n+        this.indexSettings = settings.build();\n+        return this;\n+    }\n+\n+    /**\n+     * Sets settings that should be added/changed for restored index\n+     */\n+    public MountSearchableSnapshotRequest indexSettings(String source, XContentType xContentType) {\n+        this.indexSettings = Settings.builder().loadFromSource(source, xContentType).build();\n+        return this;\n+    }\n+\n+    /**\n+     * Sets settings that should be added/changed for restored index\n+     */\n+    public MountSearchableSnapshotRequest indexSettings(Map<String, Object> source) {\n+        try {\n+            XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);\n+            builder.map(source);\n+            indexSettings(Strings.toString(builder), builder.contentType());\n+        } catch (IOException e) {\n+            throw new ElasticsearchGenerationException(\"Failed to generate [\" + source + \"]\", e);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Returns settings that should be added/changed for restored index\n+     */\n+    public Settings indexSettings() {\n+        return this.indexSettings;\n+    }\n+\n+    /**\n+     * Parses mount definition\n+     *\n+     * @param source mount definition\n+     * @return this request\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MountSearchableSnapshotRequest source(Map<String, Object> source) {\n+        // TODO: this could be rewritten with a Constructing Object Parser rather than manually\n+        //  parsing the XContent, this was copied/modified from RestoreSnapshotRequest", "originalCommit": "000ee16dffa1b1b82fc4f7f6bc444677c932db53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE4Mzk0OA==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r388183948", "bodyText": "I think just POST is sufficient, in line with the restore API. We're not creating a resource at this URI as PUT  would imply.", "author": "DaveCTurner", "createdAt": "2020-03-05T09:51:35Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/rest/RestMountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.rest;\n+\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.action.RestToXContentListener;\n+import org.elasticsearch.xpack.searchablesnapshots.action.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.searchablesnapshots.action.MountSearchableSnapshotRequest;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.POST;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+public class RestMountSearchableSnapshotAction extends BaseRestHandler {\n+    @Override\n+    public String getName() {\n+        return \"mount_snapshot_action\";\n+    }\n+\n+    @Override\n+    public List<Route> routes() {\n+        return Arrays.asList(new Route(POST, \"/{index}/_snapshot/mount\"),\n+            new Route(PUT, \"/{index}/_snapshot/mount\"));", "originalCommit": "000ee16dffa1b1b82fc4f7f6bc444677c932db53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "74212e11ba35bdda4f07e216d15bfc3631eb2ccf", "url": "https://github.com/elastic/elasticsearch/commit/74212e11ba35bdda4f07e216d15bfc3631eb2ccf", "message": "ConstructingObjectParser", "committedDate": "2020-03-05T18:00:00Z", "type": "commit"}, {"oid": "b4933e547ef34a23fbc522c70205567d36d5b5d9", "url": "https://github.com/elastic/elasticsearch/commit/b4933e547ef34a23fbc522c70205567d36d5b5d9", "message": "Tidy up transport action", "committedDate": "2020-03-06T11:08:52Z", "type": "commit"}, {"oid": "ff16586957b240aeba35d9a9a6b23f6f37006b5d", "url": "https://github.com/elastic/elasticsearch/commit/ff16586957b240aeba35d9a9a6b23f6f37006b5d", "message": "Revert", "committedDate": "2020-03-06T11:08:52Z", "type": "commit"}, {"oid": "520673e5505ade3a6e17a73829ebd71f6822d0a8", "url": "https://github.com/elastic/elasticsearch/commit/520673e5505ade3a6e17a73829ebd71f6822d0a8", "message": "Fix up REST tests and a  bit of a refactor", "committedDate": "2020-03-06T12:23:22Z", "type": "commit"}, {"oid": "4cbf27e33c1f4ff28475cf2705136fbe3d46711c", "url": "https://github.com/elastic/elasticsearch/commit/4cbf27e33c1f4ff28475cf2705136fbe3d46711c", "message": "Move more code  out  of SearchableSnapshotRepository", "committedDate": "2020-03-06T12:37:34Z", "type": "commit"}, {"oid": "4ad409b41801d78137832d0c8f3d099a4f968853", "url": "https://github.com/elastic/elasticsearch/commit/4ad409b41801d78137832d0c8f3d099a4f968853", "message": "Move factory around", "committedDate": "2020-03-06T12:47:15Z", "type": "commit"}, {"oid": "f44d68fcb7bcf84874398d366bd4555bc0151056", "url": "https://github.com/elastic/elasticsearch/commit/f44d68fcb7bcf84874398d366bd4555bc0151056", "message": "Move settings etc.", "committedDate": "2020-03-06T12:52:21Z", "type": "commit"}, {"oid": "595a74f2bee65cee0fd6066e0e5533bd3949af54", "url": "https://github.com/elastic/elasticsearch/commit/595a74f2bee65cee0fd6066e0e5533bd3949af54", "message": "Whitespace", "committedDate": "2020-03-06T13:04:07Z", "type": "commit"}, {"oid": "924a74131ccae10ed0d9414f87552a02facce63e", "url": "https://github.com/elastic/elasticsearch/commit/924a74131ccae10ed0d9414f87552a02facce63e", "message": "Less nullability", "committedDate": "2020-03-06T13:15:49Z", "type": "commit"}, {"oid": "fd9d85803494939cc2facbb96e4c7b003080b62b", "url": "https://github.com/elastic/elasticsearch/commit/fd9d85803494939cc2facbb96e4c7b003080b62b", "message": "Final", "committedDate": "2020-03-06T13:16:57Z", "type": "commit"}, {"oid": "7297b3583383b899986e04f754851ef182a2a152", "url": "https://github.com/elastic/elasticsearch/commit/7297b3583383b899986e04f754851ef182a2a152", "message": "More tidy", "committedDate": "2020-03-06T13:33:06Z", "type": "commit"}, {"oid": "dae1d9328687eb96c0038c2d463c970e89dcb353", "url": "https://github.com/elastic/elasticsearch/commit/dae1d9328687eb96c0038c2d463c970e89dcb353", "message": "Rejig API shape", "committedDate": "2020-03-06T13:54:42Z", "type": "commit"}, {"oid": "366f4561a03ff02e35a5005a4443f259e4bbdaf6", "url": "https://github.com/elastic/elasticsearch/commit/366f4561a03ff02e35a5005a4443f259e4bbdaf6", "message": "Merge branch 'feature/searchable-snapshots' into ss-add-dedicated-restore-api", "committedDate": "2020-03-06T14:06:01Z", "type": "commit"}, {"oid": "96ab3241962d5a38d94f82185f9667f209dd4e4c", "url": "https://github.com/elastic/elasticsearch/commit/96ab3241962d5a38d94f82185f9667f209dd4e4c", "message": "Merge branch 'feature/searchable-snapshots' into ss-add-dedicated-restore-api", "committedDate": "2020-03-06T16:20:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUyNzUxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389527515", "bodyText": "Should we validate that the request contains a repo/snapshot/index?", "author": "tlrx", "createdAt": "2020-03-09T08:54:41Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotRequest.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.master.MasterNodeRequest;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;\n+import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+\n+public class MountSearchableSnapshotRequest extends MasterNodeRequest<MountSearchableSnapshotRequest> implements ToXContentObject {\n+\n+    public static final ConstructingObjectParser<MountSearchableSnapshotRequest, RequestParams> PARSER = new ConstructingObjectParser<>(\n+        \"mount_searchable_snapshot\", true,\n+        (a, p) -> new MountSearchableSnapshotRequest(\n+            Objects.requireNonNullElse((String)a[1], (String)a[0]),\n+            p.repositoryName,\n+            p.snapshotName,\n+            (String)a[0],\n+            Objects.requireNonNullElse((Settings)a[2], Settings.EMPTY),\n+            Objects.requireNonNullElse((String[])a[3], Strings.EMPTY_ARRAY),\n+            p.waitForCompletion));\n+\n+    private static final ParseField INDEX_FIELD = new ParseField(\"index\");\n+    private static final ParseField RENAMED_INDEX_FIELD = new ParseField(\"renamed_index\");\n+    private static final ParseField INDEX_SETTINGS_FIELD = new ParseField(\"index_settings\");\n+    private static final ParseField IGNORE_INDEX_SETTINGS_FIELD = new ParseField(\"ignore_index_settings\");\n+\n+    static {\n+        PARSER.declareField(constructorArg(), XContentParser::text, INDEX_FIELD, ObjectParser.ValueType.STRING);\n+        PARSER.declareField(optionalConstructorArg(), XContentParser::text, RENAMED_INDEX_FIELD, ObjectParser.ValueType.STRING);\n+        PARSER.declareField(optionalConstructorArg(), Settings::fromXContent, INDEX_SETTINGS_FIELD, ObjectParser.ValueType.OBJECT);\n+        PARSER.declareField(optionalConstructorArg(),\n+            p -> p.list().stream().map(s -> (String) s).collect(Collectors.toList()).toArray(Strings.EMPTY_ARRAY),\n+            IGNORE_INDEX_SETTINGS_FIELD, ObjectParser.ValueType.STRING_ARRAY);\n+    }\n+\n+    public static class RequestParams {\n+        private final String repositoryName;\n+        private final String snapshotName;\n+        final boolean waitForCompletion;\n+\n+        public RequestParams(String repositoryName, String snapshotName, boolean waitForCompletion) {\n+            this.repositoryName = repositoryName;\n+            this.snapshotName = snapshotName;\n+            this.waitForCompletion = waitForCompletion;\n+        }\n+    }\n+\n+    private final String mountedIndexName;\n+    private final String repositoryName;\n+    private final String snapshotName;\n+    private final String snapshotIndexName;\n+    private final Settings indexSettings;\n+    private final String[] ignoredIndexSettings;\n+    private final boolean waitForCompletion;\n+\n+    /**\n+     * Constructs a new mount searchable snapshot request, restoring an index with the settings needed to make it a searchable snapshot.\n+     */\n+    public MountSearchableSnapshotRequest(String mountedIndexName, String repositoryName, String snapshotName, String snapshotIndexName,\n+                                          Settings indexSettings, String[] ignoredIndexSettings, boolean waitForCompletion) {\n+        this.mountedIndexName = Objects.requireNonNull(mountedIndexName);\n+        this.repositoryName = Objects.requireNonNull(repositoryName);\n+        this.snapshotName = Objects.requireNonNull(snapshotName);\n+        this.snapshotIndexName = Objects.requireNonNull(snapshotIndexName);\n+        this.indexSettings = Objects.requireNonNull(indexSettings);\n+        this.ignoredIndexSettings = Objects.requireNonNull(ignoredIndexSettings);\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    MountSearchableSnapshotRequest(StreamInput in) throws IOException {\n+        super(in);\n+        this.mountedIndexName = in.readString();\n+        this.repositoryName = in.readString();\n+        this.snapshotName = in.readString();\n+        this.snapshotIndexName = in.readOptionalString();\n+        this.indexSettings = readSettingsFromStream(in);\n+        this.ignoredIndexSettings = in.readStringArray();\n+        this.waitForCompletion = in.readBoolean();\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeString(mountedIndexName);\n+        out.writeString(repositoryName);\n+        out.writeString(snapshotName);\n+        out.writeOptionalString(snapshotIndexName);\n+        writeSettingsToStream(indexSettings, out);\n+        out.writeStringArray(ignoredIndexSettings);\n+        out.writeBoolean(waitForCompletion);\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+       return null;", "originalCommit": "96ab3241962d5a38d94f82185f9667f209dd4e4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwNDI1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389604253", "bodyText": "They can't be null by construction (we use Objects.requireNonNull in the constructor).", "author": "DaveCTurner", "createdAt": "2020-03-09T11:32:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUyNzUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzMTE0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389531147", "bodyText": "Maybe pass the RestRequest directly to the ObjectParser's context when applying the parsing logic?", "author": "tlrx", "createdAt": "2020-03-09T09:02:42Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotRequest.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.master.MasterNodeRequest;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;\n+import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+\n+public class MountSearchableSnapshotRequest extends MasterNodeRequest<MountSearchableSnapshotRequest> implements ToXContentObject {\n+\n+    public static final ConstructingObjectParser<MountSearchableSnapshotRequest, RequestParams> PARSER = new ConstructingObjectParser<>(\n+        \"mount_searchable_snapshot\", true,\n+        (a, p) -> new MountSearchableSnapshotRequest(\n+            Objects.requireNonNullElse((String)a[1], (String)a[0]),\n+            p.repositoryName,\n+            p.snapshotName,\n+            (String)a[0],\n+            Objects.requireNonNullElse((Settings)a[2], Settings.EMPTY),\n+            Objects.requireNonNullElse((String[])a[3], Strings.EMPTY_ARRAY),\n+            p.waitForCompletion));\n+\n+    private static final ParseField INDEX_FIELD = new ParseField(\"index\");\n+    private static final ParseField RENAMED_INDEX_FIELD = new ParseField(\"renamed_index\");\n+    private static final ParseField INDEX_SETTINGS_FIELD = new ParseField(\"index_settings\");\n+    private static final ParseField IGNORE_INDEX_SETTINGS_FIELD = new ParseField(\"ignore_index_settings\");\n+\n+    static {\n+        PARSER.declareField(constructorArg(), XContentParser::text, INDEX_FIELD, ObjectParser.ValueType.STRING);\n+        PARSER.declareField(optionalConstructorArg(), XContentParser::text, RENAMED_INDEX_FIELD, ObjectParser.ValueType.STRING);\n+        PARSER.declareField(optionalConstructorArg(), Settings::fromXContent, INDEX_SETTINGS_FIELD, ObjectParser.ValueType.OBJECT);\n+        PARSER.declareField(optionalConstructorArg(),\n+            p -> p.list().stream().map(s -> (String) s).collect(Collectors.toList()).toArray(Strings.EMPTY_ARRAY),\n+            IGNORE_INDEX_SETTINGS_FIELD, ObjectParser.ValueType.STRING_ARRAY);\n+    }\n+\n+    public static class RequestParams {", "originalCommit": "96ab3241962d5a38d94f82185f9667f209dd4e4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwNDAzNw==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389604037", "bodyText": "Sure, done in dbe178f.", "author": "DaveCTurner", "createdAt": "2020-03-09T11:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzMTE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzMjMzMg==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389532332", "bodyText": "Generating a XContent from a request object is useful for the RestHighLevelClient only (we don't really need it for testing the server logic) so I think this code should be moved to the rest-high-level project in a different PR. We'll have to upgrade the RestHighLevelClient to support other searchable snapshot APIs anyway and we can do it later.", "author": "tlrx", "createdAt": "2020-03-09T09:05:20Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotRequest.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.master.MasterNodeRequest;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;\n+import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+\n+public class MountSearchableSnapshotRequest extends MasterNodeRequest<MountSearchableSnapshotRequest> implements ToXContentObject {\n+\n+    public static final ConstructingObjectParser<MountSearchableSnapshotRequest, RequestParams> PARSER = new ConstructingObjectParser<>(\n+        \"mount_searchable_snapshot\", true,\n+        (a, p) -> new MountSearchableSnapshotRequest(\n+            Objects.requireNonNullElse((String)a[1], (String)a[0]),\n+            p.repositoryName,\n+            p.snapshotName,\n+            (String)a[0],\n+            Objects.requireNonNullElse((Settings)a[2], Settings.EMPTY),\n+            Objects.requireNonNullElse((String[])a[3], Strings.EMPTY_ARRAY),\n+            p.waitForCompletion));\n+\n+    private static final ParseField INDEX_FIELD = new ParseField(\"index\");\n+    private static final ParseField RENAMED_INDEX_FIELD = new ParseField(\"renamed_index\");\n+    private static final ParseField INDEX_SETTINGS_FIELD = new ParseField(\"index_settings\");\n+    private static final ParseField IGNORE_INDEX_SETTINGS_FIELD = new ParseField(\"ignore_index_settings\");\n+\n+    static {\n+        PARSER.declareField(constructorArg(), XContentParser::text, INDEX_FIELD, ObjectParser.ValueType.STRING);\n+        PARSER.declareField(optionalConstructorArg(), XContentParser::text, RENAMED_INDEX_FIELD, ObjectParser.ValueType.STRING);\n+        PARSER.declareField(optionalConstructorArg(), Settings::fromXContent, INDEX_SETTINGS_FIELD, ObjectParser.ValueType.OBJECT);\n+        PARSER.declareField(optionalConstructorArg(),\n+            p -> p.list().stream().map(s -> (String) s).collect(Collectors.toList()).toArray(Strings.EMPTY_ARRAY),\n+            IGNORE_INDEX_SETTINGS_FIELD, ObjectParser.ValueType.STRING_ARRAY);\n+    }\n+\n+    public static class RequestParams {\n+        private final String repositoryName;\n+        private final String snapshotName;\n+        final boolean waitForCompletion;\n+\n+        public RequestParams(String repositoryName, String snapshotName, boolean waitForCompletion) {\n+            this.repositoryName = repositoryName;\n+            this.snapshotName = snapshotName;\n+            this.waitForCompletion = waitForCompletion;\n+        }\n+    }\n+\n+    private final String mountedIndexName;\n+    private final String repositoryName;\n+    private final String snapshotName;\n+    private final String snapshotIndexName;\n+    private final Settings indexSettings;\n+    private final String[] ignoredIndexSettings;\n+    private final boolean waitForCompletion;\n+\n+    /**\n+     * Constructs a new mount searchable snapshot request, restoring an index with the settings needed to make it a searchable snapshot.\n+     */\n+    public MountSearchableSnapshotRequest(String mountedIndexName, String repositoryName, String snapshotName, String snapshotIndexName,\n+                                          Settings indexSettings, String[] ignoredIndexSettings, boolean waitForCompletion) {\n+        this.mountedIndexName = Objects.requireNonNull(mountedIndexName);\n+        this.repositoryName = Objects.requireNonNull(repositoryName);\n+        this.snapshotName = Objects.requireNonNull(snapshotName);\n+        this.snapshotIndexName = Objects.requireNonNull(snapshotIndexName);\n+        this.indexSettings = Objects.requireNonNull(indexSettings);\n+        this.ignoredIndexSettings = Objects.requireNonNull(ignoredIndexSettings);\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    MountSearchableSnapshotRequest(StreamInput in) throws IOException {\n+        super(in);\n+        this.mountedIndexName = in.readString();\n+        this.repositoryName = in.readString();\n+        this.snapshotName = in.readString();\n+        this.snapshotIndexName = in.readOptionalString();\n+        this.indexSettings = readSettingsFromStream(in);\n+        this.ignoredIndexSettings = in.readStringArray();\n+        this.waitForCompletion = in.readBoolean();\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeString(mountedIndexName);\n+        out.writeString(repositoryName);\n+        out.writeString(snapshotName);\n+        out.writeOptionalString(snapshotIndexName);\n+        writeSettingsToStream(indexSettings, out);\n+        out.writeStringArray(ignoredIndexSettings);\n+        out.writeBoolean(waitForCompletion);\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+       return null;\n+    }\n+\n+    /**\n+     * @return the name of the index that will be created\n+     */\n+    public String mountedIndexName() {\n+        return mountedIndexName;\n+    }\n+\n+    /**\n+     * @return the name of the repository\n+     */\n+    public String repositoryName() {\n+        return this.repositoryName;\n+    }\n+\n+    /**\n+     * @return the name of the snapshot.\n+     */\n+    public String snapshotName() {\n+        return this.snapshotName;\n+    }\n+\n+    /**\n+     * @return the name of the index contained in the snapshot\n+     */\n+    public String snapshotIndexName() {\n+        return snapshotIndexName;\n+    }\n+\n+    /**\n+     * @return true if the operation will wait for completion\n+     */\n+    public boolean waitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * @return settings that should be added to the index when it is mounted\n+     */\n+    public Settings indexSettings() {\n+        return this.indexSettings;\n+    }\n+\n+    /**\n+     * @return the names of settings that should be removed from the index when it is mounted\n+     */\n+    public String[] ignoreIndexSettings() {\n+        return ignoredIndexSettings;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {", "originalCommit": "96ab3241962d5a38d94f82185f9667f209dd4e4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwMzkyNA==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389603924", "bodyText": "Ok, I've removed this in 4a7588f and added a note to #50999 to revisit client support later.", "author": "DaveCTurner", "createdAt": "2020-03-09T11:31:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzMjMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzMjgyMA==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389532820", "bodyText": "Maybe:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return \"mount snapshot [\" + repositoryName + \":\" + snapshotName + \":\" + snapshotIndexName + \"->\" + mountedIndexName + \"]\";\n          \n          \n            \n                    return \"mount snapshot [\" + repositoryName + \":\" + snapshotName + \":\" + snapshotIndexName + \"] as index [\" + mountedIndexName + \"]\";", "author": "tlrx", "createdAt": "2020-03-09T09:06:21Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotRequest.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.master.MasterNodeRequest;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;\n+import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+\n+public class MountSearchableSnapshotRequest extends MasterNodeRequest<MountSearchableSnapshotRequest> implements ToXContentObject {\n+\n+    public static final ConstructingObjectParser<MountSearchableSnapshotRequest, RequestParams> PARSER = new ConstructingObjectParser<>(\n+        \"mount_searchable_snapshot\", true,\n+        (a, p) -> new MountSearchableSnapshotRequest(\n+            Objects.requireNonNullElse((String)a[1], (String)a[0]),\n+            p.repositoryName,\n+            p.snapshotName,\n+            (String)a[0],\n+            Objects.requireNonNullElse((Settings)a[2], Settings.EMPTY),\n+            Objects.requireNonNullElse((String[])a[3], Strings.EMPTY_ARRAY),\n+            p.waitForCompletion));\n+\n+    private static final ParseField INDEX_FIELD = new ParseField(\"index\");\n+    private static final ParseField RENAMED_INDEX_FIELD = new ParseField(\"renamed_index\");\n+    private static final ParseField INDEX_SETTINGS_FIELD = new ParseField(\"index_settings\");\n+    private static final ParseField IGNORE_INDEX_SETTINGS_FIELD = new ParseField(\"ignore_index_settings\");\n+\n+    static {\n+        PARSER.declareField(constructorArg(), XContentParser::text, INDEX_FIELD, ObjectParser.ValueType.STRING);\n+        PARSER.declareField(optionalConstructorArg(), XContentParser::text, RENAMED_INDEX_FIELD, ObjectParser.ValueType.STRING);\n+        PARSER.declareField(optionalConstructorArg(), Settings::fromXContent, INDEX_SETTINGS_FIELD, ObjectParser.ValueType.OBJECT);\n+        PARSER.declareField(optionalConstructorArg(),\n+            p -> p.list().stream().map(s -> (String) s).collect(Collectors.toList()).toArray(Strings.EMPTY_ARRAY),\n+            IGNORE_INDEX_SETTINGS_FIELD, ObjectParser.ValueType.STRING_ARRAY);\n+    }\n+\n+    public static class RequestParams {\n+        private final String repositoryName;\n+        private final String snapshotName;\n+        final boolean waitForCompletion;\n+\n+        public RequestParams(String repositoryName, String snapshotName, boolean waitForCompletion) {\n+            this.repositoryName = repositoryName;\n+            this.snapshotName = snapshotName;\n+            this.waitForCompletion = waitForCompletion;\n+        }\n+    }\n+\n+    private final String mountedIndexName;\n+    private final String repositoryName;\n+    private final String snapshotName;\n+    private final String snapshotIndexName;\n+    private final Settings indexSettings;\n+    private final String[] ignoredIndexSettings;\n+    private final boolean waitForCompletion;\n+\n+    /**\n+     * Constructs a new mount searchable snapshot request, restoring an index with the settings needed to make it a searchable snapshot.\n+     */\n+    public MountSearchableSnapshotRequest(String mountedIndexName, String repositoryName, String snapshotName, String snapshotIndexName,\n+                                          Settings indexSettings, String[] ignoredIndexSettings, boolean waitForCompletion) {\n+        this.mountedIndexName = Objects.requireNonNull(mountedIndexName);\n+        this.repositoryName = Objects.requireNonNull(repositoryName);\n+        this.snapshotName = Objects.requireNonNull(snapshotName);\n+        this.snapshotIndexName = Objects.requireNonNull(snapshotIndexName);\n+        this.indexSettings = Objects.requireNonNull(indexSettings);\n+        this.ignoredIndexSettings = Objects.requireNonNull(ignoredIndexSettings);\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    MountSearchableSnapshotRequest(StreamInput in) throws IOException {\n+        super(in);\n+        this.mountedIndexName = in.readString();\n+        this.repositoryName = in.readString();\n+        this.snapshotName = in.readString();\n+        this.snapshotIndexName = in.readOptionalString();\n+        this.indexSettings = readSettingsFromStream(in);\n+        this.ignoredIndexSettings = in.readStringArray();\n+        this.waitForCompletion = in.readBoolean();\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeString(mountedIndexName);\n+        out.writeString(repositoryName);\n+        out.writeString(snapshotName);\n+        out.writeOptionalString(snapshotIndexName);\n+        writeSettingsToStream(indexSettings, out);\n+        out.writeStringArray(ignoredIndexSettings);\n+        out.writeBoolean(waitForCompletion);\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+       return null;\n+    }\n+\n+    /**\n+     * @return the name of the index that will be created\n+     */\n+    public String mountedIndexName() {\n+        return mountedIndexName;\n+    }\n+\n+    /**\n+     * @return the name of the repository\n+     */\n+    public String repositoryName() {\n+        return this.repositoryName;\n+    }\n+\n+    /**\n+     * @return the name of the snapshot.\n+     */\n+    public String snapshotName() {\n+        return this.snapshotName;\n+    }\n+\n+    /**\n+     * @return the name of the index contained in the snapshot\n+     */\n+    public String snapshotIndexName() {\n+        return snapshotIndexName;\n+    }\n+\n+    /**\n+     * @return true if the operation will wait for completion\n+     */\n+    public boolean waitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * @return settings that should be added to the index when it is mounted\n+     */\n+    public Settings indexSettings() {\n+        return this.indexSettings;\n+    }\n+\n+    /**\n+     * @return the names of settings that should be removed from the index when it is mounted\n+     */\n+    public String[] ignoreIndexSettings() {\n+        return ignoredIndexSettings;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(INDEX_FIELD.getPreferredName(), snapshotIndexName);\n+        builder.field(RENAMED_INDEX_FIELD.getPreferredName(), mountedIndexName);\n+        if (indexSettings.isEmpty() == false) {\n+            builder.startObject(INDEX_SETTINGS_FIELD.getPreferredName());\n+            indexSettings.toXContent(builder, params);\n+            builder.endObject();\n+        }\n+        if (ignoredIndexSettings.length > 0) {\n+            builder.startArray(IGNORE_INDEX_SETTINGS_FIELD.getPreferredName());\n+            for (String ignoreIndexSetting : ignoredIndexSettings) {\n+                builder.value(ignoreIndexSetting);\n+            }\n+            builder.endArray();\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return \"mount snapshot [\" + repositoryName + \":\" + snapshotName + \":\" + snapshotIndexName + \"->\" + mountedIndexName + \"]\";", "originalCommit": "96ab3241962d5a38d94f82185f9667f209dd4e4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwMzc0NA==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389603744", "bodyText": "++ done in cca756e.", "author": "DaveCTurner", "createdAt": "2020-03-09T11:31:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzMjgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzMzQzNg==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389533436", "bodyText": "Nit: I think this could be plain Javadoc at the class level (for better visibility)", "author": "tlrx", "createdAt": "2020-03-09T09:07:45Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportMountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.StepListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.RepositoryData;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+\n+public class TransportMountSearchableSnapshotAction\n+    extends TransportMasterNodeAction<MountSearchableSnapshotRequest, RestoreSnapshotResponse> {\n+    // This action doesn't technically need to run on the master node, but it needs to get metadata from the repository and we only expect", "originalCommit": "96ab3241962d5a38d94f82185f9667f209dd4e4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwMzY2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389603667", "bodyText": "Sure, done in 6d2e48c.", "author": "DaveCTurner", "createdAt": "2020-03-09T11:31:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzMzQzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzMzY1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389533651", "bodyText": "I think this deserves a tests", "author": "tlrx", "createdAt": "2020-03-09T09:08:16Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportMountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.StepListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.RepositoryData;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+\n+public class TransportMountSearchableSnapshotAction\n+    extends TransportMasterNodeAction<MountSearchableSnapshotRequest, RestoreSnapshotResponse> {\n+    // This action doesn't technically need to run on the master node, but it needs to get metadata from the repository and we only expect\n+    // the repository to be accessible from data and master-eligible nodes so we can't run it everywhere. Given that we already have a way\n+    // to run actions on the master and that we have to do the restore via the master, it's simplest to use TransportMasterNodeAction.\n+\n+    private final Client client;\n+    private final RepositoriesService repositoriesService;\n+\n+    @Inject\n+    public TransportMountSearchableSnapshotAction(TransportService transportService, ClusterService clusterService, Client client,\n+                                                  ThreadPool threadPool, RepositoriesService repositoriesService,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MountSearchableSnapshotAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MountSearchableSnapshotRequest::new, indexNameExpressionResolver);\n+        this.client = client;\n+        this.repositoriesService = repositoriesService;\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        // Avoid SNAPSHOT since snapshot threads may all be busy with long-running tasks which would block this action from responding with\n+        // an error. Avoid SAME since getting the repository metadata may block on IO.", "originalCommit": "96ab3241962d5a38d94f82185f9667f209dd4e4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwNTA0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389605049", "bodyText": "I'm not sure how to write a test of this that isn't vacuous. Any suggestions?", "author": "DaveCTurner", "createdAt": "2020-03-09T11:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzMzY1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYyNDUxOA==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389624518", "bodyText": "I looked at it and I don't see how to easily craft a good test for this. Maybe just ignore my review comment, as you already commented correctly the usage of this thread pool.", "author": "tlrx", "createdAt": "2020-03-09T12:19:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzMzY1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYyNDYyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389624629", "bodyText": "(and sorry for the noise)", "author": "tlrx", "createdAt": "2020-03-09T12:19:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzMzY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzNDQwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389534405", "bodyText": "Nit: maybe buildIndexSettings() ?", "author": "tlrx", "createdAt": "2020-03-09T09:09:57Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportMountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.StepListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.RepositoryData;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+\n+public class TransportMountSearchableSnapshotAction\n+    extends TransportMasterNodeAction<MountSearchableSnapshotRequest, RestoreSnapshotResponse> {\n+    // This action doesn't technically need to run on the master node, but it needs to get metadata from the repository and we only expect\n+    // the repository to be accessible from data and master-eligible nodes so we can't run it everywhere. Given that we already have a way\n+    // to run actions on the master and that we have to do the restore via the master, it's simplest to use TransportMasterNodeAction.\n+\n+    private final Client client;\n+    private final RepositoriesService repositoriesService;\n+\n+    @Inject\n+    public TransportMountSearchableSnapshotAction(TransportService transportService, ClusterService clusterService, Client client,\n+                                                  ThreadPool threadPool, RepositoriesService repositoriesService,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MountSearchableSnapshotAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MountSearchableSnapshotRequest::new, indexNameExpressionResolver);\n+        this.client = client;\n+        this.repositoriesService = repositoriesService;\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        // Avoid SNAPSHOT since snapshot threads may all be busy with long-running tasks which would block this action from responding with\n+        // an error. Avoid SAME since getting the repository metadata may block on IO.\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    @Override\n+    protected RestoreSnapshotResponse read(StreamInput in) throws IOException {\n+        return new RestoreSnapshotResponse(in);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkBlock(MountSearchableSnapshotRequest request, ClusterState state) {\n+        // The restore action checks the cluster blocks.\n+        return null;\n+    }\n+\n+    /**\n+     * Return the index settings required to make a snapshot searchable\n+     */\n+    private static Settings getIndexSettings(String repoName, SnapshotId snapshotId, IndexId indexId) {", "originalCommit": "96ab3241962d5a38d94f82185f9667f209dd4e4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwMzU4OA==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389603588", "bodyText": "++ done in 85ba301", "author": "DaveCTurner", "createdAt": "2020-03-09T11:30:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzNDQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU0NTE4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389545182", "bodyText": "This is a good observation. I don't have a strong opinion about it as the Directory implementation ensures (from index settings) that we are restoring the snapshot id/index id discovered here; but I agree that a different snapshot and/or index could be resolved later by the transport restore action itself (and if that index has a different number of shards, boom). I see this as a low risk that could maybe be worked around by adding snapshot it and index id to the restore request and check them (if present) during restore?", "author": "tlrx", "createdAt": "2020-03-09T09:31:11Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportMountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.StepListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.RepositoryData;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+\n+public class TransportMountSearchableSnapshotAction\n+    extends TransportMasterNodeAction<MountSearchableSnapshotRequest, RestoreSnapshotResponse> {\n+    // This action doesn't technically need to run on the master node, but it needs to get metadata from the repository and we only expect\n+    // the repository to be accessible from data and master-eligible nodes so we can't run it everywhere. Given that we already have a way\n+    // to run actions on the master and that we have to do the restore via the master, it's simplest to use TransportMasterNodeAction.\n+\n+    private final Client client;\n+    private final RepositoriesService repositoriesService;\n+\n+    @Inject\n+    public TransportMountSearchableSnapshotAction(TransportService transportService, ClusterService clusterService, Client client,\n+                                                  ThreadPool threadPool, RepositoriesService repositoriesService,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MountSearchableSnapshotAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MountSearchableSnapshotRequest::new, indexNameExpressionResolver);\n+        this.client = client;\n+        this.repositoriesService = repositoriesService;\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        // Avoid SNAPSHOT since snapshot threads may all be busy with long-running tasks which would block this action from responding with\n+        // an error. Avoid SAME since getting the repository metadata may block on IO.\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    @Override\n+    protected RestoreSnapshotResponse read(StreamInput in) throws IOException {\n+        return new RestoreSnapshotResponse(in);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkBlock(MountSearchableSnapshotRequest request, ClusterState state) {\n+        // The restore action checks the cluster blocks.\n+        return null;\n+    }\n+\n+    /**\n+     * Return the index settings required to make a snapshot searchable\n+     */\n+    private static Settings getIndexSettings(String repoName, SnapshotId snapshotId, IndexId indexId) {\n+        return Settings.builder()\n+            .put(SearchableSnapshots.SNAPSHOT_REPOSITORY_SETTING.getKey(), repoName)\n+            .put(SearchableSnapshots.SNAPSHOT_SNAPSHOT_NAME_SETTING.getKey(), snapshotId.getName())\n+            .put(SearchableSnapshots.SNAPSHOT_SNAPSHOT_ID_SETTING.getKey(), snapshotId.getUUID())\n+            .put(SearchableSnapshots.SNAPSHOT_INDEX_ID_SETTING.getKey(), indexId.getId())\n+            .put(INDEX_STORE_TYPE_SETTING.getKey(), SearchableSnapshots.SNAPSHOT_DIRECTORY_FACTORY_KEY)\n+            .put(IndexMetaData.SETTING_BLOCKS_WRITE, true)\n+            .build();\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, final MountSearchableSnapshotRequest request, final ClusterState state,\n+                                   final ActionListener<RestoreSnapshotResponse> listener) {\n+        final String repoName = request.repositoryName();\n+        final String snapName = request.snapshotName();\n+        final String indexName = request.snapshotIndexName();\n+\n+        // Retrieve IndexId and SnapshotId instances, which are then used to create a new restore\n+        // request, which is then sent on to the actual snapshot restore mechanism\n+        final Repository repository = repositoriesService.repository(repoName);\n+        final StepListener<RepositoryData> repositoryDataListener = new StepListener<>();\n+        repository.getRepositoryData(repositoryDataListener);\n+        repositoryDataListener.whenComplete(repoData -> {\n+            final Map<String, IndexId> indexIds = repoData.getIndices();\n+            if (indexIds.containsKey(indexName) == false && indexIds.get(indexName) != null) {\n+                throw new IndexNotFoundException(\"index [\" + indexName + \"] not found in repository [\" + repoName + \"]\");\n+            }\n+            final IndexId indexId = indexIds.get(indexName);\n+\n+            final Optional<SnapshotId> matchingSnapshotId = repoData.getSnapshotIds().stream()\n+                .filter(s -> snapName.equals(s.getName())).findFirst();\n+            if (matchingSnapshotId.isEmpty()) {\n+                throw new ElasticsearchException(\"snapshot [\" + snapName + \"] not found in repository [\" + repoName + \"]\");\n+            }\n+            final SnapshotId snapshotId = matchingSnapshotId.get();\n+\n+            // NORELEASE TODO should we ensure that the IDs we just obtained match the ones that we ultimately restore?", "originalCommit": "96ab3241962d5a38d94f82185f9667f209dd4e4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwNzYxOA==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389607618", "bodyText": "Yes, it'd involve adding extra data to the restore so that we can re-validate them later. I think we need to do this TBH, or else we have no guarantees that the index metadata we restore corresponds with the snapshot.\nI expanded the comment in 414e830 but we can address this later.", "author": "DaveCTurner", "createdAt": "2020-03-09T11:40:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU0NTE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYxODE3NA==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389618174", "bodyText": "\ud83d\udc4d", "author": "tlrx", "createdAt": "2020-03-09T12:04:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU0NTE4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1MDQ4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389550482", "bodyText": "I don't think we should test the request parsing logic here (we have AbstractRequestTestCase for this in the client project)", "author": "tlrx", "createdAt": "2020-03-09T09:41:34Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotRequestTests.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.test.AbstractWireSerializingTestCase;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+public class MountSearchableSnapshotRequestTests extends AbstractWireSerializingTestCase<MountSearchableSnapshotRequest> {\n+    public void testParse() throws Exception {", "originalCommit": "96ab3241962d5a38d94f82185f9667f209dd4e4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwMzQ5NA==", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389603494", "bodyText": "Ok, removed in 4a7588f", "author": "DaveCTurner", "createdAt": "2020-03-09T11:30:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1MDQ4Mg=="}], "type": "inlineReview"}, {"oid": "7b8e5608b2076061c805ab4c6aa8799aae350629", "url": "https://github.com/elastic/elasticsearch/commit/7b8e5608b2076061c805ab4c6aa8799aae350629", "message": "Not optional", "committedDate": "2020-03-09T09:50:28Z", "type": "commit"}, {"oid": "cca756ecba0db5cc514e13568c9413681264254e", "url": "https://github.com/elastic/elasticsearch/commit/cca756ecba0db5cc514e13568c9413681264254e", "message": "Better description", "committedDate": "2020-03-09T09:53:33Z", "type": "commit"}, {"oid": "4a7588f2959f7a43e98061d788e9ff8225441cfa", "url": "https://github.com/elastic/elasticsearch/commit/4a7588f2959f7a43e98061d788e9ff8225441cfa", "message": "Remove ToXContent, we will do this later in the client", "committedDate": "2020-03-09T11:06:08Z", "type": "commit"}, {"oid": "dbe178f8d913d3125b3601acf84a34c52ac952ed", "url": "https://github.com/elastic/elasticsearch/commit/dbe178f8d913d3125b3601acf84a34c52ac952ed", "message": "Pass request directly to parser", "committedDate": "2020-03-09T11:17:41Z", "type": "commit"}, {"oid": "6d2e48ceffa25c484fb917cccf1ea928655e8031", "url": "https://github.com/elastic/elasticsearch/commit/6d2e48ceffa25c484fb917cccf1ea928655e8031", "message": "Javadoc", "committedDate": "2020-03-09T11:21:03Z", "type": "commit"}, {"oid": "85ba30188ae38d8dffd9ea2825e501ca12a733e4", "url": "https://github.com/elastic/elasticsearch/commit/85ba30188ae38d8dffd9ea2825e501ca12a733e4", "message": "Rename", "committedDate": "2020-03-09T11:22:58Z", "type": "commit"}, {"oid": "414e830129249bff43ccec131543f939c3a1b8b7", "url": "https://github.com/elastic/elasticsearch/commit/414e830129249bff43ccec131543f939c3a1b8b7", "message": "Expand TODO comment", "committedDate": "2020-03-09T11:40:15Z", "type": "commit"}, {"oid": "e9945d50e1cdf8f7202025880db60368caa04ae2", "url": "https://github.com/elastic/elasticsearch/commit/e9945d50e1cdf8f7202025880db60368caa04ae2", "message": "Merge branch 'feature/searchable-snapshots' into ss-add-dedicated-restore-api", "committedDate": "2020-03-09T12:14:07Z", "type": "commit"}, {"oid": "b44d22052f941b0d6fb372c16a399a608d2052be", "url": "https://github.com/elastic/elasticsearch/commit/b44d22052f941b0d6fb372c16a399a608d2052be", "message": "Merge branch 'feature/searchable-snapshots' into ss-add-dedicated-restore-api", "committedDate": "2020-03-09T13:07:33Z", "type": "commit"}]}