{"pr_number": 55867, "pr_title": "Improve start_recovery check in IndexRecoveryIT", "pr_createdAt": "2020-04-28T15:47:00Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55867", "timeline": [{"oid": "3c956b2f2d20a1868d1a6cc685429a0fc528bce7", "url": "https://github.com/elastic/elasticsearch/commit/3c956b2f2d20a1868d1a6cc685429a0fc528bce7", "message": "Improve start_recovery check in IndexRecoveryIT\n\nCurrently the testTransientErrorsDuringRecoveryAreRetried validates that\nthe expected peer recovery starts only once. This check is coarse and is\nexecuted on all nodes and indexes. This commit modifies this check to\nonly be performed on the expected index. Additionally this commit\nremoves the disruption behavior from the \"blue\" node where it is not\nrelevant. Finally, this commit improves the logging for this test.", "committedDate": "2020-04-28T15:41:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjczOTA5OA==", "url": "https://github.com/elastic/elasticsearch/pull/55867#discussion_r416739098", "bodyText": "I can reproduce this by insertingThread.sleep(Randomness.get().nextInt(100)) before we apply the cluster state.\nPeer recovery can start more than once if the recovery source hasn't applied the latest cluster state. Should we only set the flag recoveryStarted after we have sent/received any retryable action?", "author": "dnhatn", "createdAt": "2020-04-28T16:07:53Z", "path": "server/src/test/java/org/elasticsearch/indices/recovery/IndexRecoveryIT.java", "diffHunk": "@@ -850,16 +846,24 @@ public void messageReceived(TransportRequestHandler<TransportRequest> handler, T\n         }\n     }\n \n-    private static class SingleStartEnforcer implements Consumer<String> {\n+    private class SingleStartEnforcer implements BiConsumer<String, TransportRequest> {\n \n         private final AtomicBoolean recoveryStarted = new AtomicBoolean(false);\n+        private final String indexName;\n+\n+        private SingleStartEnforcer(String indexName) {\n+            this.indexName = indexName;\n+        }\n \n         @Override\n-        public void accept(String action) {\n+        public void accept(String action, TransportRequest request) {\n             // The cluster state applier will immediately attempt to retry the recovery on a cluster state\n             // update. We want to assert that the first and only recovery attempt succeeds\n             if (PeerRecoverySourceService.Actions.START_RECOVERY.equals(action)) {\n-                if (recoveryStarted.compareAndSet(false, true) == false) {\n+                StartRecoveryRequest startRecoveryRequest = (StartRecoveryRequest) request;\n+                ShardId shardId = startRecoveryRequest.shardId();\n+                logger.info(\"--> attempting to send start_recovery request for shard: \" + shardId);\n+                if (indexName.equals(shardId.getIndexName()) && recoveryStarted.compareAndSet(false, true) == false) {", "originalCommit": "3c956b2f2d20a1868d1a6cc685429a0fc528bce7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6550c64f993edd43f62b45d3482c3e1bf4a78c49", "url": "https://github.com/elastic/elasticsearch/commit/6550c64f993edd43f62b45d3482c3e1bf4a78c49", "message": "Fix", "committedDate": "2020-04-28T16:24:12Z", "type": "commit"}, {"oid": "1adbab7afbc5cc7ab17fa15e8a0cb52f337d443d", "url": "https://github.com/elastic/elasticsearch/commit/1adbab7afbc5cc7ab17fa15e8a0cb52f337d443d", "message": "Merge remote-tracking branch 'upstream/master' into cleanup_transient_peer_failures", "committedDate": "2020-04-28T17:10:01Z", "type": "commit"}]}