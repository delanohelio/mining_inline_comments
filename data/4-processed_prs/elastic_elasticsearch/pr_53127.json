{"pr_number": 53127, "pr_title": "Mask wildcard query special characters on keyword queries", "pr_createdAt": "2020-03-04T17:21:55Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53127", "timeline": [{"oid": "ec7ecf71282a8b8b191da275aacb386094e657e0", "url": "https://github.com/elastic/elasticsearch/commit/ec7ecf71282a8b8b191da275aacb386094e657e0", "message": "Mask wildcard query special characters on keyword queries\n\nWildcard queries on keyword fields get normalized, however this normalization\nstep should exclude the two special characters * and ? in order to keep the\nwildcard query itself intact.\n\nCloses #46300", "committedDate": "2020-03-04T17:16:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNTI4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r387825286", "bodyText": "We should do that only for wildcard queries. For other term-based queries these characters should remain in the normalization so I'd move this code to StringFieldType#wildcardQuery ?", "author": "jimczi", "createdAt": "2020-03-04T17:38:18Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "diffHunk": "@@ -305,6 +310,31 @@ protected BytesRef indexedValueForSearch(Object value) {\n             if (value instanceof BytesRef) {\n                 value = ((BytesRef) value).utf8ToString();\n             }\n+            if (value instanceof String) {\n+                // best effort to not pass the wildcard characters and escaped characters through #normalize", "originalCommit": "ec7ecf71282a8b8b191da275aacb386094e657e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1e3fc34cd60508efe961a6a35d8eec84bdfb2c84", "url": "https://github.com/elastic/elasticsearch/commit/1e3fc34cd60508efe961a6a35d8eec84bdfb2c84", "message": "Moving masking code to StringFieldType#wildcardQuery", "committedDate": "2020-03-05T17:54:27Z", "type": "commit"}, {"oid": "8cf6a71a189ada752741fd8b1744d6c44450098e", "url": "https://github.com/elastic/elasticsearch/commit/8cf6a71a189ada752741fd8b1744d6c44450098e", "message": "Merge branch 'master' into fix-46300", "committedDate": "2020-03-05T17:54:36Z", "type": "commit"}, {"oid": "f0da91d9b8e125ab5fa91b880d110a71c0ec6642", "url": "https://github.com/elastic/elasticsearch/commit/f0da91d9b8e125ab5fa91b880d110a71c0ec6642", "message": "iter", "committedDate": "2020-03-06T10:40:35Z", "type": "commit"}, {"oid": "c4529d1172c897342ad3fb9c37c403302affa098", "url": "https://github.com/elastic/elasticsearch/commit/c4529d1172c897342ad3fb9c37c403302affa098", "message": "Merge branch 'master' into fix-46300", "committedDate": "2020-03-10T14:30:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgxMzc4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r390813783", "bodyText": "We don't want to create a wildcard query for the _type field, this is not needed.\nIt should be possible to extend the new ConstantFieldType now that _type can have a single value (or none) ?\nCurrently TypeFieldType#termQuery can return Queries.newNonNestedFilter() and that's not handled in the code below. Although, I don't think this is needed since we exclude nested docs for the entire query at the end of the query parsing so it should be safe to remove. IMO the _type field should solely return MatchNoDocsQuery and MatchAllDocsQuery, that's exactly what the ConstantFieldType provides :).\n@romseygeek what do you think ?", "author": "jimczi", "createdAt": "2020-03-11T08:38:39Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java", "diffHunk": "@@ -156,6 +162,24 @@ public Query termsQuery(List<?> values, QueryShardContext context) {\n             }\n         }\n \n+        @Override\n+        public Query wildcardQuery(String value, MultiTermQuery.RewriteMethod method, QueryShardContext context) {\n+            Query termQuery = termQuery(value, context);\n+            if (termQuery instanceof MatchNoDocsQuery || termQuery instanceof MatchAllDocsQuery) {\n+                return termQuery;\n+            }\n+", "originalCommit": "c4529d1172c897342ad3fb9c37c403302affa098", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgyMzI1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r390823257", "bodyText": "It should be possible to extend the new ConstantFieldType now that _type can have a single value (or none) ?\n\n+1", "author": "romseygeek", "createdAt": "2020-03-11T08:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgxMzc4Mw=="}], "type": "inlineReview"}, {"oid": "e727b91d02d9c9dd5a48ee700227e8be684bac46", "url": "https://github.com/elastic/elasticsearch/commit/e727b91d02d9c9dd5a48ee700227e8be684bac46", "message": "Change TypeFieldType to extend ConstantFieldType", "committedDate": "2020-03-11T13:47:57Z", "type": "commit"}, {"oid": "a59ea3e62f690e0e84de30b2b52f8443439f88ce", "url": "https://github.com/elastic/elasticsearch/commit/a59ea3e62f690e0e84de30b2b52f8443439f88ce", "message": "Merge branch 'master' into fix-46300", "committedDate": "2020-03-11T14:08:31Z", "type": "commit"}, {"oid": "ddf828c25f28854551edd45589339965924fc46f", "url": "https://github.com/elastic/elasticsearch/commit/ddf828c25f28854551edd45589339965924fc46f", "message": "iter", "committedDate": "2020-03-11T14:32:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAyMjk4MA==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r391022980", "bodyText": "I think you can use context.getMapperService().type() here, instead of SINGLE_MAPPING_NAME, and it will then backport easily.", "author": "romseygeek", "createdAt": "2020-03-11T14:44:16Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java", "diffHunk": "@@ -121,61 +121,12 @@ public ValuesSourceType getValuesSourceType() {\n         }\n \n         @Override\n-        public boolean isSearchable() {\n-            return true;\n-        }\n-\n-        @Override\n-        public Query existsQuery(QueryShardContext context) {\n-            return new MatchAllDocsQuery();\n-        }\n-\n-        @Override\n-        public Query termQuery(Object value, QueryShardContext context) {\n-            return termsQuery(Arrays.asList(value), context);\n-        }\n-\n-        @Override\n-        public Query termsQuery(List<?> values, QueryShardContext context) {\n-            DocumentMapper mapper = context.getMapperService().documentMapper();\n-            if (mapper == null) {\n-                return new MatchNoDocsQuery(\"No types\");\n-            }\n-            BytesRef indexType = indexedValueForSearch(mapper.type());\n-            if (values.stream()\n-                    .map(this::indexedValueForSearch)\n-                    .anyMatch(indexType::equals)) {\n-                if (context.getMapperService().hasNested()) {\n-                    // type filters are expected not to match nested docs\n-                    return Queries.newNonNestedFilter();\n-                } else {\n-                    return new MatchAllDocsQuery();\n-                }\n-            } else {\n-                return new MatchNoDocsQuery(\"Type list does not contain the index type\");\n-            }\n-        }\n-\n-        @Override\n-        public Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, QueryShardContext context) {\n-            Query result = new MatchAllDocsQuery();\n-            String type = context.getMapperService().documentMapper().type();\n-            if (type != null) {\n-                BytesRef typeBytes = new BytesRef(type);\n-                if (lowerTerm != null) {\n-                    int comp = indexedValueForSearch(lowerTerm).compareTo(typeBytes);\n-                    if (comp > 0 || (comp == 0 && includeLower == false)) {\n-                        result = new MatchNoDocsQuery(\"[_type] was lexicographically smaller than lower bound of range\");\n-                    }\n-                }\n-                if (upperTerm != null) {\n-                    int comp = indexedValueForSearch(upperTerm).compareTo(typeBytes);\n-                    if (comp < 0 || (comp == 0 && includeUpper == false)) {\n-                        result = new MatchNoDocsQuery(\"[_type] was lexicographically greater than upper bound of range\");\n-                    }\n-                }\n+        protected boolean matches(String pattern, QueryShardContext context) {\n+            if (pattern.contains(\"?\") == false) {\n+                return Regex.simpleMatch(pattern, MapperService.SINGLE_MAPPING_NAME);", "originalCommit": "ddf828c25f28854551edd45589339965924fc46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzMjc4NA==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r391032784", "bodyText": "context.getMapperService().type()\n\nDoesn't seem to be there on master? Or am I missing sth? I can sure use this when backporting...", "author": "cbuescher", "createdAt": "2020-03-11T14:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAyMjk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzNDI4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r391034281", "bodyText": "Sorry, I mean context.getMapperService().documentMapper().type()", "author": "romseygeek", "createdAt": "2020-03-11T14:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAyMjk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAyNDU5MA==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r391024590", "bodyText": "Is this for backwards compatibility? Nested fields are defined using a different field in 8x", "author": "romseygeek", "createdAt": "2020-03-11T14:46:20Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/ConstantFieldType.java", "diffHunk": "@@ -79,6 +79,10 @@ private static String valueToString(Object value) {\n     public final Query termQuery(Object value, QueryShardContext context) {\n         String pattern = valueToString(value);\n         if (matches(pattern, context)) {\n+            if (context != null && context.getMapperService().hasNested()) {", "originalCommit": "ddf828c25f28854551edd45589339965924fc46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzMTMyNg==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r391031326", "bodyText": "Yes, I wasn't sure about this, there was a test failing without it here: https://github.com/elastic/elasticsearch/blob/master/server/src/test/java/org/elasticsearch/index/mapper/TypeFieldTypeTests.java#L70, so I assumed its still valid. If this is not the case I'm happy to remove this together with the test, but I wasn't sure about the implications.", "author": "cbuescher", "createdAt": "2020-03-11T14:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAyNDU5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0MzA4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r391043086", "bodyText": "Yes, I don't think this applies any more, as nested queries are always built via the NestedPathFieldMapper, so you should be able to remove this block and those few lines of the test.", "author": "romseygeek", "createdAt": "2020-03-11T15:11:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAyNDU5MA=="}], "type": "inlineReview"}, {"oid": "c555c4390835569a8de639642e28920f4129c73b", "url": "https://github.com/elastic/elasticsearch/commit/c555c4390835569a8de639642e28920f4129c73b", "message": "iter", "committedDate": "2020-03-11T15:02:59Z", "type": "commit"}, {"oid": "db5ea54bfed5867e1bf8e8bd3324ab36adf2473b", "url": "https://github.com/elastic/elasticsearch/commit/db5ea54bfed5867e1bf8e8bd3324ab36adf2473b", "message": "Fix mocks in test", "committedDate": "2020-03-11T15:38:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU3MDg4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r391570882", "bodyText": "I don't think we need to handle wildcard and prefixes here ? We don't support prefix and wildcard queries on the _type field today and since _type are now a thing from the past I don't think we should add this ability. Just checking that the pattern exactly matches the internal type should be enough.", "author": "jimczi", "createdAt": "2020-03-12T11:55:32Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java", "diffHunk": "@@ -121,61 +121,12 @@ public ValuesSourceType getValuesSourceType() {\n         }\n \n         @Override\n-        public boolean isSearchable() {\n-            return true;\n-        }\n-\n-        @Override\n-        public Query existsQuery(QueryShardContext context) {\n-            return new MatchAllDocsQuery();\n-        }\n-\n-        @Override\n-        public Query termQuery(Object value, QueryShardContext context) {\n-            return termsQuery(Arrays.asList(value), context);\n-        }\n-\n-        @Override\n-        public Query termsQuery(List<?> values, QueryShardContext context) {\n-            DocumentMapper mapper = context.getMapperService().documentMapper();\n-            if (mapper == null) {\n-                return new MatchNoDocsQuery(\"No types\");\n-            }\n-            BytesRef indexType = indexedValueForSearch(mapper.type());\n-            if (values.stream()\n-                    .map(this::indexedValueForSearch)\n-                    .anyMatch(indexType::equals)) {\n-                if (context.getMapperService().hasNested()) {\n-                    // type filters are expected not to match nested docs\n-                    return Queries.newNonNestedFilter();\n-                } else {\n-                    return new MatchAllDocsQuery();\n-                }\n-            } else {\n-                return new MatchNoDocsQuery(\"Type list does not contain the index type\");\n-            }\n-        }\n-\n-        @Override\n-        public Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, QueryShardContext context) {\n-            Query result = new MatchAllDocsQuery();\n-            String type = context.getMapperService().documentMapper().type();\n-            if (type != null) {\n-                BytesRef typeBytes = new BytesRef(type);\n-                if (lowerTerm != null) {\n-                    int comp = indexedValueForSearch(lowerTerm).compareTo(typeBytes);\n-                    if (comp > 0 || (comp == 0 && includeLower == false)) {\n-                        result = new MatchNoDocsQuery(\"[_type] was lexicographically smaller than lower bound of range\");\n-                    }\n-                }\n-                if (upperTerm != null) {\n-                    int comp = indexedValueForSearch(upperTerm).compareTo(typeBytes);\n-                    if (comp < 0 || (comp == 0 && includeUpper == false)) {\n-                        result = new MatchNoDocsQuery(\"[_type] was lexicographically greater than upper bound of range\");\n-                    }\n-                }\n+        protected boolean matches(String pattern, QueryShardContext context) {", "originalCommit": "db5ea54bfed5867e1bf8e8bd3324ab36adf2473b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4dfe63df8a9f020f3c39c024292c7f221fd58527", "url": "https://github.com/elastic/elasticsearch/commit/4dfe63df8a9f020f3c39c024292c7f221fd58527", "message": "TypeFieldType#matches only needs to support exact match", "committedDate": "2020-03-12T14:23:03Z", "type": "commit"}, {"oid": "e466513ca9a5b9a02e124e14b84ddc67192dd2a9", "url": "https://github.com/elastic/elasticsearch/commit/e466513ca9a5b9a02e124e14b84ddc67192dd2a9", "message": "Merge branch 'master' into fix-46300", "committedDate": "2020-03-12T16:25:29Z", "type": "commit"}]}