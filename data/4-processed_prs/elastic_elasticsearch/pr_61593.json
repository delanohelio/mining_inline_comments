{"pr_number": 61593, "pr_title": "[DOCS] Add PIT to search after docs", "pr_createdAt": "2020-08-26T16:34:58Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/61593", "timeline": [{"oid": "3c42613f7befc3743aab45e8ca88531f9fd15151", "url": "https://github.com/elastic/elasticsearch/commit/3c42613f7befc3743aab45e8ca88531f9fd15151", "message": "[DOCS] Add PIT to search after docs", "committedDate": "2020-08-26T17:17:11Z", "type": "commit"}, {"oid": "3c42613f7befc3743aab45e8ca88531f9fd15151", "url": "https://github.com/elastic/elasticsearch/commit/3c42613f7befc3743aab45e8ca88531f9fd15151", "message": "[DOCS] Add PIT to search after docs", "committedDate": "2020-08-26T17:17:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ3MTg0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61593#discussion_r477471842", "bodyText": "For reviewers:\nThe original admon suggested using the set ingest processor to create a tiebreaker field containing the doc's _id value. However, you can't use ingest processors to access autogen docs IDs.\nIs it worth explicitly mentioning enabling indices.id_field_data.enabled and sorting on _id here?", "author": "jrodewig", "createdAt": "2020-08-26T17:34:19Z", "path": "docs/reference/search/search-your-data/paginate-search-results.asciidoc", "diffHunk": "@@ -28,29 +20,178 @@ GET /_search\n }\n ----\n \n-By default, you cannot page through more than 10,000 documents using the `from`\n-and `size` parameters. This limit is set using the\n-<<index-max-result-window,`index.max_result_window`>> index setting.\n+By default, you cannot use `from` and `size` to page through more than 10,000\n+hits. Using `from` and `size` requires each searched shard to load hits for\n+previous pages into memory. This can significantly increase memory and CPU\n+usage, resulting in degraded performance or node failures.\n+\n+If you need to page through more than 10,000 hits, use the\n+<<search-after,`search_after`>> parameter. If needed, you can use the\n+<<index-max-result-window,`index.max_result_window`>> index setting to change\n+the 10,000 hit safeguard.\n+\n+WARNING: {es} uses Lucene's internal doc IDs as tie-breakers. These internal doc\n+IDs can be completely different across replicas of the same data. When paging\n+search hits, you might occasionally see that documents with the same sort values\n+are not ordered consistently.\n+\n+[discrete]\n+[[search-after]]\n+=== Search after\n+\n+You can use the `search_after` parameter to retrieve the next page of hits\n+using a set of <<sort-search-results,sort values>> from the previous page.\n+\n+Using `search_after` requires multiple search requests with the same `query` and\n+`sort` values. If a <<near-real-time,refresh>> occurs between these requests,\n+the order of your results may change, resulting in inconsistent pages. To\n+prevent this, you can create a <<point-in-time-api,point in time (PIT)>> to\n+preserve the current index state for a specified period.\n+\n+IMPORTANT: We don't recommend creating PITs for each user request. Each PIT\n+requires additional disk space and file handles. If you want to paginate search\n+results for user requests, skip this step and use `search_after` without a PIT.\n+\n+[source,console]\n+----\n+POST /my-index-000001/_pit?keep_alive=1m\n+----\n+// TEST[setup:my_index]\n+\n+The API returns a PIT ID.\n+\n+[source,console-result]\n+----\n+{\n+  \"id\": \"46ToAwMDaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQNpZHkFdXVpZDIrBm5vZGVfMwAAAAAAAAAAKgFjA2lkeQV1dWlkMioGbm9kZV8yAAAAAAAAAAAMAWICBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==\"\n+}\n+----\n+// TESTRESPONSE[s/\"id\": \"46ToAwMDaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQNpZHkFdXVpZDIrBm5vZGVfMwAAAAAAAAAAKgFjA2lkeQV1dWlkMioGbm9kZV8yAAAAAAAAAAAMAWICBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==\"/\"id\": $body.id/]\n+\n+To get the first page of results, submit a search request with a `sort`\n+argument. If using a PIT, include the PIT ID as the `pit.id` argument.\n+\n+IMPORTANT: We recommend you include a tiebreaker field in your `sort`. This\n+tiebreaker field should contain a unique value for each document. If you don't\n+include a tiebreaker field, your paged results could miss or duplicate hits.", "originalCommit": "3c42613f7befc3743aab45e8ca88531f9fd15151", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMwNTEzMA==", "url": "https://github.com/elastic/elasticsearch/pull/61593#discussion_r482305130", "bodyText": "No this should be avoided and in 8.0 this will probably be forbidden. We have a follow up for PIT to add a simple tiebreaker in #56828. We want to have it soon so that users don't need to worry about creating a doc value field for this purpose. That said, I think that the documentation should be updated when we have the new feature but the new shape looks great. I think we should proceed with this update to the docs and add the virtual tiebreaker part when it's ready.", "author": "jimczi", "createdAt": "2020-09-02T18:53:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ3MTg0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2NDc1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61593#discussion_r482964756", "bodyText": "Sounds good. Thanks for the context @jimczi.", "author": "jrodewig", "createdAt": "2020-09-03T13:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ3MTg0Mg=="}], "type": "inlineReview"}, {"oid": "ede7d9c8816b2df0bafb9880a9e5e1c5ec5cee03", "url": "https://github.com/elastic/elasticsearch/commit/ede7d9c8816b2df0bafb9880a9e5e1c5ec5cee03", "message": "Editorial changes", "committedDate": "2020-08-26T20:05:42Z", "type": "commit"}, {"oid": "6017c316b7e7bf651a64bd7ea34ee7f6aeb2fb18", "url": "https://github.com/elastic/elasticsearch/commit/6017c316b7e7bf651a64bd7ea34ee7f6aeb2fb18", "message": "minor wording fixes", "committedDate": "2020-08-26T22:38:20Z", "type": "commit"}, {"oid": "4b5b859dd1694f26df83373b1ddcc46bb5db1e87", "url": "https://github.com/elastic/elasticsearch/commit/4b5b859dd1694f26df83373b1ddcc46bb5db1e87", "message": "missing word", "committedDate": "2020-08-26T22:43:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMwNzczNQ==", "url": "https://github.com/elastic/elasticsearch/pull/61593#discussion_r482307735", "bodyText": "That's not entirely true. I know we had such recommendations for search_after but I think we should remove it now. The goal of the PIT is to provide a way to share the readers internally so that's misleading imo.", "author": "jimczi", "createdAt": "2020-09-02T18:55:51Z", "path": "docs/reference/search/search-your-data/paginate-search-results.asciidoc", "diffHunk": "@@ -28,29 +21,180 @@ GET /_search\n }\n ----\n \n-By default, you cannot page through more than 10,000 documents using the `from`\n-and `size` parameters. This limit is set using the\n-<<index-max-result-window,`index.max_result_window`>> index setting.\n+Avoid using `from` and `size` to page too deeply or request too many results at\n+once. Search requests usually span multiple shards. Each shard must load its\n+requested hits and the hits for any previous pages into memory. For deep pages\n+or large sets of results, these operations can significantly increase memory and\n+CPU usage, resulting in degraded performance or node failures.\n+\n+By default, you cannot use `from` and `size` to page through more than 10,000\n+hits. This limit is a safeguard set by the\n+<<index-max-result-window,`index.max_result_window`>> index setting. If you need\n+to page through more than 10,000 hits, use the <<search-after,`search_after`>>\n+parameter instead.\n+\n+WARNING: {es} uses Lucene's internal doc IDs as tie-breakers. These internal doc\n+IDs can be completely different across replicas of the same data. When paging\n+search hits, you might occasionally see that documents with the same sort values\n+are not ordered consistently.\n+\n+[discrete]\n+[[search-after]]\n+=== Search after\n+\n+You can use the `search_after` parameter to retrieve the next page of hits\n+using a set of <<sort-search-results,sort values>> from the previous page.\n+\n+Using `search_after` requires multiple search requests with the same `query` and\n+`sort` values. If a <<near-real-time,refresh>> occurs between these requests,\n+the order of your results may change, causing inconsistent results across pages. To\n+prevent this, you can create a <<point-in-time-api,point in time (PIT)>> to\n+preserve the current index state over your searches.\n+\n+IMPORTANT: We don't recommend creating PITs for each user request. Each PIT\n+requires additional disk space and file handles. If you want to paginate search\n+results for user requests, use `search_after` without a PIT.", "originalCommit": "4b5b859dd1694f26df83373b1ddcc46bb5db1e87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2NjQxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61593#discussion_r482966411", "bodyText": "Good to know. Removed with df7ca43. Thanks for the correction!", "author": "jrodewig", "createdAt": "2020-09-03T13:12:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMwNzczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMwODMzMw==", "url": "https://github.com/elastic/elasticsearch/pull/61593#discussion_r482308333", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When you're finished, we recommend deleting your PIT.\n          \n          \n            \n            When you're finished, you should delete your PIT.", "author": "jimczi", "createdAt": "2020-09-02T18:56:27Z", "path": "docs/reference/search/search-your-data/paginate-search-results.asciidoc", "diffHunk": "@@ -28,29 +21,180 @@ GET /_search\n }\n ----\n \n-By default, you cannot page through more than 10,000 documents using the `from`\n-and `size` parameters. This limit is set using the\n-<<index-max-result-window,`index.max_result_window`>> index setting.\n+Avoid using `from` and `size` to page too deeply or request too many results at\n+once. Search requests usually span multiple shards. Each shard must load its\n+requested hits and the hits for any previous pages into memory. For deep pages\n+or large sets of results, these operations can significantly increase memory and\n+CPU usage, resulting in degraded performance or node failures.\n+\n+By default, you cannot use `from` and `size` to page through more than 10,000\n+hits. This limit is a safeguard set by the\n+<<index-max-result-window,`index.max_result_window`>> index setting. If you need\n+to page through more than 10,000 hits, use the <<search-after,`search_after`>>\n+parameter instead.\n+\n+WARNING: {es} uses Lucene's internal doc IDs as tie-breakers. These internal doc\n+IDs can be completely different across replicas of the same data. When paging\n+search hits, you might occasionally see that documents with the same sort values\n+are not ordered consistently.\n+\n+[discrete]\n+[[search-after]]\n+=== Search after\n+\n+You can use the `search_after` parameter to retrieve the next page of hits\n+using a set of <<sort-search-results,sort values>> from the previous page.\n+\n+Using `search_after` requires multiple search requests with the same `query` and\n+`sort` values. If a <<near-real-time,refresh>> occurs between these requests,\n+the order of your results may change, causing inconsistent results across pages. To\n+prevent this, you can create a <<point-in-time-api,point in time (PIT)>> to\n+preserve the current index state over your searches.\n+\n+IMPORTANT: We don't recommend creating PITs for each user request. Each PIT\n+requires additional disk space and file handles. If you want to paginate search\n+results for user requests, use `search_after` without a PIT.\n+\n+[source,console]\n+----\n+POST /my-index-000001/_pit?keep_alive=1m\n+----\n+// TEST[setup:my_index]\n+\n+The API returns a PIT ID.\n+\n+[source,console-result]\n+----\n+{\n+  \"id\": \"46ToAwMDaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQNpZHkFdXVpZDIrBm5vZGVfMwAAAAAAAAAAKgFjA2lkeQV1dWlkMioGbm9kZV8yAAAAAAAAAAAMAWICBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==\"\n+}\n+----\n+// TESTRESPONSE[s/\"id\": \"46ToAwMDaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQNpZHkFdXVpZDIrBm5vZGVfMwAAAAAAAAAAKgFjA2lkeQV1dWlkMioGbm9kZV8yAAAAAAAAAAAMAWICBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==\"/\"id\": $body.id/]\n+\n+To get the first page of results, submit a search request with a `sort`\n+argument. If using a PIT, specify the PIT ID in the `pit.id` parameter.\n+\n+IMPORTANT: We recommend you include a tiebreaker field in your `sort`. This\n+tiebreaker field should contain a unique value for each document. If you don't\n+include a tiebreaker field, your paged results could miss or duplicate hits.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"size\": 10000,\n+  \"query\": {\n+    \"match\" : {\n+      \"user.id\" : \"elkbee\"\n+    }\n+  },\n+  \"pit\": {\n+\t    \"id\":  \"46ToAwMDaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQNpZHkFdXVpZDIrBm5vZGVfMwAAAAAAAAAAKgFjA2lkeQV1dWlkMioGbm9kZV8yAAAAAAAAAAAMAWICBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==\", <1>\n+\t    \"keep_alive\": \"1m\"\n+  },\n+  \"sort\": [ <2>\n+    {\"@timestamp\": \"asc\"},\n+    {\"tie_breaker_id\": \"asc\"}\n+  ]\n+}\n+----\n+// TEST[catch:missing]\n+\n+<1> PIT ID for the search.\n+<2> Sorts hits for the search.\n+\n+The search response includes an array of `sort` values for each hit. If you used\n+a PIT, the response's `pit_id` parameter contains an updated PIT ID.\n+\n+[source,console-result]\n+----\n+{\n+  \"pit_id\" : \"46ToAwEPbXktaW5kZXgtMDAwMDAxFnVzaTVuenpUVGQ2TFNheUxVUG5LVVEAFldicVdzOFFtVHZTZDFoWWowTGkwS0EAAAAAAAAAAAQURzZzcUszUUJ5U1NMX3Jyak5ET0wBFnVzaTVuenpUVGQ2TFNheUxVUG5LVVEAAA==\", <1>\n+  \"took\" : 17,\n+  \"timed_out\" : false,\n+  \"_shards\" : ...,\n+  \"hits\" : {\n+    \"total\" : ...,\n+    \"max_score\" : null,\n+    \"hits\" : [\n+      ...\n+      {\n+        \"_index\" : \"my-index-000001\",\n+        \"_id\" : \"FaslK3QBySSL_rrj9zM5\",\n+        \"_score\" : null,\n+        \"_source\" : ...,\n+        \"sort\" : [                                <2>\n+          4098435132000,\n+          \"FaslK3QBySSL_rrj9zM5\"\n+        ]\n+      }\n+    ]\n+  }\n+}\n+----\n+// TESTRESPONSE[skip: unable to access PIT ID]\n+\n+<1> Updated `id` for the point in time.\n+<2> Sort values for the last returned hit.\n+\n+To get the next page of results, rerun the previous search using the last hit's\n+sort values as the `search_after` argument. If using a PIT, use the latest PIT\n+ID in the `pit.id` parameter. The search's `query` and `sort` arguments must\n+remain unchanged. If provided, the `from` argument must be `0` (default) or `-1`.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"size\": 10000,\n+  \"query\": {\n+    \"match\" : {\n+      \"user.id\" : \"elkbee\"\n+    }\n+  },\n+  \"pit\": {\n+\t    \"id\":  \"46ToAwEPbXktaW5kZXgtMDAwMDAxFnVzaTVuenpUVGQ2TFNheUxVUG5LVVEAFldicVdzOFFtVHZTZDFoWWowTGkwS0EAAAAAAAAAAAQURzZzcUszUUJ5U1NMX3Jyak5ET0wBFnVzaTVuenpUVGQ2TFNheUxVUG5LVVEAAA==\", <1>\n+\t    \"keep_alive\": \"1m\"\n+  },\n+  \"sort\": [\n+    {\"@timestamp\": \"asc\"},\n+    {\"tie_breaker_id\": \"asc\"}\n+  ],\n+  \"search_after\": [                                <2>\n+    4098435132000,\n+    \"FaslK3QBySSL_rrj9zM5\"\n+  ]\n+}\n+----\n+// TEST[catch:missing]\n+\n+<1> PIT ID returned by the previous search.\n+<2> Sort values from the previous search's last hit.\n \n-Deep paging or requesting many results at once can result in slow searches.\n-Results are sorted before being returned. Because search requests usually span\n-multiple shards, each shard must generate its own sorted results. These separate\n-results must then be combined and sorted to ensure that the overall sort order\n-is correct.\n+You can repeat this process to get additional pages of results. If using a PIT,\n+you can extend the PIT's retention period using the\n+`keep_alive` parameter of each search request.\n \n-As an alternative to deep paging, we recommend using\n-<<scroll-search-results,scroll>> or the\n-<<search-after,`search_after`>> parameter.\n+When you're finished, we recommend deleting your PIT.", "originalCommit": "4b5b859dd1694f26df83373b1ddcc46bb5db1e87", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9cdf464ac02e556f630ffca3d2e8bc9abea2f0ba", "url": "https://github.com/elastic/elasticsearch/commit/9cdf464ac02e556f630ffca3d2e8bc9abea2f0ba", "message": "Update docs/reference/search/search-your-data/paginate-search-results.asciidoc\n\nCo-authored-by: Jim Ferenczi <jim.ferenczi@elastic.co>", "committedDate": "2020-09-03T13:09:27Z", "type": "commit"}, {"oid": "df7ca438f5ecda1ab49f40a84ec2716f5280edcf", "url": "https://github.com/elastic/elasticsearch/commit/df7ca438f5ecda1ab49f40a84ec2716f5280edcf", "message": "Remove admon re: user requests", "committedDate": "2020-09-03T13:11:49Z", "type": "commit"}]}