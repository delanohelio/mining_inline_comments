{"pr_number": 52886, "pr_title": "Create API Key on behalf of other user", "pr_createdAt": "2020-02-27T12:56:09Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52886", "timeline": [{"oid": "f4cbe14e1b7871155161d08ec1a23990534c706b", "url": "https://github.com/elastic/elasticsearch/commit/f4cbe14e1b7871155161d08ec1a23990534c706b", "message": "Create API Key on behalf of other user\n\nThis change adds a \"grant API key action\"\n\n   POST /_security/api_key/grant\n\nthat creates a new API key using the privileges of one user (\"the\nsystem user\") to execute the action, but creates the API key with\nthe roles of the second user (\"the end user\").\n\nThis allows a system (such as Kibana) to create API keys representing\nthe identity and access of an authenticated user without requiring\nthat user to have permission to create API keys on their own.", "committedDate": "2020-02-27T12:53:14Z", "type": "commit"}, {"oid": "21c16fff2c58f16e66e127cd3cfe61bb5956d31f", "url": "https://github.com/elastic/elasticsearch/commit/21c16fff2c58f16e66e127cd3cfe61bb5956d31f", "message": "Revert formatting change", "committedDate": "2020-02-27T13:03:14Z", "type": "commit"}, {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955", "url": "https://github.com/elastic/elasticsearch/commit/17d292f52d9fd1d9ff51a1944cf230d2df28c955", "message": "Revert unnecessary changes", "committedDate": "2020-02-27T13:09:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcxNjQ0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r385716446", "bodyText": "use a local var for the type since we use it multiple times below", "author": "jkakavas", "createdAt": "2020-02-28T14:13:17Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/GrantApiKeyRequest.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.settings.SecureString;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * Request class used for the creation of an API key on behalf of another user.\n+ * Logically this is similar to {@link CreateApiKeyRequest}, but is for cases when the user that has permission to call this action\n+ * is different to the user for whom the API key should be created\n+ */\n+public final class GrantApiKeyRequest extends ActionRequest {\n+\n+    public static final WriteRequest.RefreshPolicy DEFAULT_REFRESH_POLICY = WriteRequest.RefreshPolicy.WAIT_UNTIL;\n+    public static final String PASSWORD_GRANT_TYPE = \"password\";\n+    public static final String ACCESS_TOKEN_GRANT_TYPE = \"access_token\";\n+\n+    /**\n+     * Fields related to the end user authentication\n+     */\n+    public static class Grant implements Writeable {\n+        private String type;\n+        private String username;\n+        private SecureString password;\n+        private SecureString accessToken;\n+\n+        public Grant() {\n+        }\n+\n+        public Grant(StreamInput in) throws IOException {\n+            this.type = in.readString();\n+            this.username = in.readOptionalString();\n+            this.password = in.readOptionalSecureString();\n+            this.accessToken = in.readOptionalSecureString();\n+        }\n+\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(type);\n+            out.writeOptionalString(username);\n+            out.writeOptionalSecureString(password);\n+            out.writeOptionalSecureString(accessToken);\n+        }\n+\n+        public String getType() {\n+            return type;\n+        }\n+\n+        public String getUsername() {\n+            return username;\n+        }\n+\n+        public SecureString getPassword() {\n+            return password;\n+        }\n+\n+        public SecureString getAccessToken() {\n+            return accessToken;\n+        }\n+\n+        public void setType(String type) {\n+            this.type = type;\n+        }\n+\n+        public void setUsername(String username) {\n+            this.username = username;\n+        }\n+\n+        public void setPassword(SecureString password) {\n+            this.password = password;\n+        }\n+\n+        public void setAccessToken(SecureString accessToken) {\n+            this.accessToken = accessToken;\n+        }\n+    }\n+\n+    private final Grant grant;\n+    private CreateApiKeyRequest apiKey;\n+    private WriteRequest.RefreshPolicy refreshPolicy;\n+\n+    public GrantApiKeyRequest() {\n+        this.grant = new Grant();\n+        this.apiKey = new CreateApiKeyRequest();\n+        this.refreshPolicy = DEFAULT_REFRESH_POLICY;\n+    }\n+\n+    public GrantApiKeyRequest(StreamInput in) throws IOException {\n+        super(in);\n+        this.grant = new Grant(in);\n+        this.apiKey = new CreateApiKeyRequest(in);\n+        this.refreshPolicy = WriteRequest.RefreshPolicy.readFrom(in);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        grant.writeTo(out);\n+        apiKey.writeTo(out);\n+        refreshPolicy.writeTo(out);\n+    }\n+\n+    public WriteRequest.RefreshPolicy getRefreshPolicy() {\n+        return refreshPolicy;\n+    }\n+\n+    public void setRefreshPolicy(WriteRequest.RefreshPolicy refreshPolicy) {\n+        this.refreshPolicy = Objects.requireNonNull(refreshPolicy, \"refresh policy may not be null\");\n+    }\n+\n+    public Grant getGrant() {\n+        return grant;\n+    }\n+\n+    public CreateApiKeyRequest getApiKeyRequest() {\n+        return apiKey;\n+    }\n+\n+    public void setApiKeyRequest(CreateApiKeyRequest apiKeyRequest) {\n+        this.apiKey = Objects.requireNonNull(apiKeyRequest, \"Cannot set a null api_key\");\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = apiKey.validate();\n+        if (grant.type == null) {", "originalCommit": "17d292f52d9fd1d9ff51a1944cf230d2df28c955", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0NzYxMw==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r386347613", "bodyText": "Can do, but is there a reason why you'd like that?", "author": "tvernum", "createdAt": "2020-03-02T11:49:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcxNjQ0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxMzQ4OA==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r386813488", "bodyText": "Not the end of the world as we know it, I think it reads better, feel free to decide.", "author": "jkakavas", "createdAt": "2020-03-03T05:59:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcxNjQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcyOTMyNw==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r385729327", "bodyText": "should we add one with access_token grant since we're at it?", "author": "jkakavas", "createdAt": "2020-02-28T14:37:20Z", "path": "x-pack/plugin/security/qa/security-basic/src/test/java/org/elasticsearch/xpack/security/apikey/ApiKeyRestIT.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.apikey;\n+\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.security.support.ApiKey;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.test.XContentTestUtils;\n+import org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken;\n+import org.elasticsearch.xpack.security.SecurityInBasicRestTestCase;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+/**\n+ * This IT runs in the \"security-basic\" QA test because it has a working cluster with\n+ * API keys enabled, and there's no reason to have a dedicated QA project for API keys.\n+ */\n+public class ApiKeyRestIT extends SecurityInBasicRestTestCase {\n+\n+    private static final String SYSTEM_USER = \"system_user\";\n+    private static final SecureString SYSTEM_USER_PASSWORD = new SecureString(\"sys-pass\".toCharArray());\n+    private static final String END_USER = \"end_user\";\n+    private static final SecureString END_USER_PASSWORD = new SecureString(\"user-pass\".toCharArray());\n+\n+    @Before\n+    public void createUsers() throws IOException {\n+        createUser(SYSTEM_USER, SYSTEM_USER_PASSWORD, List.of(\"system_role\"));\n+        createRole(\"system_role\", Set.of(\"manage_api_key\"));\n+        createUser(END_USER, END_USER_PASSWORD, List.of(\"user_role\"));\n+        createRole(\"user_role\", Set.of(\"monitor\"));\n+    }\n+\n+    @After\n+    public void cleanUp() throws IOException {\n+        deleteUser(\"system_user\");\n+        deleteUser(\"end_user\");\n+        deleteRole(\"system_role\");\n+        deleteRole(\"user_role\");\n+        invalidateApiKeysForUser(END_USER);\n+    }\n+\n+    public void testGrantApiKeyForOtherUser() throws IOException {", "originalCommit": "17d292f52d9fd1d9ff51a1944cf230d2df28c955", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0OTY5NA==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r386349694", "bodyText": "I can't in this test, because basic license doesn't suppor tokens, but I can move the test elsewhere and do that if you'd like it.\nSince the transport action test already covers Username+Password and AccessToken (both valid and invalid), I didn't think it was necessary to cover it again in the IT. I just wanted something integrated to test it top-to-bottom.\nTesting's a tricky balance, so if it's something you think we need, I'm happy to make it happen (but it will probably means a whole new QA project for rest tests using  security on trial licenses).", "author": "tvernum", "createdAt": "2020-03-02T11:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcyOTMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxMzYwOA==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r386813608", "bodyText": "SGTM to leave it as is", "author": "jkakavas", "createdAt": "2020-03-03T05:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcyOTMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3Mzc1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r387973753", "bodyText": "I can't in this test, because basic license doesn't support tokens\n\nBut you can start a trial, as it's done in SecurityWithBasicLicenseIT#testWithTrialLicense , right ? If this is possible, I would also just slightly prefer a test case using tokens.", "author": "albertzaharovits", "createdAt": "2020-03-04T22:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcyOTMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3ODQyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r387978421", "bodyText": "No, because a cluster can only start a trial once, and the other test does that.\nIf we want to test this with a non-basic license then we'll need a new QA project.", "author": "tvernum", "createdAt": "2020-03-04T22:41:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcyOTMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA2NDc4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r388064786", "bodyText": "You convinced me that I was just being lazy, so I've added a new QA project, and a new test for authenticating with a token + API key expiration.", "author": "tvernum", "createdAt": "2020-03-05T03:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcyOTMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0MDc2MA==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r385740760", "bodyText": "is this needed ?", "author": "jkakavas", "createdAt": "2020-02-28T14:57:58Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/TransportGrantApiKeyAction.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportMessage;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken;\n+import org.elasticsearch.xpack.security.authc.ApiKeyService;\n+import org.elasticsearch.xpack.security.authc.AuthenticationService;\n+import org.elasticsearch.xpack.security.authc.TokenService;\n+import org.elasticsearch.xpack.security.authc.support.ApiKeyGenerator;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+\n+/**\n+ * Implementation of the action needed to create an API key on behalf of another user (using an OAuth style \"grant\")\n+ */\n+public final class TransportGrantApiKeyAction extends HandledTransportAction<GrantApiKeyRequest, CreateApiKeyResponse> {\n+\n+    private final ThreadContext threadContext;\n+    private final ApiKeyGenerator generator;\n+    private final AuthenticationService authenticationService;\n+    private final TokenService tokenService;\n+\n+    @Inject\n+    public TransportGrantApiKeyAction(TransportService transportService, ActionFilters actionFilters, ThreadPool threadPool,\n+                                      ApiKeyService apiKeyService, AuthenticationService authenticationService, TokenService tokenService,\n+                                      CompositeRolesStore rolesStore, NamedXContentRegistry xContentRegistry) {\n+        this(transportService, actionFilters, threadPool.getThreadContext(),\n+            new ApiKeyGenerator(apiKeyService, rolesStore, xContentRegistry), authenticationService, tokenService\n+        );\n+    }\n+\n+    // Constructor for testing\n+    TransportGrantApiKeyAction(TransportService transportService, ActionFilters actionFilters, ThreadContext threadContext,\n+                                      ApiKeyGenerator generator, AuthenticationService authenticationService, TokenService tokenService) {\n+        super(GrantApiKeyAction.NAME, transportService, actionFilters, GrantApiKeyRequest::new);\n+        this.threadContext = threadContext;\n+        this.generator = generator;\n+        this.authenticationService = authenticationService;\n+        this.tokenService = tokenService;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, GrantApiKeyRequest request, ActionListener<CreateApiKeyResponse> listener) {\n+        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n+            resolveAuthentication(request.getGrant(), request, ActionListener.wrap(\n+                authentication -> generator.generateApiKey(authentication, request.getApiKeyRequest(), listener),\n+                listener::onFailure\n+            ));\n+        }\n+    }\n+\n+    private void resolveAuthentication(GrantApiKeyRequest.Grant grant, TransportMessage message, ActionListener<Authentication> listener) {\n+        switch (grant.getType()) {\n+            case GrantApiKeyRequest.PASSWORD_GRANT_TYPE:\n+                final UsernamePasswordToken token = new UsernamePasswordToken(grant.getUsername(), grant.getPassword());\n+                authenticationService.authenticate(super.actionName, message, token, listener);\n+                return;\n+            case GrantApiKeyRequest.ACCESS_TOKEN_GRANT_TYPE:\n+                tokenService.authenticateToken(grant.getAccessToken(), listener);\n+                return;\n+            default:\n+                listener.onFailure(new ElasticsearchSecurityException(\"the grant type [{}] is not supported\", grant.getType()));\n+                return;", "originalCommit": "17d292f52d9fd1d9ff51a1944cf230d2df28c955", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNjgyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r386716829", "bodyText": "The return ? Not strictly, but I did it for symmetry with the other switch cases.\nDoes it bother you? I'm happy to change it, and I'm personally not consistent in my balance between \"symmetry\" and \"necessity\"", "author": "tvernum", "createdAt": "2020-03-02T23:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0MDc2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxNTAwMA==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r386815000", "bodyText": "again, this was a nit, feel free to address or not. I tend to review ( also not very consistently I'd admit ) taking personal preference into consideration and I usually don't hold strong opinions on such things.", "author": "jkakavas", "createdAt": "2020-03-03T06:05:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0MDc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NDM1NA==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r385754354", "bodyText": "This is called in ApiKeyService#createApiKey(). Is it intentional that we do it here too becayse getRoleDescriptors can be expensive ? If so can we also /instead inject the ApiKeyService in the Transport service and short circuit there ?", "author": "jkakavas", "createdAt": "2020-02-28T15:21:15Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/support/ApiKeyGenerator.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.authc.support;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.support.DLSRoleQueryValidator;\n+import org.elasticsearch.xpack.security.authc.ApiKeyService;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+\n+public class ApiKeyGenerator {\n+\n+    private final ApiKeyService apiKeyService;\n+    private final CompositeRolesStore rolesStore;\n+    private final NamedXContentRegistry xContentRegistry;\n+\n+    public ApiKeyGenerator(ApiKeyService apiKeyService, CompositeRolesStore rolesStore, NamedXContentRegistry xContentRegistry) {\n+        this.apiKeyService = apiKeyService;\n+        this.rolesStore = rolesStore;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void generateApiKey(Authentication authentication, CreateApiKeyRequest request, ActionListener<CreateApiKeyResponse> listener) {\n+        if (authentication == null) {\n+            listener.onFailure(new ElasticsearchSecurityException(\"no authentication available to generate API key\"));\n+            return;\n+        }\n+        apiKeyService.ensureEnabled();", "originalCommit": "17d292f52d9fd1d9ff51a1944cf230d2df28c955", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNzc3NA==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r386717774", "bodyText": "Partly the relative expense, but partly the \"right\" error message. If the API key service is disabled you want to prioritise that error message ahead of any role format issues.\n(That's specifically what triggered me to write it, I ran into something along those lines while testing)", "author": "tvernum", "createdAt": "2020-03-02T23:41:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NDM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxODI5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r386718295", "bodyText": "If so can we also /instead inject the ApiKeyService in the Transport service and short circuit there\n\nI don't know if we want to. I think we should prioritise authentication problems (even secondary auth problems) over the service being disabled. Happy to discuss if you feel otherwise.", "author": "tvernum", "createdAt": "2020-03-02T23:42:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NDM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxNjEzNw==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r386816137", "bodyText": ", but partly the \"right\" error message.\n\nMakes sense.\n\nI think we should prioritise authentication problems\n\nAgreed, I didn't think this through", "author": "jkakavas", "createdAt": "2020-03-03T06:10:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NDM1NA=="}], "type": "inlineReview"}, {"oid": "24e0fcccce77aba552b36ce71008354aa7d41271", "url": "https://github.com/elastic/elasticsearch/commit/24e0fcccce77aba552b36ce71008354aa7d41271", "message": "Merge branch 'master' into feature/48716-api-key-other-user", "committedDate": "2020-03-05T00:45:55Z", "type": "commit"}, {"oid": "f5808256c01fc4c0ce767b8ebc414be74162e584", "url": "https://github.com/elastic/elasticsearch/commit/f5808256c01fc4c0ce767b8ebc414be74162e584", "message": "Move API key test to new QA/security-trial project\n\nThis test was piggy-backing on the security-in-basic QA project we\nhad, but the grant-api-key endpoint has the ability to use tokens,\nwhich are not a basic licensed feature.\n\nThis creates a new QA project for security on trial licenses and run\nthe API key tests there", "committedDate": "2020-03-05T01:12:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwNzA4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r388207085", "bodyText": "I believe this new method should return the new fancy 400 exceptions when the token service is not enabled (since it's not used in the authentication chain).", "author": "albertzaharovits", "createdAt": "2020-03-05T10:33:21Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "diffHunk": "@@ -394,6 +394,32 @@ void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener)\n         }\n     }\n \n+    /**\n+     * Decodes the provided token, and validates it (for format, expiry and invalidation).\n+     * If valid, the token's {@link Authentication} (see {@link UserToken#getAuthentication()} is provided to the listener.\n+     * If the token is invalid (expired etc), then {@link ActionListener#onFailure(Exception)} will be called.\n+     * If tokens are not enabled, or the token does not exist, {@link ActionListener#onResponse} will be called with a\n+     * {@code null} authentication object.\n+     */\n+    public void authenticateToken(SecureString tokenString, ActionListener<Authentication> listener) {\n+        if (isEnabled()) {", "originalCommit": "f5808256c01fc4c0ce767b8ebc414be74162e584", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwOTU2NA==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r388209564", "bodyText": "Also because this new method is not used in the authn chain, when a token fails decoding it's a client error.\nI believe:\nlistener.onFailure(new IllegalArgumentException());\n\nwould do, it would return 400 (currently this falls back to 500 in ApiKeyGenerator#generateApiKey).", "author": "albertzaharovits", "createdAt": "2020-03-05T10:37:43Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "diffHunk": "@@ -394,6 +394,32 @@ void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener)\n         }\n     }\n \n+    /**\n+     * Decodes the provided token, and validates it (for format, expiry and invalidation).\n+     * If valid, the token's {@link Authentication} (see {@link UserToken#getAuthentication()} is provided to the listener.\n+     * If the token is invalid (expired etc), then {@link ActionListener#onFailure(Exception)} will be called.\n+     * If tokens are not enabled, or the token does not exist, {@link ActionListener#onResponse} will be called with a\n+     * {@code null} authentication object.\n+     */\n+    public void authenticateToken(SecureString tokenString, ActionListener<Authentication> listener) {\n+        if (isEnabled()) {\n+            decodeToken(tokenString.toString(), ActionListener.wrap(userToken -> {\n+                if (userToken != null) {\n+                    checkIfTokenIsValid(userToken, ActionListener.wrap(\n+                        token -> {\n+                            listener.onResponse(token == null ? null : token.getAuthentication());\n+                        },\n+                        listener::onFailure\n+                    ));\n+                } else {\n+                    listener.onResponse(null);", "originalCommit": "f5808256c01fc4c0ce767b8ebc414be74162e584", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMTc4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r388231785", "bodyText": "Good point @albertzaharovits", "author": "jkakavas", "createdAt": "2020-03-05T11:21:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwOTU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyOTExMA==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r388229110", "bodyText": "The refresh_policy should be forwarded to the inner CreateApiKeyRequest to take effect.", "author": "albertzaharovits", "createdAt": "2020-03-05T11:15:20Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/rest/action/apikey/RestGrantApiKeyAction.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.rest.action.apikey;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyRequest;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.POST;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+/**\n+ * Rest action to create an API key on behalf of another user. Loosely mimics the API of\n+ * {@link org.elasticsearch.xpack.security.rest.action.oauth2.RestGetTokenAction} combined with {@link RestCreateApiKeyAction}\n+ */\n+public final class RestGrantApiKeyAction extends ApiKeyBaseRestHandler {\n+\n+    final Logger logger = LogManager.getLogger();\n+\n+    static final ObjectParser<GrantApiKeyRequest, Void> PARSER = new ObjectParser<>(\"grant_api_key_request\", GrantApiKeyRequest::new);\n+    static {\n+        PARSER.declareString((req, str) -> req.getGrant().setType(str), new ParseField(\"grant_type\"));\n+        PARSER.declareString((req, str) -> req.getGrant().setUsername(str), new ParseField(\"username\"));\n+        PARSER.declareField((req, secStr) -> req.getGrant().setPassword(secStr), RestGrantApiKeyAction::getSecureString,\n+            new ParseField(\"password\"), ObjectParser.ValueType.STRING);\n+        PARSER.declareField((req, secStr) -> req.getGrant().setAccessToken(secStr), RestGrantApiKeyAction::getSecureString,\n+            new ParseField(\"access_token\"), ObjectParser.ValueType.STRING);\n+        PARSER.declareObject((req, api) -> req.setApiKeyRequest(api), (parser, ignore) -> CreateApiKeyRequestBuilder.parse(parser),\n+            new ParseField(\"api_key\"));\n+    }\n+\n+    private static SecureString getSecureString(XContentParser parser) throws IOException {\n+        return new SecureString(\n+            Arrays.copyOfRange(parser.textCharacters(), parser.textOffset(), parser.textOffset() + parser.textLength()));\n+    }\n+\n+    public RestGrantApiKeyAction(Settings settings, XPackLicenseState licenseState) {\n+        super(settings, licenseState);\n+    }\n+\n+    @Override\n+    public List<Route> routes() {\n+        return List.of(\n+            new Route(POST, \"/_security/api_key/grant\"),\n+            new Route(PUT, \"/_security/api_key/grant\"));\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"xpack_security_grant_api_key\";\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer innerPrepareRequest(final RestRequest request, final NodeClient client) throws IOException {\n+        String refresh = request.param(\"refresh\");\n+        try (XContentParser parser = request.contentParser()) {\n+            final GrantApiKeyRequest grantRequest = PARSER.parse(parser, null);\n+            if (refresh != null) {\n+                grantRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.parse(refresh));", "originalCommit": "f5808256c01fc4c0ce767b8ebc414be74162e584", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzNzMzMw==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r388237333", "bodyText": "I like this wrapping to translate 401 to 403!\nAssuming this is the sole reason of existence for the inner class, in order to make it easier to read, I would make it more concise:\n            return channel -> client.execute(GrantApiKeyAction.INSTANCE, grantRequest,\n                    ActionListener.delegateResponse(new RestToXContentListener<>(channel),\n                            (l, e) -> {\n                                RestStatus status = ExceptionsHelper.status(e);\n                                if (status == RestStatus.UNAUTHORIZED) {\n                                    l.onFailure(new ElasticsearchSecurityException(\"Failed to authenticate api key grant\",\n                                            RestStatus.FORBIDDEN, e));\n                                } else {\n                                    l.onFailure(e);\n                                }\n                            }));", "author": "albertzaharovits", "createdAt": "2020-03-05T11:32:48Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/rest/action/apikey/RestGrantApiKeyAction.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.rest.action.apikey;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyRequest;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.POST;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+/**\n+ * Rest action to create an API key on behalf of another user. Loosely mimics the API of\n+ * {@link org.elasticsearch.xpack.security.rest.action.oauth2.RestGetTokenAction} combined with {@link RestCreateApiKeyAction}\n+ */\n+public final class RestGrantApiKeyAction extends ApiKeyBaseRestHandler {\n+\n+    final Logger logger = LogManager.getLogger();\n+\n+    static final ObjectParser<GrantApiKeyRequest, Void> PARSER = new ObjectParser<>(\"grant_api_key_request\", GrantApiKeyRequest::new);\n+    static {\n+        PARSER.declareString((req, str) -> req.getGrant().setType(str), new ParseField(\"grant_type\"));\n+        PARSER.declareString((req, str) -> req.getGrant().setUsername(str), new ParseField(\"username\"));\n+        PARSER.declareField((req, secStr) -> req.getGrant().setPassword(secStr), RestGrantApiKeyAction::getSecureString,\n+            new ParseField(\"password\"), ObjectParser.ValueType.STRING);\n+        PARSER.declareField((req, secStr) -> req.getGrant().setAccessToken(secStr), RestGrantApiKeyAction::getSecureString,\n+            new ParseField(\"access_token\"), ObjectParser.ValueType.STRING);\n+        PARSER.declareObject((req, api) -> req.setApiKeyRequest(api), (parser, ignore) -> CreateApiKeyRequestBuilder.parse(parser),\n+            new ParseField(\"api_key\"));\n+    }\n+\n+    private static SecureString getSecureString(XContentParser parser) throws IOException {\n+        return new SecureString(\n+            Arrays.copyOfRange(parser.textCharacters(), parser.textOffset(), parser.textOffset() + parser.textLength()));\n+    }\n+\n+    public RestGrantApiKeyAction(Settings settings, XPackLicenseState licenseState) {\n+        super(settings, licenseState);\n+    }\n+\n+    @Override\n+    public List<Route> routes() {\n+        return List.of(\n+            new Route(POST, \"/_security/api_key/grant\"),\n+            new Route(PUT, \"/_security/api_key/grant\"));\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"xpack_security_grant_api_key\";\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer innerPrepareRequest(final RestRequest request, final NodeClient client) throws IOException {\n+        String refresh = request.param(\"refresh\");\n+        try (XContentParser parser = request.contentParser()) {\n+            final GrantApiKeyRequest grantRequest = PARSER.parse(parser, null);\n+            if (refresh != null) {\n+                grantRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.parse(refresh));\n+            }\n+            return channel -> client.execute(GrantApiKeyAction.INSTANCE, grantRequest, new ResponseListener(channel));\n+        }\n+    }\n+\n+    private class ResponseListener implements ActionListener<CreateApiKeyResponse> {\n+        private final RestChannel channel;\n+\n+        ResponseListener(RestChannel channel) {\n+            this.channel = channel;\n+        }\n+\n+        @Override\n+        public void onResponse(CreateApiKeyResponse response) {\n+            try (XContentBuilder builder = channel.newBuilder()) {\n+                channel.sendResponse(new BytesRestResponse(RestStatus.OK, response.toXContent(builder, channel.request())));\n+            } catch (IOException e) {\n+                sendFailure(e);\n+            }\n+        }\n+\n+        @Override\n+        public void onFailure(Exception e) {\n+            RestStatus status = ExceptionsHelper.status(e);\n+            if (status == RestStatus.UNAUTHORIZED) {\n+                sendFailure(new ElasticsearchSecurityException(\"Failed to authenticate api key grant\", RestStatus.FORBIDDEN, e));", "originalCommit": "f5808256c01fc4c0ce767b8ebc414be74162e584", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQxNDgzMg==", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r391414832", "bodyText": "Thanks @albertzaharovits that was a huge improvement.", "author": "tvernum", "createdAt": "2020-03-12T05:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzNzMzMw=="}], "type": "inlineReview"}, {"oid": "dbd772635340c02f731b66c470fe659efa6af363", "url": "https://github.com/elastic/elasticsearch/commit/dbd772635340c02f731b66c470fe659efa6af363", "message": "Merge branch 'master' into feature/48716-api-key-other-user", "committedDate": "2020-03-11T11:54:35Z", "type": "commit"}, {"oid": "036c402945d26e524cf435853fc611a852f23312", "url": "https://github.com/elastic/elasticsearch/commit/036c402945d26e524cf435853fc611a852f23312", "message": "Address feedback", "committedDate": "2020-03-11T12:05:02Z", "type": "commit"}, {"oid": "8215d25085f6ae76cbbccbea6a76bb2c065ad62f", "url": "https://github.com/elastic/elasticsearch/commit/8215d25085f6ae76cbbccbea6a76bb2c065ad62f", "message": "Merge branch 'master' into feature/48716-api-key-other-user", "committedDate": "2020-03-12T04:13:51Z", "type": "commit"}, {"oid": "04339c6a52e8f225e68c14ab66039a96dea43a66", "url": "https://github.com/elastic/elasticsearch/commit/04339c6a52e8f225e68c14ab66039a96dea43a66", "message": "Address more feedback", "committedDate": "2020-03-12T04:47:57Z", "type": "commit"}]}