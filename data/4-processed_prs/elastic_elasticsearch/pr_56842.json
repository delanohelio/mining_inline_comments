{"pr_number": 56842, "pr_title": "Add template simulation API for simulating template composition", "pr_createdAt": "2020-05-15T19:18:05Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/56842", "timeline": [{"oid": "581d635cad4aca06996a84c06cb6579e35a2aa69", "url": "https://github.com/elastic/elasticsearch/commit/581d635cad4aca06996a84c06cb6579e35a2aa69", "message": "Add template simulation API for simulating template composition\n\nThis adds an API for simulating template composition with or without an index template.\n\nIt looks like:\n\n```\nPOST /_index_template/_simulate/my-template\n```\n\nTo simulate a template named `my-template` that already exists, or, to simulate a template that does\nnot already exist:\n\n```\nPOST /_index_template/_simulate\n{\n  \"index_patterns\": [\"my-index\"]\n  \"composed_of\": [\"ct1\", \"ct2\"],\n}\n```\n\nThis is related to #55686, which adds an API to simulate composition based on an index name (hence\nthe `_simulate_index` vs `_simulate`).\n\nThis commit also adds reference documentation for both simulation APIs.\n\nRelates to #53101\nResolves #56390\nResolves #56255", "committedDate": "2020-05-15T19:10:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwMTU1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/56842#discussion_r426001557", "bodyText": "@andreidan I had to remove this wrapping because the simulated documents came back with the _doc parameter in the mappings, and they can't be sent as new component or index templates with _doc in the mappings", "author": "dakrone", "createdAt": "2020-05-15T19:19:37Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateIndexTemplateAction.java", "diffHunk": "@@ -99,30 +98,51 @@ protected SimulateIndexTemplateResponse read(StreamInput in) throws IOException\n     @Override\n     protected void masterOperation(Task task, SimulateIndexTemplateRequest request, ClusterState state,\n                                    ActionListener<SimulateIndexTemplateResponse> listener) throws Exception {\n-        ClusterState simulateOnClusterState = state;\n+        final ClusterState stateWithTemplate;\n         if (request.getIndexTemplateRequest() != null) {\n             // we'll \"locally\" add the template defined by the user in the cluster state (as if it existed in the system)\n-            String simulateTemplateToAdd = \"simulate_new_template_\" + UUIDs.randomBase64UUID().toLowerCase(Locale.ROOT);\n-            simulateOnClusterState = indexTemplateService.addIndexTemplateV2(state, request.getIndexTemplateRequest().create(),\n+            String simulateTemplateToAdd = \"simulate_index_template_\" + UUIDs.randomBase64UUID().toLowerCase(Locale.ROOT);\n+            // Perform validation for things like typos in component template names\n+            MetadataIndexTemplateService.validateV2TemplateRequest(state.metadata(), simulateTemplateToAdd,\n+                request.getIndexTemplateRequest().indexTemplate());\n+            stateWithTemplate = indexTemplateService.addIndexTemplateV2(state, request.getIndexTemplateRequest().create(),\n                 simulateTemplateToAdd, request.getIndexTemplateRequest().indexTemplate());\n+        } else {\n+            stateWithTemplate = state;\n         }\n \n-        String matchingTemplate = findV2Template(simulateOnClusterState.metadata(), request.getIndexName(), false);\n+        String matchingTemplate = findV2Template(stateWithTemplate.metadata(), request.getIndexName(), false);\n         if (matchingTemplate == null) {\n             listener.onResponse(new SimulateIndexTemplateResponse(null, null));\n             return;\n         }\n-        Settings settings = resolveSettings(simulateOnClusterState.metadata(), matchingTemplate);\n \n-        // empty request mapping as the user can't specify any explicit mappings via the simulate api\n-        Map<String, Object> mappings = resolveV2Mappings(\"{}\", simulateOnClusterState, matchingTemplate, xContentRegistry);\n-        String mappingsJson = Strings.toString(XContentFactory.jsonBuilder()\n-            .startObject()\n-            .field(MapperService.SINGLE_MAPPING_NAME, mappings)\n-            .endObject());", "originalCommit": "581d635cad4aca06996a84c06cb6579e35a2aa69", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6ff715f461fc3f79babeec70b0977c717ceacb52", "url": "https://github.com/elastic/elasticsearch/commit/6ff715f461fc3f79babeec70b0977c717ceacb52", "message": "Add to list of HLRC test exemptions", "committedDate": "2020-05-15T21:24:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUwMjg0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/56842#discussion_r426502845", "bodyText": "Should we also include the merged templates to illustrate the index template composition? (ie. the result of the _simulate* calls?)", "author": "andreidan", "createdAt": "2020-05-18T09:47:47Z", "path": "docs/reference/indices/index-templates.asciidoc", "diffHunk": "@@ -291,6 +291,96 @@ PUT /_index_template/template_1\n In this case, an index matching `t*` will have three primary shards. If the order of composed\n templates were reversed, the index would have two primary shards.\n \n+\n+[[simulating-templates]]\n+===== Simulating template composition\n+\n+Since templates can be composed not only of multiple component templates, but also the index\n+template itself, there are two simulation APIs to determine what the resulting index settings will\n+be.\n+\n+To simulate the settings that would be applied to a matching index name:\n+\n+[source,console]\n+--------------------------------------------------\n+POST /_index_template/_simulate_index/myindex\n+--------------------------------------------------\n+\n+To simulate the settings that would be applied from a particular template:\n+\n+[source,console]\n+--------------------------------------------------\n+POST /_index_template/_simulate/template_1\n+\n+POST /_index_template/_simulate\n+{\n+  \"index_patterns\": [\"foo\"],\n+  \"template\": {\n+    \"settings\": {\n+      \"number_of_replicas\": 0\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+\n+Here's an example demonstrating simulating both an index name and template name:\n+\n+[source,console]\n+--------------------------------------------------\n+PUT /_component_template/ct1 <1>\n+{\n+  \"template\": {\n+    \"settings\": {\n+      \"index.number_of_shards\": 2\n+    }\n+  }\n+}\n+\n+PUT /_component_template/ct2 <2>\n+{\n+  \"template\": {\n+    \"settings\": {\n+      \"index.number_of_replicas\": 0\n+    },\n+    \"mappings\": {\n+      \"properties\": {\n+        \"@timestamp\": {\n+          \"type\": \"date\"\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+PUT /_index_template/final-template <3>\n+{\n+  \"index_patterns\": [\"logdata-*\"],\n+  \"composed_of\": [\"ct1\", \"ct2\"],\n+  \"priority\": 5\n+}\n+\n+POST /_index_template/_simulate_index/logdata-2019-02-01 <4>\n+\n+POST /_index_template/_simulate/final-template <5>\n+\n+POST /_index_template/_simulate <6>\n+{\n+  \"index_patterns\": [\"mydata-*\"],\n+  \"composed_of\": [\"ct2\"],\n+  \"priority\": 10\n+}\n+--------------------------------------------------\n+<1> Creating a component template (ct1) setting the number of shards to two\n+<2> Creating another component template (ct2) setting the number of replicas to zero with mappings\n+<3> Creating an index template called \"final\" template using ct1 and ct2\n+<4> Simulate the settings that would be applied for a new index \"logdata-2019-02-01\"\n+<5> Simulate the settings composed using the \"final-template\" index template\n+<6> Simulate the settings composed using a custom specified template\n+\n+When simulating a template and specifying a template in the body of the request, the simulated\n+template is not added to the existing templates, it is only used for the simulation.\n+", "originalCommit": "6ff715f461fc3f79babeec70b0977c717ceacb52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUyMDY4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/56842#discussion_r426520683", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        listener.onFailure(new IllegalArgumentException(\"unable to find a matching template\"));\n          \n          \n            \n                        listener.onFailure(new IllegalArgumentException(\"a template name to match or a new template body must be specified\"));", "author": "andreidan", "createdAt": "2020-05-18T10:17:45Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateTemplateAction.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeReadAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.AliasValidator;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.IndexTemplateV2;\n+import org.elasticsearch.cluster.metadata.MetadataIndexTemplateService;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV1Templates;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV2Templates;\n+\n+/**\n+ * Handles simulating an index template either by name (looking it up in the\n+ * cluster state), or by a provided template configuration\n+ */\n+public class TransportSimulateTemplateAction\n+    extends TransportMasterNodeReadAction<SimulateTemplateAction.Request, SimulateIndexTemplateResponse> {\n+\n+    private final MetadataIndexTemplateService indexTemplateService;\n+    private final NamedXContentRegistry xContentRegistry;\n+    private final IndicesService indicesService;\n+    private AliasValidator aliasValidator;\n+\n+    @Inject\n+    public TransportSimulateTemplateAction(TransportService transportService, ClusterService clusterService,\n+                                           ThreadPool threadPool, MetadataIndexTemplateService indexTemplateService,\n+                                           ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver,\n+                                           NamedXContentRegistry xContentRegistry, IndicesService indicesService) {\n+        super(SimulateTemplateAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            SimulateTemplateAction.Request::new, indexNameExpressionResolver);\n+        this.indexTemplateService = indexTemplateService;\n+        this.xContentRegistry = xContentRegistry;\n+        this.indicesService = indicesService;\n+        this.aliasValidator = new AliasValidator();\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        return ThreadPool.Names.SAME;\n+    }\n+\n+    @Override\n+    protected SimulateIndexTemplateResponse read(StreamInput in) throws IOException {\n+        return new SimulateIndexTemplateResponse(in);\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, SimulateTemplateAction.Request request, ClusterState state,\n+                                   ActionListener<SimulateIndexTemplateResponse> listener) throws Exception {\n+        String uuid = UUIDs.randomBase64UUID().toLowerCase(Locale.ROOT);\n+        final String temporaryIndexName = \"simulate_template_index_\" + uuid;\n+        final ClusterState stateWithTemplate;\n+        final String simulateTemplateToAdd;\n+\n+        // First, if a template body was requested, we need to \"fake add\" that template to the\n+        // cluster state, so it can be used when we resolved settings/etc\n+        if (request.getIndexTemplateRequest() != null) {\n+            // we'll \"locally\" add the template defined by the user in the cluster state (as if it existed in the system)\n+            simulateTemplateToAdd = \"simulate_template_\" + uuid;\n+            // Perform validation for things like typos in component template names\n+            MetadataIndexTemplateService.validateV2TemplateRequest(state.metadata(), simulateTemplateToAdd,\n+                request.getIndexTemplateRequest().indexTemplate());\n+            stateWithTemplate = indexTemplateService.addIndexTemplateV2(state, request.getIndexTemplateRequest().create(),\n+                simulateTemplateToAdd, request.getIndexTemplateRequest().indexTemplate());\n+        } else {\n+            simulateTemplateToAdd = null;\n+            stateWithTemplate = state;\n+        }\n+\n+        // We also need the name of the template we're going to resolve, so if they specified a\n+        // name, use that, otherwise use the name of the template that was \"fake added\" in the previous block\n+        final String matchingTemplate;\n+        if (request.getTemplateName() == null) {\n+            // Automatically match the template that was added\n+            matchingTemplate = simulateTemplateToAdd;\n+        } else {\n+            matchingTemplate = request.getTemplateName();\n+        }\n+\n+        // If they didn't either specify a name that existed or a template body, we cannot simulate anything!\n+        if (matchingTemplate == null) {\n+            // They should have specified either a template name or the body of a template, but neither were specified\n+            listener.onFailure(new IllegalArgumentException(\"unable to find a matching template\"));", "originalCommit": "6ff715f461fc3f79babeec70b0977c717ceacb52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b2756012526d536562d6eeeac7c9b2f13405b0f2", "url": "https://github.com/elastic/elasticsearch/commit/b2756012526d536562d6eeeac7c9b2f13405b0f2", "message": "Add example output to docs", "committedDate": "2020-05-18T18:18:38Z", "type": "commit"}, {"oid": "4b6164b4b1ab955cc04a298c9f568fab83924204", "url": "https://github.com/elastic/elasticsearch/commit/4b6164b4b1ab955cc04a298c9f568fab83924204", "message": "Update server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateTemplateAction.java\n\nCo-authored-by: Andrei Dan <andrei.dan@elastic.co>", "committedDate": "2020-05-18T18:19:13Z", "type": "commit"}, {"oid": "2f0c4ca6372f2c3ee2165a240b5cc411db730642", "url": "https://github.com/elastic/elasticsearch/commit/2f0c4ca6372f2c3ee2165a240b5cc411db730642", "message": "Merge branch 'master' into itv2-add-simulate-template", "committedDate": "2020-05-18T19:32:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1NzY5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/56842#discussion_r426857699", "bodyText": "I think it's worth explaining why this isn't a composite of number_of_replicas and number_of_shards either inline or linking to some docs that explain the merging strategy we've chosen. Otherwise I can see people being confused and possibly thinking this is a typo.", "author": "cjcenizal", "createdAt": "2020-05-18T19:50:20Z", "path": "docs/reference/indices/index-templates.asciidoc", "diffHunk": "@@ -291,6 +291,127 @@ PUT /_index_template/template_1\n In this case, an index matching `t*` will have three primary shards. If the order of composed\n templates were reversed, the index would have two primary shards.\n \n+\n+[[simulating-templates]]\n+===== Simulating template composition\n+\n+Since templates can be composed not only of multiple component templates, but also the index\n+template itself, there are two simulation APIs to determine what the resulting index settings will\n+be.\n+\n+To simulate the settings that would be applied to a matching index name:\n+\n+[source,console]\n+--------------------------------------------------\n+POST /_index_template/_simulate_index/myindex\n+--------------------------------------------------\n+\n+To simulate the settings that would be applied from a particular template:\n+\n+[source,console]\n+--------------------------------------------------\n+POST /_index_template/_simulate/template_1\n+\n+POST /_index_template/_simulate\n+{\n+  \"index_patterns\": [\"foo\"],\n+  \"template\": {\n+    \"settings\": {\n+      \"number_of_replicas\": 0\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+\n+Here's an example demonstrating simulating both an index name and template name:\n+\n+[source,console]\n+--------------------------------------------------\n+PUT /_component_template/ct1 <1>\n+{\n+  \"template\": {\n+    \"settings\": {\n+      \"index.number_of_shards\": 2\n+    }\n+  }\n+}\n+\n+PUT /_component_template/ct2 <2>\n+{\n+  \"template\": {\n+    \"settings\": {\n+      \"index.number_of_replicas\": 0\n+    },\n+    \"mappings\": {\n+      \"properties\": {\n+        \"@timestamp\": {\n+          \"type\": \"date\"\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+PUT /_index_template/final-template <3>\n+{\n+  \"index_patterns\": [\"logdata-*\"],\n+  \"composed_of\": [\"ct1\", \"ct2\"],\n+  \"priority\": 5\n+}\n+\n+POST /_index_template/_simulate_index/logdata-2019-02-01 <4>\n+\n+POST /_index_template/_simulate/final-template <5>\n+\n+POST /_index_template/_simulate <6>\n+{\n+  \"index_patterns\": [\"logdata-*\"],\n+  \"composed_of\": [\"ct2\"],\n+  \"priority\": 10\n+}\n+--------------------------------------------------\n+<1> Creating a component template (ct1) setting the number of shards to two\n+<2> Creating another component template (ct2) setting the number of replicas to zero with mappings\n+<3> Creating an index template called \"final\" template using ct1 and ct2\n+<4> Simulate the settings that would be applied for a new index \"logdata-2019-02-01\"\n+<5> Simulate the settings composed using the \"final-template\" index template\n+<6> Simulate the settings composed using a custom specified template\n+\n+The output of the simulate API looks like:\n+\n+[source,console-result]\n+---------------------------------------------------------\n+{\n+  \"template\" : {\n+    \"settings\" : {\n+      \"index\" : {", "originalCommit": "2f0c4ca6372f2c3ee2165a240b5cc411db730642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9916b812e20f8c40c6965851ba9cdf1051ac1925", "url": "https://github.com/elastic/elasticsearch/commit/9916b812e20f8c40c6965851ba9cdf1051ac1925", "message": "More docs", "committedDate": "2020-05-18T20:09:08Z", "type": "commit"}]}