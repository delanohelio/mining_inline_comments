{"pr_number": 54227, "pr_title": "EQL: Sequence/Join parsing and model", "pr_createdAt": "2020-03-25T19:47:50Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/54227", "timeline": [{"oid": "c5d7a3f213b53d5a623796818f23d64c539a4e73", "url": "https://github.com/elastic/elasticsearch/commit/c5d7a3f213b53d5a623796818f23d64c539a4e73", "message": "Initial model and parsing for Join", "committedDate": "2020-03-31T20:03:20Z", "type": "forcePushed"}, {"oid": "9b7dfeac1ea7b4af379342fcad761de4c5787432", "url": "https://github.com/elastic/elasticsearch/commit/9b7dfeac1ea7b4af379342fcad761de4c5787432", "message": "wip", "committedDate": "2020-04-02T12:13:58Z", "type": "commit"}, {"oid": "f00e6f088f14f7bc0cfa8ca77a5c31215bd9391c", "url": "https://github.com/elastic/elasticsearch/commit/f00e6f088f14f7bc0cfa8ca77a5c31215bd9391c", "message": "Initial model and parsing for Join", "committedDate": "2020-04-02T12:13:58Z", "type": "commit"}, {"oid": "96550c11222b5738628c6ac6cd3589bd5ff199d7", "url": "https://github.com/elastic/elasticsearch/commit/96550c11222b5738628c6ac6cd3589bd5ff199d7", "message": "wip", "committedDate": "2020-04-02T12:13:59Z", "type": "commit"}, {"oid": "adfa27c40a0979a139bf2cb97464652ce811443f", "url": "https://github.com/elastic/elasticsearch/commit/adfa27c40a0979a139bf2cb97464652ce811443f", "message": "Done with parsing, need to improve the test suite.", "committedDate": "2020-04-02T13:01:25Z", "type": "commit"}, {"oid": "adfa27c40a0979a139bf2cb97464652ce811443f", "url": "https://github.com/elastic/elasticsearch/commit/adfa27c40a0979a139bf2cb97464652ce811443f", "message": "Done with parsing, need to improve the test suite.", "committedDate": "2020-04-02T13:01:25Z", "type": "forcePushed"}, {"oid": "6d4d3948fc845b28153537d4d6a3bd47ac5f5b43", "url": "https://github.com/elastic/elasticsearch/commit/6d4d3948fc845b28153537d4d6a3bd47ac5f5b43", "message": "Add more parsing tests", "committedDate": "2020-04-03T21:28:40Z", "type": "commit"}, {"oid": "1d344373133fbd0f261bb5e2292bea65193d1b75", "url": "https://github.com/elastic/elasticsearch/commit/1d344373133fbd0f261bb5e2292bea65193d1b75", "message": "Merge remote-tracking branch 'remotes/upstream/master' into eql/sequence", "committedDate": "2020-04-03T21:29:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM2ODA2NA==", "url": "https://github.com/elastic/elasticsearch/pull/54227#discussion_r403368064", "bodyText": "I added #54760 to track an issue for removing unknown time units and only supporting ones that are recognized by range queries.", "author": "rw-access", "createdAt": "2020-04-03T22:34:44Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LogicalPlanBuilder.java", "diffHunk": "@@ -44,11 +61,157 @@ public LogicalPlan visitEventQuery(EqlBaseParser.EventQueryContext ctx) {\n             condition = new And(source, eventMatch, condition);\n         }\n \n-        Filter filter = new Filter(source, new UnresolvedRelation(Source.EMPTY, null, \"\", false, \"\"), condition);\n-        // add implicit sorting - when pipes are added, this would better seat there (as a default pipe)\n+        Filter filter = new Filter(source, RELATION, condition);\n+        // add implicit sorting - when pipes are added, this would better sit there (as a default pipe)\n         Order order = new Order(source, new UnresolvedAttribute(source, params.fieldTimestamp()), Order.OrderDirection.ASC,\n                 Order.NullsPosition.FIRST);\n         OrderBy orderBy = new OrderBy(source, filter, singletonList(order));\n         return orderBy;\n     }\n-}\n+\n+    @Override\n+    public Join visitJoin(JoinContext ctx) {\n+        List<Expression> parentJoinKeys = visitJoinKeys(ctx.by);\n+\n+        LogicalPlan until;\n+        \n+        if (ctx.until != null) {\n+            until = visitJoinTerm(ctx.until, parentJoinKeys);\n+        } else {\n+            // no until declared means the condition never gets executed and thus folds to false\n+            until = new Filter(source(ctx), RELATION, new Literal(source(ctx), Boolean.FALSE, DataTypes.BOOLEAN));\n+        }\n+        \n+        int numberOfKeys = -1;\n+        List<LogicalPlan> queries = new ArrayList<>(ctx.joinTerm().size());\n+\n+        for (JoinTermContext joinTermCtx : ctx.joinTerm()) {\n+            KeyedFilter joinTerm = visitJoinTerm(joinTermCtx, parentJoinKeys);\n+            int keySize = joinTerm.keys().size();\n+            if (numberOfKeys < 0) {\n+                numberOfKeys = keySize;\n+            } else {\n+                if (numberOfKeys != keySize) {\n+                    Source src = source(joinTermCtx.by != null ? joinTermCtx.by : joinTermCtx);\n+                    int expected = numberOfKeys - parentJoinKeys.size();\n+                    int found = keySize - parentJoinKeys.size();\n+                    throw new ParsingException(src, \"Inconsistent number of join keys specified; expected [{}] but found [{}]\", expected,\n+                            found);\n+                }\n+                queries.add(joinTerm);\n+            }\n+        }\n+\n+        return new Join(source(ctx), queries, until);\n+    }\n+\n+    public KeyedFilter visitJoinTerm(JoinTermContext ctx, List<Expression> joinKeys) {\n+        List<Expression> keys = CollectionUtils.combine(joinKeys, visitJoinKeys(ctx.by));\n+        return new KeyedFilter(source(ctx), visitEventQuery(ctx.subquery().eventQuery()), keys);\n+    }\n+\n+    @Override\n+    public Sequence visitSequence(SequenceContext ctx) {\n+        List<Expression> parentJoinKeys = visitJoinKeys(ctx.by);\n+\n+        TimeValue maxSpan = visitSequenceParams(ctx.sequenceParams());\n+\n+        LogicalPlan until;\n+\n+        if (ctx.until != null) {\n+            until = visitSequenceTerm(ctx.until, parentJoinKeys);\n+        } else {\n+            // no until declared means the condition never gets executed and thus folds to false\n+            until = new Filter(source(ctx), RELATION, new Literal(source(ctx), Boolean.FALSE, DataTypes.BOOLEAN));\n+        }\n+\n+        int numberOfKeys = -1;\n+        List<LogicalPlan> queries = new ArrayList<>(ctx.sequenceTerm().size());\n+\n+        for (SequenceTermContext sequenceTermCtx : ctx.sequenceTerm()) {\n+            KeyedFilter sequenceTerm = visitSequenceTerm(sequenceTermCtx, parentJoinKeys);\n+            int keySize = sequenceTerm.keys().size();\n+            if (numberOfKeys < 0) {\n+                numberOfKeys = keySize;\n+            } else {\n+                if (numberOfKeys != keySize) {\n+                    Source src = source(sequenceTermCtx.by != null ? sequenceTermCtx.by : sequenceTermCtx);\n+                    int expected = numberOfKeys - parentJoinKeys.size();\n+                    int found = keySize - parentJoinKeys.size();\n+                    throw new ParsingException(src, \"Inconsistent number of join keys specified; expected [{}] but found [{}]\", expected,\n+                            found);\n+                }\n+                queries.add(sequenceTerm);\n+            }\n+        }\n+\n+        return new Sequence(source(ctx), queries, until, maxSpan);\n+    }\n+\n+    public KeyedFilter visitSequenceTerm(SequenceTermContext ctx, List<Expression> joinKeys) {\n+        if (ctx.FORK() != null) {\n+            throw new ParsingException(source(ctx.FORK()), \"sequence fork is unsupported\");\n+        }\n+\n+        List<Expression> keys = CollectionUtils.combine(joinKeys, visitJoinKeys(ctx.by));\n+        return new KeyedFilter(source(ctx), visitEventQuery(ctx.subquery().eventQuery()), keys);\n+    }\n+\n+    @Override\n+    public TimeValue visitSequenceParams(SequenceParamsContext ctx) {\n+        if (ctx == null) {\n+            return TimeValue.MINUS_ONE;\n+        }\n+\n+        NumberContext numberCtx = ctx.timeUnit().number();\n+        if (numberCtx instanceof IntegerLiteralContext) {\n+            Number number = (Number) visitIntegerLiteral((IntegerLiteralContext) numberCtx).fold();\n+            long value = number.longValue();\n+            \n+            if (value <= 0) {\n+                throw new ParsingException(source(numberCtx), \"A positive maxspan value is required; found [{}]\", value);\n+            }\n+            \n+            String timeString = text(ctx.timeUnit().IDENTIFIER());\n+            TimeUnit timeUnit = TimeUnit.SECONDS;\n+            if (timeString != null) {\n+                switch (timeString) {\n+                    case \"\":\n+                    case \"s\":\n+                    case \"sec\":\n+                    case \"secs\":\n+                    case \"second\":\n+                    case \"seconds\":\n+                        timeUnit = TimeUnit.SECONDS;\n+                        break;\n+                    case \"m\":\n+                    case \"min\":\n+                    case \"mins\":\n+                    case \"minute\":\n+                    case \"minutes\":\n+                        timeUnit = TimeUnit.MINUTES;\n+                        break;\n+                    case \"h\":\n+                    case \"hs\":\n+                    case \"hour\":\n+                    case \"hours\":\n+                        timeUnit = TimeUnit.HOURS;\n+                        break;\n+                    case \"d\":\n+                    case \"ds\":\n+                    case \"day\":\n+                    case \"days\":\n+                        timeUnit = TimeUnit.DAYS;\n+                        break;\n+                    default:", "originalCommit": "1d344373133fbd0f261bb5e2292bea65193d1b75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0fb96ca04c34bc556ffad4ceacd5bb76a56e3fc3", "url": "https://github.com/elastic/elasticsearch/commit/0fb96ca04c34bc556ffad4ceacd5bb76a56e3fc3", "message": "Merge branch 'master' into eql/sequence", "committedDate": "2020-04-04T18:54:56Z", "type": "commit"}, {"oid": "08bd9240399c22446d61512d8c70431d97e09318", "url": "https://github.com/elastic/elasticsearch/commit/08bd9240399c22446d61512d8c70431d97e09318", "message": "Merge branch 'master' into eql/sequence", "committedDate": "2020-04-05T17:11:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEzMDg0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/54227#discussion_r404130846", "bodyText": "does the sequence of 0 timespan make sense at all?", "author": "aleksmaus", "createdAt": "2020-04-06T14:22:26Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LogicalPlanBuilder.java", "diffHunk": "@@ -44,11 +61,157 @@ public LogicalPlan visitEventQuery(EqlBaseParser.EventQueryContext ctx) {\n             condition = new And(source, eventMatch, condition);\n         }\n \n-        Filter filter = new Filter(source, new UnresolvedRelation(Source.EMPTY, null, \"\", false, \"\"), condition);\n-        // add implicit sorting - when pipes are added, this would better seat there (as a default pipe)\n+        Filter filter = new Filter(source, RELATION, condition);\n+        // add implicit sorting - when pipes are added, this would better sit there (as a default pipe)\n         Order order = new Order(source, new UnresolvedAttribute(source, params.fieldTimestamp()), Order.OrderDirection.ASC,\n                 Order.NullsPosition.FIRST);\n         OrderBy orderBy = new OrderBy(source, filter, singletonList(order));\n         return orderBy;\n     }\n-}\n+\n+    @Override\n+    public Join visitJoin(JoinContext ctx) {\n+        List<Expression> parentJoinKeys = visitJoinKeys(ctx.by);\n+\n+        LogicalPlan until;\n+        \n+        if (ctx.until != null) {\n+            until = visitJoinTerm(ctx.until, parentJoinKeys);\n+        } else {\n+            // no until declared means the condition never gets executed and thus folds to false\n+            until = new Filter(source(ctx), RELATION, new Literal(source(ctx), Boolean.FALSE, DataTypes.BOOLEAN));\n+        }\n+        \n+        int numberOfKeys = -1;\n+        List<LogicalPlan> queries = new ArrayList<>(ctx.joinTerm().size());\n+\n+        for (JoinTermContext joinTermCtx : ctx.joinTerm()) {\n+            KeyedFilter joinTerm = visitJoinTerm(joinTermCtx, parentJoinKeys);\n+            int keySize = joinTerm.keys().size();\n+            if (numberOfKeys < 0) {\n+                numberOfKeys = keySize;\n+            } else {\n+                if (numberOfKeys != keySize) {\n+                    Source src = source(joinTermCtx.by != null ? joinTermCtx.by : joinTermCtx);\n+                    int expected = numberOfKeys - parentJoinKeys.size();\n+                    int found = keySize - parentJoinKeys.size();\n+                    throw new ParsingException(src, \"Inconsistent number of join keys specified; expected [{}] but found [{}]\", expected,\n+                            found);\n+                }\n+                queries.add(joinTerm);\n+            }\n+        }\n+\n+        return new Join(source(ctx), queries, until);\n+    }\n+\n+    public KeyedFilter visitJoinTerm(JoinTermContext ctx, List<Expression> joinKeys) {\n+        List<Expression> keys = CollectionUtils.combine(joinKeys, visitJoinKeys(ctx.by));\n+        return new KeyedFilter(source(ctx), visitEventQuery(ctx.subquery().eventQuery()), keys);\n+    }\n+\n+    @Override\n+    public Sequence visitSequence(SequenceContext ctx) {\n+        List<Expression> parentJoinKeys = visitJoinKeys(ctx.by);\n+\n+        TimeValue maxSpan = visitSequenceParams(ctx.sequenceParams());\n+\n+        LogicalPlan until;\n+\n+        if (ctx.until != null) {\n+            until = visitSequenceTerm(ctx.until, parentJoinKeys);\n+        } else {\n+            // no until declared means the condition never gets executed and thus folds to false\n+            until = new Filter(source(ctx), RELATION, new Literal(source(ctx), Boolean.FALSE, DataTypes.BOOLEAN));\n+        }\n+\n+        int numberOfKeys = -1;\n+        List<LogicalPlan> queries = new ArrayList<>(ctx.sequenceTerm().size());\n+\n+        for (SequenceTermContext sequenceTermCtx : ctx.sequenceTerm()) {\n+            KeyedFilter sequenceTerm = visitSequenceTerm(sequenceTermCtx, parentJoinKeys);\n+            int keySize = sequenceTerm.keys().size();\n+            if (numberOfKeys < 0) {\n+                numberOfKeys = keySize;\n+            } else {\n+                if (numberOfKeys != keySize) {\n+                    Source src = source(sequenceTermCtx.by != null ? sequenceTermCtx.by : sequenceTermCtx);\n+                    int expected = numberOfKeys - parentJoinKeys.size();\n+                    int found = keySize - parentJoinKeys.size();\n+                    throw new ParsingException(src, \"Inconsistent number of join keys specified; expected [{}] but found [{}]\", expected,\n+                            found);\n+                }\n+                queries.add(sequenceTerm);\n+            }\n+        }\n+\n+        return new Sequence(source(ctx), queries, until, maxSpan);\n+    }\n+\n+    public KeyedFilter visitSequenceTerm(SequenceTermContext ctx, List<Expression> joinKeys) {\n+        if (ctx.FORK() != null) {\n+            throw new ParsingException(source(ctx.FORK()), \"sequence fork is unsupported\");\n+        }\n+\n+        List<Expression> keys = CollectionUtils.combine(joinKeys, visitJoinKeys(ctx.by));\n+        return new KeyedFilter(source(ctx), visitEventQuery(ctx.subquery().eventQuery()), keys);\n+    }\n+\n+    @Override\n+    public TimeValue visitSequenceParams(SequenceParamsContext ctx) {\n+        if (ctx == null) {\n+            return TimeValue.MINUS_ONE;\n+        }\n+\n+        NumberContext numberCtx = ctx.timeUnit().number();\n+        if (numberCtx instanceof IntegerLiteralContext) {\n+            Number number = (Number) visitIntegerLiteral((IntegerLiteralContext) numberCtx).fold();\n+            long value = number.longValue();\n+            \n+            if (value <= 0) {", "originalCommit": "08bd9240399c22446d61512d8c70431d97e09318", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE5MDczMg==", "url": "https://github.com/elastic/elasticsearch/pull/54227#discussion_r404190732", "bodyText": "I think not - if no maxspan is needed I opted for not declaring it.\nIf we agree to have 0 indicate no limit across EQL, the parser can be improved.", "author": "costin", "createdAt": "2020-04-06T15:39:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEzMDg0Ng=="}], "type": "inlineReview"}]}