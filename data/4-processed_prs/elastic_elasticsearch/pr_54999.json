{"pr_number": 54999, "pr_title": "Handle TLS file updates during startup", "pr_createdAt": "2020-04-09T06:04:22Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/54999", "timeline": [{"oid": "60788f10dd3cb14e7d1a904174ed57c444ba2113", "url": "https://github.com/elastic/elasticsearch/commit/60788f10dd3cb14e7d1a904174ed57c444ba2113", "message": "Handle TLS file updates during startup\n\nThis change reworks the loading and monitoring of files that are used\nfor the construction of SSLContexts so that updates to these files are\nnot lost if the updates occur during startup. Previously, the\nSSLService would parse the settings, build the SSLConfiguration\nobjects, and construct the SSLContexts prior to the\nSSLConfigurationReloader starting to monitor these files for changes.\nThis allowed for a small window where updates to these files may never\nbe observed until the node restarted.\n\nTo remove the potential miss of a change to these files, the code now\nparses the settings and builds SSLConfiguration instances prior to the\nconstruction of the SSLService. The files back the SSLConfiguration\ninstances are then registered for monitoring and finally the SSLService\nis constructed from the previously parse SSLConfiguration instances. As\nthe SSLService is not constructed when the code starts monitoring the\nfiles for changes, a CompleteableFuture is used to obtain a reference\nto the SSLService; this allows for construction of the SSLService to\ncomplete and ensures that we do not miss any file updates during the\nconstruction of the SSLService.\n\nWhile working on this change, the SSLConfigurationReloader was also\nrefactored to reflect how it is currently used. When the\nSSLConfigurationReloader was originally written the files that it\nmonitored could change during runtime. This is no longer the case as\nwe stopped the monitoring of files that back dynamic SSLContext\ninstances. In order to support the ability for items to change during\nruntime, the class made use of concurrent data structures. The use of\nthese concurrent datastructures has been removed and the class is now\nprimarily a utility class that no longer needs to be instantiated.\n\nCloses #54867", "committedDate": "2020-04-09T05:45:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwNjY0NA==", "url": "https://github.com/elastic/elasticsearch/pull/54999#discussion_r407806644", "bodyText": "This is a nice change to have immutable list of SSLConfiguration and avoid the overhead of CopyOnWriteArraySet.", "author": "ywangd", "createdAt": "2020-04-14T01:08:06Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ssl/SSLConfigurationReloader.java", "diffHunk": "@@ -17,68 +17,55 @@\n \n import java.io.IOException;\n import java.nio.file.Path;\n+import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.function.Consumer;\n \n /**\n  * Ensures that the files backing an {@link SSLConfiguration} are monitored for changes and the underlying key/trust material is reloaded\n  * and the {@link SSLContext} has existing sessions invalidated to force the use of the new key/trust material\n  */\n-public class SSLConfigurationReloader {\n+public final class SSLConfigurationReloader {\n \n     private static final Logger logger = LogManager.getLogger(SSLConfigurationReloader.class);\n \n-    private final ConcurrentHashMap<Path, ChangeListener> pathToChangeListenerMap = new ConcurrentHashMap<>();\n-    private final Environment environment;\n-    private final ResourceWatcherService resourceWatcherService;\n-    private final SSLService sslService;\n-\n-    public SSLConfigurationReloader(Environment env, SSLService sslService, ResourceWatcherService resourceWatcher) {\n-        this.environment = env;\n-        this.resourceWatcherService = resourceWatcher;\n-        this.sslService = sslService;\n-        startWatching(sslService.getLoadedSSLConfigurations());\n-    }\n+    private SSLConfigurationReloader() { }\n \n     /**\n      * Collects all of the directories that need to be monitored for the provided {@link SSLConfiguration} instances and ensures that\n      * they are being watched for changes\n      */\n-    private void startWatching(Collection<SSLConfiguration> sslConfigurations) {\n+    public static void startWatching(Environment environment, Consumer<SSLConfiguration> reloadConsumer,\n+                                      ResourceWatcherService resourceWatcherService, Collection<SSLConfiguration> sslConfigurations) {\n+        Map<Path, List<SSLConfiguration>> pathToConfigurationsMap = new HashMap<>();\n         for (SSLConfiguration sslConfiguration : sslConfigurations) {\n             for (Path directory : directoriesToMonitor(sslConfiguration.filesToMonitor(environment))) {\n-                pathToChangeListenerMap.compute(directory, (path, listener) -> {\n-                    if (listener != null) {\n-                        listener.addSSLConfiguration(sslConfiguration);\n-                        return listener;\n+                pathToConfigurationsMap.compute(directory, (path, list) -> {\n+                    if (list == null) {\n+                        list = new ArrayList<>();\n                     }\n-\n-                    ChangeListener changeListener = new ChangeListener();\n-                    changeListener.addSSLConfiguration(sslConfiguration);\n-                    FileWatcher fileWatcher = new FileWatcher(path);\n-                    fileWatcher.addListener(changeListener);\n-                    try {\n-                        resourceWatcherService.add(fileWatcher, Frequency.HIGH);\n-                        return changeListener;\n-                    } catch (IOException e) {\n-                        logger.error(\"failed to start watching directory [{}] for ssl configuration [{}]\", path, sslConfiguration);\n-                    }\n-                    return null;\n+                    list.add(sslConfiguration);\n+                    return list;\n                 });\n             }\n         }\n-    }\n \n-    /**\n-     * Reloads the ssl context associated with this configuration. It is visible so that tests can override as needed\n-     */\n-    void reloadSSLContext(SSLConfiguration configuration) {\n-        logger.debug(\"reloading ssl configuration [{}]\", configuration);\n-        sslService.sslContextHolder(configuration).reload();\n+        for (Entry<Path, List<SSLConfiguration>> entry : pathToConfigurationsMap.entrySet()) {\n+            ChangeListener changeListener = new ChangeListener(environment, List.copyOf(entry.getValue()), reloadConsumer);", "originalCommit": "60788f10dd3cb14e7d1a904174ed57c444ba2113", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxMDMyNg==", "url": "https://github.com/elastic/elasticsearch/pull/54999#discussion_r407810326", "bodyText": "What is this extra setting for?", "author": "ywangd", "createdAt": "2020-04-14T01:21:44Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/test/SecuritySettingsSource.java", "diffHunk": "@@ -130,6 +131,7 @@ public Settings nodeSettings(int nodeOrdinal) {\n         writeFile(xpackConf, \"users_roles\", configUsersRoles());\n \n         Settings.Builder builder = Settings.builder()\n+                .put(Environment.PATH_HOME_SETTING.getKey(), home)", "originalCommit": "60788f10dd3cb14e7d1a904174ed57c444ba2113", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkzNDE0MA==", "url": "https://github.com/elastic/elasticsearch/pull/54999#discussion_r408934140", "bodyText": "In the newly added test, I create an Environment object (https://github.com/elastic/elasticsearch/pull/54999/files/60788f10dd3cb14e7d1a904174ed57c444ba2113#diff-985c60881de972e053b8aaff38e27168R48) which requires path.home to be set in the settings. The intention of the code in the security settings source was to prepare the config directory inside the home directory but the home directory was not specified in the settings from the configuration source (SecuritySettingsSource). The test framework would set the path.home setting through the use of default settings in InternalTestCluster before building the node so that's how it worked before this change.", "author": "jaymode", "createdAt": "2020-04-15T15:29:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxMDMyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwODA5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/54999#discussion_r409208092", "bodyText": "ah ok I see. nodeSettings is called before new InternalTestCluster is created and now path.home is needed inside nodeSettings. So it must be set eariler on. Thanks.", "author": "ywangd", "createdAt": "2020-04-16T00:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxMDMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxODIwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/54999#discussion_r407818205", "bodyText": "I am not clear about the intention of these 2 latches. Why is it necessary? Could you please help me understand? Also would it be better to use Phaser here?", "author": "ywangd", "createdAt": "2020-04-14T01:49:54Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/ssl/SSLReloadDuringStartupIntegTests.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.xpack.ssl;\n+\n+import org.elasticsearch.common.settings.MockSecureSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.env.TestEnvironment;\n+import org.elasticsearch.test.InternalTestCluster.RestartCallback;\n+import org.elasticsearch.test.SecurityIntegTestCase;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.concurrent.CountDownLatch;\n+\n+public class SSLReloadDuringStartupIntegTests extends SecurityIntegTestCase {\n+\n+    @Override\n+    public Settings nodeSettings(int nodeOrdinal) {\n+        Settings settings = super.nodeSettings(nodeOrdinal);\n+        Environment tmpEnv = TestEnvironment.newEnvironment(settings);\n+        // each node gets its own keystore under its home/config dir\n+        Path origKeystorePath = getDataPath(\"/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks\");\n+        Path nodeSpecificPath = tmpEnv.configFile().resolve(\"testnode.jks\");\n+        try {\n+            Files.copy(origKeystorePath, nodeSpecificPath, StandardCopyOption.REPLACE_EXISTING);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+\n+        Settings.Builder builder = Settings.builder()\n+            .put(settings.filter((s) -> s.startsWith(\"xpack.security.transport.ssl.\") == false), false);\n+        MockSecureSettings secureSettings = new MockSecureSettings();\n+        builder.setSecureSettings(secureSettings);\n+        builder.put(\"xpack.security.transport.ssl.keystore.path\", nodeSpecificPath)\n+            .put(\"resource.reload.interval.high\", \"1s\")\n+            .put(\"xpack.security.transport.ssl.enabled\", true);\n+        secureSettings.setString(\"xpack.security.transport.ssl.keystore.secure_password\", \"testnode\");\n+        return builder.build();\n+    }\n+\n+    @Override\n+    protected boolean transportSSLEnabled() {\n+        return true;\n+    }\n+\n+    public void testReloadDuringStartup() throws Exception {\n+        final String node = randomFrom(internalCluster().getNodeNames());\n+        final Environment env = internalCluster().getInstance(Environment.class, node);\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        final CountDownLatch writtenLatch = new CountDownLatch(1);\n+\n+        // restart the node\n+        internalCluster().restartNode(node, new RestartCallback() {\n+            @Override\n+            public Settings onNodeStopped(String nodeName) throws Exception {\n+                Path origKeystorePath = getDataPath(\"/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks\");\n+                Path keystorePath = env.configFile().resolve(\"testnode.jks\");\n+                Path updatedKeystorePath = getDataPath(\"/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks\");\n+                assertTrue(Files.exists(keystorePath));\n+                // replace the keystore\n+                copyAndAtomicMoveIfPossible(updatedKeystorePath, keystorePath);\n+                new Thread(() -> {\n+                    latch.countDown();\n+                    try {\n+                        latch.await();\n+                        Thread.sleep(randomLongBetween(1L, 2000L));\n+                    } catch (InterruptedException e) {\n+                        Thread.currentThread().interrupt();\n+                    }\n+\n+                    try {\n+                        copyAndAtomicMoveIfPossible(origKeystorePath, keystorePath);\n+                        writtenLatch.countDown();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                }).start();\n+\n+                latch.countDown();", "originalCommit": "60788f10dd3cb14e7d1a904174ed57c444ba2113", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0MTAyNw==", "url": "https://github.com/elastic/elasticsearch/pull/54999#discussion_r408941027", "bodyText": "latch is a way to allow for the test to synchronize between a thread that performs the file modification during startup to be constructed and execution of node restart to continue.\nwrittenLatch provides a way for the test itself to wait until the file has been written; technically it is not necessary but avoids us trying to execute the checks on cluster size and connections until we know that connections are actually expected to succeed.\nA phaser could be used here but we know upfront the number of registrants and do not need to be used repeatedly for waiting, so latches suffice for this test.\nI'm happy to elaborate more if necessary.", "author": "jaymode", "createdAt": "2020-04-15T15:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxODIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5MzI1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/54999#discussion_r409093252", "bodyText": "I also added comments in the test 2db3a9a", "author": "jaymode", "createdAt": "2020-04-15T19:49:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxODIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwOTk4MA==", "url": "https://github.com/elastic/elasticsearch/pull/54999#discussion_r409209980", "bodyText": "Thanks for the explanation. Maybe I didn't ask the right question. I understand what the 2 latch trying to do. I just wasn't sure whether they are necessary. Since the original failure is a rare race condition which is hard to re-produce. So would it be better if we just let the threads run without any synchronisation for a possibly more real simulation?", "author": "ywangd", "createdAt": "2020-04-16T00:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxODIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI0MTk3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/54999#discussion_r409241976", "bodyText": "I think the synchronization helps get closer to the possibility of that rare condition by ensuring one thread doesn't just jump ahead which would mean that the two actions do not happen concurrently.", "author": "jaymode", "createdAt": "2020-04-16T02:21:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxODIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgyMjA0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/54999#discussion_r407822049", "bodyText": "Can we encapsulate this logic inside SSLConfigurationReloader like how it was before? I personally prefer to have SSLConfigurationReloader hide the complexitiy as much as possible. How about have APIs like the follows:\n\nsslConfigurationReloader = new SSLConfigurationReloader(...) to prepare everything and also create the Future object internally. So everything is ready just waiting for the future to be completed.\nsslConfigurationReloader.startWatching(sslService) to resolve the future internally. Effectively this method is just oneline of sslServiceFuture.complete(sslService)", "author": "ywangd", "createdAt": "2020-04-14T02:03:55Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/XPackPlugin.java", "diffHunk": "@@ -233,10 +238,23 @@ public Settings additionalSettings() {\n                                                IndexNameExpressionResolver expressionResolver) {\n         List<Object> components = new ArrayList<>();\n \n-        final SSLService sslService = new SSLService(environment);\n+        final Map<String, SSLConfiguration> sslConfigurations = SSLService.getSSLConfigurations(environment.settings());\n+        final CompletableFuture<SSLService> sslServiceFuture = new CompletableFuture<>();\n+        final Consumer<SSLConfiguration> reloadConsumer = sslConfiguration -> {\n+            try {\n+                final SSLService sslService = sslServiceFuture.get();\n+                logger.debug(\"reloading ssl configuration [{}]\", sslConfiguration);\n+                sslService.reloadSSLContext(sslConfiguration);\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+            } catch (ExecutionException e) {\n+                throw new ElasticsearchException(\"failed to obtain ssl service\", e);\n+            }\n+        };", "originalCommit": "60788f10dd3cb14e7d1a904174ed57c444ba2113", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5MzAwMA==", "url": "https://github.com/elastic/elasticsearch/pull/54999#discussion_r409093000", "bodyText": "I'd rather not put this logic in SSLConfigurationReloader for a few reasons.\n\nThe need for a future is tied directly to the order of initialization and that should not be something that the configuration reloader needs to be concerned with.\nWe avoid creating an object to keep around for the lifetime of the node by leaving this initialization logic out of the SSLConfigurationReloader class\nThe SSLConfigurationReloader and SSLService are not directly tied together; our reload change listeners just need to know that some consumer needs to be called if a file changes\n\nMy alternative is to \"hide\" the start of reloading and the glue between the two in a private method to create the SSLService, which I've done in 6830389", "author": "jaymode", "createdAt": "2020-04-15T19:48:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgyMjA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIxNzM1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/54999#discussion_r409217352", "bodyText": "I personally still think the separation between the reloadConsumer setup and the reloader itself is unnecessary.\nIt has value in theory and also the point of \"one less object to keep around\" is good. But in the current form (both before and after this PR), SSLConfigurationReloader is specific about SSLService. It does one specific thing which is to ensure a call to sslService.reloadSSLContext(...) on file changes. It can be generalised by keep differnt parts in separate classes. But in fact we don't have a 2nd use case for it. So this decomposition feels unnecessary to me.\nIn my opinion, having these logics encapsulated by SSLConfigurationReloader makes the code easier to understand and clean to use. The fact that \"a Reloader should guarantee an update is always picked up\" sounds like internal implementation details to me, regardless whether it uses a Future or something else to achieve it. So I'd personally leave that to the Reloader class itself.", "author": "ywangd", "createdAt": "2020-04-16T00:52:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgyMjA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI0MjI2OA==", "url": "https://github.com/elastic/elasticsearch/pull/54999#discussion_r409242268", "bodyText": "I've gone ahead with a version that moves this back into the reloader.", "author": "jaymode", "createdAt": "2020-04-16T02:23:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgyMjA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI1NjIwOA==", "url": "https://github.com/elastic/elasticsearch/pull/54999#discussion_r409256208", "bodyText": "Thanks @jaymode I appreciate the open discussion.", "author": "ywangd", "createdAt": "2020-04-16T03:15:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgyMjA0OQ=="}], "type": "inlineReview"}, {"oid": "25a1c9c3ff43d5a853925e3ff9932733ba6e34b6", "url": "https://github.com/elastic/elasticsearch/commit/25a1c9c3ff43d5a853925e3ff9932733ba6e34b6", "message": "Merge branch 'master' into refactor_ssl_reloader", "committedDate": "2020-04-15T17:31:43Z", "type": "commit"}, {"oid": "6830389674428336d0ef21883d1e4b04c3e0c1e3", "url": "https://github.com/elastic/elasticsearch/commit/6830389674428336d0ef21883d1e4b04c3e0c1e3", "message": "move to private method", "committedDate": "2020-04-15T19:43:23Z", "type": "commit"}, {"oid": "2db3a9a6b724bdf6adf01972a9be8e2504a74698", "url": "https://github.com/elastic/elasticsearch/commit/2db3a9a6b724bdf6adf01972a9be8e2504a74698", "message": "add comments", "committedDate": "2020-04-15T19:47:47Z", "type": "commit"}, {"oid": "16196ed51005ed1edb3feb2903e4a7d1207f38c9", "url": "https://github.com/elastic/elasticsearch/commit/16196ed51005ed1edb3feb2903e4a7d1207f38c9", "message": "Merge branch 'master' into refactor_ssl_reloader", "committedDate": "2020-04-16T01:44:47Z", "type": "commit"}, {"oid": "8f48415bbe4ad8e8dd3db1a4561a783b3a5533b0", "url": "https://github.com/elastic/elasticsearch/commit/8f48415bbe4ad8e8dd3db1a4561a783b3a5533b0", "message": "refactor", "committedDate": "2020-04-16T02:17:26Z", "type": "commit"}]}