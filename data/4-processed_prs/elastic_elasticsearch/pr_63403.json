{"pr_number": 63403, "pr_title": "Consider query when optimizing date rounding", "pr_createdAt": "2020-10-07T13:50:05Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/63403", "timeline": [{"oid": "e4c4f68e7f933f67d7ba0f6d15c56fd74c3e4f6b", "url": "https://github.com/elastic/elasticsearch/commit/e4c4f68e7f933f67d7ba0f6d15c56fd74c3e4f6b", "message": "Consider query when optimizing date rounding\n\nBefore this change we inspected the index when optimizing\n`date_histogram` aggregations, precalculating the divisions for the\nbuckets for the entire range of dates on the index so long as there\naren't a ton of these buckets. This works very well when you query all\nof the dates in the index which is quite common - after all, folks\nfrequently want to query a week of data and have daily indices.\n\nBut it doesn't work as well when the index is much larger than the\nquery. This is quite common when dumping data into ES just to\ninvestigate it but less common in the traditional time series use case.\nBut even there it still happens, it is just less impactful. Consider\nthe default query produced by Kibana's Discover app: a range of 15\nminutes and a interval of 30 seconds. This optimization saves something\nlike 3 to 12 nanoseconds per document, so that 15 minutes would have to\nhave hundreds of millions of documents for it to be impactful.\n\nAnyway, this commit takes the query into account when precalculating the\nbuckets. Mostly this is good when you have \"dirty data\". Immagine\nloading 80 billion docs in an index to investigate them. Most of them\nhave dates around 2015 and 2016 but some have dates in 1970 and\nothers have dates in 2030. These outlier dates are \"dirty\" \"garbage\".\nWell, without this change a `date_histogram` across many of these docs\nis significantly slowed down because we don't precalculate the range due\nto the outliers. That's just rude! So this change takes the query into\naccount.\n\nThe bulk of the code change here is plumbing the query into place. It\nturns out that its a *ton* of plumbing, so instead of just adding a\n`Query` member in hundreds of args replace `QueryShardContext` with a\nnew `AggregationContext` which does two things:\n1. Has the top level `Query`.\n2. Exposes just the parts of `QueryShardContext` that we actually need\n   to run aggregation. This lets us simplify a few tests now and will\n   let us simplify many, many tests later.", "committedDate": "2020-10-07T13:21:56Z", "type": "commit"}, {"oid": "3c6953c26c379e745108a047c82699577b546968", "url": "https://github.com/elastic/elasticsearch/commit/3c6953c26c379e745108a047c82699577b546968", "message": "Merge branch 'master' into limit_rounding_to_query", "committedDate": "2020-10-07T14:39:14Z", "type": "commit"}, {"oid": "b25aae8b3b9442d37dc454d198eb06d979339161", "url": "https://github.com/elastic/elasticsearch/commit/b25aae8b3b9442d37dc454d198eb06d979339161", "message": "Update after merge", "committedDate": "2020-10-07T14:48:34Z", "type": "commit"}, {"oid": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "url": "https://github.com/elastic/elasticsearch/commit/788846f2af146b56b32fc3b0a97ab854805ca7ea", "message": "Ooops", "committedDate": "2020-10-07T16:17:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwMzM3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501203379", "bodyText": "I simplified this when I bumped into it working on solving this issue. It's not strictly related, but some changes were indeed required to be compatible with the rest of the changes. The key simplification is that we don't stand up a whole node any more - just set up the mapper parsing infrastructure and some lucene indices.", "author": "nik9000", "createdAt": "2020-10-07T17:55:29Z", "path": "modules/parent-join/src/test/java/org/elasticsearch/join/mapper/ParentJoinFieldMapperTests.java", "diffHunk": "@@ -19,186 +19,122 @@\n \n package org.elasticsearch.join.mapper;\n \n-import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.bytes.BytesReference;\n-import org.elasticsearch.common.compress.CompressedXContent;\n import org.elasticsearch.common.xcontent.XContentFactory;\n import org.elasticsearch.common.xcontent.XContentType;\n-import org.elasticsearch.index.IndexService;\n import org.elasticsearch.index.mapper.DocumentMapper;\n import org.elasticsearch.index.mapper.MapperException;\n import org.elasticsearch.index.mapper.MapperParsingException;\n import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.index.mapper.MapperServiceTestCase;\n import org.elasticsearch.index.mapper.ParsedDocument;\n import org.elasticsearch.index.mapper.SourceToParse;\n import org.elasticsearch.join.ParentJoinPlugin;\n import org.elasticsearch.plugins.Plugin;\n-import org.elasticsearch.test.ESSingleNodeTestCase;\n \n import java.util.Collection;\n-import java.util.Collections;\n \n+import static java.util.Collections.singleton;\n import static org.hamcrest.Matchers.containsString;\n \n-public class ParentJoinFieldMapperTests extends ESSingleNodeTestCase {", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwMzc3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501203773", "bodyText": "We don't need this at all any more - the caller now gets it form the ValuesSourceRegistry.", "author": "nik9000", "createdAt": "2020-10-07T17:56:05Z", "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -512,8 +511,4 @@ public SimilarityService getSimilarityService() {\n     public BitsetFilterCache getBitsetFilterCache() {\n         return bitsetFilterCache;\n     }\n-\n-    public AggregationUsageService getUsageService() {\n-        return valuesSourceRegistry.getUsageService();\n-    }", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwNDA2NA==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501204064", "bodyText": "This is the start of the actual plumbing.", "author": "nik9000", "createdAt": "2020-10-07T17:56:31Z", "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -933,8 +934,12 @@ private void parseSource(DefaultSearchContext context, SearchSourceBuilder sourc\n         }\n         context.terminateAfter(source.terminateAfter());\n         if (source.aggregations() != null && includeAggregations) {\n+            AggregationContext aggContext = AggregationContext.from(\n+                queryShardContext,\n+                context.parsedQuery() == null ? null : context.parsedQuery().query()\n+            );\n             try {\n-                AggregatorFactories factories = source.aggregations().build(queryShardContext, null);", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwNDY4NA==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501204684", "bodyText": "There was a TODO around moving this to the ctor which I bumped into while I was fixing the calls next to it.", "author": "nik9000", "createdAt": "2020-10-07T17:57:30Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/AutoDateHistogramAggregator.java", "diffHunk": "@@ -70,7 +69,6 @@ static AutoDateHistogramAggregator build(\n         AggregatorFactories factories,\n         int targetBuckets,\n         RoundingInfo[] roundingInfos,\n-        Function<Rounding, Rounding.Prepared> roundingPreparer,", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwNTA1MA==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501205050", "bodyText": "I switched the parsing so we don't need to pass the whole query shard context in, now it is easier to test too!", "author": "nik9000", "createdAt": "2020-10-07T17:58:04Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramAggregationBuilder.java", "diffHunk": "@@ -441,14 +441,14 @@ protected ValuesSourceAggregatorFactory innerBuild(QueryShardContext queryShardC\n         LongBounds roundedBounds = null;\n         if (this.extendedBounds != null) {\n             // parse any string bounds to longs and round\n-            roundedBounds = this.extendedBounds.parseAndValidate(name, \"extended_bounds\" , queryShardContext, config.format())\n+            roundedBounds = this.extendedBounds.parseAndValidate(name, \"extended_bounds\" , context::nowInMillis, config.format())", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwODI3MA==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501208270", "bodyText": "This means that runtime fields can't do it. It makes me think that we're doing something wrong, but I think that is something to solve in a follow up.", "author": "nik9000", "createdAt": "2020-10-07T18:03:30Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/CoreValuesSourceType.java", "diffHunk": "@@ -240,28 +244,21 @@ public ValuesSource getScript(AggregationScript.LeafFactory script, ValueType sc\n         }\n \n         @Override\n-        public ValuesSource getField(FieldContext fieldContext, AggregationScript.LeafFactory script) {\n-            ValuesSource.Numeric dataSource = fieldData(fieldContext);\n+        public ValuesSource getField(FieldContext fieldContext, AggregationScript.LeafFactory script, AggregationContext context) {\n+            ValuesSource.Numeric dataSource = fieldData(fieldContext, context);\n             if (script != null) {\n                 // Value script case\n                 return new ValuesSource.Numeric.WithScript(dataSource, script);\n             }\n             return dataSource;\n         }\n \n-        private ValuesSource.Numeric fieldData(FieldContext fieldContext) {\n+        private ValuesSource.Numeric fieldData(FieldContext fieldContext, AggregationContext context) {\n             if ((fieldContext.indexFieldData() instanceof IndexNumericFieldData) == false) {\n                 throw new IllegalArgumentException(\"Expected numeric type on field [\" + fieldContext.field() +\n                     \"], but got [\" + fieldContext.fieldType().typeName() + \"]\");\n             }\n-            if (fieldContext.fieldType().isSearchable() == false\n-                    || fieldContext.fieldType() instanceof DateFieldType == false) {\n-                /*\n-                 * We can't implement roundingPreparer in these cases because\n-                 * we can't look up the min and max date without both the\n-                 * search index (the first test) and the resolution which is\n-                 * on the DateFieldType.\n-                 */\n+            if (fieldContext.fieldType() instanceof DateFieldType == false) {", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg3NTgwMw==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501875803", "bodyText": "Agreed.  The instanceof check definitely smells wrong here, but I don't know what the right answer is.", "author": "not-napoleon", "createdAt": "2020-10-08T17:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwODI3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxMDk1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501210956", "bodyText": "This one was so short I thought I could clean up lots of these ESSingleNodeTestCases in this PR. It turns out that no, no, I can't.", "author": "nik9000", "createdAt": "2020-10-07T18:08:03Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/AggregatorBaseTests.java", "diffHunk": "@@ -25,32 +25,30 @@\n import org.apache.lucene.search.MatchAllDocsQuery;\n import org.apache.lucene.search.Query;\n import org.apache.lucene.search.TermQuery;\n-import org.elasticsearch.action.support.WriteRequest;\n import org.elasticsearch.common.breaker.CircuitBreaker;\n-import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.util.BigArrays;\n-import org.elasticsearch.index.IndexService;\n-import org.elasticsearch.index.engine.Engine;\n import org.elasticsearch.index.mapper.DateFieldMapper;\n import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.index.mapper.MapperServiceTestCase;\n import org.elasticsearch.index.mapper.NumberFieldMapper;\n-import org.elasticsearch.index.query.QueryShardContext;\n import org.elasticsearch.indices.breaker.CircuitBreakerService;\n+import org.elasticsearch.search.aggregations.support.AggregationContext;\n import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;\n import org.elasticsearch.search.internal.SearchContext;\n-import org.elasticsearch.test.ESSingleNodeTestCase;\n \n import java.io.IOException;\n import java.time.Instant;\n import java.util.Collections;\n+import java.util.List;\n import java.util.Map;\n import java.util.function.Function;\n \n import static org.hamcrest.Matchers.equalTo;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n-public class AggregatorBaseTests extends ESSingleNodeTestCase {", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxMTg0NA==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501211844", "bodyText": "No more entire node!", "author": "nik9000", "createdAt": "2020-10-07T18:09:38Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/support/ValuesSourceConfigTests.java", "diffHunk": "@@ -22,278 +22,198 @@\n import org.apache.lucene.index.LeafReaderContext;\n import org.apache.lucene.index.SortedNumericDocValues;\n import org.apache.lucene.util.BytesRef;\n-import org.elasticsearch.action.support.WriteRequest;\n-import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.index.IndexService;\n-import org.elasticsearch.index.engine.Engine;\n import org.elasticsearch.index.fielddata.SortedBinaryDocValues;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.index.mapper.MapperServiceTestCase;\n import org.elasticsearch.index.mapper.TypeFieldType;\n-import org.elasticsearch.index.query.QueryShardContext;\n-import org.elasticsearch.test.ESSingleNodeTestCase;\n \n-// TODO: This whole set of tests needs to be rethought.\n-public class ValuesSourceConfigTests extends ESSingleNodeTestCase {\n+import java.io.IOException;\n+import java.util.List;\n \n+// TODO: This whole set of tests needs to be rethought.\n+public class ValuesSourceConfigTests extends MapperServiceTestCase {", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxMjI1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501212251", "bodyText": "parent/child tests wanted this one.", "author": "nik9000", "createdAt": "2020-10-07T18:10:15Z", "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/MapperServiceTestCase.java", "diffHunk": "@@ -163,10 +187,15 @@ protected final void withLuceneIndex(\n     }\n \n     protected final SourceToParse source(CheckedConsumer<XContentBuilder, IOException> build) throws IOException {\n+        return source(\"1\", build, null);\n+    }\n+\n+    protected final SourceToParse source(String id, CheckedConsumer<XContentBuilder, IOException> build, @Nullable String routing)", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxMjUzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501212539", "bodyText": "I decided not to go with mockito here partially because I wanted to suffer every time I added a new method to AggreationContext.", "author": "nik9000", "createdAt": "2020-10-07T18:10:48Z", "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/MapperServiceTestCase.java", "diffHunk": "@@ -222,7 +251,111 @@ protected final XContentBuilder fieldMapping(CheckedConsumer<XContentBuilder, IO\n         });\n     }\n \n-    QueryShardContext createQueryShardContext(MapperService mapperService) {\n+    private AggregationContext aggregationContext(MapperService mapperService, IndexSearcher searcher, Query query) {", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkwMTI5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501901296", "bodyText": "I can't tell if you're joking or not.", "author": "not-napoleon", "createdAt": "2020-10-08T17:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxMjUzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMzMzUwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r503333501", "bodyText": "I'm really not. Suffering makes you think \"should I really add this method? this class is already big. maybe there is a cleaner way.\"", "author": "nik9000", "createdAt": "2020-10-12T14:27:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxMjUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MTAyOA==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501271028", "bodyText": "Nit: It's no longer clear what service refers to in this javadoc", "author": "not-napoleon", "createdAt": "2020-10-07T19:53:20Z", "path": "modules/parent-join/src/main/java/org/elasticsearch/join/mapper/ParentJoinFieldMapper.java", "diffHunk": "@@ -84,16 +84,24 @@\n      * Returns the {@link ParentJoinFieldMapper} associated with the <code>service</code> or null", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3NTMxNw==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501275317", "bodyText": "Nit: I think it'd be cleaner to put a getUsageService() call on AggregationContext, even if that just delegates it to the values source registry.", "author": "not-napoleon", "createdAt": "2020-10-07T20:01:25Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/AbstractAggregationBuilder.java", "diffHunk": "@@ -135,13 +135,13 @@ public final String getWriteableName() {\n     }\n \n     @Override\n-    public final AggregatorFactory build(QueryShardContext queryShardContext, AggregatorFactory parent) throws IOException {\n-        AggregatorFactory factory = doBuild(queryShardContext, parent, factoriesBuilder);\n-        queryShardContext.getUsageService().incAggregationUsage(getType(), factory.getStatsSubtype());\n+    public final AggregatorFactory build(AggregationContext context, AggregatorFactory parent) throws IOException {\n+        AggregatorFactory factory = doBuild(context, parent, factoriesBuilder);\n+        context.getValuesSourceRegistry().getUsageService().incAggregationUsage(getType(), factory.getStatsSubtype());", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3Nzk5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501277995", "bodyText": "this (already unhelpful) bit of javadoc isn't even remotely accurate now.", "author": "not-napoleon", "createdAt": "2020-10-07T20:06:36Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/composite/CompositeValuesSourceBuilder.java", "diffHunk": "@@ -265,18 +266,18 @@ public String format() {\n \n     /**\n      * Creates a {@link CompositeValuesSourceConfig} for this source.\n-     *  @param queryShardContext   The shard context for this source.\n-     * @param config    The {@link ValuesSourceConfig} for this source.\n+     * @param context  The shard context for this source.", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3ODMzMg==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501278332", "bodyText": "Nit: context is an unexpected name for a ValuesSourceRegistry instance.  Maybe registry instead?", "author": "not-napoleon", "createdAt": "2020-10-07T20:07:18Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/composite/CompositeValuesSourceBuilder.java", "diffHunk": "@@ -265,18 +266,18 @@ public String format() {\n \n     /**\n      * Creates a {@link CompositeValuesSourceConfig} for this source.\n-     *  @param queryShardContext   The shard context for this source.\n-     * @param config    The {@link ValuesSourceConfig} for this source.\n+     * @param context  The shard context for this source.\n+     * @param config   The {@link ValuesSourceConfig} for this source.\n      */\n-    protected abstract CompositeValuesSourceConfig innerBuild(QueryShardContext queryShardContext,\n+    protected abstract CompositeValuesSourceConfig innerBuild(ValuesSourceRegistry context,", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMyNzExNA==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r503327114", "bodyText": "What I get for copy and pasting too fast.", "author": "nik9000", "createdAt": "2020-10-12T14:17:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3ODMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI4NTQ5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501285492", "bodyText": "There's a few places where we get the values source just to get the rounding preparer off of it.  I wonder if we should just expose getRoundingPreparer on ValuesSourceConfig?", "author": "not-napoleon", "createdAt": "2020-10-07T20:20:31Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramAggregator.java", "diffHunk": "@@ -87,7 +86,7 @@\n \n         super(name, factories, aggregationContext, parent, CardinalityUpperBound.MANY, metadata);\n         this.rounding = rounding;\n-        this.preparedRounding = preparedRounding;\n+        this.preparedRounding = valuesSourceConfig.getValuesSource().roundingPreparer().apply(rounding);", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMzMTI5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r503331293", "bodyText": "I can do that!", "author": "nik9000", "createdAt": "2020-10-12T14:23:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI4NTQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI4ODIwOA==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501288208", "bodyText": "We don't need this TODO anymore?", "author": "not-napoleon", "createdAt": "2020-10-07T20:25:45Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramAggregatorFactory.java", "diffHunk": "@@ -88,17 +88,13 @@ protected Aggregator doCreateInternal(\n         CardinalityUpperBound cardinality,\n         Map<String, Object> metadata\n     ) throws IOException {\n-        DateHistogramAggregationSupplier aggregatorSupplier = queryShardContext.getValuesSourceRegistry()\n+        DateHistogramAggregationSupplier aggregatorSupplier = context.getValuesSourceRegistry()\n             .getAggregator(DateHistogramAggregationBuilder.REGISTRY_KEY, config);\n         // TODO: Is there a reason not to get the prepared rounding in the supplier itself?", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg0NDczNA==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501844734", "bodyText": "Nit: formatting", "author": "not-napoleon", "createdAt": "2020-10-08T16:14:40Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/PercentilesAggregationBuilder.java", "diffHunk": "@@ -128,12 +128,12 @@ public PercentilesAggregationBuilder percentiles(double... percents) {\n     }\n \n     @Override\n-    protected ValuesSourceAggregatorFactory innerBuild(QueryShardContext queryShardContext,\n+    protected ValuesSourceAggregatorFactory innerBuild(AggregationContext context,", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg1MTk1MA==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501851950", "bodyText": "I like this.  It annoys me when we pass in both an object and something derived from that object like the old version had.", "author": "not-napoleon", "createdAt": "2020-10-08T16:25:33Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/ScriptedMetricAggregationBuilder.java", "diffHunk": "@@ -229,25 +229,25 @@ protected ScriptedMetricAggregatorFactory doBuild(QueryShardContext queryShardCo\n         ScriptedMetricAggContexts.InitScript.Factory compiledInitScript;\n         Map<String, Object> initScriptParams;\n         if (initScript != null) {\n-            compiledInitScript = queryShardContext.compile(initScript, ScriptedMetricAggContexts.InitScript.CONTEXT);\n+            compiledInitScript = context.compile(initScript, ScriptedMetricAggContexts.InitScript.CONTEXT);\n             initScriptParams = initScript.getParams();\n         } else {\n             compiledInitScript = null;\n             initScriptParams = Collections.emptyMap();\n         }\n \n-        ScriptedMetricAggContexts.MapScript.Factory compiledMapScript = queryShardContext.compile(mapScript,\n+        ScriptedMetricAggContexts.MapScript.Factory compiledMapScript = context.compile(mapScript,\n             ScriptedMetricAggContexts.MapScript.CONTEXT);\n         Map<String, Object> mapScriptParams = mapScript.getParams();\n \n \n-        ScriptedMetricAggContexts.CombineScript.Factory compiledCombineScript = queryShardContext.compile(combineScript,\n+        ScriptedMetricAggContexts.CombineScript.Factory compiledCombineScript = context.compile(combineScript,\n             ScriptedMetricAggContexts.CombineScript.CONTEXT);\n         Map<String, Object> combineScriptParams = combineScript.getParams();\n \n         return new ScriptedMetricAggregatorFactory(name, compiledMapScript, mapScriptParams, compiledInitScript,\n                 initScriptParams, compiledCombineScript, combineScriptParams, reduceScript,\n-                params, queryShardContext.lookup(), queryShardContext, parent, subfactoriesBuilder, metadata);\n+                params, context, parent, subfactoriesBuilder, metadata);", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg2MjI2MA==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501862260", "bodyText": "We should have some class level javadoc for this.", "author": "not-napoleon", "createdAt": "2020-10-08T16:42:12Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/AggregationContext.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.support;\n+\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.ObjectMapper;\n+import org.elasticsearch.index.query.QueryBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.support.NestedScope;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptContext;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+import org.elasticsearch.search.sort.SortAndFormats;\n+import org.elasticsearch.search.sort.SortBuilder;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public abstract class AggregationContext {", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg3MjQ4MA==", "url": "https://github.com/elastic/elasticsearch/pull/63403#discussion_r501872480", "bodyText": "What are we gaining by making AggregationConetxt abstract and building it via this anonymous closure thing?  Seems to me, we could just store a reference to a QueryShardContext in a concrete class and serve these same methods up directly.  I think that would be more readable, but maybe there's another consideration I haven't thought of?", "author": "not-napoleon", "createdAt": "2020-10-08T16:58:46Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/AggregationContext.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.support;\n+\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.ObjectMapper;\n+import org.elasticsearch.index.query.QueryBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.support.NestedScope;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptContext;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+import org.elasticsearch.search.sort.SortAndFormats;\n+import org.elasticsearch.search.sort.SortBuilder;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public abstract class AggregationContext {\n+    /**\n+     * The query at the top level of the search in which these aggregations are running.\n+     */\n+    public abstract Query query();\n+\n+    /**\n+     * The time in milliseconds that is shared across all resources involved. Even across shards and nodes.\n+     */\n+    public abstract long nowInMillis();\n+\n+    /**\n+     * Lookup the context for a field.\n+     */\n+    public final FieldContext buildFieldContext(String field) {\n+        MappedFieldType ft = getFieldType(field);\n+        if (ft == null) {\n+            // The field is unmapped\n+            return null;\n+        }\n+        return new FieldContext(field, buildFieldData(ft), ft);\n+    }\n+\n+    /**\n+     * Lookup the context for an already resolved field type.\n+     */\n+    public final FieldContext buildFieldContext(MappedFieldType ft) {\n+        return new FieldContext(ft.name(), buildFieldData(ft), ft);\n+    }\n+\n+    /**\n+     * Build field data.\n+     */\n+    protected abstract IndexFieldData<?> buildFieldData(MappedFieldType ft);\n+\n+    /**\n+     * Lookup a {@link MappedFieldType} by path.\n+     */\n+    public abstract MappedFieldType getFieldType(String path);\n+\n+    /**\n+     * Lookup a field {@link Mapper} by path.\n+     */\n+    public abstract Mapper getMapper(String path);\n+\n+    /**\n+     * Compile a script.\n+     */\n+    public abstract <FactoryType> FactoryType compile(Script script, ScriptContext<FactoryType> context);\n+\n+    /**\n+     * Fetch the shared {@link SearchLookup}.\n+     */\n+    public abstract SearchLookup lookup();\n+\n+    /**\n+     * The {@link ValuesSourceRegistry} to resolve {@link Aggregator}s and the like.\n+     */\n+    public abstract ValuesSourceRegistry getValuesSourceRegistry();\n+\n+    /**\n+     * Utility to share and track large arrays.\n+     */\n+    public abstract BigArrays bigArrays();\n+\n+    /**\n+     * The searcher that will execute this query.\n+     */\n+    public abstract IndexSearcher searcher();\n+\n+    /**\n+     * Build a query.\n+     */\n+    public abstract Query buildQuery(QueryBuilder builder) throws IOException;\n+\n+    /**\n+     * The settings for the index against which this search is running.\n+     */\n+    public abstract IndexSettings getIndexSettings();\n+\n+    /**\n+     * Compile a sort.\n+     */\n+    public abstract Optional<SortAndFormats> buildSort(List<SortBuilder<?>> sortBuilders) throws IOException;\n+\n+    /**\n+     * Find an {@link ObjectMapper}.\n+     */\n+    public abstract ObjectMapper getObjectMapper(String path);\n+\n+    /**\n+     * Access the nested scope. Stay away from this unless you are dealing with nested.\n+     */\n+    public abstract NestedScope nestedScope();\n+\n+    /**\n+     * Build a {@link AggregationContext} wrapping a {@link SearchContext} and the\n+     * top level {@link Query}.\n+     */\n+    public static AggregationContext from(QueryShardContext context, Query query) {\n+        return new AggregationContext() {", "originalCommit": "788846f2af146b56b32fc3b0a97ab854805ca7ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "569e0e7d5d2fc3e085e61baa88f57f11f6c82eb2", "url": "https://github.com/elastic/elasticsearch/commit/569e0e7d5d2fc3e085e61baa88f57f11f6c82eb2", "message": "Merge branch 'master' into limit_rounding_to_query", "committedDate": "2020-10-12T14:11:34Z", "type": "commit"}, {"oid": "3d7e63968fbeee5d9b5c76b4bbf672b9e5c158f3", "url": "https://github.com/elastic/elasticsearch/commit/3d7e63968fbeee5d9b5c76b4bbf672b9e5c158f3", "message": "Update javadoc", "committedDate": "2020-10-12T14:13:35Z", "type": "commit"}, {"oid": "04caaddecf505c111aa45ae56b51fdcfef9a4969", "url": "https://github.com/elastic/elasticsearch/commit/04caaddecf505c111aa45ae56b51fdcfef9a4969", "message": "Promote AggregationUsageService", "committedDate": "2020-10-12T14:16:34Z", "type": "commit"}, {"oid": "3316c9f99374b5e6836a3555398996bf9fc7726d", "url": "https://github.com/elastic/elasticsearch/commit/3316c9f99374b5e6836a3555398996bf9fc7726d", "message": "Iter", "committedDate": "2020-10-12T14:24:41Z", "type": "commit"}, {"oid": "4b3073bfaa9b949fb9e1a24dd73978c320630811", "url": "https://github.com/elastic/elasticsearch/commit/4b3073bfaa9b949fb9e1a24dd73978c320630811", "message": "Hit it with the formatter", "committedDate": "2020-10-12T14:25:17Z", "type": "commit"}, {"oid": "6d8cd95537cee60631cd72a5c2a7991db4477445", "url": "https://github.com/elastic/elasticsearch/commit/6d8cd95537cee60631cd72a5c2a7991db4477445", "message": "Iter", "committedDate": "2020-10-12T14:39:47Z", "type": "commit"}, {"oid": "18ac471a3634d83e921adcfb6e6e2e25728b72b9", "url": "https://github.com/elastic/elasticsearch/commit/18ac471a3634d83e921adcfb6e6e2e25728b72b9", "message": "Ooops", "committedDate": "2020-10-12T15:56:19Z", "type": "commit"}]}