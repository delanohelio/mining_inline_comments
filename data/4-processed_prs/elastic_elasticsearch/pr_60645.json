{"pr_number": 60645, "pr_title": "Convert KeywordFieldMapper to parametrized form", "pr_createdAt": "2020-08-04T11:12:11Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/60645", "timeline": [{"oid": "ed8f8baf697e8bfa8df3f5cdc5d7b21c32c0f3bb", "url": "https://github.com/elastic/elasticsearch/commit/ed8f8baf697e8bfa8df3f5cdc5d7b21c32c0f3bb", "message": "Convert KeywordFieldMapper to parametrized form", "committedDate": "2020-08-04T10:37:44Z", "type": "commit"}, {"oid": "f929d922a0f9e38863ebed771fb7349226b01957", "url": "https://github.com/elastic/elasticsearch/commit/f929d922a0f9e38863ebed771fb7349226b01957", "message": "Include boost param", "committedDate": "2020-08-04T11:09:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk3NTE1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r464975152", "bodyText": "This yields better error messages for dynamic mappings, including the name of the dynamic mapping itself and the type of the dynamically created field.", "author": "romseygeek", "createdAt": "2020-08-04T11:13:10Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/RootObjectMapper.java", "diffHunk": "@@ -388,10 +388,11 @@ private static void validateDynamicTemplate(Mapper.TypeParser.ParserContext pars\n                 continue;\n             }\n \n-            Map<String, Object> fieldTypeConfig = dynamicTemplate.mappingForName(\"__dummy__\", defaultDynamicType);\n-            fieldTypeConfig.remove(\"type\");\n+            String templateName = \"__dynamic__\" + dynamicTemplate.name();\n+            Map<String, Object> fieldTypeConfig = dynamicTemplate.mappingForName(templateName, defaultDynamicType);", "originalCommit": "f929d922a0f9e38863ebed771fb7349226b01957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk3NjcxMw==", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r464976713", "bodyText": "KeywordFieldMapper.Builder doesn't match the signature of parseField anymore (because we don't actually use it in parsing), so I've adjusted these to directly test the parseMeta method.", "author": "romseygeek", "createdAt": "2020-08-04T11:16:28Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/TypeParsersTests.java", "diffHunk": "@@ -232,55 +235,49 @@ public TokenStream create(TokenStream tokenStream) {\n     }\n \n     public void testParseMeta() {\n-        FieldMapper.Builder<?> builder = new KeywordFieldMapper.Builder(\"foo\");\n-        Mapper.TypeParser.ParserContext parserContext = new Mapper.TypeParser.ParserContext(null, null, null, null, null, null);\n-\n         {\n-            Map<String, Object> mapping = new HashMap<>(Map.of(\"meta\", 3));\n             MapperParsingException e = expectThrows(MapperParsingException.class,\n-                    () -> TypeParsers.parseField(builder, builder.name, mapping, parserContext));", "originalCommit": "f929d922a0f9e38863ebed771fb7349226b01957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a5085da116ef8703e510c915b89eccb93948656a", "url": "https://github.com/elastic/elasticsearch/commit/a5085da116ef8703e510c915b89eccb93948656a", "message": "Add back boost test", "committedDate": "2020-08-04T11:16:57Z", "type": "commit"}, {"oid": "76116517d0927dcb01d3d8cccc765614c4043b8f", "url": "https://github.com/elastic/elasticsearch/commit/76116517d0927dcb01d3d8cccc765614c4043b8f", "message": "Merge remote-tracking branch 'origin/master' into mapper/keywordfieldmapper", "committedDate": "2020-08-04T12:35:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1MDYwMw==", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r468550603", "bodyText": "Are we using anywhere this method?", "author": "mayya-sharipova", "createdAt": "2020-08-11T12:44:20Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "diffHunk": "@@ -92,149 +83,134 @@ public KeywordField(String field, BytesRef term) {\n \n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n+    private static KeywordFieldMapper toType(FieldMapper in) {\n+        return (KeywordFieldMapper) in;\n+    }\n \n-        protected String nullValue = Defaults.NULL_VALUE;\n-        protected int ignoreAbove = Defaults.IGNORE_ABOVE;\n-        private IndexAnalyzers indexAnalyzers;\n-        private String normalizerName = \"default\";\n-        private boolean eagerGlobalOrdinals = Defaults.EAGER_GLOBAL_ORDINALS;\n-        private boolean splitQueriesOnWhitespace = Defaults.SPLIT_QUERIES_ON_WHITESPACE;\n-        private SimilarityProvider similarity;\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n \n-        public Builder(String name) {\n-            super(name, Defaults.FIELD_TYPE);\n-            builder = this;\n-        }\n+        private final Parameter<Boolean> indexed = Parameter.indexParam(m -> toType(m).indexed, true);\n+        private final Parameter<Boolean> hasDocValues = Parameter.docValuesParam(m -> toType(m).hasDocValues, true);\n+        private final Parameter<Boolean> stored = Parameter.storeParam(m -> toType(m).fieldType.stored(), false);\n \n-        @Override\n-        public Builder omitNorms(boolean omitNorms) {\n-            fieldType.setOmitNorms(omitNorms);\n-            return builder;\n+        private final Parameter<String> nullValue = Parameter.stringParam(\"null_value\", false, m -> toType(m).nullValue, null);\n+\n+        private final Parameter<Boolean> eagerGlobalOrdinals\n+            = Parameter.boolParam(\"eager_global_ordinals\", true, m -> toType(m).eagerGlobalOrdinals, false);\n+        private final Parameter<Integer> ignoreAbove\n+            = Parameter.intParam(\"ignore_above\", true, m -> toType(m).ignoreAbove, Integer.MAX_VALUE);\n+\n+        private final Parameter<String> indexOptions\n+            = Parameter.restrictedStringParam(\"index_options\", false, m -> toType(m).indexOptions, \"docs\", \"freqs\");\n+        private final Parameter<Boolean> hasNorms\n+            = Parameter.boolParam(\"norms\", false, m -> toType(m).fieldType.omitNorms() == false, false);\n+        private final Parameter<SimilarityProvider> similarity = new Parameter<>(\"similarity\", false, () -> null,\n+            (n, c, o) -> TypeParsers.resolveSimilarity(c, n, o.toString()), m -> toType(m).similarity);\n+\n+        private final Parameter<String> normalizer\n+            = Parameter.stringParam(\"normalizer\", false, m -> toType(m).normalizerName, \"default\");\n+\n+        private final Parameter<Boolean> splitQueriesOnWhitespace\n+            = Parameter.boolParam(\"split_queries_on_whitespace\", true, m -> toType(m).splitQueriesOnWhitespace, false);\n+\n+        private final Parameter<Map<String, String>> meta = Parameter.metaParam();\n+        private final Parameter<Float> boost = Parameter.boostParam();\n+\n+        private final IndexAnalyzers indexAnalyzers;\n+\n+        public Builder(String name, IndexAnalyzers indexAnalyzers) {\n+            super(name);\n+            this.indexAnalyzers = indexAnalyzers;\n         }\n \n-        public void similarity(SimilarityProvider similarity) {\n-            this.similarity = similarity;\n+        public Builder(String name) {\n+            this(name, null);\n         }\n \n         public Builder ignoreAbove(int ignoreAbove) {\n-            if (ignoreAbove < 0) {\n-                throw new IllegalArgumentException(\"[ignore_above] must be positive, got \" + ignoreAbove);\n-            }\n-            this.ignoreAbove = ignoreAbove;\n+            this.ignoreAbove.setValue(ignoreAbove);\n             return this;\n         }\n \n-        @Override\n-        public Builder indexOptions(IndexOptions indexOptions) {\n-            if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) > 0) {\n-                throw new IllegalArgumentException(\"The [keyword] field does not support positions, got [index_options]=\"\n-                        + indexOptionToString(indexOptions));\n-            }\n-            return super.indexOptions(indexOptions);\n+        Builder normalizer(String normalizerName) {", "originalCommit": "76116517d0927dcb01d3d8cccc765614c4043b8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4NzQzMA==", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r468587430", "bodyText": "This is used in tests", "author": "romseygeek", "createdAt": "2020-08-11T13:41:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1MDYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1MDY4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r468550685", "bodyText": "Are we using anywhere this method?", "author": "mayya-sharipova", "createdAt": "2020-08-11T12:44:28Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "diffHunk": "@@ -92,149 +83,134 @@ public KeywordField(String field, BytesRef term) {\n \n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n+    private static KeywordFieldMapper toType(FieldMapper in) {\n+        return (KeywordFieldMapper) in;\n+    }\n \n-        protected String nullValue = Defaults.NULL_VALUE;\n-        protected int ignoreAbove = Defaults.IGNORE_ABOVE;\n-        private IndexAnalyzers indexAnalyzers;\n-        private String normalizerName = \"default\";\n-        private boolean eagerGlobalOrdinals = Defaults.EAGER_GLOBAL_ORDINALS;\n-        private boolean splitQueriesOnWhitespace = Defaults.SPLIT_QUERIES_ON_WHITESPACE;\n-        private SimilarityProvider similarity;\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n \n-        public Builder(String name) {\n-            super(name, Defaults.FIELD_TYPE);\n-            builder = this;\n-        }\n+        private final Parameter<Boolean> indexed = Parameter.indexParam(m -> toType(m).indexed, true);\n+        private final Parameter<Boolean> hasDocValues = Parameter.docValuesParam(m -> toType(m).hasDocValues, true);\n+        private final Parameter<Boolean> stored = Parameter.storeParam(m -> toType(m).fieldType.stored(), false);\n \n-        @Override\n-        public Builder omitNorms(boolean omitNorms) {\n-            fieldType.setOmitNorms(omitNorms);\n-            return builder;\n+        private final Parameter<String> nullValue = Parameter.stringParam(\"null_value\", false, m -> toType(m).nullValue, null);\n+\n+        private final Parameter<Boolean> eagerGlobalOrdinals\n+            = Parameter.boolParam(\"eager_global_ordinals\", true, m -> toType(m).eagerGlobalOrdinals, false);\n+        private final Parameter<Integer> ignoreAbove\n+            = Parameter.intParam(\"ignore_above\", true, m -> toType(m).ignoreAbove, Integer.MAX_VALUE);\n+\n+        private final Parameter<String> indexOptions\n+            = Parameter.restrictedStringParam(\"index_options\", false, m -> toType(m).indexOptions, \"docs\", \"freqs\");\n+        private final Parameter<Boolean> hasNorms\n+            = Parameter.boolParam(\"norms\", false, m -> toType(m).fieldType.omitNorms() == false, false);\n+        private final Parameter<SimilarityProvider> similarity = new Parameter<>(\"similarity\", false, () -> null,\n+            (n, c, o) -> TypeParsers.resolveSimilarity(c, n, o.toString()), m -> toType(m).similarity);\n+\n+        private final Parameter<String> normalizer\n+            = Parameter.stringParam(\"normalizer\", false, m -> toType(m).normalizerName, \"default\");\n+\n+        private final Parameter<Boolean> splitQueriesOnWhitespace\n+            = Parameter.boolParam(\"split_queries_on_whitespace\", true, m -> toType(m).splitQueriesOnWhitespace, false);\n+\n+        private final Parameter<Map<String, String>> meta = Parameter.metaParam();\n+        private final Parameter<Float> boost = Parameter.boostParam();\n+\n+        private final IndexAnalyzers indexAnalyzers;\n+\n+        public Builder(String name, IndexAnalyzers indexAnalyzers) {\n+            super(name);\n+            this.indexAnalyzers = indexAnalyzers;\n         }\n \n-        public void similarity(SimilarityProvider similarity) {\n-            this.similarity = similarity;\n+        public Builder(String name) {\n+            this(name, null);\n         }\n \n         public Builder ignoreAbove(int ignoreAbove) {\n-            if (ignoreAbove < 0) {\n-                throw new IllegalArgumentException(\"[ignore_above] must be positive, got \" + ignoreAbove);\n-            }\n-            this.ignoreAbove = ignoreAbove;\n+            this.ignoreAbove.setValue(ignoreAbove);\n             return this;\n         }\n \n-        @Override\n-        public Builder indexOptions(IndexOptions indexOptions) {\n-            if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) > 0) {\n-                throw new IllegalArgumentException(\"The [keyword] field does not support positions, got [index_options]=\"\n-                        + indexOptionToString(indexOptions));\n-            }\n-            return super.indexOptions(indexOptions);\n+        Builder normalizer(String normalizerName) {\n+            this.normalizer.setValue(normalizerName);\n+            return this;\n         }\n \n-        public Builder eagerGlobalOrdinals(boolean eagerGlobalOrdinals) {\n-            this.eagerGlobalOrdinals = eagerGlobalOrdinals;\n-            return builder;\n+        Builder nullValue(String nullValue) {", "originalCommit": "76116517d0927dcb01d3d8cccc765614c4043b8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4NzU5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r468587595", "bodyText": "This was being used in tests, but possibly isn't... let me check", "author": "romseygeek", "createdAt": "2020-08-11T13:41:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1MDY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1NjY0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r468656643", "bodyText": "nullValue and normalizer are both used in KeywordFieldMapperTests", "author": "romseygeek", "createdAt": "2020-08-11T15:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1MDY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU2NzgzNg==", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r468567836", "bodyText": "Are we planning to use all these parameters later instead of accessing them through fieldType() as below:\ne.g.  =>\nfieldType().hasDocValues() => hasDocValues?\nDo we still need a fieldType here, if all values can be retrieved through builder?", "author": "mayya-sharipova", "createdAt": "2020-08-11T13:12:23Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "diffHunk": "@@ -314,18 +290,35 @@ protected BytesRef indexedValueForSearch(Object value) {\n         }\n     }\n \n-    private int ignoreAbove;\n-    private boolean splitQueriesOnWhitespace;\n-    private String nullValue;\n+    private final boolean indexed;\n+    private final boolean hasDocValues;\n+    private final String nullValue;\n+    private final boolean eagerGlobalOrdinals;\n+    private final int ignoreAbove;\n+    private final String indexOptions;\n+    private final FieldType fieldType;\n+    private final SimilarityProvider similarity;\n+    private final String normalizerName;\n+    private final boolean splitQueriesOnWhitespace;\n+\n+    private final IndexAnalyzers indexAnalyzers;\n \n     protected KeywordFieldMapper(String simpleName, FieldType fieldType, MappedFieldType mappedFieldType,\n-                                 int ignoreAbove, boolean splitQueriesOnWhitespace, String nullValue,\n-                                 MultiFields multiFields, CopyTo copyTo) {\n-        super(simpleName, fieldType, mappedFieldType, multiFields, copyTo);\n+                                 MultiFields multiFields, CopyTo copyTo, Builder builder) {\n+        super(simpleName, mappedFieldType, multiFields, copyTo);\n         assert fieldType.indexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) <= 0;\n-        this.ignoreAbove = ignoreAbove;\n-        this.splitQueriesOnWhitespace = splitQueriesOnWhitespace;\n-        this.nullValue = nullValue;\n+        this.indexed = builder.indexed.getValue();", "originalCommit": "76116517d0927dcb01d3d8cccc765614c4043b8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4ODcxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r468588715", "bodyText": "We still need fieldType because it needs to be passed to the super constructor, although I would like to make it unnecessary in future.  The fields themselves are used in the Parameter definitions further up, to initialize the merge builder from the existing mapping.", "author": "romseygeek", "createdAt": "2020-08-11T13:42:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU2NzgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU2OTg0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r468569842", "bodyText": "Lines 69-71 and 80-82 seem to be unused", "author": "mayya-sharipova", "createdAt": "2020-08-11T13:15:28Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "diffHunk": "@@ -92,149 +83,134 @@ public KeywordField(String field, BytesRef term) {\n \n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n+    private static KeywordFieldMapper toType(FieldMapper in) {", "originalCommit": "76116517d0927dcb01d3d8cccc765614c4043b8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4OTEzMg==", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r468589132", "bodyText": "++ they are, will remove", "author": "romseygeek", "createdAt": "2020-08-11T13:43:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU2OTg0Mg=="}], "type": "inlineReview"}, {"oid": "59695ce56ae5d86b657bc63ac4a4e036d22a01b7", "url": "https://github.com/elastic/elasticsearch/commit/59695ce56ae5d86b657bc63ac4a4e036d22a01b7", "message": "Merge remote-tracking branch 'origin/master' into mapper/keywordfieldmapper", "committedDate": "2020-08-11T14:50:10Z", "type": "commit"}, {"oid": "1fcc4099ce76739ceca02385f6ef0d0412e797a8", "url": "https://github.com/elastic/elasticsearch/commit/1fcc4099ce76739ceca02385f6ef0d0412e797a8", "message": "feedback", "committedDate": "2020-08-11T15:11:24Z", "type": "commit"}, {"oid": "d19975bf7eeace3fc0c986724ab40e1c6784dc67", "url": "https://github.com/elastic/elasticsearch/commit/d19975bf7eeace3fc0c986724ab40e1c6784dc67", "message": "Merge branch 'master' into mapper/keywordfieldmapper", "committedDate": "2020-08-12T09:24:53Z", "type": "commit"}]}