{"pr_number": 65697, "pr_title": "Ensure notify when proxy connections disconnect", "pr_createdAt": "2020-12-01T18:16:33Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65697", "timeline": [{"oid": "dff6d2211c255d58dec20426d5abfe28a88710bb", "url": "https://github.com/elastic/elasticsearch/commit/dff6d2211c255d58dec20426d5abfe28a88710bb", "message": "Ensure notify when proxy connection disconnect", "committedDate": "2020-12-01T18:06:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ4NTc5NA==", "url": "https://github.com/elastic/elasticsearch/pull/65697#discussion_r534485794", "bodyText": "NIT: we have CollectionUtils.appendToCopy(super.nodePlugins(clusterAlias), SearchListenerPlugin.class); to make this stuff one line", "author": "original-brownbear", "createdAt": "2020-12-02T21:15:02Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/search/ccs/CrossClusterSearchIT.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.ccs;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexModule;\n+import org.elasticsearch.index.query.MatchAllQueryBuilder;\n+import org.elasticsearch.index.shard.SearchOperationListener;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.test.AbstractMultiClustersTestCase;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.test.NodeRoles;\n+import org.elasticsearch.test.hamcrest.ElasticsearchAssertions;\n+import org.junit.Before;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+\n+public class CrossClusterSearchIT extends AbstractMultiClustersTestCase {\n+\n+    @Override\n+    protected Collection<String> remoteClusterAlias() {\n+        return List.of(\"cluster_a\");\n+    }\n+\n+    private int indexDocs(Client client, String index) {\n+        int numDocs = between(1, 10);\n+        for (int i = 0; i < numDocs; i++) {\n+            client.prepareIndex(index).setSource(\"f\", \"v\").get();\n+        }\n+        client.admin().indices().prepareRefresh(index).get();\n+        return numDocs;\n+    }\n+\n+    public void testRemoteClusterClientRole() throws Exception {\n+        assertAcked(client(LOCAL_CLUSTER).admin().indices().prepareCreate(\"demo\"));\n+        final int demoDocs = indexDocs(client(LOCAL_CLUSTER), \"demo\");\n+        assertAcked(client(\"cluster_a\").admin().indices().prepareCreate(\"prod\"));\n+        final int prodDocs = indexDocs(client(\"cluster_a\"), \"prod\");\n+        final InternalTestCluster localCluster = cluster(LOCAL_CLUSTER);\n+        final String pureDataNode = randomBoolean() ? localCluster.startDataOnlyNode() : null;\n+        final String nodeWithoutRemoteClusterClientRole = localCluster.startNode(NodeRoles.onlyRole(DiscoveryNodeRole.DATA_ROLE));\n+        ElasticsearchAssertions.assertFutureThrows(\n+            localCluster.client(nodeWithoutRemoteClusterClientRole)\n+                .prepareSearch(\"demo\", \"cluster_a:prod\")\n+                .setQuery(new MatchAllQueryBuilder())\n+                .setAllowPartialSearchResults(false)\n+                .setSize(1000)\n+                .execute(),\n+            IllegalArgumentException.class,\n+            RestStatus.BAD_REQUEST,\n+            \"node [\" + nodeWithoutRemoteClusterClientRole + \"] does not have the remote cluster client role enabled\"\n+        );\n+\n+        final String nodeWithRemoteClusterClientRole = randomFrom(\n+            StreamSupport.stream(localCluster.clusterService().state().nodes().spliterator(), false)\n+                .map(DiscoveryNode::getName)\n+                .filter(nodeName -> nodeWithoutRemoteClusterClientRole.equals(nodeName) == false)\n+                .filter(nodeName -> nodeName.equals(pureDataNode) == false)\n+                .collect(Collectors.toList()));\n+\n+        final SearchResponse resp = localCluster.client(nodeWithRemoteClusterClientRole)\n+            .prepareSearch(\"demo\", \"cluster_a:prod\")\n+            .setQuery(new MatchAllQueryBuilder())\n+            .setAllowPartialSearchResults(false)\n+            .setSize(1000)\n+            .get();\n+        assertHitCount(resp, demoDocs + prodDocs);\n+    }\n+\n+    public void testProxyConnectionDisconnect() throws Exception {\n+        assertAcked(client(LOCAL_CLUSTER).admin().indices().prepareCreate(\"demo\"));\n+        indexDocs(client(LOCAL_CLUSTER), \"demo\");\n+        final String remoteNode = cluster(\"cluster_a\").startDataOnlyNode();\n+        assertAcked(client(\"cluster_a\").admin().indices().prepareCreate(\"prod\")\n+            .setSettings(Settings.builder().put(\"index.routing.allocation.require._name\", remoteNode)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0).build()));\n+        indexDocs(client(\"cluster_a\"), \"prod\");\n+        SearchListenerPlugin.blockQueryPhase();\n+        try {\n+            PlainActionFuture<SearchResponse> future = new PlainActionFuture<>();\n+            SearchRequest searchRequest = new SearchRequest(\"demo\", \"cluster_a:prod\");\n+            searchRequest.allowPartialSearchResults(false);\n+            searchRequest.setCcsMinimizeRoundtrips(false);\n+            searchRequest.source(new SearchSourceBuilder().query(new MatchAllQueryBuilder()).size(1000));\n+            client(LOCAL_CLUSTER).search(searchRequest, future);\n+            SearchListenerPlugin.waitSearchStarted();\n+            disconnectFromRemoteClusters();\n+            assertBusy(() -> assertTrue(future.isDone()));\n+            configureAndConnectsToRemoteClusters();\n+        } finally {\n+            SearchListenerPlugin.allowQueryPhase();\n+        }\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins(String clusterAlias) {\n+        if (clusterAlias.equals(LOCAL_CLUSTER)) {\n+            return super.nodePlugins(clusterAlias);\n+        } else {\n+            final List<Class<? extends Plugin>> plugins = new ArrayList<>(super.nodePlugins(clusterAlias));\n+            plugins.add(SearchListenerPlugin.class);\n+            return plugins;", "originalCommit": "dff6d2211c255d58dec20426d5abfe28a88710bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwNTQ3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65697#discussion_r534505476", "bodyText": "Nice, see 3e262a7", "author": "dnhatn", "createdAt": "2020-12-02T21:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ4NTc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ4NzUyMg==", "url": "https://github.com/elastic/elasticsearch/pull/65697#discussion_r534487522", "bodyText": "NIT: Maybe put a timeout on these .await here and above and assertTrue to make test failures a little more obvious?", "author": "original-brownbear", "createdAt": "2020-12-02T21:18:16Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/search/ccs/CrossClusterSearchIT.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.ccs;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexModule;\n+import org.elasticsearch.index.query.MatchAllQueryBuilder;\n+import org.elasticsearch.index.shard.SearchOperationListener;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.test.AbstractMultiClustersTestCase;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.test.NodeRoles;\n+import org.elasticsearch.test.hamcrest.ElasticsearchAssertions;\n+import org.junit.Before;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+\n+public class CrossClusterSearchIT extends AbstractMultiClustersTestCase {\n+\n+    @Override\n+    protected Collection<String> remoteClusterAlias() {\n+        return List.of(\"cluster_a\");\n+    }\n+\n+    private int indexDocs(Client client, String index) {\n+        int numDocs = between(1, 10);\n+        for (int i = 0; i < numDocs; i++) {\n+            client.prepareIndex(index).setSource(\"f\", \"v\").get();\n+        }\n+        client.admin().indices().prepareRefresh(index).get();\n+        return numDocs;\n+    }\n+\n+    public void testRemoteClusterClientRole() throws Exception {\n+        assertAcked(client(LOCAL_CLUSTER).admin().indices().prepareCreate(\"demo\"));\n+        final int demoDocs = indexDocs(client(LOCAL_CLUSTER), \"demo\");\n+        assertAcked(client(\"cluster_a\").admin().indices().prepareCreate(\"prod\"));\n+        final int prodDocs = indexDocs(client(\"cluster_a\"), \"prod\");\n+        final InternalTestCluster localCluster = cluster(LOCAL_CLUSTER);\n+        final String pureDataNode = randomBoolean() ? localCluster.startDataOnlyNode() : null;\n+        final String nodeWithoutRemoteClusterClientRole = localCluster.startNode(NodeRoles.onlyRole(DiscoveryNodeRole.DATA_ROLE));\n+        ElasticsearchAssertions.assertFutureThrows(\n+            localCluster.client(nodeWithoutRemoteClusterClientRole)\n+                .prepareSearch(\"demo\", \"cluster_a:prod\")\n+                .setQuery(new MatchAllQueryBuilder())\n+                .setAllowPartialSearchResults(false)\n+                .setSize(1000)\n+                .execute(),\n+            IllegalArgumentException.class,\n+            RestStatus.BAD_REQUEST,\n+            \"node [\" + nodeWithoutRemoteClusterClientRole + \"] does not have the remote cluster client role enabled\"\n+        );\n+\n+        final String nodeWithRemoteClusterClientRole = randomFrom(\n+            StreamSupport.stream(localCluster.clusterService().state().nodes().spliterator(), false)\n+                .map(DiscoveryNode::getName)\n+                .filter(nodeName -> nodeWithoutRemoteClusterClientRole.equals(nodeName) == false)\n+                .filter(nodeName -> nodeName.equals(pureDataNode) == false)\n+                .collect(Collectors.toList()));\n+\n+        final SearchResponse resp = localCluster.client(nodeWithRemoteClusterClientRole)\n+            .prepareSearch(\"demo\", \"cluster_a:prod\")\n+            .setQuery(new MatchAllQueryBuilder())\n+            .setAllowPartialSearchResults(false)\n+            .setSize(1000)\n+            .get();\n+        assertHitCount(resp, demoDocs + prodDocs);\n+    }\n+\n+    public void testProxyConnectionDisconnect() throws Exception {\n+        assertAcked(client(LOCAL_CLUSTER).admin().indices().prepareCreate(\"demo\"));\n+        indexDocs(client(LOCAL_CLUSTER), \"demo\");\n+        final String remoteNode = cluster(\"cluster_a\").startDataOnlyNode();\n+        assertAcked(client(\"cluster_a\").admin().indices().prepareCreate(\"prod\")\n+            .setSettings(Settings.builder().put(\"index.routing.allocation.require._name\", remoteNode)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0).build()));\n+        indexDocs(client(\"cluster_a\"), \"prod\");\n+        SearchListenerPlugin.blockQueryPhase();\n+        try {\n+            PlainActionFuture<SearchResponse> future = new PlainActionFuture<>();\n+            SearchRequest searchRequest = new SearchRequest(\"demo\", \"cluster_a:prod\");\n+            searchRequest.allowPartialSearchResults(false);\n+            searchRequest.setCcsMinimizeRoundtrips(false);\n+            searchRequest.source(new SearchSourceBuilder().query(new MatchAllQueryBuilder()).size(1000));\n+            client(LOCAL_CLUSTER).search(searchRequest, future);\n+            SearchListenerPlugin.waitSearchStarted();\n+            disconnectFromRemoteClusters();\n+            assertBusy(() -> assertTrue(future.isDone()));\n+            configureAndConnectsToRemoteClusters();\n+        } finally {\n+            SearchListenerPlugin.allowQueryPhase();\n+        }\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins(String clusterAlias) {\n+        if (clusterAlias.equals(LOCAL_CLUSTER)) {\n+            return super.nodePlugins(clusterAlias);\n+        } else {\n+            final List<Class<? extends Plugin>> plugins = new ArrayList<>(super.nodePlugins(clusterAlias));\n+            plugins.add(SearchListenerPlugin.class);\n+            return plugins;\n+        }\n+    }\n+\n+    @Before\n+    public void resetSearchListenerPlugin() throws Exception {\n+        SearchListenerPlugin.reset();\n+    }\n+\n+    public static class SearchListenerPlugin extends Plugin {\n+        private static final AtomicReference<CountDownLatch> startedLatch = new AtomicReference<>();\n+        private static final AtomicReference<CountDownLatch> queryLatch = new AtomicReference<>();\n+\n+        static void reset() {\n+            startedLatch.set(new CountDownLatch(1));\n+        }\n+\n+        static void blockQueryPhase() {\n+            queryLatch.set(new CountDownLatch(1));\n+        }\n+\n+        static void allowQueryPhase() {\n+            final CountDownLatch latch = queryLatch.get();\n+            if (latch != null) {\n+                latch.countDown();\n+            }\n+        }\n+\n+        static void waitSearchStarted() throws InterruptedException {\n+            startedLatch.get().await();\n+        }\n+\n+        @Override\n+        public void onIndexModule(IndexModule indexModule) {\n+            indexModule.addSearchOperationListener(new SearchOperationListener() {\n+                @Override\n+                public void onPreQueryPhase(SearchContext searchContext) {\n+                    startedLatch.get().countDown();\n+                    final CountDownLatch latch = queryLatch.get();\n+                    if (latch != null) {\n+                        try {\n+                            latch.await();", "originalCommit": "dff6d2211c255d58dec20426d5abfe28a88710bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwNTYwNw==", "url": "https://github.com/elastic/elasticsearch/pull/65697#discussion_r534505607", "bodyText": "Sure, adjusted in 031bf82", "author": "dnhatn", "createdAt": "2020-12-02T21:51:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ4NzUyMg=="}], "type": "inlineReview"}, {"oid": "4ddc99aa968f336cc6afc9d001ae7c4c28feac24", "url": "https://github.com/elastic/elasticsearch/commit/4ddc99aa968f336cc6afc9d001ae7c4c28feac24", "message": "Merge branch 'master' into proxy-disconnected", "committedDate": "2020-12-02T21:48:17Z", "type": "commit"}, {"oid": "031bf821152fb07cc37e7ff63b89d298aa491ae3", "url": "https://github.com/elastic/elasticsearch/commit/031bf821152fb07cc37e7ff63b89d298aa491ae3", "message": "await latch with timeout", "committedDate": "2020-12-02T21:50:24Z", "type": "commit"}, {"oid": "3e262a7349647bb6b3c48ab1b840d88396aa08ce", "url": "https://github.com/elastic/elasticsearch/commit/3e262a7349647bb6b3c48ab1b840d88396aa08ce", "message": "better collection", "committedDate": "2020-12-02T21:51:22Z", "type": "commit"}]}