{"pr_number": 57675, "pr_title": "Add support for snapshot and restore to data streams", "pr_createdAt": "2020-06-04T14:16:13Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/57675", "timeline": [{"oid": "3fb3a5e85e9560e44593691fd9b2729c2ae276e4", "url": "https://github.com/elastic/elasticsearch/commit/3fb3a5e85e9560e44593691fd9b2729c2ae276e4", "message": "snapshot-restore working", "committedDate": "2020-06-04T10:19:42Z", "type": "commit"}, {"oid": "ac7a8e2e81c1a2882b2d9a8b15e2d9dafb254a09", "url": "https://github.com/elastic/elasticsearch/commit/ac7a8e2e81c1a2882b2d9a8b15e2d9dafb254a09", "message": "store data streams in SnapshotInfo", "committedDate": "2020-06-04T11:57:33Z", "type": "commit"}, {"oid": "cbff19cdb20505e9bd14192293af8b5cc391746c", "url": "https://github.com/elastic/elasticsearch/commit/cbff19cdb20505e9bd14192293af8b5cc391746c", "message": "Merge remote-tracking branch 'origin/master' into datastreams-snapshots", "committedDate": "2020-06-04T12:00:19Z", "type": "commit"}, {"oid": "f5fdd80a9e763ddd62399886ff6897f7561efa48", "url": "https://github.com/elastic/elasticsearch/commit/f5fdd80a9e763ddd62399886ff6897f7561efa48", "message": "store data streams in SnapshotInfo", "committedDate": "2020-06-04T13:36:40Z", "type": "commit"}, {"oid": "38672a25abc04692eeb5717272288793ac12a4e7", "url": "https://github.com/elastic/elasticsearch/commit/38672a25abc04692eeb5717272288793ac12a4e7", "message": "fix ccr repository", "committedDate": "2020-06-04T14:25:30Z", "type": "commit"}, {"oid": "e97739c5223aed3cc7a07ce27940f54f694fe84b", "url": "https://github.com/elastic/elasticsearch/commit/e97739c5223aed3cc7a07ce27940f54f694fe84b", "message": "fix SLM", "committedDate": "2020-06-04T14:34:38Z", "type": "commit"}, {"oid": "028d73129b63440bc4526850668a10c2a948f65c", "url": "https://github.com/elastic/elasticsearch/commit/028d73129b63440bc4526850668a10c2a948f65c", "message": "fix SLM", "committedDate": "2020-06-04T14:43:02Z", "type": "commit"}, {"oid": "7a75eb13de812f791e666d9152873cde262eb30d", "url": "https://github.com/elastic/elasticsearch/commit/7a75eb13de812f791e666d9152873cde262eb30d", "message": "fix tests and checkstyle", "committedDate": "2020-06-04T15:01:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3OTIzNw==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r435379237", "bodyText": "I don't think we need the concrete instances of DataStream here? I think we should just track the IDs of data streams to snapshot here like we do for indices. Otherwise, we have to keep these in memory for the whole duration of the snapshot.", "author": "original-brownbear", "createdAt": "2020-06-04T16:10:54Z", "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -202,6 +208,10 @@ public long startTime() {\n             return startTime;\n         }\n \n+        public List<DataStream> dataStreams() {", "originalCommit": "7a75eb13de812f791e666d9152873cde262eb30d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MTY5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r435381697", "bodyText": "I would rather not add the data streams to the SnapshotInfo blobs. Adding them here, means that these blobs can get quite large and we load them in parallel in many occasions (e.g. SLM figuring out what snapshots to delete). These blobs really are designed as a lightweight thing, not as something to store data in. If we add to it we up the resource (memory+transfer) usage of our get snapshots APIs which is already problematic in some cases.", "author": "original-brownbear", "createdAt": "2020-06-04T16:14:53Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotInfo.java", "diffHunk": "@@ -53,12 +54,15 @@\n  */\n public final class SnapshotInfo implements Comparable<SnapshotInfo>, ToXContent, Writeable {\n \n+    public static final Version DATA_STREAMS_IN_SNAPSHOT = Version.V_8_0_0;\n+\n     public static final String CONTEXT_MODE_PARAM = \"context_mode\";\n     public static final String CONTEXT_MODE_SNAPSHOT = \"SNAPSHOT\";\n     private static final DateFormatter DATE_TIME_FORMATTER = DateFormatter.forPattern(\"strictDateOptionalTime\");\n     private static final String SNAPSHOT = \"snapshot\";\n     private static final String UUID = \"uuid\";\n     private static final String INDICES = \"indices\";\n+    private static final String DATA_STREAMS = \"data_streams\";", "originalCommit": "7a75eb13de812f791e666d9152873cde262eb30d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczMDE1MA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r435730150", "bodyText": "Would just the data stream name ids be ok?", "author": "martijnvg", "createdAt": "2020-06-05T07:11:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MTY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNTU2MA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r435735560", "bodyText": "I'm assuming you want to add it to be able to get a list of data streams for each snapshot in the snapshot listing from the get snapshots API?\nFor that I think it's fine. Not great to add it here but I don't see an easy alternative to it right now and it's not a lot of data anyway if it's just the names.\nFor purposes of restoring I don't think we would need this (we can just inspect the cluster state we're restoring from there).", "author": "original-brownbear", "createdAt": "2020-06-05T07:23:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MTY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4MTQ1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r435781459", "bodyText": "Thanks @original-brownbear for review! I initially do it the way you proposed (storing data streams in global metadata) - metadataForSnapshot is already modified accordingl, it worked just fine and for sure was less intrusive change.\nMy concern with that was that on any restore with have to download whole state to examine it for data streams and that can be costly. Storing data streams ids would mitigate some of it, but still we would need whole global state if we want to restore any data stream.\nOr do you think this should not be such big problem?\n(I didn't really care for displaying it in get snapshots TBH, but it is nice touch)", "author": "probakowski", "createdAt": "2020-06-05T08:51:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MTY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4OTA3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r435789079", "bodyText": "npnp @probakowski :)\n\nOr do you think this should not be such big problem?\n\nYea this is irrelevant. Those few extra bytes to download won't hurt anyone for a rare action like restoring data streams :)\n\n(I didn't really care for displaying it in get snapshots TBH, but it is nice touch)\n\nHmm, if we don't care about it all that much, we could even leave out the change to SnapshotInfo for step 1 I guess. It's certainly nice to save those bytes here and not add any format changes if we don't have to. But I'm fine adding the list of names as well if you think it's helpful for users.", "author": "original-brownbear", "createdAt": "2020-06-05T09:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MTY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5NzQwMw==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r435397403", "bodyText": "You have to make sure not to allow any specific data stream snapshotting as long as there's master nodes older than DATA_STREAMS_IN_SNAPSHOT in the cluster. Otherwise, if you have a master failover to an old version master the information about the data stream snapshots is just lost because it won't deserialize that part.", "author": "original-brownbear", "createdAt": "2020-06-04T16:39:40Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -224,7 +225,17 @@ public ClusterState execute(ClusterState currentState) {\n                 }\n                 // Store newSnapshot here to be processed in clusterStateProcessed\n                 List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,\n-                    request.indicesOptions(), request.indices()));\n+                    request.indicesOptions(), true, request.indices()));\n+\n+                Map<String, DataStream> allDataStreams = currentState.metadata().dataStreams();\n+                List<DataStream> dataStreams;\n+                if(request.includeGlobalState()){\n+                    dataStreams = new ArrayList<>(allDataStreams.values());\n+                } else {\n+                    dataStreams = indexNameExpressionResolver.dataStreamNames(currentState, request.indicesOptions(),", "originalCommit": "7a75eb13de812f791e666d9152873cde262eb30d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4MTk0NA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r435781944", "bodyText": "Thanks for suggestion, is there a way to check that whole cluster is already on correct version?", "author": "probakowski", "createdAt": "2020-06-05T08:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5NzQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4NTk2MA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r435785960", "bodyText": "Jup, you can use:\nclusterState.nodes().getMinNodeVersion()\nsee e.g.\nhttps://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java#L231", "author": "original-brownbear", "createdAt": "2020-06-05T08:59:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5NzQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4NjQzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r435786435", "bodyText": "I think the version variable indicates the lowest version of nodes in the entire cluster.\n(that variable is based on clusterService.state().nodes().getMinNodeVersion())", "author": "martijnvg", "createdAt": "2020-06-05T09:00:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5NzQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4NjkzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r435786931", "bodyText": "stale read from side...", "author": "martijnvg", "createdAt": "2020-06-05T09:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5NzQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM4MjgxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r439382811", "bodyText": "Added required check", "author": "probakowski", "createdAt": "2020-06-12T12:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5NzQwMw=="}], "type": "inlineReview"}, {"oid": "6a0f7ae440febc54c95e1bb185db51d2db58264f", "url": "https://github.com/elastic/elasticsearch/commit/6a0f7ae440febc54c95e1bb185db51d2db58264f", "message": "Revert \"fix SLM\"\n\nThis reverts commit 028d73129b63440bc4526850668a10c2a948f65c.", "committedDate": "2020-06-05T09:21:45Z", "type": "commit"}, {"oid": "3ed053c27c6a20cc21046335f4fc2d79befe1665", "url": "https://github.com/elastic/elasticsearch/commit/3ed053c27c6a20cc21046335f4fc2d79befe1665", "message": "Revert \"fix SLM\"\n\nThis reverts commit e97739c5223aed3cc7a07ce27940f54f694fe84b.", "committedDate": "2020-06-05T09:21:49Z", "type": "commit"}, {"oid": "8ad7a604e577d6dba60fa9a6220f6fdde8962379", "url": "https://github.com/elastic/elasticsearch/commit/8ad7a604e577d6dba60fa9a6220f6fdde8962379", "message": "Revert \"fix ccr repository\"\n\nThis reverts commit 38672a25abc04692eeb5717272288793ac12a4e7.", "committedDate": "2020-06-05T09:21:53Z", "type": "commit"}, {"oid": "7ec931e78fdee7641aff56b47f24ecf307204d74", "url": "https://github.com/elastic/elasticsearch/commit/7ec931e78fdee7641aff56b47f24ecf307204d74", "message": "Revert \"store data streams in SnapshotInfo\"\n\nThis reverts commit f5fdd80a9e763ddd62399886ff6897f7561efa48.", "committedDate": "2020-06-05T09:21:56Z", "type": "commit"}, {"oid": "9ef9702116f92e67d7d6ca843e6222f7bba9693c", "url": "https://github.com/elastic/elasticsearch/commit/9ef9702116f92e67d7d6ca843e6222f7bba9693c", "message": "Revert \"store data streams in SnapshotInfo\"\n\nThis reverts commit ac7a8e2e81c1a2882b2d9a8b15e2d9dafb254a09.", "committedDate": "2020-06-05T09:38:41Z", "type": "commit"}, {"oid": "c0dd528fbebf5ce0dcb91321797012a2efd41443", "url": "https://github.com/elastic/elasticsearch/commit/c0dd528fbebf5ce0dcb91321797012a2efd41443", "message": "tests fix", "committedDate": "2020-06-05T09:57:48Z", "type": "commit"}, {"oid": "41bfb409beffdfe344b179bdb60df311a061aac3", "url": "https://github.com/elastic/elasticsearch/commit/41bfb409beffdfe344b179bdb60df311a061aac3", "message": "checkstyle + all ds on global state", "committedDate": "2020-06-05T10:15:57Z", "type": "commit"}, {"oid": "0f8a105990c07f062c1b29ed7ff3dccc3395037e", "url": "https://github.com/elastic/elasticsearch/commit/0f8a105990c07f062c1b29ed7ff3dccc3395037e", "message": "checkstyle", "committedDate": "2020-06-05T10:44:06Z", "type": "commit"}, {"oid": "d8acc602d20df15131900d31116ec370364e533f", "url": "https://github.com/elastic/elasticsearch/commit/d8acc602d20df15131900d31116ec370364e533f", "message": "tests fix", "committedDate": "2020-06-09T08:56:50Z", "type": "commit"}, {"oid": "69a393d596603543c06e73e59f4bb8b23d1d76eb", "url": "https://github.com/elastic/elasticsearch/commit/69a393d596603543c06e73e59f4bb8b23d1d76eb", "message": "Merge remote-tracking branch 'origin/master' into datastreams-snapshots", "committedDate": "2020-06-09T08:57:52Z", "type": "commit"}, {"oid": "931fd31a04b46780939f81f7db6ca325fa628918", "url": "https://github.com/elastic/elasticsearch/commit/931fd31a04b46780939f81f7db6ca325fa628918", "message": "Rename adjusted to new naming requirements", "committedDate": "2020-06-09T10:43:35Z", "type": "commit"}, {"oid": "e51533f5ef320be6391ea790fe5eb15191a50f85", "url": "https://github.com/elastic/elasticsearch/commit/e51533f5ef320be6391ea790fe5eb15191a50f85", "message": "removed test after changing assumptions", "committedDate": "2020-06-09T11:22:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2NDU0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r437364547", "bodyText": "iirc if actionGet() is invoked then the real exception is thrown instead of ExecutionException. So maybe do that instead of invoked get()?", "author": "martijnvg", "createdAt": "2020-06-09T12:20:37Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/snapshots/DataStreamsSnapshotsIT.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import org.elasticsearch.ResourceNotFoundException;\n+import org.elasticsearch.action.DocWriteRequest;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.get.GetSnapshotsResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.admin.indices.datastream.CreateDataStreamAction;\n+import org.elasticsearch.action.admin.indices.datastream.DeleteDataStreamAction;\n+import org.elasticsearch.action.admin.indices.datastream.GetDataStreamAction;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.indices.DataStreamIT;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.transport.RemoteTransportException;\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+\n+public class DataStreamsSnapshotsIT extends AbstractSnapshotIntegTestCase {\n+\n+    public void testSnapshotAndRestore() throws Exception {\n+        Client client = client();\n+\n+        Path location = randomRepoPath();\n+        createRepository(\"repo\", \"fs\", location);\n+\n+        DataStreamIT.createIndexTemplate(\"t1\", \"@timestamp\", \"ds\", \"other-ds\");\n+\n+        CreateDataStreamAction.Request request = new CreateDataStreamAction.Request(\"ds\");\n+        AcknowledgedResponse response = client.admin().indices().createDataStream(request).get();\n+        assertTrue(response.isAcknowledged());\n+\n+        request = new CreateDataStreamAction.Request(\"other-ds\");\n+        response = client.admin().indices().createDataStream(request).get();\n+        assertTrue(response.isAcknowledged());\n+\n+        Map<String, Integer> source = Collections.singletonMap(\"@timestamp\", 123);\n+        IndexResponse indexResponse = client.prepareIndex(\"ds\")\n+            .setOpType(DocWriteRequest.OpType.CREATE)\n+            .setSource(source)\n+            .get();\n+        assertEquals(DocWriteResponse.Result.CREATED, indexResponse.getResult());\n+\n+        CreateSnapshotResponse createSnapshotResponse = client.admin().cluster()\n+            .prepareCreateSnapshot(\"repo\", \"snap\")\n+            .setWaitForCompletion(true)\n+            .setIndices(\"ds\")\n+            .setIncludeGlobalState(false)\n+            .get();\n+\n+        RestStatus status = createSnapshotResponse.getSnapshotInfo().status();\n+        assertEquals(RestStatus.OK, status);\n+\n+        GetSnapshotsResponse snapshot = client.admin().cluster().prepareGetSnapshots(\"repo\").setSnapshots(\"snap\").get();\n+        List<SnapshotInfo> snap = snapshot.getSnapshots(\"repo\");\n+        assertEquals(1, snap.size());\n+        assertEquals(Collections.singletonList(\".ds-ds-000001\"), snap.get(0).indices());\n+\n+        assertTrue(client.admin().indices().deleteDataStream(new DeleteDataStreamAction.Request(\"ds\")).get().isAcknowledged());\n+\n+        RestoreSnapshotResponse restoreSnapshotResponse = client.admin().cluster()\n+            .prepareRestoreSnapshot(\"repo\", \"snap\")\n+            .setWaitForCompletion(true)\n+            .setIndices(\"ds\")\n+            .get();\n+\n+        assertEquals(1, restoreSnapshotResponse.getRestoreInfo().successfulShards());\n+\n+        GetResponse getResponse = client.prepareGet(\".ds-ds-000001\", indexResponse.getId()).get();\n+        assertEquals(source, getResponse.getSourceAsMap());\n+\n+        GetDataStreamAction.Response ds = client.admin().indices().getDataStreams(new GetDataStreamAction.Request(\"ds\")).get();\n+        assertEquals(1, ds.getDataStreams().size());\n+        assertEquals(1, ds.getDataStreams().get(0).getIndices().size());\n+        assertEquals(\".ds-ds-000001\", ds.getDataStreams().get(0).getIndices().get(0).getName());\n+        assertEquals(source, client.prepareSearch(\"ds\").get().getHits().getHits()[0].getSourceAsMap());\n+\n+        restoreSnapshotResponse = client.admin().cluster()\n+            .prepareRestoreSnapshot(\"repo\", \"snap\")\n+            .setWaitForCompletion(true)\n+            .setIndices(\"ds\")\n+            .setRenamePattern(\"ds\")\n+            .setRenameReplacement(\"ds2\")\n+            .get();\n+\n+        ds = client.admin().indices().getDataStreams(new GetDataStreamAction.Request(\"ds2\")).get();\n+        assertEquals(1, ds.getDataStreams().size());\n+        assertEquals(1, ds.getDataStreams().get(0).getIndices().size());\n+        assertEquals(\".ds-ds2-000001\", ds.getDataStreams().get(0).getIndices().get(0).getName());\n+        assertEquals(source, client.prepareSearch(\"ds2\").get().getHits().getHits()[0].getSourceAsMap());\n+    }\n+\n+    public void testWildcards() throws Exception {\n+        Client client = client();\n+\n+        Path location = randomRepoPath();\n+        createRepository(\"repo\", \"fs\", location);\n+\n+        DataStreamIT.createIndexTemplate(\"t1\", \"@timestamp\", \"ds\", \"other-ds\");\n+\n+        CreateDataStreamAction.Request request = new CreateDataStreamAction.Request(\"ds\");\n+        AcknowledgedResponse response = client.admin().indices().createDataStream(request).get();\n+        assertTrue(response.isAcknowledged());\n+\n+        CreateSnapshotResponse createSnapshotResponse = client.admin().cluster()\n+            .prepareCreateSnapshot(\"repo\", \"snap2\")\n+            .setWaitForCompletion(true)\n+            .setIndices(\"d*\")\n+            .setIncludeGlobalState(false)\n+            .get();\n+\n+        RestStatus status = createSnapshotResponse.getSnapshotInfo().status();\n+        assertEquals(RestStatus.OK, status);\n+\n+        RestoreSnapshotResponse restoreSnapshotResponse = client.admin().cluster()\n+            .prepareRestoreSnapshot(\"repo\", \"snap2\")\n+            .setWaitForCompletion(true)\n+            .setIndices(\"d*\")\n+            .setRenamePattern(\"ds\")\n+            .setRenameReplacement(\"ds2\")\n+            .get();\n+\n+        assertEquals(RestStatus.OK, restoreSnapshotResponse.status());\n+\n+        GetDataStreamAction.Response ds = client.admin().indices().getDataStreams(new GetDataStreamAction.Request(\"ds2\")).get();\n+        assertEquals(1, ds.getDataStreams().size());\n+        assertEquals(1, ds.getDataStreams().get(0).getIndices().size());\n+        assertEquals(\".ds-ds2-000001\", ds.getDataStreams().get(0).getIndices().get(0).getName());\n+    }\n+\n+    public void testDataStreamNotStoredWhenIndexRequested() throws Exception {\n+        Client client = client();\n+\n+        Path location = randomRepoPath();\n+        createRepository(\"repo\", \"fs\", location);\n+\n+        DataStreamIT.createIndexTemplate(\"t1\", \"@timestamp\", \"ds\", \"other-ds\");\n+\n+        CreateDataStreamAction.Request request = new CreateDataStreamAction.Request(\"ds\");\n+        AcknowledgedResponse response = client.admin().indices().createDataStream(request).get();\n+        assertTrue(response.isAcknowledged());\n+\n+        CreateSnapshotResponse createSnapshotResponse = client.admin().cluster()\n+            .prepareCreateSnapshot(\"repo\", \"snap2\")\n+            .setWaitForCompletion(true)\n+            .setIndices(\".ds-ds-000001\")\n+            .setIncludeGlobalState(false)\n+            .get();\n+\n+        RestStatus status = createSnapshotResponse.getSnapshotInfo().status();\n+        assertEquals(RestStatus.OK, status);\n+        expectThrows(Exception.class, () -> client.admin().cluster()\n+            .prepareRestoreSnapshot(\"repo\", \"snap2\")\n+            .setWaitForCompletion(true)\n+            .setIndices(\"ds\")\n+            .get());\n+    }\n+\n+    public void testDataStreamNotRestoredWhenIndexRequested() throws Exception {\n+        Client client = client();\n+\n+        Path location = randomRepoPath();\n+        createRepository(\"repo\", \"fs\", location);\n+\n+        DataStreamIT.createIndexTemplate(\"t1\", \"@timestamp\", \"ds\", \"other-ds\");\n+\n+        CreateDataStreamAction.Request request = new CreateDataStreamAction.Request(\"ds\");\n+        AcknowledgedResponse response = client.admin().indices().createDataStream(request).get();\n+        assertTrue(response.isAcknowledged());\n+\n+        CreateSnapshotResponse createSnapshotResponse = client.admin().cluster()\n+            .prepareCreateSnapshot(\"repo\", \"snap2\")\n+            .setWaitForCompletion(true)\n+            .setIndices(\"ds\")\n+            .setIncludeGlobalState(false)\n+            .get();\n+\n+        RestStatus status = createSnapshotResponse.getSnapshotInfo().status();\n+        assertEquals(RestStatus.OK, status);\n+\n+        assertTrue(client.admin().indices().deleteDataStream(new DeleteDataStreamAction.Request(\"ds\")).get().isAcknowledged());\n+\n+        RestoreSnapshotResponse restoreSnapshotResponse = client.admin().cluster()\n+            .prepareRestoreSnapshot(\"repo\", \"snap2\")\n+            .setWaitForCompletion(true)\n+            .setIndices(\".ds-ds-*\")\n+            .get();\n+\n+        assertEquals(RestStatus.OK, restoreSnapshotResponse.status());\n+\n+        GetDataStreamAction.Request getRequest = new GetDataStreamAction.Request(\"ds\");\n+        Throwable e = expectThrows(ExecutionException.class, () -> client.admin().indices().getDataStreams(getRequest).get()).getCause();", "originalCommit": "e51533f5ef320be6391ea790fe5eb15191a50f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM4Mjk3NA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r439382974", "bodyText": "Great suggestion, thanks!", "author": "probakowski", "createdAt": "2020-06-12T12:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2NDU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2NTAyNg==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r437365026", "bodyText": "Maybe also do a search on the restored data stream?", "author": "martijnvg", "createdAt": "2020-06-09T12:21:06Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/snapshots/DataStreamsSnapshotsIT.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import org.elasticsearch.ResourceNotFoundException;\n+import org.elasticsearch.action.DocWriteRequest;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.get.GetSnapshotsResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.admin.indices.datastream.CreateDataStreamAction;\n+import org.elasticsearch.action.admin.indices.datastream.DeleteDataStreamAction;\n+import org.elasticsearch.action.admin.indices.datastream.GetDataStreamAction;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.indices.DataStreamIT;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.transport.RemoteTransportException;\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+\n+public class DataStreamsSnapshotsIT extends AbstractSnapshotIntegTestCase {\n+\n+    public void testSnapshotAndRestore() throws Exception {\n+        Client client = client();\n+\n+        Path location = randomRepoPath();\n+        createRepository(\"repo\", \"fs\", location);\n+\n+        DataStreamIT.createIndexTemplate(\"t1\", \"@timestamp\", \"ds\", \"other-ds\");\n+\n+        CreateDataStreamAction.Request request = new CreateDataStreamAction.Request(\"ds\");\n+        AcknowledgedResponse response = client.admin().indices().createDataStream(request).get();\n+        assertTrue(response.isAcknowledged());\n+\n+        request = new CreateDataStreamAction.Request(\"other-ds\");\n+        response = client.admin().indices().createDataStream(request).get();\n+        assertTrue(response.isAcknowledged());\n+\n+        Map<String, Integer> source = Collections.singletonMap(\"@timestamp\", 123);\n+        IndexResponse indexResponse = client.prepareIndex(\"ds\")\n+            .setOpType(DocWriteRequest.OpType.CREATE)\n+            .setSource(source)\n+            .get();\n+        assertEquals(DocWriteResponse.Result.CREATED, indexResponse.getResult());\n+\n+        CreateSnapshotResponse createSnapshotResponse = client.admin().cluster()\n+            .prepareCreateSnapshot(\"repo\", \"snap\")\n+            .setWaitForCompletion(true)\n+            .setIndices(\"ds\")\n+            .setIncludeGlobalState(false)\n+            .get();\n+\n+        RestStatus status = createSnapshotResponse.getSnapshotInfo().status();\n+        assertEquals(RestStatus.OK, status);\n+\n+        GetSnapshotsResponse snapshot = client.admin().cluster().prepareGetSnapshots(\"repo\").setSnapshots(\"snap\").get();\n+        List<SnapshotInfo> snap = snapshot.getSnapshots(\"repo\");\n+        assertEquals(1, snap.size());\n+        assertEquals(Collections.singletonList(\".ds-ds-000001\"), snap.get(0).indices());\n+\n+        assertTrue(client.admin().indices().deleteDataStream(new DeleteDataStreamAction.Request(\"ds\")).get().isAcknowledged());\n+\n+        RestoreSnapshotResponse restoreSnapshotResponse = client.admin().cluster()\n+            .prepareRestoreSnapshot(\"repo\", \"snap\")\n+            .setWaitForCompletion(true)\n+            .setIndices(\"ds\")\n+            .get();\n+\n+        assertEquals(1, restoreSnapshotResponse.getRestoreInfo().successfulShards());\n+\n+        GetResponse getResponse = client.prepareGet(\".ds-ds-000001\", indexResponse.getId()).get();", "originalCommit": "e51533f5ef320be6391ea790fe5eb15191a50f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM4NDY5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r439384692", "bodyText": "I've tested it already - code was few lines below, I moved it group both searches together", "author": "probakowski", "createdAt": "2020-06-12T12:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2NTAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2OTI4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r437369285", "bodyText": "maybe test the rename functionality in a separate test method?", "author": "martijnvg", "createdAt": "2020-06-09T12:25:48Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/snapshots/DataStreamsSnapshotsIT.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import org.elasticsearch.ResourceNotFoundException;\n+import org.elasticsearch.action.DocWriteRequest;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.get.GetSnapshotsResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.admin.indices.datastream.CreateDataStreamAction;\n+import org.elasticsearch.action.admin.indices.datastream.DeleteDataStreamAction;\n+import org.elasticsearch.action.admin.indices.datastream.GetDataStreamAction;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.indices.DataStreamIT;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.transport.RemoteTransportException;\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+\n+public class DataStreamsSnapshotsIT extends AbstractSnapshotIntegTestCase {\n+\n+    public void testSnapshotAndRestore() throws Exception {\n+        Client client = client();\n+\n+        Path location = randomRepoPath();\n+        createRepository(\"repo\", \"fs\", location);\n+\n+        DataStreamIT.createIndexTemplate(\"t1\", \"@timestamp\", \"ds\", \"other-ds\");\n+\n+        CreateDataStreamAction.Request request = new CreateDataStreamAction.Request(\"ds\");\n+        AcknowledgedResponse response = client.admin().indices().createDataStream(request).get();\n+        assertTrue(response.isAcknowledged());\n+\n+        request = new CreateDataStreamAction.Request(\"other-ds\");\n+        response = client.admin().indices().createDataStream(request).get();\n+        assertTrue(response.isAcknowledged());\n+\n+        Map<String, Integer> source = Collections.singletonMap(\"@timestamp\", 123);\n+        IndexResponse indexResponse = client.prepareIndex(\"ds\")\n+            .setOpType(DocWriteRequest.OpType.CREATE)\n+            .setSource(source)\n+            .get();\n+        assertEquals(DocWriteResponse.Result.CREATED, indexResponse.getResult());\n+\n+        CreateSnapshotResponse createSnapshotResponse = client.admin().cluster()\n+            .prepareCreateSnapshot(\"repo\", \"snap\")\n+            .setWaitForCompletion(true)\n+            .setIndices(\"ds\")\n+            .setIncludeGlobalState(false)\n+            .get();\n+\n+        RestStatus status = createSnapshotResponse.getSnapshotInfo().status();\n+        assertEquals(RestStatus.OK, status);\n+\n+        GetSnapshotsResponse snapshot = client.admin().cluster().prepareGetSnapshots(\"repo\").setSnapshots(\"snap\").get();\n+        List<SnapshotInfo> snap = snapshot.getSnapshots(\"repo\");\n+        assertEquals(1, snap.size());\n+        assertEquals(Collections.singletonList(\".ds-ds-000001\"), snap.get(0).indices());\n+\n+        assertTrue(client.admin().indices().deleteDataStream(new DeleteDataStreamAction.Request(\"ds\")).get().isAcknowledged());\n+\n+        RestoreSnapshotResponse restoreSnapshotResponse = client.admin().cluster()\n+            .prepareRestoreSnapshot(\"repo\", \"snap\")\n+            .setWaitForCompletion(true)\n+            .setIndices(\"ds\")\n+            .get();\n+\n+        assertEquals(1, restoreSnapshotResponse.getRestoreInfo().successfulShards());\n+\n+        GetResponse getResponse = client.prepareGet(\".ds-ds-000001\", indexResponse.getId()).get();\n+        assertEquals(source, getResponse.getSourceAsMap());\n+\n+        GetDataStreamAction.Response ds = client.admin().indices().getDataStreams(new GetDataStreamAction.Request(\"ds\")).get();\n+        assertEquals(1, ds.getDataStreams().size());\n+        assertEquals(1, ds.getDataStreams().get(0).getIndices().size());\n+        assertEquals(\".ds-ds-000001\", ds.getDataStreams().get(0).getIndices().get(0).getName());\n+        assertEquals(source, client.prepareSearch(\"ds\").get().getHits().getHits()[0].getSourceAsMap());\n+\n+        restoreSnapshotResponse = client.admin().cluster()\n+            .prepareRestoreSnapshot(\"repo\", \"snap\")\n+            .setWaitForCompletion(true)\n+            .setIndices(\"ds\")\n+            .setRenamePattern(\"ds\")\n+            .setRenameReplacement(\"ds2\")", "originalCommit": "e51533f5ef320be6391ea790fe5eb15191a50f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM4MzEwNA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r439383104", "bodyText": "\ud83d\udc4d moved to separate method", "author": "probakowski", "createdAt": "2020-06-12T12:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2OTI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3Mzg3NA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r437373874", "bodyText": "Maybe write a unit test for this method, which tests the renaming more thoroughly?", "author": "martijnvg", "createdAt": "2020-06-09T12:30:53Z", "path": "server/src/main/java/org/elasticsearch/snapshots/RestoreService.java", "diffHunk": "@@ -552,6 +586,17 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n         }\n     }\n \n+    private DataStream updateDataStream(DataStream dataStream, Metadata.Builder metadata, RestoreSnapshotRequest request) {", "originalCommit": "e51533f5ef320be6391ea790fe5eb15191a50f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM4NDQxNg==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r439384416", "bodyText": "Done", "author": "probakowski", "createdAt": "2020-06-12T12:19:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3Mzg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3NjA0OA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r437376048", "bodyText": "Maybe add a unit test for this method to IndexNameExpressionResolverTests?", "author": "martijnvg", "createdAt": "2020-06-09T12:33:23Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java", "diffHunk": "@@ -117,6 +117,15 @@\n         return concreteIndexNames(context, indexExpressions);\n     }\n \n+    public List<String> dataStreamNames(ClusterState state, IndicesOptions options, String... indexExpressions) {", "originalCommit": "e51533f5ef320be6391ea790fe5eb15191a50f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM4MzE1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r439383151", "bodyText": "Done", "author": "probakowski", "createdAt": "2020-06-12T12:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3NjA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM4MjI0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r437382245", "bodyText": "Maybe keep this test and just removing the mentioned lines? Or assume that during a restore global state is loaded.\nSo that we ensure no global state is loaded when creating a snapshot or using get snapshot api and snapshot status api?", "author": "martijnvg", "createdAt": "2020-06-09T12:43:32Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/snapshots/MetadataLoadingDuringSnapshotRestoreIT.java", "diffHunk": "@@ -1,217 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.snapshots;\n-\n-import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n-import org.elasticsearch.action.admin.cluster.snapshots.get.GetSnapshotsResponse;\n-import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n-import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n-import org.elasticsearch.action.support.PlainActionFuture;\n-import org.elasticsearch.cluster.metadata.IndexMetadata;\n-import org.elasticsearch.cluster.metadata.Metadata;\n-import org.elasticsearch.cluster.metadata.RepositoryMetadata;\n-import org.elasticsearch.cluster.service.ClusterService;\n-import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n-import org.elasticsearch.env.Environment;\n-import org.elasticsearch.plugins.Plugin;\n-import org.elasticsearch.repositories.IndexId;\n-import org.elasticsearch.repositories.RepositoriesService;\n-import org.elasticsearch.repositories.Repository;\n-import org.elasticsearch.repositories.RepositoryData;\n-import org.elasticsearch.rest.RestStatus;\n-import org.elasticsearch.snapshots.mockstore.MockRepository;\n-\n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n-import static org.hamcrest.Matchers.equalTo;\n-import static org.hamcrest.Matchers.hasSize;\n-import static org.hamcrest.Matchers.instanceOf;\n-import static org.hamcrest.Matchers.nullValue;\n-\n-/**\n- * This class tests whether global and index metadata are only loaded from the repository when needed.\n-*/\n-public class MetadataLoadingDuringSnapshotRestoreIT extends AbstractSnapshotIntegTestCase {\n-\n-    @Override\n-    protected Collection<Class<? extends Plugin>> nodePlugins() {\n-        /// This test uses a snapshot/restore plugin implementation that\n-        // counts the number of times metadata are loaded\n-        return Collections.singletonList(CountingMockRepositoryPlugin.class);\n-    }\n-\n-    public void testWhenMetadataAreLoaded() throws Exception {\n-        createIndex(\"docs\");\n-        indexRandom(true,\n-            client().prepareIndex(\"docs\").setId(\"1\").setSource(\"rank\", 1),\n-            client().prepareIndex(\"docs\").setId(\"2\").setSource(\"rank\", 2),\n-            client().prepareIndex(\"docs\").setId(\"3\").setSource(\"rank\", 3),\n-            client().prepareIndex(\"others\").setSource(\"rank\", 4),\n-            client().prepareIndex(\"others\").setSource(\"rank\", 5));\n-\n-        createRepository(\"repository\", CountingMockRepositoryPlugin.TYPE, randomRepoPath());\n-\n-        // Creating a snapshot does not load any metadata\n-        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot(\"repository\", \"snap\")\n-                                                                                    .setIncludeGlobalState(true)\n-                                                                                    .setWaitForCompletion(true)\n-                                                                                    .get();\n-        assertThat(createSnapshotResponse.getSnapshotInfo().failedShards(), equalTo(0));\n-        assertThat(createSnapshotResponse.getSnapshotInfo().status(), equalTo(RestStatus.OK));\n-        assertGlobalMetadataLoads(\"snap\", 0);\n-        assertIndexMetadataLoads(\"snap\", \"docs\", 0);\n-        assertIndexMetadataLoads(\"snap\", \"others\", 0);\n-\n-        // Getting a snapshot does not load any metadata\n-        GetSnapshotsResponse getSnapshotsResponse =\n-            client().admin().cluster().prepareGetSnapshots(\"repository\").addSnapshots(\"snap\").setVerbose(randomBoolean()).get();\n-        assertThat(getSnapshotsResponse.getSnapshots(\"repository\"), hasSize(1));\n-        assertGlobalMetadataLoads(\"snap\", 0);\n-        assertIndexMetadataLoads(\"snap\", \"docs\", 0);\n-        assertIndexMetadataLoads(\"snap\", \"others\", 0);\n-\n-        // Getting the status of a snapshot loads indices metadata but not global metadata\n-        SnapshotsStatusResponse snapshotStatusResponse =\n-            client().admin().cluster().prepareSnapshotStatus(\"repository\").setSnapshots(\"snap\").get();\n-        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1));\n-        assertGlobalMetadataLoads(\"snap\", 0);\n-        assertIndexMetadataLoads(\"snap\", \"docs\", 1);\n-        assertIndexMetadataLoads(\"snap\", \"others\", 1);\n-\n-        assertAcked(client().admin().indices().prepareDelete(\"docs\", \"others\"));\n-\n-        // Restoring a snapshot loads indices metadata but not the global state\n-        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot(\"repository\", \"snap\")\n-                                                                                    .setWaitForCompletion(true)\n-                                                                                    .get();\n-        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0));\n-        assertGlobalMetadataLoads(\"snap\", 0);\n-        assertIndexMetadataLoads(\"snap\", \"docs\", 2);\n-        assertIndexMetadataLoads(\"snap\", \"others\", 2);\n-\n-        assertAcked(client().admin().indices().prepareDelete(\"docs\"));\n-\n-        // Restoring a snapshot with selective indices loads only required index metadata\n-        restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot(\"repository\", \"snap\")\n-                                                            .setIndices(\"docs\")\n-                                                            .setWaitForCompletion(true)\n-                                                            .get();\n-        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0));\n-        assertGlobalMetadataLoads(\"snap\", 0);\n-        assertIndexMetadataLoads(\"snap\", \"docs\", 3);\n-        assertIndexMetadataLoads(\"snap\", \"others\", 2);\n-\n-        assertAcked(client().admin().indices().prepareDelete(\"docs\", \"others\"));\n-\n-        // Restoring a snapshot including the global state loads it with the index metadata\n-        restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot(\"repository\", \"snap\")\n-            .setIndices(\"docs\", \"oth*\")\n-            .setRestoreGlobalState(true)\n-            .setWaitForCompletion(true)\n-            .get();\n-        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0));\n-        assertGlobalMetadataLoads(\"snap\", 1);\n-        assertIndexMetadataLoads(\"snap\", \"docs\", 4);\n-        assertIndexMetadataLoads(\"snap\", \"others\", 3);", "originalCommit": "e51533f5ef320be6391ea790fe5eb15191a50f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM4MzMyMg==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r439383322", "bodyText": "Yes, it was silly of me to remove the test completely, I restored it and modified only required parts", "author": "probakowski", "createdAt": "2020-06-12T12:16:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM4MjI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM4NzI3NA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r437387274", "bodyText": "Maybe adjust SnapshotsInProgressSerializationTests, so that a randomly generated instance also contains randomly a list of data stream names.", "author": "martijnvg", "createdAt": "2020-06-09T12:51:36Z", "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -56,6 +56,7 @@\n public class SnapshotsInProgress extends AbstractNamedDiffable<Custom> implements Custom {", "originalCommit": "e51533f5ef320be6391ea790fe5eb15191a50f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM5NDk1NA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r439394954", "bodyText": "Done", "author": "probakowski", "createdAt": "2020-06-12T12:42:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM4NzI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQwNDQxNg==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r437404416", "bodyText": "NIT: Maybe refactor this a little cleaner to:\nfinal  List<String> dataStreams;\nif (in.getVersion().onOrAfter(DATA_STREAMS_IN_SNAPSHOT)){\n                dataStreams = Arrays.asList(in.readStringArray());\n} else {\n  dataStreams = Collections.emptyList();\n}", "author": "original-brownbear", "createdAt": "2020-06-09T13:11:01Z", "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -531,11 +540,16 @@ public SnapshotsInProgress(StreamInput in) throws IOException {\n                 // generations.\n                 version = in.readBoolean() ? SnapshotsService.SHARD_GEN_IN_REPO_DATA_VERSION : SnapshotsService.OLD_SNAPSHOT_FORMAT;\n             }\n+            List<String> dataStreams = Collections.emptyList();", "originalCommit": "e51533f5ef320be6391ea790fe5eb15191a50f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM4MzQ0OA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r439383448", "bodyText": "Done", "author": "probakowski", "createdAt": "2020-06-12T12:17:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQwNDQxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQwNTA3MA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r437405070", "bodyText": "You can just use writeStringCollection no need to go through the array round trip.", "author": "original-brownbear", "createdAt": "2020-06-09T13:11:59Z", "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -573,6 +587,9 @@ public void writeTo(StreamOutput out) throws IOException {\n             } else {\n                 out.writeBoolean(SnapshotsService.useShardGenerations(entry.version));\n             }\n+            if (out.getVersion().onOrAfter(DATA_STREAMS_IN_SNAPSHOT)) {\n+                out.writeStringArray(entry.dataStreams.toArray(new String[0]));", "originalCommit": "e51533f5ef320be6391ea790fe5eb15191a50f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM4MzY1MA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r439383650", "bodyText": "thanks for suggestion, I've missed that method", "author": "probakowski", "createdAt": "2020-06-12T12:17:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQwNTA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQwNTM2MA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r437405360", "bodyText": "use in.readStringList", "author": "original-brownbear", "createdAt": "2020-06-09T13:12:26Z", "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -531,11 +540,16 @@ public SnapshotsInProgress(StreamInput in) throws IOException {\n                 // generations.\n                 version = in.readBoolean() ? SnapshotsService.SHARD_GEN_IN_REPO_DATA_VERSION : SnapshotsService.OLD_SNAPSHOT_FORMAT;\n             }\n+            List<String> dataStreams = Collections.emptyList();\n+            if (in.getVersion().onOrAfter(DATA_STREAMS_IN_SNAPSHOT)){\n+                dataStreams = Arrays.asList(in.readStringArray());", "originalCommit": "e51533f5ef320be6391ea790fe5eb15191a50f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM4Mzc1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r439383753", "bodyText": "\ud83d\udc4d", "author": "probakowski", "createdAt": "2020-06-12T12:17:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQwNTM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQwNzI1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r437407253", "bodyText": "This looks broken, we should always be able to read global metadata (we always write at least a dummy instance of it to the repository). If we fail here, then that means the snapshot is corrupted and we should throw right away and can simplify the below code accordingly.", "author": "original-brownbear", "createdAt": "2020-06-09T13:15:16Z", "path": "server/src/main/java/org/elasticsearch/snapshots/RestoreService.java", "diffHunk": "@@ -201,12 +205,36 @@ public void restoreSnapshot(final RestoreSnapshotRequest request, final ActionLi\n                 // Make sure that we can restore from this snapshot\n                 validateSnapshotRestorable(repositoryName, snapshotInfo);\n \n+                SnapshotException snapshotException = null;\n+                Metadata globalMetadata = null;\n                 // Resolve the indices from the snapshot that need to be restored\n-                final List<String> indicesInSnapshot = filterIndices(snapshotInfo.indices(), request.indices(), request.indicesOptions());\n+                try {\n+                    globalMetadata = repository.getSnapshotGlobalMetadata(snapshotId);\n+                } catch (SnapshotException e) {\n+                    snapshotException = e;", "originalCommit": "e51533f5ef320be6391ea790fe5eb15191a50f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM5MDQzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r439390435", "bodyText": "I followed SharedClusterSnapshotRestoreIT.testRestoreSnapshotWithCorruptedGlobalState. It targets situation when global metadata is broken, not empty.\nIt makes sense to me that even when global metadata is broken we should be able to restore indices and data for rescue purposes. If we throw here (as it was before) we can't do that even when we don't care about data streams. WDYT?", "author": "probakowski", "createdAt": "2020-06-12T12:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQwNzI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4MzAyMg==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r439483022", "bodyText": "Ah I see ... but then we should only try to load the global metadata if either includeGlobalState() or data streams have been requested for restore specifically?\nThat way we don't create some new weird half-working state where indices are restored but data streams aren't when both are requested. Also, we save loading the global metadata needlessly this way.\nI guess that needs a data streams parameter on the restore request or at least a flag data streams yes/no?\nI don't think we should introduce an API here that would return a 200 even though data streams couldn't be restored. No one ever looks at the logs :)", "author": "original-brownbear", "createdAt": "2020-06-12T15:18:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQwNzI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYyNDgyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r439624825", "bodyText": "Ok, I took another turn on that, storing data streams' names in userMeta (similarly as SLM stores policy name there).\nIt simplifies things greatly (no need to change Entry and its serialization etc) and saves us from loading global state on every restore (we need it only on restoring data streams).\nIt does enlarge SnapshotInfo, it should not be that bad though as they are only names not whole data streams.\nLet me know what do you think?", "author": "probakowski", "createdAt": "2020-06-12T20:20:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQwNzI1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxMTg4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r437411886", "bodyText": "This look potentially broken. can we remove a data stream while it is in the process of being snapshotted? (looks like it) If so, then we're failing without error if someone concurrently removes (while the data nodes are busy doing their work) and before we get here it?", "author": "original-brownbear", "createdAt": "2020-06-09T13:22:06Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -355,6 +365,10 @@ private static Metadata metadataForSnapshot(SnapshotsInProgress.Entry snapshot,\n                     builder.put(indexMetadata, false);\n                 }\n             }\n+\n+            Map<String, DataStream> dataStreams = new HashMap<>(metadata.dataStreams());\n+            dataStreams.keySet().removeIf(ds -> snapshot.dataStreams().contains(ds) == false);", "originalCommit": "e51533f5ef320be6391ea790fe5eb15191a50f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM4Mzk5NA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r439383994", "bodyText": "You are right, I changed it to similar check as above for indices", "author": "probakowski", "createdAt": "2020-06-12T12:18:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxMTg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxMzc0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r437413747", "bodyText": "We should assert that we don't have any data streams if we're writing to an older version and must make sure to not start snapshots that include data streams as long as there's old version nodes in the cluster that don't understand data stream snapshots.", "author": "original-brownbear", "createdAt": "2020-06-09T13:24:46Z", "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -573,6 +587,9 @@ public void writeTo(StreamOutput out) throws IOException {\n             } else {\n                 out.writeBoolean(SnapshotsService.useShardGenerations(entry.version));\n             }\n+            if (out.getVersion().onOrAfter(DATA_STREAMS_IN_SNAPSHOT)) {", "originalCommit": "e51533f5ef320be6391ea790fe5eb15191a50f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM4NDE1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r439384152", "bodyText": "Added required check", "author": "probakowski", "createdAt": "2020-06-12T12:18:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxMzc0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyNDY0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r437424649", "bodyText": "Minor, but having gone through the exercise of changing the backing index naming scheme, it would be nice to use DataStream::getDefaultBackingIndexName here so any future changes are automatically picked up.", "author": "danhermann", "createdAt": "2020-06-09T13:39:57Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/snapshots/DataStreamsSnapshotsIT.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import org.elasticsearch.ResourceNotFoundException;\n+import org.elasticsearch.action.DocWriteRequest;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.get.GetSnapshotsResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.admin.indices.datastream.CreateDataStreamAction;\n+import org.elasticsearch.action.admin.indices.datastream.DeleteDataStreamAction;\n+import org.elasticsearch.action.admin.indices.datastream.GetDataStreamAction;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.indices.DataStreamIT;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.transport.RemoteTransportException;\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+\n+public class DataStreamsSnapshotsIT extends AbstractSnapshotIntegTestCase {\n+\n+    public void testSnapshotAndRestore() throws Exception {\n+        Client client = client();\n+\n+        Path location = randomRepoPath();\n+        createRepository(\"repo\", \"fs\", location);\n+\n+        DataStreamIT.createIndexTemplate(\"t1\", \"@timestamp\", \"ds\", \"other-ds\");\n+\n+        CreateDataStreamAction.Request request = new CreateDataStreamAction.Request(\"ds\");\n+        AcknowledgedResponse response = client.admin().indices().createDataStream(request).get();\n+        assertTrue(response.isAcknowledged());\n+\n+        request = new CreateDataStreamAction.Request(\"other-ds\");\n+        response = client.admin().indices().createDataStream(request).get();\n+        assertTrue(response.isAcknowledged());\n+\n+        Map<String, Integer> source = Collections.singletonMap(\"@timestamp\", 123);\n+        IndexResponse indexResponse = client.prepareIndex(\"ds\")\n+            .setOpType(DocWriteRequest.OpType.CREATE)\n+            .setSource(source)\n+            .get();\n+        assertEquals(DocWriteResponse.Result.CREATED, indexResponse.getResult());\n+\n+        CreateSnapshotResponse createSnapshotResponse = client.admin().cluster()\n+            .prepareCreateSnapshot(\"repo\", \"snap\")\n+            .setWaitForCompletion(true)\n+            .setIndices(\"ds\")\n+            .setIncludeGlobalState(false)\n+            .get();\n+\n+        RestStatus status = createSnapshotResponse.getSnapshotInfo().status();\n+        assertEquals(RestStatus.OK, status);\n+\n+        GetSnapshotsResponse snapshot = client.admin().cluster().prepareGetSnapshots(\"repo\").setSnapshots(\"snap\").get();\n+        List<SnapshotInfo> snap = snapshot.getSnapshots(\"repo\");\n+        assertEquals(1, snap.size());\n+        assertEquals(Collections.singletonList(\".ds-ds-000001\"), snap.get(0).indices());", "originalCommit": "e51533f5ef320be6391ea790fe5eb15191a50f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM4NDI3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r439384276", "bodyText": "Good suggestion, I've changed the code accordingly", "author": "probakowski", "createdAt": "2020-06-12T12:18:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyNDY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyNDg1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r437424856", "bodyText": "same here and a couple other places below", "author": "danhermann", "createdAt": "2020-06-09T13:40:12Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/snapshots/DataStreamsSnapshotsIT.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import org.elasticsearch.ResourceNotFoundException;\n+import org.elasticsearch.action.DocWriteRequest;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.get.GetSnapshotsResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.admin.indices.datastream.CreateDataStreamAction;\n+import org.elasticsearch.action.admin.indices.datastream.DeleteDataStreamAction;\n+import org.elasticsearch.action.admin.indices.datastream.GetDataStreamAction;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.indices.DataStreamIT;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.transport.RemoteTransportException;\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+\n+public class DataStreamsSnapshotsIT extends AbstractSnapshotIntegTestCase {\n+\n+    public void testSnapshotAndRestore() throws Exception {\n+        Client client = client();\n+\n+        Path location = randomRepoPath();\n+        createRepository(\"repo\", \"fs\", location);\n+\n+        DataStreamIT.createIndexTemplate(\"t1\", \"@timestamp\", \"ds\", \"other-ds\");\n+\n+        CreateDataStreamAction.Request request = new CreateDataStreamAction.Request(\"ds\");\n+        AcknowledgedResponse response = client.admin().indices().createDataStream(request).get();\n+        assertTrue(response.isAcknowledged());\n+\n+        request = new CreateDataStreamAction.Request(\"other-ds\");\n+        response = client.admin().indices().createDataStream(request).get();\n+        assertTrue(response.isAcknowledged());\n+\n+        Map<String, Integer> source = Collections.singletonMap(\"@timestamp\", 123);\n+        IndexResponse indexResponse = client.prepareIndex(\"ds\")\n+            .setOpType(DocWriteRequest.OpType.CREATE)\n+            .setSource(source)\n+            .get();\n+        assertEquals(DocWriteResponse.Result.CREATED, indexResponse.getResult());\n+\n+        CreateSnapshotResponse createSnapshotResponse = client.admin().cluster()\n+            .prepareCreateSnapshot(\"repo\", \"snap\")\n+            .setWaitForCompletion(true)\n+            .setIndices(\"ds\")\n+            .setIncludeGlobalState(false)\n+            .get();\n+\n+        RestStatus status = createSnapshotResponse.getSnapshotInfo().status();\n+        assertEquals(RestStatus.OK, status);\n+\n+        GetSnapshotsResponse snapshot = client.admin().cluster().prepareGetSnapshots(\"repo\").setSnapshots(\"snap\").get();\n+        List<SnapshotInfo> snap = snapshot.getSnapshots(\"repo\");\n+        assertEquals(1, snap.size());\n+        assertEquals(Collections.singletonList(\".ds-ds-000001\"), snap.get(0).indices());\n+\n+        assertTrue(client.admin().indices().deleteDataStream(new DeleteDataStreamAction.Request(\"ds\")).get().isAcknowledged());\n+\n+        RestoreSnapshotResponse restoreSnapshotResponse = client.admin().cluster()\n+            .prepareRestoreSnapshot(\"repo\", \"snap\")\n+            .setWaitForCompletion(true)\n+            .setIndices(\"ds\")\n+            .get();\n+\n+        assertEquals(1, restoreSnapshotResponse.getRestoreInfo().successfulShards());\n+\n+        GetResponse getResponse = client.prepareGet(\".ds-ds-000001\", indexResponse.getId()).get();\n+        assertEquals(source, getResponse.getSourceAsMap());\n+\n+        GetDataStreamAction.Response ds = client.admin().indices().getDataStreams(new GetDataStreamAction.Request(\"ds\")).get();\n+        assertEquals(1, ds.getDataStreams().size());\n+        assertEquals(1, ds.getDataStreams().get(0).getIndices().size());\n+        assertEquals(\".ds-ds-000001\", ds.getDataStreams().get(0).getIndices().get(0).getName());", "originalCommit": "e51533f5ef320be6391ea790fe5eb15191a50f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM4NDMyNA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r439384324", "bodyText": "Done", "author": "probakowski", "createdAt": "2020-06-12T12:18:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyNDg1Ng=="}], "type": "inlineReview"}, {"oid": "b21f6cb8821cdc81e4551da1b11d8defb7885673", "url": "https://github.com/elastic/elasticsearch/commit/b21f6cb8821cdc81e4551da1b11d8defb7885673", "message": "tests", "committedDate": "2020-06-10T09:37:10Z", "type": "commit"}, {"oid": "4a2a098532e0f9babf4d3a43cd50b7d5090905f5", "url": "https://github.com/elastic/elasticsearch/commit/4a2a098532e0f9babf4d3a43cd50b7d5090905f5", "message": "min snapshot version required", "committedDate": "2020-06-10T20:35:41Z", "type": "commit"}, {"oid": "9628d0e6620b3424e0d502024740f73e81ce4d98", "url": "https://github.com/elastic/elasticsearch/commit/9628d0e6620b3424e0d502024740f73e81ce4d98", "message": "review comments", "committedDate": "2020-06-12T11:43:04Z", "type": "commit"}, {"oid": "a1cd151d92d289d1fc3c8fdf9aba85d8a6653eba", "url": "https://github.com/elastic/elasticsearch/commit/a1cd151d92d289d1fc3c8fdf9aba85d8a6653eba", "message": "Merge branch 'master' into datastreams-snapshots", "committedDate": "2020-06-12T12:14:49Z", "type": "commit"}, {"oid": "8b11dfe63a6dd058466fd9e9ab7786fcf2e08eff", "url": "https://github.com/elastic/elasticsearch/commit/8b11dfe63a6dd058466fd9e9ab7786fcf2e08eff", "message": "Merge remote-tracking branch 'origin/master' into datastreams-snapshots", "committedDate": "2020-06-12T12:26:45Z", "type": "commit"}, {"oid": "57fc7e0685129cb56148e0f772d475cc9738e962", "url": "https://github.com/elastic/elasticsearch/commit/57fc7e0685129cb56148e0f772d475cc9738e962", "message": "test change", "committedDate": "2020-06-12T12:42:19Z", "type": "commit"}, {"oid": "b143137d19abb5af02fe547de3265f54065ebdd2", "url": "https://github.com/elastic/elasticsearch/commit/b143137d19abb5af02fe547de3265f54065ebdd2", "message": "store data streams in user metadata", "committedDate": "2020-06-12T20:06:46Z", "type": "commit"}, {"oid": "4161e97a972dda4c8d2e9ec7369ae3b3b9ce52ee", "url": "https://github.com/elastic/elasticsearch/commit/4161e97a972dda4c8d2e9ec7369ae3b3b9ce52ee", "message": "Merge remote-tracking branch 'origin/master' into datastreams-snapshots", "committedDate": "2020-06-12T20:08:00Z", "type": "commit"}, {"oid": "7f92d777aafbd24776740b550e12ff15802e8946", "url": "https://github.com/elastic/elasticsearch/commit/7f92d777aafbd24776740b550e12ff15802e8946", "message": "reverted unneeded changes", "committedDate": "2020-06-12T20:12:48Z", "type": "commit"}, {"oid": "6082bb7b385f3fe232337acd0100312a5b9e6161", "url": "https://github.com/elastic/elasticsearch/commit/6082bb7b385f3fe232337acd0100312a5b9e6161", "message": "reverted unneeded changes", "committedDate": "2020-06-12T20:13:55Z", "type": "commit"}, {"oid": "1e07b3428dbc987844df657407296ab64bd6307e", "url": "https://github.com/elastic/elasticsearch/commit/1e07b3428dbc987844df657407296ab64bd6307e", "message": "Merge branch 'master' into datastreams-snapshots", "committedDate": "2020-06-13T05:38:05Z", "type": "commit"}, {"oid": "e9225583d27657228ef2f6bfa2a7b18d35db4c66", "url": "https://github.com/elastic/elasticsearch/commit/e9225583d27657228ef2f6bfa2a7b18d35db4c66", "message": "handle null usermeta", "committedDate": "2020-06-13T20:25:27Z", "type": "commit"}, {"oid": "4e9195ae6f9f63901e93bb1682a9b64b11a8ecfa", "url": "https://github.com/elastic/elasticsearch/commit/4e9195ae6f9f63901e93bb1682a9b64b11a8ecfa", "message": "checkstyle fix", "committedDate": "2020-06-13T20:45:27Z", "type": "commit"}, {"oid": "f611d5beeecda9eb43057f1ce82eff5fe49da3ae", "url": "https://github.com/elastic/elasticsearch/commit/f611d5beeecda9eb43057f1ce82eff5fe49da3ae", "message": "Merge branch 'master' into datastreams-snapshots", "committedDate": "2020-06-14T13:31:44Z", "type": "commit"}, {"oid": "3955ee46c00db519ae3cefc039f0a609cc6daada", "url": "https://github.com/elastic/elasticsearch/commit/3955ee46c00db519ae3cefc039f0a609cc6daada", "message": "test fix", "committedDate": "2020-06-15T07:11:38Z", "type": "commit"}, {"oid": "858a6da67c176a54ed3822a6918f12160490678f", "url": "https://github.com/elastic/elasticsearch/commit/858a6da67c176a54ed3822a6918f12160490678f", "message": "don't set userMeta if not needed", "committedDate": "2020-06-15T07:11:38Z", "type": "commit"}, {"oid": "fc7da85a463bd93f7c0f75c46b7ee86c324e8fd8", "url": "https://github.com/elastic/elasticsearch/commit/fc7da85a463bd93f7c0f75c46b7ee86c324e8fd8", "message": "fix npe in SnapshotService", "committedDate": "2020-06-15T07:27:00Z", "type": "commit"}, {"oid": "78ec5e7237e7b0fb8fc21917f8b95af7300696a4", "url": "https://github.com/elastic/elasticsearch/commit/78ec5e7237e7b0fb8fc21917f8b95af7300696a4", "message": "test fix", "committedDate": "2020-06-15T08:09:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMwMDI1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r440300252", "bodyText": "What code guarantees that we don't trip this assertion? It seems to me I can simply remove a data stream while a non-partial snapshot is running right now can't I?", "author": "original-brownbear", "createdAt": "2020-06-15T16:29:50Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -354,6 +371,22 @@ private static Metadata metadataForSnapshot(SnapshotsInProgress.Entry snapshot,\n                     builder.put(indexMetadata, false);\n                 }\n             }\n+\n+            if (snapshot.userMetadata() != null && snapshot.userMetadata().containsKey(DataStream.DATA_STREAMS_METADATA_FIELD)) {\n+                @SuppressWarnings(\"unchecked\")\n+                List<String> dataStreamNames = (List<String>) snapshot.userMetadata().get(DataStream.DATA_STREAMS_METADATA_FIELD);\n+                Map<String, DataStream> dataStreams = new HashMap<>();\n+                for (String dataStreamName : dataStreamNames) {\n+                    DataStream dataStream = metadata.dataStreams().get(dataStreamName);\n+                    if (dataStream == null) {\n+                        assert snapshot.partial() : \"Data stream [\" + dataStreamName +", "originalCommit": "78ec5e7237e7b0fb8fc21917f8b95af7300696a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwNTk2OA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r440605968", "bodyText": "Should the delete data stream api then check for snapshots that are in progress and then fail is data stream to be deleted is being snapshotted? Similar to what is done in the delete index api for indices that are being snapshotted?", "author": "martijnvg", "createdAt": "2020-06-16T06:07:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMwMDI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwNjg5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r440606896", "bodyText": "Yea, I'd say so. We treat data streams and indices pretty much the same way in snapshot APIs here so being consistent here makes sense to me.", "author": "original-brownbear", "createdAt": "2020-06-16T06:09:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMwMDI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwODYyNA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r440608624", "bodyText": "I think that this can be done in a followup?", "author": "martijnvg", "createdAt": "2020-06-16T06:14:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMwMDI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYxMDg2OA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r440610868", "bodyText": "I guess so but this assertion can trip until it's addressed and it's not a great place for the code to be in. We could throw an exception here then in place of the assertion and add a TODO but we are creating a situation where deleting data streams concurrently can either quietly corrupt snapshots or cause them to fail at the very last step of snapshotting (the later option seems ok to me for now).", "author": "original-brownbear", "createdAt": "2020-06-16T06:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMwMDI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYyMzQ5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r440623496", "bodyText": "I see, then it is better to address this issue in this PR.", "author": "martijnvg", "createdAt": "2020-06-16T06:52:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMwMDI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgwOTY2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r441809663", "bodyText": "I've switched implementation to storing names of data streams in SnapshotInfo and added check in delete API for data streams being snapshotted.\nI'm not sure if we still need to add check for min node version(both in SnapshotsService and SnapshotInProgress), as you pointed out we won't be able to create any data stream in mixed cluster so we should never have a situation when we write data that can't be understood by any node.\nPlease let me know what do you think?", "author": "probakowski", "createdAt": "2020-06-17T20:20:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMwMDI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYxMTk1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r440611952", "bodyText": "Another thing I just noticed, we will have to update the list of data streams that gets written to SnapshotInfo down the line in case of partial snapshots (if one was concurrently removed) won't we? Currently partial snapshots would list data streams in their SnapshotInfo that may not be part of the snapshot because they were concurrently deleted?", "author": "original-brownbear", "createdAt": "2020-06-16T06:23:28Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -354,6 +371,22 @@ private static Metadata metadataForSnapshot(SnapshotsInProgress.Entry snapshot,\n                     builder.put(indexMetadata, false);\n                 }\n             }\n+\n+            if (snapshot.userMetadata() != null && snapshot.userMetadata().containsKey(DataStream.DATA_STREAMS_METADATA_FIELD)) {\n+                @SuppressWarnings(\"unchecked\")\n+                List<String> dataStreamNames = (List<String>) snapshot.userMetadata().get(DataStream.DATA_STREAMS_METADATA_FIELD);\n+                Map<String, DataStream> dataStreams = new HashMap<>();\n+                for (String dataStreamName : dataStreamNames) {\n+                    DataStream dataStream = metadata.dataStreams().get(dataStreamName);\n+                    if (dataStream == null) {\n+                        assert snapshot.partial() : \"Data stream [\" + dataStreamName +", "originalCommit": "78ec5e7237e7b0fb8fc21917f8b95af7300696a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgwNzU5MA==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r441807590", "bodyText": "The list is updated already, SnapshotInfo is created by the repository from data streams included in the metadata, not from the list in Entry", "author": "probakowski", "createdAt": "2020-06-17T20:16:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYxMTk1Mg=="}], "type": "inlineReview"}, {"oid": "0881bf7cf3c4b5aecd80787910ef561a99f3e909", "url": "https://github.com/elastic/elasticsearch/commit/0881bf7cf3c4b5aecd80787910ef561a99f3e909", "message": "Store data streams names in SnapshotInfo", "committedDate": "2020-06-16T11:20:35Z", "type": "commit"}, {"oid": "97dc7f079be16879ab31316822074058a3bd8884", "url": "https://github.com/elastic/elasticsearch/commit/97dc7f079be16879ab31316822074058a3bd8884", "message": "fixed SnapshotInfo.equals", "committedDate": "2020-06-16T21:10:08Z", "type": "commit"}, {"oid": "304e39a8158a625444edddca8f2757d005baf83d", "url": "https://github.com/elastic/elasticsearch/commit/304e39a8158a625444edddca8f2757d005baf83d", "message": "fix SnapshotService", "committedDate": "2020-06-17T09:31:03Z", "type": "commit"}, {"oid": "bbc727e74792e1fdfd61039e40c15e40c6311596", "url": "https://github.com/elastic/elasticsearch/commit/bbc727e74792e1fdfd61039e40c15e40c6311596", "message": "Prevent delete snapshotting data stream", "committedDate": "2020-06-17T12:01:20Z", "type": "commit"}, {"oid": "0d65b34219ffedf53c4209a1e36bb3c99392133e", "url": "https://github.com/elastic/elasticsearch/commit/0d65b34219ffedf53c4209a1e36bb3c99392133e", "message": "add SLM test", "committedDate": "2020-06-18T09:10:49Z", "type": "commit"}, {"oid": "569e848d2b92a3b1ec86113ec13b4d2d20374226", "url": "https://github.com/elastic/elasticsearch/commit/569e848d2b92a3b1ec86113ec13b4d2d20374226", "message": "Merge branch 'master' into datastreams-snapshots", "committedDate": "2020-06-18T14:26:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM0MDI0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r442340246", "bodyText": "I think this would benefit from a real integration test like we have for indices with org.elasticsearch.snapshots.SharedClusterSnapshotRestoreIT#testCloseOrDeleteIndexDuringSnapshot. There's lots of things that can go wrong with changes to the snapshot code that this test won't catch. I think it's pretty easy to create an analogous test to org.elasticsearch.snapshots.SharedClusterSnapshotRestoreIT#testCloseOrDeleteIndexDuringSnapshot for data streams right?", "author": "original-brownbear", "createdAt": "2020-06-18T16:07:54Z", "path": "server/src/test/java/org/elasticsearch/action/admin/indices/datastream/DeleteDataStreamRequestTests.java", "diffHunk": "@@ -85,6 +90,31 @@ public void testDeleteDataStream() {\n         }\n     }\n \n+    public void testDeleteSnapshottingDataStream() {", "originalCommit": "569e848d2b92a3b1ec86113ec13b4d2d20374226", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwODY0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r442508647", "bodyText": "You're right, I've added SharedClusterSnapshotRestoreIT.testDeleteDataStreamDuringSnapshot", "author": "probakowski", "createdAt": "2020-06-18T21:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM0MDI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1NjczNw==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r442356737", "bodyText": "This can be reverted again I think", "author": "original-brownbear", "createdAt": "2020-06-18T16:34:05Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -194,7 +195,8 @@ public void createSnapshot(final CreateSnapshotRequest request, final ActionList\n             return;\n         }\n         final Snapshot snapshot = new Snapshot(repositoryName, snapshotId);\n-        final Map<String, Object> userMeta = repository.adaptUserMetadata(request.userMetadata());\n+\n+        Map<String, Object> userMeta = repository.adaptUserMetadata(request.userMetadata());", "originalCommit": "569e848d2b92a3b1ec86113ec13b4d2d20374226", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNzgwMw==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r442507803", "bodyText": "Yep, reverted", "author": "probakowski", "createdAt": "2020-06-18T21:17:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1NjczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1Nzk4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r442357989", "bodyText": "This comment does not apply?", "author": "original-brownbear", "createdAt": "2020-06-18T16:36:17Z", "path": "x-pack/plugin/ilm/qa/multi-node/src/test/java/org/elasticsearch/xpack/slm/SnapshotLifecycleRestIT.java", "diffHunk": "@@ -461,6 +465,49 @@ public void testBasicTimeBasedRetention() throws Exception {\n         }\n     }\n \n+    public void testDataStreams() throws Exception {\n+        String dataStreamName = \"ds-test\";\n+        String repoId = \"ds-repo\";\n+        String policyName = \"ds-policy\";\n+\n+        String mapping = \"{\\n\" +\n+            \"      \\\"properties\\\": {\\n\" +\n+            \"        \\\"@timestamp\\\": {\\n\" +\n+            \"          \\\"type\\\": \\\"date\\\"\\n\" +\n+            \"        }\\n\" +\n+            \"      }\\n\" +\n+            \"    }\";\n+        Template template = new Template(null, new CompressedXContent(mapping), null);\n+        createComposableTemplate(client(), \"ds-template\", dataStreamName, template);\n+\n+        client().performRequest(new Request(\"PUT\", \"_data_stream/\" + dataStreamName));\n+\n+        // Create a snapshot repo\n+        initializeRepo(repoId);\n+\n+        // Create a policy with a retention period of 1 millisecond", "originalCommit": "569e848d2b92a3b1ec86113ec13b4d2d20374226", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNzg4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/57675#discussion_r442507886", "bodyText": "Yep, I've removed it", "author": "probakowski", "createdAt": "2020-06-18T21:17:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1Nzk4OQ=="}], "type": "inlineReview"}, {"oid": "c6ca14932f2053719ba2a2f000cfc59a2f6e76ea", "url": "https://github.com/elastic/elasticsearch/commit/c6ca14932f2053719ba2a2f000cfc59a2f6e76ea", "message": "pr comments", "committedDate": "2020-06-18T21:16:26Z", "type": "commit"}, {"oid": "e560d7e40de3b092b8702837520300eb841b6c28", "url": "https://github.com/elastic/elasticsearch/commit/e560d7e40de3b092b8702837520300eb841b6c28", "message": "test fix", "committedDate": "2020-06-18T22:03:01Z", "type": "commit"}]}