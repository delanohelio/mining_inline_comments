{"pr_number": 63542, "pr_title": "[ML] Wait for controller to respond to commands", "pr_createdAt": "2020-10-12T09:42:36Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/63542", "timeline": [{"oid": "aab801a296b4219ce34035960342c2e9deb6a2cb", "url": "https://github.com/elastic/elasticsearch/commit/aab801a296b4219ce34035960342c2e9deb6a2cb", "message": "[ML] Wait for controller to respond to commands\n\nThis change makes threads that send a command to the ML\ncontroller process wait for it to respond to the command.\nPreviously such threads would block until the command was\nsent, but not until it was actioned.  This was on the\nassumption that the sort of commands being sent would be\nactioned almost instantaneously, but that assumption has\nbeen shown to be false when anti-malware software is\nrunning.\n\nRelates elastic/ml-cpp#1520\nFixes #62823", "committedDate": "2020-10-12T09:35:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3ODU5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/63542#discussion_r503278591", "bodyText": "I am curious on locking on this and not on ourResponseTracker for the entire while loop.\nIf we lock on this, that means that any other command could not be processed.\nOur commands are always handled in a single thread and could NEVER be processed out of order correct? If they are ever processed out of order, this seems like it would cause a thread lock.", "author": "benwtrent", "createdAt": "2020-10-12T12:58:58Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/process/NativeController.java", "diffHunk": "@@ -152,4 +200,75 @@ public void stop() throws IOException {\n         // The C++ process will exit when it gets EOF on the command stream\n         commandStream.close();\n     }\n+\n+    private void setupResponseTracker(int commandId) {\n+        ResponseTracker tracker = new ResponseTracker();\n+        ResponseTracker previous = responseTrackers.put(commandId, tracker);\n+        assert previous == null;\n+    }\n+\n+    private void removeResponseTracker(int commandId) {\n+        responseTrackers.remove(commandId);\n+    }\n+\n+    private void awaitCompletion(int commandId) throws IOException, InterruptedException {\n+\n+        ResponseTracker ourResponseTracker = responseTrackers.get(commandId);\n+        assert ourResponseTracker != null;\n+\n+        // If our response has not been seen already (by another thread), parse messages under lock until it is seen.\n+        // This approach means that of all the threads waiting for controller responses, one is parsing the messages\n+        // on behalf of all of them, and the others are blocked.  When the thread that is parsing gets the response\n+        // it needs another thread will pick up the parsing.\n+        if (ourResponseTracker.hasResponded() == false) {\n+            synchronized (responseIteratorHolder) {", "originalCommit": "aab801a296b4219ce34035960342c2e9deb6a2cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQzMzc1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/63542#discussion_r503433757", "bodyText": "It's correct that at the moment the C++ always processes commands in order.  This may not always be the case though.\nIt's also true that in the future if two commands were processed out-of-order in the C++ then this Java code would delay one of the threads waiting for a response unnecessarily.  However, it wouldn't be a deadlock - it would just mean threads 1 and 2 would unblock on the response to command 1 (or disconnection of controller) even though thread 2 could have unblocked on the earlier response to command 2.\nSo some optimisation work could be done here if the C++ is ever modified to process commands out-of-order.\nThe actual parsing needs to synchronize on responseIteratorHolder, because only one thread can be parsing the stream at any time.  What could be done is that the other threads simply wait for their response latches on the assumption that the thread doing the parsing will count these down.  However, this is non-trivial, because if the thread doing the parsing has just decided that it can stop parsing but hasn't exited the synchronized block then no thread would be parsing.  So it would need more complex synchronization to ensure that the decision of one thread to wait for its latch instead of for the parser lock would need to be atomic with the thread currently holding the parser lock to decide to stop parsing (which is not the same as releasing the parser lock).  Rather than risk messing this up I went for the simpler approach.\nThe alternative is to have a dedicated thread for parsing responses like we do for most C++ outputs, but this seems wasteful in the case of controller where there is very low traffic and we'd be permanently hogging a thread for it.", "author": "droberts195", "createdAt": "2020-10-12T17:23:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3ODU5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ2NjMwMw==", "url": "https://github.com/elastic/elasticsearch/pull/63542#discussion_r503466303", "bodyText": "\ud83d\udc4d\nThanks for the additional information. It just wasn't obvious to me :D", "author": "benwtrent", "createdAt": "2020-10-12T18:30:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3ODU5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MDYxNw==", "url": "https://github.com/elastic/elasticsearch/pull/63542#discussion_r503260617", "bodyText": "Can you use the more standard [job_id] message format here and in the other logged warnings\nLOGGER.warn(\"[{}] Interrupted while launching autodetect\", job.getId());", "author": "davidkyle", "createdAt": "2020-10-12T12:27:48Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/process/autodetect/NativeAutodetectProcessFactory.java", "diffHunk": "@@ -127,6 +127,9 @@ void createNativeProcess(Job job, AutodetectParams autodetectParams, ProcessPipe\n                 autodetectBuilder.quantiles(autodetectParams.quantiles());\n             }\n             autodetectBuilder.build();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            LOGGER.warn(\"Interrupted while launching autodetect for job \" + job.getId());", "originalCommit": "aab801a296b4219ce34035960342c2e9deb6a2cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMwMDU5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/63542#discussion_r503300591", "bodyText": "I was matching the format of the existing message from a few lines below.  But I guess I can change the pre-existing ones too.", "author": "droberts195", "createdAt": "2020-10-12T13:35:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MDYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2NzU3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/63542#discussion_r503267579", "bodyText": "commandId is set in the first line of the synchronized block I don't see how it could ever be -1. Also will add a tracker to the map whatever the value of commandId", "author": "davidkyle", "createdAt": "2020-10-12T12:40:16Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/process/NativeController.java", "diffHunk": "@@ -110,19 +130,31 @@ public void startProcess(List<String> command) throws IOException {\n             throw new ElasticsearchException(msg);\n         }\n \n-        synchronized (commandStream) {\n-            LOGGER.debug(\"Starting process with command: \" + command);\n-            commandStream.write(START_COMMAND.getBytes(StandardCharsets.UTF_8));\n-            for (String arg : command) {\n+        int commandId = -1;\n+        try {\n+            synchronized (commandStream) {\n+                commandId = nextCommandId++;\n+                setupResponseTracker(commandId);\n+                LOGGER.debug(\"Command [{}]: starting process with command {}\", commandId, command);\n+                commandStream.write(Integer.toString(commandId).getBytes(StandardCharsets.UTF_8));\n                 commandStream.write('\\t');\n-                commandStream.write(arg.getBytes(StandardCharsets.UTF_8));\n+                commandStream.write(START_COMMAND.getBytes(StandardCharsets.UTF_8));\n+                for (String arg : command) {\n+                    commandStream.write('\\t');\n+                    commandStream.write(arg.getBytes(StandardCharsets.UTF_8));\n+                }\n+                commandStream.write('\\n');\n+                commandStream.flush();\n+            }\n+            awaitCompletion(commandId);\n+        } finally {\n+            if (commandId != -1) {", "originalCommit": "aab801a296b4219ce34035960342c2e9deb6a2cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI4NTg5MA==", "url": "https://github.com/elastic/elasticsearch/pull/63542#discussion_r503285890", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (commandId != -1) {\n          \n          \n            \n                        if (awaitCompletion) {", "author": "davidkyle", "createdAt": "2020-10-12T13:11:19Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/process/NativeController.java", "diffHunk": "@@ -137,13 +169,29 @@ public void killProcess(long pid) throws TimeoutException, IOException {\n             throw new ElasticsearchException(msg);\n         }\n \n-        synchronized (commandStream) {\n-            LOGGER.debug(\"Killing process with PID: \" + pid);\n-            commandStream.write(KILL_COMMAND.getBytes(StandardCharsets.UTF_8));\n-            commandStream.write('\\t');\n-            commandStream.write(Long.toString(pid).getBytes(StandardCharsets.UTF_8));\n-            commandStream.write('\\n');\n-            commandStream.flush();\n+        int commandId = -1;\n+        try {\n+            synchronized (commandStream) {\n+                commandId = nextCommandId++;\n+                if (awaitCompletion) {\n+                    setupResponseTracker(commandId);\n+                }\n+                LOGGER.debug(\"Command [{}]: killing process with PID [{}]\", commandId, pid);\n+                commandStream.write(Integer.toString(commandId).getBytes(StandardCharsets.UTF_8));\n+                commandStream.write('\\t');\n+                commandStream.write(KILL_COMMAND.getBytes(StandardCharsets.UTF_8));\n+                commandStream.write('\\t');\n+                commandStream.write(Long.toString(pid).getBytes(StandardCharsets.UTF_8));\n+                commandStream.write('\\n');\n+                commandStream.flush();\n+            }\n+            if (awaitCompletion) {\n+                awaitCompletion(commandId);\n+            }\n+        } finally {\n+            if (commandId != -1) {", "originalCommit": "aab801a296b4219ce34035960342c2e9deb6a2cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f768561a65ff4dc0e3fcd839f28f9b658fac04f4", "url": "https://github.com/elastic/elasticsearch/commit/f768561a65ff4dc0e3fcd839f28f9b658fac04f4", "message": "Some review comments", "committedDate": "2020-10-12T15:49:18Z", "type": "commit"}, {"oid": "b093276adb1c0dc2ae717986d1bca8265a881247", "url": "https://github.com/elastic/elasticsearch/commit/b093276adb1c0dc2ae717986d1bca8265a881247", "message": "Merge branch 'master' into controller_response_changes", "committedDate": "2020-10-17T06:32:00Z", "type": "commit"}, {"oid": "1dc8ef96d19997a69968cc7ed31692957f7e3b93", "url": "https://github.com/elastic/elasticsearch/commit/1dc8ef96d19997a69968cc7ed31692957f7e3b93", "message": "Revert \"[ML] Mute all ML tests that may create native processes (#63610)\"\n\nThis reverts commit 16bb39dd752aa8fdad0c5544c7f3d79c522f78b2.", "committedDate": "2020-10-17T06:32:17Z", "type": "commit"}]}