{"pr_number": 56365, "pr_title": "Move all Snapshot Master Node Steps to SnapshotsService", "pr_createdAt": "2020-05-07T16:33:36Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/56365", "timeline": [{"oid": "8500ad60334567097c3a36b154ea4f53b3d37b05", "url": "https://github.com/elastic/elasticsearch/commit/8500ad60334567097c3a36b154ea4f53b3d37b05", "message": "Move all Snapshot Master Node Steps to SnapshotsService\n\nThis refactoring has two motivations:\n\n1. Separate all master node steps during snapshot operations from all data node steps in code.\n2. Set up next steps in concurrent repository operations and general improvments by centralizing tracking\nof each shard's state in the repository in `SnapshotShardsService` so that operations for each shard\ncan be linearized efficiently.", "committedDate": "2020-05-07T16:21:05Z", "type": "commit"}, {"oid": "99b16d65a9cf803d98996a5ebdff7b10ac3c57ed", "url": "https://github.com/elastic/elasticsearch/commit/99b16d65a9cf803d98996a5ebdff7b10ac3c57ed", "message": "better efficiency", "committedDate": "2020-05-07T18:52:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcyNDQ2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/56365#discussion_r421724462", "bodyText": "This is kind of lazy and obviously a better solution would be to simply track those snapshots that were completed in the update by adding them to a list or so to be processed here. Just didn't want to do that in this PR since it introduces quite a bit of complexity. But I figured just adding the changed flag here and in the other tasks was enough to illustrate the motivation for this change and is already a huge win in terms of not having to iterate all the shards on every CS application.", "author": "original-brownbear", "createdAt": "2020-05-07T18:57:20Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -527,17 +571,26 @@ public ClusterState execute(ClusterState currentState) {\n             public void onFailure(String source, Exception e) {\n                 logger.warn(\"failed to update snapshot state after node removal\");\n             }\n+\n+            @Override\n+            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n+                if (changed) {", "originalCommit": "99b16d65a9cf803d98996a5ebdff7b10ac3c57ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0MTc5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/56365#discussion_r421941797", "bodyText": "This stuff all got moved to SnapshotsService exactly as is without changes", "author": "original-brownbear", "createdAt": "2020-05-08T05:12:12Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotShardsService.java", "diffHunk": "@@ -423,77 +392,6 @@ private void syncShardStatsOnNewMaster(ClusterChangedEvent event) {\n         }\n     }\n \n-    /**\n-     * Internal request that is used to send changes in snapshot status to master\n-     */\n-    public static class UpdateIndexShardSnapshotStatusRequest extends MasterNodeRequest<UpdateIndexShardSnapshotStatusRequest> {", "originalCommit": "99b16d65a9cf803d98996a5ebdff7b10ac3c57ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzcxNzc5MA==", "url": "https://github.com/elastic/elasticsearch/pull/56365#discussion_r423717790", "bodyText": "Now it is used in different services it could maybe be located in its own file", "author": "tlrx", "createdAt": "2020-05-12T13:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0MTc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0MjI2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/56365#discussion_r421942267", "bodyText": "This is the only change relative to what this code did and looked like in SnapshotShardsService.", "author": "original-brownbear", "createdAt": "2020-05-08T05:13:59Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1321,4 +1382,199 @@ protected void doStop() {\n     protected void doClose() {\n         clusterService.removeApplier(this);\n     }\n+\n+    private static class SnapshotStateExecutor implements ClusterStateTaskExecutor<UpdateIndexShardSnapshotStatusRequest> {\n+\n+        @Override\n+        public ClusterTasksResult<UpdateIndexShardSnapshotStatusRequest>\n+                        execute(ClusterState currentState, List<UpdateIndexShardSnapshotStatusRequest> tasks) {\n+            final SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n+            if (snapshots != null) {\n+                int changedCount = 0;\n+                final List<SnapshotsInProgress.Entry> entries = new ArrayList<>();\n+                for (SnapshotsInProgress.Entry entry : snapshots.entries()) {\n+                    ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder();\n+                    boolean updated = false;\n+\n+                    for (UpdateIndexShardSnapshotStatusRequest updateSnapshotState : tasks) {\n+                        if (entry.snapshot().equals(updateSnapshotState.snapshot())) {\n+                            logger.trace(\"[{}] Updating shard [{}] with status [{}]\", updateSnapshotState.snapshot(),\n+                                updateSnapshotState.shardId(), updateSnapshotState.status().state());\n+                            if (updated == false) {\n+                                shards.putAll(entry.shards());\n+                                updated = true;\n+                            }\n+                            shards.put(updateSnapshotState.shardId(), updateSnapshotState.status());\n+                            changedCount++;\n+                        }\n+                    }\n+\n+                    if (updated) {\n+                        if (completed(shards.values()) == false) {\n+                            entries.add(new SnapshotsInProgress.Entry(entry, shards.build()));\n+                        } else {\n+                            // Snapshot is finished - mark it as done\n+                            // TODO: Add PARTIAL_SUCCESS status?\n+                            SnapshotsInProgress.Entry updatedEntry = new SnapshotsInProgress.Entry(entry, State.SUCCESS, shards.build());\n+                            entries.add(updatedEntry);\n+                        }\n+                    } else {\n+                        entries.add(entry);\n+                    }\n+                }\n+                if (changedCount > 0) {\n+                    logger.trace(\"changed cluster state triggered by {} snapshot state updates\", changedCount);\n+                    return ClusterTasksResult.<UpdateIndexShardSnapshotStatusRequest>builder().successes(tasks)\n+                        .build(ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE,\n+                            new SnapshotsInProgress(unmodifiableList(entries))).build());\n+                }\n+            }\n+            return ClusterTasksResult.<UpdateIndexShardSnapshotStatusRequest>builder().successes(tasks).build(currentState);\n+        }\n+    }\n+\n+    /**\n+     * Internal request that is used to send changes in snapshot status to master\n+     */\n+    public static class UpdateIndexShardSnapshotStatusRequest extends MasterNodeRequest<UpdateIndexShardSnapshotStatusRequest> {\n+        private final Snapshot snapshot;\n+        private final ShardId shardId;\n+        private final ShardSnapshotStatus status;\n+\n+        public UpdateIndexShardSnapshotStatusRequest(StreamInput in) throws IOException {\n+            super(in);\n+            snapshot = new Snapshot(in);\n+            shardId = new ShardId(in);\n+            status = new ShardSnapshotStatus(in);\n+        }\n+\n+        public UpdateIndexShardSnapshotStatusRequest(Snapshot snapshot, ShardId shardId, ShardSnapshotStatus status) {\n+            this.snapshot = snapshot;\n+            this.shardId = shardId;\n+            this.status = status;\n+            // By default, we keep trying to post snapshot status messages to avoid snapshot processes getting stuck.\n+            this.masterNodeTimeout = TimeValue.timeValueNanos(Long.MAX_VALUE);\n+        }\n+\n+        @Override\n+        public ActionRequestValidationException validate() {\n+            return null;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            super.writeTo(out);\n+            snapshot.writeTo(out);\n+            shardId.writeTo(out);\n+            status.writeTo(out);\n+        }\n+\n+        public Snapshot snapshot() {\n+            return snapshot;\n+        }\n+\n+        public ShardId shardId() {\n+            return shardId;\n+        }\n+\n+        public ShardSnapshotStatus status() {\n+            return status;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return snapshot + \", shardId [\" + shardId + \"], status [\" + status.state() + \"]\";\n+        }\n+\n+        @Override\n+        public boolean equals(final Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+            if (o == null || getClass() != o.getClass()) {\n+                return false;\n+            }\n+            final UpdateIndexShardSnapshotStatusRequest that = (UpdateIndexShardSnapshotStatusRequest) o;\n+            return snapshot.equals(that.snapshot) && shardId.equals(that.shardId) && status.equals(that.status);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(snapshot, shardId, status);\n+        }\n+    }\n+\n+    /**\n+     * Updates the shard status on master node\n+     *\n+     * @param request update shard status request\n+     */\n+    private void innerUpdateSnapshotState(final SnapshotsService.UpdateIndexShardSnapshotStatusRequest request,\n+                                          ActionListener<UpdateIndexShardSnapshotStatusResponse> listener) {\n+        logger.trace(\"received updated snapshot restore state [{}]\", request);\n+        clusterService.submitStateUpdateTask(\n+                \"update snapshot state\",\n+                request,\n+                ClusterStateTaskConfig.build(Priority.NORMAL),\n+                snapshotStateExecutor,\n+                new ClusterStateTaskListener() {\n+                    @Override\n+                    public void onFailure(String source, Exception e) {\n+                        listener.onFailure(e);\n+                    }\n+\n+                    @Override\n+                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n+                        try {\n+                            listener.onResponse(new UpdateIndexShardSnapshotStatusResponse());\n+                        } finally {\n+                            endCompletedSnapshots(newState);", "originalCommit": "99b16d65a9cf803d98996a5ebdff7b10ac3c57ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0MzEyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/56365#discussion_r421943121", "bodyText": "Running this check on every CS update wasn't great and added a lot of cycles on the CS thread for larger snapshots. It would be even worse when we start actually having multiple snapshot-in-progress entries. We really should only have to do a full check if anything changed about the entries' shards or on master fail-over.\nThis is change moves all the updating of the shard entries into this class so we can selectively run this check (though see my other comment below, we could be even more selective in a follow-up :)).", "author": "original-brownbear", "createdAt": "2020-05-08T05:17:17Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -409,13 +443,9 @@ public void applyClusterState(ClusterChangedEvent event) {\n                     if (event.routingTableChanged() && waitingShardsStartedOrUnassigned(snapshotsInProgress, event)) {\n                         processStartedShards();\n                     }\n-                    // Cleanup all snapshots that have no more work left:\n-                    // 1. Completed snapshots\n-                    // 2. Snapshots in state INIT that a previous master of an older version failed to start\n-                    // 3. Snapshots in any other state that have all their shard tasks completed\n-                    snapshotsInProgress.entries().stream().filter(", "originalCommit": "99b16d65a9cf803d98996a5ebdff7b10ac3c57ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0MzYzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/56365#discussion_r421943635", "bodyText": "No need to actually run the full check here over all entries in newState here, the only two options of ending the snapshot here right away are if it has no shards or was set to FAILED right away.", "author": "original-brownbear", "createdAt": "2020-05-08T05:19:13Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -252,8 +280,14 @@ public void onFailure(String source, Exception e) {\n \n             @Override\n             public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {\n-                logger.info(\"snapshot [{}] started\", snapshot);\n-                listener.onResponse(snapshot);\n+                try {\n+                    logger.info(\"snapshot [{}] started\", snapshot);\n+                    listener.onResponse(snapshot);\n+                } finally {\n+                    if (newEntry.state().completed() || newEntry.shards().isEmpty()) {", "originalCommit": "99b16d65a9cf803d98996a5ebdff7b10ac3c57ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzcxODUwMg==", "url": "https://github.com/elastic/elasticsearch/pull/56365#discussion_r423718502", "bodyText": "nit: I don't think it need to be fully qualified?", "author": "tlrx", "createdAt": "2020-05-12T13:09:03Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -125,16 +143,25 @@\n     // Set of snapshots that are currently being ended by this node\n     private final Set<Snapshot> endingSnapshots = Collections.synchronizedSet(new HashSet<>());\n \n+    private final SnapshotsService.SnapshotStateExecutor snapshotStateExecutor = new SnapshotsService.SnapshotStateExecutor();", "originalCommit": "99b16d65a9cf803d98996a5ebdff7b10ac3c57ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzcxOTg0MA==", "url": "https://github.com/elastic/elasticsearch/pull/56365#discussion_r423719840", "bodyText": "nit: maybe comment this right before this.updateSnapshotStatusHandler = ... and not in this block", "author": "tlrx", "createdAt": "2020-05-12T13:10:53Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -125,16 +143,25 @@\n     // Set of snapshots that are currently being ended by this node\n     private final Set<Snapshot> endingSnapshots = Collections.synchronizedSet(new HashSet<>());\n \n+    private final SnapshotsService.SnapshotStateExecutor snapshotStateExecutor = new SnapshotsService.SnapshotStateExecutor();\n+    private final UpdateSnapshotStatusAction updateSnapshotStatusHandler;\n+\n+    private final TransportService transportService;\n+\n     public SnapshotsService(Settings settings, ClusterService clusterService, IndexNameExpressionResolver indexNameExpressionResolver,\n-                            RepositoriesService repositoriesService, ThreadPool threadPool) {\n+                            RepositoriesService repositoriesService, TransportService transportService, ActionFilters actionFilters) {\n         this.clusterService = clusterService;\n         this.indexNameExpressionResolver = indexNameExpressionResolver;\n         this.repositoriesService = repositoriesService;\n-        this.threadPool = threadPool;\n+        this.threadPool = transportService.getThreadPool();\n+        this.transportService = transportService;\n \n+        this.updateSnapshotStatusHandler = new UpdateSnapshotStatusAction(\n+                transportService, clusterService, threadPool, actionFilters, indexNameExpressionResolver);\n         if (DiscoveryNode.isMasterNode(settings)) {\n             // addLowPriorityApplier to make sure that Repository will be created before snapshot\n             clusterService.addLowPriorityApplier(this);\n+            // The constructor of UpdateSnapshotStatusAction will register itself to the TransportService.", "originalCommit": "99b16d65a9cf803d98996a5ebdff7b10ac3c57ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzcyMzc2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/56365#discussion_r423723763", "bodyText": "nit: this could be javadoc", "author": "tlrx", "createdAt": "2020-05-12T13:16:37Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -427,6 +457,18 @@ public void applyClusterState(ClusterChangedEvent event) {\n         assert assertConsistentWithClusterState(event.state());\n     }\n \n+    private void endCompletedSnapshots(ClusterState state) {\n+        SnapshotsInProgress snapshotsInProgress = state.custom(SnapshotsInProgress.TYPE);\n+        assert snapshotsInProgress != null;\n+        // Cleanup all snapshots that have no more work left:", "originalCommit": "99b16d65a9cf803d98996a5ebdff7b10ac3c57ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2992dba319a6f38b62466e442cdfc3e91546012c", "url": "https://github.com/elastic/elasticsearch/commit/2992dba319a6f38b62466e442cdfc3e91546012c", "message": "Merge remote-tracking branch 'elastic/master' into cleaner-snapshot-shards-service", "committedDate": "2020-05-12T14:11:36Z", "type": "commit"}, {"oid": "e2e50710d1bfba9a4e5fd1437253541bbcd11265", "url": "https://github.com/elastic/elasticsearch/commit/e2e50710d1bfba9a4e5fd1437253541bbcd11265", "message": "CR: Nits :)", "committedDate": "2020-05-12T14:22:53Z", "type": "commit"}]}