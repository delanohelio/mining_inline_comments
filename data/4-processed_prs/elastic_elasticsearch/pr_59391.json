{"pr_number": 59391, "pr_title": "Make ScriptFieldMapper a parameterized mapper", "pr_createdAt": "2020-07-13T10:05:14Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/59391", "timeline": [{"oid": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383", "url": "https://github.com/elastic/elasticsearch/commit/c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383", "message": "Make ScriptFieldMapper a parameterized mapper", "committedDate": "2020-07-13T10:03:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU0NTc2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453545761", "bodyText": "You should be able to use Parameter.metaParam() here", "author": "romseygeek", "createdAt": "2020-07-13T10:15:45Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -56,81 +73,118 @@ protected String contentType() {\n         return CONTENT_TYPE;\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n-\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        private final Parameter<Map<String, String>> meta = new Parameter<>(", "originalCommit": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYwNTQ1MA==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453605450", "bodyText": "good one, the feature branch was slightly behind, I will merge master in.", "author": "javanna", "createdAt": "2020-07-13T12:13:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU0NTc2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU0Njk0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453546946", "bodyText": "Is there no way of getting it via the ParserContext?", "author": "romseygeek", "createdAt": "2020-07-13T10:17:52Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -56,81 +73,118 @@ protected String contentType() {\n         return CONTENT_TYPE;\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n-\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        private final Parameter<Map<String, String>> meta = new Parameter<>(\n+            \"meta\",\n+            true,\n+            Collections.emptyMap(),\n+            TypeParsers::parseMeta,\n+            m -> m.fieldType().meta()\n+        );\n+        private final Parameter<String> runtimeType = Parameter.stringParam(\n+            \"runtime_type\",\n+            true,\n+            mapper -> toType(mapper).runtimeType,\n+            null\n+        );\n+        // TODO script and runtime_type can be updated: what happens to the currently running queries when they get updated?\n+        // do all the shards get a consistent view?\n+        private final Parameter<Script> script = new Parameter<>(\"script\", true, null,\n+            Builder::parseScript, mapper -> toType(mapper).script);\n         private final ScriptService scriptService;\n \n-        private String runtimeType;\n-        private Script script;\n-\n         protected Builder(String name, ScriptService scriptService) {\n-            super(name, FIELD_TYPE);\n+            super(name);\n             this.scriptService = scriptService;\n         }\n \n-        public void runtimeType(String runtimeType) {\n-            this.runtimeType = runtimeType;\n-        }\n-\n-        public void script(Script script) {\n-            this.script = script;\n+        @Override\n+        protected List<Parameter<?>> getParameters() {\n+            return List.of(meta, runtimeType, script);\n         }\n \n         @Override\n         public ScriptFieldMapper build(BuilderContext context) {\n-            if (runtimeType == null) {\n-                throw new IllegalArgumentException(\"runtime_type must be specified\");\n+            if (runtimeType.getValue() == null) {\n+                throw new IllegalArgumentException(\"runtime_type must be specified for script field [\" + name + \"]\");\n             }\n-            if (script == null) {\n-                throw new IllegalArgumentException(\"script must be specified\");\n+            if (script.getValue() == null) {\n+                throw new IllegalArgumentException(\"script must be specified for script field [\" + name + \"]\");\n             }\n \n             MappedFieldType mappedFieldType;\n-            if (runtimeType.equals(\"keyword\")) {\n-                StringScriptFieldScript.Factory factory = scriptService.compile(script, StringScriptFieldScript.CONTEXT);\n-                mappedFieldType = new RuntimeKeywordMappedFieldType(buildFullName(context), script, factory, meta);\n+            if (runtimeType.getValue().equals(\"keyword\")) {\n+                StringScriptFieldScript.Factory factory = scriptService.compile(script.getValue(), StringScriptFieldScript.CONTEXT);\n+                mappedFieldType = new RuntimeKeywordMappedFieldType(buildFullName(context), script.getValue(), factory, meta.getValue());\n             } else {\n                 throw new IllegalArgumentException(\"runtime_type [\" + runtimeType + \"] not supported\");\n             }\n-            // TODO copy to and multi_fields... not sure what needs to be done.\n-            return new ScriptFieldMapper(name, mappedFieldType, multiFieldsBuilder.build(this, context), copyTo);\n+            // TODO copy to and multi_fields should not be supported, parametrized field mapper needs to be adapted\n+            return new ScriptFieldMapper(name, mappedFieldType, multiFieldsBuilder.build(this, context), copyTo.build(), this);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        static Script parseScript(String name, Object scriptObject) {\n+            if (scriptObject instanceof Map) {\n+                Map<String, ?> scriptMap = (Map<String, ?>) scriptObject;\n+                Object sourceObject = scriptMap.remove(\"source\");\n+                if (sourceObject == null) {\n+                    throw new IllegalArgumentException(\"script source must be specified for script field [\" + name + \"]\");\n+                }\n+                Object langObject = scriptMap.remove(\"lang\");\n+                if (langObject != null && langObject.toString().equals(PainlessScriptEngine.NAME) == false) {\n+                    throw new IllegalArgumentException(\"script lang [\" + langObject.toString() + \"] not supported for script field [\"\n+                        + name + \"]\");\n+                }\n+                Map<String, Object> params;\n+                Object paramsObject = scriptMap.remove(\"params\");\n+                if (paramsObject != null) {\n+                    if (paramsObject instanceof Map == false) {\n+                        throw new IllegalArgumentException(\"unable to parse params for script field [\" + name + \"]\");\n+                    }\n+                    params = (Map<String, Object>) paramsObject;\n+                } else {\n+                    params = Collections.emptyMap();\n+                }\n+                Map<String, String> options;\n+                Object optionsObject = scriptMap.remove(\"options\");\n+                if (optionsObject != null) {\n+                    if (optionsObject instanceof Map == false) {\n+                        throw new IllegalArgumentException(\"unable to parse options for script field [\" + name + \"]\");\n+                    }\n+                    options = (Map<String, String>) optionsObject;\n+                } else {\n+                    options = Collections.emptyMap();\n+                }\n+                if (scriptMap.size() > 0) {\n+                    throw new IllegalArgumentException(\"unsupported parameters specified for script field [\" + name + \"]: \"\n+                        + scriptMap.keySet());\n+                }\n+                return new Script(ScriptType.INLINE, PainlessScriptEngine.NAME, sourceObject.toString(), options, params);\n+            } else if (scriptObject instanceof String) {\n+                return new Script((String) scriptObject);\n+            } else {\n+                throw new IllegalArgumentException(\"unable to parse script for script field [\" + name + \"]\");\n+\n+            }\n         }\n     }\n \n     public static class TypeParser implements Mapper.TypeParser {\n \n-        private final SetOnce<ScriptService> scriptService = new SetOnce<>();\n+        // TODO this is quite ugly and it's static which makes it even worse\n+        private static final SetOnce<ScriptService> SCRIPT_SERVICE = new SetOnce<>();\n ", "originalCommit": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzU1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453553553", "bodyText": "It looks as though we'd have to wire ScriptService into MapperService, but I think that's a reasonable thing to do", "author": "romseygeek", "createdAt": "2020-07-13T10:30:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU0Njk0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMDQxOA==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453610418", "bodyText": "I will look into it, thanks for the suggestion.", "author": "javanna", "createdAt": "2020-07-13T12:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU0Njk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU0NzkxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453547911", "bodyText": "Once #59291 is merged then you can set validators directly on the parameter", "author": "romseygeek", "createdAt": "2020-07-13T10:19:42Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -56,81 +73,118 @@ protected String contentType() {\n         return CONTENT_TYPE;\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n-\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        private final Parameter<Map<String, String>> meta = new Parameter<>(\n+            \"meta\",\n+            true,\n+            Collections.emptyMap(),\n+            TypeParsers::parseMeta,\n+            m -> m.fieldType().meta()\n+        );\n+        private final Parameter<String> runtimeType = Parameter.stringParam(\n+            \"runtime_type\",\n+            true,\n+            mapper -> toType(mapper).runtimeType,\n+            null\n+        );\n+        // TODO script and runtime_type can be updated: what happens to the currently running queries when they get updated?\n+        // do all the shards get a consistent view?\n+        private final Parameter<Script> script = new Parameter<>(\"script\", true, null,\n+            Builder::parseScript, mapper -> toType(mapper).script);\n         private final ScriptService scriptService;\n \n-        private String runtimeType;\n-        private Script script;\n-\n         protected Builder(String name, ScriptService scriptService) {\n-            super(name, FIELD_TYPE);\n+            super(name);\n             this.scriptService = scriptService;\n         }\n \n-        public void runtimeType(String runtimeType) {\n-            this.runtimeType = runtimeType;\n-        }\n-\n-        public void script(Script script) {\n-            this.script = script;\n+        @Override\n+        protected List<Parameter<?>> getParameters() {\n+            return List.of(meta, runtimeType, script);\n         }\n \n         @Override\n         public ScriptFieldMapper build(BuilderContext context) {\n-            if (runtimeType == null) {\n-                throw new IllegalArgumentException(\"runtime_type must be specified\");\n+            if (runtimeType.getValue() == null) {\n+                throw new IllegalArgumentException(\"runtime_type must be specified for script field [\" + name + \"]\");", "originalCommit": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYwNTY5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453605696", "bodyText": "nice I was surprised that there wasn't a way to do that.", "author": "javanna", "createdAt": "2020-07-13T12:14:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU0NzkxMQ=="}], "type": "inlineReview"}, {"oid": "c913bbfcb1938f72b0ba66e908a1fb873b667cc9", "url": "https://github.com/elastic/elasticsearch/commit/c913bbfcb1938f72b0ba66e908a1fb873b667cc9", "message": "Merge branch 'feature/runtime_fields' into enhancement/script_mapper_parameterized", "committedDate": "2020-07-13T12:10:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMDcwNg==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453610706", "bodyText": "@romseygeek this is for you, does it make sense?", "author": "javanna", "createdAt": "2020-07-13T12:23:57Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -6,42 +6,59 @@\n \n package org.elasticsearch.xpack.runtimefields.mapper;\n \n-import org.apache.lucene.document.FieldType;\n import org.apache.lucene.util.SetOnce;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n-import org.elasticsearch.common.xcontent.support.XContentMapValues;\n import org.elasticsearch.index.mapper.FieldMapper;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.Mapper;\n import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParametrizedFieldMapper;\n import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.mapper.TypeParsers;\n+import org.elasticsearch.painless.PainlessScriptEngine;\n import org.elasticsearch.script.Script;\n import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.script.ScriptType;\n import org.elasticsearch.xpack.runtimefields.StringScriptFieldScript;\n \n import java.io.IOException;\n-import java.util.Iterator;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n-public final class ScriptFieldMapper extends FieldMapper {\n+public final class ScriptFieldMapper extends ParametrizedFieldMapper {\n \n     public static final String CONTENT_TYPE = \"script\";\n \n-    private static final FieldType FIELD_TYPE = new FieldType();\n+    private final String runtimeType;\n+    private final Script script;\n \n-    ScriptFieldMapper(String simpleName, MappedFieldType mappedFieldType, MultiFields multiFields, CopyTo copyTo) {\n-        super(simpleName, FIELD_TYPE, mappedFieldType, multiFields, copyTo);\n+    private static ScriptFieldMapper toType(FieldMapper in) {\n+        return (ScriptFieldMapper) in;\n+    }\n+\n+    protected ScriptFieldMapper(\n+        String simpleName,\n+        MappedFieldType mappedFieldType,\n+        MultiFields multiFields,\n+        CopyTo copyTo,\n+        Builder builder\n+    ) {\n+        super(simpleName, mappedFieldType, multiFields, copyTo);\n+        // TODO is it ok that the object being built needs to read from the object that is building it? Shouldn't Builder#build return\n+        // a complete object? Maybe all the parameters need to be passed through instead of the whole builder?", "originalCommit": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYyMTg5NA==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453621894", "bodyText": "Given that the mapper constructor is protected here, I think it's OK?  You can pull out individual parameters if you think it's clearer, I used this pattern on other mappers simply because otherwise you end up with 14 constructor parameters most of which are just boilerplate.", "author": "romseygeek", "createdAt": "2020-07-13T12:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMDcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMDkyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453610929", "bodyText": "@romseygeek do you have thoughts on this?", "author": "javanna", "createdAt": "2020-07-13T12:24:23Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -56,81 +73,118 @@ protected String contentType() {\n         return CONTENT_TYPE;\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n-\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        private final Parameter<Map<String, String>> meta = new Parameter<>(\n+            \"meta\",\n+            true,\n+            Collections.emptyMap(),\n+            TypeParsers::parseMeta,\n+            m -> m.fieldType().meta()\n+        );\n+        private final Parameter<String> runtimeType = Parameter.stringParam(\n+            \"runtime_type\",\n+            true,\n+            mapper -> toType(mapper).runtimeType,\n+            null\n+        );\n+        // TODO script and runtime_type can be updated: what happens to the currently running queries when they get updated?\n+        // do all the shards get a consistent view?", "originalCommit": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYyMzc4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453623783", "bodyText": "So currently QueryShardContext#fieldMapper() delegates field lookups back to the MapperService, which gets updated in-place, so if there's an update while a query is running then the script will get changed out and there may well be inconsistencies between phases, as well as between shards.  We could make QueryShardContext take a FieldTypeLookup as a parameter which would at least remove the possibility of an update between phases?", "author": "romseygeek", "createdAt": "2020-07-13T12:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMDkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY1ODAwMg==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453658002", "bodyText": "We have this sort of problem now with any thing that can change. I guess scripts make this worse because they are \"more mutable\" than other stuff.", "author": "nik9000", "createdAt": "2020-07-13T13:41:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMDkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMTQ1NA==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453611454", "bodyText": "@romseygeek and this one too. I think I would prefer making the changes upstream instead of adapting parameterized field mapper in the feature branch. Thoughts?", "author": "javanna", "createdAt": "2020-07-13T12:25:20Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -56,81 +73,118 @@ protected String contentType() {\n         return CONTENT_TYPE;\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n-\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        private final Parameter<Map<String, String>> meta = new Parameter<>(\n+            \"meta\",\n+            true,\n+            Collections.emptyMap(),\n+            TypeParsers::parseMeta,\n+            m -> m.fieldType().meta()\n+        );\n+        private final Parameter<String> runtimeType = Parameter.stringParam(\n+            \"runtime_type\",\n+            true,\n+            mapper -> toType(mapper).runtimeType,\n+            null\n+        );\n+        // TODO script and runtime_type can be updated: what happens to the currently running queries when they get updated?\n+        // do all the shards get a consistent view?\n+        private final Parameter<Script> script = new Parameter<>(\"script\", true, null,\n+            Builder::parseScript, mapper -> toType(mapper).script);\n         private final ScriptService scriptService;\n \n-        private String runtimeType;\n-        private Script script;\n-\n         protected Builder(String name, ScriptService scriptService) {\n-            super(name, FIELD_TYPE);\n+            super(name);\n             this.scriptService = scriptService;\n         }\n \n-        public void runtimeType(String runtimeType) {\n-            this.runtimeType = runtimeType;\n-        }\n-\n-        public void script(Script script) {\n-            this.script = script;\n+        @Override\n+        protected List<Parameter<?>> getParameters() {\n+            return List.of(meta, runtimeType, script);\n         }\n \n         @Override\n         public ScriptFieldMapper build(BuilderContext context) {\n-            if (runtimeType == null) {\n-                throw new IllegalArgumentException(\"runtime_type must be specified\");\n+            if (runtimeType.getValue() == null) {\n+                throw new IllegalArgumentException(\"runtime_type must be specified for script field [\" + name + \"]\");\n             }\n-            if (script == null) {\n-                throw new IllegalArgumentException(\"script must be specified\");\n+            if (script.getValue() == null) {\n+                throw new IllegalArgumentException(\"script must be specified for script field [\" + name + \"]\");\n             }\n \n             MappedFieldType mappedFieldType;\n-            if (runtimeType.equals(\"keyword\")) {\n-                StringScriptFieldScript.Factory factory = scriptService.compile(script, StringScriptFieldScript.CONTEXT);\n-                mappedFieldType = new RuntimeKeywordMappedFieldType(buildFullName(context), script, factory, meta);\n+            if (runtimeType.getValue().equals(\"keyword\")) {\n+                StringScriptFieldScript.Factory factory = scriptService.compile(script.getValue(), StringScriptFieldScript.CONTEXT);\n+                mappedFieldType = new RuntimeKeywordMappedFieldType(buildFullName(context), script.getValue(), factory, meta.getValue());\n             } else {\n                 throw new IllegalArgumentException(\"runtime_type [\" + runtimeType + \"] not supported\");\n             }\n-            // TODO copy to and multi_fields... not sure what needs to be done.\n-            return new ScriptFieldMapper(name, mappedFieldType, multiFieldsBuilder.build(this, context), copyTo);\n+            // TODO copy to and multi_fields should not be supported, parametrized field mapper needs to be adapted", "originalCommit": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYyNTk4NA==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453625984", "bodyText": "++, I can work on this one.", "author": "romseygeek", "createdAt": "2020-07-13T12:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMTQ1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYyODMwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453628309", "bodyText": "thanks that would be great!", "author": "javanna", "createdAt": "2020-07-13T12:55:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMTQ1NA=="}], "type": "inlineReview"}, {"oid": "4458b7133d63d2417652f9e5fa90244e16dfdb07", "url": "https://github.com/elastic/elasticsearch/commit/4458b7133d63d2417652f9e5fa90244e16dfdb07", "message": "iter", "committedDate": "2020-07-13T13:17:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY1ODMxMA==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453658310", "bodyText": "@nik9000 help!", "author": "javanna", "createdAt": "2020-07-13T13:42:20Z", "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapperTests.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.mapper;\n+\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.painless.PainlessPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n+import org.elasticsearch.test.InternalSettingsPlugin;\n+import org.elasticsearch.xpack.runtimefields.RuntimeFields;\n+\n+import java.util.Collection;\n+\n+import static org.hamcrest.Matchers.instanceOf;\n+\n+public class ScriptFieldMapperTests extends ESSingleNodeTestCase {\n+\n+    private static final String[] SUPPORTED_RUNTIME_TYPES = new String[] { \"keyword\" };\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> getPlugins() {\n+        return pluginList(InternalSettingsPlugin.class, RuntimeFields.class, PainlessPlugin.class);\n+    }\n+\n+    public void testRuntimeTypeIsRequired() throws Exception {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder()\n+            .startObject()\n+            .startObject(\"_doc\")\n+            .startObject(\"properties\")\n+            .startObject(\"my_field\")\n+            .field(\"type\", \"script\")\n+            .field(\"script\", \"value('test')\")\n+            .endObject()\n+            .endObject()\n+            .endObject()\n+            .endObject();\n+\n+        MapperParsingException exception = expectThrows(MapperParsingException.class, () -> createIndex(\"test\", Settings.EMPTY, mapping));\n+        assertEquals(\"Failed to parse mapping: runtime_type must be specified for script field [my_field]\", exception.getMessage());\n+    }\n+\n+    public void testScriptIsRequired() throws Exception {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder()\n+            .startObject()\n+            .startObject(\"_doc\")\n+            .startObject(\"properties\")\n+            .startObject(\"my_field\")\n+            .field(\"type\", \"script\")\n+            .field(\"runtime_type\", randomFrom(SUPPORTED_RUNTIME_TYPES))\n+            .endObject()\n+            .endObject()\n+            .endObject()\n+            .endObject();\n+\n+        MapperParsingException exception = expectThrows(MapperParsingException.class, () -> createIndex(\"test\", Settings.EMPTY, mapping));\n+        assertEquals(\"Failed to parse mapping: script must be specified for script field [my_field]\", exception.getMessage());\n+    }\n+\n+    @AwaitsFix(bugUrl = \"Nik: help! :)\")", "originalCommit": "4458b7133d63d2417652f9e5fa90244e16dfdb07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY2MDAxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453660015", "bodyText": "I swear I've seen this before somewhere else...", "author": "nik9000", "createdAt": "2020-07-13T13:44:44Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -56,81 +74,122 @@ protected String contentType() {\n         return CONTENT_TYPE;\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n-\n-        private final ScriptService scriptService;\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n \n-        private String runtimeType;\n-        private Script script;\n-\n-        protected Builder(String name, ScriptService scriptService) {\n-            super(name, FIELD_TYPE);\n-            this.scriptService = scriptService;\n-        }\n+        private final Parameter<Map<String, String>> meta = Parameter.metaParam();\n+        private final Parameter<String> runtimeType = Parameter.stringParam(\n+            \"runtime_type\",\n+            true,\n+            mapper -> toType(mapper).runtimeType,\n+            null\n+        ).setValidator(runtimeType -> {\n+            if (runtimeType == null) {\n+                throw new IllegalArgumentException(\"runtime_type must be specified for script field [\" + name + \"]\");\n+            }\n+        });\n+        // TODO script and runtime_type can be updated: what happens to the currently running queries when they get updated?\n+        // do all the shards get a consistent view?\n+        private final Parameter<Script> script = new Parameter<>(\n+            \"script\",\n+            true,\n+            null,\n+            Builder::parseScript,\n+            mapper -> toType(mapper).script\n+        ).setValidator(script -> {\n+            if (script == null) {\n+                throw new IllegalArgumentException(\"script must be specified for script field [\" + name + \"]\");\n+            }\n+        });\n+        private final Supplier<QueryShardContext> queryShardContextSupplier;\n \n-        public void runtimeType(String runtimeType) {\n-            this.runtimeType = runtimeType;\n+        protected Builder(String name, Supplier<QueryShardContext> queryShardContextSupplier) {\n+            super(name);\n+            this.queryShardContextSupplier = queryShardContextSupplier;\n         }\n \n-        public void script(Script script) {\n-            this.script = script;\n+        @Override\n+        protected List<Parameter<?>> getParameters() {\n+            return List.of(meta, runtimeType, script);\n         }\n \n         @Override\n         public ScriptFieldMapper build(BuilderContext context) {\n-            if (runtimeType == null) {\n-                throw new IllegalArgumentException(\"runtime_type must be specified\");\n-            }\n-            if (script == null) {\n-                throw new IllegalArgumentException(\"script must be specified\");\n-            }\n-\n+            QueryShardContext queryShardContext = queryShardContextSupplier.get();\n             MappedFieldType mappedFieldType;\n-            if (runtimeType.equals(\"keyword\")) {\n-                StringScriptFieldScript.Factory factory = scriptService.compile(script, StringScriptFieldScript.CONTEXT);\n-                mappedFieldType = new RuntimeKeywordMappedFieldType(buildFullName(context), script, factory, meta);\n+            if (runtimeType.getValue().equals(\"keyword\")) {\n+                StringScriptFieldScript.Factory factory = queryShardContext.compile(script.getValue(), StringScriptFieldScript.CONTEXT);\n+                mappedFieldType = new RuntimeKeywordMappedFieldType(buildFullName(context), script.getValue(), factory, meta.getValue());\n             } else {\n                 throw new IllegalArgumentException(\"runtime_type [\" + runtimeType + \"] not supported\");\n             }\n-            // TODO copy to and multi_fields... not sure what needs to be done.\n-            return new ScriptFieldMapper(name, mappedFieldType, multiFieldsBuilder.build(this, context), copyTo);\n+            // TODO copy to and multi_fields should not be supported, parametrized field mapper needs to be adapted\n+            return new ScriptFieldMapper(\n+                name,\n+                mappedFieldType,\n+                multiFieldsBuilder.build(this, context),\n+                copyTo.build(),\n+                runtimeType.getValue(),\n+                script.getValue(),\n+                queryShardContextSupplier\n+            );\n         }\n-    }\n \n-    public static class TypeParser implements Mapper.TypeParser {\n-\n-        private final SetOnce<ScriptService> scriptService = new SetOnce<>();\n+        @SuppressWarnings(\"unchecked\")\n+        static Script parseScript(String name, Mapper.TypeParser.ParserContext parserContext, Object scriptObject) {", "originalCommit": "4458b7133d63d2417652f9e5fa90244e16dfdb07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc0Mjg1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453742857", "bodyText": "you may have, but we only accept painless and we don't parse stored scripts. I will look though, I assumed that we never parse from a map but watcher may do that actually.", "author": "javanna", "createdAt": "2020-07-13T15:39:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY2MDAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIxOTEwMw==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r454219103", "bodyText": "I found it, it was in update by query, I opened #59507 so that we can test and reuse that existing code", "author": "javanna", "createdAt": "2020-07-14T09:16:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY2MDAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyNzA3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453727073", "bodyText": "I think queryShardContextSupplier exists for the percolator and it is a bit sneaky. It'll do but I'd feel more comfortable if we had the ScriptService directly.", "author": "nik9000", "createdAt": "2020-07-13T15:18:20Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -56,81 +74,122 @@ protected String contentType() {\n         return CONTENT_TYPE;\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n-\n-        private final ScriptService scriptService;\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n \n-        private String runtimeType;\n-        private Script script;\n-\n-        protected Builder(String name, ScriptService scriptService) {\n-            super(name, FIELD_TYPE);\n-            this.scriptService = scriptService;\n-        }\n+        private final Parameter<Map<String, String>> meta = Parameter.metaParam();\n+        private final Parameter<String> runtimeType = Parameter.stringParam(\n+            \"runtime_type\",\n+            true,\n+            mapper -> toType(mapper).runtimeType,\n+            null\n+        ).setValidator(runtimeType -> {\n+            if (runtimeType == null) {\n+                throw new IllegalArgumentException(\"runtime_type must be specified for script field [\" + name + \"]\");\n+            }\n+        });\n+        // TODO script and runtime_type can be updated: what happens to the currently running queries when they get updated?\n+        // do all the shards get a consistent view?\n+        private final Parameter<Script> script = new Parameter<>(\n+            \"script\",\n+            true,\n+            null,\n+            Builder::parseScript,\n+            mapper -> toType(mapper).script\n+        ).setValidator(script -> {\n+            if (script == null) {\n+                throw new IllegalArgumentException(\"script must be specified for script field [\" + name + \"]\");\n+            }\n+        });\n+        private final Supplier<QueryShardContext> queryShardContextSupplier;\n \n-        public void runtimeType(String runtimeType) {\n-            this.runtimeType = runtimeType;\n+        protected Builder(String name, Supplier<QueryShardContext> queryShardContextSupplier) {\n+            super(name);\n+            this.queryShardContextSupplier = queryShardContextSupplier;\n         }\n \n-        public void script(Script script) {\n-            this.script = script;\n+        @Override\n+        protected List<Parameter<?>> getParameters() {\n+            return List.of(meta, runtimeType, script);\n         }\n \n         @Override\n         public ScriptFieldMapper build(BuilderContext context) {\n-            if (runtimeType == null) {\n-                throw new IllegalArgumentException(\"runtime_type must be specified\");\n-            }\n-            if (script == null) {\n-                throw new IllegalArgumentException(\"script must be specified\");\n-            }\n-\n+            QueryShardContext queryShardContext = queryShardContextSupplier.get();\n             MappedFieldType mappedFieldType;\n-            if (runtimeType.equals(\"keyword\")) {\n-                StringScriptFieldScript.Factory factory = scriptService.compile(script, StringScriptFieldScript.CONTEXT);\n-                mappedFieldType = new RuntimeKeywordMappedFieldType(buildFullName(context), script, factory, meta);\n+            if (runtimeType.getValue().equals(\"keyword\")) {\n+                StringScriptFieldScript.Factory factory = queryShardContext.compile(script.getValue(), StringScriptFieldScript.CONTEXT);\n+                mappedFieldType = new RuntimeKeywordMappedFieldType(buildFullName(context), script.getValue(), factory, meta.getValue());\n             } else {\n                 throw new IllegalArgumentException(\"runtime_type [\" + runtimeType + \"] not supported\");\n             }\n-            // TODO copy to and multi_fields... not sure what needs to be done.\n-            return new ScriptFieldMapper(name, mappedFieldType, multiFieldsBuilder.build(this, context), copyTo);\n+            // TODO copy to and multi_fields should not be supported, parametrized field mapper needs to be adapted\n+            return new ScriptFieldMapper(\n+                name,\n+                mappedFieldType,\n+                multiFieldsBuilder.build(this, context),\n+                copyTo.build(),\n+                runtimeType.getValue(),\n+                script.getValue(),\n+                queryShardContextSupplier\n+            );\n         }\n-    }\n \n-    public static class TypeParser implements Mapper.TypeParser {\n-\n-        private final SetOnce<ScriptService> scriptService = new SetOnce<>();\n+        @SuppressWarnings(\"unchecked\")\n+        static Script parseScript(String name, Mapper.TypeParser.ParserContext parserContext, Object scriptObject) {\n+            if (scriptObject instanceof Map) {\n+                Map<String, ?> scriptMap = (Map<String, ?>) scriptObject;\n+                Object sourceObject = scriptMap.remove(\"source\");\n+                if (sourceObject == null) {\n+                    throw new IllegalArgumentException(\"script source must be specified for script field [\" + name + \"]\");\n+                }\n+                Object langObject = scriptMap.remove(\"lang\");\n+                if (langObject != null && langObject.toString().equals(PainlessScriptEngine.NAME) == false) {\n+                    throw new IllegalArgumentException(\n+                        \"script lang [\" + langObject.toString() + \"] not supported for script field [\" + name + \"]\"\n+                    );\n+                }\n+                Map<String, Object> params;\n+                Object paramsObject = scriptMap.remove(\"params\");\n+                if (paramsObject != null) {\n+                    if (paramsObject instanceof Map == false) {\n+                        throw new IllegalArgumentException(\"unable to parse params for script field [\" + name + \"]\");\n+                    }\n+                    params = (Map<String, Object>) paramsObject;\n+                } else {\n+                    params = Collections.emptyMap();\n+                }\n+                Map<String, String> options;\n+                Object optionsObject = scriptMap.remove(\"options\");\n+                if (optionsObject != null) {\n+                    if (optionsObject instanceof Map == false) {\n+                        throw new IllegalArgumentException(\"unable to parse options for script field [\" + name + \"]\");\n+                    }\n+                    options = (Map<String, String>) optionsObject;\n+                } else {\n+                    options = Collections.emptyMap();\n+                }\n+                if (scriptMap.size() > 0) {\n+                    throw new IllegalArgumentException(\n+                        \"unsupported parameters specified for script field [\" + name + \"]: \" + scriptMap.keySet()\n+                    );\n+                }\n+                return new Script(ScriptType.INLINE, PainlessScriptEngine.NAME, sourceObject.toString(), options, params);\n+            } else if (scriptObject instanceof String) {\n+                return new Script((String) scriptObject);\n+            } else {\n+                throw new IllegalArgumentException(\"unable to parse script for script field [\" + name + \"]\");\n \n-        public void setScriptService(ScriptService scriptService) {\n-            this.scriptService.set(scriptService);\n+            }\n         }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {\n \n         @Override\n         public ScriptFieldMapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext)\n             throws MapperParsingException {\n-            Builder builder = new Builder(name, scriptService.get());\n-            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n-                Map.Entry<String, Object> entry = iterator.next();\n-                String propName = entry.getKey();\n-                Object propNode = entry.getValue();\n-                if (propName.equals(\"runtime_type\")) {\n-                    if (propNode == null) {\n-                        throw new MapperParsingException(\"Property [runtime_type] cannot be null.\");\n-                    }\n-                    builder.runtimeType(XContentMapValues.nodeStringValue(propNode, name + \".runtime_type\"));\n-                    iterator.remove();\n-                } else if (propName.equals(\"script\")) {\n-                    if (propNode == null) {\n-                        throw new MapperParsingException(\"Property [script] cannot be null.\");\n-                    }\n-                    // TODO this should become an object and support the usual script syntax, including lang and params\n-                    builder.script(new Script(XContentMapValues.nodeStringValue(propNode, name + \".script\")));\n-                    iterator.remove();\n-                }\n-            }\n-            // TODO these get passed in sometimes and we don't need them\n-            node.remove(\"doc_values\");\n-            node.remove(\"index\");\n+            ScriptFieldMapper.Builder builder = new ScriptFieldMapper.Builder(name, parserContext.queryShardContextSupplier());", "originalCommit": "4458b7133d63d2417652f9e5fa90244e16dfdb07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczMDg4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453730889", "bodyText": "I worry about keeping the queryShardContextSupplier around because it is sneaky. Could getMergeBuilder get the parse context or something like that?", "author": "nik9000", "createdAt": "2020-07-13T15:23:26Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -6,42 +6,60 @@\n \n package org.elasticsearch.xpack.runtimefields.mapper;\n \n-import org.apache.lucene.document.FieldType;\n-import org.apache.lucene.util.SetOnce;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n-import org.elasticsearch.common.xcontent.support.XContentMapValues;\n import org.elasticsearch.index.mapper.FieldMapper;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.Mapper;\n import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParametrizedFieldMapper;\n import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.painless.PainlessScriptEngine;\n import org.elasticsearch.script.Script;\n-import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.script.ScriptType;\n import org.elasticsearch.xpack.runtimefields.StringScriptFieldScript;\n \n import java.io.IOException;\n-import java.util.Iterator;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.function.Supplier;\n \n-public final class ScriptFieldMapper extends FieldMapper {\n+public final class ScriptFieldMapper extends ParametrizedFieldMapper {\n \n     public static final String CONTENT_TYPE = \"script\";\n \n-    private static final FieldType FIELD_TYPE = new FieldType();\n+    private final String runtimeType;\n+    private final Script script;\n+    private final Supplier<QueryShardContext> queryShardContextSupplier;\n \n-    ScriptFieldMapper(String simpleName, MappedFieldType mappedFieldType, MultiFields multiFields, CopyTo copyTo) {\n-        super(simpleName, FIELD_TYPE, mappedFieldType, multiFields, copyTo);\n+    private static ScriptFieldMapper toType(FieldMapper in) {\n+        return (ScriptFieldMapper) in;\n+    }\n+\n+    protected ScriptFieldMapper(\n+        String simpleName,\n+        MappedFieldType mappedFieldType,\n+        MultiFields multiFields,\n+        CopyTo copyTo,\n+        String runtimeType,\n+        Script script,\n+        Supplier<QueryShardContext> queryShardContextSupplier\n+    ) {\n+        super(simpleName, mappedFieldType, multiFields, copyTo);\n+        this.runtimeType = runtimeType;\n+        this.script = script;\n+        this.queryShardContextSupplier = queryShardContextSupplier;", "originalCommit": "4458b7133d63d2417652f9e5fa90244e16dfdb07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc0MTg3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453741876", "bodyText": "I agree. I personally prefer the hack that we had before (SetOnce in the type parser, set from the plugin class). Otherwise I can get the query shard context from the parser context and pass in only the script service, hopefully it is available.", "author": "javanna", "createdAt": "2020-07-13T15:38:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczMDg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczMTIyNw==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453731227", "bodyText": "Could you move this next to the Builder?", "author": "nik9000", "createdAt": "2020-07-13T15:23:53Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -6,42 +6,60 @@\n \n package org.elasticsearch.xpack.runtimefields.mapper;\n \n-import org.apache.lucene.document.FieldType;\n-import org.apache.lucene.util.SetOnce;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n-import org.elasticsearch.common.xcontent.support.XContentMapValues;\n import org.elasticsearch.index.mapper.FieldMapper;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.Mapper;\n import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParametrizedFieldMapper;\n import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.painless.PainlessScriptEngine;\n import org.elasticsearch.script.Script;\n-import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.script.ScriptType;\n import org.elasticsearch.xpack.runtimefields.StringScriptFieldScript;\n \n import java.io.IOException;\n-import java.util.Iterator;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.function.Supplier;\n \n-public final class ScriptFieldMapper extends FieldMapper {\n+public final class ScriptFieldMapper extends ParametrizedFieldMapper {\n \n     public static final String CONTENT_TYPE = \"script\";\n \n-    private static final FieldType FIELD_TYPE = new FieldType();\n+    private final String runtimeType;\n+    private final Script script;\n+    private final Supplier<QueryShardContext> queryShardContextSupplier;\n \n-    ScriptFieldMapper(String simpleName, MappedFieldType mappedFieldType, MultiFields multiFields, CopyTo copyTo) {\n-        super(simpleName, FIELD_TYPE, mappedFieldType, multiFields, copyTo);\n+    private static ScriptFieldMapper toType(FieldMapper in) {", "originalCommit": "4458b7133d63d2417652f9e5fa90244e16dfdb07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczMTMyMA==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453731320", "bodyText": "Or even in the builder?", "author": "nik9000", "createdAt": "2020-07-13T15:24:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczMTIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczNTM1OA==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453735358", "bodyText": "Is the idea to test that we can properly parse a simple version of the mapper? I don't really get the name of the method. I will try and hack on it locally and let you know what I find.", "author": "nik9000", "createdAt": "2020-07-13T15:29:55Z", "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapperTests.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.mapper;\n+\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.painless.PainlessPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n+import org.elasticsearch.test.InternalSettingsPlugin;\n+import org.elasticsearch.xpack.runtimefields.RuntimeFields;\n+\n+import java.util.Collection;\n+\n+import static org.hamcrest.Matchers.instanceOf;\n+\n+public class ScriptFieldMapperTests extends ESSingleNodeTestCase {\n+\n+    private static final String[] SUPPORTED_RUNTIME_TYPES = new String[] { \"keyword\" };\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> getPlugins() {\n+        return pluginList(InternalSettingsPlugin.class, RuntimeFields.class, PainlessPlugin.class);\n+    }\n+\n+    public void testRuntimeTypeIsRequired() throws Exception {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder()\n+            .startObject()\n+            .startObject(\"_doc\")\n+            .startObject(\"properties\")\n+            .startObject(\"my_field\")\n+            .field(\"type\", \"script\")\n+            .field(\"script\", \"value('test')\")\n+            .endObject()\n+            .endObject()\n+            .endObject()\n+            .endObject();\n+\n+        MapperParsingException exception = expectThrows(MapperParsingException.class, () -> createIndex(\"test\", Settings.EMPTY, mapping));\n+        assertEquals(\"Failed to parse mapping: runtime_type must be specified for script field [my_field]\", exception.getMessage());\n+    }\n+\n+    public void testScriptIsRequired() throws Exception {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder()\n+            .startObject()\n+            .startObject(\"_doc\")\n+            .startObject(\"properties\")\n+            .startObject(\"my_field\")\n+            .field(\"type\", \"script\")\n+            .field(\"runtime_type\", randomFrom(SUPPORTED_RUNTIME_TYPES))\n+            .endObject()\n+            .endObject()\n+            .endObject()\n+            .endObject();\n+\n+        MapperParsingException exception = expectThrows(MapperParsingException.class, () -> createIndex(\"test\", Settings.EMPTY, mapping));\n+        assertEquals(\"Failed to parse mapping: script must be specified for script field [my_field]\", exception.getMessage());\n+    }\n+\n+    @AwaitsFix(bugUrl = \"Nik: help! :)\")\n+    public void testDefaultMapping() throws Exception {", "originalCommit": "4458b7133d63d2417652f9e5fa90244e16dfdb07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc0MDIzNA==", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453740234", "bodyText": "the name is from a copy/paste. I wanted to test that the mapper works indeed.", "author": "javanna", "createdAt": "2020-07-13T15:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczNTM1OA=="}], "type": "inlineReview"}, {"oid": "99f18133932d0202acd9874b338a32c782e47011", "url": "https://github.com/elastic/elasticsearch/commit/99f18133932d0202acd9874b338a32c782e47011", "message": "Merge branch 'feature/runtime_fields' into enhancement/script_mapper_parameterized", "committedDate": "2020-07-14T07:47:33Z", "type": "commit"}, {"oid": "993ba667c240c1cd9fc6ce9d2000d2981b933995", "url": "https://github.com/elastic/elasticsearch/commit/993ba667c240c1cd9fc6ce9d2000d2981b933995", "message": "iter", "committedDate": "2020-07-14T08:13:29Z", "type": "commit"}, {"oid": "7265381b9dfa5c6948276d4f1ce86eae1ef9276b", "url": "https://github.com/elastic/elasticsearch/commit/7265381b9dfa5c6948276d4f1ce86eae1ef9276b", "message": "Merge branch 'feature/runtime_fields' into enhancement/script_mapper_parameterized", "committedDate": "2020-07-14T12:50:02Z", "type": "commit"}, {"oid": "6b7846d386565c901374f4aef3a2637965628022", "url": "https://github.com/elastic/elasticsearch/commit/6b7846d386565c901374f4aef3a2637965628022", "message": "share parsing code", "committedDate": "2020-07-14T13:02:21Z", "type": "commit"}, {"oid": "67cc50dadaf4f062ee85809111afd7e332db6598", "url": "https://github.com/elastic/elasticsearch/commit/67cc50dadaf4f062ee85809111afd7e332db6598", "message": "make test work", "committedDate": "2020-07-14T13:47:50Z", "type": "commit"}, {"oid": "0b69696a352692ae5eedf770a47db33b6c2aa363", "url": "https://github.com/elastic/elasticsearch/commit/0b69696a352692ae5eedf770a47db33b6c2aa363", "message": "iter", "committedDate": "2020-07-14T13:58:16Z", "type": "commit"}]}