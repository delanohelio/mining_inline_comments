{"pr_number": 60585, "pr_title": "Rework checking if a year is a leap year", "pr_createdAt": "2020-08-03T12:10:05Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/60585", "timeline": [{"oid": "d2ba5938ef47250c0a1eca30a21faa93f095b2b2", "url": "https://github.com/elastic/elasticsearch/commit/d2ba5938ef47250c0a1eca30a21faa93f095b2b2", "message": "Rework checking if a year is a leap year\n\nThis way is faster, saving about 8% on the microbenchmark that rounds to\nthe nearest month. That is in the hot path for `date_histogram` which is\na very popular aggregation so it seems worth it to at least try and\nspeed it up a little.", "committedDate": "2020-08-03T12:12:16Z", "type": "commit"}, {"oid": "d2ba5938ef47250c0a1eca30a21faa93f095b2b2", "url": "https://github.com/elastic/elasticsearch/commit/d2ba5938ef47250c0a1eca30a21faa93f095b2b2", "message": "Rework checking if a year is a leap year\n\nThis way is faster, saving about 8% on the microbenchmark that rounds to\nthe nearest month. That is in the hot path for `date_histogram` which is\na very popular aggregation so it seems worth it to at least try and\nspeed it up a little.", "committedDate": "2020-08-03T12:12:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM3NTQyMw==", "url": "https://github.com/elastic/elasticsearch/pull/60585#discussion_r464375423", "bodyText": "I wrote all this while I was working on this because I couldn't figure out how to get actual intel assembly instructions. It turns out that if you install the hsdis that they build as part of the openjdk you'll just get jvm opcodes. Those are neat, but not useful to me. Instead you need the hsdis from the \"Free Code Manipulation Library\". Which you have to build. And it isn't a simple as git clone foo && cd foo && ./configure && make && sudo make install. You need to do what I did.\nI can separate this out into a separate change if either change is controversial.", "author": "nik9000", "createdAt": "2020-08-03T12:16:18Z", "path": "benchmarks/README.md", "diffHunk": "@@ -63,3 +63,29 @@ To get realistic results, you should exercise care when running benchmarks. Here\n * Blindly believe the numbers that your microbenchmark produces but verify them by measuring e.g. with `-prof perfasm`.\n * Run more threads than your number of CPU cores (in case you run multi-threaded microbenchmarks).\n * Look only at the `Score` column and ignore `Error`. Instead take countermeasures to keep `Error` low / variance explainable.\n+", "originalCommit": "d2ba5938ef47250c0a1eca30a21faa93f095b2b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3OTUzMw==", "url": "https://github.com/elastic/elasticsearch/pull/60585#discussion_r464479533", "bodyText": "Seems helpful to me... I would appreciate instructions like this if I were getting started :)", "author": "polyfractal", "createdAt": "2020-08-03T15:14:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM3NTQyMw=="}], "type": "inlineReview"}, {"oid": "fc5734da3bb2b8a3d8e0ffe07cada23a8faaf414", "url": "https://github.com/elastic/elasticsearch/commit/fc5734da3bb2b8a3d8e0ffe07cada23a8faaf414", "message": "no indent", "committedDate": "2020-08-03T12:30:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQxMjE0MA==", "url": "https://github.com/elastic/elasticsearch/pull/60585#discussion_r464412140", "bodyText": "This seems like a good candidate for randomized testing, since we have an alternative (slower) implementation that the new implementation should match exactly.  Then again, that might be overkill.", "author": "not-napoleon", "createdAt": "2020-08-03T13:27:15Z", "path": "server/src/test/java/org/elasticsearch/common/time/DateUtilsRoundingTests.java", "diffHunk": "@@ -46,4 +46,14 @@ public void testDateUtilsRounding() {\n             }\n         }\n     }\n+\n+    public void testIsLeapYear() {", "originalCommit": "fc5734da3bb2b8a3d8e0ffe07cada23a8faaf414", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQxNDc1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/60585#discussion_r464414751", "bodyText": "We sort of have that above. I wrote this to have something simple to double check my bit twiddling.", "author": "nik9000", "createdAt": "2020-08-03T13:31:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQxMjE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQxNTYyNw==", "url": "https://github.com/elastic/elasticsearch/pull/60585#discussion_r464415627", "bodyText": "ah, so we do.  Should have looked deeper before I commented.", "author": "not-napoleon", "createdAt": "2020-08-03T13:33:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQxMjE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTExODA1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/60585#discussion_r465118053", "bodyText": "Something I was thinking about - do we see the difference because of the change from year % 400 to (year / 100) & 3, or because of unrolling the short circuit logic?  And if it's only the former, does it make more sense to leave this as a one-liner and let the optimizer short circuit it as necessary?  I'm more asking out of curiosity about how the optimizer works than out of a need to see this changed.", "author": "not-napoleon", "createdAt": "2020-08-04T15:01:53Z", "path": "server/src/main/java/org/elasticsearch/common/time/DateUtilsRounding.java", "diffHunk": "@@ -92,8 +92,27 @@ static long utcMillisAtStartOfYear(final int year) {\n         return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * MILLIS_PER_DAY; // millis per day\n     }\n \n-    private static boolean isLeapYear(final int year) {\n-        return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);\n+    static boolean isLeapYear(final int year) {\n+        // Joda had\n+        // return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);\n+        // But we've replaced that with this:\n+        if ((year & 3) != 0) {\n+            return false;\n+        }\n+        if (year % 100 != 0) {\n+            return true;\n+        }\n+        return ((year / 100) & 3) == 0;", "originalCommit": "fc5734da3bb2b8a3d8e0ffe07cada23a8faaf414", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk3NDkwNg==", "url": "https://github.com/elastic/elasticsearch/pull/60585#discussion_r465974906", "bodyText": "I think the short circuiting is actually the same here. At least, that is how I read the Java. I believe the speed is entirely around the change from (year % 400) == 0 to ((year / 100) & 3) == 0. We certainly could keep it as a one liner, but I think it as harder to read that way. Certainly harder for me to track down the disassembly chunks because the disassembler sticks line numbers in there. Not that you can truly believe them though.", "author": "nik9000", "createdAt": "2020-08-05T20:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTExODA1Mw=="}], "type": "inlineReview"}]}