{"pr_number": 64976, "pr_title": "Makes testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats more robust", "pr_createdAt": "2020-11-12T09:22:47Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/64976", "timeline": [{"oid": "db1ef4e2b0ae7a3163aadd1c5bb5cefbb9aba4dc", "url": "https://github.com/elastic/elasticsearch/commit/db1ef4e2b0ae7a3163aadd1c5bb5cefbb9aba4dc", "message": "Check snapshot shard sizes within cluster state listener\n\ncloses #64167", "committedDate": "2020-11-12T09:19:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5MjgzNA==", "url": "https://github.com/elastic/elasticsearch/pull/64976#discussion_r521992834", "bodyText": "Should we  remove this listener before we enter the busy assert loop? Otherwise subsequent CS updates will run into it again in the background again and again? (technically probably not a problem because subsequent CS updates will prevent us from getting here but I'd still remove it to have one less thing to worry about when debugging this :)", "author": "original-brownbear", "createdAt": "2020-11-12T10:17:53Z", "path": "x-pack/plugin/ccr/src/internalClusterTest/java/org/elasticsearch/xpack/ccr/CcrRepositoryIT.java", "diffHunk": "@@ -513,69 +517,62 @@ public void testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats()\n                 equalTo(indexStats.getIndexShards().get(shardId).getPrimary().getStore().getSizeInBytes()));\n         }\n \n-        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n-\n-        final List<MockTransportService> transportServices = new ArrayList<>();\n-        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n-            final MockTransportService mockTransportService = (MockTransportService) transportService;\n-            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n-                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n-                    try {\n-                        blockCcrRestore.await();\n-                    } catch (InterruptedException e) {\n-                        throw new AssertionError(e);\n+        final String followerIndex = \"follower\";\n+        final RestoreService restoreService = getFollowerCluster().getCurrentMasterNodeInstance(RestoreService.class);\n+        final ClusterService clusterService = getFollowerCluster().getCurrentMasterNodeInstance(ClusterService.class);\n+        final SnapshotsInfoService snapshotsInfoService = getFollowerCluster().getCurrentMasterNodeInstance(SnapshotsInfoService.class);\n+\n+        final Map<Integer, Long> fetchedSnapshotShardSizes = new ConcurrentHashMap<>();\n+\n+        final PlainActionFuture<Void> waitForRestoreInProgress = PlainActionFuture.newFuture();\n+        final ClusterStateListener listener = event -> {\n+            RestoreInProgress restoreInProgress = event.state().custom(RestoreInProgress.TYPE, RestoreInProgress.EMPTY);\n+            if (restoreInProgress != null\n+                && restoreInProgress.isEmpty() == false\n+                && event.state().routingTable().hasIndex(followerIndex)) {\n+                final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(followerIndex);\n+                for (ShardRouting shardRouting : indexRoutingTable.shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                    if (shardRouting.unassignedInfo().getLastAllocationStatus() == AllocationStatus.FETCHING_SHARD_DATA) {\n+                        try {", "originalCommit": "db1ef4e2b0ae7a3163aadd1c5bb5cefbb9aba4dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5OTk4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/64976#discussion_r521999983", "bodyText": "We need to run in it again and again until all unassigned shards are allocated, so it should not be an issue but in case more than 4 shards are created there should be multiple CS updates to allocate all primaries.\nThat's also the reason why the Map<Integer,Long> is outside the scope of the listener.", "author": "tlrx", "createdAt": "2020-11-12T10:29:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5MjgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAwMDQ1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/64976#discussion_r522000453", "bodyText": "\ud83e\udd26 right ... nevermind me :)", "author": "original-brownbear", "createdAt": "2020-11-12T10:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5MjgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5MzE5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/64976#discussion_r521993192", "bodyText": "Let's add the exception to the AssertionError?", "author": "original-brownbear", "createdAt": "2020-11-12T10:18:28Z", "path": "x-pack/plugin/ccr/src/internalClusterTest/java/org/elasticsearch/xpack/ccr/CcrRepositoryIT.java", "diffHunk": "@@ -513,69 +517,62 @@ public void testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats()\n                 equalTo(indexStats.getIndexShards().get(shardId).getPrimary().getStore().getSizeInBytes()));\n         }\n \n-        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n-\n-        final List<MockTransportService> transportServices = new ArrayList<>();\n-        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n-            final MockTransportService mockTransportService = (MockTransportService) transportService;\n-            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n-                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n-                    try {\n-                        blockCcrRestore.await();\n-                    } catch (InterruptedException e) {\n-                        throw new AssertionError(e);\n+        final String followerIndex = \"follower\";\n+        final RestoreService restoreService = getFollowerCluster().getCurrentMasterNodeInstance(RestoreService.class);\n+        final ClusterService clusterService = getFollowerCluster().getCurrentMasterNodeInstance(ClusterService.class);\n+        final SnapshotsInfoService snapshotsInfoService = getFollowerCluster().getCurrentMasterNodeInstance(SnapshotsInfoService.class);\n+\n+        final Map<Integer, Long> fetchedSnapshotShardSizes = new ConcurrentHashMap<>();\n+\n+        final PlainActionFuture<Void> waitForRestoreInProgress = PlainActionFuture.newFuture();\n+        final ClusterStateListener listener = event -> {\n+            RestoreInProgress restoreInProgress = event.state().custom(RestoreInProgress.TYPE, RestoreInProgress.EMPTY);\n+            if (restoreInProgress != null\n+                && restoreInProgress.isEmpty() == false\n+                && event.state().routingTable().hasIndex(followerIndex)) {\n+                final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(followerIndex);\n+                for (ShardRouting shardRouting : indexRoutingTable.shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                    if (shardRouting.unassignedInfo().getLastAllocationStatus() == AllocationStatus.FETCHING_SHARD_DATA) {\n+                        try {\n+                            assertBusy(() -> {\n+                                final Long snapshotShardSize = snapshotsInfoService.snapshotShardSizes().getShardSize(shardRouting);\n+                                assertThat(snapshotShardSize, notNullValue());\n+                                fetchedSnapshotShardSizes.put(shardRouting.getId(), snapshotShardSize);\n+                            }, 30L, TimeUnit.SECONDS);\n+                        } catch (Exception e) {\n+                            throw new AssertionError(\"Failed to retrieve snapshot shard size for shard \" + shardRouting);", "originalCommit": "db1ef4e2b0ae7a3163aadd1c5bb5cefbb9aba4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5MzUzOA==", "url": "https://github.com/elastic/elasticsearch/pull/64976#discussion_r521993538", "bodyText": "Let's add a -->  prefix to this logging like we have for other test log lines?", "author": "original-brownbear", "createdAt": "2020-11-12T10:19:02Z", "path": "x-pack/plugin/ccr/src/internalClusterTest/java/org/elasticsearch/xpack/ccr/CcrRepositoryIT.java", "diffHunk": "@@ -513,69 +517,62 @@ public void testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats()\n                 equalTo(indexStats.getIndexShards().get(shardId).getPrimary().getStore().getSizeInBytes()));\n         }\n \n-        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n-\n-        final List<MockTransportService> transportServices = new ArrayList<>();\n-        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n-            final MockTransportService mockTransportService = (MockTransportService) transportService;\n-            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n-                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n-                    try {\n-                        blockCcrRestore.await();\n-                    } catch (InterruptedException e) {\n-                        throw new AssertionError(e);\n+        final String followerIndex = \"follower\";\n+        final RestoreService restoreService = getFollowerCluster().getCurrentMasterNodeInstance(RestoreService.class);\n+        final ClusterService clusterService = getFollowerCluster().getCurrentMasterNodeInstance(ClusterService.class);\n+        final SnapshotsInfoService snapshotsInfoService = getFollowerCluster().getCurrentMasterNodeInstance(SnapshotsInfoService.class);\n+\n+        final Map<Integer, Long> fetchedSnapshotShardSizes = new ConcurrentHashMap<>();\n+\n+        final PlainActionFuture<Void> waitForRestoreInProgress = PlainActionFuture.newFuture();\n+        final ClusterStateListener listener = event -> {\n+            RestoreInProgress restoreInProgress = event.state().custom(RestoreInProgress.TYPE, RestoreInProgress.EMPTY);\n+            if (restoreInProgress != null\n+                && restoreInProgress.isEmpty() == false\n+                && event.state().routingTable().hasIndex(followerIndex)) {\n+                final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(followerIndex);\n+                for (ShardRouting shardRouting : indexRoutingTable.shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                    if (shardRouting.unassignedInfo().getLastAllocationStatus() == AllocationStatus.FETCHING_SHARD_DATA) {\n+                        try {\n+                            assertBusy(() -> {\n+                                final Long snapshotShardSize = snapshotsInfoService.snapshotShardSizes().getShardSize(shardRouting);\n+                                assertThat(snapshotShardSize, notNullValue());\n+                                fetchedSnapshotShardSizes.put(shardRouting.getId(), snapshotShardSize);\n+                            }, 30L, TimeUnit.SECONDS);\n+                        } catch (Exception e) {\n+                            throw new AssertionError(\"Failed to retrieve snapshot shard size for shard \" + shardRouting);\n+                        }\n                     }\n                 }\n-                connection.sendRequest(requestId, action, request, options);\n-            });\n-            transportServices.add(mockTransportService);\n-        }\n-\n-        try {\n-            final String followerIndex = \"follower\";\n-            final RestoreService restoreService = getFollowerCluster().getCurrentMasterNodeInstance(RestoreService.class);\n-            final ClusterService clusterService = getFollowerCluster().getCurrentMasterNodeInstance(ClusterService.class);\n-\n-            final PlainActionFuture<IndexRoutingTable> waitForRestoreInProgress = PlainActionFuture.newFuture();\n-            final ClusterStateListener listener = event -> {\n-                RestoreInProgress restoreInProgress = event.state().custom(RestoreInProgress.TYPE, RestoreInProgress.EMPTY);\n-                if (restoreInProgress != null\n-                    && restoreInProgress.isEmpty() == false\n-                    && event.state().routingTable().hasIndex(followerIndex)) {\n-                    waitForRestoreInProgress.onResponse(event.state().routingTable().index(followerIndex));\n-                }\n-            };\n-            clusterService.addListener(listener);\n-\n-            final RestoreSnapshotRequest restoreRequest = new RestoreSnapshotRequest(leaderCluster, CcrRepository.LATEST)\n-                .indices(leaderIndex).indicesOptions(indicesOptions).renamePattern(\"^(.*)$\")\n-                .renameReplacement(followerIndex)\n-                .masterNodeTimeout(TimeValue.MAX_VALUE)\n-                .indexSettings(Settings.builder()\n-                    .put(IndexMetadata.SETTING_INDEX_PROVIDED_NAME, followerIndex)\n-                    .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true));\n-            restoreService.restoreSnapshot(restoreRequest, PlainActionFuture.newFuture());\n-\n-            final IndexRoutingTable indexRoutingTable = waitForRestoreInProgress.get(30L, TimeUnit.SECONDS);\n-            clusterService.removeListener(listener);\n-\n-            final SnapshotsInfoService snapshotsInfoService = getFollowerCluster().getCurrentMasterNodeInstance(SnapshotsInfoService.class);\n-            assertBusy(() -> {\n-                SnapshotShardSizeInfo snapshotShardSizeInfo = snapshotsInfoService.snapshotShardSizes();\n-                for (int shardId = 0; shardId < numberOfShards; shardId++) {\n-                    Long snapshotShardSize = snapshotShardSizeInfo.getShardSize(indexRoutingTable.shard(shardId).primaryShard());\n-                    assertThat(snapshotShardSize,\n-                        equalTo(indexStats.getIndexShards().get(shardId).getPrimary().getStore().getSizeInBytes()));\n+                logger.info(\"[{}/{}] snapshot shard sizes fetched\", fetchedSnapshotShardSizes.size(), numberOfShards);", "originalCommit": "db1ef4e2b0ae7a3163aadd1c5bb5cefbb9aba4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5NDg0OA==", "url": "https://github.com/elastic/elasticsearch/pull/64976#discussion_r521994848", "bodyText": "Could just make this a PlainActionFuture<Map<Integer, Long>> and return the map from it instead of having it in the outer scope? :) Makes it a little clearer when the map is coming from and you don't have to reason about why there's a CHM when debugging this.", "author": "original-brownbear", "createdAt": "2020-11-12T10:21:02Z", "path": "x-pack/plugin/ccr/src/internalClusterTest/java/org/elasticsearch/xpack/ccr/CcrRepositoryIT.java", "diffHunk": "@@ -513,69 +517,62 @@ public void testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats()\n                 equalTo(indexStats.getIndexShards().get(shardId).getPrimary().getStore().getSizeInBytes()));\n         }\n \n-        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n-\n-        final List<MockTransportService> transportServices = new ArrayList<>();\n-        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n-            final MockTransportService mockTransportService = (MockTransportService) transportService;\n-            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n-                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n-                    try {\n-                        blockCcrRestore.await();\n-                    } catch (InterruptedException e) {\n-                        throw new AssertionError(e);\n+        final String followerIndex = \"follower\";\n+        final RestoreService restoreService = getFollowerCluster().getCurrentMasterNodeInstance(RestoreService.class);\n+        final ClusterService clusterService = getFollowerCluster().getCurrentMasterNodeInstance(ClusterService.class);\n+        final SnapshotsInfoService snapshotsInfoService = getFollowerCluster().getCurrentMasterNodeInstance(SnapshotsInfoService.class);\n+\n+        final Map<Integer, Long> fetchedSnapshotShardSizes = new ConcurrentHashMap<>();\n+\n+        final PlainActionFuture<Void> waitForRestoreInProgress = PlainActionFuture.newFuture();", "originalCommit": "db1ef4e2b0ae7a3163aadd1c5bb5cefbb9aba4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f9b53cc028527df15d116fcc73f4b239144bb911", "url": "https://github.com/elastic/elasticsearch/commit/f9b53cc028527df15d116fcc73f4b239144bb911", "message": "add exception ++ -->", "committedDate": "2020-11-12T10:29:58Z", "type": "commit"}]}