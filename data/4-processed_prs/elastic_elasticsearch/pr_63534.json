{"pr_number": 63534, "pr_title": "Fix Broken Snapshot State Machine in Corner Case", "pr_createdAt": "2020-10-12T08:10:51Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/63534", "timeline": [{"oid": "b3f8c8a62fa9b8909ef96d7a96883cbbe553e7db", "url": "https://github.com/elastic/elasticsearch/commit/b3f8c8a62fa9b8909ef96d7a96883cbbe553e7db", "message": "Fix Broken Snapshot State Machine in Corner Case\n\nThis fixes a gap in testing and a bug that can occur in various forms:\nWhen we would start a snapshot or clone related to a shard that was done\nsnapshotting/cloning but its overall operation was not yet finalized\nat the time of starting the operation, we would base the operation off of\nthe wrong generation. This would not cause a corrupted repo, but would\ncause the operation to be `PARTIAL`.\nThis commit fixes the state machine to take into account the correct generation\nin this case.\n\nCloses #63498", "committedDate": "2020-10-12T08:03:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzExNzE0MA==", "url": "https://github.com/elastic/elasticsearch/pull/63534#discussion_r503117140", "bodyText": "Sorry for making this so complicated, but this required 4 new tests I'm afraid because you can have all possible combinations of clone or snapshot ready for a shard but not finalized and then wanting to run either a new clone or new snapshot => 2 x 2 = 4 possible buggy scenarios.", "author": "original-brownbear", "createdAt": "2020-10-12T08:17:18Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/snapshots/ConcurrentSnapshotsIT.java", "diffHunk": "@@ -1248,6 +1248,33 @@ public void testAbortNotStartedSnapshotWithoutIO() throws Exception {\n         assertThat(getRepositoryData(repoName).getGenId(), is(0L));\n     }\n \n+    public void testStartWithSuccessfulShardSnapshotPendingFinalization() throws Exception {", "originalCommit": "b3f8c8a62fa9b8909ef96d7a96883cbbe553e7db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzExOTgzNg==", "url": "https://github.com/elastic/elasticsearch/pull/63534#discussion_r503119836", "bodyText": "I was really torn about adding a new class for this one, but I figured adding this logic to SnapshotsInProgress or SnapshotsService isn't so great because those two classes are already very very complicated. This way we can at least take some of the complication out of them?", "author": "original-brownbear", "createdAt": "2020-10-12T08:21:39Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InFlightShardSnapshotStates.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectObjectCursor;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoryShardId;\n+import org.elasticsearch.repositories.ShardGenerations;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Holds information about currently in-flight shard level snapshot or clone operations on a per-shard level.\n+ * Concretely, this means information on which shards are actively being written to in the repository currently\n+ * as well as the latest written shard generation per shard in case there is a shard generation for a shard that has\n+ * been cleanly written out to the repository but not yet made part of the current {@link org.elasticsearch.repositories.RepositoryData}\n+ * through a snapshot finalization.\n+ */\n+public final class InFlightShardSnapshotStates {", "originalCommit": "b3f8c8a62fa9b8909ef96d7a96883cbbe553e7db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxMjMwNA==", "url": "https://github.com/elastic/elasticsearch/pull/63534#discussion_r503812304", "bodyText": "I think it was a good idea to factor out this into its own class. The client code is easier to read.", "author": "fcofdez", "createdAt": "2020-10-13T09:40:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzExOTgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEyMTY5NA==", "url": "https://github.com/elastic/elasticsearch/pull/63534#discussion_r503121694", "bodyText": "Not having this was a serious gap in our testing unfortunately. We've had various test failures that were essentially the result of a race with physically writing the next index generation while the repo wasn't yet in a consistent state. The new tests using this significantly up the coverage of this scenario (at the annoying cost of making this class yet again more complex).", "author": "original-brownbear", "createdAt": "2020-10-12T08:24:39Z", "path": "test/framework/src/main/java/org/elasticsearch/snapshots/mockstore/MockRepository.java", "diffHunk": "@@ -111,8 +111,15 @@ public long getFailureCount() {\n \n     private volatile boolean blockOnDeleteIndexN;\n \n-    /** Allows blocking on writing the index-N blob; this is a way to enforce blocking the\n-     *  finalization of a snapshot, while permitting other IO operations to proceed unblocked. */\n+    /**\n+     * Allows blocking on writing the index-N blob and subsequently failing it on unblock.\n+     * This is a way to enforce blocking the  finalization of a snapshot, while permitting other IO operations to proceed unblocked.\n+     */\n+    private volatile boolean blockAndFailOnWriteIndexFile;\n+\n+    /**\n+     * Same as {@link #blockAndFailOnWriteIndexFile} but proceeds without error after unblock.\n+     */\n     private volatile boolean blockOnWriteIndexFile;", "originalCommit": "b3f8c8a62fa9b8909ef96d7a96883cbbe553e7db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgzODI1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/63534#discussion_r503838257", "bodyText": "It worth it IMO", "author": "tlrx", "createdAt": "2020-10-13T10:23:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEyMTY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEyMzE2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/63534#discussion_r503123163", "bodyText": "Obvious bug here and in snapshot creation in hindsight ... fortunately this was not something that would corrupt the repository but it would lead to a lot of partial snapshots in practice (seen this in prod. logs as well not just this test failure).", "author": "original-brownbear", "createdAt": "2020-10-12T08:26:55Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -484,26 +484,22 @@ public ClusterState execute(ClusterState currentState) {\n                 boolean changed = false;\n                 final String localNodeId = currentState.nodes().getLocalNodeId();\n                 final String repoName = cloneEntry.repository();\n-                final Map<String, IndexId> indexIds = getInFlightIndexIds(updatedEntries, repoName);\n                 final ShardGenerations shardGenerations = repoData.shardGenerations();\n                 for (int i = 0; i < updatedEntries.size(); i++) {\n-                    if (cloneEntry.equals(updatedEntries.get(i))) {\n+                    if (cloneEntry.snapshot().equals(updatedEntries.get(i).snapshot())) {\n                         final ImmutableOpenMap.Builder<RepositoryShardId, ShardSnapshotStatus> clonesBuilder =\n                                 ImmutableOpenMap.builder();\n-                        // TODO: could be optimized by just dealing with repo shard id directly\n-                        final Set<RepositoryShardId> busyShardsInRepo =\n-                                busyShardsForRepo(repoName, snapshotsInProgress, currentState.metadata())\n-                                        .stream()\n-                                        .map(shardId -> new RepositoryShardId(indexIds.get(shardId.getIndexName()), shardId.getId()))\n-                                        .collect(Collectors.toSet());\n+                        final InFlightShardSnapshotStates inFlightShardStates =\n+                            InFlightShardSnapshotStates.forRepo(repoName, snapshotsInProgress.entries());\n                         for (Tuple<IndexId, Integer> count : counts) {\n                             for (int shardId = 0; shardId < count.v2(); shardId++) {\n                                 final RepositoryShardId repoShardId = new RepositoryShardId(count.v1(), shardId);\n-                                if (busyShardsInRepo.contains(repoShardId)) {\n+                                final String indexName = repoShardId.indexName();\n+                                if (inFlightShardStates.isBusy(indexName, shardId)) {\n                                     clonesBuilder.put(repoShardId, ShardSnapshotStatus.UNASSIGNED_QUEUED);\n                                 } else {\n-                                    clonesBuilder.put(repoShardId,\n-                                            new ShardSnapshotStatus(localNodeId, shardGenerations.getShardGen(count.v1(), shardId)));\n+                                    clonesBuilder.put(repoShardId, new ShardSnapshotStatus(localNodeId,\n+                                        inFlightShardStates.bestGeneration(repoShardId.index(), shardId, shardGenerations)));", "originalCommit": "b3f8c8a62fa9b8909ef96d7a96883cbbe553e7db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEyNjM4MA==", "url": "https://github.com/elastic/elasticsearch/pull/63534#discussion_r503126380", "bodyText": "The fact that we would block on data files here even though snapshot 3  and snapshot 2 were snapshotting the same data actually already demonstrated the bug in hindsight. Since this test forces an exception on this snapshot below this was hidden from us unfortunately.", "author": "original-brownbear", "createdAt": "2020-10-12T08:31:53Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/snapshots/ConcurrentSnapshotsIT.java", "diffHunk": "@@ -435,7 +435,7 @@ public void testMasterFailOverWithQueuedDeletes() throws Exception {\n         final ActionFuture<AcknowledgedResponse> firstDeleteFuture = startDeleteFromNonMasterClient(repoName, firstSnapshot);\n         awaitNDeletionsInProgress(1);\n \n-        blockDataNode(repoName, dataNode2);\n+        blockNodeOnAnyFiles(repoName, dataNode2);", "originalCommit": "b3f8c8a62fa9b8909ef96d7a96883cbbe553e7db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgwMzYzMg==", "url": "https://github.com/elastic/elasticsearch/pull/63534#discussion_r503803632", "bodyText": "I find this method name a bit confusing. Maybe we should rename it to generationForShard or something along those lines?", "author": "fcofdez", "createdAt": "2020-10-13T09:27:47Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InFlightShardSnapshotStates.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectObjectCursor;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoryShardId;\n+import org.elasticsearch.repositories.ShardGenerations;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Holds information about currently in-flight shard level snapshot or clone operations on a per-shard level.\n+ * Concretely, this means information on which shards are actively being written to in the repository currently\n+ * as well as the latest written shard generation per shard in case there is a shard generation for a shard that has\n+ * been cleanly written out to the repository but not yet made part of the current {@link org.elasticsearch.repositories.RepositoryData}\n+ * through a snapshot finalization.\n+ */\n+public final class InFlightShardSnapshotStates {\n+\n+    /**\n+     * Compute information about all shard ids that currently have in-flight state for the given repository.\n+     *\n+     * @param repoName  repository name\n+     * @param snapshots snapshots in progress\n+     * @return in flight shard states for all snapshot operation running for the given repository name\n+     */\n+    public static InFlightShardSnapshotStates forRepo(String repoName, List<SnapshotsInProgress.Entry> snapshots) {\n+        final Map<String, Map<Integer, String>> generations = new HashMap<>();\n+        final Map<String, Set<Integer>> busyIds = new HashMap<>();\n+        for (SnapshotsInProgress.Entry runningSnapshot : snapshots) {\n+            if (runningSnapshot.repository().equals(repoName) == false) {\n+                continue;\n+            }\n+            if (runningSnapshot.isClone()) {\n+                for (ObjectObjectCursor<RepositoryShardId, SnapshotsInProgress.ShardSnapshotStatus> clone : runningSnapshot.clones()) {\n+                    final RepositoryShardId repoShardId = clone.key;\n+                    addStateInformation(generations, busyIds, clone.value, repoShardId.shardId(), repoShardId.indexName());\n+                }\n+            } else {\n+                for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shard : runningSnapshot.shards()) {\n+                    final ShardId sid = shard.key;\n+                    addStateInformation(generations, busyIds, shard.value, sid.id(), sid.getIndexName());\n+                }\n+            }\n+        }\n+        return new InFlightShardSnapshotStates(generations, busyIds);\n+    }\n+\n+    private static void addStateInformation(Map<String, Map<Integer, String>> generations, Map<String, Set<Integer>> busyIds,\n+                                            SnapshotsInProgress.ShardSnapshotStatus shardState, int shardId, String indexName) {\n+        if (shardState.isActive()) {\n+            busyIds.computeIfAbsent(indexName, k -> new HashSet<>()).add(shardId);\n+            assert assertGenerationConsistency(generations, indexName, shardId, shardState.generation());\n+        } else if (shardState.state() == SnapshotsInProgress.ShardState.SUCCESS) {\n+            assert busyIds.getOrDefault(indexName, Collections.emptySet()).contains(shardId) == false :\n+                \"Can't have a successful operation queued after an in-progress operation\";\n+            generations.computeIfAbsent(indexName, k -> new HashMap<>()).put(shardId, shardState.generation());\n+        }\n+    }\n+\n+    /**\n+     * Map that maps index name to a nested map of shard id to most recent successful shard generation for that\n+     * shard id.\n+     */\n+    private final Map<String, Map<Integer, String>> generations;\n+\n+    /**\n+     * Map of index name to a set of shard ids that currently are actively executing an operation on the repository.\n+     */\n+    private final Map<String, Set<Integer>> busyIds;\n+\n+\n+    private InFlightShardSnapshotStates(Map<String, Map<Integer, String>> generations, Map<String, Set<Integer>> busyIds) {\n+        this.generations = generations;\n+        this.busyIds = busyIds;\n+    }\n+\n+    private static boolean assertGenerationConsistency(Map<String, Map<Integer, String>> generations, String indexName,\n+                                                       int shardId, String activeGeneration) {\n+        final String bestGeneration = generations.getOrDefault(indexName, Collections.emptyMap()).get(shardId);\n+        assert bestGeneration == null || activeGeneration.equals(bestGeneration);\n+        return true;\n+    }\n+\n+    /**\n+     * Check if a given shard currently has an actively executing shard operation.\n+     *\n+     * @param indexName name of the shard's index\n+     * @param shardId   shard id of the shard\n+     * @return true if shard has an actively executing shard operation\n+     */\n+    boolean isBusy(String indexName, int shardId) {\n+        return busyIds.getOrDefault(indexName, Collections.emptySet()).contains(shardId);\n+    }\n+\n+    /**\n+     * Determine the current generation for a shard by first checking if any in-flight but successful new shard\n+     * snapshots or clones have set a relevant generation and then falling back to {@link ShardGenerations#getShardGen}\n+     * if not.\n+     *\n+     * @param indexId          index id of the shard\n+     * @param shardId          shard id of the shard\n+     * @param shardGenerations current shard generations in the repository data\n+     * @return most recent shard generation for the given shard\n+     */\n+    @Nullable\n+    String bestGeneration(IndexId indexId, int shardId, ShardGenerations shardGenerations) {", "originalCommit": "b3f8c8a62fa9b8909ef96d7a96883cbbe553e7db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxMDQ1OA==", "url": "https://github.com/elastic/elasticsearch/pull/63534#discussion_r503810458", "bodyText": "I guess that it's enough to assert that the snapshot is successful to ensure that they get the corresponding generation number? otherwise it would be a partial snapshot, right?", "author": "fcofdez", "createdAt": "2020-10-13T09:37:54Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/snapshots/CloneSnapshotIT.java", "diffHunk": "@@ -469,6 +470,105 @@ public void testDoesNotStartOnBrokenSourceSnapshot() throws Exception {\n         \"] because its snapshot was not successful.\"));\n     }\n \n+    public void testStartSnapshotWithSuccessfulShardClonePendingFinalization() throws Exception {\n+        final String masterName = internalCluster().startMasterOnlyNode(LARGE_SNAPSHOT_POOL_SETTINGS);\n+        final String dataNode = internalCluster().startDataOnlyNode();\n+        final String repoName = \"test-repo\";\n+        createRepository(repoName, \"mock\");\n+\n+        final String indexName = \"test-idx\";\n+        createIndexWithContent(indexName);\n+\n+        final String sourceSnapshot = \"source-snapshot\";\n+        createFullSnapshot(repoName, sourceSnapshot);\n+\n+        blockMasterOnWriteIndexFile(repoName);\n+        final String cloneName = \"clone-blocked\";\n+        final ActionFuture<AcknowledgedResponse> blockedClone = startClone(repoName, sourceSnapshot, cloneName, indexName);\n+        waitForBlock(masterName, repoName, TimeValue.timeValueSeconds(30L));\n+        awaitNumberOfSnapshotsInProgress(1);\n+        blockNodeOnAnyFiles(repoName, dataNode);\n+        final ActionFuture<CreateSnapshotResponse> otherSnapshot = startFullSnapshot(repoName, \"other-snapshot\");\n+        awaitNumberOfSnapshotsInProgress(2);\n+        assertFalse(blockedClone.isDone());\n+        unblockNode(repoName, masterName);\n+        awaitNumberOfSnapshotsInProgress(1);\n+        awaitMasterFinishRepoOperations();\n+        unblockNode(repoName, dataNode);\n+        assertAcked(blockedClone.get());\n+        assertEquals(getSnapshot(repoName, cloneName).state(), SnapshotState.SUCCESS);\n+        assertSuccessful(otherSnapshot);", "originalCommit": "b3f8c8a62fa9b8909ef96d7a96883cbbe553e7db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg2MTQ2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/63534#discussion_r503861465", "bodyText": "Yea exactly, if the snapshot was based off of a broken/outdated shard generation value it would be PARTIAL because the shard(s) working from the broken generation would fail with a ~FileNotFoundException/404.", "author": "original-brownbear", "createdAt": "2020-10-13T11:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxMDQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxMzI2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/63534#discussion_r503813262", "bodyText": "nit: extra line", "author": "tlrx", "createdAt": "2020-10-13T09:42:13Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/snapshots/CloneSnapshotIT.java", "diffHunk": "@@ -469,6 +470,105 @@ public void testDoesNotStartOnBrokenSourceSnapshot() throws Exception {\n         \"] because its snapshot was not successful.\"));\n     }\n \n+    public void testStartSnapshotWithSuccessfulShardClonePendingFinalization() throws Exception {\n+        final String masterName = internalCluster().startMasterOnlyNode(LARGE_SNAPSHOT_POOL_SETTINGS);\n+        final String dataNode = internalCluster().startDataOnlyNode();\n+        final String repoName = \"test-repo\";\n+        createRepository(repoName, \"mock\");\n+\n+        final String indexName = \"test-idx\";\n+        createIndexWithContent(indexName);\n+\n+        final String sourceSnapshot = \"source-snapshot\";\n+        createFullSnapshot(repoName, sourceSnapshot);\n+\n+        blockMasterOnWriteIndexFile(repoName);\n+        final String cloneName = \"clone-blocked\";\n+        final ActionFuture<AcknowledgedResponse> blockedClone = startClone(repoName, sourceSnapshot, cloneName, indexName);\n+        waitForBlock(masterName, repoName, TimeValue.timeValueSeconds(30L));\n+        awaitNumberOfSnapshotsInProgress(1);\n+        blockNodeOnAnyFiles(repoName, dataNode);\n+        final ActionFuture<CreateSnapshotResponse> otherSnapshot = startFullSnapshot(repoName, \"other-snapshot\");\n+        awaitNumberOfSnapshotsInProgress(2);\n+        assertFalse(blockedClone.isDone());\n+        unblockNode(repoName, masterName);\n+        awaitNumberOfSnapshotsInProgress(1);\n+        awaitMasterFinishRepoOperations();\n+        unblockNode(repoName, dataNode);\n+        assertAcked(blockedClone.get());\n+        assertEquals(getSnapshot(repoName, cloneName).state(), SnapshotState.SUCCESS);\n+        assertSuccessful(otherSnapshot);\n+    }\n+\n+    public void testStartCloneWithSuccessfulShardClonePendingFinalization() throws Exception {\n+        final String masterName = internalCluster().startMasterOnlyNode();\n+        internalCluster().startDataOnlyNode();\n+        final String repoName = \"test-repo\";\n+        createRepository(repoName, \"mock\");\n+\n+        final String indexName = \"test-idx\";\n+        createIndexWithContent(indexName);\n+\n+        final String sourceSnapshot = \"source-snapshot\";\n+        createFullSnapshot(repoName, sourceSnapshot);\n+\n+        blockMasterOnWriteIndexFile(repoName);\n+        final String cloneName = \"clone-blocked\";\n+        final ActionFuture<AcknowledgedResponse> blockedClone = startClone(repoName, sourceSnapshot, cloneName, indexName);\n+        waitForBlock(masterName, repoName, TimeValue.timeValueSeconds(30L));\n+        awaitNumberOfSnapshotsInProgress(1);\n+        final String otherCloneName = \"other-clone\";\n+        final ActionFuture<AcknowledgedResponse> otherClone = startClone(repoName, sourceSnapshot, otherCloneName, indexName);\n+        awaitNumberOfSnapshotsInProgress(2);\n+        assertFalse(blockedClone.isDone());\n+        unblockNode(repoName, masterName);\n+        awaitNoMoreRunningOperations(masterName);\n+        awaitMasterFinishRepoOperations();\n+        assertAcked(blockedClone.get());\n+        assertAcked(otherClone.get());\n+        assertEquals(getSnapshot(repoName, cloneName).state(), SnapshotState.SUCCESS);\n+        assertEquals(getSnapshot(repoName, otherCloneName).state(), SnapshotState.SUCCESS);\n+    }\n+\n+    public void testStartCloneWithSuccessfulShardSnapshotPendingFinalization() throws Exception {\n+        final String masterName = internalCluster().startMasterOnlyNode(LARGE_SNAPSHOT_POOL_SETTINGS);\n+        internalCluster().startDataOnlyNode();\n+        final String repoName = \"test-repo\";\n+        createRepository(repoName, \"mock\");\n+", "originalCommit": "b3f8c8a62fa9b8909ef96d7a96883cbbe553e7db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyMzMzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/63534#discussion_r503823331", "bodyText": "Maybe activeIds to mirror ShardSnapshotStatus.isActive() and activeGeneration ?", "author": "tlrx", "createdAt": "2020-10-13T09:57:53Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InFlightShardSnapshotStates.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectObjectCursor;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoryShardId;\n+import org.elasticsearch.repositories.ShardGenerations;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Holds information about currently in-flight shard level snapshot or clone operations on a per-shard level.\n+ * Concretely, this means information on which shards are actively being written to in the repository currently\n+ * as well as the latest written shard generation per shard in case there is a shard generation for a shard that has\n+ * been cleanly written out to the repository but not yet made part of the current {@link org.elasticsearch.repositories.RepositoryData}\n+ * through a snapshot finalization.\n+ */\n+public final class InFlightShardSnapshotStates {\n+\n+    /**\n+     * Compute information about all shard ids that currently have in-flight state for the given repository.\n+     *\n+     * @param repoName  repository name\n+     * @param snapshots snapshots in progress\n+     * @return in flight shard states for all snapshot operation running for the given repository name\n+     */\n+    public static InFlightShardSnapshotStates forRepo(String repoName, List<SnapshotsInProgress.Entry> snapshots) {\n+        final Map<String, Map<Integer, String>> generations = new HashMap<>();\n+        final Map<String, Set<Integer>> busyIds = new HashMap<>();\n+        for (SnapshotsInProgress.Entry runningSnapshot : snapshots) {\n+            if (runningSnapshot.repository().equals(repoName) == false) {\n+                continue;\n+            }\n+            if (runningSnapshot.isClone()) {\n+                for (ObjectObjectCursor<RepositoryShardId, SnapshotsInProgress.ShardSnapshotStatus> clone : runningSnapshot.clones()) {\n+                    final RepositoryShardId repoShardId = clone.key;\n+                    addStateInformation(generations, busyIds, clone.value, repoShardId.shardId(), repoShardId.indexName());\n+                }\n+            } else {\n+                for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shard : runningSnapshot.shards()) {\n+                    final ShardId sid = shard.key;\n+                    addStateInformation(generations, busyIds, shard.value, sid.id(), sid.getIndexName());\n+                }\n+            }\n+        }\n+        return new InFlightShardSnapshotStates(generations, busyIds);\n+    }\n+\n+    private static void addStateInformation(Map<String, Map<Integer, String>> generations, Map<String, Set<Integer>> busyIds,\n+                                            SnapshotsInProgress.ShardSnapshotStatus shardState, int shardId, String indexName) {\n+        if (shardState.isActive()) {\n+            busyIds.computeIfAbsent(indexName, k -> new HashSet<>()).add(shardId);\n+            assert assertGenerationConsistency(generations, indexName, shardId, shardState.generation());\n+        } else if (shardState.state() == SnapshotsInProgress.ShardState.SUCCESS) {\n+            assert busyIds.getOrDefault(indexName, Collections.emptySet()).contains(shardId) == false :\n+                \"Can't have a successful operation queued after an in-progress operation\";\n+            generations.computeIfAbsent(indexName, k -> new HashMap<>()).put(shardId, shardState.generation());\n+        }\n+    }\n+\n+    /**\n+     * Map that maps index name to a nested map of shard id to most recent successful shard generation for that\n+     * shard id.\n+     */\n+    private final Map<String, Map<Integer, String>> generations;\n+\n+    /**\n+     * Map of index name to a set of shard ids that currently are actively executing an operation on the repository.\n+     */\n+    private final Map<String, Set<Integer>> busyIds;", "originalCommit": "b3f8c8a62fa9b8909ef96d7a96883cbbe553e7db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyNjU2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/63534#discussion_r503826566", "bodyText": "Maybe isActive()? I find that using busy / active wording is too much.", "author": "tlrx", "createdAt": "2020-10-13T10:03:09Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InFlightShardSnapshotStates.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectObjectCursor;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoryShardId;\n+import org.elasticsearch.repositories.ShardGenerations;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Holds information about currently in-flight shard level snapshot or clone operations on a per-shard level.\n+ * Concretely, this means information on which shards are actively being written to in the repository currently\n+ * as well as the latest written shard generation per shard in case there is a shard generation for a shard that has\n+ * been cleanly written out to the repository but not yet made part of the current {@link org.elasticsearch.repositories.RepositoryData}\n+ * through a snapshot finalization.\n+ */\n+public final class InFlightShardSnapshotStates {\n+\n+    /**\n+     * Compute information about all shard ids that currently have in-flight state for the given repository.\n+     *\n+     * @param repoName  repository name\n+     * @param snapshots snapshots in progress\n+     * @return in flight shard states for all snapshot operation running for the given repository name\n+     */\n+    public static InFlightShardSnapshotStates forRepo(String repoName, List<SnapshotsInProgress.Entry> snapshots) {\n+        final Map<String, Map<Integer, String>> generations = new HashMap<>();\n+        final Map<String, Set<Integer>> busyIds = new HashMap<>();\n+        for (SnapshotsInProgress.Entry runningSnapshot : snapshots) {\n+            if (runningSnapshot.repository().equals(repoName) == false) {\n+                continue;\n+            }\n+            if (runningSnapshot.isClone()) {\n+                for (ObjectObjectCursor<RepositoryShardId, SnapshotsInProgress.ShardSnapshotStatus> clone : runningSnapshot.clones()) {\n+                    final RepositoryShardId repoShardId = clone.key;\n+                    addStateInformation(generations, busyIds, clone.value, repoShardId.shardId(), repoShardId.indexName());\n+                }\n+            } else {\n+                for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shard : runningSnapshot.shards()) {\n+                    final ShardId sid = shard.key;\n+                    addStateInformation(generations, busyIds, shard.value, sid.id(), sid.getIndexName());\n+                }\n+            }\n+        }\n+        return new InFlightShardSnapshotStates(generations, busyIds);\n+    }\n+\n+    private static void addStateInformation(Map<String, Map<Integer, String>> generations, Map<String, Set<Integer>> busyIds,\n+                                            SnapshotsInProgress.ShardSnapshotStatus shardState, int shardId, String indexName) {\n+        if (shardState.isActive()) {\n+            busyIds.computeIfAbsent(indexName, k -> new HashSet<>()).add(shardId);\n+            assert assertGenerationConsistency(generations, indexName, shardId, shardState.generation());\n+        } else if (shardState.state() == SnapshotsInProgress.ShardState.SUCCESS) {\n+            assert busyIds.getOrDefault(indexName, Collections.emptySet()).contains(shardId) == false :\n+                \"Can't have a successful operation queued after an in-progress operation\";\n+            generations.computeIfAbsent(indexName, k -> new HashMap<>()).put(shardId, shardState.generation());\n+        }\n+    }\n+\n+    /**\n+     * Map that maps index name to a nested map of shard id to most recent successful shard generation for that\n+     * shard id.\n+     */\n+    private final Map<String, Map<Integer, String>> generations;\n+\n+    /**\n+     * Map of index name to a set of shard ids that currently are actively executing an operation on the repository.\n+     */\n+    private final Map<String, Set<Integer>> busyIds;\n+\n+\n+    private InFlightShardSnapshotStates(Map<String, Map<Integer, String>> generations, Map<String, Set<Integer>> busyIds) {\n+        this.generations = generations;\n+        this.busyIds = busyIds;\n+    }\n+\n+    private static boolean assertGenerationConsistency(Map<String, Map<Integer, String>> generations, String indexName,\n+                                                       int shardId, String activeGeneration) {\n+        final String bestGeneration = generations.getOrDefault(indexName, Collections.emptyMap()).get(shardId);\n+        assert bestGeneration == null || activeGeneration.equals(bestGeneration);\n+        return true;\n+    }\n+\n+    /**\n+     * Check if a given shard currently has an actively executing shard operation.\n+     *\n+     * @param indexName name of the shard's index\n+     * @param shardId   shard id of the shard\n+     * @return true if shard has an actively executing shard operation\n+     */\n+    boolean isBusy(String indexName, int shardId) {", "originalCommit": "b3f8c8a62fa9b8909ef96d7a96883cbbe553e7db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgzNzYzMg==", "url": "https://github.com/elastic/elasticsearch/pull/63534#discussion_r503837632", "bodyText": "The number of active threads relies on ThreadPoolExecutor#getActiveCount() which is approximate, but having core == max should make this OK I think.", "author": "tlrx", "createdAt": "2020-10-13T10:21:57Z", "path": "test/framework/src/main/java/org/elasticsearch/snapshots/AbstractSnapshotIntegTestCase.java", "diffHunk": "@@ -570,4 +579,17 @@ protected SnapshotInfo getSnapshot(String repository, String snapshot) {\n         assertThat(snapshotInfos, hasSize(1));\n         return snapshotInfos.get(0);\n     }\n+\n+    protected void awaitMasterFinishRepoOperations() throws Exception {\n+        logger.info(\"--> waiting for master to finish all repo operations on its SNAPSHOT pool\");\n+        final ThreadPool masterThreadPool = internalCluster().getMasterNodeInstance(ThreadPool.class);\n+        assertBusy(() -> {\n+            for (ThreadPoolStats.Stats stat : masterThreadPool.stats()) {\n+                if (ThreadPool.Names.SNAPSHOT.equals(stat.getName())) {\n+                    assertEquals(stat.getActive(), 0);", "originalCommit": "b3f8c8a62fa9b8909ef96d7a96883cbbe553e7db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgzODAzMA==", "url": "https://github.com/elastic/elasticsearch/pull/63534#discussion_r503838030", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * This is a way to enforce blocking the  finalization of a snapshot, while permitting other IO operations to proceed unblocked.\n          \n          \n            \n                 * This is a way to enforce blocking the finalization of a snapshot, while permitting other IO operations to proceed unblocked.", "author": "tlrx", "createdAt": "2020-10-13T10:22:35Z", "path": "test/framework/src/main/java/org/elasticsearch/snapshots/mockstore/MockRepository.java", "diffHunk": "@@ -111,8 +111,15 @@ public long getFailureCount() {\n \n     private volatile boolean blockOnDeleteIndexN;\n \n-    /** Allows blocking on writing the index-N blob; this is a way to enforce blocking the\n-     *  finalization of a snapshot, while permitting other IO operations to proceed unblocked. */\n+    /**\n+     * Allows blocking on writing the index-N blob and subsequently failing it on unblock.\n+     * This is a way to enforce blocking the  finalization of a snapshot, while permitting other IO operations to proceed unblocked.", "originalCommit": "b3f8c8a62fa9b8909ef96d7a96883cbbe553e7db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgzODk4MA==", "url": "https://github.com/elastic/elasticsearch/pull/63534#discussion_r503838980", "bodyText": "Double checking my understanding, this will also update the shard generation to use for WAITING shard snapshots, right?", "author": "tlrx", "createdAt": "2020-10-13T10:24:20Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -2086,19 +2083,20 @@ public static ClusterState updateWithSnapshots(ClusterState state,\n                     final ShardId shardId = indexRoutingTable.shard(i).shardId();\n                     final String shardRepoGeneration;\n                     if (useShardGenerations) {\n-                        if (isNewIndex) {\n+                        final String inFlightGeneration = inFlightShardStates.bestGeneration(index, shardId.id(), shardGenerations);\n+                        if (inFlightGeneration == null && isNewIndex) {\n                             assert shardGenerations.getShardGen(index, shardId.getId()) == null\n                                 : \"Found shard generation for new index [\" + index + \"]\";\n                             shardRepoGeneration = ShardGenerations.NEW_SHARD_GEN;\n                         } else {\n-                            shardRepoGeneration = shardGenerations.getShardGen(index, shardId.getId());\n+                            shardRepoGeneration = inFlightGeneration;", "originalCommit": "b3f8c8a62fa9b8909ef96d7a96883cbbe553e7db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg2MDc5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/63534#discussion_r503860793", "bodyText": "Yes exactly, see a few line below where we use this variable:\n                    } else if (primary.relocating() || primary.initializing()) {\n                        shardSnapshotStatus = new ShardSnapshotStatus(\n                            primary.currentNodeId(), ShardState.WAITING, shardRepoGeneration);", "author": "original-brownbear", "createdAt": "2020-10-13T11:03:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgzODk4MA=="}], "type": "inlineReview"}, {"oid": "0d6c9562d2a9179187ccf1d2cffe27b6fddcfdea", "url": "https://github.com/elastic/elasticsearch/commit/0d6c9562d2a9179187ccf1d2cffe27b6fddcfdea", "message": "Merge remote-tracking branch 'elastic/master' into 63498", "committedDate": "2020-10-13T10:58:38Z", "type": "commit"}, {"oid": "24c7231a0070076e464f73b2d21fd89d52e29376", "url": "https://github.com/elastic/elasticsearch/commit/24c7231a0070076e464f73b2d21fd89d52e29376", "message": "CR: comments", "committedDate": "2020-10-13T11:10:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg2Nzc3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/63534#discussion_r503867772", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // make sure in-flight-shard-states can be build cleanly for the entries without tripping assertions\n          \n          \n            \n                        // make sure in-flight-shard-states can be built cleanly for the entries without tripping assertions", "author": "tlrx", "createdAt": "2020-10-13T11:16:47Z", "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -694,6 +695,10 @@ private static boolean assertConsistentEntries(List<Entry> entries) {\n                 }\n             }\n         }\n+        for (String repoName : assignedShardsByRepo.keySet()) {\n+            // make sure in-flight-shard-states can be build cleanly for the entries without tripping assertions", "originalCommit": "24c7231a0070076e464f73b2d21fd89d52e29376", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "be7320bb85ff1c0a4e3e408bd3e359ad3d991718", "url": "https://github.com/elastic/elasticsearch/commit/be7320bb85ff1c0a4e3e408bd3e359ad3d991718", "message": "CR: typo", "committedDate": "2020-10-13T11:21:36Z", "type": "commit"}]}