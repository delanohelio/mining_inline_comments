{"pr_number": 58608, "pr_title": "Add microbenchmark for LongKeyedBucketOrds", "pr_createdAt": "2020-06-26T14:11:31Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58608", "timeline": [{"oid": "7e1371e34202d4cba981d689eff7911757907a16", "url": "https://github.com/elastic/elasticsearch/commit/7e1371e34202d4cba981d689eff7911757907a16", "message": "Add microbenchmark for LongKeyedBucketOrds\n\nI've always been confused by the strange behavior that I saw when\nworking on #57304. Specifically, I saw switching from a bimorphic\ninvocation to a monomorphic invocation to give us a 7%-15% performance\nbump. This felt *bonkers* to me. And, it also made me wonder whether\nit'd be worth looking into doing it everywhere.\n\nIt turns out that, no, it isn't needed everywhere. This benchmark shows\nthat a bimorphic invocation like:\n```\nLongKeyedBucketOrds ords = new LongKeyedBucketOrds.ForSingle();\nords.add(0, 0); <------ this line\n```\n\nis 19% slower than a monomorphic invocation like:\n```\nLongKeyedBucketOrds.ForSingle ords = new LongKeyedBucketOrds.ForSingle();\nords.add(0, 0); <------ this line\n```\n\nBut *only* when the reference is mutable. In the example above, if\n`ords` is never changed then both perform the same. But if the `ords`\nreference is assigned twice then we start to see the difference:\n```\nimmutable bimorphic    avgt   10   6.468 \u00b1 0.045  ns/op\nimmutable monomorphic  avgt   10   6.756 \u00b1 0.026  ns/op\nmutable   bimorphic    avgt   10   9.741 \u00b1 0.073  ns/op\nmutable   monomorphic  avgt   10   8.190 \u00b1 0.016  ns/op\n```\n\nSo the conclusion from all this is that we've done the right thing:\n`auto_date_histogram` is the only aggregation in which `ords` isn't final\nand it is the only aggregation that forces monomorphic invocations. All\nother aggregations use an immutable bimorphic invocation. Which is fine.\n\nRelates to #56487", "committedDate": "2020-06-26T14:11:15Z", "type": "commit"}, {"oid": "7c20cd414437c4cf262c5cbc8a9fbbd658ce7464", "url": "https://github.com/elastic/elasticsearch/commit/7c20cd414437c4cf262c5cbc8a9fbbd658ce7464", "message": "Merge branch 'master' into long_keyed_bucket_ords", "committedDate": "2020-06-30T21:08:45Z", "type": "commit"}, {"oid": "9075f23de1c10551ef1df79cb9b25d041e372800", "url": "https://github.com/elastic/elasticsearch/commit/9075f23de1c10551ef1df79cb9b25d041e372800", "message": "Merge branch 'master' into long_keyed_bucket_ords", "committedDate": "2020-06-30T22:42:30Z", "type": "commit"}, {"oid": "2e4fb47c82260222be946d9fad401d1b0d1479a6", "url": "https://github.com/elastic/elasticsearch/commit/2e4fb47c82260222be946d9fad401d1b0d1479a6", "message": "Merge branch 'master' into long_keyed_bucket_ords", "committedDate": "2020-07-06T14:01:10Z", "type": "commit"}, {"oid": "80ba140322035157349bb2a694c1a78301210a4d", "url": "https://github.com/elastic/elasticsearch/commit/80ba140322035157349bb2a694c1a78301210a4d", "message": "Move benchmark to proper package", "committedDate": "2020-07-06T14:05:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxNTk4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r451315983", "bodyText": "This benchmark is prone to an optimization called dead code elimination because you neither return anything nor you feed anything into JMH's Blackhole.", "author": "danielmitterdorfer", "createdAt": "2020-07-08T06:40:35Z", "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket()} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation() {", "originalCommit": "80ba140322035157349bb2a694c1a78301210a4d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxNjAxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r451316011", "bodyText": "This benchmark is prone to an optimization called dead code elimination because you neither return anything nor you feed anything into JMH's Blackhole.", "author": "danielmitterdorfer", "createdAt": "2020-07-08T06:40:40Z", "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket()} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation() {\n+        try (LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that most aggregations use {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableBimorphicInvocation() {", "originalCommit": "80ba140322035157349bb2a694c1a78301210a4d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxNjA1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r451316059", "bodyText": "This benchmark is prone to an optimization called dead code elimination because you neither return anything nor you feed anything into JMH's Blackhole.", "author": "danielmitterdorfer", "createdAt": "2020-07-08T06:40:45Z", "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket()} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation() {\n+        try (LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that most aggregations use {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableBimorphicInvocation() {\n+        try (LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, true)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that {@link AutoDateHistogramAggregationBuilder} uses {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableMonmorphicInvocation() {", "originalCommit": "80ba140322035157349bb2a694c1a78301210a4d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxNjA5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r451316095", "bodyText": "This benchmark is prone to an optimization called dead code elimination because you neither return anything nor you feed anything into JMH's Blackhole.", "author": "danielmitterdorfer", "createdAt": "2020-07-08T06:40:53Z", "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket()} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation() {\n+        try (LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that most aggregations use {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableBimorphicInvocation() {\n+        try (LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, true)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that {@link AutoDateHistogramAggregationBuilder} uses {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableMonmorphicInvocation() {\n+        LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays);\n+        for (long i = 0; i < LIMIT; i++) {\n+            if (i % 100_000 == 0) {\n+                ords.close();\n+                ords = new LongKeyedBucketOrds.FromSingle(bigArrays);\n+            }\n+            ords.add(0, i % DISTINCT_VALUES);\n+        }\n+        ords.close();\n+    }\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is significantly slower than the\n+     * {@link #singleBucketIntoSingleMutableMonmorphicInvocation() monomorphic invocation}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableBimorphicInvocation() {", "originalCommit": "80ba140322035157349bb2a694c1a78301210a4d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxNjEyNg==", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r451316126", "bodyText": "This benchmark is prone to an optimization called dead code elimination because you neither return anything nor you feed anything into JMH's Blackhole.", "author": "danielmitterdorfer", "createdAt": "2020-07-08T06:40:58Z", "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket()} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation() {\n+        try (LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that most aggregations use {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableBimorphicInvocation() {\n+        try (LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, true)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that {@link AutoDateHistogramAggregationBuilder} uses {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableMonmorphicInvocation() {\n+        LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays);\n+        for (long i = 0; i < LIMIT; i++) {\n+            if (i % 100_000 == 0) {\n+                ords.close();\n+                ords = new LongKeyedBucketOrds.FromSingle(bigArrays);\n+            }\n+            ords.add(0, i % DISTINCT_VALUES);\n+        }\n+        ords.close();\n+    }\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is significantly slower than the\n+     * {@link #singleBucketIntoSingleMutableMonmorphicInvocation() monomorphic invocation}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableBimorphicInvocation() {\n+        LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, true);\n+        for (long i = 0; i < LIMIT; i++) {\n+            if (i % 100_000 == 0) {\n+                ords.close();\n+                ords = LongKeyedBucketOrds.build(bigArrays, true);\n+            }\n+            ords.add(0, i % DISTINCT_VALUES);\n+\n+        }\n+        ords.close();\n+    }\n+\n+    /**\n+     * Emulates an aggregation that collects from a single bucket \"by accident\".\n+     * This can happen if an aggregation is under, say, a {@code terms}\n+     * aggregation and there is only a single value for that term in the index.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoMulti() {", "originalCommit": "80ba140322035157349bb2a694c1a78301210a4d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxNjE1MA==", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r451316150", "bodyText": "This benchmark is prone to an optimization called dead code elimination because you neither return anything nor you feed anything into JMH's Blackhole.", "author": "danielmitterdorfer", "createdAt": "2020-07-08T06:41:02Z", "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket()} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation() {\n+        try (LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that most aggregations use {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableBimorphicInvocation() {\n+        try (LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, true)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that {@link AutoDateHistogramAggregationBuilder} uses {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableMonmorphicInvocation() {\n+        LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays);\n+        for (long i = 0; i < LIMIT; i++) {\n+            if (i % 100_000 == 0) {\n+                ords.close();\n+                ords = new LongKeyedBucketOrds.FromSingle(bigArrays);\n+            }\n+            ords.add(0, i % DISTINCT_VALUES);\n+        }\n+        ords.close();\n+    }\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is significantly slower than the\n+     * {@link #singleBucketIntoSingleMutableMonmorphicInvocation() monomorphic invocation}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableBimorphicInvocation() {\n+        LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, true);\n+        for (long i = 0; i < LIMIT; i++) {\n+            if (i % 100_000 == 0) {\n+                ords.close();\n+                ords = LongKeyedBucketOrds.build(bigArrays, true);\n+            }\n+            ords.add(0, i % DISTINCT_VALUES);\n+\n+        }\n+        ords.close();\n+    }\n+\n+    /**\n+     * Emulates an aggregation that collects from a single bucket \"by accident\".\n+     * This can happen if an aggregation is under, say, a {@code terms}\n+     * aggregation and there is only a single value for that term in the index.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoMulti() {\n+        try (LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, false)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates an aggregation that collects from many buckets.\n+     */\n+    @Benchmark\n+    public void multiBucket() {", "originalCommit": "80ba140322035157349bb2a694c1a78301210a4d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6d26ed4cb5d3bcd684e353d380d3b2fd4406d2ce", "url": "https://github.com/elastic/elasticsearch/commit/6d26ed4cb5d3bcd684e353d380d3b2fd4406d2ce", "message": "Merge branch 'master' into long_keyed_bucket_ords", "committedDate": "2020-07-08T19:33:30Z", "type": "commit"}, {"oid": "0f46086db0c66023ebd6a4394fc7705259203582", "url": "https://github.com/elastic/elasticsearch/commit/0f46086db0c66023ebd6a4394fc7705259203582", "message": "Blackhole", "committedDate": "2020-07-08T19:36:36Z", "type": "commit"}, {"oid": "dde47b2c8c112bcac6d389715fe6bc22e91a5891", "url": "https://github.com/elastic/elasticsearch/commit/dde47b2c8c112bcac6d389715fe6bc22e91a5891", "message": "Handle merge", "committedDate": "2020-07-08T19:38:52Z", "type": "commit"}, {"oid": "7ab3390daa6a68a7a788fe86a56518230d2df0f9", "url": "https://github.com/elastic/elasticsearch/commit/7ab3390daa6a68a7a788fe86a56518230d2df0f9", "message": "javadoc", "committedDate": "2020-07-08T19:41:50Z", "type": "commit"}, {"oid": "d31dd304434fb3e2175a6be44d130c5c31460b14", "url": "https://github.com/elastic/elasticsearch/commit/d31dd304434fb3e2175a6be44d130c5c31460b14", "message": "Force init", "committedDate": "2020-07-08T19:47:59Z", "type": "commit"}, {"oid": "67b57dba147bc70ff40c5b0c0ccd794247f45164", "url": "https://github.com/elastic/elasticsearch/commit/67b57dba147bc70ff40c5b0c0ccd794247f45164", "message": "Force loading classes", "committedDate": "2020-07-08T19:49:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ5NTY5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r453495693", "bodyText": "I assume you're not interested in measuring class loading so you can move this code out of the measurement loop and into a separate setup method:\n    @Setup\n    public void setUp(Blackhole bh) {\n        // you can also inline this method now that there is only one call site\n        forceLoadClasses(bh);\n    }", "author": "danielmitterdorfer", "createdAt": "2020-07-13T08:53:48Z", "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.CardinalityUpperBound;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation(Blackhole bh) {\n+        forceLoadClasses(bh);", "originalCommit": "67b57dba147bc70ff40c5b0c0ccd794247f45164", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1NTkyMg==", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r453855922", "bodyText": "\ud83d\udc4d", "author": "nik9000", "createdAt": "2020-07-13T18:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ5NTY5Mw=="}], "type": "inlineReview"}, {"oid": "308c982972050429f5f4be4a2729411fda54cc0f", "url": "https://github.com/elastic/elasticsearch/commit/308c982972050429f5f4be4a2729411fda54cc0f", "message": "Merge branch 'master' into long_keyed_bucket_ords", "committedDate": "2020-07-13T18:33:24Z", "type": "commit"}, {"oid": "f426b5575868bc6c0b90591bd3255e253ab26d3e", "url": "https://github.com/elastic/elasticsearch/commit/f426b5575868bc6c0b90591bd3255e253ab26d3e", "message": "Move force loading classes to setup", "committedDate": "2020-07-13T18:38:24Z", "type": "commit"}]}