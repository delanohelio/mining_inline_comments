{"pr_number": 64900, "pr_title": "Adds a new Rollup Action", "pr_createdAt": "2020-11-10T23:40:10Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/64900", "timeline": [{"oid": "be90dd3ac889ed116777f997bc76de6d27eefb3c", "url": "https://github.com/elastic/elasticsearch/commit/be90dd3ac889ed116777f997bc76de6d27eefb3c", "message": "fix config serialization tests", "committedDate": "2020-11-11T23:59:49Z", "type": "forcePushed"}, {"oid": "20ea956b5a5dafc00cd8027b725f4ad01275c709", "url": "https://github.com/elastic/elasticsearch/commit/20ea956b5a5dafc00cd8027b725f4ad01275c709", "message": "Adds a new Rollup V2 Action\n\nThis commit adds a new endpoint for Rollup V2, a new way to rollup indices.\n\nInstead of relying on a cron-job, this action will rollup a whole index on the spot.\n\nWhen an index is rolled up using a Rollup Config, it does the following\n\n1. check that original index is read-only\n2. runs an aggregation and indexes results into a temporary hidden rollup index\n3. \"resizes\" the temporary index into the final rollup-index (in-place segment pointer juggling)\n4. adds RollupMetadata about the rollup-group (keyed by original index name) and adds custom index-metadata with data about what the rollup index's original index is so that its group information in RollupMetadata can be looked up\n\nexample usage:\n\n```\nPOST /_rollup_vtwo/index\n{\n    \"rollup_index\": \"index_rolled\",\n    \"groups\": {\n        \"date_histogram\": {\n            \"field\": \"date\",\n            \"calendar_interval\": \"1M\"\n        },\n        \"terms\": {\n            \"fields\": [\"unit\"]\n        }\n    },\n    \"metrics\": [\n        {\n            \"field\": \"temperature\",\n            \"metrics\": [\"sum\"]\n        }\n    ]\n}\n```", "committedDate": "2020-11-19T00:01:30Z", "type": "commit"}, {"oid": "1a3e115eda1859d25f5aa3fd6701b05a1045c61c", "url": "https://github.com/elastic/elasticsearch/commit/1a3e115eda1859d25f5aa3fd6701b05a1045c61c", "message": "fix config serialization tests", "committedDate": "2020-11-19T00:01:30Z", "type": "commit"}, {"oid": "1a3e115eda1859d25f5aa3fd6701b05a1045c61c", "url": "https://github.com/elastic/elasticsearch/commit/1a3e115eda1859d25f5aa3fd6701b05a1045c61c", "message": "fix config serialization tests", "committedDate": "2020-11-19T00:01:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM4NDUwOA==", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r526384508", "bodyText": "Exposing Build here seems wrong, as does duplicating this check.  I think we should wrap this whole conditional up in a RollupV2.enabled() method that just returns a boolean.", "author": "not-napoleon", "createdAt": "2020-11-18T20:04:49Z", "path": "server/src/main/java/org/elasticsearch/cluster/ClusterModule.java", "diffHunk": "@@ -143,7 +144,8 @@ public ClusterModule(Settings settings, ClusterService clusterService, List<Clus\n             ComposableIndexTemplateMetadata::readDiffFrom);\n         registerMetadataCustom(entries, DataStreamMetadata.TYPE, DataStreamMetadata::new, DataStreamMetadata::readDiffFrom);\n \n-        if (RollupV2.ROLLUPV2_FEATURE_FLAG_REGISTERED != null && RollupV2.ROLLUPV2_FEATURE_FLAG_REGISTERED) {\n+        if (Build.CURRENT.isSnapshot() ||", "originalCommit": "be90dd3ac889ed116777f997bc76de6d27eefb3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMTExMw==", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r527131113", "bodyText": "\ud83d\udc4d will clean that up", "author": "talevy", "createdAt": "2020-11-19T19:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM4NDUwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM5NzczNA==", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r526397734", "bodyText": "asking more for my own knowledge than anything else - is this functionally different than return rollupConfig.hashCode();?", "author": "not-napoleon", "createdAt": "2020-11-18T20:25:02Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/rollup/v2/RollupV2Action.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.rollup.v2;\n+\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestBuilder;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.client.ElasticsearchClient;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.tasks.TaskId;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class RollupV2Action extends ActionType<RollupV2Action.Response> {\n+\n+    public static final RollupV2Action INSTANCE = new RollupV2Action();\n+    public static final String NAME = \"cluster:admin/xpack/rollupV2\";\n+\n+    private RollupV2Action() {\n+        super(NAME, RollupV2Action.Response::new);\n+    }\n+\n+    public static class Request extends ActionRequest implements ToXContentObject {\n+        private RollupV2Config rollupConfig;\n+\n+        public Request(RollupV2Config rollupConfig) {\n+            this.rollupConfig = rollupConfig;\n+        }\n+\n+        public Request() {}\n+\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+            rollupConfig = new RollupV2Config(in);\n+        }\n+\n+        @Override\n+        public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {\n+            return new RollupV2Task(id, type, action, parentTaskId, rollupConfig, headers);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            super.writeTo(out);\n+            rollupConfig.writeTo(out);\n+        }\n+\n+        public RollupV2Config getRollupConfig() {\n+            return rollupConfig;\n+        }\n+\n+        @Override\n+        public ActionRequestValidationException validate() {\n+            return null;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            rollupConfig.toXContent(builder, params);\n+            builder.endObject();\n+            return builder;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(rollupConfig);", "originalCommit": "be90dd3ac889ed116777f997bc76de6d27eefb3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMTkyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r527131929", "bodyText": "functionally, no. I just like the consistency of calling Objects#hash, more-so when there are multiple instance variables to hash. For this reason, I chose to go with calling that method from Objects.", "author": "talevy", "createdAt": "2020-11-19T19:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM5NzczNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMjM2OA==", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r527132368", "bodyText": "Also, not that rollupConfig can be null, but if it could, then calling Objects#hash is safer w.r.t. NPE", "author": "talevy", "createdAt": "2020-11-19T19:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM5NzczNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE3Mjk2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r527172966", "bodyText": "Cool, makes sense.", "author": "not-napoleon", "createdAt": "2020-11-19T20:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM5NzczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM5ODU2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r526398566", "bodyText": "Shouldn't this cast to RollupV2Action here?", "author": "not-napoleon", "createdAt": "2020-11-18T20:26:27Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/rollup/v2/RollupV2Action.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.rollup.v2;\n+\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestBuilder;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.client.ElasticsearchClient;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.tasks.TaskId;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class RollupV2Action extends ActionType<RollupV2Action.Response> {\n+\n+    public static final RollupV2Action INSTANCE = new RollupV2Action();\n+    public static final String NAME = \"cluster:admin/xpack/rollupV2\";\n+\n+    private RollupV2Action() {\n+        super(NAME, RollupV2Action.Response::new);\n+    }\n+\n+    public static class Request extends ActionRequest implements ToXContentObject {\n+        private RollupV2Config rollupConfig;\n+\n+        public Request(RollupV2Config rollupConfig) {\n+            this.rollupConfig = rollupConfig;\n+        }\n+\n+        public Request() {}\n+\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+            rollupConfig = new RollupV2Config(in);\n+        }\n+\n+        @Override\n+        public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {\n+            return new RollupV2Task(id, type, action, parentTaskId, rollupConfig, headers);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            super.writeTo(out);\n+            rollupConfig.writeTo(out);\n+        }\n+\n+        public RollupV2Config getRollupConfig() {\n+            return rollupConfig;\n+        }\n+\n+        @Override\n+        public ActionRequestValidationException validate() {\n+            return null;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            rollupConfig.toXContent(builder, params);\n+            builder.endObject();\n+            return builder;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(rollupConfig);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            Request other = (Request) obj;", "originalCommit": "be90dd3ac889ed116777f997bc76de6d27eefb3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzODU0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r527138545", "bodyText": "this is a subclass of RollupV2Action \u2014 RollupV2Action.Request", "author": "talevy", "createdAt": "2020-11-19T19:21:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM5ODU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE3MzMwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r527173305", "bodyText": "ah, that makes more sense.  Sorry for the noise.", "author": "not-napoleon", "createdAt": "2020-11-19T20:21:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM5ODU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEyMDk0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r527120946", "bodyText": "We're bleeding implementation details here a bit.  I feel like we should just create an empty RollupGroup and then use the RollupGroup#add(indexName, dateInterval, ZoneId) method you used in the other branch of this conditional.  Seems weird to me that this method decides the concrete map implementation the RollupGroup is using, for example.", "author": "not-napoleon", "createdAt": "2020-11-19T18:51:42Z", "path": "x-pack/plugin/rollup/src/main/java/org/elasticsearch/xpack/rollup/v2/TransportRollupV2Action.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.rollup.v2;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateUpdateTask;\n+import org.elasticsearch.cluster.metadata.DataStream;\n+import org.elasticsearch.cluster.metadata.IndexAbstraction;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.metadata.RollupGroup;\n+import org.elasticsearch.cluster.metadata.RollupMetadata;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.time.WriteableZoneId;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogramInterval;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.indexing.IndexerState;\n+import org.elasticsearch.xpack.core.rollup.job.DateHistogramGroupConfig;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupV2Action;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupV2Task;\n+import org.elasticsearch.xpack.rollup.Rollup;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+// TODO(talevy): enforce that rollup-indices of indices backing a datastream must be hidden\n+public class TransportRollupV2Action extends HandledTransportAction<RollupV2Action.Request, RollupV2Action.Response> {\n+    private final Client client;\n+    private final ThreadPool threadPool;\n+    private final ClusterService clusterService;\n+\n+    @Inject\n+    public TransportRollupV2Action(\n+            final Client client,\n+            final ClusterService clusterService,\n+            final ThreadPool threadPool,\n+            final TransportService transportService,\n+            final ActionFilters actionFilters\n+    ) {\n+        super(RollupV2Action.NAME, transportService, actionFilters, RollupV2Action.Request::new);\n+        this.client = client;\n+        this.threadPool = threadPool;\n+        this.clusterService = clusterService;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, RollupV2Action.Request request, ActionListener<RollupV2Action.Response> listener) {\n+        RollupV2Task rollupV2Task = (RollupV2Task) task;\n+        RollupV2Indexer indexer = new RollupV2Indexer(client, threadPool, Rollup.TASK_THREAD_POOL_NAME,\n+            rollupV2Task.config(), rollupV2Task.headers(), ActionListener.wrap(c -> {\n+            // update Rollup metadata to include this index\n+            clusterService.submitStateUpdateTask(\"update-rollup-metadata\", new ClusterStateUpdateTask() {\n+\n+                @Override\n+                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n+                    listener.onResponse(new RollupV2Action.Response(true));\n+                }\n+\n+                @Override\n+                public ClusterState execute(ClusterState currentState) throws Exception {\n+                    String rollupIndexName = rollupV2Task.config().getRollupIndex();\n+                    IndexMetadata rollupIndexMetadata = currentState.getMetadata().index(rollupIndexName);\n+                    Index rollupIndex = rollupIndexMetadata.getIndex();\n+                    // TODO(talevy): find better spot to get the original index name\n+                    // extract created rollup index original index name to be used as metadata key\n+                    String originalIndexName = rollupV2Task.config().getSourceIndex();\n+                    Map<String, String> idxMetadata = currentState.getMetadata().index(originalIndexName)\n+                        .getCustomData(RollupMetadata.TYPE);\n+                    String rollupGroupKeyName = (idxMetadata == null) ?\n+                        originalIndexName : idxMetadata.get(RollupMetadata.SOURCE_INDEX_NAME_META_FIELD);\n+                    Map<String, String> rollupIndexRollupMetadata = new HashMap<>();\n+                    rollupIndexRollupMetadata.put(RollupMetadata.SOURCE_INDEX_NAME_META_FIELD, rollupGroupKeyName);\n+                    final RollupMetadata rollupMetadata = currentState.metadata().custom(RollupMetadata.TYPE);\n+                    final Map<String, RollupGroup> rollupGroups;\n+                    if (rollupMetadata == null) {\n+                        rollupGroups = new HashMap<>();\n+                    } else {\n+                        rollupGroups = new HashMap<>(rollupMetadata.rollupGroups());\n+                    }\n+                    DateHistogramGroupConfig dateConfig = rollupV2Task.config().getGroupConfig().getDateHistogram();\n+                    WriteableZoneId rollupDateZoneId = WriteableZoneId.of(dateConfig.getTimeZone());\n+                    if (rollupGroups.containsKey(rollupGroupKeyName)) {\n+                        RollupGroup group = rollupGroups.get(rollupGroupKeyName);\n+                        group.add(rollupIndexName, dateConfig.getInterval(), rollupDateZoneId);\n+                    } else {\n+                        List<String> indices = new ArrayList<>();\n+                        Map<String, DateHistogramInterval> intervals = new HashMap<>();\n+                        Map<String, WriteableZoneId> timezones = new HashMap<>();\n+                        indices.add(rollupIndexName);\n+                        intervals.put(rollupIndexName, dateConfig.getInterval());\n+                        timezones.put(rollupIndexName, rollupDateZoneId);", "originalCommit": "1a3e115eda1859d25f5aa3fd6701b05a1045c61c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzODgyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/64900#discussion_r527138829", "bodyText": "good point. I'll work to clean this up", "author": "talevy", "createdAt": "2020-11-19T19:21:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEyMDk0Ng=="}], "type": "inlineReview"}, {"oid": "55a3087b00e702db2b624b1f6a5c9175fe752abf", "url": "https://github.com/elastic/elasticsearch/commit/55a3087b00e702db2b624b1f6a5c9175fe752abf", "message": "Merge remote-tracking branch 'elastic/master' into rollupv2action", "committedDate": "2020-11-19T19:40:51Z", "type": "commit"}, {"oid": "49796c248c6cd26b8ef5a5ab4b2fa72026e60e1c", "url": "https://github.com/elastic/elasticsearch/commit/49796c248c6cd26b8ef5a5ab4b2fa72026e60e1c", "message": "fix merge issue where aggregate_metric was removed", "committedDate": "2020-11-19T22:12:01Z", "type": "commit"}, {"oid": "35d5dc1255ed42ec760c9d1545add66c93481fde", "url": "https://github.com/elastic/elasticsearch/commit/35d5dc1255ed42ec760c9d1545add66c93481fde", "message": "rename endpoint from rollupv2 -> rollup", "committedDate": "2020-11-19T23:48:34Z", "type": "commit"}, {"oid": "8af508a6537a3bf40a22accc8200581b0a699d72", "url": "https://github.com/elastic/elasticsearch/commit/8af508a6537a3bf40a22accc8200581b0a699d72", "message": "fix checkstyle", "committedDate": "2020-11-20T00:15:16Z", "type": "commit"}, {"oid": "96f484046e335c9d5af4255ad3535c35b7e9a0b9", "url": "https://github.com/elastic/elasticsearch/commit/96f484046e335c9d5af4255ad3535c35b7e9a0b9", "message": "use valid rest path", "committedDate": "2020-11-20T00:26:43Z", "type": "commit"}, {"oid": "32d585740979d383008d0417ce8c594aa4026773", "url": "https://github.com/elastic/elasticsearch/commit/32d585740979d383008d0417ce8c594aa4026773", "message": "Merge remote-tracking branch 'elastic/master' into rollupv2action", "committedDate": "2020-11-23T18:03:29Z", "type": "commit"}, {"oid": "a395a035159f34b0fcb259637b1688ddfb256044", "url": "https://github.com/elastic/elasticsearch/commit/a395a035159f34b0fcb259637b1688ddfb256044", "message": "cleanup adding of new rollup groups", "committedDate": "2020-11-23T18:06:45Z", "type": "commit"}, {"oid": "219e356bbb6ea2fc02e583dd60fef68010d61921", "url": "https://github.com/elastic/elasticsearch/commit/219e356bbb6ea2fc02e583dd60fef68010d61921", "message": "fix checkstyle", "committedDate": "2020-11-23T20:19:04Z", "type": "commit"}]}