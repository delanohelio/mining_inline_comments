{"pr_number": 61358, "pr_title": "Speed up Compression Logic by Pooling Resources", "pr_createdAt": "2020-08-20T08:17:51Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/61358", "timeline": [{"oid": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "url": "https://github.com/elastic/elasticsearch/commit/d717a47cdb6d00c023cf1d04f02438beed19a4c6", "message": "Speed up Compression Logic by Pooling Resources\n\nThis is mostly motivated by the performance issues we are seeing around the GET mappings\nREST API which (in case of a large number of indices) will create decompressing streams in a hot loop\nwhich takes a significant amount of time for the system calls involved in instantiating deflaters\nand inflaters.\nAlso, this fixes a leaked deflater when deserializing cached repository data.", "committedDate": "2020-08-20T08:09:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzc1MTgxNg==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r473751816", "bodyText": "No need for this kind of extra atomic boolean+check, the BufferedOutputStream is a filter output stream that will only close once.", "author": "original-brownbear", "createdAt": "2020-08-20T08:20:38Z", "path": "server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java", "diffHunk": "@@ -88,56 +142,64 @@ public StreamInput streamInput(StreamInput in) throws IOException {\n             throw new IllegalArgumentException(\"Input stream is not compressed with DEFLATE!\");\n         }\n \n-        final boolean nowrap = true;\n-        final Inflater inflater = new Inflater(nowrap);\n-        InputStream decompressedIn = new InflaterInputStream(in, inflater, BUFFER_SIZE);\n-        decompressedIn = new BufferedInputStream(decompressedIn, BUFFER_SIZE);\n-        return new InputStreamStreamInput(decompressedIn) {\n-            final AtomicBoolean closed = new AtomicBoolean(false);\n-\n+        final ReleasableReference<Inflater> current = inflaterForStreamRef.get();\n+        final Releasable releasable;\n+        final Inflater inflater;\n+        if (current.inUse) {\n+            // Nested de-compression streams should not happen but we still handle them safely by using a fresh Inflater\n+            inflater = new Inflater(true);\n+            releasable = inflater::end;\n+        } else {\n+            inflater = current.get();\n+            releasable = current;\n+        }\n+        InputStream decompressedIn = new InflaterInputStream(in, inflater, BUFFER_SIZE) {\n+            @Override\n             public void close() throws IOException {\n                 try {\n                     super.close();\n                 } finally {\n-                    if (closed.compareAndSet(false, true)) {\n-                        // important to release native memory\n-                        inflater.end();\n-                    }\n+                    releasable.close();\n                 }\n             }\n         };\n+        return new InputStreamStreamInput(new BufferedInputStream(decompressedIn, BUFFER_SIZE));\n     }\n \n     @Override\n     public StreamOutput streamOutput(OutputStream out) throws IOException {\n         out.write(HEADER);\n-        final boolean nowrap = true;\n-        final Deflater deflater = new Deflater(LEVEL, nowrap);\n+        final ReleasableReference<Deflater> current = deflaterForStreamRef.get();\n+        final Releasable releasable;\n+        final Deflater deflater;\n+        if (current.inUse) {\n+            // Nested compression streams should not happen but we still handle them safely by using a fresh Deflater\n+            deflater = new Deflater(LEVEL, true);\n+            releasable = deflater::end;\n+        } else {\n+            deflater = current.get();\n+            releasable = current;\n+        }\n         final boolean syncFlush = true;\n-        DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(out, deflater, BUFFER_SIZE, syncFlush);\n-        OutputStream compressedOut = new BufferedOutputStream(deflaterOutputStream, BUFFER_SIZE);\n-        return new OutputStreamStreamOutput(compressedOut) {\n-            final AtomicBoolean closed = new AtomicBoolean(false);\n-\n+        DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(out, deflater, BUFFER_SIZE, syncFlush) {\n+            @Override\n             public void close() throws IOException {\n                 try {\n                     super.close();\n                 } finally {\n-                    if (closed.compareAndSet(false, true)) {\n-                        // important to release native memory\n-                        deflater.end();\n-                    }\n+                    releasable.close();", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwODE3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474108177", "bodyText": "Let's add this as a code comment", "author": "jaymode", "createdAt": "2020-08-20T16:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzc1MTgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzc1MjQ4NA==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r473752484", "bodyText": "No need for this kind of extra atomic boolean+check, the BufferedInputStream will only close once.", "author": "original-brownbear", "createdAt": "2020-08-20T08:21:21Z", "path": "server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java", "diffHunk": "@@ -88,56 +142,64 @@ public StreamInput streamInput(StreamInput in) throws IOException {\n             throw new IllegalArgumentException(\"Input stream is not compressed with DEFLATE!\");\n         }\n \n-        final boolean nowrap = true;\n-        final Inflater inflater = new Inflater(nowrap);\n-        InputStream decompressedIn = new InflaterInputStream(in, inflater, BUFFER_SIZE);\n-        decompressedIn = new BufferedInputStream(decompressedIn, BUFFER_SIZE);\n-        return new InputStreamStreamInput(decompressedIn) {\n-            final AtomicBoolean closed = new AtomicBoolean(false);\n-\n+        final ReleasableReference<Inflater> current = inflaterForStreamRef.get();\n+        final Releasable releasable;\n+        final Inflater inflater;\n+        if (current.inUse) {\n+            // Nested de-compression streams should not happen but we still handle them safely by using a fresh Inflater\n+            inflater = new Inflater(true);\n+            releasable = inflater::end;\n+        } else {\n+            inflater = current.get();\n+            releasable = current;\n+        }\n+        InputStream decompressedIn = new InflaterInputStream(in, inflater, BUFFER_SIZE) {\n+            @Override\n             public void close() throws IOException {\n                 try {\n                     super.close();\n                 } finally {\n-                    if (closed.compareAndSet(false, true)) {\n-                        // important to release native memory\n-                        inflater.end();\n-                    }\n+                    releasable.close();", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwODAwOA==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474108008", "bodyText": "Let's add this as a code comment", "author": "jaymode", "createdAt": "2020-08-20T16:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzc1MjQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzc1MzM1OA==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r473753358", "bodyText": "This was just a bug where we failed to close the stream and that became visible with the changes in this PR.", "author": "original-brownbear", "createdAt": "2020-08-20T08:22:21Z", "path": "server/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java", "diffHunk": "@@ -1331,10 +1332,11 @@ private void cacheRepositoryData(BytesReference updated, long generation) {\n     }\n \n     private RepositoryData repositoryDataFromCachedEntry(Tuple<Long, BytesReference> cacheEntry) throws IOException {\n-        return RepositoryData.snapshotsFromXContent(\n-            XContentType.JSON.xContent().createParser(NamedXContentRegistry.EMPTY,\n-                LoggingDeprecationHandler.INSTANCE,\n-                CompressorFactory.COMPRESSOR.streamInput(cacheEntry.v2().streamInput())), cacheEntry.v1(), false);\n+        try (StreamInput input = CompressorFactory.COMPRESSOR.streamInput(cacheEntry.v2().streamInput())) {", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzc1NDc0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r473754749", "bodyText": "We do have compressed mapping sources in the cluster state that itself comes to us in compressed form so not closing here would actually lead to not having nested decompression streams so I added the early close.", "author": "original-brownbear", "createdAt": "2020-08-20T08:23:51Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java", "diffHunk": "@@ -145,6 +145,8 @@ private PublishWithJoinResponse handleIncomingPublishRequest(BytesTransportReque\n                 final ClusterState incomingState;\n                 try {\n                     incomingState = ClusterState.readFrom(in, transportService.getLocalNode());\n+                    // Close early to release resources used by the de-compression as early as possible\n+                    in.close();", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMDk3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474100977", "bodyText": "How about using try with resources?", "author": "jaymode", "createdAt": "2020-08-20T16:08:42Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java", "diffHunk": "@@ -145,6 +145,8 @@ private PublishWithJoinResponse handleIncomingPublishRequest(BytesTransportReque\n                 final ClusterState incomingState;\n                 try {\n                     incomingState = ClusterState.readFrom(in, transportService.getLocalNode());\n+                    // Close early to release resources used by the de-compression as early as possible\n+                    in.close();", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMTYzNw==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474101637", "bodyText": "Is it that important to close before applying the diff here? Otherwise you could use try with resources", "author": "jaymode", "createdAt": "2020-08-20T16:09:38Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java", "diffHunk": "@@ -165,6 +167,8 @@ private PublishWithJoinResponse handleIncomingPublishRequest(BytesTransportReque\n                     ClusterState incomingState;\n                     try {\n                         Diff<ClusterState> diff = ClusterState.readDiffFrom(in, lastSeen.nodes().getLocalNode());\n+                        // Close early to release resources used by the de-compression as early as possible\n+                        in.close();", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5MDc5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474190795", "bodyText": "Yea we want to get the handle for the Inflater before because index metadata operations will use it potentially, but just closing here is pretty lazy admittedly, I'll make it nicer using try-with-resources.", "author": "original-brownbear", "createdAt": "2020-08-20T18:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMTYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMTg4MA==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474101880", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Creates a new stream input that decompresses the contents read from teh provided stream input.\n          \n          \n            \n                 * Creates a new stream input that decompresses the contents read from the provided stream input.", "author": "jaymode", "createdAt": "2020-08-20T16:10:00Z", "path": "server/src/main/java/org/elasticsearch/common/compress/Compressor.java", "diffHunk": "@@ -32,11 +32,19 @@\n \n     int headerLength();\n \n+    /**\n+     * Creates a new stream input that decompresses the contents read from teh provided stream input.", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMzAyOA==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474103028", "bodyText": "Maybe name this method something like unsafeStreamInput or threadLocalStreamInput?", "author": "jaymode", "createdAt": "2020-08-20T16:11:43Z", "path": "server/src/main/java/org/elasticsearch/common/compress/Compressor.java", "diffHunk": "@@ -32,11 +32,19 @@\n \n     int headerLength();\n \n+    /**\n+     * Creates a new stream input that decompresses the contents read from teh provided stream input.\n+     * Closing the returned {@link StreamInput} will close the provided stream input.\n+     * Note: The returned stream may only be used on the thread that created it as it might use thread-local resources and must be safely\n+     * closed after use\n+     */\n     StreamInput streamInput(StreamInput in) throws IOException;", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMzYwMw==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474103603", "bodyText": "Maybe name this method something like unsafeStreamOutput or threadLocalStreamOutput?", "author": "jaymode", "createdAt": "2020-08-20T16:12:36Z", "path": "server/src/main/java/org/elasticsearch/common/compress/Compressor.java", "diffHunk": "@@ -32,11 +32,19 @@\n \n     int headerLength();\n \n+    /**\n+     * Creates a new stream input that decompresses the contents read from teh provided stream input.\n+     * Closing the returned {@link StreamInput} will close the provided stream input.\n+     * Note: The returned stream may only be used on the thread that created it as it might use thread-local resources and must be safely\n+     * closed after use\n+     */\n     StreamInput streamInput(StreamInput in) throws IOException;\n \n     /**\n      * Creates a new stream output that compresses the contents and writes to the provided stream\n      * output. Closing the returned {@link StreamOutput} will close the provided stream output.\n+     * Note: The returned stream may only be used on the thread that created it as it might use thread-local resources and must be safely\n+     * closed after use\n      */\n     StreamOutput streamOutput(OutputStream out) throws IOException;", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5OTAwOA==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474199008", "bodyText": "edited: nevermind my previous comment unsafeStreamOutput is fine :) I'll special case the http exporter situation another way :)", "author": "original-brownbear", "createdAt": "2020-08-20T18:48:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMzYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwNTIxNw==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474105217", "bodyText": "s/user/thread ?\nAlso maybe add a note that this is only used when assertions are enabled?", "author": "jaymode", "createdAt": "2020-08-20T16:15:14Z", "path": "server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java", "diffHunk": "@@ -73,6 +74,59 @@ public int headerLength() {\n         return HEADER.length;\n     }\n \n+    // Reusable inflater reference for streaming decompression\n+    private static final ThreadLocal<ReleasableReference<Inflater>> inflaterForStreamRef = ThreadLocal.withInitial(() -> {\n+        final Inflater inflater = new Inflater(true);\n+        return new ReleasableReference<>(inflater, inflater::reset);\n+    });\n+\n+    // Reusable deflater reference for streaming compression\n+    private static final ThreadLocal<ReleasableReference<Deflater>> deflaterForStreamRef = ThreadLocal.withInitial(() -> {\n+        final Deflater deflater = new Deflater(LEVEL, true);\n+        return new ReleasableReference<>(deflater, deflater::reset);\n+    });\n+\n+    // Reference to a deflater or inflater that is used to make sure we do not use the same stream twice when nesting streams.\n+    private static final class ReleasableReference<T> implements Releasable {\n+\n+        protected final T resource;\n+\n+        private final Releasable releasable;\n+\n+        // Thread that is currently using this reference\n+        private Thread user = null;", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f10df36ad024f50bc236d152c016e00bbe09974c", "url": "https://github.com/elastic/elasticsearch/commit/f10df36ad024f50bc236d152c016e00bbe09974c", "message": "Merge remote-tracking branch 'elastic/master' into faster-compression-2", "committedDate": "2020-08-20T18:31:00Z", "type": "commit"}, {"oid": "24afec1e19db5daaa45f52fce3f1218cbc667300", "url": "https://github.com/elastic/elasticsearch/commit/24afec1e19db5daaa45f52fce3f1218cbc667300", "message": "Merge remote-tracking branch 'elastic/master' into faster-compression-2", "committedDate": "2020-08-21T05:30:27Z", "type": "commit"}, {"oid": "44b01fcb285e7ef40bbd4d735d0b1306053b9d02", "url": "https://github.com/elastic/elasticsearch/commit/44b01fcb285e7ef40bbd4d735d0b1306053b9d02", "message": "CR: comments", "committedDate": "2020-08-21T06:39:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU0OTMxOA==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474549318", "bodyText": "I know this is breaking with the style of the Compressor interface a little but I figured it was the simplest to just expose this as a static utility directly.\nAlso, I wonder if we shouldn't just make all the methods on this class static and do away with the Compressor interface. We only have one implementation that we use via its singleton, so there isn't much point in doing in having that interface around?", "author": "original-brownbear", "createdAt": "2020-08-21T09:00:28Z", "path": "server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java", "diffHunk": "@@ -73,8 +74,75 @@ public int headerLength() {\n         return HEADER.length;\n     }\n \n+    // Reusable inflater reference for streaming decompression\n+    private static final ThreadLocal<ReleasableReference<Inflater>> inflaterForStreamRef = ThreadLocal.withInitial(() -> {\n+        final Inflater inflater = new Inflater(true);\n+        return new ReleasableReference<>(inflater, inflater::reset);\n+    });\n+\n+    // Reusable deflater reference for streaming compression\n+    private static final ThreadLocal<ReleasableReference<Deflater>> deflaterForStreamRef = ThreadLocal.withInitial(() -> {\n+        final Deflater deflater = new Deflater(LEVEL, true);\n+        return new ReleasableReference<>(deflater, deflater::reset);\n+    });\n+\n+    // Reference to a deflater or inflater that is used to make sure we do not use the same stream twice when nesting streams.\n+    private static final class ReleasableReference<T> implements Releasable {\n+\n+        protected final T resource;\n+\n+        private final Releasable releasable;\n+\n+        // Thread that is currently using this reference. Only used for assertions and only assigned if assertions are enabled.\n+        private Thread thread = null;\n+\n+        // true if this reference is currently in use and is not available for re-use\n+        boolean inUse;\n+\n+        protected ReleasableReference(T resource, Releasable releasable) {\n+            this.resource = resource;\n+            this.releasable = releasable;\n+        }\n+\n+        T get() {\n+            if (Assertions.ENABLED) {\n+                assert thread == null;\n+                thread = Thread.currentThread();\n+            }\n+            assert inUse == false;\n+            inUse = true;\n+            return resource;\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (Assertions.ENABLED) {\n+                assert thread == Thread.currentThread() :\n+                        \"Opened on [\" + thread.getName() + \"] but closed on [\" + Thread.currentThread().getName() + \"]\";\n+                thread = null;\n+            }\n+            assert inUse;\n+            inUse = false;\n+            releasable.close();\n+        }\n+    }\n+\n     @Override\n-    public StreamInput streamInput(StreamInput in) throws IOException {\n+    public StreamInput threadLocalStreamInput(StreamInput in) throws IOException {\n+        return new InputStreamStreamInput(inputStream(in, true));\n+    }\n+\n+    /**\n+     * Creates a new input stream that decompresses the contents read from the provided input stream.\n+     * Closing the returned stream will close the provided input stream.\n+     * Optionally uses thread-local, pooled resources to save off-heap allocations if the stream is guaranteed to not escape the current\n+     * thread.\n+     *\n+     * @param in           input stream to wrap\n+     * @param threadLocal  whether this stream will only be used on the current thread or not\n+     * @return             decompressing stream\n+     */\n+    public static InputStream inputStream(InputStream in, boolean threadLocal) throws IOException {", "originalCommit": "44b01fcb285e7ef40bbd4d735d0b1306053b9d02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcwNzUzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r475707531", "bodyText": "I'm fine with this as a one-off special case.\n\nAlso, I wonder if we shouldn't just make all the methods on this class static and do away with the Compressor interface. We only have one implementation that we use via its singleton, so there isn't much point in doing in having that interface around?\n\nThis is a good point; there was a time when both DEFLATE and LZF were available. I hesitate on removing the interface since there may be a desire to allow other compression algorithms in the future; I'm not aware of any specific effort but that doesn't mean there won't be one to investigate/add something else like Zstd.", "author": "jaymode", "createdAt": "2020-08-24T15:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU0OTMxOA=="}], "type": "inlineReview"}]}