{"pr_number": 52380, "pr_title": "Unit tests for Range and DateRange aggs", "pr_createdAt": "2020-02-14T18:50:53Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52380", "timeline": [{"oid": "7424affb58bcdb0f546aa648b0fca0e2e1c8e908", "url": "https://github.com/elastic/elasticsearch/commit/7424affb58bcdb0f546aa648b0fca0e2e1c8e908", "message": "Unit tests for Range and DateRange aggs", "committedDate": "2020-02-14T18:49:17Z", "type": "commit"}, {"oid": "4fd0b3c352e0958038ee4c22a081c23a6ff5e6ef", "url": "https://github.com/elastic/elasticsearch/commit/4fd0b3c352e0958038ee4c22a081c23a6ff5e6ef", "message": "Added a couple more edge cases", "committedDate": "2020-02-18T18:48:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkyMjAxOA==", "url": "https://github.com/elastic/elasticsearch/pull/52380#discussion_r380922018", "bodyText": "This line looks like it has kind of funny indentation.", "author": "nik9000", "createdAt": "2020-02-18T20:40:05Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/bucket/range/DateRangeAggregatorTests.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.bucket.range;\n+\n+import org.apache.lucene.document.NumericDocValuesField;\n+import org.apache.lucene.document.SortedNumericDocValuesField;\n+import org.apache.lucene.document.SortedSetDocValuesField;\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.IndexReader;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.CheckedConsumer;\n+import org.elasticsearch.index.mapper.DateFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.search.aggregations.AggregatorTestCase;\n+import org.elasticsearch.search.aggregations.support.AggregationInspectionHelper;\n+\n+import java.io.IOException;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import static java.util.Collections.singleton;\n+\n+public class DateRangeAggregatorTests extends AggregatorTestCase {\n+\n+    private String NUMBER_FIELD_NAME = \"number\";\n+    private String UNMAPPED_FIELD_NAME = \"field_not_appearing_in_this_index\";\n+    private String DATE_FIELD_NAME = \"date\";\n+\n+    private long milli1 = ZonedDateTime.of(2015, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n+    private long milli2 = ZonedDateTime.of(2016, 11, 13, 16, 14, 34, 0, ZoneOffset.UTC).toInstant().toEpochMilli();\n+\n+    public void testNoMatchingField() throws IOException {\n+        testBothResolutions(new MatchAllDocsQuery(), iw -> {\n+            iw.addDocument(singleton(new SortedNumericDocValuesField(\"bogus_field_name\", 7)));\n+            iw.addDocument(singleton(new SortedNumericDocValuesField(\"bogus_field_name\", 2)));\n+            iw.addDocument(singleton(new SortedNumericDocValuesField(\"bogus_field_name\", 3)));\n+        }, range -> {\n+            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n+            assertEquals(2, ranges.size());\n+            assertEquals(0, ranges.get(0).getDocCount());\n+            assertEquals(0, ranges.get(1).getDocCount());\n+            assertFalse(AggregationInspectionHelper.hasValue(range));\n+        });\n+    }\n+\n+    public void testMatchesSortedNumericDocValues() throws IOException {\n+        testBothResolutions(new MatchAllDocsQuery(), iw -> {\n+            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n+            iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n+        }, range -> {\n+            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n+            assertEquals(2, ranges.size());\n+            assertEquals(1, ranges.get(0).getDocCount());\n+            assertEquals(0, ranges.get(1).getDocCount());\n+            assertTrue(AggregationInspectionHelper.hasValue(range));\n+        });\n+    }\n+\n+    public void testMatchesNumericDocValues() throws IOException {\n+        testBothResolutions(new MatchAllDocsQuery(), iw -> {\n+            iw.addDocument(singleton(new NumericDocValuesField(DATE_FIELD_NAME, milli1)));\n+            iw.addDocument(singleton(new NumericDocValuesField(DATE_FIELD_NAME, milli2)));\n+        }, range -> {\n+            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n+            assertEquals(2, ranges.size());\n+            assertEquals(1, ranges.get(0).getDocCount());\n+            assertEquals(0, ranges.get(1).getDocCount());\n+            assertTrue(AggregationInspectionHelper.hasValue(range));\n+        });\n+    }\n+\n+        public void  testMissingDateStringWithDateField() throws IOException {\n+            DateFieldMapper.Builder builder = new DateFieldMapper.Builder(DATE_FIELD_NAME)\n+                .withResolution(DateFieldMapper.Resolution.MILLISECONDS);\n+            DateFieldMapper.DateFieldType fieldType = builder.fieldType();\n+            fieldType.setHasDocValues(true);\n+            fieldType.setName(DATE_FIELD_NAME);\n+\n+            DateRangeAggregationBuilder aggregationBuilder = new DateRangeAggregationBuilder(\"date_range\")\n+                .field(DATE_FIELD_NAME)\n+                .missing(\"2015-11-13T16:14:34\")\n+                .addRange(\"2015-11-13\", \"2015-11-14\");\n+\n+            testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n+                iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli1)));\n+                iw.addDocument(singleton(new SortedNumericDocValuesField(DATE_FIELD_NAME, milli2)));\n+                // Missing will apply to this document\n+                iw.addDocument(singleton(new SortedNumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n+            }, range -> {\n+                List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n+                assertEquals(1, ranges.size());\n+                assertEquals(2, ranges.get(0).getDocCount());\n+                assertTrue(AggregationInspectionHelper.hasValue(range));\n+            }, fieldType);\n+        }\n+\n+    public void  testNumberFieldDateRanges() throws IOException {\n+        DateRangeAggregationBuilder aggregationBuilder = new DateRangeAggregationBuilder(\"date_range\")\n+            .field(NUMBER_FIELD_NAME)\n+            .addRange(\"2015-11-13\", \"2015-11-14\");\n+\n+        MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.INTEGER);\n+        fieldType.setName(NUMBER_FIELD_NAME);\n+\n+        expectThrows(NumberFormatException.class,\n+            () -> testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n+                iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n+                iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 1)));\n+            }, range -> fail(\"Should have thrown exception\"), fieldType));\n+    }\n+\n+    public void  testNumberFieldNumberRanges() throws IOException {\n+        DateRangeAggregationBuilder aggregationBuilder = new DateRangeAggregationBuilder(\"date_range\")\n+            .field(NUMBER_FIELD_NAME)\n+            .addRange(0, 5);\n+\n+        MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.INTEGER);\n+        fieldType.setName(NUMBER_FIELD_NAME);\n+\n+        testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n+            iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n+            iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 1)));\n+        }, range -> {\n+            List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n+            assertEquals(1, ranges.size());\n+            assertEquals(1, ranges.get(0).getDocCount());\n+            assertTrue(AggregationInspectionHelper.hasValue(range));\n+        }, fieldType);\n+    }\n+\n+    public void  testMissingDateStringWithNumberField() throws IOException {\n+            DateRangeAggregationBuilder aggregationBuilder = new DateRangeAggregationBuilder(\"date_range\")\n+                .field(NUMBER_FIELD_NAME)\n+                .addRange(\"2015-11-13\", \"2015-11-14\")\n+                .missing(\"1979-01-01T00:00:00\");\n+\n+            MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.INTEGER);\n+            fieldType.setName(NUMBER_FIELD_NAME);\n+\n+            expectThrows(NumberFormatException.class,\n+                () -> testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n+                    iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n+                    iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 1)));\n+                }, range -> fail(\"Should have thrown exception\"), fieldType));\n+        }\n+\n+        public void testUnmappedWithMissingNumber() throws IOException {\n+            DateRangeAggregationBuilder aggregationBuilder = new DateRangeAggregationBuilder(\"date_range\")\n+                .field(\"does_not_exist\")\n+                .addRange(\"2015-11-13\", \"2015-11-14\")\n+                .missing(1447438575000L); // 2015-11-13 6:16:15\n+\n+            MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.INTEGER);\n+            fieldType.setName(NUMBER_FIELD_NAME);\n+\n+            testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n+                iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n+                iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 1)));\n+            }, range -> {\n+                List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n+                assertEquals(1, ranges.size());\n+                assertEquals(2, ranges.get(0).getDocCount());\n+                assertTrue(AggregationInspectionHelper.hasValue(range));\n+            }, fieldType);\n+        }\n+\n+        public void testUnmappedWithMissingDate() throws IOException {\n+            DateRangeAggregationBuilder aggregationBuilder = new DateRangeAggregationBuilder(\"date_range\")\n+                .field(\"does_not_exist\")\n+                .addRange(\"2015-11-13\", \"2015-11-14\")\n+                .missing(\"2015-11-13T10:11:12\");\n+\n+            MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.INTEGER);\n+            fieldType.setName(NUMBER_FIELD_NAME);\n+\n+                testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n+                    iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n+                    iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 1)));\n+                }, range -> {\n+                    List<? extends InternalRange.Bucket> ranges = range.getBuckets();\n+                    assertEquals(1, ranges.size());\n+                    assertEquals(2, ranges.get(0).getDocCount());\n+                    assertTrue(AggregationInspectionHelper.hasValue(range));\n+                }, fieldType);\n+        }\n+\n+        public void testKeywordField() {\n+            DateRangeAggregationBuilder aggregationBuilder = new DateRangeAggregationBuilder(\"date_range\")\n+                .field(\"not_a_number\")\n+                .addRange(\"2015-11-13\", \"2015-11-14\");\n+\n+            MappedFieldType fieldType = new KeywordFieldMapper.KeywordFieldType();\n+            fieldType.setName(\"not_a_number\");\n+            fieldType.setHasDocValues(true);\n+\n+            IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n+                () -> testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n+                    iw.addDocument(singleton(new SortedSetDocValuesField(\"string\", new BytesRef(\"foo\"))));\n+                }, range -> fail(\"Should have thrown exception\"), fieldType));\n+            // I believe this error is coming from improperly parsing the range, not the field.\n+            assertEquals(\"For input string: \\\"2015-11-13\\\"\", e.getMessage());\n+        }\n+\n+        public void testBadMissingField() {\n+            DateRangeAggregationBuilder aggregationBuilder = new DateRangeAggregationBuilder(\"date_range\")\n+                .field(NUMBER_FIELD_NAME)\n+                .addRange(\"2020-01-01T00:00:00\", \"2020-01-02T00:00:00\")\n+                .missing(\"bogus\");\n+\n+            MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.INTEGER);\n+            fieldType.setName(NUMBER_FIELD_NAME);\n+\n+            expectThrows(NumberFormatException.class,\n+                () -> testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n+                    iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n+                    iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 1)));\n+                }, range -> fail(\"Should have thrown exception\"), fieldType));\n+        }\n+\n+        public void testUnmappedWithBadMissingField() {\n+            DateRangeAggregationBuilder aggregationBuilder = new DateRangeAggregationBuilder(\"date_range\")\n+                .field(\"does_not_exist\")\n+                .addRange(\"2020-01-01T00:00:00\", \"2020-01-02T00:00:00\")\n+                .missing(\"bogus\");\n+\n+            MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.INTEGER);\n+            fieldType.setName(NUMBER_FIELD_NAME);\n+\n+            expectThrows(ElasticsearchParseException.class,\n+                () -> testCase(aggregationBuilder, new MatchAllDocsQuery(), iw -> {\n+                    iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 7)));\n+                    iw.addDocument(singleton(new NumericDocValuesField(NUMBER_FIELD_NAME, 1)));\n+                }, range -> fail(\"Should have thrown exception\"), fieldType));\n+        }\n+\n+    private void testBothResolutions(Query query,\n+                                     CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n+                                     Consumer<InternalRange<? extends InternalRange.Bucket, ? extends InternalRange>> verify)\n+        throws IOException {", "originalCommit": "4fd0b3c352e0958038ee4c22a081c23a6ff5e6ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5ab6298149383b161101ae371ef5a13087cfde80", "url": "https://github.com/elastic/elasticsearch/commit/5ab6298149383b161101ae371ef5a13087cfde80", "message": "fix indentation", "committedDate": "2020-02-18T21:03:39Z", "type": "commit"}, {"oid": "2dd0827bd141e3770ba544a5fbc3c7572f1b811c", "url": "https://github.com/elastic/elasticsearch/commit/2dd0827bd141e3770ba544a5fbc3c7572f1b811c", "message": "Merge branch 'master' into range-unit-tests", "committedDate": "2020-02-18T21:48:35Z", "type": "commit"}]}