{"pr_number": 64591, "pr_title": "Centralize cache service instances creation in tests", "pr_createdAt": "2020-11-04T13:45:05Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/64591", "timeline": [{"oid": "ef9518eec2f71780a85a5505cd9774fc7740ea7f", "url": "https://github.com/elastic/elasticsearch/commit/ef9518eec2f71780a85a5505cd9774fc7740ea7f", "message": "Mutualize cache service creation in tests", "committedDate": "2020-11-04T13:30:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxMTUxNg==", "url": "https://github.com/elastic/elasticsearch/pull/64591#discussion_r517411516", "bodyText": "The method this replaces in some spots used a 30s timeout. When I created it I just copied those 30s from previous code so I don't know if we actually need the long of a timeout here, but maybe we do and should put I back here?", "author": "original-brownbear", "createdAt": "2020-11-04T15:06:32Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/AbstractSearchableSnapshotsTestCase.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.routing.TestShardRouting;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.lucene.store.ESIndexInputTestCase;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.indices.recovery.RecoveryState;\n+import org.elasticsearch.indices.recovery.SearchableSnapshotRecoveryState;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.snapshots.Snapshot;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.threadpool.ThreadPoolStats;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheService;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+public abstract class AbstractSearchableSnapshotsTestCase extends ESIndexInputTestCase {\n+\n+    protected ThreadPool threadPool;\n+\n+    @Before\n+    public void setUpTest() {\n+        threadPool = new TestThreadPool(getTestName(), SearchableSnapshots.executorBuilders());\n+    }\n+\n+    @After\n+    public void tearDownTest() {\n+        assertTrue(ThreadPool.terminate(threadPool, 30, TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * @return a new {@link CacheService} instance configured with default settings\n+     */\n+    protected CacheService defaultCacheService() {\n+        return new CacheService(AbstractSearchableSnapshotsTestCase::noOpCacheCleaner, Settings.EMPTY);\n+    }\n+\n+    /**\n+     * @return a new {@link CacheService} instance configured with random cache size and cache range size settings\n+     */\n+    protected CacheService randomCacheService() {\n+        final Settings.Builder cacheSettings = Settings.builder();\n+        if (randomBoolean()) {\n+            cacheSettings.put(CacheService.SNAPSHOT_CACHE_SIZE_SETTING.getKey(), randomCacheSize());\n+        }\n+        if (randomBoolean()) {\n+            cacheSettings.put(CacheService.SNAPSHOT_CACHE_RANGE_SIZE_SETTING.getKey(), randomCacheRangeSize());\n+        }\n+        return new CacheService(AbstractSearchableSnapshotsTestCase::noOpCacheCleaner, cacheSettings.build());\n+    }\n+\n+    /**\n+     * @return a new {@link CacheService} instance configured with the given cache size and cache range size settings\n+     */\n+    protected CacheService createCacheService(final ByteSizeValue cacheSize, final ByteSizeValue cacheRangeSize) {\n+        return new CacheService(\n+            AbstractSearchableSnapshotsTestCase::noOpCacheCleaner,\n+            Settings.builder()\n+                .put(CacheService.SNAPSHOT_CACHE_SIZE_SETTING.getKey(), cacheSize)\n+                .put(CacheService.SNAPSHOT_CACHE_RANGE_SIZE_SETTING.getKey(), cacheRangeSize)\n+                .build()\n+        );\n+    }\n+\n+    protected static void noOpCacheCleaner() {}\n+\n+    /**\n+     * @return a random {@link ByteSizeValue} that can be used to set {@link CacheService#SNAPSHOT_CACHE_SIZE_SETTING}.\n+     * Note that it can return a cache size of 0.\n+     */\n+    protected static ByteSizeValue randomCacheSize() {\n+        return new ByteSizeValue(randomNonNegativeLong());\n+    }\n+\n+    /**\n+     * @return a random {@link ByteSizeValue} that can be used to set {@link CacheService#SNAPSHOT_CACHE_RANGE_SIZE_SETTING}\n+     */\n+    protected static ByteSizeValue randomCacheRangeSize() {\n+        return new ByteSizeValue(\n+            randomLongBetween(CacheService.MIN_SNAPSHOT_CACHE_RANGE_SIZE.getBytes(), CacheService.MAX_SNAPSHOT_CACHE_RANGE_SIZE.getBytes())\n+        );\n+    }\n+\n+    protected static SearchableSnapshotRecoveryState createRecoveryState() {\n+        ShardRouting shardRouting = TestShardRouting.newShardRouting(\n+            new ShardId(randomAlphaOfLength(10), randomAlphaOfLength(10), 0),\n+            randomAlphaOfLength(10),\n+            true,\n+            ShardRoutingState.INITIALIZING,\n+            new RecoverySource.SnapshotRecoverySource(\n+                UUIDs.randomBase64UUID(),\n+                new Snapshot(\"repo\", new SnapshotId(randomAlphaOfLength(8), UUIDs.randomBase64UUID())),\n+                Version.CURRENT,\n+                new IndexId(\"some_index\", UUIDs.randomBase64UUID(random()))\n+            )\n+        );\n+        DiscoveryNode targetNode = new DiscoveryNode(\"local\", buildNewFakeTransportAddress(), Version.CURRENT);\n+        SearchableSnapshotRecoveryState recoveryState = new SearchableSnapshotRecoveryState(shardRouting, targetNode, null);\n+\n+        recoveryState.setStage(RecoveryState.Stage.INIT)\n+            .setStage(RecoveryState.Stage.INDEX)\n+            .setStage(RecoveryState.Stage.VERIFY_INDEX)\n+            .setStage(RecoveryState.Stage.TRANSLOG);\n+        recoveryState.getIndex().setFileDetailsComplete();\n+        recoveryState.setStage(RecoveryState.Stage.FINALIZE).setStage(RecoveryState.Stage.DONE);\n+\n+        return recoveryState;\n+    }\n+\n+    /**\n+     * Wait for all operations on the threadpool to complete\n+     */\n+    protected static void assertThreadPoolNotBusy(ThreadPool threadPool) throws Exception {\n+        assertBusy(() -> {", "originalCommit": "ef9518eec2f71780a85a5505cd9774fc7740ea7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg2MzMzMw==", "url": "https://github.com/elastic/elasticsearch/pull/64591#discussion_r517863333", "bodyText": "Thanks for catching this. I looked a bit at the history and I think it's preferable to use a long timeout here (mostly for testRandomReads())", "author": "tlrx", "createdAt": "2020-11-05T08:18:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxMTUxNg=="}], "type": "inlineReview"}, {"oid": "afa3c6bc0637cb810c3fd6d1c2f7b8c2c63bb13e", "url": "https://github.com/elastic/elasticsearch/commit/afa3c6bc0637cb810c3fd6d1c2f7b8c2c63bb13e", "message": "30s", "committedDate": "2020-11-04T16:31:14Z", "type": "commit"}]}