{"pr_number": 55633, "pr_title": "Retry failed replication due to transient errors", "pr_createdAt": "2020-04-22T22:53:20Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55633", "timeline": [{"oid": "185f0a0e2bf85b7e27f0f3707fc73a386b3b846f", "url": "https://github.com/elastic/elasticsearch/commit/185f0a0e2bf85b7e27f0f3707fc73a386b3b846f", "message": "Retry failed replication due to transient errors\n\nCurrently a failed replication action will fail an entire replica. This\nincludes when replication fails due to potentially short lived transient\nissues such as network distruptions or circuit breaking errors.\n\nThis commit adds the concept of a retryable action. A retryable action\nwill be retryed in face of certain errors. The action will be retried\nafter an exponentially increasing backoff period. After defined time,\nthe action will timeout.", "committedDate": "2020-03-26T22:31:18Z", "type": "commit"}, {"oid": "59dda7a918a5bbbf9dfd7b42b66e573bd6cec1c2", "url": "https://github.com/elastic/elasticsearch/commit/59dda7a918a5bbbf9dfd7b42b66e573bd6cec1c2", "message": "Fix", "committedDate": "2020-03-26T22:42:33Z", "type": "commit"}, {"oid": "eab09d49bab5a6d226621ae9f8eafa524d6db6b5", "url": "https://github.com/elastic/elasticsearch/commit/eab09d49bab5a6d226621ae9f8eafa524d6db6b5", "message": "Merge remote-tracking branch 'upstream/master' into retry_replication", "committedDate": "2020-03-30T20:44:05Z", "type": "commit"}, {"oid": "7aa25e0919424261bc5a5a2a89093dd8caf75319", "url": "https://github.com/elastic/elasticsearch/commit/7aa25e0919424261bc5a5a2a89093dd8caf75319", "message": "Changes", "committedDate": "2020-03-30T22:39:42Z", "type": "commit"}, {"oid": "20fc73d04664bba02d21fea5478e39086aefae9a", "url": "https://github.com/elastic/elasticsearch/commit/20fc73d04664bba02d21fea5478e39086aefae9a", "message": "Merge remote-tracking branch 'upstream/master' into retry_replication", "committedDate": "2020-04-03T21:58:07Z", "type": "commit"}, {"oid": "448f35b4b748e20055e7b7b2f70a15fb646c7fcc", "url": "https://github.com/elastic/elasticsearch/commit/448f35b4b748e20055e7b7b2f70a15fb646c7fcc", "message": "Change", "committedDate": "2020-04-04T00:17:53Z", "type": "commit"}, {"oid": "3e2a918f84c03130a0aeb5881cedc673bbbe647d", "url": "https://github.com/elastic/elasticsearch/commit/3e2a918f84c03130a0aeb5881cedc673bbbe647d", "message": "Merge remote-tracking branch 'upstream/master' into retry_replication", "committedDate": "2020-04-22T18:44:43Z", "type": "commit"}, {"oid": "00bd1570871b84e85390356e13af7808b7ea4b31", "url": "https://github.com/elastic/elasticsearch/commit/00bd1570871b84e85390356e13af7808b7ea4b31", "message": "Changes", "committedDate": "2020-04-22T22:26:48Z", "type": "commit"}, {"oid": "f775f95e296713e52be63567ae229ff73b0bf974", "url": "https://github.com/elastic/elasticsearch/commit/f775f95e296713e52be63567ae229ff73b0bf974", "message": "Changes", "committedDate": "2020-04-22T22:50:52Z", "type": "commit"}, {"oid": "83f11aeb6ada46da2a3d102fb341e216201ba45b", "url": "https://github.com/elastic/elasticsearch/commit/83f11aeb6ada46da2a3d102fb341e216201ba45b", "message": "Changes", "committedDate": "2020-04-22T23:04:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMjQzMg==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413722432", "bodyText": "Similar to GlobalCheckpointListeners, I would prefer for PendingReplicationActions to live outside ReplicationTracker (namely in IndexShard). We can then also close it whenever the shard closes, which is another event where we want to ensure that all pending replication actions are completed.\nInstead, we could have a ReplicationGroupChangedListener here, which just invokes a Consumer<ReplicationGroup> here.", "author": "ywelsch", "createdAt": "2020-04-23T11:04:42Z", "path": "server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java", "diffHunk": "@@ -223,6 +224,8 @@\n      */\n     private final double fileBasedRecoveryThreshold;\n \n+    private final PendingReplicationActions pendingReplication;", "originalCommit": "83f11aeb6ada46da2a3d102fb341e216201ba45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyNzcwMw==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413727703", "bodyText": "should we just use the RetryableAction as key?", "author": "ywelsch", "createdAt": "2020-04-23T11:13:34Z", "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+\n+import java.util.Map;\n+\n+public class PendingReplicationActions {\n+\n+    private final Map<String, Map<Object, RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+\n+    public void addPendingAction(String nodeId, Object actionKey, RetryableAction<?> replicationAction) {", "originalCommit": "83f11aeb6ada46da2a3d102fb341e216201ba45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyODc3OA==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413728778", "bodyText": "In case where this is null, shouldn't we cancel the RetryableAction right away?", "author": "ywelsch", "createdAt": "2020-04-23T11:15:32Z", "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+\n+import java.util.Map;\n+\n+public class PendingReplicationActions {\n+\n+    private final Map<String, Map<Object, RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+\n+    public void addPendingAction(String nodeId, Object actionKey, RetryableAction<?> replicationAction) {\n+        Map<Object, RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(nodeId);\n+        if (ongoingActionsOnNode != null) {", "originalCommit": "83f11aeb6ada46da2a3d102fb341e216201ba45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczNDM3NA==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413734374", "bodyText": "I'm concerned that we're still running this under the mutex of ReplicationTracker, which is supposed to be only held for a very short time. I wonder if we should fork off to a different thread, or if we should try to move this out of the mutex", "author": "ywelsch", "createdAt": "2020-04-23T11:25:08Z", "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+\n+import java.util.Map;\n+\n+public class PendingReplicationActions {\n+\n+    private final Map<String, Map<Object, RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+\n+    public void addPendingAction(String nodeId, Object actionKey, RetryableAction<?> replicationAction) {\n+        Map<Object, RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(nodeId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.put(actionKey, replicationAction);\n+            if (onGoingReplicationActions.containsKey(nodeId) == false) {\n+                replicationAction.cancel(new ElasticsearchException(\"TODO\"));\n+            }\n+        }\n+    }\n+\n+    public void removeReplicationAction(String nodeId, Object actionKey) {\n+        Map<Object, RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(nodeId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.remove(actionKey);\n+        }\n+    }\n+\n+    public synchronized void nodeJoinedReplicationGroup(String nodeId) {\n+        onGoingReplicationActions.put(nodeId, ConcurrentCollections.newConcurrentMap());\n+    }\n+\n+    public synchronized void nodeLeftReplicationGroup(String nodeId) {\n+        Map<Object, RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.remove(nodeId);\n+        for (RetryableAction<?> replicationAction : ongoingActionsOnNode.values()) {\n+            replicationAction.cancel(new ElasticsearchException(\"TODO\"));", "originalCommit": "83f11aeb6ada46da2a3d102fb341e216201ba45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczODc4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413738785", "bodyText": "should we call this before run? That would allow things to be cancelled right away if the node had already dropped...", "author": "ywelsch", "createdAt": "2020-04-23T11:32:47Z", "path": "server/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java", "diffHunk": "@@ -184,42 +192,65 @@ private void performOnReplica(final ShardRouting shard, final ReplicaRequest rep\n         if (logger.isTraceEnabled()) {\n             logger.trace(\"[{}] sending op [{}] to replica {} for request [{}]\", shard.shardId(), opType, shard, replicaRequest);\n         }\n+        final Object actionKey = new Object();\n \n         totalShards.incrementAndGet();\n         pendingActions.incrementAndGet();\n-        replicasProxy.performOn(shard, replicaRequest, primaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes,\n-            new ActionListener<>() {\n-                @Override\n-                public void onResponse(ReplicaResponse response) {\n-                    successfulShards.incrementAndGet();\n-                    try {\n-                        updateCheckPoints(shard, response::localCheckpoint, response::globalCheckpoint);\n-                    } finally {\n-                        decPendingAndFinishIfNeeded();\n-                    }\n+        PendingReplicationActions pendingReplicationActions = primary.getPendingReplicationActions();\n+        final ActionListener<ReplicaResponse> replicationListener = new ActionListener<>() {\n+            @Override\n+            public void onResponse(ReplicaResponse response) {\n+                pendingReplicationActions.removeReplicationAction(shard.currentNodeId(), actionKey);\n+                successfulShards.incrementAndGet();\n+                try {\n+                    updateCheckPoints(shard, response::localCheckpoint, response::globalCheckpoint);\n+                } finally {\n+                    decPendingAndFinishIfNeeded();\n                 }\n+            }\n \n-                @Override\n-                public void onFailure(Exception replicaException) {\n-                    logger.trace(() -> new ParameterizedMessage(\n-                        \"[{}] failure while performing [{}] on replica {}, request [{}]\",\n-                        shard.shardId(), opType, shard, replicaRequest), replicaException);\n-                    // Only report \"critical\" exceptions - TODO: Reach out to the master node to get the latest shard state then report.\n-                    if (TransportActions.isShardNotAvailableException(replicaException) == false) {\n-                        RestStatus restStatus = ExceptionsHelper.status(replicaException);\n-                        shardReplicaFailures.add(new ReplicationResponse.ShardInfo.Failure(\n-                            shard.shardId(), shard.currentNodeId(), replicaException, restStatus, false));\n-                    }\n-                    String message = String.format(Locale.ROOT, \"failed to perform %s on replica %s\", opType, shard);\n-                    replicasProxy.failShardIfNeeded(shard, primaryTerm, message, replicaException,\n-                        ActionListener.wrap(r -> decPendingAndFinishIfNeeded(), ReplicationOperation.this::onNoLongerPrimary));\n+            @Override\n+            public void onFailure(Exception replicaException) {\n+                pendingReplicationActions.removeReplicationAction(shard.currentNodeId(), actionKey);\n+                logger.trace(() -> new ParameterizedMessage(\n+                    \"[{}] failure while performing [{}] on replica {}, request [{}]\",\n+                    shard.shardId(), opType, shard, replicaRequest), replicaException);\n+                // Only report \"critical\" exceptions - TODO: Reach out to the master node to get the latest shard state then report.\n+                if (TransportActions.isShardNotAvailableException(replicaException) == false) {\n+                    RestStatus restStatus = ExceptionsHelper.status(replicaException);\n+                    shardReplicaFailures.add(new ReplicationResponse.ShardInfo.Failure(\n+                        shard.shardId(), shard.currentNodeId(), replicaException, restStatus, false));\n                 }\n+                String message = String.format(Locale.ROOT, \"failed to perform %s on replica %s\", opType, shard);\n+                replicasProxy.failShardIfNeeded(shard, primaryTerm, message, replicaException,\n+                    ActionListener.wrap(r -> decPendingAndFinishIfNeeded(), ReplicationOperation.this::onNoLongerPrimary));\n+            }\n \n-                @Override\n-                public String toString() {\n-                    return \"[\" + replicaRequest + \"][\" + shard + \"]\";\n-                }\n-            });\n+            @Override\n+            public String toString() {\n+                return \"[\" + replicaRequest + \"][\" + shard + \"]\";\n+            }\n+        };\n+\n+        final RetryableAction<ReplicaResponse> replicationAction = new RetryableAction<>(logger, threadPool, TimeValue.timeValueMillis(50),\n+            replicaRequest.timeout(), replicationListener) {\n+\n+            @Override\n+            public void tryAction(ActionListener<ReplicaResponse> listener) {\n+                replicasProxy.performOn(shard, replicaRequest, primaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes, listener);\n+            }\n+\n+            @Override\n+            public boolean shouldRetry(Exception e) {\n+                final Throwable cause = ExceptionsHelper.unwrapCause(e);\n+                return cause instanceof CircuitBreakingException ||\n+                    cause instanceof EsRejectedExecutionException ||\n+                    cause instanceof ConnectTransportException;\n+            }\n+        };\n+\n+        replicationAction.run();\n+        pendingReplicationActions.addPendingAction(shard.currentNodeId(), actionKey, replicationAction);", "originalCommit": "83f11aeb6ada46da2a3d102fb341e216201ba45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczOTE0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413739147", "bodyText": "undo?", "author": "ywelsch", "createdAt": "2020-04-23T11:33:23Z", "path": "server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java", "diffHunk": "@@ -862,8 +865,7 @@ private static long inSyncCheckpointStates(\n     /**\n      * Initialize the global checkpoint service. The specified global checkpoint should be set to the last known global checkpoint, or\n      * {@link SequenceNumbers#UNASSIGNED_SEQ_NO}.\n-     *\n-     * @param shardId               the shard ID\n+     *  @param shardId               the shard ID", "originalCommit": "83f11aeb6ada46da2a3d102fb341e216201ba45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2NDAxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413764015", "bodyText": "I think that I would prefer for this to be set before we call the methods on pendingReplication, just to be sure that an exception there does not mess up the state in this class.", "author": "ywelsch", "createdAt": "2020-04-23T12:14:47Z", "path": "server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java", "diffHunk": "@@ -916,6 +919,47 @@ public ReplicationGroup getReplicationGroup() {\n         return replicationGroup;\n     }\n \n+    /**\n+     * Returns the pending replication actions for the shard.\n+     *\n+     * @return the pending replication actions\n+     */\n+    public PendingReplicationActions getPendingReplicationActions() {\n+        assert primaryMode;\n+        return pendingReplication;\n+    }\n+\n+    private void updateReplicationGroupAndNotify(boolean replicasMightHaveChanged) {\n+        ReplicationGroup newReplicationGroup = calculateReplicationGroup();\n+        ReplicationGroup oldReplicationGroup = this.replicationGroup;\n+        if (replicasMightHaveChanged) {\n+            Set<String> oldReplicaNodeIds;\n+            if (oldReplicationGroup == null) {\n+                oldReplicaNodeIds = Collections.emptySet();\n+            } else {\n+                oldReplicaNodeIds = oldReplicationGroup.getReplicationTargets().stream()\n+                    .map(ShardRouting::currentNodeId)\n+                    .collect(Collectors.toSet());\n+            }\n+            for (ShardRouting replica : newReplicationGroup.getReplicationTargets()) {\n+                if (oldReplicaNodeIds.contains(replica.currentNodeId()) == false) {\n+                    pendingReplication.nodeJoinedReplicationGroup(replica.currentNodeId());\n+                }\n+            }\n+        }\n+        this.replicationGroup = newReplicationGroup;", "originalCommit": "83f11aeb6ada46da2a3d102fb341e216201ba45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE5MDk5NA==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r414190994", "bodyText": "This work was to prevent the race where the ReplicationGroup is returned by the replication tracker with a new node to a ReplicationOperation. This operation attempts to start a replication request, but the listener to PendingReplicationActions has not yet been called so the request is immediately cancelled.\nI made your change. But I think spurious cancellations are possible.", "author": "tbrooks8", "createdAt": "2020-04-23T23:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2NDAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzODYyMw==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r417138623", "bodyText": "ok, I see now. One option is to turn it around then, but use try - finally to make sure that the state is updated even when the listener throws.\nAnother option (currently preferring this one for its generality) is that we have a versioning concept on ReplicationGroup (i.e. knowing which one is newer than another one) and that we explicitly update PendingReplicationActions whenever we capture the ReplicationGroup in IndexShard (most times the update will be a NOOP and should not need any locking on PendingReplicationActions).", "author": "ywelsch", "createdAt": "2020-04-29T08:09:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2NDAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2NTgyNg==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413765826", "bodyText": "maybe calculate the node sets for both old and new, and then just use Sets.difference to determine what changed? With the approach here, you're notifying the absence of a given node multiple times.", "author": "ywelsch", "createdAt": "2020-04-23T12:17:41Z", "path": "server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java", "diffHunk": "@@ -916,6 +919,47 @@ public ReplicationGroup getReplicationGroup() {\n         return replicationGroup;\n     }\n \n+    /**\n+     * Returns the pending replication actions for the shard.\n+     *\n+     * @return the pending replication actions\n+     */\n+    public PendingReplicationActions getPendingReplicationActions() {\n+        assert primaryMode;\n+        return pendingReplication;\n+    }\n+\n+    private void updateReplicationGroupAndNotify(boolean replicasMightHaveChanged) {\n+        ReplicationGroup newReplicationGroup = calculateReplicationGroup();\n+        ReplicationGroup oldReplicationGroup = this.replicationGroup;\n+        if (replicasMightHaveChanged) {\n+            Set<String> oldReplicaNodeIds;\n+            if (oldReplicationGroup == null) {\n+                oldReplicaNodeIds = Collections.emptySet();\n+            } else {\n+                oldReplicaNodeIds = oldReplicationGroup.getReplicationTargets().stream()\n+                    .map(ShardRouting::currentNodeId)\n+                    .collect(Collectors.toSet());\n+            }\n+            for (ShardRouting replica : newReplicationGroup.getReplicationTargets()) {\n+                if (oldReplicaNodeIds.contains(replica.currentNodeId()) == false) {\n+                    pendingReplication.nodeJoinedReplicationGroup(replica.currentNodeId());\n+                }\n+            }\n+        }\n+        this.replicationGroup = newReplicationGroup;\n+        if (oldReplicationGroup != null && replicasMightHaveChanged) {\n+            Set<String> newReplicaNodeIds = newReplicationGroup.getReplicationTargets().stream()\n+                .map(ShardRouting::currentNodeId)\n+                .collect(Collectors.toSet());\n+            for (ShardRouting replica : oldReplicationGroup.getReplicationTargets()) {", "originalCommit": "83f11aeb6ada46da2a3d102fb341e216201ba45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE5MDI3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r414190272", "bodyText": "I'm not sure I follow this comment. We need to check the new ones against previous and add new nodes. And then check previous against new ones and remove old nodes. Maybe you can update this comment based on the current version.", "author": "tbrooks8", "createdAt": "2020-04-23T23:28:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2NTgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2OTY0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413769642", "bodyText": "I think this optimization (replicasMightHaveChanged) is unnecessary (and easy to get wrong). The methods that call updateReplicationGroupAndNotify are rarely called, so let's omit this.", "author": "ywelsch", "createdAt": "2020-04-23T12:23:30Z", "path": "server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java", "diffHunk": "@@ -916,6 +919,47 @@ public ReplicationGroup getReplicationGroup() {\n         return replicationGroup;\n     }\n \n+    /**\n+     * Returns the pending replication actions for the shard.\n+     *\n+     * @return the pending replication actions\n+     */\n+    public PendingReplicationActions getPendingReplicationActions() {\n+        assert primaryMode;\n+        return pendingReplication;\n+    }\n+\n+    private void updateReplicationGroupAndNotify(boolean replicasMightHaveChanged) {", "originalCommit": "83f11aeb6ada46da2a3d102fb341e216201ba45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc3NTM4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413775382", "bodyText": "I we only register an action when we're actively scheduling something for retry, we might not need this class at all, and just have a simple list of listeners that wait for replication group changes, each of which checks whether the set of nodes changed? We could potentially even store the set of nodes of replication targets in ReplicationGroup. This means that a simple hashset lookup would suffice on notificaion of ReplicattionGroup changes to determine if the requests is still to be kept scheduled retrying.", "author": "ywelsch", "createdAt": "2020-04-23T12:32:05Z", "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+\n+import java.util.Map;\n+\n+public class PendingReplicationActions {", "originalCommit": "83f11aeb6ada46da2a3d102fb341e216201ba45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE5MzI3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r414193272", "bodyText": "I made some of these changes (set of node ids in ReplicationGroup, only register retries, etc). But I don't see the whole vision. I understand that with a limited subset of stored listeners we can iterate through them all and pass the ReplicationGroup. But it seems to me that there is a race between a retry being scheduled and the listener being registered.\nThe ConcurrentMaps in PendingReplicationActions prevents a listener from being scheduled on a node that left the ReplicationGroup. If we just maintain a list of listeners, it is possible that the ReplicationGroup has changed as the listener is registered. Unless you want me to forcefully call the listener with the most recent view of the ReplicationGroup after the listener has been registered.", "author": "tbrooks8", "createdAt": "2020-04-23T23:36:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc3NTM4Mg=="}], "type": "inlineReview"}, {"oid": "e33efc29676e13134e26cfefbaeaf944889f2f62", "url": "https://github.com/elastic/elasticsearch/commit/e33efc29676e13134e26cfefbaeaf944889f2f62", "message": "Merge remote-tracking branch 'upstream/master' into retry_replication", "committedDate": "2020-04-23T21:10:23Z", "type": "commit"}, {"oid": "099d784cfa5b4d090d8d3c649707bc7109bfa508", "url": "https://github.com/elastic/elasticsearch/commit/099d784cfa5b4d090d8d3c649707bc7109bfa508", "message": "Changes", "committedDate": "2020-04-23T22:13:06Z", "type": "commit"}, {"oid": "94fdb6eea40867b8ae6f4b9156d3dc8a877ae00d", "url": "https://github.com/elastic/elasticsearch/commit/94fdb6eea40867b8ae6f4b9156d3dc8a877ae00d", "message": "Change", "committedDate": "2020-04-23T22:18:17Z", "type": "commit"}, {"oid": "6eec964be7a38db6da5c6360632a0d7794299eea", "url": "https://github.com/elastic/elasticsearch/commit/6eec964be7a38db6da5c6360632a0d7794299eea", "message": "Put if absent", "committedDate": "2020-04-23T22:22:43Z", "type": "commit"}, {"oid": "0bbbd21901b1d3c2d38e56853603bb5dd244e4bb", "url": "https://github.com/elastic/elasticsearch/commit/0bbbd21901b1d3c2d38e56853603bb5dd244e4bb", "message": "Changes", "committedDate": "2020-04-23T23:26:09Z", "type": "commit"}, {"oid": "a4a23dfff6905814cd18ba209532cba634ec868e", "url": "https://github.com/elastic/elasticsearch/commit/a4a23dfff6905814cd18ba209532cba634ec868e", "message": "Whitespace", "committedDate": "2020-04-23T23:40:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUyNDY0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r414524647", "bodyText": "onReplicationGroupUpdated?", "author": "ywelsch", "createdAt": "2020-04-24T12:07:33Z", "path": "server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java", "diffHunk": "@@ -223,6 +224,8 @@\n      */\n     private final double fileBasedRecoveryThreshold;\n \n+    private final Consumer<ReplicationGroup> onReplicationGroup;", "originalCommit": "a4a23dfff6905814cd18ba209532cba634ec868e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUyNjY5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r414526699", "bodyText": "Given that this is happening under the mutex anyway (add assert Thread.holdsLock(this); to the beginning of this method), I would prefer for the field to be set before the listener is called.", "author": "ywelsch", "createdAt": "2020-04-24T12:10:49Z", "path": "server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java", "diffHunk": "@@ -916,6 +936,12 @@ public ReplicationGroup getReplicationGroup() {\n         return replicationGroup;\n     }\n \n+    private void updateReplicationGroupAndNotify() {\n+        ReplicationGroup newReplicationGroup = calculateReplicationGroup();\n+        onReplicationGroup.accept(newReplicationGroup);\n+        replicationGroup = newReplicationGroup;", "originalCommit": "a4a23dfff6905814cd18ba209532cba634ec868e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUyNzkzNw==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r414527937", "bodyText": "replicationTargets also contain the primary. Perhaps call this replicationTargetNodeIds instead and update method name  / javadoc below.", "author": "ywelsch", "createdAt": "2020-04-24T12:12:54Z", "path": "server/src/main/java/org/elasticsearch/index/shard/ReplicationGroup.java", "diffHunk": "@@ -36,6 +37,7 @@\n     private final Set<String> trackedAllocationIds;\n \n     private final Set<String> unavailableInSyncShards; // derived from the other fields\n+    private final Set<String> replicaNodeIds; // derived from the other fields", "originalCommit": "a4a23dfff6905814cd18ba209532cba634ec868e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU3MzYzNw==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r414573637", "bodyText": "Thinking a bit more about this, we don't need this at all. We can just use trackedAllocationIds in this class instead, and key the information in PendingReplicationActions by allocation id (which represents the shard that is being replicated to).", "author": "ywelsch", "createdAt": "2020-04-24T13:25:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUyNzkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzMzc0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r414533747", "bodyText": "this can be moved now further down below where it's actually used, or perhaps even better, pass it in to the performOnReplica method.", "author": "ywelsch", "createdAt": "2020-04-24T12:22:38Z", "path": "server/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java", "diffHunk": "@@ -184,42 +192,82 @@ private void performOnReplica(final ShardRouting shard, final ReplicaRequest rep\n         if (logger.isTraceEnabled()) {\n             logger.trace(\"[{}] sending op [{}] to replica {} for request [{}]\", shard.shardId(), opType, shard, replicaRequest);\n         }\n-\n         totalShards.incrementAndGet();\n         pendingActions.incrementAndGet();\n-        replicasProxy.performOn(shard, replicaRequest, primaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes,\n-            new ActionListener<>() {\n-                @Override\n-                public void onResponse(ReplicaResponse response) {\n-                    successfulShards.incrementAndGet();\n-                    try {\n-                        updateCheckPoints(shard, response::localCheckpoint, response::globalCheckpoint);\n-                    } finally {\n-                        decPendingAndFinishIfNeeded();\n-                    }\n+        PendingReplicationActions pendingReplicationActions = primary.getPendingReplicationActions();", "originalCommit": "a4a23dfff6905814cd18ba209532cba634ec868e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU1MTU3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r414551577", "bodyText": "If we implement this check here, then the breaker/rejected/connect exception will be bubbled up as the cause for failure of the replica, which could be confusing (The failure is rather that the replica has been removed from the replication group).", "author": "ywelsch", "createdAt": "2020-04-24T12:51:46Z", "path": "server/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java", "diffHunk": "@@ -184,42 +192,82 @@ private void performOnReplica(final ShardRouting shard, final ReplicaRequest rep\n         if (logger.isTraceEnabled()) {\n             logger.trace(\"[{}] sending op [{}] to replica {} for request [{}]\", shard.shardId(), opType, shard, replicaRequest);\n         }\n-\n         totalShards.incrementAndGet();\n         pendingActions.incrementAndGet();\n-        replicasProxy.performOn(shard, replicaRequest, primaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes,\n-            new ActionListener<>() {\n-                @Override\n-                public void onResponse(ReplicaResponse response) {\n-                    successfulShards.incrementAndGet();\n-                    try {\n-                        updateCheckPoints(shard, response::localCheckpoint, response::globalCheckpoint);\n-                    } finally {\n-                        decPendingAndFinishIfNeeded();\n-                    }\n+        PendingReplicationActions pendingReplicationActions = primary.getPendingReplicationActions();\n+        final ActionListener<ReplicaResponse> replicationListener = new ActionListener<>() {\n+            @Override\n+            public void onResponse(ReplicaResponse response) {\n+                successfulShards.incrementAndGet();\n+                try {\n+                    updateCheckPoints(shard, response::localCheckpoint, response::globalCheckpoint);\n+                } finally {\n+                    decPendingAndFinishIfNeeded();\n                 }\n+            }\n \n-                @Override\n-                public void onFailure(Exception replicaException) {\n-                    logger.trace(() -> new ParameterizedMessage(\n-                        \"[{}] failure while performing [{}] on replica {}, request [{}]\",\n-                        shard.shardId(), opType, shard, replicaRequest), replicaException);\n-                    // Only report \"critical\" exceptions - TODO: Reach out to the master node to get the latest shard state then report.\n-                    if (TransportActions.isShardNotAvailableException(replicaException) == false) {\n-                        RestStatus restStatus = ExceptionsHelper.status(replicaException);\n-                        shardReplicaFailures.add(new ReplicationResponse.ShardInfo.Failure(\n-                            shard.shardId(), shard.currentNodeId(), replicaException, restStatus, false));\n-                    }\n-                    String message = String.format(Locale.ROOT, \"failed to perform %s on replica %s\", opType, shard);\n-                    replicasProxy.failShardIfNeeded(shard, primaryTerm, message, replicaException,\n-                        ActionListener.wrap(r -> decPendingAndFinishIfNeeded(), ReplicationOperation.this::onNoLongerPrimary));\n+            @Override\n+            public void onFailure(Exception replicaException) {\n+                logger.trace(() -> new ParameterizedMessage(\n+                    \"[{}] failure while performing [{}] on replica {}, request [{}]\",\n+                    shard.shardId(), opType, shard, replicaRequest), replicaException);\n+                // Only report \"critical\" exceptions - TODO: Reach out to the master node to get the latest shard state then report.\n+                if (TransportActions.isShardNotAvailableException(replicaException) == false) {\n+                    RestStatus restStatus = ExceptionsHelper.status(replicaException);\n+                    shardReplicaFailures.add(new ReplicationResponse.ShardInfo.Failure(\n+                        shard.shardId(), shard.currentNodeId(), replicaException, restStatus, false));\n                 }\n+                String message = String.format(Locale.ROOT, \"failed to perform %s on replica %s\", opType, shard);\n+                replicasProxy.failShardIfNeeded(shard, primaryTerm, message, replicaException,\n+                    ActionListener.wrap(r -> decPendingAndFinishIfNeeded(), ReplicationOperation.this::onNoLongerPrimary));\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"[\" + replicaRequest + \"][\" + shard + \"]\";\n+            }\n+        };\n \n-                @Override\n-                public String toString() {\n-                    return \"[\" + replicaRequest + \"][\" + shard + \"]\";\n+        final RetryableAction<ReplicaResponse> replicationAction = new RetryableAction<>(logger, threadPool, TimeValue.timeValueMillis(50),\n+            replicaRequest.timeout(), replicationListener) {\n+\n+            private boolean addedToPending = false;\n+\n+            @Override\n+            public void tryAction(ActionListener<ReplicaResponse> listener) {\n+                replicasProxy.performOn(shard, replicaRequest, primaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes, listener);\n+            }\n+\n+            @Override\n+            public void onSchedulingRetry() {\n+                super.onSchedulingRetry();\n+                if (addedToPending == false) {\n+                    pendingReplicationActions.addPendingAction(shard.currentNodeId(), this);\n+                    addedToPending = true;\n                 }\n-            });\n+            }\n+\n+            @Override\n+            public void onFinished() {\n+                super.onFinished();\n+                pendingReplicationActions.removeReplicationAction(shard.currentNodeId(), this);\n+            }\n+\n+            @Override\n+            public boolean shouldRetry(Exception e) {\n+                // If the node has left the replication group, do not retry\n+                if (primary.getReplicationGroup().getReplicaNodeIds().contains(shard.currentNodeId()) == false) {", "originalCommit": "a4a23dfff6905814cd18ba209532cba634ec868e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e5dac25efe21782f957d83cd3d3c68a51539a565", "url": "https://github.com/elastic/elasticsearch/commit/e5dac25efe21782f957d83cd3d3c68a51539a565", "message": "Merge remote-tracking branch 'upstream/master' into retry_replication", "committedDate": "2020-04-24T18:13:01Z", "type": "commit"}, {"oid": "0ca3da2303558994104e8501086761693b46bd2b", "url": "https://github.com/elastic/elasticsearch/commit/0ca3da2303558994104e8501086761693b46bd2b", "message": "Merge remote-tracking branch 'upstream/master' into retry_replication", "committedDate": "2020-04-24T20:59:10Z", "type": "commit"}, {"oid": "2ccfa0c3735e9fed539c9dc102d8e6a6a657d87d", "url": "https://github.com/elastic/elasticsearch/commit/2ccfa0c3735e9fed539c9dc102d8e6a6a657d87d", "message": "Changes", "committedDate": "2020-04-24T22:06:53Z", "type": "commit"}, {"oid": "bccf4029a6dbfb19d655a575eb0bd07d14271fdc", "url": "https://github.com/elastic/elasticsearch/commit/bccf4029a6dbfb19d655a575eb0bd07d14271fdc", "message": "Changes", "committedDate": "2020-04-24T22:20:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgwNDA5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r415804091", "bodyText": "Perhaps we can use IndexShardClosedException here which tells us that a shard has gone away.", "author": "ywelsch", "createdAt": "2020-04-27T13:17:40Z", "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.action.UnavailableShardsException;\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.index.shard.IndexShardClosedException;\n+import org.elasticsearch.index.shard.ReplicationGroup;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PendingReplicationActions implements Consumer<ReplicationGroup>, Releasable {\n+\n+    private final Map<String, Set<RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+    private final ShardId shardId;\n+    private final ThreadPool threadPool;\n+\n+    public PendingReplicationActions(ShardId shardId, ThreadPool threadPool) {\n+        this.shardId = shardId;\n+        this.threadPool = threadPool;\n+    }\n+\n+    public void addPendingAction(String allocationId, RetryableAction<?> replicationAction) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.add(replicationAction);\n+            if (onGoingReplicationActions.containsKey(allocationId) == false) {\n+                replicationAction.cancel(new UnavailableShardsException(shardId,", "originalCommit": "bccf4029a6dbfb19d655a575eb0bd07d14271fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNzAwNg==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r416317006", "bodyText": "Do you want this for all the failures?", "author": "tbrooks8", "createdAt": "2020-04-28T04:26:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgwNDA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgwNjgwMw==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r415806803", "bodyText": "onGoingReplicationActions.keySet() is only eventually consistent (i.e. can race against addPendingAction).", "author": "ywelsch", "createdAt": "2020-04-27T13:21:12Z", "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.action.UnavailableShardsException;\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.index.shard.IndexShardClosedException;\n+import org.elasticsearch.index.shard.ReplicationGroup;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PendingReplicationActions implements Consumer<ReplicationGroup>, Releasable {\n+\n+    private final Map<String, Set<RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+    private final ShardId shardId;\n+    private final ThreadPool threadPool;\n+\n+    public PendingReplicationActions(ShardId shardId, ThreadPool threadPool) {\n+        this.shardId = shardId;\n+        this.threadPool = threadPool;\n+    }\n+\n+    public void addPendingAction(String allocationId, RetryableAction<?> replicationAction) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.add(replicationAction);\n+            if (onGoingReplicationActions.containsKey(allocationId) == false) {\n+                replicationAction.cancel(new UnavailableShardsException(shardId,\n+                    \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+            }\n+        } else {\n+            replicationAction.cancel(new UnavailableShardsException(shardId,\n+                \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+        }\n+    }\n+\n+    public void removeReplicationAction(String allocationId, RetryableAction<?> action) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.remove(action);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void accept(ReplicationGroup replicationGroup) {\n+        Set<String> trackedAllocationIds = replicationGroup.getTrackedAllocationIds();\n+\n+        for (String targetAllocationId : trackedAllocationIds) {\n+            onGoingReplicationActions.putIfAbsent(targetAllocationId, ConcurrentCollections.newConcurrentSet());\n+        }\n+        ArrayList<Set<RetryableAction<?>>> toCancel = new ArrayList<>();\n+        for (String allocationId : onGoingReplicationActions.keySet()) {", "originalCommit": "bccf4029a6dbfb19d655a575eb0bd07d14271fdc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgxMDQyNg==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r415810426", "bodyText": "This is only eventually consistent (and can race any of the other methods). It's not strictly a problem for the use case where we're using this, but I wonder if we should add a recheck method in this class that we call whenever we reschedule that makes sure that pendingReplicationActions has not been closed, or if we should properly serialize all access to the top-level keyset, e.g. using a read-write-lock.", "author": "ywelsch", "createdAt": "2020-04-27T13:25:59Z", "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.action.UnavailableShardsException;\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.index.shard.IndexShardClosedException;\n+import org.elasticsearch.index.shard.ReplicationGroup;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PendingReplicationActions implements Consumer<ReplicationGroup>, Releasable {\n+\n+    private final Map<String, Set<RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+    private final ShardId shardId;\n+    private final ThreadPool threadPool;\n+\n+    public PendingReplicationActions(ShardId shardId, ThreadPool threadPool) {\n+        this.shardId = shardId;\n+        this.threadPool = threadPool;\n+    }\n+\n+    public void addPendingAction(String allocationId, RetryableAction<?> replicationAction) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.add(replicationAction);\n+            if (onGoingReplicationActions.containsKey(allocationId) == false) {\n+                replicationAction.cancel(new UnavailableShardsException(shardId,\n+                    \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+            }\n+        } else {\n+            replicationAction.cancel(new UnavailableShardsException(shardId,\n+                \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+        }\n+    }\n+\n+    public void removeReplicationAction(String allocationId, RetryableAction<?> action) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.remove(action);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void accept(ReplicationGroup replicationGroup) {\n+        Set<String> trackedAllocationIds = replicationGroup.getTrackedAllocationIds();\n+\n+        for (String targetAllocationId : trackedAllocationIds) {\n+            onGoingReplicationActions.putIfAbsent(targetAllocationId, ConcurrentCollections.newConcurrentSet());\n+        }\n+        ArrayList<Set<RetryableAction<?>>> toCancel = new ArrayList<>();\n+        for (String allocationId : onGoingReplicationActions.keySet()) {\n+            if (trackedAllocationIds.contains(allocationId) == false) {\n+                toCancel.add(onGoingReplicationActions.remove(allocationId));\n+            }\n+        }\n+\n+        threadPool.executor(ThreadPool.Names.GENERIC).execute(() -> toCancel.stream()\n+            .flatMap(Collection::stream)\n+            .forEach(action -> action.cancel(new UnavailableShardsException(shardId, \"Replica left ReplicationGroup\"))));\n+    }\n+\n+\n+    @Override\n+    public void close() {\n+        ArrayList<Set<RetryableAction<?>>> toCancel = new ArrayList<>(onGoingReplicationActions.values());\n+        onGoingReplicationActions.clear();", "originalCommit": "bccf4029a6dbfb19d655a575eb0bd07d14271fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxODA0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r416318042", "bodyText": "I don't understand the concern here.\nOnly close and accept can write to the allocation_id->set map. And they are synchronized. addPendingAction does not write to the to that map. It only writes to the set. And it checks to ensure that the set is still part of the allocation_id->set map after writing. And close and accept only access the keyset after removing from allocation_id->set.", "author": "tbrooks8", "createdAt": "2020-04-28T04:29:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgxMDQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUxNzUwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r416517509", "bodyText": "ok, I missed the synchronized keywords", "author": "ywelsch", "createdAt": "2020-04-28T10:50:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgxMDQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgxMTAzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r415811035", "bodyText": "let's introduce a new setting for this", "author": "ywelsch", "createdAt": "2020-04-27T13:26:41Z", "path": "server/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java", "diffHunk": "@@ -174,52 +184,78 @@ private void performOnReplicas(final ReplicaRequest replicaRequest, final long g\n \n         for (final ShardRouting shard : replicationGroup.getReplicationTargets()) {\n             if (shard.isSameAllocation(primaryRouting) == false) {\n-                performOnReplica(shard, replicaRequest, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes);\n+                performOnReplica(shard, replicaRequest, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes, pendingReplicationActions);\n             }\n         }\n     }\n \n     private void performOnReplica(final ShardRouting shard, final ReplicaRequest replicaRequest,\n-                                  final long globalCheckpoint, final long maxSeqNoOfUpdatesOrDeletes) {\n+                                  final long globalCheckpoint, final long maxSeqNoOfUpdatesOrDeletes,\n+                                  final PendingReplicationActions pendingReplicationActions) {\n         if (logger.isTraceEnabled()) {\n             logger.trace(\"[{}] sending op [{}] to replica {} for request [{}]\", shard.shardId(), opType, shard, replicaRequest);\n         }\n-\n         totalShards.incrementAndGet();\n         pendingActions.incrementAndGet();\n-        replicasProxy.performOn(shard, replicaRequest, primaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes,\n-            new ActionListener<>() {\n-                @Override\n-                public void onResponse(ReplicaResponse response) {\n-                    successfulShards.incrementAndGet();\n-                    try {\n-                        updateCheckPoints(shard, response::localCheckpoint, response::globalCheckpoint);\n-                    } finally {\n-                        decPendingAndFinishIfNeeded();\n-                    }\n+        final ActionListener<ReplicaResponse> replicationListener = new ActionListener<>() {\n+            @Override\n+            public void onResponse(ReplicaResponse response) {\n+                successfulShards.incrementAndGet();\n+                try {\n+                    updateCheckPoints(shard, response::localCheckpoint, response::globalCheckpoint);\n+                } finally {\n+                    decPendingAndFinishIfNeeded();\n                 }\n+            }\n \n-                @Override\n-                public void onFailure(Exception replicaException) {\n-                    logger.trace(() -> new ParameterizedMessage(\n-                        \"[{}] failure while performing [{}] on replica {}, request [{}]\",\n-                        shard.shardId(), opType, shard, replicaRequest), replicaException);\n-                    // Only report \"critical\" exceptions - TODO: Reach out to the master node to get the latest shard state then report.\n-                    if (TransportActions.isShardNotAvailableException(replicaException) == false) {\n-                        RestStatus restStatus = ExceptionsHelper.status(replicaException);\n-                        shardReplicaFailures.add(new ReplicationResponse.ShardInfo.Failure(\n-                            shard.shardId(), shard.currentNodeId(), replicaException, restStatus, false));\n-                    }\n-                    String message = String.format(Locale.ROOT, \"failed to perform %s on replica %s\", opType, shard);\n-                    replicasProxy.failShardIfNeeded(shard, primaryTerm, message, replicaException,\n-                        ActionListener.wrap(r -> decPendingAndFinishIfNeeded(), ReplicationOperation.this::onNoLongerPrimary));\n+            @Override\n+            public void onFailure(Exception replicaException) {\n+                logger.trace(() -> new ParameterizedMessage(\n+                    \"[{}] failure while performing [{}] on replica {}, request [{}]\",\n+                    shard.shardId(), opType, shard, replicaRequest), replicaException);\n+                // Only report \"critical\" exceptions - TODO: Reach out to the master node to get the latest shard state then report.\n+                if (TransportActions.isShardNotAvailableException(replicaException) == false) {\n+                    RestStatus restStatus = ExceptionsHelper.status(replicaException);\n+                    shardReplicaFailures.add(new ReplicationResponse.ShardInfo.Failure(\n+                        shard.shardId(), shard.currentNodeId(), replicaException, restStatus, false));\n                 }\n+                String message = String.format(Locale.ROOT, \"failed to perform %s on replica %s\", opType, shard);\n+                replicasProxy.failShardIfNeeded(shard, primaryTerm, message, replicaException,\n+                    ActionListener.wrap(r -> decPendingAndFinishIfNeeded(), ReplicationOperation.this::onNoLongerPrimary));\n+            }\n \n-                @Override\n-                public String toString() {\n-                    return \"[\" + replicaRequest + \"][\" + shard + \"]\";\n-                }\n-            });\n+            @Override\n+            public String toString() {\n+                return \"[\" + replicaRequest + \"][\" + shard + \"]\";\n+            }\n+        };\n+\n+        final String allocationId = shard.allocationId().getId();\n+        final RetryableAction<ReplicaResponse> replicationAction = new RetryableAction<>(logger, threadPool, TimeValue.timeValueMillis(50),", "originalCommit": "bccf4029a6dbfb19d655a575eb0bd07d14271fdc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5a1b105099441560f2a5672e4438dee8fa32519c", "url": "https://github.com/elastic/elasticsearch/commit/5a1b105099441560f2a5672e4438dee8fa32519c", "message": "Changes", "committedDate": "2020-04-27T16:25:44Z", "type": "commit"}, {"oid": "0ef2378212ee513eddede7201b80e60cc44cdbf8", "url": "https://github.com/elastic/elasticsearch/commit/0ef2378212ee513eddede7201b80e60cc44cdbf8", "message": "Chnages", "committedDate": "2020-04-27T23:02:15Z", "type": "commit"}, {"oid": "06982e9caecbef7f0c063dca7328cac2acf9891f", "url": "https://github.com/elastic/elasticsearch/commit/06982e9caecbef7f0c063dca7328cac2acf9891f", "message": "Merge remote-tracking branch 'upstream/master' into retry_replication", "committedDate": "2020-04-28T01:50:35Z", "type": "commit"}, {"oid": "159c138024f854a6c2ae7278a8aea32bf51b08da", "url": "https://github.com/elastic/elasticsearch/commit/159c138024f854a6c2ae7278a8aea32bf51b08da", "message": "Changes", "committedDate": "2020-04-28T02:20:08Z", "type": "commit"}, {"oid": "7568718fe1dd671e4d8cc4c07e7c86f1464ccd93", "url": "https://github.com/elastic/elasticsearch/commit/7568718fe1dd671e4d8cc4c07e7c86f1464ccd93", "message": "Changes", "committedDate": "2020-04-28T04:32:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUwOTc4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r416509783", "bodyText": "Let's call onFinished before the finalListener (in all cases here).", "author": "ywelsch", "createdAt": "2020-04-28T10:37:07Z", "path": "server/src/main/java/org/elasticsearch/action/support/RetryableAction.java", "diffHunk": "@@ -128,6 +132,7 @@ private RetryingListener(long delayMillisBound, ArrayDeque<Exception> caughtExce\n         public void onResponse(Response response) {\n             if (isDone.compareAndSet(false, true)) {\n                 finalListener.onResponse(response);\n+                onFinished();", "originalCommit": "7568718fe1dd671e4d8cc4c07e7c86f1464ccd93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUxODYyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r416518629", "bodyText": "can you add the message here that the primary shard closed (in contrast to the replica closing)?", "author": "ywelsch", "createdAt": "2020-04-28T10:52:46Z", "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.index.shard.IndexShardClosedException;\n+import org.elasticsearch.index.shard.ReplicationGroup;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PendingReplicationActions implements Consumer<ReplicationGroup>, Releasable {\n+\n+    private final Map<String, Set<RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+    private final ShardId shardId;\n+    private final ThreadPool threadPool;\n+\n+    public PendingReplicationActions(ShardId shardId, ThreadPool threadPool) {\n+        this.shardId = shardId;\n+        this.threadPool = threadPool;\n+    }\n+\n+    public void addPendingAction(String allocationId, RetryableAction<?> replicationAction) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.add(replicationAction);\n+            if (onGoingReplicationActions.containsKey(allocationId) == false) {\n+                replicationAction.cancel(new IndexShardClosedException(shardId,\n+                    \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+            }\n+        } else {\n+            replicationAction.cancel(new IndexShardClosedException(shardId,\n+                \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+        }\n+    }\n+\n+    public void removeReplicationAction(String allocationId, RetryableAction<?> action) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.remove(action);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void accept(ReplicationGroup replicationGroup) {\n+        acceptNewTrackedAllocationIds(replicationGroup.getTrackedAllocationIds());\n+    }\n+\n+    // Visible for testing\n+    synchronized void acceptNewTrackedAllocationIds(Set<String> trackedAllocationIds) {\n+        for (String targetAllocationId : trackedAllocationIds) {\n+            onGoingReplicationActions.putIfAbsent(targetAllocationId, ConcurrentCollections.newConcurrentSet());\n+        }\n+        ArrayList<Set<RetryableAction<?>>> toCancel = new ArrayList<>();\n+        for (String allocationId : onGoingReplicationActions.keySet()) {\n+            if (trackedAllocationIds.contains(allocationId) == false) {\n+                toCancel.add(onGoingReplicationActions.remove(allocationId));\n+            }\n+        }\n+\n+        threadPool.executor(ThreadPool.Names.GENERIC).execute(() -> toCancel.stream()\n+            .flatMap(Collection::stream)\n+            .forEach(action -> action.cancel(new IndexShardClosedException(shardId, \"Replica left ReplicationGroup\"))));\n+    }\n+\n+\n+    @Override\n+    public synchronized void close() {\n+        ArrayList<Set<RetryableAction<?>>> toCancel = new ArrayList<>(onGoingReplicationActions.values());\n+        onGoingReplicationActions.clear();\n+\n+        threadPool.executor(ThreadPool.Names.GENERIC).execute(() -> toCancel.stream()\n+            .flatMap(Collection::stream)\n+            .forEach(action -> action.cancel(new IndexShardClosedException(shardId))));", "originalCommit": "7568718fe1dd671e4d8cc4c07e7c86f1464ccd93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "decb9eee834c19a93355fc2a57bfbe9175f6f4b0", "url": "https://github.com/elastic/elasticsearch/commit/decb9eee834c19a93355fc2a57bfbe9175f6f4b0", "message": "Merge remote-tracking branch 'upstream/master' into retry_replication", "committedDate": "2020-04-28T20:34:00Z", "type": "commit"}, {"oid": "6efa3ffc1825840a70b2962249feb2daf99dde1b", "url": "https://github.com/elastic/elasticsearch/commit/6efa3ffc1825840a70b2962249feb2daf99dde1b", "message": "Changes", "committedDate": "2020-04-28T20:38:31Z", "type": "commit"}, {"oid": "83e57d1ae6059868b61ad0fc5fd4852c68d6d0c9", "url": "https://github.com/elastic/elasticsearch/commit/83e57d1ae6059868b61ad0fc5fd4852c68d6d0c9", "message": "Mute to ensure all tests are run", "committedDate": "2020-04-28T21:33:56Z", "type": "commit"}, {"oid": "7f33e2e17433707a843ce1f7d441e0f5b871465e", "url": "https://github.com/elastic/elasticsearch/commit/7f33e2e17433707a843ce1f7d441e0f5b871465e", "message": "Changes", "committedDate": "2020-04-29T15:19:21Z", "type": "commit"}, {"oid": "44b607aa4db1f704d774369275c5337cc28ba2ba", "url": "https://github.com/elastic/elasticsearch/commit/44b607aa4db1f704d774369275c5337cc28ba2ba", "message": "Add", "committedDate": "2020-04-29T15:38:07Z", "type": "commit"}, {"oid": "f9ca9d1b5452a2687fd3d5781a40953d178d5754", "url": "https://github.com/elastic/elasticsearch/commit/f9ca9d1b5452a2687fd3d5781a40953d178d5754", "message": "double check", "committedDate": "2020-04-29T15:40:54Z", "type": "commit"}, {"oid": "d5876f52425f063313237786b4e53b3ebd57837a", "url": "https://github.com/elastic/elasticsearch/commit/d5876f52425f063313237786b4e53b3ebd57837a", "message": "Merge remote-tracking branch 'upstream/master' into retry_replication", "committedDate": "2020-04-29T16:12:46Z", "type": "commit"}, {"oid": "2f75aea491c1c3d1e3dd939563a0138118e82395", "url": "https://github.com/elastic/elasticsearch/commit/2f75aea491c1c3d1e3dd939563a0138118e82395", "message": "npe", "committedDate": "2020-04-29T16:16:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ0Nzk1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r417447959", "bodyText": "Test failure, should probably be using the random instance here", "author": "ywelsch", "createdAt": "2020-04-29T16:27:18Z", "path": "test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java", "diffHunk": "@@ -505,6 +508,11 @@ private static Settings getRandomNodeSettings(long seed) {\n             builder.put(ScriptService.SCRIPT_CACHE_EXPIRE_SETTING.getConcreteSettingForNamespace(ctx).getKey(),\n                         timeValueMillis(RandomNumbers.randomIntBetween(random, 750, 10000000)).getStringRep());\n         }\n+        if (random.nextBoolean()) {\n+            builder.put(TransportReplicationAction.REPLICATION_RETRY_TIMEOUT.getKey(), timeValueSeconds(randomInt(60)));", "originalCommit": "44b607aa4db1f704d774369275c5337cc28ba2ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "11d35e42a37be128ccee94bc7641d2288a6d42e1", "url": "https://github.com/elastic/elasticsearch/commit/11d35e42a37be128ccee94bc7641d2288a6d42e1", "message": "Use correct random", "committedDate": "2020-04-29T16:43:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1NTc2MA==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r417655760", "bodyText": "Maybe share this logic with close?", "author": "dnhatn", "createdAt": "2020-04-29T22:44:15Z", "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.index.shard.IndexShardClosedException;\n+import org.elasticsearch.index.shard.ReplicationGroup;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PendingReplicationActions implements Consumer<ReplicationGroup>, Releasable {\n+\n+    private final Map<String, Set<RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+    private final ShardId shardId;\n+    private final ThreadPool threadPool;\n+    private volatile long replicationGroupVersion = -1;\n+\n+    public PendingReplicationActions(ShardId shardId, ThreadPool threadPool) {\n+        this.shardId = shardId;\n+        this.threadPool = threadPool;\n+    }\n+\n+    public void addPendingAction(String allocationId, RetryableAction<?> replicationAction) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.add(replicationAction);\n+            if (onGoingReplicationActions.containsKey(allocationId) == false) {\n+                replicationAction.cancel(new IndexShardClosedException(shardId,\n+                    \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+            }\n+        } else {\n+            replicationAction.cancel(new IndexShardClosedException(shardId,\n+                \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+        }\n+    }\n+\n+    public void removeReplicationAction(String allocationId, RetryableAction<?> action) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.remove(action);\n+        }\n+    }\n+\n+    @Override\n+    public void accept(ReplicationGroup replicationGroup) {\n+        if (replicationGroup.getVersion() - replicationGroupVersion > 0) {\n+            synchronized (this) {\n+                if (replicationGroup.getVersion() - replicationGroupVersion > 0) {\n+                    acceptNewTrackedAllocationIds(replicationGroup.getTrackedAllocationIds());\n+                    replicationGroupVersion = replicationGroup.getVersion();\n+                }\n+            }\n+        }\n+    }\n+\n+    // Visible for testing\n+    synchronized void acceptNewTrackedAllocationIds(Set<String> trackedAllocationIds) {\n+        for (String targetAllocationId : trackedAllocationIds) {\n+            onGoingReplicationActions.putIfAbsent(targetAllocationId, ConcurrentCollections.newConcurrentSet());\n+        }\n+        ArrayList<Set<RetryableAction<?>>> toCancel = new ArrayList<>();\n+        for (String allocationId : onGoingReplicationActions.keySet()) {\n+            if (trackedAllocationIds.contains(allocationId) == false) {\n+                toCancel.add(onGoingReplicationActions.remove(allocationId));\n+            }\n+        }\n+\n+        threadPool.executor(ThreadPool.Names.GENERIC).execute(() -> toCancel.stream()", "originalCommit": "11d35e42a37be128ccee94bc7641d2288a6d42e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1NTkyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r417655925", "bodyText": "maybe just replicationGroup.getVersion() > replicationGroupVersion?", "author": "dnhatn", "createdAt": "2020-04-29T22:44:39Z", "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.index.shard.IndexShardClosedException;\n+import org.elasticsearch.index.shard.ReplicationGroup;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PendingReplicationActions implements Consumer<ReplicationGroup>, Releasable {\n+\n+    private final Map<String, Set<RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+    private final ShardId shardId;\n+    private final ThreadPool threadPool;\n+    private volatile long replicationGroupVersion = -1;\n+\n+    public PendingReplicationActions(ShardId shardId, ThreadPool threadPool) {\n+        this.shardId = shardId;\n+        this.threadPool = threadPool;\n+    }\n+\n+    public void addPendingAction(String allocationId, RetryableAction<?> replicationAction) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.add(replicationAction);\n+            if (onGoingReplicationActions.containsKey(allocationId) == false) {\n+                replicationAction.cancel(new IndexShardClosedException(shardId,\n+                    \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+            }\n+        } else {\n+            replicationAction.cancel(new IndexShardClosedException(shardId,\n+                \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+        }\n+    }\n+\n+    public void removeReplicationAction(String allocationId, RetryableAction<?> action) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.remove(action);\n+        }\n+    }\n+\n+    @Override\n+    public void accept(ReplicationGroup replicationGroup) {\n+        if (replicationGroup.getVersion() - replicationGroupVersion > 0) {", "originalCommit": "11d35e42a37be128ccee94bc7641d2288a6d42e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1NjA1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r417656053", "bodyText": "maybe just replicationGroup.getVersion() > replicationGroupVersion ?", "author": "dnhatn", "createdAt": "2020-04-29T22:45:00Z", "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.index.shard.IndexShardClosedException;\n+import org.elasticsearch.index.shard.ReplicationGroup;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PendingReplicationActions implements Consumer<ReplicationGroup>, Releasable {\n+\n+    private final Map<String, Set<RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+    private final ShardId shardId;\n+    private final ThreadPool threadPool;\n+    private volatile long replicationGroupVersion = -1;\n+\n+    public PendingReplicationActions(ShardId shardId, ThreadPool threadPool) {\n+        this.shardId = shardId;\n+        this.threadPool = threadPool;\n+    }\n+\n+    public void addPendingAction(String allocationId, RetryableAction<?> replicationAction) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.add(replicationAction);\n+            if (onGoingReplicationActions.containsKey(allocationId) == false) {\n+                replicationAction.cancel(new IndexShardClosedException(shardId,\n+                    \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+            }\n+        } else {\n+            replicationAction.cancel(new IndexShardClosedException(shardId,\n+                \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+        }\n+    }\n+\n+    public void removeReplicationAction(String allocationId, RetryableAction<?> action) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.remove(action);\n+        }\n+    }\n+\n+    @Override\n+    public void accept(ReplicationGroup replicationGroup) {\n+        if (replicationGroup.getVersion() - replicationGroupVersion > 0) {\n+            synchronized (this) {\n+                if (replicationGroup.getVersion() - replicationGroupVersion > 0) {", "originalCommit": "11d35e42a37be128ccee94bc7641d2288a6d42e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c77b873ffb417f0257f5dd80dce969eb70e0329c", "url": "https://github.com/elastic/elasticsearch/commit/c77b873ffb417f0257f5dd80dce969eb70e0329c", "message": "Chnage", "committedDate": "2020-04-30T15:19:14Z", "type": "commit"}]}